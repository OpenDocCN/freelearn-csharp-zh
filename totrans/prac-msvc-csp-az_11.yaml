- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Logging and Monitoring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录和监控
- en: With a microservices solution, many services can interact with each other. When
    one service fails, the complete solution should not break. In the previous chapter,
    we covered different kinds of tests to find issues early. Here, we’ll look at
    finding issues in production as early as possible – probably before a user sees
    a problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务解决方案中，许多服务可以相互交互。当一个服务失败时，整个解决方案不应该崩溃。在前一章中，我们介绍了不同类型的测试以尽早发现问题。在这里，我们将探讨尽可能早地在生产中查找问题——可能是在用户看到问题之前。
- en: To find issues when the application is running and see how the application runs
    successfully, the solution needs to be enhanced to offer telemetry data. With
    **logging**, we see what’s going on; based on different log levels, we can differentiate
    between informational logs and errors. With **metrics** data, we can monitor counters,
    such as memory and CPU consumption, and the number of HTTP requests. We will also
    write custom counters to see the number of games played and the number of game
    moves needed for a win. **Distributed tracing** gives information on how services
    interact. Who is making calls to this service? Where does this error originate
    from?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在应用程序运行时发现问题和查看应用程序如何成功运行，解决方案需要增强以提供遥测数据。通过**日志记录**，我们可以看到正在发生什么；根据不同的日志级别，我们可以区分信息日志和错误。通过**指标**数据，我们可以监控计数器，例如内存和CPU消耗，以及HTTP请求的数量。我们还将编写自定义计数器以查看游戏玩了多少次以及需要多少次游戏移动才能获胜。**分布式跟踪**提供了关于服务如何交互的信息。谁在调用此服务？这个错误是从哪里开始的？
- en: '**OpenTelemetry** is an industry standard – a collection of APIs that allows
    different languages and tools to instrument, generate, collect, and export telemetry
    data. The .NET APIs for logging, metrics, and distributed tracing support OpenTelemetry,
    and this is what this chapter is about. We’ll use **Prometheus** and **Grafana**,
    which have great graphical views for an on-premises solution, as well as **Azure
    Application Insights** for the solution to run with the Microsoft Azure cloud.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenTelemetry**是一个行业标准 – 一组API，允许不同的语言和工具进行工具化、生成、收集和导出遥测数据。支持OpenTelemetry的.NET
    API用于日志记录、指标和分布式跟踪，这正是本章的内容。我们将使用**Prometheus**和**Grafana**，它们为本地解决方案提供了出色的图形视图，以及**Azure
    Application Insights**，以便解决方案可以在Microsoft Azure云中运行。'
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Add log messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加日志消息
- en: Use and create metrics data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和创建指标数据
- en: Use distributed tracing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分布式跟踪
- en: Monitor with Azure Application Insights
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Azure Application Insights进行监控
- en: Monitor with Prometheus and Grafana
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prometheus和Grafana进行监控
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: With this chapter, as with the previous chapters, you need an Azure subscription
    and Docker Desktop. To create all the Azure resources for the solution, you can
    use the Azure Developer CLI – `azd up` creates all the resources. Check the README
    file of this chapter in the repository for details.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，您需要一个Azure订阅和Docker Desktop。要创建解决方案的所有Azure资源，您可以使用Azure开发者CLI – `azd
    up`创建所有资源。请查看存储库中本章的README文件以获取详细信息。
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub存储库中找到：[https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/)。
- en: In the `ch11` folder, you’ll see these projects with the result of this chapter.
    This chapter adds the Prometheus launch profile with the `launchsettings.json`
    file of the `AppHost` project. This also sets the `ASPNETCORE_ENVIRONMENT` and
    `DOTNETCORE_ENVIRONMENT` environment variables to `Prometheus`. The default launch
    profile uses services running with Microsoft Azure. The Prometheus launch profile
    is used to run Prometheus and Grafana, which can be used easily in an on-premises
    environment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch11`文件夹中，您将看到本章的项目结果。本章在`AppHost`项目的`launchsettings.json`文件中添加了Prometheus启动配置文件。这也将`ASPNETCORE_ENVIRONMENT`和`DOTNETCORE_ENVIRONMENT`环境变量设置为`Prometheus`。默认启动配置文件使用运行在Microsoft
    Azure上的服务。Prometheus启动配置文件用于运行Prometheus和Grafana，这些工具可以在本地环境中轻松使用。
- en: 'These are the important projects for this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章的重要项目：
- en: '`Codebreaker.AppHost` – The .NET Aspire host project.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.AppHost` – .NET Aspire宿主项目。'
- en: '`Codebreaker.ServiceDefaults` – Common service configuration. This project
    is enhanced with service configurations for monitoring.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.ServiceDefaults` – 通用服务配置。该项目增加了用于监控的服务配置。'
- en: '`Codebreaker.GamesAPI` – The service project is enhanced with logging, metrics,
    and distributed tracing.*   `Codebreaker.Bot` – This project has monitoring information
    included and will be used to play games that can be monitored.*   `grafana` folder
    contains configuration files that are used within the Grafana Docker container.*   The
    `prometheus` folder contains a configuration file that is used by the Prometheus
    Docker container.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Codebreaker.GamesAPI` – 服务项目通过日志记录、指标和分布式跟踪得到增强.*   `Codebreaker.Bot` – 此项目包含监控信息，并将用于玩可监控的游戏.*   `grafana`文件夹包含在Grafana
    Docker容器内使用的配置文件.*   `prometheus`文件夹包含由Prometheus Docker容器使用的配置文件。'
- en: You can start with the source code from the previous chapter to integrate the
    features from this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从上一章的源代码开始，以集成本章的功能。
- en: Adding log messages
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加日志消息
- en: 'To see what’s going on successfully or not when running the solution, we add
    log messages. The important parts of understanding the concept of logging are
    the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行解决方案时成功或失败地查看正在发生的事情，我们添加日志消息。理解日志概念的重要部分如下：
- en: '**The source**: Who writes log information – what is the category name?'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：谁写入日志信息——类别名称是什么？'
- en: '**The log provider**: Where is log information written to?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志提供程序**：日志信息被写入到哪里？'
- en: '**The log level**: What is the level of the log message? Is it just information
    or an error?'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志级别**：日志消息的级别是什么？仅仅是信息还是错误？'
- en: '**Filtering**: What information is logged?'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：记录了哪些信息？'
- en: The source is defined using the `ILogger<T>` generic interface. With this generic
    interface, the category name is taken from the class name of the generic parameter
    type. In case you use the `ILoggerFactory` interface instead of `ILogger<T>`,
    the category name is passed by invoking the `CreateLogger` method. Examples of
    category names used by .NET are `Microsoft.EntityFrameworkCore.Database.Command`,
    `System.Net.Http.HttpClient`, and `Microsoft.Hosting.Lifetime`. Having hierarchical
    names helps with common configuration settings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 源是通过使用`ILogger<T>`泛型接口定义的。使用这个泛型接口，类别名称是从泛型参数类型的类名中获取的。如果你使用`ILoggerFactory`接口而不是`ILogger<T>`，类别名称是通过调用`CreateLogger`方法传递的。.NET使用的类别名称示例包括`Microsoft.EntityFrameworkCore.Database.Command`、`System.Net.Http.HttpClient`和`Microsoft.Hosting.Lifetime`。具有层次结构的名称有助于配置常见的设置。
- en: 'To define where log messages are written, log providers are configured with
    the startup of the application. The `CreateBuilder` method of the `WebApplication`
    class configures multiple log providers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义日志消息的写入位置，日志提供程序在应用程序启动时进行配置。`WebApplication`类的`CreateBuilder`方法配置了多个日志提供程序：
- en: '`ConsoleLogProvider` to write log messages to the console'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConsoleLogProvider`用于将日志消息写入控制台'
- en: '`DebugLoggerProvider`, which only writes messages to the debug output window
    when a debugger is attached'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugLoggerProvider`，仅在附加调试器时将消息写入调试输出窗口'
- en: '`EventSourceLoggerProvider`, which writes log messages using **Event Tracing
    for Windows** (**ETW**) on Windows and the **Linux Trace Toolkit: next generation**
    (**LTTng**) on Linux'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSourceLoggerProvider`，该提供程序在Windows上使用**Windows事件跟踪**（**ETW**）和在Linux上使用**Linux跟踪工具包：下一代**（**LTTng**）来写入日志消息'
- en: With the AOT ASP.NET Core application that was created in [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    the `CreateSlimBuilder` method was used. `CreateSlimBuilder` only configures the
    console provider; other providers need to be added manually.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B21217_05.xhtml#_idTextAnchor110)中创建的AOT ASP.NET Core应用程序中，使用了`CreateSlimBuilder`方法。`CreateSlimBuilder`仅配置控制台提供程序；其他提供程序需要手动添加。
- en: The `ILogger` interface defines a `Log` method with a `LogLevel` enum value
    containing `Trace` (0) – `Debug` – `Information` – `Warning` – `Error` – `Critical`
    (5) – `None` (6) values. With this, we can configure to only write `Warning`-level
    messages and higher or write every message specifying the `Trace` level and higher).
    This configuration can be different based on the provider and the source.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILogger`接口定义了一个带有`LogLevel`枚举值的`Log`方法，包含`Trace`（0）- `Debug` - `Information`
    - `Warning` - `Error` - `Critical`（5）- `None`（6）值。通过这个，我们可以配置只写入`Warning`级别或更高级别的消息，或者写入指定`Trace`级别或更高级别的每条消息。此配置可能因提供程序和源而异。'
- en: 'The following snippet shows a customized configuration with a JSON configuration
    file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了使用JSON配置文件的定制配置：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Logging` section with the configuration is accessed within the implementation
    of the `CreateBuilder` method at startup. Here, we can customize the logging configuration.
    With this configuration file, the default log level is specified with the `LogLevel:Default`
    key. Here, logging is set to `Information`, thus `Debug` and `Trace` log messages
    are not written. This default configuration is changed with log categories that
    start with `Microsoft.AspNetCore`. With this category, only warnings, errors,
    and critical messages are written. With the `LogLevel` key as a subkey to `Logging`,
    all log providers are configured, unless the configuration for the provider is
    overwritten. Here, this is done for the `EventSource` log provider. The `Default`
    log level is set to `Warning`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，在 `CreateBuilder` 方法的实现中访问带有配置的 `Logging` 部分。在这里，我们可以自定义日志配置。使用此配置文件，默认日志级别通过
    `LogLevel:Default` 键指定。在这里，日志设置为 `Information`，因此 `Debug` 和 `Trace` 日志消息不会被写入。此默认配置通过以
    `Microsoft.AspNetCore` 开头的日志类别进行更改。使用此类别，只写入警告、错误和关键消息。作为 `Logging` 的子键的 `LogLevel`
    键配置了所有日志提供程序，除非覆盖了提供程序的配置。在这里，这是为 `EventSource` 日志提供程序执行的。默认日志级别设置为 `Warning`。
- en: Next, let’s add logging to the games API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为游戏API添加日志记录功能。
- en: Creating strongly typed log messages
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建强类型日志消息
- en: 'The games API service makes use of `ILogger` extension methods such as `LogError`
    and `LogInformation`, when writing log messages, we use custom log methods as
    shown next. Let’s add a `Log` class to define all log messages with the games
    API project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏API服务在编写日志消息时使用了 `ILogger` 扩展方法，如 `LogError` 和 `LogInformation`。接下来，我们将展示如何使用自定义日志方法。让我们添加一个
    `Log` 类来定义所有与游戏API项目相关的日志消息：
- en: Codebreaker.GameAPIs/Infrastructure/Log.cs
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/Log.cs
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `LoggerMessage` attribute is used by a source generator. For methods that
    are annotated with this attribute, the logger source generator creates an implementation.
    The method needs to be `void` with an `ILogger` parameter. The method can also
    be defined as an extension method, as is the case here. Parameter names need to
    match the expressions used within the `Message` property, such as `gameId`, `move`,
    and `result`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggerMessage` 属性被源生成器使用。对于带有此属性的注解方法，日志源生成器会创建一个实现。该方法需要是 `void` 类型并带有 `ILogger`
    参数。该方法也可以定义为扩展方法，就像这里的情况一样。参数名称需要与 `Message` 属性内部使用的表达式匹配，例如 `gameId`、`move` 和
    `result`。'
- en: 'Before the log message is written, the generated logging code checks if the
    log level is enabled. Sometimes, it can be useful to create custom methods that
    make use of generated methods, as shown in the next code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入日志消息之前，生成的日志代码会检查日志级别是否启用。有时，创建使用生成方法的自定义方法可能很有用，如下面的代码片段所示：
- en: Codebreaker.GameAPIs/Infrastructure/Log.cs
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/Log.cs
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `GameEnded` method checks the `Game` object to see if it’s a victory or
    not, and depending on this, either the `GameWon` or the `GameLost` logging method
    is invoked. Before using any CPU and memory for this process (logging could also
    need to enumerate collections to produce useful log messages), it’s good practice
    to verify if this should be done at all – if the log level is enabled. This is
    checked using the `logger.IsEnabled` method and passing the log level.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameEnded` 方法检查 `Game` 对象是否为胜利，并据此调用 `GameWon` 或 `GameLost` 日志方法。在使用任何CPU和内存进行此过程（日志也可能需要枚举集合以生成有用的日志消息）之前，验证是否应该执行此操作——即检查日志级别是否启用。这是通过使用
    `logger.IsEnabled` 方法并传递日志级别来检查的。'
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Writing logs, don’t use interpolated strings such as `logger.LogInformation($"log
    message {expression}");`. Instead, use `logger.LogInformation("log message {expression}",
    expression);`. The second form supports structured logging. The message string
    passed is a template. With this template, the content within the curly braces
    can be used to create an index, and (depending on the log collector) you can query
    for all log entries containing this term. Also, using the formatted string allocates
    a new string that needs to be garbage-collected. With the second version, there’s
    just one string for all log entries written.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 写入日志时，不要使用插值字符串，例如 `logger.LogInformation($"log message {expression}");`。相反，使用
    `logger.LogInformation("log message {expression}", expression);`。第二种形式支持结构化日志。传递的消息字符串是一个模板。使用这个模板，大括号内的内容可以用来创建索引，并且（取决于日志收集器）你可以查询包含此术语的所有日志条目。此外，使用格式化字符串会分配一个新的字符串，该字符串需要被垃圾回收。在第二种版本中，所有写入的日志条目只有一个字符串。
- en: Check the GitHub repo for more methods defined with the `Log` class. Next, let’s
    use this class to write log messages.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检查GitHub仓库以获取使用`Log`类定义的更多方法。接下来，让我们使用这个类来编写日志消息。
- en: Writing log messages
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写日志消息
- en: 'Log messages are mainly written from the `GamesService` class, thus we need
    to change the constructor:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息主要是由`GamesService`类编写的，因此我们需要更改构造函数：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the updated constructor, the generic version of the `ILogger` interface
    is injected. The type parameter specifies the category name for logging.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的构造函数，注入了`ILogger`接口的泛型版本。类型参数指定了日志的类别名称。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, the `GamesService` class is enhanced with logging, distributed
    tracing, and metrics functionality. That’s why you see all these changes in the
    final code in the source code repository.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，`GamesService`类通过日志、分布式跟踪和度量功能进行了增强。这就是为什么你在源代码仓库的最终代码中看到所有这些更改的原因。
- en: 'The `StartGameAsync` method is enhanced with logging:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartGameAsync`方法通过日志进行了增强：'
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `GamesFactory` class can throw an exception of type `CodebreakerException`.
    This is caught to write a log message and to re-throw the exception. The exception
    will be dealt with by the endpoint implementation to finally return a specific
    HTTP result. Here, we just want to log this information and re-throw the exception.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesFactory`类可以抛出`CodebreakerException`类型的异常。这个异常被捕获以写入日志消息并重新抛出异常。异常将由端点实现处理，最终返回特定的HTTP结果。在这里，我们只想记录这个信息并重新抛出异常。'
- en: For generic exceptions, a strongly typed `Error` method is defined by the `Log`
    class and used to write this message. The `InvalidGameType` method writes a log
    message with the `Warning` level. Here, the client probably sent an invalid (or
    currently not accepted) game type. While this shouldn’t happen, it’s usually an
    issue with the client, and we don’t have to deal with it on the service side.
    It’s just good to know about such clients. The `Error` method writes a log message
    with the `Error` level. It could be useful to check for more specific error types
    and create additional messages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于泛型异常，`Log`类定义了一个强类型的`Error`方法，并用于写入此消息。`InvalidGameType`方法以`Warning`级别写入日志消息。在这里，客户端可能发送了无效的（或目前不被接受的）游戏类型。虽然这种情况不应该发生，但通常是由于客户端的问题，我们不需要在服务端处理它。了解这样的客户端是有好处的。`Error`方法以`Error`级别写入日志消息。检查更具体的错误类型并创建额外的消息可能是有用的。
- en: On a successful invocation, a log message is written by invoking the `GameStarted`
    method of the `Log` class, which has the `Informational` level set.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功调用时，通过调用`Log`类的`GameStarted`方法写入日志消息，该方法的`Informational`级别被设置。
- en: Let’s check the log messages with .NET Aspire next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用.NET Aspire检查日志消息。
- en: Viewing logs with the .NET Aspire dashboard
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Aspire仪表板查看日志
- en: 'The .NET Aspire-generated `Codebreaker.ServiceDefaults` library contains logging
    configuration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Aspire生成的`Codebreaker.ServiceDefaults`库包含日志配置：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `AddOpenTelemetry` method adds the `OpenTelemetry` logger to the logger
    factory. This provider is configured to include formatted messages and to include
    logging scopes. Setting `IncludeFormattedMessage` to `true` specifies that if
    log templates are used (which we did), formatted messages are also included when
    creating log records for OpenTelemetry. By default, this would not be the case.
    Setting `IncludeScopes` to `true` specifies to include logging scope IDs with
    logs, which allows us to see a hierarchy of log messages when using the `BeginScope`
    method of the `ILogger` interface to define scopes. The `ConfigureOpenTelemetry`
    method is invoked from within the `AddServiceDefaults` method, which in turn is
    invoked both from the games API and the bot service.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOpenTelemetry`方法将`OpenTelemetry`日志记录器添加到日志工厂。此提供程序配置为包括格式化消息和包括日志作用域。将`IncludeFormattedMessage`设置为`true`指定，如果使用日志模板（我们确实使用了），则在为OpenTelemetry创建日志记录时也会包括格式化消息。默认情况下，情况并非如此。将`IncludeScopes`设置为`true`指定在日志中包括日志作用域ID，这允许我们使用`ILogger`接口的`BeginScope`方法定义作用域时看到日志消息的层次结构。`ConfigureOpenTelemetry`方法在`AddServiceDefaults`方法内部调用，而`AddServiceDefaults`方法又从游戏API和机器人服务中调用。'
- en: 'With this logging configuration in place, it’s time to start the services locally,
    running the .NET Aspire dashboard. Start the application and solution and let
    the bot service play some games. Then, open the .NET Aspire dashboard and select
    **Console Logs** within the **Monitoring** category. Here, you’ll see log outputs
    for games that have been started, as shown in *Figure 11**.1*. You can also see
    log outputs from **Entity Framework Core** (**EF Core**), including queries done
    and ASP.NET Core logs – unless the level is set to not show informational messages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此日志配置就绪后，是时候在本地启动服务，运行 .NET Aspire 仪表板。启动应用程序和解决方案，让机器人服务玩一些游戏。然后，打开 .NET Aspire
    仪表板，在 **监控** 类别下选择 **控制台日志**。在这里，你会看到已启动游戏的日志输出，如图 *图 11.1* 所示。你还可以看到来自 **Entity
    Framework Core** （**EF Core**）的日志输出，包括执行的查询和 ASP.NET Core 日志 - 除非将级别设置为不显示信息性消息：
- en: '![Figure 11.1 – Logs with the .NET Aspire dashboard](img/B21217_11_01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 带有 .NET Aspire 仪表板的日志](img/B21217_11_01.jpg)'
- en: Figure 11.1 – Logs with the .NET Aspire dashboard
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 带有 .NET Aspire 仪表板的日志
- en: 'Also, open the logs from the bot service. The bot service writes log output
    with every move set after the result is received to show how successful the move
    was and how many remaining options are available, as shown in *Figure 11**.2*:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，打开来自机器人服务的日志。机器人服务在收到结果后，会记录每次移动集合的日志输出，以显示移动的成功程度和剩余选项的数量，如图 *图 11.2* 所示：
- en: '![Figure 11.2 – Logs from the bot service](img/B21217_11_02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 机器人服务的日志](img/B21217_11_02.jpg)'
- en: Figure 11.2 – Logs from the bot service
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 机器人服务的日志
- en: 'When you open `GameId` placeholder we’ve written with the `GameStarted` event,
    as shown in *Figure 11**.3*. Other data, such as the `RequestPath` placeholder,
    is coming from .NET activities, which we’ll look at later in the *Using distributed*
    *tracing* section:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开我们用 `GameStarted` 事件编写的 `GameId` 占位符时，如图 *图 11.3* 所示。其他数据，如 `RequestPath`
    占位符，来自 .NET 活动，我们将在 *使用分布式* *跟踪* 部分稍后查看：
- en: '![Figure 11.3 – Structured logging](img/B21217_11_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 带有 .NET Aspire 仪表板的日志](img/B21217_11_03.jpg)'
- en: Figure 11.3 – Structured logging
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 结构化日志
- en: 'With the `GameId`, set the game identifier as the value, and read all the logs
    related to this game. Here, you easily can follow a single gameplay with the moves
    set, as shown in *Figure 11**.4*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GameId`，将游戏标识符设置为值，并读取与此游戏相关的所有日志。在这里，你可以轻松地跟踪单个游戏玩法，如图 *图 11.4* 所示：
- en: '![Figure 11.4 – Structured logging with a GameId filter](img/B21217_11_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 带有 GameId 过滤器的结构化日志](img/B21217_11_04.jpg)'
- en: Figure 11.4 – Structured logging with a GameId filter
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 带有 GameId 过滤器的结构化日志
- en: After writing logs, let’s get started with metrics data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写日志后，让我们开始处理指标数据。
- en: Using metrics data
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指标数据
- en: Metrics data is used to monitor counts such as CPU and memory consumption or
    the length of an HTTP queue. This information can be used to analyze resources
    needed by services and can scale the services accordingly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 指标数据用于监控 CPU 和内存消耗或 HTTP 队列长度等计数。这些信息可用于分析服务所需资源，并相应地扩展服务。
- en: With metrics data, we get some counts. Such counts can be used for scaling services,
    based on memory or CPU consumption, or the length of an HTTP queue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指标数据，我们可以得到一些计数。这些计数可以根据内存或 CPU 消耗或 HTTP 队列长度来扩展服务。
- en: Let’s check the built-in metrics data before we add custom metrics.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加自定义指标之前，让我们先检查内置的指标数据。
- en: Monitoring built-in .NET metrics
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控内置 .NET 指标
- en: 'As mentioned, .NET offers much built-in metrics data that can be monitored
    using the `dotnet counters` .NET tool (install it via `dotnet tool install dotnet-counters
    -g` as a global tool), and many counts are already available from the .NET Aspire
    dashboard by opening the **Metrics** view. *Figure 11**.5* shows the .NET-managed
    heap size of the games API service at a time the bot played several games in parallel:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，.NET 提供了许多内置的指标数据，可以使用 `dotnet counters` .NET 工具进行监控（通过 `dotnet tool install
    dotnet-counters -g` 作为全局工具安装），许多计数已经通过打开 **指标** 视图从 .NET Aspire 仪表板中可用。*图 11.5*
    显示了在机器人并行玩了几场游戏时，游戏 API 服务的 .NET 管理堆大小：
- en: '![Figure 11.5 – Metrics](img/B21217_11_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 指标](img/B21217_11_05.jpg)'
- en: Figure 11.5 – Metrics
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 指标
- en: With many applications, you don’t need to create custom metrics data – but some
    custom counts might be interesting to see, and it’s not hard to add these, as
    shown in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用程序，你不需要创建自定义指标数据 - 但一些自定义计数可能很有趣，并且如下一节所示，添加这些指标并不困难。
- en: Creating custom metrics data
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义指标数据
- en: With the `Codebreaker` solution, we are interested in knowing about the number
    of active games that are just played, the time it takes from one game move to
    another, the time it takes to complete a game, and how many games are won versus
    lost.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Codebreaker` 解决方案，我们感兴趣的是了解刚刚玩过的活跃游戏数量、从一个游戏移动到另一个游戏所需的时间、完成游戏所需的时间以及赢得与输掉的游戏数量。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: With all the data we collect, we need to pay attention to the **General Data
    Protection Regulation** (**GDPR**). Not storing any user-related data with logging
    and metrics information, we are on the safe side.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集所有数据后，我们需要注意**通用数据保护条例**（**GDPR**）。不存储任何与用户相关的数据，仅保留日志和指标信息，我们就在安全的一边。
- en: 'Let’s create a new `GamesMetrics` class that contains all the counters needed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 `GamesMetrics` 类，它包含所有需要的计数器：
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fields defined within the `GameMetrics` class are for the `Meter` class,
    which is needed to create all the different metric instruments. This class is
    defined within the `System.Diagnostics.Metrics` namespace. This class is responsible
    for creating all the different instruments needed to monitor metrics data. The
    `Meter` type needs a name that is used to specify what metrics data we are interested
    in. The value for the version is optional.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameMetrics` 类中定义的字段是为 `Meter` 类准备的，这是创建所有不同度量仪器所需的。这个类在 `System.Diagnostics.Metrics`
    命名空间内定义。这个类负责创建所有用于监控度量数据的仪器。`Meter` 类型需要一个名称，用于指定我们感兴趣的度量数据。版本值是可选的。
- en: The `Counter` type is used to count the number of games won and lost and for
    all invalid game moves. `Counter` can be used for positive values, and most metrics
    viewers show the number of counts per second but can also show cumulative values.
    The `UpDownCounter` type is used for positive and negative values. We use this
    for the number of games active. Every time a game ends, a decrement will be made.
    The `Histogram` type is of special interest. This metrics instrument can be used
    to show arbitrary values. Here, this instrument is used to show the time it takes
    to complete a game, the time a user needs between game moves, and the number of
    moves needed to win a game.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 类型用于计算赢得和输掉的游戏数量以及所有无效的游戏移动。`Counter` 可以用于正数值，并且大多数度量查看器显示每秒的计数数量，但也可以显示累积值。`UpDownCounter`
    类型用于正负值。我们用它来表示活跃游戏的数量。每次游戏结束时，都会进行一次递减。`Histogram` 类型特别有趣。这种度量仪器可以用来显示任意值。在这里，这个仪器用来显示完成游戏所需的时间、用户在游戏移动之间所需的时间以及赢得游戏所需的移动次数。'
- en: 'With the constructor of the `GamesMetrics` class, the `Meter` class and the
    instruments are created and initialized:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GamesMetrics` 类的构造函数，创建并初始化 `Meter` 类和仪器：
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`IMeterFactory` is a new interface since .NET 8\. This allows the creation
    of metrics types via `IMeterFactory` is injected with the `GamesMetrics` constructor
    to create a `Meter` instance and instruments. `CreateCounter`, `CreateUpDownCounter`,
    and `CreateHistogram` are the methods to create the different metric instruments.
    The name of the instrument, the unit, and the description are assigned upon creating
    the instruments.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMeterFactory` 是从 .NET 8 开始的新接口。这允许通过 `IMeterFactory` 创建度量类型，通过将 `GamesMetrics`
    构造函数注入来创建 `Meter` 实例和仪器。`CreateCounter`、`CreateUpDownCounter` 和 `CreateHistogram`
    是创建不同度量仪器的函数。仪器的名称、单位和描述在创建仪器时指定。'
- en: Before using these counters, let’s add tags.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些计数器之前，让我们添加标签。
- en: Creating tags
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建标签
- en: 'Writing metrics data, `GameMetrics` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 写入度量数据，`GameMetrics` 类：
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`CreateGameTypeTag` is a helper method to create a tag with the name `GameType`
    and set the value passed with the method parameter. Similarly, `CreateGameIdTag`
    is a method to create a tag for `GameId`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateGameTypeTag` 是一个辅助方法，用于创建名为 `GameType` 的标签，并设置通过方法参数传递的值。同样，`CreateGameIdTag`
    是创建 `GameId` 标签的方法。'
- en: Now, we are ready to create methods using the instruments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好使用这些仪器创建方法。
- en: Creating strongly typed methods for metrics data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为度量数据创建强类型方法
- en: 'The `GameStarted` method is for writing metrics data on creating a new game:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameStarted` 方法用于在创建新游戏时写入度量数据：'
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When nobody listens to metrics data, there’s no need to take any action. Before
    writing values to an instrument, it should be verified that the instrument is
    enabled. If nobody listens to the meter, the counters are disabled.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有人监听度量数据时，无需采取任何行动。在向仪表写入值之前，应验证仪表是否已启用。如果没有人监听仪表，则计数器被禁用。
- en: To write the delta time between moves, we need to remember the time of the previous
    move. For this, the `GameMetrics` class holds the `_moveTimes` dictionary. This
    dictionary uses the game ID for the key and the last time for the latest move
    (or game start) value. Calculating this information is only necessary when the
    `_moveThinkTime` instrument is used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入移动之间的时间差，我们需要记住上一个移动的时间。为此，`GameMetrics` 类包含 `_moveTimes` 字典。这个字典使用游戏 ID
    作为键，最后移动（或游戏开始）的时间作为最新移动值。只有在使用 `_moveThinkTime` 仪表时，才需要计算此信息。
- en: The counter that’s incremented at the start of the game is `_activeGamesCounter`.
    With `UpDownCounter`, the `Add` method is used to change the counter value. The
    second – optional – argument of the `Add` method allows passing tags. Here, a
    tag for the game type is added. This allows us to check the metrics data filtered
    based on the game type. It’s interesting to compare the active game counts based
    on the different game types.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开始时增加计数的计数器是 `_activeGamesCounter`。使用 `UpDownCounter`，`Add` 方法用于更改计数器值。`Add`
    方法的第二个——可选的——参数允许传递标签。在这里，添加了一个游戏类型的标签。这允许我们根据游戏类型检查度量数据。比较不同游戏类型的活跃游戏计数很有趣。
- en: 'To write a histogram value, we implement the `MoveSet` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入直方图值，我们实现 `MoveSet` 方法：
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the implementation of `MoveSet`, for the received game ID, we get the previous
    recorded time from the dictionary, calculate the delta with the new time, use
    the `Record` method of the `Histogram` instrument to write the data, and write
    the new received time to the dictionary.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `MoveSet` 时，对于接收到的游戏 ID，我们从字典中获取之前记录的时间，计算与新时间的差值，使用 `Histogram` 仪表的 `Record`
    方法写入数据，并将新接收的时间写入字典。
- en: On ending the game, the `GameEnded` method is implemented. Here, multiple instruments
    are used, but this method just needs a simple implementation to check for every
    instrument to be enabled and write the counts accordingly. Check the source code
    repository for the complete code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏结束时，实现 `GameEnded` 方法。在这里，使用了多个仪表，但此方法只需要简单的实现来检查每个仪表是否启用，并相应地写入计数。请检查源代码存储库以获取完整的代码。
- en: Next, we can change the implementation of the `GamesService` class to use a
    `GamesMetrics` instance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将 `GamesService` 类的实现更改为使用 `GamesMetrics` 实例。
- en: Injecting and using metrics
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入和使用度量
- en: 'Let’s update the `GamesService` class for metrics data:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `GamesService` 类以支持度量数据：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All that needs to be done is to inject the `GamesMetrics` class and invoke the
    `GameStarted` method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所需做的只是注入 `GamesMetrics` 类并调用 `GameStarted` 方法。
- en: 'Of course, the `GamesMetrics` class needs configuration within the **DI** **container**
    (**DIC**):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`GamesMetrics` 类需要在 **DI** 容器（**DIC**）中进行配置：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `AddMetrics` extension method registers an implementation for the `IMeterFactory`
    interface. The `GamesMetrics` class is registered as a singleton – to create the
    instruments once. We also configure the `GamesMetrics` class with OpenTelemetry
    – this way, we have a listener, and these metrics will be shown with the .NET
    Aspire dashboard.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddMetrics` 扩展方法注册了 `IMeterFactory` 接口的实现。`GamesMetrics` 类被注册为单例——以创建仪表一次。我们还使用
    OpenTelemetry 配置了 `GamesMetrics` 类——这样，我们就有了监听器，这些度量数据将显示在 .NET Aspire 仪表板上。'
- en: With this, we could run the application. However, the unit tests for the `GamesService`
    class no longer compile because of this additional parameter. Let’s update this
    before we continue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，我们可以运行应用程序。然而，由于这个额外的参数，`GamesService` 类的单元测试不再编译。在我们继续之前，让我们更新它。
- en: Updating unit tests to inject metrics types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新单元测试以注入度量类型
- en: The `GamesService` class uses a concrete type – it injects the `GamesMetrics`
    type. This cannot be mocked directly, but we can mock the `IMeterFactory` interface
    to create a `GamesMetrics` instance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`GamesService` 类使用一个具体类型——它注入 `GamesMetrics` 类型。这不能直接模拟，但我们可以模拟 `IMeterFactory`
    接口以创建 `GamesMetrics` 实例。'
- en: 'The following code snippet shows an implementation of the `IMeterFactory` interface
    to be used for unit tests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了用于单元测试的`IMeterFactory`接口的实现：
- en: Codebreaker.GameAPIs.Tests/TestMeterFactory.cs
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/TestMeterFactory.cs
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To implement the `IMeterFactory` interface, `Create` and `Dispose` methods need
    to be implemented. With the `Create` method, a new `Meter` instance is created
    using name, version, and tag information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`IMeterFactory`接口，需要实现`Create`和`Dispose`方法。使用`Create`方法，通过名称、版本和标签信息创建一个新的`Meter`实例。
- en: 'This `TestMeterFactory` class can now be used to create an instance of the
    `GamesService` class for the unit test:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个`TestMeterFactory`类可以用来为单元测试创建`GamesService`类的实例：
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a new `GamesMetrics` instance, the `TestMeterFactory` class is created.
    The unit test for the `GamesService` class now builds successfully again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`GamesMetrics`实例时，会创建`TestMeterFactory`类。现在`GamesService`类的单元测试可以成功构建。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The GitHub contains an additional parameter, `ActivitySource`, when invoking
    the `GamesService` constructor. The `ActivitiySource` is added in the section
    *Using distributed tracing*, and requires an adaption of the unit tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`GamesService`构造函数时，GitHub包含一个额外的参数，`ActivitySource`。`ActivitySource`在*使用分布式跟踪*部分中添加，并需要适配单元测试。
- en: There’s also a unit test for the `GamesMetrics` class needed, which we’ll do
    next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要为`GamesMetrics`类编写一个单元测试，我们将在下一步进行。
- en: Creating unit tests to verify metrics
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单元测试以验证指标
- en: Metric data can be important business information easily shown on monitors in
    the office. What’s going on with the application? How active are users? Is an
    error rate going up? While metrics information is not important for orders coming
    in and being processed, if metrics data is not written, it can easily be missed
    that something is not working – thus creating unit tests for metrics data should
    be part of creating custom metric types.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 指标数据可以轻易地在办公室的显示器上显示为重要的业务信息。应用程序发生了什么？用户活跃度如何？错误率是否上升？虽然指标信息对于正在接收和处理的订单来说并不重要，但如果未记录指标数据，很容易错过某些东西不工作的情况——因此，为指标数据创建单元测试应该是创建自定义指标类型的一部分。
- en: First, let’s create a skeleton to return an `IMeterFactory` instance and a `GamesMetrics`
    instance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个骨架来返回`IMeterFactory`实例和`GamesMetrics`实例。
- en: Meter factory skeleton
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数器工厂骨架
- en: 'The following code snippet defines the skeleton used by the `GamesMetrics`
    unit tests:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段定义了`GamesMetrics`单元测试使用的骨架：
- en: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we need the real implementation of the `IMeterFactory` Interface. This
    is configured with the DIC for the unit test – along with the `GamesMetrics` singleton.
    The `CreateMeterFactorySkelton` method now gets the `IMeterFactory` and `GameMetrics`
    instances from the DIC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们需要`IMeterFactory`接口的真实实现。这是通过单元测试的DIC配置的——包括`GamesMetrics`单例。现在`CreateMeterFactorySkelton`方法从DIC中获取`IMeterFactory`和`GameMetrics`实例。
- en: Unit tests
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Using this skeleton, we can create unit tests for all `GameMetrics` methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此骨架，我们可以为所有`GameMetrics`方法创建单元测试：
- en: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For easy unit testing of metrics classes, the `MetricCollector` class defined
    in the `Microsoft.Extensions.Diagnostics.Testing` NuGet package in the `Microsoft.Extensions.Diagnostics.Metrics.Testing`
    namespace can register as a listener for the metrics data and collect this information.
    It’s also great for debugging purposes to have the metrics instruments enabled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便对指标类进行单元测试，`Microsoft.Extensions.Diagnostics.Testing` NuGet包中定义的`MetricCollector`类可以在`Microsoft.Extensions.Diagnostics.Metrics.Testing`命名空间中注册为指标数据的监听器并收集这些信息。对于调试目的，启用指标工具也非常有用。
- en: After the `IMeterFActory` and `GamesMetrics` objects are returned from the skeleton,
    a collector is created. You need to create a collector for every instrument that
    needs to be tested. The generic type parameter and the name of the instrument
    need to match. The `MoveSet` method of the `GamesMetrics` class records the time
    between the previous move (or the game start) and the current move. Using `Assert.Single`,it’s
    verified that exactly one measurement is written to the collector. With `Assert.Equal`,
    it’s checked that this one recording contains the value 10\. If you calculate
    the values from `_gameStartTime` and `_gameMove1Time`, this matches the time difference
    passed with the test data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在从骨架返回`IMeterFActory`和`GamesMetrics`对象后，创建了一个收集器。您需要为每个需要测试的仪器创建一个收集器。泛型类型参数和仪器的名称需要匹配。`GamesMetrics`类的`MoveSet`方法记录了前一个动作（或游戏开始）和当前动作之间的时间。使用`Assert.Single`，它验证了恰好有一个测量值写入收集器。使用`Assert.Equal`，它检查这一记录包含值10。如果您从`_gameStartTime`和`_gameMove1Time`计算值，这与测试数据传递的时间差相匹配。
- en: As the `GameMetrics` class tests successfully, let’s go to the .NET Aspire dashboard
    to see the custom metrics data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`GameMetrics`类测试成功，让我们转到.NET Aspire仪表板来查看自定义指标数据。
- en: Viewing metrics data with the .NET Aspire dashboard
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.NET Aspire仪表板查看指标数据
- en: We injected metrics and configured our custom `GamesMetrics` class with OpenTelemetry
    in the game APIs project. Now, we can use the .NET Aspire dashboard to see the
    games played!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在游戏API项目中注入了指标，并使用OpenTelemetry配置了我们的自定义`GamesMetrics`类。现在，我们可以使用.NET Aspire仪表板来查看玩过的游戏了！
- en: 'Running the services and starting the bot to run multiple games in parallel,
    we can see interesting outcomes. Sometimes, the bot doesn’t find an answer within
    12 moves because it lost the game, as shown in *Figure 11**.6*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务并启动机器人以并行运行多个游戏，我们可以看到有趣的结果。有时，由于机器人输掉了游戏，它无法在12步内找到答案，如*图11.6*所示：
- en: '![Figure 11.6 – Counter for games lost](img/B21217_11_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6 – 失败游戏的计数器](img/B21217_11_06.jpg)'
- en: Figure 11.6 – Counter for games lost
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 失败游戏的计数器
- en: '*Figure 11**.7* shows the number of games won by the bot is much higher. This
    figure also shows the filter for the game type that can be selected because of
    the tag specified:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.7* 显示了机器人赢得的游戏数量要高得多。此图还显示了由于指定的标签而可以选择的游戏类型过滤器：'
- en: '![Figure 11.7 – Counter for games won](img/B21217_11_07.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 胜利游戏的计数器](img/B21217_11_07.jpg)'
- en: Figure 11.7 – Counter for games won
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 胜利游戏的计数器
- en: 'While games won and lost used simple counters, *Figure 11**.8* shows the up-down
    counter with the number of active games:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然胜利和失败使用了简单的计数器，*图11.8* 显示了带有活跃游戏数量的上下计数器：
- en: '![Figure 11.8 – Up-down counter for active games](img/B21217_11_08.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 活跃游戏的上下计数器](img/B21217_11_08.jpg)'
- en: Figure 11.8 – Up-down counter for active games
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 活跃游戏的上下计数器
- en: '*Figure 11**.9* shows a histogram that allows checking the duration of games:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.9* 显示了一个直方图，可以检查游戏的持续时间：'
- en: '![Figure 11.9 – Histogram showing the game duration](img/B21217_11_09.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – 显示游戏持续时间的直方图](img/B21217_11_09.jpg)'
- en: Figure 11.9 – Histogram showing the game duration
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 显示游戏持续时间的直方图
- en: 'A histogram graph shows **P50**, **P90**, and **P99** values. These names are
    marks for percentiles. 50% of the finished games are within the lowest values:
    over the complete time, 50% of the games were finished within 25 seconds. The
    next higher line marks 90% of the game runs. Over time, with some peaks, we can
    see that sometimes 90% of the games were finished within 25 seconds, but it also
    took up to 50 seconds. To get to a higher number of games, 99% of the games were
    finished within 50 to 75 seconds. At peak time, it took 250 seconds. If a user
    is playing the game, this can be expected. We need more time than the bot to solve
    this. But here, it was just the bot playing. With different games, the bot was
    configured to take different times between game moves. However, the bot was never
    configured to take that long. Thus, this needs to be another issue, probably too
    high a load on the service. To find the reason more easily for such behavior,
    the next section covering distributed tracing will help.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一个直方图显示了**P50**、**P90**和**P99**的值。这些名称是百分位数的标记。完成的游戏中有50%在最低值以下：在整个时间范围内，50%的游戏在25秒内完成。下一条更高的线标记了90%的游戏运行。随着时间的推移，有一些峰值，我们可以看到有时90%的游戏在25秒内完成，但也可能需要50秒。为了达到更高的游戏数量，99%的游戏在50到75秒内完成。在高峰时段，需要250秒。如果用户在玩游戏，这是可以预料的。我们需要比机器人更多的时间来解决这个问题。但在这里，只是机器人玩游戏。对于不同的游戏，机器人被配置为在游戏移动之间采取不同的时间。然而，机器人从未被配置为花费这么长时间。因此，这需要是另一个问题，可能是服务负载过高。为了更容易地找到这种行为的原因，下一节将介绍分布式追踪。
- en: Using distributed tracing
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分布式追踪
- en: If errors happen on the service, where is this request coming from, and from
    where does it originate? With distributed tracing, we can see the interaction
    of services and resources and can easily follow information on how requests from
    a client flow to the different services and see when errors occur, going from
    the error up to the stack.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在服务中发生错误，这个请求是从哪里来的，它起源于哪里？使用分布式追踪，我们可以看到服务和资源的交互，并且可以轻松地跟踪客户端请求如何流向不同的服务，并看到错误何时发生，从错误向上到堆栈。
- en: Using .NET, we use `ActivitySource` and `Activity` classes to specify information
    for distributed tracing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET，我们使用`ActivitySource`和`Activity`类来指定分布式追踪的信息。
- en: Creating an ActivitySource class with the DIC
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DIC创建ActivitySource类
- en: 'When writing trace information, you’ll usually have one `ActivitySource` class
    in a project that’s used by all classes that write trace information. With the
    games client library, an `ActivitySource` class is used as a static member. Using
    an `ActivitySource` class from an executable project such as the games API, we
    can register this in the DIC:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写追踪信息时，你通常在一个项目中只有一个`ActivitySource`类，该类被所有编写追踪信息的类使用。在游戏客户端库中，`ActivitySource`类被用作静态成员。使用如游戏API这样的可执行项目中的`ActivitySource`类，我们可以将其注册到DIC中：
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/ApplicationServices.cs
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The ASP.NET Core initialization already registers an `ActivitySource` class
    with the name `Microsoft.AspNetCore` as a singleton for the `ActivitySource` type.
    We don’t want to overwrite this setting with our name. The ASP.NET Core features
    injecting this `ActivitySource` instance should still get this instance, but for
    our own trace messages, the `Codebreaker.GameAPIs` activity source should be used.
    With .NET 8 enhancements on the DIC, we can register a named service within the
    DIC by invoking the `AddKeyedSingleton` method and specifying the name and version
    strings. One instance is created using the factory defined with the lambda expression.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core的初始化已经注册了一个名为`Microsoft.AspNetCore`的`ActivitySource`类作为`ActivitySource`类型的单例。我们不希望用我们的名字覆盖这个设置。ASP.NET
    Core特性注入这个`ActivitySource`实例应该仍然得到这个实例，但对我们自己的追踪消息，应该使用`Codebreaker.GameAPIs`活动源。借助.NET
    8对依赖注入（DIC）的增强，我们可以通过调用`AddKeyedSingleton`方法并指定名称和版本字符串，在DIC中注册一个命名服务。使用由lambda表达式定义的工厂创建一个实例。
- en: Next, we can inject this singleton instance with the `GamesService` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`GamesService`类注入这个单例实例。
- en: Writing trace messages
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写追踪消息
- en: 'With the constructor of the `GamesService` class, we can now inject the configured
    `ActivitySource` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`GamesService`类的构造函数，我们现在可以注入配置好的`ActivitySource`类：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using the `FromKeyedServices` attribute, we get the named instance from the
    DIC.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FromKeyedServices`属性，我们从DIC中获取命名实例。
- en: 'Next, let’s update the creation of a new game by creating an `Activity` object:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过创建一个`Activity`对象来更新创建新游戏的过程：
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.GameAPIs/Services/GamesService.cs
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Activity` object is created by invoking the `CreateActivity` method. The
    parameters used here are the name of the activity and the activity kind. The service
    specifies `ActivityKind.Server`, whereas the client library uses `ActivityKind.Client`.
    Other types available are `Producer` and `Consumer`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `CreateActivity` 方法创建 `Activity` 对象。这里使用的参数是活动的名称和活动类型。服务指定 `ActivityKind.Server`，而客户端库使用
    `ActivityKind.Client`。其他可用的类型有 `Producer` 和 `Consumer`。
- en: The methods creating an `Activity` object might return `null`. If no one adds
    a listener to the `ActivitySource` class, the `CreateActivity` method returns
    `null`. This reduces the overhead but also means we always need to check for `null`
    values before using an `Activity` object. Using the `null` conditional operator,
    this is easy to do.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Activity` 对象的方法可能会返回 `null`。如果没有人为 `ActivitySource` 类添加监听器，`CreateActivity`
    方法将返回 `null`。这减少了开销，但也意味着我们始终需要在使用 `Activity` 对象之前检查 `null` 值。使用 `null` 条件运算符，这很容易做到。
- en: Using the `StartActivity` method instead of the `CreateActivity` method would
    immediately start the activity. Here, we want to add some data to the activity
    that is shown with the log output. The `AddTag` method is used to add the game
    type and the game ID. This method adds key-value pairs to the log entries, which
    allows filtering and searching. The `SetBaggage` method allows adding information
    not only to this activity output – this information is passed to the child activities.
    Baggage information is used across processes and thus needs to be serializable.
    Invoking the `Start` method starts the activity – this writes the first log record
    along with tag and baggage information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StartActivity` 方法而不是 `CreateActivity` 方法会立即启动活动。在这里，我们希望向活动添加一些数据，这些数据会与日志输出一起显示。使用
    `AddTag` 方法添加游戏类型和游戏 ID。此方法将键值对添加到日志条目中，允许过滤和搜索。`SetBaggage` 方法允许添加信息不仅限于这个活动输出——这些信息会传递给子活动。行李信息跨进程使用，因此需要可序列化。调用
    `Start` 方法开始活动——这将写入带有标签和行李信息的第一个日志记录。
- en: An activity ends when the `Stop` method is invoked. Here, the `using` declaration
    is used to dispose of the activity when the `activity` variable goes out of scope.
    This stops the activity implicitly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `Stop` 方法时，活动结束。在这里，使用 `using` 声明在 `activity` 变量超出作用域时销毁活动。这会隐式地停止活动。
- en: Before the activity ends, the `SetStatus` method is invoked. This method specifies
    the outcome of the activity and is written when the activity ends. With a successful
    start of the game, `ActivityStatusCode.Ok` is the status of the activity. In case
    of errors, the status code is `ActivityStatusCode.Error` and an exception message
    is written.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动结束之前，调用 `SetStatus` 方法。此方法指定活动的结果，并在活动结束时写入。在游戏成功启动的情况下，活动的状态是 `ActivityStatusCode.Ok`。在出现错误的情况下，状态码是
    `ActivityStatusCode.Error`，并写入异常消息。
- en: Check the other source code repo for the other activities created with the `GamesService`
    class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查其他源代码仓库，以获取使用 `GamesService` 类创建的其他活动。
- en: With this implementation, we just need to configure the service defaults library
    to monitor the custom `ActivitySource` class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们只需要配置服务默认库来监控自定义的 `ActivitySource` 类。
- en: Viewing distributed traces with the .NET Aspire dashboard
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .NET Aspire 仪表板查看分布式跟踪
- en: 'First, let’s add a custom `ActivitySource` class to the configuration:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将自定义的 `ActivitySource` 类添加到配置中：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE20]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `WithTracing` method configures the distributed trace settings. The `AddSource`
    method of the `TracerProviderBuilder` class sets the sources that should be subscribed
    to. `Codebreaker.GameAPIs` is the activity source name that has been configured
    with the games API service. `Codebreaker.GameAPIs.Client` is the activity source
    name used from the client library, which is referenced by the bot service. The
    next methods invoked configure the built-in sources with ASP.NET Core, gRPC, and
    `HttpClient`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithTracing` 方法配置分布式跟踪设置。`TracerProviderBuilder` 类的 `AddSource` 方法设置应订阅的源。`Codebreaker.GameAPIs`
    是配置了游戏 API 服务的活动源名称。`Codebreaker.GameAPIs.Client` 是客户端库中使用的活动源名称，该库由机器人服务引用。接下来的方法调用配置了
    ASP.NET Core、gRPC 和 `HttpClient` 的内置源。'
- en: 'Now, running a few games using the bot, you can see *traces* in the .NET Aspire
    dashboard, as shown in *Figure 11**.10*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用机器人运行几场游戏，你可以在 .NET Aspire 仪表板中看到 *跟踪*，如图 *11.10* 所示：
- en: '![Figure 11.10 – Tracing](img/B21217_11_10.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 跟踪](img/B21217_11_10.jpg)'
- en: Figure 11.10 – Tracing
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 跟踪
- en: Sending a `POST` request to the bot to play multiple games, the request immediately
    returns (the one request in the figure lists 4,84 ms). The figure also shows activities
    started from this request from within a background task. This task is to play
    games. How this relates to multiple activities (or `bot POST bot/bots`, is an
    activity created from ASP.NET Core. The next activity, `bot StartGameAsync`, is
    a custom activity that was created from the games client library. `bot POST` is
    the next activity from `HttpClient`. From there, we switch over to the `gameapis`
    service. The custom activities created with the games API are `gameapis StartGame`
    and `gameapis SetMove`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 向机器人发送`POST`请求以玩多个游戏，请求立即返回（图中的请求列出了4,84毫秒）。该图还显示了从后台任务中启动的此请求的活动。这个任务是为了玩游戏。这与多个活动（或`bot
    POST bot/bots`，这是从ASP.NET Core创建的活动）有什么关系。下一个活动`bot StartGameAsync`是从游戏客户端库创建的自定义活动。`bot
    POST`是来自`HttpClient`的下一个活动。从那里，我们切换到`gameapis`服务。使用游戏API创建的自定义活动是`gameapis StartGame`和`gameapis
    SetMove`。
- en: 'With every one of these activities, you can dig deeper and get the data written,
    including the tags for the game ID and the game type, as shown in *Figure 11**.11*:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些活动中的每一个时，你都可以深入了解并获取数据，包括游戏ID和游戏类型的标签，如图*11.11*所示：
- en: '![Figure 11.11 – Trace data](img/B21217_11_11.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 跟踪数据](img/B21217_11_11.jpg)'
- en: Figure 11.11 – Trace data
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 跟踪数据
- en: While monitoring this data, also switch to **Structured Logs**. With these logs,
    you can see a **Trace** identifier. Clicking on this, you switch from the log
    to the trace information. It’s also working the other way around. While opening
    a trace, you can switch to the log information associated with the trace.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控这些数据的同时，也切换到**结构化日志**。使用这些日志，你可以看到一个**跟踪**标识符。点击它，你将从日志切换到跟踪信息。反之亦然。在打开跟踪时，你也可以切换到与跟踪相关的日志信息。
- en: Using the .NET Aspire dashboard is now great in the development environment.
    For production environments, we have different needs. Let’s switch over to using
    .NET Azure services for monitoring.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中使用.NET Aspire仪表板现在非常棒。对于生产环境，我们有不同的需求。让我们切换到使用.NET Azure服务进行监控。
- en: Monitoring with Azure Application Insights
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Azure Application Insights进行监控
- en: Creating an Azure Container Apps environment (starting with [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137))
    also creates an **Azure Log Analytics** resource. In this chapter, we add an **Azure
    Application Insights** resource, and add a Log Analytics respource explicitly
    to the app model. Log Analytics and Application Insights are both part of the
    **Azure** **Monitor** service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Azure Container Apps环境（从[*第6章*](B21217_06.xhtml#_idTextAnchor137)开始）也会创建一个**Azure
    Log Analytics**资源。在本章中，我们添加了一个**Azure Application Insights**资源，并显式地将Log Analytics资源添加到应用程序模型中。Log
    Analytics和Application Insights都是**Azure** **Monitor**服务的一部分。
- en: Log Analytics is used to monitor the amount of log data created and the cost
    associated and gives reasons when there is a higher-than-expected usage. Application
    Insights has a focus on application telemetry data and user data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Log Analytics用于监控创建的日志数据量及其相关成本，并在使用量高于预期时提供原因。Application Insights专注于应用程序遥测数据和用户数据。
- en: Configuring the .NET Aspire host for Application Insights
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置.NET Aspire主机以使用Application Insights
- en: 'To add Application Insights, add the NuGet package `Aspire.Hosting.Azure.ApplicationInsights`,
    and update the `Program.cs` file of the .NET Aspire `AppHost` project:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加Application Insights，请添加NuGet包`Aspire.Hosting.Azure.ApplicationInsights`，并更新.NET
    Aspire `AppHost`项目的`Program.cs`文件：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Application Insights resource is added invoking the AddAzureApplicationInsights
    method. This method requires a name and a log analytics workspace resource which
    is created invoking the AddAzureLogAnalytics method. Both the games API and the
    bot services will use this resource, thus it is forwarded using Aspire orchestration
    by using the `WithReference` method.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用AddAzureApplicationInsights方法添加Application Insights资源。此方法需要一个名称和一个由调用AddAzureLogAnalytics方法创建的日志分析工作区资源。游戏API和机器人服务都将使用此资源，因此它通过使用`WithReference`方法通过Aspire编排进行转发。
- en: With this, we can configure the services to use Application Insights.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以配置服务以使用Application Insights。
- en: Configuring the services to use Application Insights
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置服务以使用Application Insights
- en: 'To use Application Insights, the common configuration project can be updated:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Application Insights，可以更新通用配置项目：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `AddOpenTelemetryExporters` method is invoked from the `AddServiceDefaults`
    method in the same class. `AddServiceDefaults` is called with the `WebApplication`
    configuration of every service project. The `AddOpenTelemetry` method is part
    of the OpenTelementry SDK to configure services for logging, metrics, and distributed
    tracing. The `UseAzureMonitor` extension method configures providers to write
    this information to Azure Monitor.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOpenTelemetryExporters` 方法是在同一类中的 `AddServiceDefaults` 方法中调用的。`AddServiceDefaults`
    方法使用每个服务项目的 `WebApplication` 配置进行调用。`AddOpenTelemetry` 方法是 OpenTelementry SDK
    的一部分，用于配置服务的日志记录、指标和分布式跟踪。`UseAzureMonitor` 扩展方法配置提供者将此信息写入 Azure Monitor。'
- en: This is all that we need to do. Let’s check the information we get from the
    application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的全部。让我们检查从应用程序中获得的信息。
- en: Monitoring the solution with Application Insights
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Application Insights 监控解决方案
- en: As before, upon running the application when monitoring using the Aspire dashboard,
    use the bot to run multiple games. As Application Insights is configured, it’s
    not necessary to have the solution deployed to Azure; monitoring information will
    be available within Azure when running the application locally as well. After
    starting a few game runs using the bot, open the Azure Application Insights resource
    within the Azure portal.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当使用 Aspire 仪表板进行监控时运行应用程序，使用机器人运行多个游戏。由于 Application Insights 已配置，因此不需要将解决方案部署到
    Azure；当在本地运行应用程序时，监控信息也将可在 Azure 中获取。使用机器人启动几轮游戏后，在 Azure 门户中打开 Azure Application
    Insights 资源。
- en: 'After playing a few games, check the Azure portal. With Application Insights,
    in the **Investigate** category on the left pane, select **Application map**.
    Here, you see how the different services communicate, as shown in *Figure 11**.12*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 玩了几局游戏后，检查 Azure 门户。使用 Application Insights，在左侧面板的 **调查** 类别中，选择 **应用映射**。在这里，你可以看到不同的服务是如何通信的，如
    *图 11*.12* 所示：
- en: '![Figure 11.12 – Application map](img/B21217_11_12.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 应用映射](img/B21217_11_12.jpg)'
- en: Figure 11.12 – Application map
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 应用映射
- en: The previous figure shows the bot service invokes the game API service, and
    this communicates with the Azure Cosmos database. The count of messages, the time
    used, and errors can easily be seen from this information. Clicking on a connection,
    it’s possible to investigate performance by seeing the slowest calls and directly
    accessing log information.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图显示了机器人服务调用游戏 API 服务，并且它与 Azure Cosmos 数据库进行通信。从这些信息中可以轻松地看到消息计数、使用的时间和错误。点击一个连接，可以通过查看最慢的调用和直接访问日志信息来调查性能。
- en: With the **Investigate** category in the Azure portal, you can dig into other
    interesting information such as **Performance**, where you get insights into slow
    operations, and **Failures**, where you can dive into errors and exceptions. Smart
    detection can give you notifications (alerts) when services are not behaving with
    usual, expected values.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 门户的 **调查** 类别中，你可以深入了解其他有趣的信息，例如 **性能**，在这里你可以了解慢速操作，以及 **故障**，在这里你可以深入了解错误和异常。智能检测可以在服务不按通常的预期值行为时给你发送通知（警报）。
- en: 'Within the `codebreaker.active_games` and `codebreaker.game_moves-per-win`,
    where you can select the metric name and the aggregation type to calculate values
    and see graphical results, as shown in *Figure 11**.13*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `codebreaker.active_games` 和 `codebreaker.game_moves-per-win` 中，你可以选择指标名称和聚合类型来计算值并查看图形结果，如
    *图 11*.13* 所示：
- en: '![Figure 11.13 – Metrics via Application Insights](img/B21217_11_13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – 通过 Application Insights 获取的指标](img/B21217_11_13.jpg)'
- en: Figure 11.13 – Metrics via Application Insights
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – 通过 Application Insights 获取的指标
- en: With this figure, the first line shows the average duration of a game (seconds),
    the second line shows the average number of moves needed, and the third line shows
    the number of games currently active.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个图表，第一行显示了游戏的平均持续时间（秒），第二行显示了平均所需的移动次数，第三行显示了当前活跃的游戏数量。
- en: Clicking `customMetrics` table, you can query all the metrics data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `customMetrics` 表，你可以查询所有指标数据。
- en: 'Use this KQL query to get the average EF Core queries on a time chart:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 KQL 查询在时间图表上获取平均 EF Core 查询：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This query accesses the `customMetrics` table filtered by the `name` column
    to get the EF Core queries by second. This result (you can see every record fitting
    this query by clicking on **Results**) is then used to show the average values
    and a timestamp rendered on a time chart. Your result might look like the one
    shown in *Figure 11**.14*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询通过 `name` 列筛选 `customMetrics` 表，以获取每秒的 EF Core 查询。此结果（您可以通过点击 **结果** 来查看符合此查询的每条记录）随后用于显示时间图表上的平均值和时间戳。您的结果可能看起来像
    *图 11.14* 中所示：
- en: '![Figure 11.14 – EF Core average queries using KQL](img/B21217_11_14.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – 使用 KQL 的 EF Core 平均查询](img/B21217_11_14.jpg)'
- en: Figure 11.14 – EF Core average queries using KQL
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 使用 KQL 的 EF Core 平均查询
- en: The Application Insights resource can be used no matter where your services
    are running if they have access to this resource on Microsoft Azure. In case the
    complete solution needs to run on-premises, you can use Prometheus and Grafana,
    as we’ll do next.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务可以访问 Microsoft Azure 上的此资源，则无论服务运行在何处，都可以使用 Application Insights 资源。如果整个解决方案需要在本地运行，则可以使用
    Prometheus 和 Grafana，正如我们接下来将要做的。
- en: Monitoring with Prometheus and Grafana
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prometheus 和 Grafana 进行监控
- en: For monitoring microservices solutions, Prometheus and Grafana are often used.
    **Prometheus** uses a pull model to collect data from services. Using this data,
    the **PromQL** query language analyzes this information. **Grafana** can access
    the data collected from Prometheus to show a graphical view.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于监控微服务解决方案，Prometheus 和 Grafana 经常被使用。**Prometheus** 使用拉模型从服务中收集数据。使用这些数据，**PromQL**
    查询语言分析这些信息。**Grafana** 可以访问 Prometheus 收集的数据以显示图形视图。
- en: We’ll use Docker containers running Prometheus and Grafana. Microsoft Azure
    also offers managed services for Prometheus and Grafana that can be used as well.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用运行 Prometheus 和 Grafana 的 Docker 容器。Microsoft Azure 还提供了 Prometheus 和 Grafana
    的托管服务，也可以使用。
- en: Let’s configure Docker containers for Prometheus and Grafana next.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为 Prometheus 和 Grafana 配置 Docker 容器。
- en: Adding Docker containers for Prometheus and Grafana
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Prometheus 和 Grafana 添加 Docker 容器
- en: To use the solution with Prometheus and Grafana, you need to select the launch
    profile – using Visual Studio, select **OnPremises** in the toolbar after the
    project selection.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Prometheus 和 Grafana 的解决方案，您需要选择启动配置文件 – 使用 Visual Studio，在项目选择后，在工具栏中选择
    **OnPremises**。
- en: 'Using the command line, use the `--``launch-profile` parameter:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行，使用 `--launch-profile` 参数：
- en: '[PRE24]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To also use SQL Server within a Docker container, set the `DataStore` configuration
    to `SQLServer` (see [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063) for details);
    you could also use in-memory or Cosmos instead with the same build configuration.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Docker 容器内使用 SQL Server，请将 `DataStore` 配置设置为 `SQLServer`（有关详细信息，请参阅 [*第 3
    章*](B21217_03.xhtml#_idTextAnchor063)）；您也可以使用相同的构建配置使用内存或 Cosmos。
- en: 'For using a Prometheus Docker container, we need to change the .NET Aspire
    `AppHost` implementation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Prometheus Docker 容器，我们需要更改 .NET Aspire `AppHost` 实现：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first Docker container we used was the container for SQL Server. For using
    the Docker image for SQL Server, the `AddSqlServerContainer` extension method
    was used. To use the Prometheus Docker image, we need to use the `AddContainer`
    generic method, which allows adding any Docker image. The Docker image for Prometheus
    can be pulled from Docker Hub using `prom/prometheus`. For the Prometheus configuration,
    we use the `prometheus` folder, which is stored outside of the container. Using
    `WithBindMount`, the `prometheus` host directory is mapped to the `/etc/prometheus`
    folder within the container. Prometheus used port `9090` to access its services.
    This port is mapped to the host port `9090` with the `WithHttpEndpoint` method
    to make Prometheus available.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初使用的第一个 Docker 容器是 SQL Server 的容器。要使用 SQL Server 的 Docker 镜像，使用了 `AddSqlServerContainer`
    扩展方法。要使用 Prometheus Docker 镜像，我们需要使用 `AddContainer` 泛型方法，它允许添加任何 Docker 镜像。Prometheus
    的 Docker 镜像可以从 Docker Hub 使用 `prom/prometheus` 拉取。对于 Prometheus 配置，我们使用存储在容器外部的
    `prometheus` 文件夹。使用 `WithBindMount`，将 `prometheus` 主机目录映射到容器内的 `/etc/prometheus`
    文件夹。Prometheus 使用端口 `9090` 访问其服务。此端口通过 `WithHttpEndpoint` 方法映射到主机端口 `9090` 以使
    Prometheus 可用。
- en: 'Next, add a Docker container for Grafana with the same file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个具有相同文件的 Grafana Docker 容器：
- en: Codebreaker.AppHost/Program.cs
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.AppHost/Program.cs
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Docker image for Grafana is pulled from Docker Hub with the name `grafana/grafana`.
    This container needs mounts within the `/etc/grafana` and `/var/lib/grafana/dashboards`
    Docker container directories for the Grafana configuration and dashboard configurations
    used. For both mounts, we’ll have a local `grafana` directory. The Grafana service
    will be available on port `3000`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Grafana 的 Docker 镜像通过 Docker Hub 以 `grafana/grafana` 的名称拉取。此容器需要在 `/etc/grafana`
    和 `/var/lib/grafana/dashboards` Docker 容器目录中进行挂载，用于 Grafana 配置和仪表板配置。对于这两个挂载，我们将有一个本地的
    `grafana` 目录。Grafana 服务将在端口 `3000` 上可用。
- en: After configuring the Docker containers, let’s add the configuration for Prometheus.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 Docker 容器之后，让我们添加 Prometheus 的配置。
- en: Configuring Prometheus
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Prometheus
- en: 'Prometheus is configured with this YML file in the `prometheus` folder that’s
    referenced with the Docker container configuration specified previously:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 使用 `prometheus` 文件夹中的此 YML 文件进行配置，该文件夹由先前指定的 Docker 容器配置引用：
- en: prometheus/prometheus.yml
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: prometheus/prometheus.yml
- en: '[PRE27]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Prometheus pulls telemetry data from services. How often this is done from Prometheus
    is defined by the `scrape_interval` parameter. To run tests and get fast information,
    here, 1 second is configured. On a production system, you might increase this
    value to, for example, 30 seconds to decrease the load on the services. The services
    that are accessed from Prometheus are the games API and the bot service. Make
    sure to configure the ports to the port numbers of your service projects. You
    can see these values with the `Properties/launchsettings.json` files.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 从服务中拉取遥测数据。Prometheus 从 Prometheus 拉取数据的频率由 `scrape_interval` 参数定义。为了运行测试和获取快速信息，这里配置了
    1 秒。在生产系统中，您可能需要将此值增加到，例如，30 秒以减少对服务的负载。从 Prometheus 访问的服务是游戏 API 和机器人服务。请确保配置到您的服务项目的端口号。您可以使用
    `Properties/launchsettings.json` 文件查看这些值。
- en: 'To add an API endpoint that’s accessed by Prometheus for scraping telemetry
    data, the `MapDefaultEndpoints` method of the `Extensions` class needs an update:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个 Prometheus 用于抓取遥测数据的 API 端点，`Extensions` 类的 `MapDefaultEndpoints` 方法需要更新：
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `MapPrometheusScrapingEndpoint` method configures an endpoint and maps the
    `PrometheusExporterMiddleware` middleware.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapPrometheusScrapingEndpoint` 方法配置了一个端点并将 `PrometheusExporterMiddleware`
    中间件映射。'
- en: 'The `AddOpenTelemetryExporters` method needs an update as well:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOpenTelemetryExporters` 方法也需要更新：'
- en: Codebreaker.ServiceDefaults/Extensions.cs
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Codebreaker.ServiceDefaults/Extensions.cs
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With Azure Application Insights, we used the `UseAzureMonitor` method. For Prometheus,
    we use the `WithMetrics` method, and `AddPrometheusExporter` adds the exporter
    for Prometheus.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure Application Insights，我们使用了 `UseAzureMonitor` 方法。对于 Prometheus，我们使用
    `WithMetrics` 方法，而 `AddPrometheusExporter` 添加了 Prometheus 的导出器。
- en: After the configuration of Prometheus, let’s configure Grafana.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 Prometheus 之后，让我们配置 Grafana。
- en: Configuring Grafana
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Grafana
- en: 'With this configuration of the Grafana Docker container, we defined using the
    `grafana` host folder. Here, we need to create a `grafana.ini` configuration file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置的 Grafana Docker 容器，我们使用 `grafana` 主文件夹定义了配置。在这里，我们需要创建一个 `grafana.ini`
    配置文件：
- en: grafana/grafana.ini
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: grafana/grafana.ini
- en: '[PRE30]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For simple tests locally, we allow anonymous authentication and specify that
    non-authenticated users have admin access to change settings and customize dashboards.
    The home dashboard that’s used is the ASP.NET Core dashboard.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地的简单测试，我们允许匿名认证并指定非认证用户可以更改设置和自定义仪表板。使用的首页仪表板是 ASP.NET Core 仪表板。
- en: 'To access Prometheus from Grafana, the data source needs to be specified with
    a YML file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Grafana 访问 Prometheus，需要使用 YML 文件指定数据源：
- en: grafana/config/provisioning/datasources/default.yaml
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: grafana/config/provisioning/datasources/default.yaml
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `datasources` folder contains the configuration file for the Prometheus
    data source. This uses port `9090` used by Prometheus.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`datasources` 文件夹包含 Prometheus 数据源的配置文件。它使用 Prometheus 使用的端口 `9090`。'
- en: 'The default dashboard is configured with a YML file as well:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 默认仪表板也使用 YML 文件进行配置：
- en: grafana/config/provisioning/dashbaords/default.yml
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: grafana/config/provisioning/dashboards/default.yml
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The dashboards themselves are stored within the `grafana/dashboards` folder.
    You can get pre-built dashboards at [https://grafana.com/grafana/dashboards](https://grafana.com/grafana/dashboards).
    The ASP.NET Core team provides the dashboards for .NET 8 named *ASP.NET Core Endpoint*
    (ID: 19925) and *ASP.NET Core* (ID: 19924) to monitor request durations, error
    rates, current connections, total requests… for ASP.NET Core metrics. Both dashboards
    are copied to the final solution of this chapter.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘本身存储在 `grafana/dashboards` 文件夹中。您可以在 [https://grafana.com/grafana/dashboards](https://grafana.com/grafana/dashboards)
    获取预构建的仪表盘。ASP.NET Core 团队提供了名为 *ASP.NET Core Endpoint*（ID：19925）和 *ASP.NET Core*（ID：19924）的仪表盘，用于监控请求持续时间、错误率、当前连接、总请求等
    .NET 8 指标。这两个仪表盘都已复制到本章的最终解决方案中。
- en: When this configuration is in place, we are ready to start the solution again
    – running all services on the local system.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当此配置就绪时，我们就可以再次启动解决方案了——在本地系统上运行所有服务。
- en: Monitoring the solution with Prometheus and Grafana
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Prometheus 和 Grafana 监控解决方案
- en: 'When you run the application now, three Docker containers are running: SQL
    Server, Prometheus, and Grafana, and the bot and game APIs projects, as shown
    in *Figure 11**.15*. Grafana lists an endpoint that’s accessible from the host:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在运行应用程序时，有三个 Docker 容器正在运行：SQL Server、Prometheus 和 Grafana，以及机器人和服务 API 项目，如图
    *图 11.15* 所示。Grafana 列出了从主机可访问的端点：
- en: '![Figure 11.15 – Aspire dashboard with Prometheus and Grafana](img/B21217_11_15.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – 使用 Prometheus 和 Grafana 的 Aspire 仪表盘](img/B21217_11_15.jpg)'
- en: Figure 11.15 – Aspire dashboard with Prometheus and Grafana
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 使用 Prometheus 和 Grafana 的 Aspire 仪表盘
- en: 'By accessing the bot service again to let it play some games, we can access
    the configured dashboards from the Grafana Docker container, as shown in *Figure
    11**.16*:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次访问机器人服务以让它玩一些游戏，我们可以从 Grafana Docker 容器中访问配置的仪表盘，如图 *图 11.16* 所示：
- en: '![Figure 11.16 – Grafana Dashboards](img/B21217_11_16.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – Grafana 仪表盘](img/B21217_11_16.jpg)'
- en: Figure 11.16 – Grafana Dashboards
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – Grafana 仪表盘
- en: This page is opened by selecting **Dashboards** in the left pane. There, you
    can open both configured ASP.NET Core dashboards to see these metrics.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面是通过在左侧面板中选择 **仪表盘** 打开的。在那里，您可以打开配置的 ASP.NET Core 仪表盘以查看这些指标。
- en: 'You can also see the custom metric counts written, as shown in *Figure 11**.17*:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到写入的自定义指标计数，如图 *图 11.17* 所示：
- en: '![Figure 11.17 – Active games with Grafana](img/B21217_11_17.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – 使用 Grafana 的活动游戏](img/B21217_11_17.jpg)'
- en: Figure 11.17 – Active games with Grafana
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – 使用 Grafana 的活动游戏
- en: The preceding figure shows the active game count (all started from the bot).
    To see this screen, open the **Explore** menu in the left pane. Then, select the
    value of the metric from a combobox and click the **Query** button. With the graph,
    you can select from different display types.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了活动游戏数量（所有都是从机器人开始的）。要查看此屏幕，请打开左侧面板中的 **探索** 菜单。然后，从组合框中选择指标的值并单击 **查询**
    按钮。通过图表，您可以选择不同的显示类型。
- en: 'In the previous section, you’ve seen Azure services to monitor the solution.
    With Prometheus and Grafana, you’ve seen services that can easily be used in an
    on-premises environment. In case you prefer Prometheus and Grafana while running
    within Microsoft Azure, one way of use is to run these services in Azure Container
    Apps. Azure-managed services are available as well: Azure offers Managed Grafana
    and Azure Monitor Managed Service for Prometheus. Using these services, the same
    service is available but with reduced management needs.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您已经看到了用于监控解决方案的 Azure 服务。使用 Prometheus 和 Grafana，您已经看到了可以轻松用于本地环境的服务。如果您在
    Microsoft Azure 中运行时更喜欢 Prometheus 和 Grafana，一种使用方式是将这些服务运行在 Azure Container Apps
    中。同时，Azure 也提供了管理的服务：Azure 提供了管理 Grafana 和 Azure Monitor 管理服务 Prometheus。使用这些服务，相同的服务可用，但管理需求减少。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about offering telemetry data from a microservice
    solution covering logging, metrics, and distributed tracing. With logging, you
    used high-performance, strongly typed logging to write information-level logs
    as well as errors. For metrics, you created custom metric data using the `Meter`
    class with instruments created. For distributed tracing, you used the `ActivitySource`
    and `Activity` classes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了从微服务解决方案中提供遥测数据，包括日志记录、指标和分布式跟踪。对于日志记录，您使用了高性能、强类型的日志记录来编写信息级日志以及错误。对于指标，您使用创建的仪表创建自定义指标数据。对于分布式跟踪，您使用了
    `ActivitySource` 和 `Activity` 类。
- en: To monitor all this telemetry data, you used the .NET Aspire dashboard, Azure
    Application Insights, and Prometheus with Grafana.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控所有这些遥测数据，您使用了.NET Aspire仪表板、Azure Application Insights和Prometheus与Grafana。
- en: In the next chapter, we’ll look into how to use metrics data to scale the services
    running with Azure Container Apps. We’ll find out about the memory and CPU usage
    of services using load tests we created in [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239),
    combine this with metrics information from this chapter, learn about scaling services
    to be ready no matter how demand grows, and implement health checks to recover
    services when not healthy.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用指标数据来扩展在Azure Container Apps中运行的服务。我们将了解使用我们在[*第10章*](B21217_10.xhtml#_idTextAnchor239)中创建的负载测试来测量的服务的内存和CPU使用情况，结合本章的指标信息，了解如何根据需求增长进行服务扩展，并实现健康检查以在服务不健康时恢复服务。
- en: Further reading
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: 'OpenTelemetry: [https://opentelemetry.io/](https://opentelemetry.io/)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenTelemetry：[https://opentelemetry.io/](https://opentelemetry.io/)
- en: 'High-performance logging in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET中的高性能日志记录：[https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging)
- en: 'Application Insights: [https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Application Insights：[https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
- en: 'KQL repo: [https://github.com/microsoft/Kusto-Query-Language](https://github.com/microsoft/Kusto-Query-Language)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KQL仓库：[https://github.com/microsoft/Kusto-Query-Language](https://github.com/microsoft/Kusto-Query-Language)
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus：[https://prometheus.io/](https://prometheus.io/)
- en: 'Grafana repo: [https://github.com/grafana/grafana](https://github.com/grafana/grafana)'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana仓库：[https://github.com/grafana/grafana](https://github.com/grafana/grafana)
- en: 'Grafana Dashboards: [https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grafana仪表板：[https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/)
