- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Native Monitoring in .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 的原生监控
- en: In this chapter, we’ll explore the out-of-the-box diagnostic capabilities of
    modern .NET applications, starting with logs and ad hoc diagnostics, and then
    move on to examine what OpenTelemetry provides on top of that. We’ll create a
    sample application and instrument it, showcasing cross-process log correlation,
    and learn how we can capture verbose logs with `dotnet-monitor`. Then, we’ll investigate
    .NET runtime counters and export them to Prometheus. Finally, we’ll configure
    OpenTelemetry to collect traces and metrics from .NET, ASP.NET Core, and Entity
    Framework, and check out how basic auto-instrumentations address observability
    needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索现代 .NET 应用程序的即用型诊断功能，从日志和临时诊断开始，然后继续探讨 OpenTelemetry 在此之上提供的内容。我们将创建一个示例应用程序并对其进行工具化，展示跨进程日志关联，并学习如何使用
    `dotnet-monitor` 捕获详细日志。然后，我们将调查 .NET 运行时计数器并将它们导出到 Prometheus。最后，我们将配置 OpenTelemetry
    以从 .NET、ASP.NET Core 和 Entity Framework 收集跟踪和指标，并查看基本的自动工具化如何满足可观察性需求。
- en: 'The following topics are what we’ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将要涵盖的主题：
- en: Native log correlation in ASP.NET Core applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 应用程序中的原生日志关联
- en: Minimalistic monitoring with .NET runtime counters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET 运行时计数器的简约监控
- en: Install OpenTelemetry and enable common instrumentations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 OpenTelemetry 并启用常用工具化
- en: Tracing and performance analysis with HTTP and database instrumentations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HTTP 和数据库工具进行跟踪和性能分析
- en: By the end of this chapter, you’ll be ready to use distributed tracing instrumentation
    in .NET libraries and frameworks, enable log correlation and metrics, and leverage
    multiple signals together to debug and monitor your applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将准备好在 .NET 库和框架中使用分布式跟踪工具，启用日志关联和指标，并利用多个信号一起调试和监控你的应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We’re going to start building a sample application and will use the following
    tools for it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建一个示例应用程序，并为此使用以下工具：
- en: .NET SDK 7.0 or newer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET SDK 7.0 或更高版本
- en: Visual Studio or Visual Studio Code with the C# development setup are recommended,
    but any text editor would work
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐使用带有 C# 开发设置的 Visual Studio 或 Visual Studio Code，但任何文本编辑器都可以工作
- en: Docker and `docker-compose`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 和 `docker-compose`
- en: The application code can be found in the book’s repository on GitHub at [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter2](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码可以在 GitHub 上的书籍仓库中找到，地址为 [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter2](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter2)。
- en: Building a sample application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: 'As shown in *Figure 2**.1*, our application consists of two REST services and
    a MySQL database:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 2.1* 所示，我们的应用程序由两个 REST 服务和一个 MySQL 数据库组成：
- en: '![Figure 2.1 – Meme service diagram](img/B19423_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Meme 服务图](img/B19423_02_01.jpg)'
- en: Figure 2.1 – Meme service diagram
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Meme 服务图
- en: '**Frontend**: ASP.NET Core Razor Pages application that serves user requests
    to upload and download images'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：为上传和下载图像服务用户请求的 ASP.NET Core Razor Pages 应用程序'
- en: '**Storage**: ASP.NET Core WebAPI application that uses Entity Framework Core
    to store images in a MySQL database or in memory for local development'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：使用 Entity Framework Core 存储图像的 ASP.NET Core WebAPI 应用程序，或用于本地开发的内存中'
- en: We’ll see how to run the full application using Docker later in this chapter.
    For now, run it locally and explore the basic logging and monitoring features
    that come with modern .NET.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面部分看到如何使用 Docker 运行完整的应用程序。现在，请在本地运行它并探索现代 .NET 所带来的基本日志和监控功能。
- en: We’re going to use the `Microsoft.Extensions.Logging.ILogger` API throughout
    this book. `ILogger` provides convenient APIs to write structured logs, along
    with verbosity control and the ability to send logs anywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中使用 `Microsoft.Extensions.Logging.ILogger` API。`ILogger` 提供了方便的 API 来编写结构化日志，包括详细程度控制以及将日志发送到任何地方的能力。
- en: ASP.NET Core and Entity Framework use `ILogger`; all we need to do is configure
    the logging level for specific categories or events to log incoming requests or
    database calls, and supply additional context with logging scopes. We’re going
    to cover this in detail in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131), *Writing
    Structured and Correlated Logs*. For now, let’s see log correlation in action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 Entity Framework 使用 `ILogger`；我们只需要为特定的类别或事件配置日志级别以记录传入的请求或数据库调用，并使用日志作用域提供额外的上下文。我们将在
    [*第 8 章*](B19423_08.xhtml#_idTextAnchor131) 中详细介绍，即 *编写结构化和关联日志*。现在，让我们看看日志关联的实际应用。
- en: Log correlation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志关联
- en: ASP.NET Core enables log correlation across multiple services by default. It
    creates an activity that loggers can access using `Activity.Current` and configures
    `Microsoft.Extensions.Logging` to populate the trace context on logging scopes.
    ASP.NET Core and `HttpClient` also support W3C Trace Context by default, so the
    context is automatically propagated over HTTP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 默认启用跨多个服务的日志关联。它创建一个日志记录器可以通过 `Activity.Current` 访问的活动，并配置 `Microsoft.Extensions.Logging`
    以在日志作用域中填充跟踪上下文。ASP.NET Core 和 `HttpClient` 也默认支持 W3C 跟踪上下文，因此上下文会自动通过 HTTP 传播。
- en: Some logging providers, for example, OpenTelemetry, don’t need any configuration
    to correlate logs, but our meme application uses a console provider, which does
    not print any logging scopes by default.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些日志提供程序，例如 OpenTelemetry，不需要任何配置即可关联日志，但我们的梗图应用程序使用的是控制台提供程序，默认情况下它不会打印任何日志作用域。
- en: 'So let’s configure our console provider to print scopes and we’ll see the trace
    context on every log record. Let’s also set the default level to `Information`
    for all categories just so we can see the output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们配置我们的控制台提供程序以打印作用域，我们将在每个日志记录上看到跟踪上下文。我们还将所有类别的默认级别设置为 `Information`，以便我们可以看到输出：
- en: appsettings.json
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: appsettings.json
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/appsettings.json](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/appsettings.json)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/appsettings.json](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/appsettings.json)'
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, you would use `Information` for application code only and set `Warning`
    or `Error` for frameworks and third-party libraries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你只会为应用程序代码使用 `Information`，并将 `Warning` 或 `Error` 设置为框架和第三方库。
- en: 'Let’s check it out – start the storage first, then, in a different terminal,
    start the frontend:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 – 首先启动存储，然后在不同的终端中启动前端：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure to keep both terminals open so we can check logs later. Now, let’s
    get the preloaded meme from the frontend in your browser – hit http://localhost:5051/Meme?name=dotnet
    and then check the logs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 确保同时保持两个终端开启，以便我们稍后可以检查日志。现在，让我们从浏览器的前端获取预加载的梗图 – 访问 http://localhost:5051/Meme?name=dotnet
    并然后检查日志。
- en: 'On the frontend, you may see something like this (other logs and scopes are
    omitted for brevity):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，你可能看到如下内容（为了简洁起见，省略了其他日志和作用域）：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first record describes the outgoing call to the storage service. You can
    see the status, duration, HTTP method, and URL, as well as the trace context.
    The second record describes an incoming HTTP call and has similar information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条记录描述了对存储服务的发出调用。你可以看到状态、持续时间、HTTP 方法以及 URL，以及跟踪上下文。第二条记录描述了一个进入的 HTTP 调用，并具有类似的信息。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This trace context is the same on both log records and belongs to the incoming
    HTTP request.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此跟踪上下文在两个日志记录中是相同的，属于进入的 HTTP 请求。
- en: 'Let’s see what happened on the storage:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看存储上发生了什么：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `TraceId` value is the same on the frontend and storage, so we have cross-process
    log correlation out of the box.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceId` 值在前端和存储上是相同的，因此我们默认具有跨进程日志关联。'
- en: 'If we had OpenTelemetry configured, we’d see a trace similar to that shown
    in *Figure 2**.2*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们配置了 OpenTelemetry，我们会看到类似于 *图 2.2* 中所示的跟踪。2*：
- en: '![Figure 2.2 – Communication between the frontend and storage](img/B19423_02_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 前端和存储之间的通信](img/B19423_02_02.jpg)'
- en: Figure 2.2 – Communication between the frontend and storage
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 前端和存储之间的通信
- en: We already know that ASP.NET Core creates an activity for each request – it
    reads trace context headers by default, but we can configure a different propagator.
    So, when we make an outgoing request from the frontend to storage, `HttpClient`
    creates another activity – a child of the ASP.NET Core one. `HttpClient` injects
    the trace context from its activity to the outgoing request headers so that they
    flow to the storage service, where ASP.NET Core parses them and creates a new
    activity, which becomes a child of the outgoing request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道 ASP.NET Core 为每个请求创建一个活动 – 它默认读取跟踪上下文头信息，但我们可以配置不同的传播者。因此，当我们从前端向存储发出请求时，`HttpClient`
    创建另一个活动 – ASP.NET Core 的子活动。`HttpClient` 将其活动的跟踪上下文注入到发出的请求头中，以便它们流向存储服务，在那里 ASP.NET
    Core 解析它们并创建一个新的活动，该活动成为发出请求的子活动。
- en: Even though we didn’t export activities, they are created and are used to enrich
    the logs with trace context, enabling correlation across different services.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有导出活动，但它们被创建并用于通过跟踪上下文丰富日志，从而实现跨不同服务之间的关联。
- en: Without exporting activities, we achieve correlation but not causation. As you
    can see in the logs, `ParentId` on storage is not the same as `SpanId` on the
    outgoing HTTP request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有导出活动的情况下，我们实现了关联，但没有因果关系。正如你在日志中看到的，存储上的 `ParentId` 与出站 HTTP 请求上的 `SpanId`
    不相同。
- en: Hint on causation
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于因果关系的提示
- en: What happens here is that the outgoing request activity is created inside `HttpClient`,
    which does not write logs with `ILogger`. The log record on the outgoing request
    we just saw is written by the handler in the `Microsoft.Extensions.Http` package.
    This handler is configured by ASP.NET Core. When the handler logs that the request
    is starting, the `HttpClient` activity has not yet been created, and when the
    handler logs that the request is ended, the `HttpClient` activity is already stopped.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，出站请求活动是在 `HttpClient` 内部创建的，它不会使用 `ILogger` 写入日志。我们刚才看到的出站请求的日志记录是由
    `Microsoft.Extensions.Http` 包中的处理器编写的。这个处理器由 ASP.NET Core 配置。当处理器记录请求开始时，`HttpClient`
    活动尚未创建，而当处理器记录请求结束时，`HttpClient` 活动已经停止。
- en: So, with ASP.NET Core and ILogger, we can easily enable log correlation. However,
    logs don’t substitute distributed traces – they just provide additional details.
    Logs also don’t need to duplicate traces.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用 ASP.NET Core 和 ILogger，我们可以轻松地启用日志关联。然而，日志不能替代分布式跟踪——它们只是提供了额外的细节。日志也不需要重复跟踪。
- en: '*Avoiding duplication is important: once, the author saved a company $80k a
    month by dropping logs that were duplicated by* *rich events.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*避免重复非常重要：作者曾经通过删除由* *丰富事件* *重复的日志，为公司节省了每月 80k 美元。*'
- en: Going forward in this book, we’ll use logs for debugging and capturing additional
    information that covers gaps in traces.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书接下来的内容中，我们将使用日志进行调试和捕获覆盖跟踪空白点的额外信息。
- en: Using logs in production
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生产中使用日志
- en: To record logs in production, where we have multiple instances of services and
    restricted access to them, we usually need a log management system – a set of
    tools that collect and send logs to a central location, potentially enriching,
    filtering, or parsing them along the way. OpenTelemetry can help us collect logs,
    but we also need a backend to store, index, and query the logs using any context,
    including `TraceId`. With this, we can easily navigate from traces to logs when
    needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中记录日志，我们通常需要一个日志管理系统——一组工具，它们收集并发送日志到中央位置，可能在这个过程中丰富、过滤或解析它们。OpenTelemetry
    可以帮助我们收集日志，但我们还需要一个后端来存储、索引和查询日志，使用任何上下文，包括 `TraceId`。这样，我们就可以在需要时轻松地从跟踪导航到日志。
- en: On-demand logging with dotnet-monitor
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dotnet-monitor 进行按需日志记录
- en: It could be useful to dynamically increase log verbosity at runtime to get more
    detailed information while reproducing the issue or, when the log exporting pipeline
    is broken, get logs from the service directly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在重现问题或当日志导出管道损坏时，动态增加日志详细程度以获取更多详细信息可能是有用的，或者直接从服务中获取日志。
- en: It’s possible with `dotnet-monitor` – a diagnostics tool that’s able to connect
    to a specific .NET process and capture logs, counters, profiles, and core dumps.
    We’ll talk about it in [*Chapter 3*](B19423_03.xhtml#_idTextAnchor052), The *.NET*
    *Observability Ecosystem*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dotnet-monitor` 是可能的——这是一个能够连接到特定 .NET 进程并捕获日志、计数器、配置文件和核心转储的诊断工具。我们将在 [*第
    3 章*](B19423_03.xhtml#_idTextAnchor052)，*.NET* *可观察性生态系统* 中讨论它。
- en: 'Let’s install and start `dotnet-monitor` to see what it can do:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装并启动 `dotnet-monitor` 来看看它能做什么：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re on macOS or Linux, you need to authenticate requests to the `dotnet-monitor`
    REST API. Please refer to the documentation at `https://github.com/dotnet/dotnet-monitor/blob/main/documentation/authentication.md`
    or, for demo purposes only, disable authentication with the `dotnet monitor collect
    –``no-auth` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS 或 Linux，你需要对 `dotnet-monitor` REST API 的请求进行身份验证。请参阅 `https://github.com/dotnet/dotnet-monitor/blob/main/documentation/authentication.md`
    中的文档，或者仅用于演示目的，使用 `dotnet monitor collect –no-auth` 命令禁用身份验证。
- en: 'If you still have frontend and storage services running, you should see them
    among the other .NET processes on your machine when you open `https://localhost:52323/processes`
    in your browser:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然运行着前端和存储服务，当你通过浏览器打开 `https://localhost:52323/processes` 时，你应该能在你的机器上的其他
    .NET 进程中看到它们：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let’s capture some debug logs from storage via `dotnet-monitor` by requesting
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过请求以下内容来通过 `dotnet-monitor` 从存储中捕获一些调试日志：
- en: '`https://localhost:52323/logs?pid=27020&level=debug&duration=60`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:52323/logs?pid=27020&level=debug&duration=60`'
- en: 'It connects to the process first, enables the requested log level, and then
    starts streaming logs to the browser for 60 seconds. It doesn’t change the logging
    level in the main logging pipeline, but will return the requested logs directly
    to you, as shown in *Figure 2**.3*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先连接到进程，启用请求的日志级别，然后开始将日志流式传输到浏览器 60 秒。它不会更改主日志管道中的日志级别，但会直接将请求的日志返回给您，如图 *图
    2.3* 所示。
- en: "![Figure 2.3 – A\uFEFFd hoc logging with dynamic level using dotnet-monitor](img/B19423_02_03.jpg)"
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 使用 dotnet-monitor 进行动态级别临时日志记录](img/B19423_02_03.jpg)'
- en: Figure 2.3 – Ad hoc logging with dynamic level using dotnet-monitor
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 使用 dotnet-monitor 进行动态级别临时日志记录
- en: You can apply a more advanced configuration using the POST logs API – check
    out https://github.com/dotnet/dotnet-monitor to learn more about it and other
    `dotnet-monitor` features.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 POST 日志 API 应用更高级的配置 – 查看https://github.com/dotnet/dotnet-monitor 了解更多相关信息以及其他
    `dotnet-monitor` 功能。
- en: Using `dotnet-monitor` in production on a multi-instance service with restricted
    SSH access can be challenging. Let’s see how we can do it by running `dotnet-monitor`
    as a sidecar in Docker. It’s also possible to run it as a sidecar in Kubernetes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有受限 SSH 访问的多实例服务上在生产环境中使用 `dotnet-monitor` 可能具有挑战性。让我们通过在 Docker 中以边车形式运行
    `dotnet-monitor` 来看看我们如何做到这一点。它也可以在 Kubernetes 中作为边车运行。
- en: Monitoring with runtime counters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用运行时计数器进行监控
- en: So, we have correlated logs from the platform and services with which we can
    debug issues. But what about system health and performance? .NET and ASP.NET Core
    expose event counters that can give some insights into the overall system state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有来自平台和服务的相关日志，我们可以用它们来调试问题。但关于系统健康和性能呢？.NET 和 ASP.NET Core 提供了事件计数器，可以提供一些关于整体系统状态的见解。
- en: We can collect counters with OpenTelemetry without running and managing `dotnet-monitor`.
    But if your metrics pipeline is broken (or if you don’t have one yet), you can
    attach `dotnet-monitor` to your process for ad hoc analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不运行和管理 `dotnet-monitor` 的情况下使用 OpenTelemetry 收集计数器。但如果您的指标管道损坏（或者您还没有一个），您可以将
    `dotnet-monitor`附加到您的进程上进行临时分析。
- en: '`dotnet-monitor` listens to `EventCounters` reported by the .NET runtime and
    returns them on an HTTP endpoint in **Prometheus** **exposition format**.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet-monitor` 监听 .NET 运行时报告的 `EventCounters`，并将它们以 **Prometheus** **暴露格式**
    返回到 HTTP 端点。'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Prometheus** is a metrics platform that scrapes and stores metrics. It supports
    multidimensional data and allows us to slice, dice, filter, and calculate derived
    metrics using **PromQL**.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prometheus** 是一个抓取和存储指标的指标平台。它支持多维数据，并允许我们使用 **PromQL** 对数据进行切片、切块、过滤和计算派生指标。'
- en: 'We’re going to run our service as a set of Docker containers with `dotnet-monitor`
    running as a sidecar for the frontend and storage, and configure Prometheus to
    scrape metrics from `dotnet-monitor` sidecars, as shown in *Figure 2**.4*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行我们的服务作为一组 Docker 容器，其中 `dotnet-monitor` 作为前端和存储的边车运行，并将 Prometheus 配置为抓取来自
    `dotnet-monitor` 边车的指标，如图 *图 2.4* 所示。
- en: '![Figure 2.4 – Meme services with runtime counters in Prometheus](img/B19423_02_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 在 Prometheus 中具有运行时计数器的 Meme 服务](img/B19423_02_04.jpg)'
- en: Figure 2.4 – Meme services with runtime counters in Prometheus
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 在 Prometheus 中具有运行时计数器的 Meme 服务
- en: This makes our setup closer to real life, where we don’t have the luxury of
    running `dotnet-monitor` on the service instance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的设置更接近现实生活，在那里我们没有在服务实例上运行 `dotnet-monitor` 的便利。
- en: 'So, let’s go ahead and run our application. Open the terminal, navigate to
    the `chapter2` folder, and run the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续运行我们的应用程序。打开终端，导航到 `chapter2` 文件夹，并运行以下命令：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might see some errors while MySQL is starting up. Let’s ignore them for
    now. After a few seconds, you should be able to reach the frontend via the same
    URL as before.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MySQL 启动时，您可能会看到一些错误。现在我们先忽略它们。几秒钟后，您应该能够通过之前的相同 URL 访问前端。
- en: 'Let’s explore the CPU and memory counters published by the .NET Runtime:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索由 .NET 运行时发布的 CPU 和内存计数器：
- en: '`cpu-usage` event counter (reported as `systemruntime_cpu_usage_ratio` metric
    to Prometheus): Represents the CPU usage as a percentage.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu-usage` 事件计数器（报告为 `systemruntime_cpu_usage_ratio` 指标到 Prometheus）：表示 CPU
    使用率作为百分比。'
- en: '`gc-heap-size` (or `systemruntime_gc_heap_size_bytes`): Represents the approximate
    allocated managed memory size in megabytes.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gc-heap-size`（或 `systemruntime_gc_heap_size_bytes`）：表示以兆字节为单位的近似已分配托管内存大小。'
- en: '`time-in-gc` (or `systemruntime_time_in_gc_ratio`): Represents time spent on
    garbage collection since the last garbage collection.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time-in-gc`（或 `systemruntime_time_in_gc_ratio`）：表示自上次垃圾回收以来在垃圾回收上花费的时间。'
- en: '`gen-0-gc-count`, `gen-1-gc-count`, and `gen-2-gc-count` (or `systemruntime_gen_<gen>_gc_count`):
    Represents the count of garbage collections in the corresponding generation per
    interval. The default update interval is 5 seconds, but you can adjust it. Generation
    sizes are also exposed as counters.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gen-0-gc-count`、`gen-1-gc-count` 和 `gen-2-gc-count`（或 `systemruntime_gen_<gen>_gc_count`）：表示每个间隔对应生成中垃圾回收的计数。默认更新间隔为
    5 秒，但您可以调整它。生成大小也作为计数器公开。'
- en: '`alloc-rate` (or `systemruntime_alloc_rate_bytes`): Represents the allocation
    rate in bytes per interval.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alloc-rate`（或 `systemruntime_alloc_rate_bytes`）：表示每个间隔的字节分配率。'
- en: You can also find counters coming from Kestrel, Sockets, TLS, and DNS that can
    be useful to investigate specific issues such as DNS outages, long request queues,
    or socket exhaustion on HTTP servers. Check out the .NET documentation for the
    full list (https://learn.microsoft.com/dotnet/core/diagnostics/available-counters).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以找到来自 Kestrel、Sockets、TLS 和 DNS 的计数器，这些计数器可以用于调查特定问题，例如 DNS 故障、长请求队列或 HTTP
    服务器上的套接字耗尽。请查看 .NET 文档以获取完整列表（https://learn.microsoft.com/dotnet/core/diagnostics/available-counters）。
- en: ASP.NET Core and `HttpClient` request counters don’t have dimensions, but would
    be useful if you didn’t have OpenTelemetry tracing or metrics and wanted to get
    a very rough idea about throughput and failure rate across all APIs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 和 `HttpClient` 请求计数器没有维度，但如果您没有 OpenTelemetry 跟踪或度量，它们将非常有用，可以大致了解所有
    API 的吞吐量和失败率。
- en: 'Prometheus scrapes metrics from the `dotnet-monitor` metrics endpoint. We can
    access it ourselves to see the raw data, as shown in *Figure 2**.5*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 从 `dotnet-monitor` 度量端点抓取度量。我们可以自己访问它来查看原始数据，如图 *图 2.5* 所示。5：
- en: '![Figure 2.5 – Frontend metrics in Prometheus exposure format](img/B19423_02_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – Prometheus 中暴露的前端度量](img/B19423_02_05.jpg)'
- en: Figure 2.5 – Frontend metrics in Prometheus exposure format
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – Prometheus 中暴露的前端度量格式
- en: It’s also possible to query and plot basic visualizations with Prometheus, as
    you can see in *Figure 2**.6*. Just hit `http://localhost:9090/graph`. For any
    advanced visualizations or dashboards, we would need tooling that integrates with
    Prometheus, such as **Grafana**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 Prometheus 查询和绘制基本可视化，如图 *图 2.6* 所示。只需点击 `http://localhost:9090/graph`。对于任何高级可视化或仪表板，我们需要与
    Prometheus 集成的工具，例如 **Grafana**。
- en: '![Figure 2.6 – GC memory heap size for frontend and storage services in Prometheus](img/B19423_02_06.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – Prometheus 中前端和存储服务器的 GC 内存堆大小](img/B19423_02_06.jpg)'
- en: Figure 2.6 – GC memory heap size for frontend and storage services in Prometheus
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – Prometheus 中前端和存储服务器的 GC 内存堆大小
- en: As you can see, even basic ASP.NET Core applications come with minimal monitoring
    capabilities – counters for overall system health and correlated logs for debugging.
    With `dotnet-monitor` we can even retrieve telemetry at runtime without changing
    the code or restarting the application (well, of course, only if we have access
    to the application instance).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使是基本的 ASP.NET Core 应用也自带了最小的监控能力——整体系统健康的计数器和用于调试的相关日志。使用 `dotnet-monitor`，我们甚至可以在不更改代码或重启应用程序的情况下（当然，前提是我们有权访问应用程序实例）在运行时检索遥测数据。
- en: With some additional infrastructure changes to run `dotnet-monitor` as a sidecar
    and logging management solution, we would be able to build a very basic production
    monitoring solution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对运行 `dotnet-monitor` 作为边车和日志管理解决方案的一些额外基础设施更改，我们将能够构建一个非常基本的实时监控解决方案。
- en: We still lack distributed tracing and metrics that have rich context. Let’s
    now see how to enable them with OpenTelemetry instrumentation and improve this
    experience further.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少具有丰富上下文的分布式跟踪和度量。现在让我们看看如何通过 OpenTelemetry 仪表板启用它们，并进一步改善这一体验。
- en: Enabling auto-collection with OpenTelemetry
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 启用自动收集
- en: In this section, we’re going to add OpenTelemetry to our demo application and
    enable auto-collection for ASP.NET Core, `HttpClient`, Entity Framework, and runtime
    metrics. We’ll see what it adds to the bare-bones monitoring experience.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的演示应用程序添加 OpenTelemetry，并启用 ASP.NET Core、`HttpClient`、Entity Framework
    和运行时度量的自动收集。我们将看到它为裸骨监控体验添加了什么。
- en: 'We’ll export traces to Jaeger and metrics to Prometheus, as shown in *Figure
    2**.7*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将跟踪导出到Jaeger，并将指标导出到Prometheus，如图*2.7*所示：
- en: '![Figure 2.7 – Meme services sending telemetry to Jaeger and Prometheus](img/B19423_02_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – Meme服务向Jaeger和Prometheus发送遥测数据](img/B19423_02_07.jpg)'
- en: Figure 2.7 – Meme services sending telemetry to Jaeger and Prometheus
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Meme服务向Jaeger和Prometheus发送遥测数据
- en: You can also send data directly to your observability backend if it has an OTLP
    endpoint, or you can configure a backend-specific exporter in the application.
    So, let’s get started and instrument our application with OpenTelemetry.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的可观察性后端有OTLP端点，您可以直接向其发送数据，或者您可以在应用程序中配置特定后端的导出器。那么，让我们开始使用OpenTelemetry检测我们的应用程序。
- en: Installing and configuring OpenTelemetry
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置OpenTelemetry
- en: 'OpenTelemetry comes as a set of NuGet packages. Here are a few that we’re using
    in our demo app:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry作为一系列NuGet包提供。以下是我们演示应用程序中使用的几个包：
- en: '`OpenTelemetry`: The SDK that contains all that we need to produce traces and
    metrics and configure a generic processing and export pipeline. It does not collect
    any telemetry on its own.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry`：包含我们生成跟踪和指标以及配置通用处理和导出管道所需的一切的SDK。它本身不收集任何遥测数据。'
- en: '`OpenTelemetry.Exporter.Jaeger`: This package contains a trace exporter that
    publishes spans to Jaeger.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Exporter.Jaeger`：此包包含一个跟踪导出器，将跨度发布到Jaeger。'
- en: '`OpenTelemetry.Exporter.Prometheus.AspNetCore`: This package contains the Prometheus
    exporter. It creates a new `/metrics` endpoint for Prometheus to scrape metrics
    from.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Exporter.Prometheus.AspNetCore`：此包包含Prometheus导出器。它为Prometheus创建一个新的`/metrics`端点以抓取指标。'
- en: '`OpenTelemetry.Extensions.Hosting`: This package simplifies OpenTelemetry configuration
    in ASP.NET Core applications.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Extensions.Hosting`：此包简化了ASP.NET Core应用程序中的OpenTelemetry配置。'
- en: '`OpenTelemetry.Instrumentation.AspNetCore`: This package enables ASP.NET Core
    tracing and metrics auto-instrumentation.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Instrumentation.AspNetCore`：此包为ASP.NET Core启用跟踪和指标自动检测。'
- en: '`OpenTelemetry.Instrumentation.Http`: This package enables tracing and metrics
    auto-instrumentation for `System.Net.HttpClient`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Instrumentation.Http`：此包为`System.Net.HttpClient`启用跟踪和指标自动检测。'
- en: '`OpenTelemetry.Instrumentation.EntityFrameworkCore`: Tracing instrumentation
    for Entity Framework Core. We only need it for the storage service.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Instrumentation.EntityFrameworkCore`：Entity Framework Core的跟踪检测。我们只需要它用于存储服务。'
- en: '`OpenTelemetry.Instrumentation.Process` and `OpenTelemetry.Instrumentation.Runtime`:
    These two packages enable process-level metrics for CPU and memory utilization
    and include the runtime counters we saw previously with `dotnet-monitor`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenTelemetry.Instrumentation.Process`和`OpenTelemetry.Instrumentation.Runtime`：这两个包为CPU和内存利用率启用进程级指标，并包括我们在`dotnet-monitor`中之前看到的运行时计数器。'
- en: You can also enable other counter sources one by one with the `OpenTelemetry.Instrumentation.EventCounters`
    package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以逐个启用其他计数器源，使用`OpenTelemetry.Instrumentation.EventCounters`包。
- en: Distributed tracing
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式跟踪
- en: 'To configure tracing, first call `AddOpenTelemetry` extension method on `IServiceCollection`
    and then call the W`ithTracing` method, as shown in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置跟踪，首先在`IServiceCollection`上调用`AddOpenTelemetry`扩展方法，然后调用`WithTracing`方法，如下例所示：
- en: Program.cs
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
- en: Here, we’re adding the Jaeger exporter and enabling `HttpClient`, ASP.NET Core,
    and Entity Framework instrumentations (on storage).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了Jaeger导出器，并启用了`HttpClient`、ASP.NET Core和Entity Framework检测（在存储上）。
- en: We’re also configuring the service name via the `OTEL_SERVICE_NAME` environment
    variable in `launchSetting.json` and in `docker-compose-otel.yml` for Docker runs.
    The OpenTelemetry SDK reads it and sets the `service.name` resource attribute
    accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`launchSetting.json`和`docker-compose-otel.yml`中的`OTEL_SERVICE_NAME`环境变量配置服务名称，以便在Docker运行时。OpenTelemetry
    SDK读取它并相应地设置`service.name`资源属性。
- en: The Jaeger host is configured with the `OTEL_EXPORTER_JAEGER_AGENT_HOST` environment
    variable in `docker-compose-otel.yml`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger主机通过`docker-compose-otel.yml`中的`OTEL_EXPORTER_JAEGER_AGENT_HOST`环境变量进行配置。
- en: We’ll talk more about configuration in [*Chapter 5*](B19423_05.xhtml#_idTextAnchor083),
    *Configuration and Control Plane*, and learn how to configure sampling, enrich
    telemetry, and add custom sources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B19423_05.xhtml#_idTextAnchor083)“配置和控制平面”中更多地讨论配置，并学习如何配置采样、丰富遥测数据以及添加自定义源。
- en: Metrics
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指标
- en: Metrics configuration is similar – we first call the `AddOpenTelemetry` extension
    method on `IServiceCollection` and then in the `WithMetrics` callback set up the
    Prometheus exporter and auto-instrumentations for `HttpClient`, ASP.NET Core,
    Process, and Runtime. Entity Framework’s instrumentation does not report metrics.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 指标配置类似——我们首先在`IServiceCollection`上调用`AddOpenTelemetry`扩展方法，然后在`WithMetrics`回调中设置
    Prometheus 导出器和`HttpClient`、ASP.NET Core、进程和运行时的自动检测。Entity Framework 的检测不报告指标。
- en: Program.cs
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
- en: 'We also need to expose the Prometheus endpoint after building the application
    instance:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序实例之后，我们还需要暴露 Prometheus 端点：
- en: Program.cs
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Program.cs
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter2/storage/Program.cs)'
- en: We’re ready to run the application!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行应用程序了！
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see logs from all services including some errors while MySQL is
    starting up. Check the frontend to make sure it works: `https://localhost:5051/Meme?name=dotnet`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到所有服务的日志，包括 MySQL 启动时的一些错误。检查前端以确保它正常工作：`https://localhost:5051/Meme?name=dotnet`。
- en: Exploring auto-generated telemetry
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自动生成的遥测数据
- en: The meme service is now up and running. Feel free to upload your favorite memes
    and if you see any issues, use telemetry to debug them!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表情包服务已经启动并运行。请随意上传您最喜欢的表情包，如果您看到任何问题，请使用遥测数据进行调试！
- en: Debugging
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: If you try to upload something right after the service starts, you might get
    an error like the one shown in *Figure 2**.8*. Let’s figure out why!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在服务启动后立即上传某些内容，你可能会得到如图**图2.8**所示的错误。让我们找出原因！
- en: '![Figure 2.8 – Error from application with traceparent](img/B19423_02_08.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.8 – Error from application with traceparent](img/B19423_02_08.jpg)'
- en: Figure 2.8 – Error from application with traceparent
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.8** – 带有 traceparent 的应用程序错误'
- en: 'We can approach this investigation from two angles. The first is to use the
    `traceparent` shown on the page; the second is to filter the traces from the frontend
    based on the error status.     In any case, let’s go to Jaeger – our tracing backend running on `http://localhost:16686/`.
    We can search by `Trace ID` or filter by service and error, as shown in *Figure
    2**.9*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从两个角度来接近这个调查。第一个是使用页面上的`traceparent`；第二个是根据错误状态从前端过滤跟踪。无论如何，让我们去 Jaeger——我们的跟踪后端运行在`http://localhost:16686/`。我们可以通过`Trace
    ID`搜索或根据服务错误过滤，如图**图2.9**所示：
- en: '![Figure 2.9 – Find the trace in Jaeger by Trace ID (1) or with a combination
    of the service (2) and error (3)](img/B19423_02_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.9 – Find the trace in Jaeger by Trace ID (1) or with a combination
    of the service (2) and error (3)](img/B19423_02_09.jpg)'
- en: Figure 2.9 – Find the trace in Jaeger by Trace ID (1) or with a combination
    of the service (2) and error (3)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.9** – 通过 Trace ID（1）或服务（2）和错误（3）的组合在 Jaeger 中找到跟踪'
- en: If we open the trace, we’ll see that the storage service refused the connection
    – check out *Figure 2**.10*. What happened here?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开跟踪，我们会看到存储服务拒绝了连接——查看**图2.10**。这里发生了什么？
- en: '![Figure 2.10 – Drill down into the trace: the frontend service could not reach
    the storage](img/B19423_02_10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 2.10 – Drill down into the trace: the frontend service could not reach
    the storage](img/B19423_02_10.jpg)'
- en: 'Figure 2.10 – Drill down into the trace: the frontend service could not reach
    the storage'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.10** – 深入跟踪：前端服务无法访问存储'
- en: 'Since there are no traces from the storage, let’s check the storage logs with
    `docker logs chapter2-storage-1`. We’ll query the logs in a more convenient way
    in [*Chapter 8*](B19423_08.xhtml#_idTextAnchor131), *Writing Structured and Correlated
    Logs*. For now, let’s just grep storage logs around the time the issue occurred
    and find the relevant record, as shown in *Figure 2**.11*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有来自存储的跟踪，让我们用 `docker logs chapter2-storage-1` 检查存储日志。我们将在 [*第 8 章*](B19423_08.xhtml#_idTextAnchor131)，*编写结构化和关联日志*
    中以更方便的方式查询日志。现在，让我们只是 grep 存储日志在问题发生的时间附近，并找到相关的记录，如图 *图 2**.11* 所示：
- en: '![Figure 2.11 – Connection error in storage stdout](img/B19423_02_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 存储标准输出中的连接错误](img/B19423_02_11.jpg)'
- en: Figure 2.11 – Connection error in storage stdout
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 存储标准输出中的连接错误
- en: Apparently, the storage was not able to connect to the MySQL server and it could
    not start until the connection was established. If we dig further into the MySQL
    logs, we’ll discover that it took a while for it to start, but then everything
    worked just fine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，存储无法连接到 MySQL 服务器，并且它只能在建立连接后才能启动。如果我们进一步挖掘 MySQL 日志，我们会发现它启动花费了一段时间，但之后一切工作正常。
- en: Some action items from this investigation are to enable retries on the frontend
    and investigate the slow start for MySQL. If it happens in production where there
    are multiple instances of storage, we should also dig into the load balancer and
    service discovery behavior.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次调查中得出的某些行动项是：在前端启用重试并调查 MySQL 的缓慢启动。如果它在生产环境中发生，并且有多个存储实例，我们还应该深入了解负载均衡器和服务发现行为。
- en: What tracing brings here is *convenience* – we could have done the same investigation
    with logs alone, but it would have taken longer and would be more difficult. Assuming
    we dealt with a more complicated case with dozens of requests over multiple services,
    parsing logs would simply not be a reasonable option.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪带来的便利性在于 – 我们本可以用日志单独完成同样的调查，但这会花费更长的时间，并且会更困难。假设我们处理的是一个更复杂的案例，涉及多个服务中的数十个请求，解析日志将根本不是一个合理的选项。
- en: As we can see in this example, tracing can help us narrow the problem down,
    but sometimes we still need logs to understand what’s going on, especially for
    issues during startup.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个例子中所看到的，追踪可以帮助我们缩小问题范围，但有时我们仍然需要日志来了解正在发生的事情，尤其是在启动期间的问题。
- en: Performance
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: Let’s check out some metrics collected by the HTTP and runtime instrumentations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一些由 HTTP 和运行时仪器收集的指标。
- en: OpenTelemetry defines `http.server.duration` and `http.client.duration` **histogram**
    metrics with low-cardinality attributes for method, API route (server only), and
    status code. These metrics allow us to calculate latency percentiles, throughputs,
    and error rates.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 定义了具有低基数属性的 `http.server.duration` 和 `http.client.duration` **直方图**指标，包括方法、API
    路由（仅限服务器）和状态码。这些指标允许我们计算延迟百分位数、吞吐量和错误率。
- en: With OpenTelemetry metrics, ASP.NET Core instrumentation can populate API routes
    so we can finally analyze latency, throughput, and error rate per route. And histograms
    give us even more flexibility – we can now check the distribution of latency rather
    than the median, average, or a predefined set of percentiles.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 指标，ASP.NET Core 仪器可以填充 API 路由，这样我们就可以最终分析每个路由的延迟、吞吐量和错误率。并且直方图提供了更多的灵活性
    – 我们现在可以检查延迟的分布，而不仅仅是中位数、平均值或预定义的百分位数集合。
- en: Latency
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟
- en: HTTP client latency can be defined as the time between initiating a request
    and the response being received. For servers, it’s the time between receiving
    a request and the end of the server’s response.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 客户端延迟可以定义为发起请求与收到响应之间的时间。对于服务器来说，是收到请求与服务器响应结束之间的时间。
- en: Tip
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When analyzing latency, filter out errors and check the distribution of latency
    rather than just averages or medians. It’s common to check the 95th percentile
    (aka P95).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析延迟时，过滤掉错误并检查延迟的分布，而不仅仅是平均值或中位数。通常检查第 95 个百分位数（也称为 P95）。
- en: '*Figure 2**.12* shows P95 latency for the `PUT /meme` API on the client and
    server side:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2**.12* 显示了客户端和服务器端 `PUT /meme` API 的 P95 延迟：'
- en: '![Figure 2.12 – Server versus client PUT /meme latency P95 in milliseconds](img/B19423_02_12.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 服务器与客户端 PUT /meme 延迟 P95（以毫秒为单位）](img/B19423_02_12.jpg)'
- en: Figure 2.12 – Server versus client PUT /meme latency P95 in milliseconds
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 服务器与客户端 PUT /meme 延迟 P95（以毫秒为单位）
- en: Time to first byte versus time to last byte
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 首字节时间与最后字节时间
- en: In .NET, `HttpClient` buffers a response before returning it, but it can be
    configured to return the response right after the headers are received with `HttpCompletionOptions`.
    `HttpClient` instrumentation can’t measure time-to-last-byte in this case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，`HttpClient` 在返回响应之前会缓冲响应，但可以通过 `HttpCompletionOptions` 配置在接收到头部后立即返回响应。在这种情况下，`HttpClient`
    仪表无法测量时间到最后一字节。
- en: The distinction between *time to first body byte* versus *time to last byte*
    can be important on frontends with clients using unreliable connections or when
    transferring a lot of data. In such cases, it’s useful to instrument stream operations
    and then measure the time to first byte *and* time to last byte. You can use the
    difference between these metrics to get an idea about connection quality and optimize
    the end user experience.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端使用不可靠连接或传输大量数据的客户端中，*时间到第一个字节*与*时间到最后一个字节*之间的区别可能很重要。在这种情况下，对流操作进行仪表化并测量时间到第一个字节和最后一个字节是有用的。您可以通过这些指标之间的差异来了解连接质量并优化最终用户体验。
- en: Error rate
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误率
- en: 'Error rate is just a rate of unsuccessful requests per a given period of time.
    The key question here is what constitutes an error:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 错误率只是给定时间段内每项请求的不成功请求的比率。这里的关键问题是什么构成了错误：
- en: '`1xx`, `2xx`, and `3xx` status codes indicate success.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1xx`、`2xx` 和 `3xx` 状态码表示成功。'
- en: '`5xx` codes cover errors such as the lack of a response, a disconnected client,
    network, or DNS issues.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5xx` 代码涵盖了诸如无响应、断开客户端、网络或 DNS 问题等错误。'
- en: Status codes in the `4xx` range are hard to categorize. For example, `404` could
    represent an issue – maybe the client expected to retrieve the data but it’s not
    there – but could also be a positive scenario, where the client is checking whether
    a resource exists before creating or updating it. There are similar concerns with
    other statuses.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4xx` 范围内的状态码难以分类。例如，`404` 可能代表一个问题 – 可能是客户端期望检索数据但数据不存在 – 但也可能是积极的场景，其中客户端在创建或更新资源之前检查资源是否存在。其他状态也存在类似的问题。'
- en: Note
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: OpenTelemetry only marks client spans with `4xx` as errors. We’ll see in [*Chapter
    5*](B19423_05.xhtml#_idTextAnchor083), *Configuration and Control Plane*, how
    to tailor it to your needs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 只将 `4xx` 作为错误标记为客户端跨度。我们将在 [*第 5 章*](B19423_05.xhtml#_idTextAnchor083)，*配置和控制平面*
    中看到如何根据您的需求定制它。
- en: It’s also common to treat latency above a given threshold as an error to measure
    availability, but we don’t strictly need it for observability purposes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常也会将超过给定阈值的延迟视为错误来衡量可用性，但为了可观察性目的，我们并不严格需要它。
- en: '*Figure 2**.13* shows an example of a server error rate chart for a single
    API grouped by error code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2.13* 展示了按错误代码分组的单个 API 服务器错误率图表的示例：'
- en: "![Figure 2.13 – Error rate per second for \uFEFFthe GET/meme API grouped by\
    \ error code](img/B19423_02_13.jpg)"
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 按错误代码分组的 GET/meme API 每秒错误率](img/B19423_02_13.jpg)'
- en: Figure 2.13 – Error rate per second for the GET/meme API grouped by error code
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 按错误代码分组的 GET/meme API 每秒错误率
- en: It is also important to calculate the error rate per API route and method on
    servers. Because of different request rates, it’s easy to miss spikes or changes
    in less frequently called APIs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 计算服务器上每个 API 路由和方法的错误率也很重要。由于不同的请求速率，很容易错过调用频率较低的 API 的峰值或变化。
- en: Tip
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Returning precise status codes for ‘‘known’’ errors and letting the service
    return `500` only for unhandled exceptions makes it easier to use your service,
    but also simplifies monitoring and alerting. By looking at the error code, we
    can discern the possible reasons and not waste time on known cases. Any `500`
    response becomes important to investigate and fix or handle properly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“已知”错误返回精确的状态码，而只让服务在未处理的异常时返回 `500`，这使得使用您的服务变得更容易，同时也简化了监控和警报。通过查看错误代码，我们可以辨别可能的原因，并避免在已知情况下浪费时间。任何
    `500` 响应都变得重要，需要调查和修复或妥善处理。
- en: 'To check resource consumption, we can use runtime and process metrics. For
    example, *Figure 2**.14* shows CPU usage:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 检查资源消耗，我们可以使用运行时和进程指标。例如，*图 2.14* 展示了 CPU 使用率：
- en: '![Figure 2.14 – CPU usage query](img/B19423_02_14.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – CPU 使用率查询](img/B19423_02_14.jpg)'
- en: Figure 2.14 – CPU usage query
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – CPU 使用率查询
- en: The query returns the average CPU utilization percentage across all instances
    for each service represented by job dimension – we configured jobs in `configs/prometheus-otel.yml`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回了所有实例中每个由作业维度表示的服务平均 CPU 利用率百分比 – 我们在 `configs/prometheus-otel.yml` 中配置了作业。
- en: 'The state dimension divides processor time into user and privileged (system)
    time. To calculate the total average CPU usage per instance per service, we could
    write another Prometheus query:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 状态维度将处理器时间分为用户时间和特权（系统）时间。为了计算每个服务每个实例的总平均 CPU 使用率，我们可以编写另一个 Prometheus 查询：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The query calculates the total CPU usage per instance and then calculates the
    average value per service.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询计算每个实例的总 CPU 使用率，然后计算每个服务的平均值。
- en: As you can see, the Prometheus query language is a powerful tool allowing us
    to calculate derived metrics and slice, dice, and filter them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Prometheus 查询语言是一个强大的工具，它允许我们计算派生指标，并对它们进行切片、切块和过滤。
- en: We’ll see more examples of runtime metrics and performance analysis in [*Chapter
    4*](B19423_04.xhtml#_idTextAnchor068), *Low-Level Performance Analysis with* *Diagnostic
    Tools*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 4 章*](B19423_04.xhtml#_idTextAnchor068)，*使用诊断工具进行低级性能分析* 中看到更多关于运行时指标和性能分析的示例。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored .NET diagnostics and monitoring capabilities supported
    by the platform and frameworks. ASP.NET Core context propagation is enabled by
    default and logging providers can use it to correlate logs. We need a log management
    system to be able to store logs from multiple instances of a service and efficiently
    query them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了平台和框架支持的 .NET 诊断和监控功能。ASP.NET Core 上下文传播默认启用，日志提供程序可以使用它来关联日志。我们需要一个日志管理系统来存储来自服务多个实例的日志，并有效地查询它们。
- en: '`dotnet-monitor` allows the streaming of logs on demand from specific instances
    of your service, and the scraping of event counters with Prometheus to get a basic
    idea about service health. It can also be used for low-level performance analysis
    and can be run in production.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet-monitor` 允许按需从您服务的特定实例流式传输日志，并使用 Prometheus 抓取事件计数器，以获得关于服务健康的基本概念。它还可以用于低级性能分析，并可以在生产环境中运行。'
- en: Then, we enabled OpenTelemetry auto-instrumentation for the HTTP stack and Entity
    Framework. HTTP and DB traces enable basic debugging capabilities, providing generic
    information on what happened for each remote call. You can search for traces based
    on attributes and query them using your tracing backend. With tracing, we can
    easily find a problematic service or component, and when that’s not enough, we
    can retrieve logs to get more details about the issue. With logs correlated to
    traces, we can easily navigate between them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为 HTTP 栈和 Entity Framework 启用了 OpenTelemetry 自动仪器化。HTTP 和 DB 跟踪启用了基本的调试功能，为每个远程调用提供了通用信息。您可以根据属性搜索跟踪，并使用您的跟踪后端进行查询。有了跟踪，我们可以轻松地找到有问题的服务或组件，如果这还不够，我们可以检索日志以获取更多关于问题的详细信息。通过将日志与跟踪关联起来，我们可以轻松地在它们之间导航。
- en: HTTP metrics enable common performance analysis. Depending on your backend,
    you can query, filter, and derive metrics and build dashboards and alerts based
    on them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 指标启用了常见的性能分析。根据您的后端，您可以查询、过滤和派生指标，并基于它们构建仪表板和警报。
- en: Now that we’ve got hands-on experience with basic distributed tracing and metrics,
    let’s explore the .NET ecosystem more and see how you can leverage instrumentation
    for common libraries and infrastructure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对基本的分布式跟踪和指标有了实践经验，让我们更深入地探索 .NET 生态系统，看看您如何利用仪器化来处理常见的库和基础设施。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How would you show trace context on a Razor page?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何在 Razor 页面上显示跟踪上下文？
- en: Imagine that the observability backend stopped receiving telemetry from some
    instances of the service. What can we do to understand what’s going on with these
    instances?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设可观察性后端停止接收来自服务某些实例的遥测数据。我们该如何了解这些实例的情况？
- en: With the help of the Prometheus documentation (https://prometheus.io/docs/prometheus/latest/querying/basics/),
    write a query with PromQL to calculate the throughput (requests per second) per
    service and API.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Prometheus 文档（https://prometheus.io/docs/prometheus/latest/querying/basics/）的帮助下，使用
    PromQL 编写一个查询来计算每个服务和 API 的吞吐量（每秒请求数）。
- en: With our meme service, how would you find out when a meme was uploaded and how
    many times it had been downloaded if you know only the meme’s name?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 meme 服务中，如果您只知道 meme 的名称，您会如何找出 meme 上传的时间和下载次数？
