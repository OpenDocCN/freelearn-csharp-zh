<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Project C &#x2013; a 2D Adventure"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Project C – a 2D Adventure</h1></div></div></div><p>In this chapter, we will begin a completely new project; specifically, a 2D adventure game in which the player controls an alien character, exploring and navigating a dangerous world complete with quests and interactive elements. This project will incorporate elements and ideas from previous chapters as well as focus on new techniques, such as Complex Collisions, 2D Physics, Singletons and Statics, and more. In short, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">2D characters and player movement</li><li class="listitem" style="list-style-type: disc">Assembling complex and multipart characters</li><li class="listitem" style="list-style-type: disc">Level design</li><li class="listitem" style="list-style-type: disc">2D Physics and collision detection<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The starting project and assets can be found in the book companion files in the <code class="literal">Chapter05/Start</code> folder. You can start here and follow along with this chapter if you don't have your own project already.</p></div></div></li></ul></div><div class="section" title="A 2D Adventure – getting started"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>A 2D Adventure – getting started</h1></div></div></div><p>Adventure <a id="id303" class="indexterm"/>games require the player to use their cunning, dexterity, mental sharpness, and acumen to make progress. Such games feature dangerous obstacles, challenging missions, and character interaction, as opposed to <span class="emphasis"><em>all-out</em></span> action like many first-person shooter games. Our adventure game will be no exception. See <span class="emphasis"><em>Figure 5.1</em></span> for a glimpse of the game that we'll create. In this game, the player moves around using the keyboard arrows or <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, <span class="emphasis"><em>D</em></span> keys. Furthermore, they can jump with the spacebar and interact with characters simply by approaching them. During the game, the player will be tasked with a mission from an NPC character to collect an ancient gem hidden somewhere within a level. The player must then navigate dangerous obstacles in search of the gem, and then finally collect it before returning to the NPC, completing the game.</p><div class="mediaobject"><img src="graphics/figure_05_01.jpg" alt="A 2D Adventure – getting started"/><div class="caption"><p>Figure 5.1: The 2D adventure game to create</p></div></div><p>To get started with creating the adventure, create a completely new and empty Unity project, and then import the <code class="literal">Particles</code>, <code class="literal">Effects</code>, <code class="literal">Characters</code>, <code class="literal">2D</code>, <code class="literal">ParticleSystems</code>, and <code class="literal">CrossPlatformInput</code> packages. You can import these from the <span class="strong"><strong>Project Creation Wizard</strong></span> or from the <a id="id304" class="indexterm"/>application menu via the <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Packages</strong></span> option. See <span class="emphasis"><em>Figure 5.2</em></span>. Details on how to import standard assets are included in <a class="link" href="ch01.html" title="Chapter 1. The Coin Collection Game – Part 1">Chapter 1</a>, <span class="emphasis"><em>The Coin Collection Game – Part 1</em></span>.</p><div class="mediaobject"><img src="graphics/figure_05_02.jpg" alt="A 2D Adventure – getting started"/><div class="caption"><p>Figure 5.2: Importing packages to a new project from the Project Creation screen</p></div></div></div></div>
<div class="section" title="Importing assets"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Importing assets</h1></div></div></div><p>Starting from an empty <a id="id305" class="indexterm"/>project created in the previous section, let's now import the texture assets we'll be using, both for the player character and environment. The assets to import are included in the book companion files in the <code class="literal">Chapter05/Assets</code> folder. From here, select all textures together in Windows Explorer or Mac Finder, and drag and drop them to the Unity Project panel in a designated <code class="literal">Textures</code> folder. (Create one if you haven't already!). This imports all relevant textures to the active Project. See <span class="emphasis"><em>Figure 5.3</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_03.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.3: Importing texture assets to the Project</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Remember that you can always use the Thumbnail Size Slider (at the bottom right corner of the Project panel) to adjust the size of thumbnail previews in order  to get an easier view of your texture assets.</p></div></div><p>By default, Unity <a id="id306" class="indexterm"/>assumes that all imported textures will eventually be used as regular textures applied to 3D models in the scene, such as cubes, spheres, and meshes. In most cases, this assumption is correct because most games are 3D. However, for 2D games like the one we're making, the settings should be different. In our case, objects don't recede in the distance, moving further away, but just remain at a constant offset from the camera. For this reason, we must adjust some crucial properties for all imported textures. Specifically, select all imported textures, and, from the <span class="strong"><strong>Object Inspector</strong></span>, change the <span class="strong"><strong>Texture Type</strong></span> field from <span class="strong"><strong>Texture</strong></span> to <span class="strong"><strong>Sprite 2D and UI</strong></span>. Then, remove the check mark from the <span class="strong"><strong>Generate Mip Maps</strong></span> box. Then, click on the <span class="strong"><strong>Apply</strong></span> button. When you do this, Unity flags the assets as having a <span class="emphasis"><em>2D usage</em></span> internally. It allows transparent backgrounds to be applied where applicable (such as for PNG sprites) and also has important performance implications for graphics rendering, as we'll see. See <span class="emphasis"><em>Figure 5.4</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_04.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.4: Configuring imported textures</p></div></div><p>Now that we've <a id="id307" class="indexterm"/>imported all essential textures for the project, let's configure our main scene, game camera, and target resolution. Switch to the <span class="strong"><strong>Game</strong></span> tab and set the resolution to <span class="strong"><strong>1024 x 600</strong></span>; which works well across many devices. To do this, click on the <span class="strong"><strong>Free Aspect</strong></span> button from the <span class="strong"><strong>Game</strong></span> tab toolbar and pick <span class="strong"><strong>1024 x 600</strong></span> from the drop-down menu, if it appears as an option. If not, click on the <span class="strong"><strong>+</strong></span> button from the bottom of the list to add the new resolution. See <span class="emphasis"><em>Figure 5.5</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_05.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.5: Adding game resolutions</p></div></div><p>To add a new <a id="id308" class="indexterm"/>resolution, enter a custom name in the <span class="strong"><strong>Name</strong></span> field, select <span class="strong"><strong>Fixed Resolution</strong></span> from the <span class="strong"><strong>Type</strong></span> drop-down, and then type your resolution dimensions in the <span class="strong"><strong>Width &amp; Height</strong></span> fields. Once completed, click on <span class="strong"><strong>OK</strong></span>. Your target resolution should then be added as a selectable option from the <span class="strong"><strong>Game</strong></span> tab. See <span class="emphasis"><em>Figure 5.6</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_06.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.6: Creating a custom resolution</p></div></div><p>Next, we'll configure the scene camera for a 2D setup so that our textures, when added as sprites, will display onscreen at a 1:1 ratio, texel for pixel. To achieve this, select the <span class="strong"><strong>MainCamera</strong></span> in the scene, either by clicking on it in the <span class="strong"><strong>Scene viewport</strong></span> or selecting it in the <span class="strong"><strong>Scene Hierarchy</strong></span>. Then, from the <span class="strong"><strong>Object Inspector</strong></span>, change <span class="strong"><strong>Projection</strong></span> to <span class="strong"><strong>Orthographic</strong></span>. This ensures that the camera displays objects in true 2D with perspective and foreshortening effects removed. Then change the camera Size to <code class="literal">3</code>. The formula for this field is <span class="emphasis"><em>Screen Height / 2 / Pixel to World</em></span>. In this case, the <span class="emphasis"><em>Screen Height</em></span> is <span class="emphasis"><em>600</em></span>. Thus, <span class="emphasis"><em>600 / 2 = 300</em></span>. Then, <span class="emphasis"><em>300 / 100 = 3</em></span>. <span class="emphasis"><em>100</em></span> refers to the pixel to world ratio applied to sprite textures; this details how many pixels in the texture will be mapped to a square meter in the world. A <a id="id309" class="indexterm"/>value of <code class="literal">1</code> means <span class="emphasis"><em>1 pixel = 1 meter</em></span>. This value can be viewed and changed by selecting a sprite in the <span class="strong"><strong>Project</strong></span> panel and changing the <span class="strong"><strong>Pixel to World ratio</strong></span> field in the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 5.7</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_07.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.7: Configuring camera orthographic size</p></div></div><p>To test the <a id="id310" class="indexterm"/>camera and scene settings, simply drag and drop a background texture from the <span class="strong"><strong>Project</strong></span> panel to the scene. The <span class="strong"><strong>Background</strong></span> textures are sized at exactly 1024 x 600 to fit the scene background. Therefore, when added to a scene and when the camera is configured correctly, the background textures should fill the screen. See <span class="emphasis"><em>Figure 5.8</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_08.jpg" alt="Importing assets"/><div class="caption"><p>Figure 5.8: Testing the camera settings with a texture</p></div></div></div>
<div class="section" title="Creating an environment &#x2013; getting started"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Creating an environment – getting started</h1></div></div></div><p>Our adventure <a id="id311" class="indexterm"/>game will feature three separate but connected scenes, which the player may explore, moving from one scene to the next. The player may travel between scenes, simply by walking off the edge of one and then moving into the next. Each scene consists primarily of platforms and ledges and, in some cases, dangers and obstacles. In terms of graphical assets, each scene is made from two textures or sprites: the background and foreground. An example for Scene 1 is shown in <span class="emphasis"><em>Figures 5.9</em></span> and and <span class="emphasis"><em>Figure 5.10</em></span>. <span class="emphasis"><em>Figure 5.9</em></span> represents the background scene and <span class="emphasis"><em>Figure 5.10</em></span> represents the foreground, which includes a complete layout of all the platforms and ledges that the player must traverse. These files are included in the book companion files in the <code class="literal">Chapter05/Assets</code> folder:</p><div class="mediaobject"><img src="graphics/figure_05_09.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.9: Scene background - tex_level01_bck.png</p></div></div><div class="mediaobject"><img src="graphics/figure_05_10.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.10: Scene foreground - tex_level01_design.png</p></div></div><p>Let's create the first level now, based on the sprites in <span class="emphasis"><em>Figures 5.9</em></span> and <span class="emphasis"><em>Figure 5.10</em></span>. To do this, use the existing empty scene, or create a new scene, ensuring that the scene camera is configured to <a id="id312" class="indexterm"/>display textures at their native size. Then, drag and drop both the background and foreground sprites from the <span class="strong"><strong>Project</strong></span> panel to the scene. Both will be added to the scene as separate sprite objects. Then, position them both to the World Origin at (0,0,0). See <span class="emphasis"><em>Figure 5.11</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_11.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.11: Adding a scene background and foreground</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>If you drag and drop both the background and foreground textures together as one selection from the <span class="strong"><strong>Project</strong></span> panel to the scene, Unity may ask you to create an Animation when you release your mouse. In such cases, Unity assumes that you want to create an animated sprite in which each selected texture becomes a frame of animation played in a sequence. You don't want to do this; instead, drag and drop each sprite to a separate <span class="strong"><strong>Hierarchy</strong></span> panel, allowing both the foreground and background to be seen at the same time.</p></div></div><p>Both sprite objects are now added to the scene at the same world position (0,0,0). The question arises now <a id="id313" class="indexterm"/>as to which sprite Unity should display on top, given that both sprites overlap one another. Left as it is right now, there is a conflict and ambiguity about depth order, and we cannot rely on Unity consistently showing the correct sprite on top. We can solve this problem with two methods: one is to move the sprite forward in the <span class="emphasis"><em>Z</em></span> axis, closer to the Orthographic camera; and the other is to change its <span class="strong"><strong>Order</strong></span> setting from the <span class="strong"><strong>Object Inspector</strong></span>. High values for <span class="strong"><strong>Order</strong></span> result in the sprite appearing atop lower-order sprites. Here, I'll use both methods and that's fine too! See <span class="emphasis"><em>Figure 5.12</em></span>. Note, however, that <span class="strong"><strong>Order</strong></span> always takes precedence over <span class="strong"><strong>Position</strong></span>. This means that higher-order objects will always appear on top of lower-order objects, even if higher-order objects are positioned behind lower-order objects.</p><div class="mediaobject"><img src="graphics/figure_05_12.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.12: Ordering sprite layers in a scene</p></div></div><p>Before moving further, let's get organized in terms of scene hierarchy to prevent overcomplication and confusion happening later. Select each environment object and name them appropriately. I named the background <code class="literal">scene_background</code> and the foreground <code class="literal">scene_foreground</code>. Having done this, create a new, empty <span class="strong"><strong>GameObject</strong></span> named <code class="literal">Env</code> (for Environment), which will be the ultimate parent or ancestor of all static (non-movable) objects in the environment. This lets us group together all related objects easily. To do this, choose <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> from the application menu, position the created empty object to the world origin, and drag and drop both the background and foreground objects as its children. See <span class="emphasis"><em>Figure 5.13</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_13.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.13: Organizing the scene hierarchy</p></div></div><p>By switching to the Game tab, we can get an early preview of the level as it will appear to the gamer in terms of mood and emotional resonance. This feel can be enhanced further by adding some Camera Post-process Effects. These refer to pixel-based effects that can be applied to the camera in order to enhance the atmosphere of the final, rendered image on each frame. The <a id="id314" class="indexterm"/>
<span class="strong"><strong>Image Effects</strong></span> are included in the Effects package, which you should have imported during the project creation phase. If you did not import the package at that time, you can do so now by navigating to <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>Effects</strong></span>. The <span class="strong"><strong>Image Effects</strong></span> assets are stored in the <code class="literal">Standard Assets/Effects</code> folder. Once imported, you can add Image Effects to the selected camera via the Application Menu by choosing <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Image Effects</strong></span> and then choosing the effect to add. See <span class="emphasis"><em>Figure 5.14</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_14.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.14: Adding Image Effects to the selected camera</p></div></div><p>For this level, and all other levels in the game, I'll add the following two image effects: <span class="strong"><strong>Bloom Optimized</strong></span> and <span class="strong"><strong>Noise and Grain</strong></span>. Once added, you will typically need to adjust the sliders and settings in the <span class="strong"><strong>Inspector</strong></span> to achieve the look you want, continually previewing the result in the <span class="strong"><strong>Game</strong></span> <a id="id315" class="indexterm"/>tab. The <span class="strong"><strong>Scene</strong></span> tab remains unaffected by image effects. The complete range of settings I've used for both image effects are included in <span class="emphasis"><em>Figure 5.15</em></span>. In many cases, these settings will take some trial and error—tweak values and observe the effect.</p><div class="mediaobject"><img src="graphics/figure_05_15.jpg" alt="Creating an environment – getting started"/><div class="caption"><p>Figure 5.15: Image Effects applied to the game camera</p></div></div><p>Good work. The scene so far features a background and foreground taken from texture files and enhancing <a id="id316" class="indexterm"/>special effects using the Image Effects assets package. This is a great start, but there's still much to do so let's move on!</p></div>
<div class="section" title="Environment Physics"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Environment Physics</h1></div></div></div><p>The main problem <a id="id317" class="indexterm"/>with our level as it stands is that it lacks interactivity. Specifically, if we dragged and dropped a player object to the level and pressed play on the toolbar, the player would drop through the floor and walls because the foreground texture isn't recognized by Unity as a solid object. It's just a texture and exists only in appearance and not in substance. In this section, we'll correct this using Physics and Colliders. To get started, we'll create a temporary player object (not the final version but just a temporary <span class="emphasis"><em>White Box</em></span> version used only for testing purposes). To create this, generate a capsule object in the scene by navigating to <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>3D Object</strong></span> | <span class="strong"><strong>Capsule</strong></span> from the application menu. Set the <span class="emphasis"><em>Z</em></span> position of the transform to match the foreground texture (for me, this is <code class="literal">-2</code>). Once generated, remove <span class="strong"><strong>Capsule Collider</strong></span> from the object. By default, the Capsule is assigned a 3D collider (such as the <span class="strong"><strong>Capsule Collider</strong></span>), which is useful primarily for 3D physics, but our game will be 2D. To remove the Collider, click on the Cog icon on the <span class="strong"><strong>Capsule Collider</strong></span> component in the <span class="strong"><strong>Object Inspector</strong></span> and choose <span class="strong"><strong>Remove Component</strong></span> from the menu. See <span class="emphasis"><em>Figure 5.16</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_16.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.16: Removing a Capsule Collider component</p></div></div><p>To make the object compatible with 2D Physics, add a Circle Collider component by choosing <a id="id318" class="indexterm"/>
<span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Circle Collider</strong></span> from the application menu. Once added, use the <span class="strong"><strong>Offset</strong></span> and <span class="strong"><strong>Radius</strong></span> settings on the Circle Collider component in the Inspector to adjust the size and position of the circle in relation to the capsule object in order to approximate the feet of a player character. To aid you in positioning the <span class="strong"><strong>Circle Collider</strong></span> more easily, you can switch the <span class="strong"><strong>Scene</strong></span> viewport mode to <span class="strong"><strong>Wireframe</strong></span> and <span class="strong"><strong>2D</strong></span>, if needed. To do this, use the <span class="strong"><strong>2D Toggle</strong></span> button and the <span class="strong"><strong>Scene Render</strong></span> mode drop-down button in the viewport toolbar. See <span class="emphasis"><em>Figure 5.17</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_17.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.17: Adjusting the Circle Collider for the player character</p></div></div><p>Next, to make the <span class="strong"><strong>Circle Collider</strong></span> work with 2D Physics, add a RigidBody2D component to the Capsule. To do this, select <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>RigidBody2D</strong></span> from the application menu. You can confirm that this has worked by previewing the game in Play mode. When you click on the play icon, the Capsule object should fall down and through the foreground floor under the effect of gravity. See <span class="emphasis"><em>Figure 5.18</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_18.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.18: Adding a Rigidbody 2D component to a test character</p></div></div><p>Now, it's <a id="id319" class="indexterm"/>time to configure the foreground texture to work as a unified whole with physics. Right now, our test player character falls through the floor and this is not what we want. To fix this, we'll need to add a collider to the foreground environment. One method for this is to use Edge Collider 2D. This lets you draw out a low polygon mesh collider around your ground image manually, approximating the terrain. To get started, select the foreground in the scene and then choose <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Edge Collider 2D</strong></span> from the application menu. Doing this will add an Edge Collider 2D component to the foreground object. See <span class="emphasis"><em>Figure 5.19</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_19.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.19: Adding an Edge Collider</p></div></div><p>By default, adding an Edge Collider 2D appears to have little effect on the selected object or any other objects, except for a single horizontal line drawn across the width of the scene. This can be seen in the <span class="strong"><strong>Scene</strong></span> tab when the <span class="strong"><strong>Foreground</strong></span> object is selected and in the <span class="strong"><strong>Game</strong></span> tab if the <span class="strong"><strong>Gizmos</strong></span> tool button is enabled. If the player is positioned above the horizontal line and <a id="id320" class="indexterm"/>you press Play on the toolbar, the player character will fall downward and treat the horizontal edge as a solid platform. See <span class="emphasis"><em>Figure 5.20</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_20.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.20: The Edge Collider is useful to approximate platforms and solid surfaces</p></div></div><p>Of course, our terrain isn't simply a straight-edged surface. Rather, it has elevations, bumps, and platforms. These can be approximated closely with the Edge Collider 2D component using the <span class="strong"><strong>Collider Edit</strong></span> mode. To access this mode, click on the <span class="strong"><strong>Edit Collider</strong></span> button from the <span class="strong"><strong>Object Inspector</strong></span>. See <span class="emphasis"><em>Figure 5.21</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_21.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.21: The Edit Collider mode lets you change the shape of an Edge Collider 2D</p></div></div><p>With the <span class="strong"><strong>Edit Collider</strong></span> mode active, you can reshape the collider to conform to the terrain. Let's focus on one area such as the bottom right-hand side of the terrain. By moving your mouse cursor over the edge points of the <span class="strong"><strong>Edge Collider</strong></span> (the green line), you can click and drag to reposition it. To approximate the bottom right island of the terrain, click and drag <a id="id321" class="indexterm"/>the rightmost edge point to the right-hand side of the scene. See <span class="emphasis"><em>Figure 5.22</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_22.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.22: Starting to reshape the Edge Collider to approximate the terrain</p></div></div><p>Next, click and drag the left point of the collider to match with the leftmost edge of the right-hand island. See <span class="emphasis"><em>Figure 5.23</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_23.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.23: Positioning the left-most of the right-hand island</p></div></div><p>Now that the left and right edge points are positioned, let's add some additional points on the line between to reshape it, conforming to the right-hand island. Move your cursor anywhere on the line, click and drag to insert a new point, and reposition it to match the island. Repeat this process, adding additional points to reshape the line as needed. See <span class="emphasis"><em>Figure 5.24</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_24.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.24: Shaping the Edge Collider to the right-most island</p></div></div><p>You now have a fully shaped line that matches the terrain's right-most island. Having created this, exit the <span class="strong"><strong>Edit Collider</strong></span> mode by simply clicking on the <span class="strong"><strong>Edit Collider</strong></span> button again from the <span class="strong"><strong>Object Inspector</strong></span>. To create colliders for the remaining islands of the terrain, add a new <span class="strong"><strong>Edge Collider</strong></span> to the same object. You can then add any number of <span class="strong"><strong>Edge Colliders</strong></span> to a single object, and each collider should be used to approximate the topology of a single, isolated island in the complete terrain. See <span class="emphasis"><em>Figure 5.25</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_25.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.25: Multiple Edge Colliders on one object can be used to approximate complex terrain</p></div></div><p>Multiple Edge Collider components are now added together to a single foreground object, approximating the complete terrain for the scene. We can now test play collisions against the <span class="strong"><strong>Player Capsule</strong></span> object by pressing the play icon on the toolbar and seeing how the capsule reacts against the terrain. This time, the capsule will collide and interact with the ground as opposed to passing <a id="id322" class="indexterm"/>through. This confirms that the terrain is configured appropriately with the physics system. See <span class="emphasis"><em>Figure 5.26</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_26.jpg" alt="Environment Physics"/><div class="caption"><p>Figure 5.26: Capsule Object interacting with a terrain made from Edge Colliders</p></div></div><p>Congratulations! In this section, we've created a complete terrain for a single scene using Edge Collider components. This terrain not only fits the screen and appears as intended, but acts as a physical obstacle for the player character and other physics-based objects. Of course, so far, we've been using a rough approximation for the player and now it's time to expand upon this.</p></div>
<div class="section" title="Creating a player"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Creating a player</h1></div></div></div><p>The player <a id="id323" class="indexterm"/>character is a small, green alien-looking creature that can be controlled and guided by the gamer through a level using many conventional platform-game mechanics, such as walking, jumping, and interacting. In the previous section, we built a <span class="emphasis"><em>White Box</em></span> (prototype) character to test physical interactions with the environment, but here, we'll develop the player character in more depth. <span class="emphasis"><em>Figure 5.27</em></span> illustrates our character texture imported earlier in the chapter, representing all limbs and parts for the player:</p><div class="mediaobject"><img src="graphics/figure_05_27.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.27: Character and his limbs in a consolidated texture</p></div></div><p>The player texture, as <a id="id324" class="indexterm"/>shown in <span class="emphasis"><em>Figure 5.27</em></span>, is called an <span class="strong"><strong>Atlas Texture</strong></span> or <span class="strong"><strong>Sprite Sheet</strong></span> <a id="id325" class="indexterm"/>because it contains all frames or parts of a character in a single texture space. The problem with this texture, as it stands, is that when dragged and <a id="id326" class="indexterm"/>dropped from the <span class="strong"><strong>Project</strong></span> panel to the scene, it'll be added as a single, self-contained sprite. This is because Unity recognizes all the separate parts as a single sprite. Rather, these should be separated into distinct units. See <span class="emphasis"><em>Figure 5.28</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_28.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.28: The player sprite texture needs to be divided into separate parts</p></div></div><p>To divide the character texture into separate parts on a per-limb basis, we'll use <span class="strong"><strong>Sprite Editor</strong></span>. To access this tool, select the character texture in the <span class="strong"><strong>Project</strong></span> panel. Then, from the <span class="strong"><strong>Object Inspector</strong></span>, change <span class="strong"><strong>Sprite Mode</strong></span> from <span class="strong"><strong>Single</strong></span> to <span class="strong"><strong>Multiple</strong></span>. Then, click on <span class="strong"><strong>Apply</strong></span>. Next, click on the <span class="strong"><strong>Sprite Editor</strong></span> button to open the <span class="strong"><strong>Sprite Editor</strong></span> tool, allowing you cut apart the whole texture into specific slices. See <span class="emphasis"><em>Figure 5.29</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_29.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.29: Specifying a sprite as Multiple</p></div></div><p>With the <span class="strong"><strong>Sprite Editor</strong></span> tool, you can separate different parts of a texture into discrete and separate units. One <a id="id327" class="indexterm"/>method to achieve this is by drawing a rectangle around each image area that should be separate, and simply clicking and dragging your mouse to draw a texture region. See <span class="emphasis"><em>Figure 5.30</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_30.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.30: Drawing a sprite manually</p></div></div><p>Now, although a sprite can be separated manually, as we've just seen, Unity can often cut apart the texture automatically, identifying isolated areas of pixels and saving us a lot of time. We'll do that here for the player character. To do this, click on the <span class="strong"><strong>Slice</strong></span> button listed at the top <a id="id328" class="indexterm"/>left corner of the <span class="strong"><strong>Sprite Editor</strong></span> window. See <span class="emphasis"><em>Figure 5.31</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_31.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.31: Accessing the Slice tool</p></div></div><p>From the <span class="strong"><strong>Slice</strong></span> tool window, ensure that <span class="strong"><strong>Type</strong></span> is set to <span class="strong"><strong>Automatic</strong></span>, which means that Unity will auto-detect the location of separate sprites. <span class="strong"><strong>Pivot</strong></span> can be left at <span class="strong"><strong>Center</strong></span>, determining the pivot point for each sprite. <span class="strong"><strong>Method</strong></span> should be <span class="strong"><strong>Delete Existing</strong></span>, meaning that any existing sprites or slices in the texture space will be erased and replaced entirely by the newly autogenerated slices. Then, click on the <span class="strong"><strong>Slice</strong></span> button to confirm the operation and the texture will be sliced into separate sprites with a clear border drawn around each sprite. See <span class="emphasis"><em>Figure 5.32</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_32.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.32: A fully sliced sprite</p></div></div><p>The texture is now divided into several sprites: head, body, arm, and leg. The final character in-scene will obviously have two arms and two legs but these will be formed from duplicated sprites. The final process now is to set the pivot point for each sprite—the point around which the sprite will rotate. This will be important later to animate the character correctly, as we'll see. Let's start by setting the pivot for the head. Select the head sprite in the editor and then click and drag the pivot handle (blue circle) to reposition the sprite's center of rotation. Click and drag the handle to the bottom middle of the head, roughly <a id="id329" class="indexterm"/>where the head would connect to the neck. This makes sense because the head will rotate and hinge from around this point. As you move the pivot around, you should see the <span class="strong"><strong>X</strong></span> and <span class="strong"><strong>Y</strong></span> values change from the <span class="strong"><strong>Custom Pivot</strong></span> field in the <span class="strong"><strong>Sprite Properties</strong></span> dialog, shown in the bottom right-hand corner of the <span class="strong"><strong>Sprite Editor</strong></span> window. See <span class="emphasis"><em>Figure 5.33</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_33.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.33: Repositioning the sprite pivot</p></div></div><p>Next, position the pivot for the arm, which should be at the shoulder joint where the arm connects to a torso; then <a id="id330" class="indexterm"/>for the leg, which should be near the hip where the leg connects to a torso, and finally, the torso itself, whose pivot should be at the hip joint. See <span class="emphasis"><em>Figure 5.34</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_34.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.34: Positioning the pivot for the torso</p></div></div><p>When completed, click on the <span class="strong"><strong>Apply</strong></span> button to confirm changes and then close the <span class="strong"><strong>Sprite Editor</strong></span>. On returning to the main Unity interface, the appearance of the character texture will have changed in the <span class="strong"><strong>Project</strong></span> panel. Specifically, the character texture features a small arrow icon attached to the right-hand side. When you click this, the texture expands to review all the separate <a id="id331" class="indexterm"/>sprites in a row, which can be dragged and dropped individually to the scene. See <span class="emphasis"><em>Figure 5.35</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_35.jpg" alt="Creating a player"/><div class="caption"><p>Figure: 5.35: Previewing character sprites</p></div></div><p>Now that we've isolated all player sprite textures, we can start to build a game character in the scene. Start by creating an empty game object with the <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Create Empty</strong></span> command from the application menu. Name the object <code class="literal">Player</code> and assign it a Player Tag from the Inspector. This object will act as the ultimate or topmost parent object for the player character. Existing beneath this object as children will be the character's constituent parts: torso, arms, and legs. So, let's drag and drop the Torso sprite from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Hierarchy</strong></span> panel as a child of the <span class="strong"><strong>Player</strong></span> object. See <span class="emphasis"><em>Figure 5.36</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_36.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.36: Starting the player character</p></div></div><p>After the torso has been added, we can add legs and arms. The arms should be added as children of the torso because the torso determines where the arms will be. However, the legs should be added as <a id="id332" class="indexterm"/>children of the <span class="strong"><strong>Player</strong></span> object and are therefore siblings of the torso, because the torso can rotate independently of the legs. See <span class="emphasis"><em>Figure 5.37</em></span> for the complete hierarchical arrangement. As you add each limb, you'll want to offset its position so that it appears correctly in relation to other limbs—the head should appear above the feet and so on.</p><div class="mediaobject"><img src="graphics/figure_05_37.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.37: Building a character</p></div></div><p>The rendering order of body parts is probably not correct by default insofar as each item will have an identical order in the Sprite Renderer component. This means that Unity could potentially render each limb in any order, allowing arms to appear in front of the head, legs to appear in front of the body, and so on. To correct this, we'll select each limb in turn and assign it an appropriate order value, taking care that it's higher than the world background order and less than the world foreground order. I've assigned the body an order of <code class="literal">103</code>, the head <a id="id333" class="indexterm"/>
<code class="literal">105</code>, left arm <code class="literal">102</code>, right arm <code class="literal">104</code>, left leg <code class="literal">100</code>, and right leg <code class="literal">101</code>. See <span class="emphasis"><em>Figure 5.38</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_38.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.38: Ordering body parts</p></div></div><p>The rendering order for limbs is now configured successfully. Let's set up collisions and physics for the player. To do this, add two colliders—a Circle Collider to approximate the character feet, allowing us to determine when the character is in contact with the ground, and a Box Collider that approximates most of the body including the head. These colliders can be added by selecting the <span class="strong"><strong>Player</strong></span> object (the topmost object) and then navigating to <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Circle Collider 2D</strong></span> and <span class="strong"><strong>Component</strong></span> | <span class="strong"><strong>Physics 2D</strong></span> | <span class="strong"><strong>Box Collider 2D</strong></span>. See <span class="emphasis"><em>Figure 5.39</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_39.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.39: Adding two colliders to the Player Object: Circle Collider and Box Collider</p></div></div><p>The Circle Collider is of special importance because it's the primary means to determine whether the character is touching the ground, and it'll also be in contact with the ground as the character moves. For <a id="id334" class="indexterm"/>this reason, a Physics Material should be assigned to this collider to prevent friction effects from stopping or corrupting character motion as it moves around the scene. To achieve this, create a new Physics Material by right-clicking in the empty space in the <span class="strong"><strong>Project</strong></span> panel and choose <span class="strong"><strong>Create</strong></span> | <span class="strong"><strong>Physics2D Material</strong></span> from the context menu. Name the material <code class="literal">Low Friction</code>. See <span class="emphasis"><em>Figure 5.40</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_40.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.40: Creating a new Physics Material</p></div></div><p>Select the Physics2D material in the <span class="strong"><strong>Project</strong></span> panel, and from the <span class="strong"><strong>Inspector</strong></span>, change the Friction setting to <code class="literal">0.1</code>. Then, drag and drop the Physics2D material from the <span class="strong"><strong>Project</strong></span> panel to the <span class="strong"><strong>Material</strong></span> slot for the CircleCollider2D component on the <span class="strong"><strong>Player</strong></span> object. See <span class="emphasis"><em>Figure 5.41</em></span>. Using these settings, the character will behave more realistically.</p><div class="mediaobject"><img src="graphics/figure_05_41.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.41: Assigning a Physics material to the player character</p></div></div><p>Then, finally assign RigidBody2D to the <span class="strong"><strong>Player</strong></span> object and set both <span class="strong"><strong>Linear Drag</strong></span> and <span class="strong"><strong>Gravity Scale</strong></span> to <code class="literal">3</code>. In addition, set <span class="strong"><strong>Collison Detection</strong></span> to <span class="strong"><strong>Continuous</strong></span> for the most accurate collision detection and <span class="strong"><strong>Freeze Rotation</strong></span> of the object on the <span class="emphasis"><em>Z</em></span> axis because the player character should <a id="id335" class="indexterm"/>never rotate. Now, you have a fully completed physical object representing the player. See <span class="emphasis"><em>Figure 5.42</em></span>. Good work!</p><div class="mediaobject"><img src="graphics/figure_05_42.jpg" alt="Creating a player"/><div class="caption"><p>Figure 5.42: Configuring the player character for Physics</p></div></div></div>
<div class="section" title="Scripting the player movement"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Scripting the player movement</h1></div></div></div><p>The game so far <a id="id336" class="indexterm"/>features an environment with collision data and a multipart player object that interacts and responds to this environment. The player, however, cannot yet be controlled, and this section explores controller functionality further. The user will have two main input mechanics, namely, movement (walking left and right) and jumping. This input can be read seamlessly and easily using <code class="literal">CrossPlatformInputManager</code>, which is a native Unity asset package. This package was imported at the project creation phase, but it can be imported now via the application menu with <span class="strong"><strong>Assets</strong></span> | <span class="strong"><strong>Import Package</strong></span> | <span class="strong"><strong>CrossPlatformInput</strong></span>. Once imported, open the <code class="literal">Standard Assets</code> | <code class="literal">CrossPlatformInput</code> | <code class="literal">Prefabs</code> folder and drag and drop the <span class="strong"><strong>MobileTiltControlRig</strong></span> prefab to the scene. This prefab lets you read input data across a range of devices, mapping directly to the horizontal and vertical axes that we've already seen in previous chapters. See <span class="emphasis"><em>Figure 5.43</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_43.jpg" alt="Scripting the player movement"/><div class="caption"><p>Figure 5.43: Cross-platform input prefabs offer easy multidevice control</p></div></div><p>Let's now script player controls. To do this, create a new C# script named <code class="literal">PlayerControl.cs</code> and attach it to the Player character. The full source code for this file is given in <a id="id337" class="indexterm"/>the  <span class="emphasis"><em>Code Sample 5.1</em></span>:</p><div class="informalexample"><pre class="programlisting">//--------------------------------
using UnityEngine;
using System.Collections;
using UnityStandardAssets.CrossPlatformInput;
//--------------------------------
public class PlayerControl : MonoBehaviour
{
  //--------------------------------
  public enum FACEDIRECTION {FACELEFT = -1, FACERIGHT = 1};
  //Which direction is the player facing - left or right?
  public FACEDIRECTION Facing = FACEDIRECTION.FACERIGHT;
  //Which objects are tagged as ground
  public LayerMask GroundLayer;
  //Reference to rigidbody
  private Rigidbody2D ThisBody = null;
  //Reference to transform
  private Transform ThisTransform = null;
  //Reference to feet collider
  public CircleCollider2D FeetCollider = null;
  //Are we touching the ground?
  public bool isGrounded = false;
  //What are the main input axes
  public string HorzAxis = "Horizontal";
  public string JumpButton = "Jump";
  //Speed variables
  public float MaxSpeed = 50f;
  public float JumpPower = 600;
  public float JumpTimeOut = 1f;
  //Can we jump right now?
  private bool CanJump = true;
  //Can we control player?
  public bool CanControl = true;
  public static PlayerControl PlayerInstance = null;
  //--------------------------------
  public static float Health
  {
    get
    {
      return _Health;
    }

    set
    {
      _Health = value;

      //If we are dead, then end game
      if(_Health &lt;= 0)
      {
        Die();
      }
    }
  }

  [SerializeField]
  private static float _Health = 100f;
  //--------------------------------
  // Use this for initialization
  void Awake ()
  {
    //Get transform and rigid body
    ThisBody = GetComponent&lt;Rigidbody2D&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Set static instance
    PlayerInstance = this;
  }
  //--------------------------------
  //Returns bool - is player on ground?
  private bool GetGrounded()
  {
    //Check ground
    Vector2 CircleCenter = new Vector2(ThisTransform.position.x, ThisTransform.position.y) + FeetCollider.offset;
    Collider2D[] HitColliders = Physics2D.OverlapCircleAll(CircleCenter, FeetCollider.radius, GroundLayer);
    if(HitColliders.Length &gt; 0) return true;
    return false;
  }
  //--------------------------------
  //Flips character direction
  private void FlipDirection()
  {
    Facing = (FACEDIRECTION) ((int)Facing * -1f);
    Vector3 LocalScale = ThisTransform.localScale;
    LocalScale.x *= -1f;
    ThisTransform.localScale = LocalScale;
  }
  //--------------------------------
  //Engage jump
  private void Jump()
  {
    //If we are grounded, then jump
    if(!isGrounded || !CanJump)return;

    //Jump
    ThisBody.AddForce(Vector2.up * JumpPower);
    CanJump = false;
    Invoke ("ActivateJump", JumpTimeOut);
  }
  //--------------------------------
  //Activates can jump variable after jump timeout
  //Prevents double-jumps
  private void ActivateJump()
  {
    CanJump = true;
  }
  //--------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //If we cannot control character, then exit
    if(!CanControl || Health &lt;= 0f)
    {
      return;
    }

    //Update grounded status
    isGrounded = GetGrounded();
    float Horz = CrossPlatformInputManager.GetAxis(HorzAxis);
    ThisBody.AddForce(Vector2.right * Horz * MaxSpeed);

    if(CrossPlatformInputManager.GetButton(JumpButton))
      Jump();

    //Clamp velocity
    ThisBody.velocity = new Vector2(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed), 
      Mathf.Clamp(ThisBody.velocity.y, -Mathf.Infinity, JumpPower));

    //Flip direction if required
    if((Horz &lt; 0f &amp;&amp; Facing != FACEDIRECTION.FACELEFT) || (Horz &gt; 0f &amp;&amp; Facing != FACEDIRECTION.FACERIGHT))
      FlipDirection();
  }
  //--------------------------------
  void OnDestroy()
  {
    PlayerInstance = null;
  }
  //--------------------------------
  //Function to kill player
  static void Die()
  {
    Destroy(PlayerControl.PlayerInstance.gameObject);
  }
  //--------------------------------
  //Resets player back to defaults
  public static void Reset()
  {
    Health = 100f;
  }
  //--------------------------------
}
//--------------------------------</pre></div><div class="section" title="Code Sample 5.1"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec23"/>Code Sample 5.1</h2></div></div></div><p>The following points summarize the code sample:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id338" class="indexterm"/><code class="literal">PlayerControl</code> class is responsible for handling all player input, making the character move left and right and jump.</li><li class="listitem" style="list-style-type: disc">To achieve player movement, a reference to the RigidBody2D component is retained in the <code class="literal">ThisBody</code> variable, which is retrieved in the <code class="literal">Awake</code> function. The <a id="id339" class="indexterm"/>movement and motion of the player is set using the <code class="literal">RigidBody2D.Velocity</code> variable. More information on this variable can be found online at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html">http://docs.unity3d.com/ScriptReference/Rigidbody2D-velocity.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FlipDirection</code> function is used to invert the horizontal scale of the sprite, turning it to face left or right as needed (reversing the image direction, for example, <code class="literal">1</code> and <code class="literal">-1</code>). From Unity 5.3 onward, the <code class="literal">Flip</code> property of the <code class="literal">SpriteRenderer</code> component can be used instead.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FixedUpdate</code> function is used instead of Update to update the movement of the player character because we're working with <code class="literal">RigidBody2D</code>—a physics-based component. All physics functionality should be updated in <code class="literal">FixedUpdate</code> that is invoked at a fixed interval each second as opposed to every <a id="id340" class="indexterm"/>frame. More information can be found at the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">GetGrounded</code> function detects where any <code class="literal">CircleCollider</code> intersects and overlaps with any other collider in the scene on a specific layer. In short, this function indicates whether the player character is touching the ground at the position of the feet. If so, the player is able to jump; otherwise, the player cannot jump as they are already airborne. Double-jumping is not allowed in this game!</li></ul></div><p>For the preceding code to work correctly, a few tweaks must be made to both the scene and player character. Specifically, the <code class="literal">GetGrounded</code> function requires that the floor area of the level is grouped together on a single layer. This simply means that the level foreground should be on a distinctive layer from other objects. To achieve this, create a new layer named <code class="literal">Ground</code>, and then assign the foreground object to this layer. To create a new layer, select the foreground object and, from the <span class="strong"><strong>Object Inspector</strong></span>, click on the drop-down named <a id="id341" class="indexterm"/>
<span class="strong"><strong>Layer</strong></span>. Then, select Add Layer from the context menu. See <span class="emphasis"><em>Figure 5.44</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_44.jpg" alt="Code Sample 5.1"/><div class="caption"><p>Figure 5.44: Adding a new layer</p></div></div><p>Then, add <a id="id342" class="indexterm"/>a new layer named <code class="literal">Ground</code> simply by entering <code class="literal">Ground</code> in an available type-in field. See <span class="emphasis"><em>Figure 5.45</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_45.jpg" alt="Code Sample 5.1"/><div class="caption"><p>Figure 5.45: Creating a new ground layer</p></div></div><p>Now, assign the foreground object to the <code class="literal">Ground</code> layer. Simply select the foreground object, and then select the <span class="strong"><strong>Ground</strong></span> layer from the <span class="strong"><strong>Layer</strong></span> drop-down in the <span class="strong"><strong>Object Inspector</strong></span>. After the foreground object is assigned to the ground layer, the <code class="literal">PlayerControl</code> script requires us to indicate which layer has been designated for the ground. To achieve this, select the <span class="strong"><strong>Player</strong></span> object and, from the <span class="strong"><strong>Object Inspector</strong></span>, select the <span class="strong"><strong>Ground</strong></span> layer for the <span class="strong"><strong>Ground Layer</strong></span> field. See <span class="emphasis"><em>Figure 5.46</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_46.jpg" alt="Code Sample 5.1"/><div class="caption"><p>Figure 5.46: Selecting the Ground layer for collision detection</p></div></div><p>In addition, the <span class="strong"><strong>Feet Collider</strong></span> slot needs assignment too in order to indicate which collider object should be used for ground collision detection. For this field, you need to drag and <a id="id343" class="indexterm"/>drop the <span class="strong"><strong>CircleCollider</strong></span> component to the <span class="strong"><strong>Feet Collider</strong></span> slot. See <span class="emphasis"><em>Figure 5.47</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_47.jpg" alt="Code Sample 5.1"/><div class="caption"><p>Figure 5.47: The Feet Collider detects when the character is in contact with the ground</p></div></div><p>Now, give the player character a test run. Simply click on the play icon on the toolbar and test out the controls of the player character. <span class="emphasis"><em>W</em></span>, <span class="emphasis"><em>A</em></span>, <span class="emphasis"><em>S</em></span>, <span class="emphasis"><em>D</em></span> (or the arrow keys) will move the player character around. The spacebar makes the character jump. See <span class="emphasis"><em>Figure 5.48</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_48.jpg" alt="Code Sample 5.1"/><div class="caption"><p>Figure 5.48: Play testing with the player character</p></div></div></div></div>
<div class="section" title="Optimization"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Optimization</h1></div></div></div><p>Our work so <a id="id344" class="indexterm"/>far has produced an interesting environment and a controllable character within this environment. Before moving forward, let's turn our attention to optimization—an issue that should be considered early during development. Optimization refers to the tips and tricks that we can apply to improve runtime performance as well as our workflow generally. Here, we'll consider prefabs to improve our workflow and Sprite Packing to improve runtime performance. Let's start with prefabs.</p><p>A prefab is a Unity asset that lets you group together many objects in a scene and package them together as a single unit that can be added to the <span class="strong"><strong>Project</strong></span> panel as an asset. From here, the prefab can be added as a complete unit to any other scene or environment as though it were a separate and complete <span class="emphasis"><em>thing</em></span>. The player character is an ideal candidate for a prefab because it must feature in all the other scenes we create. Let's create a prefab from the player. To do this, simply drag and drop the <span class="strong"><strong>Player</strong></span> object to the <span class="strong"><strong>Project</strong></span> panel in a separate folder called <code class="literal">Prefabs</code>. See <span class="emphasis"><em>Figure 5.49</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_49.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.49: Generating a player prefab</p></div></div><p>After the <span class="strong"><strong>Prefab</strong></span> is created, the <span class="strong"><strong>Player</strong></span> object name in the hierarchy panel will turn blue, indicating that it's connected to the Prefab asset. This means that if you select the <span class="strong"><strong>Prefab</strong></span> in the <span class="strong"><strong>Project</strong></span> panel and make changes in the Inspector, then the <span class="strong"><strong>Player</strong></span> object in the scene will change <a id="id345" class="indexterm"/>automatically to match these changes. You can, however, break the connection between the <span class="strong"><strong>Player</strong></span> in the scene and <span class="strong"><strong>Prefab</strong></span> by selecting the <span class="strong"><strong>Player</strong></span> object and choosing <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Break Prefab Instance</strong></span> from the application menu. This converts the scene object into a separate and independent duplicate of the Prefab. See <span class="emphasis"><em>Figure 5.50</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_50.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.50: Breaking a prefab instance</p></div></div><p>Most of the time, however, you'll want to keep the connection between objects and their prefabs. Sometimes, though, you may make changes to the object in the scene, and then want these changes to feedback to the <span class="strong"><strong>Prefab</strong></span> asset in the <span class="strong"><strong>Project</strong></span> panel, affecting all other linked instances if there are any. To do this, select the object to which changes have been made, and then <a id="id346" class="indexterm"/>select <span class="strong"><strong>GameObject</strong></span> | <span class="strong"><strong>Apply Changes to Prefab</strong></span> from the application menu. See <span class="emphasis"><em>Figure 5.51</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_51.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.51: Applying changes to a prefab</p></div></div><p>In addition to making Prefabs, you'll also want to optimize the render performance for your 2D games. Right now, when running the game, Unity will perform a unique and separate draw call for each and every unique texture or sprite onscreen at the time. A draw call simply refers to a step or process cycle that Unity must run through to properly display a graphic onscreen, such as a mesh, material, or texture. Draw calls represent a computational expense, and so it's a good idea to reduce them wherever possible.</p><p>For 2D games, we can reduce draw calls by batching together related textures, such as all the props for a scene, all the enemies, or all the weapons. That is, by indicating to Unity that a group of textures belong together, Unity can perform internal optimizations that increase render performance. Specifically, Unity will paste all related textures in a single and larger internal texture that it uses instead. To achieve this optimization, select all <span class="emphasis"><em>prop</em></span> textures. For our game, I will include the <span class="strong"><strong>Player</strong></span>, <span class="strong"><strong>House</strong></span>, <span class="strong"><strong>Platform</strong></span>, and <span class="strong"><strong>Gem</strong></span> as props. These textures are all featured in the <span class="strong"><strong>Project</strong></span> panel, though not all are used in the game yet. Select these textures and, from the Inspector, assign them the same name for the <span class="strong"><strong>Packing Tag</strong></span> field (Props). Then, click on <span class="strong"><strong>Apply</strong></span>. See <span class="emphasis"><em>Figure 5.52</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_52.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.52: Assigning multiple textures to the same Packing Tag</p></div></div><p>Now, repeat <a id="id347" class="indexterm"/>this process for the <span class="strong"><strong>Backgrounds</strong></span>, selecting all backgrounds and assigning them to the <span class="strong"><strong>Background Packing</strong></span> tag. Then, click on <span class="strong"><strong>Apply</strong></span>. See <span class="emphasis"><em>Figure 5.53</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_53.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.53: Creating a Background batch of textures</p></div></div><p>That's it! Now, when you press on the play icon, Unity will automatically batch and organize the textures for optimal performance based on your groupings. This technique can significantly reduce draw calls. On pressing the play icon, you may see a loading bar or progress bar while Unity internally generates a new texture set. During Play Mode, you can view how Unity has organized the textures through the <span class="strong"><strong>Sprite Packer</strong></span> window. To access this, select <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Sprite Packer</strong></span>. See <span class="emphasis"><em>Figure 5.54</em></span>:</p><div class="mediaobject"><img src="graphics/figure_05_54.jpg" alt="Optimization"/><div class="caption"><p>Figure 5.54: Unity organizes all similarly tagged textures into the same texture space as an Atlas</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Summary</h1></div></div></div><p>Superb work! We've come a long way in this chapter, from a blank project to an effective 2D game in which a player character can navigate a complete 2D environment with 2D Physics. The character can move left and right and jump, and the sprite texture will change to match the direction of travel as well. In addition, Sprite Packing has been used to optimize runtime performance, which is ideal for mobile devices. In the next chapter, we'll continue working by adding obstacles, collectable objects, and more!</p></div></body></html>