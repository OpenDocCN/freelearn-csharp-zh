<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-192"><a id="_idTextAnchor371"/>9</h1>
<h1 id="_idParaDest-193"><a id="_idTextAnchor372"/>Testing in ASP.NET Core (Part 1 – Unit Testing)</h1>
<p>Testing is an essential part of any software development process, including ASP.NET Core web API development. Testing helps to ensure that the application works as expected and meets the requirements. It also helps to ensure that any changes made to the code don’t break existing functionality.</p>
<p>In this chapter, we’ll look at the different types of testing that are available in ASP.NET Core and how to implement unit tests in ASP.NET Core web API applications.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Introduction to testing in ASP.NET Core</li>
<li>Writing unit tests</li>
<li>Testing the database access layer</li>
</ul>
<p>By the end of this chapter, you will be able to write unit tests for your ASP.NET Core web API application to ensure that the code unit is functioning correctly. You will also learn how to use some libraries, such as <code>Moq</code> and <code>FluentAssertions</code>, to make your tests more readable and maintainable.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor373"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter9</a>. You can use VS Code or VS 2022 to open the solutions.</p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor374"/>Introduction to testing in ASP.NET Core</h1>
<p>Different types of testing can be performed on an ASP.NET Core web API application, as follows:</p>
<ul>
<li><strong class="bold">Unit testing</strong>: This is the<a id="_idIndexMarker921"/> process of testing individual units of code, such as methods and <a id="_idIndexMarker922"/>classes, to ensure that they work as expected. Unit tests should be small, fast, and isolated from other units of code. Mocking frameworks can be used to isolate units of code from their dependencies, such as databases and external services.</li>
<li><strong class="bold">Integration testing</strong>: This<a id="_idIndexMarker923"/> involves testing the integration between<a id="_idIndexMarker924"/> different components of the application to ensure that they work together as expected. This type of testing helps to identify issues that may arise when the application is deployed to a production environment. Generally, integration tests are slower than unit tests. Integration tests may use mock objects or real objects, depending on the scenario. For example, if the integration test is to test the integration between the application and a database, then a real database instance should be used. But if the integration test is to test the application’s integration with an external service, such as a payment service, then we should use a mock object to simulate the external service. In the microservices architecture, integration tests are more complicated, as they may involve multiple services. Besides the integration tests for each service, there should also be integration tests for the entire system.</li>
<li><strong class="bold">End-to-end testing</strong>: This is <a id="_idIndexMarker925"/>the process of testing the application from the user’s <a id="_idIndexMarker926"/>perspective to ensure that the entire system from start to finish, including the user interface, the web API, the database, and more, is working as expected. End-to-end testing typically involves simulating user interactions with the application, such as clicking buttons and entering data into forms.</li>
<li><strong class="bold">Regression testing</strong>: This <a id="_idIndexMarker927"/>involves testing whether the application still works as<a id="_idIndexMarker928"/> expected after new features are added or bugs are fixed. Regression testing is usually performed after the application is deployed to a production environment. It helps to ensure that the <a id="_idIndexMarker929"/>new features <a id="_idIndexMarker930"/>or bug fixes don’t break existing functionality.</li>
<li><strong class="bold">Load testing</strong>: This <a id="_idIndexMarker931"/>involves testing whether the application can handle a normal <a id="_idIndexMarker932"/>load of users and requests. It helps to set the baseline for the performance of the application.</li>
<li><strong class="bold">Stress testing</strong>: This<a id="_idIndexMarker933"/> involves testing whether the application can handle <a id="_idIndexMarker934"/>extreme conditions, such as a sudden spike in the number of users and requests, or gradually increasing the load over a long period. It also determines whether the application can recover from failures and how long it takes to recover.</li>
<li><strong class="bold">Performance testing</strong>: This is a <a id="_idIndexMarker935"/>type of testing that evaluates the performance<a id="_idIndexMarker936"/> of the application under different workloads, including response time, throughput, resource usage, and more. Performance testing is a superset of load testing and stress testing. Generally, unit testing and integration testing are performed in the development environment and the staging environment, while performance testing is performed in a production-like environment, such as<a id="_idIndexMarker937"/> a <strong class="bold">user acceptance testing</strong> (<strong class="bold">UAT</strong>) environment, which closely mirrors the production environment in terms of infrastructure and configuration. This ensures that the performance tests are accurate and reliable. In some cases, limited performance testing can be performed in a development environment during scheduled maintenance windows to validate real-world performance scenarios.</li>
</ul>
<p>Unit testing and integration testing are the most common types of testing that are written in .NET by developers. In this chapter, we will focus on unit testing; we will discuss integration testing<a id="_idTextAnchor375"/> in <a href="B18971_10.xhtml#_idTextAnchor404"><em class="italic">Chapter 10</em></a>.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor376"/>Writing unit tests</h1>
<p>Unit tests are <a id="_idIndexMarker938"/>written to test individual units of code, such as methods and classes. Unit tests are typically written by developers who are familiar with the code. When developers develop new features or fix bugs, they should also write unit tests to ensure that the code works as expected. There are many unit testing frameworks available for .NET, including NUnit, xUnit, and MSTest. In this chapter, we will use xUnit to <a id="_idIndexMarker939"/>write unit tests since it is one of the most popular unit testing frameworks for modern .NET applic<a id="_idTextAnchor377"/>ations at present.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor378"/>Preparing the sample application</h2>
<p>The sample <a id="_idIndexMarker940"/>application, <code>InvoiceApp</code>, is a simple ASP.NET Core web API application that exposes a set of RESTful APIs for managing invoices. The sample application uses EF Core to store and retrieve data from a SQL Server database. It has the following endpoints:</p>
<ul>
<li><code>GET /api/invoices</code>: Retrieves a list of invoices</li><li><code>GET /api/invoices/{id}</code>: Retrieves an invoice by ID</li><li><code>POST /api/invoices</code>: Creates a new invoice</li><li><code>PUT /api/invoices/{id}</code>: Updates an existing invoice</li><li><code>DELETE /api/invoices/{id}</code>: Deletes an invoice</li><li><code>PATCH /api/invoices/{id}/status</code>: Updates the status of an invoice</li><li><code>POST /api/invoices/{id}/send</code>: Sends an invoice email to the contact</li></ul></li>
<li><code>GET /api/contacts</code>: Retrieves a list of contacts</li><li><code>GET /api/contacts/{id}</code>: Retrieves a contact by ID</li><li><code>POST /api/contacts</code>: Creates a new contact</li><li><code>PUT /api/contacts/{id}</code>: Updates an existing contact</li><li><code>DELETE /api/contacts/{id}</code>: Deletes a contact</li><li><code>GET /api/contacts/{id}/invoices</code>: Retrieves a list of invoices for a contact</li></ul></li>
</ul>
<p>Note that the preceding endpoints are not enough to build a complete invoice management application. It is just a sample application to demonstrate how to write unit tests and integration tests for ASP.NET Core web API applications.</p>
<p>In addition, the<a id="_idIndexMarker943"/> sample application has a Swagger UI that can be used to test the APIs. <em class="italic">Figure 9</em><em class="italic">.1</em> shows the Swagger UI for the sample application:</p>
<div><div><img alt="Figure 9.1 – The sample application API endpoints" src="img/B18971_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The sample application API endpoints</p>
<p>After you <a id="_idIndexMarker944"/>run the sample application using the <code>dotnet run</code> command, you can access the Swagger UI at <a href="http://localhost:5087/swagger/index.html">http://localhost:5087/swagger/index.html</a>.</p>
<p>Now, we will use this sample application to demonstrate how to write unit tests for ASP.NET Core<a id="_idTextAnchor379"/> web API applications.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor380"/>Setting up the unit tests project</h2>
<p>We will use xUnit to write<a id="_idIndexMarker945"/> unit tests for the sample application. xUnit is a popular unit testing framework for .NET applications. It is a free, open-source project that has been around for many years. It is also the default unit testing framework for .NET Core and .NET 5+ applications. You can find more information about xUnit at <a href="https://xunit.net/">https://xunit.net/</a>.</p>
<p>To set up the test project, you can use VS 2022 or the .NET CLI. If you use VS 2022, you can create a new xUnit test project by right-clicking on the solution and selecting <code>InvoiceApp.UnitTests</code> and click <strong class="bold">Create</strong> to create the project:</p>
<div><div><img alt="Figure 9.2 – Creating a new xUnit test project in VS 2022" src="img/B18971_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Creating a new xUnit test project in VS 2022</p>
<p>After you create the project, add a project reference to the <code>InvoiceApp.WebApi</code> project so that the test project can access the classes in the main web API project. You can do this by right-clicking on the <code>InvoiceApp.WebApi</code> project from the list of<a id="_idIndexMarker946"/> projects and click <strong class="bold">OK</strong> to add the project reference:</p>
<div><div><img alt="Figure 9.3 – Adding a project reference to the test project in VS 2022" src="img/B18971_09_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Adding a project reference to the test project in VS 2022</p>
<p>If you use the .NET CLI, you can create a new xUnit test project by running the following commands in the terminal:</p>
<pre class="console">
dotnet new xunit -n InvoiceApp.UnitTests</pre> <p>Then, you can add the test project to the solution by running the following commands:</p>
<pre class="console">
dotnet sln InvoiceApp.sln add InvoiceApp.UnitTests/InvoiceApp.UnitTests.csproj</pre> <p>You also need to add the reference to the main project by running the following command:</p>
<pre class="console">
dotnet add InvoiceApp.UnitTests/InvoiceApp.UnitTests.csproj reference InvoiceApp.WebApi/InvoiceApp.WebApi.csproj</pre> <p>The default xUnit <a id="_idIndexMarker947"/>test project template contains a sample unit test. You can delete the sample unit test named <code>UnitTest1.cs</code>; we will write our own unit tests in the next section.</p>
<p>If you create the test project starting from a blank .NET library project, you need to add the following packages to the test project:</p>
<ul>
<li><code>Microsoft.NET.Test.Sdk</code>: This is required for running unit tests</li>
<li><code>xunit</code>: This is the xUnit framework that we will use to write unit tests</li>
<li><code>xunit.runner.visualstudio</code>: This is required for running unit tests in Visual Studio</li>
<li><code>coverlet.collector</code>: This is an open-source project that provides code coverage analysis for .NET applications</li>
</ul>
<p>When we write unit <a id="_idIndexMarker948"/>tests, keep in mind that one unit test should test one unit of code, such as a method or a class. The unit test should be isolated from other units of code. If one method depends on another method, we should mock the other method to isolate the unit of code to ensure that we focus on the behavior of the unit of c<a id="_idTextAnchor381"/>ode that we are testing.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor382"/>Writing unit tests without dependencies</h2>
<p>Let’s see the <a id="_idIndexMarker949"/>first example. In the sample application, you can find a <code>Services</code> folder, which includes the <code>IEmailService</code> interface and its implementation, <code>EmailService</code>. The <code>EmailService</code> class has a method named <code>GenerateInvoiceEmail()</code>. This method is a simple function that generates an email according to the <code>Invoice</code> entity. The following code shows the <code>GenerateInvoiceEmail()</code> method:</p>
<pre class="source-code">
public (string to, string subject, string body) GenerateInvoiceEmail(Invoice invoice){
    var to = invoice.Contact.Email;
    var subject = $"Invoice {invoice.InvoiceNumber} for {invoice.Contact.FirstName} {invoice.Contact.LastName}";
    var body = $"""
        Dear {invoice.Contact.FirstName} {invoice.Contact.LastName},
        Thank you for your business. Here are your invoice details:
        Invoice Number: {invoice.InvoiceNumber}
        Invoice Date: {invoice.InvoiceDate.LocalDateTime.ToShortDateString()}
        Invoice Amount: {invoice.Amount.ToString("C")}
        Invoice Items:
        {string.Join(Environment.NewLine, invoice.InvoiceItems.Select(i =&gt; $"{i.Description} - {i.Quantity} x {i.UnitPrice.ToString("C")}"))}
        Please pay by {invoice.DueDate.LocalDateTime.ToShortDateString()}. Thank you!
        Regards,
        InvoiceApp
        """;
    return (to, subject, body);
}</pre>
<p class="callout-heading">Raw string literal</p>
<p class="callout">The <code>body</code> variable is a <a id="_idIndexMarker950"/>raw string literal, which is a new feature that was introduced in C# 11. Raw string literals are <a id="_idIndexMarker951"/>enclosed in triple quotes (<code>"""</code>). They can span multiple lines and can contain double quotes without escaping them. You can find more information about raw string<a id="_idIndexMarker952"/> literals at <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/raw-string</a>. Raw strings can also be used with interpolated strings, which is convenient for generating strings with variables.</p>
<p>There is no<a id="_idIndexMarker953"/> dependency in the <code>GenerateInvoiceEmail()</code> method, so we can write a unit test for this method without mocking any other methods. Create a class named <code>EmailServiceTests</code> in the <code>InvoiceApp.UnitTests</code> project. Then, add the following code to the class:</p>
<pre class="source-code">
[Fact]public void GenerateInvoiceEmail_Should_Return_Email()
{
    var invoiceDate = DateTimeOffset.Now;
    var dueDate = invoiceDate.AddDays(30);
    // Arrange
    var invoice = new Invoice
    {
        Id = Guid.NewGuid(),
        InvoiceNumber = "INV-001",
        Amount = 500,
        DueDate = dueDate,
        // Omit other properties for brevity
    };
    // Act
    var (to, subject, body) = new EmailService().GenerateInvoiceEmail(invoice);
    // Assert
    Assert.Equal(invoice.Contact.Email, to);
    Assert.Equal($"Invoice INV-001 for John Doe", subject);
    Assert.Equal($"""
        Dear John Doe,
        Thank you for your business. Here are your invoice details:
        Invoice Number: INV-001
        Invoice Date: {invoiceDate.LocalDateTime.ToShortDateString()}
        Invoice Amount: {invoice.Amount.ToString("C")}
        Invoice Items:
        Item 1 - 1 x $100.00
        Item 2 - 2 x $200.00
        Please pay by {invoice.DueDate.LocalDateTime.ToShortDateString()}. Thank you!
        Regards,
        InvoiceApp
        """, body);
}</pre>
<p>The <code>Fact</code> attribute<a id="_idIndexMarker954"/> indicates that the <code>GenerateInvoiceEmail_Should_Return_Email()</code> method is a unit test so that xUnit can discover and run this method as a unit test. In the <code>GenerateInvoiceEmail_Should_Return_Email()</code> method, we created an <code>Invoice</code> object and passed it to the <code>GenerateInvoiceEmail()</code> method. Then, we used the <code>Assert</code> class to verify that the <code>GenerateInvoiceEmail()</code> method returns the expected email.</p>
<p>When writing <a id="_idIndexMarker955"/>unit tests, we follow the <em class="italic">Arrange-Act-Assert</em> pattern:</p>
<ul>
<li><strong class="bold">Arrange</strong>: This is where <a id="_idIndexMarker956"/>we prepare the data and set up the environment for the unit test</li>
<li><strong class="bold">Act</strong>: This is where we call the method that we want to test</li>
<li><strong class="bold">Assert</strong>: This is where we verify that the method returns the expected result or that the method behaves as expected</li>
</ul>
<p>To run the unit test in VS 2022, you can right-click on the <code>InvoiceApp.UnitTests</code> project or the <code>EmailServiceTest.cs</code> file and select <strong class="bold">Run Tests</strong>. You can also use the <strong class="bold">Test Explorer</strong> window to run the unit test by clicking the <strong class="bold">Test</strong> menu and selecting <strong class="bold">Run </strong><strong class="bold">all tests</strong>:</p>
<div><div><img alt="Figure 9.4 – Running unit tests in VS 2022" src="img/B18971_09_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Running unit tests in VS 2022</p>
<p>VS Code supports running unit tests as well. Click the <strong class="bold">Testing</strong> icon on the left-hand side of the VS Code window to open the <strong class="bold">Test</strong> view; you will see the unit tests, as shown in <em class="italic">Figure 9</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 9.5 – Running unit tests in VS Code" src="img/B18971_09_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Running unit tests in VS Code</p>
<p>If you use the .NET CLI, you can run the unit tests by running the following command in the terminal:</p>
<pre class="console">
dotnet test</pre> <p>You will see the<a id="_idIndexMarker957"/> following output:</p>
<pre class="source-code">
Starting test execution, please wait...A total of 1 test files matched the specified pattern.
Passed!  - Failed:     0, Passed:     1, Skipped:     0, Total:     1, Duration: &lt; 1 ms - InvoiceApp.UnitTests.dll (net8.0)</pre>
<p>The output shows that the unit test passed. If you want to see the detailed test results, you can run the following command:</p>
<pre class="console">
dotnet test --verbosity normal</pre> <p>You will see<a id="_idIndexMarker958"/> detailed test results that show the test name, the resul<a id="_idTextAnchor383"/>t, the duration, and the output.</p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor384"/>Writing unit tests with dependencies</h2>
<p>Let’s look at <a id="_idIndexMarker959"/>another example. In the <code>EmailService</code> class, there is a method named <code>SendEmailAsync()</code>, which sends an email to the recipient. In real-world applications, we usually use a third-party email service to send emails. To make the <code>EmailService</code> class testable, we can create an <code>IEmailSender</code> interface and its implementation, <code>EmailSender</code>. The <code>EmailSender</code> class is a wrapper of the <code>SmtpClient</code> class, which is used to send emails. The following code shows the updated <code>EmailService</code> class:</p>
<pre class="source-code">
public async Task SendEmailAsync(string to, string subject, string body){
    // Mock the email sending process
    // In real world, you may use a third-party email service, such as SendGrid, MailChimp, Azure Logic Apps, etc.
    logger.LogInformation($"Sending email to {to} with subject {subject} and body {body}");
    try
    {
        await emailSender.SendEmailAsync(to, subject, body);
        logger.LogInformation($"Email sent to {to} with subject {subject}");
    }
    catch (SmtpException e)
    {
        logger.LogError(e, $"SmtpClient error occurs. Failed to send email to {to} with subject {subject}.");
    }
    catch (Exception e)
    {
        logger.LogError(e, $"Failed to send email to {to} with subject {subject}.");
    }
}</pre>
<p>So, now, <code>EmailService</code> has a dependency on the <code>IEmailSender</code> interface. To test the behavior of the <code>SendEmailAsync()</code> method of the <code>EmailService</code> class, we need to mock the <code>IEmailSender</code> interface to isolate the <code>EmailService</code> class from the <code>EmailSender</code> class. Otherwise, if any error occurs in the unit test, we cannot say for sure whether the error is caused by the <code>EmailService</code> class or the <code>EmailSender</code> class.</p>
<p>We can use the <code>Moq</code> library<a id="_idIndexMarker960"/> to mock the <code>IEmailSender</code> interface. <code>Moq</code> is a popular mocking library for .NET. It is available as a NuGet package. To install <code>Moq</code>, you can use <strong class="bold">NuGet Package Manager</strong> in VS 2022 or run the following command:</p>
<pre class="console">
dotnet add package Moq</pre> <p>Then, we can create the unit tests for the <code>SendEmailAsync()</code> method. Because the <code>SendEmailAsync()</code> method may throw an exception if the email-sending process fails, we need to write two unit tests to test the success and failure scenarios. The following code shows the unit test for the success scenario:</p>
<pre class="source-code">
[Fact]public async Task SendEmailAsync_Should_Send_Email()
{
    // Arrange
    var to = "user@example.com";
    var subject = "Test Email";
    var body = "Hello, this is a test email";
    var emailSenderMock = new Mock&lt;IEmailSender&gt;();
    emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))
        .Returns(Task.CompletedTask);
    var loggerMock = new Mock&lt;ILogger&lt;IEmailService&gt;&gt;();
    loggerMock.Setup(l =&gt; l.Log(It.IsAny&lt;LogLevel&gt;(), It.IsAny&lt;EventId&gt;(), It.IsAny&lt;It.IsAnyType&gt;(),
        It.IsAny&lt;Exception&gt;(), (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;())).Verifiable();
    var emailService = new EmailService(loggerMock.Object, emailSenderMock.Object);
    // Act
    await emailService.SendEmailAsync(to, subject, body);
    // Assert
    emailSenderMock.Verify(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()), Times.Once);
    loggerMock.Verify(
        l =&gt; l.Log(
            It.IsAny&lt;LogLevel&gt;(),
            It.IsAny&lt;EventId&gt;(),
            It.Is&lt;It.IsAnyType&gt;((v, t) =&gt; v.ToString().Contains($"Sending email to {to} with subject {subject} and body {body}")),
            It.IsAny&lt;Exception&gt;(),
            (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
        ),
        Times.Once
    );
    loggerMock.Verify(
        l =&gt; l.Log(
            It.IsAny&lt;LogLevel&gt;(),
            It.IsAny&lt;EventId&gt;(),
            It.Is&lt;It.IsAnyType&gt;((v, t) =&gt; v.ToString().Contains($"Email sent to {to} with subject {subject}")),
            It.IsAny&lt;Exception&gt;(),
            (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
        ),
        Times.Once
    );
}</pre>
<p>In the<a id="_idIndexMarker961"/> preceding code, we use the <code>Mock</code> class to create mock objects of the <code>IEmailSender</code> interface and the <code>ILogger</code> interface. We need to set up the behavior of the methods for the mock objects. If the methods used in the unit test are not set up, the unit test will fail. For example, we use the <code>SetUp()</code> method to mock the <code>SendEmailAsync</code> method of the <code>IEmailSender</code> interface:</p>
<pre class="source-code">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))    .Returns(Task.CompletedTask);</pre>
<p>The <code>SetUp()</code> method takes a lambda expression as the parameter, which is used to configure the behavior of the <code>SendEmailAsync()</code> method. In the preceding code, we use the <code>It.IsAny&lt;string&gt;()</code> method to specify that the <code>SendEmailAsync()</code> method can accept any string value as the parameter. Then, we use the <code>Returns()</code> method to specify the return value of the <code>SendEmailAsync()</code> method. In this case, we use the <code>Task.CompletedTask</code> property to specify that the <code>SendEmailAsync()</code> method will return a completed task. If you need to return a specific value, you can also use the <code>Returns()</code> method to return a specific value. For example, if the <code>SendEmailAsync()</code> method returns a <code>bool</code> value, you can use the following code to return a <code>true</code> value:</p>
<pre class="source-code">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))    .ReturnsAsync(true);</pre>
<p class="callout-heading">Mocking the ILogger interface</p>
<p class="callout">The <code>EmailService</code> class uses the <code>ILogger</code> interface to log the information and errors. We use the <code>LogInformation()</code> method to log the information and <code>LogError()</code> method to log the errors. However, we cannot mock the <code>LogInformation()</code> or <code>LogError()</code> method directly because they are extension methods on top of the <code>ILogger</code> interface. These extension methods, such as <code>LogInformation()</code>, <code>LogError()</code>, <code>LogDebug()</code>, <code>LogWarning()</code>, <code>LogCritical()</code>, <code>LogTrace()</code>, and others, all call the <code>Log()</code> method of the <code>ILogger</code> interface. Therefore, to verify that a given log message is logged, it is necessary to mock only the <code>Log()</code> method of the <code>ILogger</code> interface.</p>
<p>If the <code>SendEmailAsync()</code> method throws an exception, we need to ensure the logger will log the <a id="_idIndexMarker962"/>exception when the exception occurs. To test the failure scenario, we need to mock the <code>SendEmailAsync()</code> method so that it throws an exception. We can use the <code>ThrowsAsync()</code> method to mock the <code>SendEmailAsync()</code> method to throw an exception explicitly. The following code shows how to mock the <code>SendEmailAsync()</code> method to throw an exception:</p>
<pre class="source-code">
emailSenderMock.Setup(m =&gt; m.SendEmailAsync(It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;(), It.IsAny&lt;string&gt;()))  .ThrowsAsync(new SmtpException("Test SmtpException"));</pre>
<p>Then, we can verify whether the <code>LogError()</code> method of the <code>ILogger</code> interface is called when the <code>SendEmailAsync()</code> method throws an exception, as shown here:</p>
<pre class="source-code">
// Act + Assertawait Assert.ThrowsAsync&lt;SmtpException&gt;(() =&gt; emailService.SendEmailAsync(to, subject, body));
loggerMock.Verify(
    l =&gt; l.Log(
        It.IsAny&lt;LogLevel&gt;(),
        It.IsAny&lt;EventId&gt;(),
        It.Is&lt;It.IsAnyType&gt;((v, t) =&gt;
            v.ToString().Contains($"Failed to send email to {to} with subject {subject}")),
        It.IsAny&lt;SmtpException&gt;(),
        (Func&lt;It.IsAnyType, Exception?, string&gt;)It.IsAny&lt;object&gt;()
    ),
    Times.Once
);</pre>
<p>In this way, we can ensure that the <code>SendEmailAsync()</code> method will log the exception when the exception occurs.</p>
<p>When we write<a id="_idIndexMarker963"/> unit tests, note that the test method name should be descriptive and should indicate the purpose of the test. For example, <code>SendEmailAsync_ShouldLogError_WhenEmailSendingFails()</code> is a good name because it indicates that the <code>SendEmailAsync</code> method should log an error when the email sending fails. However, <code>SendEmailAsyncTest()</code> is not a good name because it does not indicate the purpose of the test.</p>
<p>For more information about how to use the <code>Mock</code> library to create mock obj<a id="_idTextAnchor385"/>ects, see <a href="https://github.com/moq/moq">https://github.com/moq/moq</a>.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor386"/>Using FluentAssertions to verify the test results</h2>
<p><code>xUnit</code> provides a set <a id="_idIndexMarker964"/>of static assertion methods to verify the test results. For example, we can use the <code>Assert.Equal()</code> method to verify if two objects are equal. These methods cover most of the scenarios, such as verifying objects, collections, exceptions, events, equality, types, and more. Here is a list of the assertion methods provided by xUnit:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-7">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">xUnit </strong><strong class="bold">Assertion Methods</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Explanation</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Equal(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> value is equal to the <code>actual</code> value</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotEqual(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> value is not equal to the <code>actual</code> value</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.StrictEqual(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> value is strictly equal to the <code>actual</code> value, using the type’s default comparer</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotStrictEqual(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> value is strictly not equal to the <code>actual</code> value, using the type’s default comparer</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Same(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> object is the same instance as the <code>actual</code> object</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotSame(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>expected</code> object is not the same instance as the <code>actual</code> object</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.True(condition)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>condition</code> is true</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.False(condition)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>condition</code> is false</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Null(object)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>object</code> is null</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotNull(object)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>object</code> is not null</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.IsType(expectedType, object)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>object</code> is exactly <code>expectedType</code>, and not a derived type</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.IsNotType(unexpectedType, object)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>object</code> is not exactly <code>unexpectedType</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.IsAssignableFrom(expectedType, object)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>object</code> is assignable to <code>expectedType</code>, which means that <code>object</code> is the given type or a derived type</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Contains(expected, collection)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>collection</code> contains the <code>expected</code> object</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.DoesNotContain(expected, collection)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>collection</code> does not contain the <code>expected</code> object</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Empty(collection)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>collection</code> is empty</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotEmpty(collection)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>collection</code> is not empty</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Single(collection)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>collection</code> contains exactly one element of the given type</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.InRange(actual, </code><code>low, high)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>actual</code> value is within the range of <code>low</code> and <code>high</code> (inclusive)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotInRange(actual, </code><code>low, high)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that the <code>actual</code> value is not within the range of <code>low</code> and <code>high</code> (inclusive)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Throws&lt;exceptionType&gt;(action)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>action</code> throws an exception of the specified <code>exceptionType</code>, and not a derived exception type</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.ThrowsAny&lt;exceptionType&gt;(action)</code></p>
</td>
<td class="No-Table-Style">
<p>Verifies that <code>action</code> throws an exception of the specified <code>exceptionType</code> or a derived exception type</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.1 – List of assertion methods provided by xUnit</p>
<p>Note this <a id="_idIndexMarker965"/>list is not complete. You can find more assertion methods in xUnit’s GitHub repository: <a href="https://github.com/xunit/assert.xunit">https://github.com/xunit/assert.xunit</a>.</p>
<p>Although the assertion methods provided by xUnit are enough for most scenarios, they are not very readable. A good way to make the unit tests more natural and readable is to use <code>FluentAssertions</code>, an open-source assertion library for .NET. It provides a set of extension methods that allow us to write assertions fluently.</p>
<p>To install <code>FluentAssertions</code>, we can use the following .NET CLI command:</p>
<pre class="console">
dotnet add package FluentAssertions</pre> <p>You can also use NuGet Package Manager to install the <code>FluentAssertions</code> package if you use VS 2022.</p>
<p>Then, we can use the <code>Should()</code> method to verify the test results. For example, we can use the <code>Should().Be()</code> method to verify whether two objects are equal.</p>
<p>The following code shows how to use the <code>Should().Be()</code> method to verify whether the <code>GetInvoicesAsync()</code> method returns a list of invoices:</p>
<pre class="source-code">
// Omitted code for brevityreturnResult.Should().NotBeNull();
returnResult.Should().HaveCount(2);
// Or use returnResult.Count.Should().Be(2);
returnResult.Should().Contain(i =&gt; i.InvoiceNumber == "INV-001");
returnResult.Should().Contain(i =&gt; i.InvoiceNumber == "INV-002");</pre>
<p>The <code>FluentAssertions</code> method is<a id="_idIndexMarker966"/> more intuitive and readable than the <code>Assert.Equal()</code> method. For most scenarios, you can easily replace the assertion methods provided by xUnit with the <code>FluentAssertions</code> methods without searching the documentation.</p>
<p>Let’s see how to verify the exception using <code>FluentAssertions</code>. In the <code>EmailServiceTests</code> class, there is a <code>SendEmailAsync_Should_Log_SmtpException()</code> method. This method verifies whether the <code>SendEmailAsync()</code> method will log the exception when the <code>SendEmailAsync()</code> method throws an exception. The following code shows how to use <code>xUnit</code> to verify the exception:</p>
<pre class="source-code">
await Assert.ThrowsAsync&lt;SmtpException&gt;(() =&gt; emailService.SendEmailAsync(to, subject, body));</pre> <p>We can use the <code>Should().ThrowAsync&lt;&gt;()</code> method of <code>FluentAssertions</code> to verify the exception, as shown in the following code:</p>
<pre class="source-code">
var act = () =&gt; emailService.SendEmailAsync(to, subject, body);await act.Should().ThrowAsync&lt;SmtpException&gt;().WithMessage("Test SmtpException");</pre>
<p>Using <code>FluentAssertions</code> is more readable and intuitive than the xUnit way. Here is a table comparing some common assertion methods provided by xUnit and <code>FluentAssertions</code>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-6">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">xUnit </strong><strong class="bold">Assertion Method</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">FluentAssertions </strong><strong class="bold">Assertion Method</strong></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Equal(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().Be(expected)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotEqual(expected, actual)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().NotBe(expected)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.True(condition)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().BeTrue()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.False(condition)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().BeFalse()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Null(object)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().BeNull()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotNull(object)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().NotBeNull()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Contains(expected, collection)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().Contain(expected)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.DoesNotContain(expected, collection)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().NotContain(expected)</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Empty(collection)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().BeEmpty()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.NotEmpty(collection)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().NotBeEmpty()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.Throws&lt;TException&gt;(action)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().Throw&lt;TException&gt;()</code></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><code>Assert.DoesNotThrow(action)</code></p>
</td>
<td class="No-Table-Style">
<p><code>.</code><code>Should().NotThrow()</code></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 9.2 – Comparison of common assertion methods provided by xUnit and FluentAssertions</p>
<p>Note that the <a id="_idIndexMarker967"/>preceding table is not an exhaustive list. You can find more extension methods in the official documentation <a id="_idIndexMarker968"/>of <code>FluentAssertions</code>: <a href="https://fluentassertions.com/introduction">https://fluentassertions.com/introduction</a>.</p>
<p>Besides the fluent assertion methods, <code>FluentAssertions</code> also provides better error messages if the test fails. For example, if we use the <code>Assert.Equal()</code> method to verify whether <code>returnResult</code> contains two invoices, the code will look like this:</p>
<pre class="source-code">
Assert.Equal(3, returnResult.Count);</pre> <p>If the <a id="_idIndexMarker969"/>test fails, the error message will be as follows:</p>
<pre class="source-code">
<strong class="bold">InvoiceApp.UnitTests.InvoiceControllerTests.GetInvoices_ShouldReturnInvoices</strong><strong class="bold">  </strong> <strong class="bold">Source:</strong> <strong class="bold">InvoiceControllerTests.cs</strong> <strong class="bold">line</strong> <strong class="bold">21</strong>
<strong class="bold">  </strong> <strong class="bold">Duration:</strong> <strong class="bold">372 ms</strong>
<strong class="bold">  Message:</strong>
<strong class="bold">Assert.Equal() Failure</strong>
<strong class="bold">Expected: 3</strong>
<strong class="bold">Actual:   2</strong>
<strong class="bold">  Stack Trace:</strong>
<strong class="bold">InvoiceControllerTests.GetInvoices_ShouldReturnInvoices()</strong> <strong class="bold">line</strong> <strong class="bold">34</strong>
<strong class="bold">InvoiceControllerTests.GetInvoices_ShouldReturnInvoices()</strong> <strong class="bold">line</strong> <strong class="bold">41</strong>
<strong class="bold">--- End of stack trace from previous location ---</strong></pre>
<p>If we have multiple <code>Assert.Equal()</code> methods in the test method, which is not recommended but something we have to do occasionally, we cannot immediately know which <code>Assert.Equal()</code> method fails. We need to check the line number of the error message to find the failing assertion. This is not very convenient.</p>
<p>If we use <code>FluentAssertions</code>, the assertion code will look like this:</p>
<pre class="source-code">
returnResult.Count.Should().Be(3);</pre> <p>If the test fails with the same reason, the error message will be as follows:</p>
<pre class="source-code">
<strong class="bold">InvoiceApp.UnitTests.InvoiceControllerTests.GetInvoices_ShouldReturnInvoices</strong><strong class="bold">  </strong> <strong class="bold">Source:</strong> <strong class="bold">InvoiceControllerTests.cs line 21</strong>
<strong class="bold">  </strong> <strong class="bold">Duration:</strong> <strong class="bold">408 ms</strong>
<strong class="bold">  Message:</strong>
<strong class="bold">Expected returnResult.Count to be 3, but found 2.</strong></pre>
<p>Now, the error message is more detailed and intuitive and tells us which assertion fails. This is very helpful when we have multiple assertions in the test method.</p>
<p>You can even enrich the error message by adding a custom message to the assertion method. For example, we can add a custom message to the <code>Should().Be()</code> method, as follows:</p>
<pre class="source-code">
returnResult.Count.Should().Be(3, "The number of invoices should be 3");</pre> <p>Now, the<a id="_idIndexMarker970"/> error message will be as follows:</p>
<pre class="source-code">
Expected returnResult.Count to be 3 because The number of invoices should be 3, but found 2.</pre> <p>Therefore, it is highly recommended to use <code>FluentAssertions</code> in your tests. It makes your tests more readable and maintainab<a id="_idTextAnchor387"/>le.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor388"/>Testing the database access layer</h1>
<p>In many web API applications, we<a id="_idIndexMarker971"/> need to access the database to perform CRUD operations. In this section, we will learn how to test the database access layer in unit te<a id="_idTextAnchor389"/>sts.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor390"/>How can we test the database access layer?</h2>
<p>Currently, we inject <code>InvoiceDbContext</code> into controllers to access the database. This approach is easy for<a id="_idIndexMarker972"/> development, but it tightly couples the controllers with the <code>InvoiceDbContext</code> class. When we test the controllers, we need to create a real <code>InvoiceDbContext</code> object and use it to test the controllers, which means controllers are not tested in isolation. This problem can be addressed in a variety of ways:</p>
<ul>
<li>Use the <code>InMemoryDatabase</code> provider of EF Core to create an in-memory database as the fake database</li>
<li>Use the SQLite in-memory database as the fake database</li>
<li>Create a separate repository layer to encapsulate the database access code, inject the repository layer into controllers (or services that need to access databases), and then use <code>Mock </code>objects to mock the repository layer</li>
<li>Use the real database for testing</li>
</ul>
<p>Each approach has its pros and cons:</p>
<ul>
<li>The <code>InMemoryDatabase</code> provider was originally designed for internal testing of EF Core. However, it is not a good choice for testing other applications because it does not behave like a real database. For example, it does not support transactions and raw SQL queries. So, it is not a good choice for testing the database access code.</li>
<li>SQLite also provides an in-memory database feature that can be used for testing. However, it has similar limitations to EF Core’s <code>InMemoryDatabase</code> provider. If the production database is SQL Server, EF Core cannot guarantee that the database access code will work correctly on SQL Server if we use SQLite for testing.</li>
<li>Creating a <a id="_idIndexMarker973"/>separate repository layer is to decouple the controllers from the <code>DbContext</code> class. In this pattern, a separate <code>IRepository</code> interface is created between the application code and <code>DbContext</code>, and the implementation of the <code>IRepository</code> interface is injected into controllers or services. In this way, we can use <code>Mock</code> objects to mock the <code>IRepository</code> interface to test controllers or services, which means controllers or services can be tested in isolation. However, this approach requires a lot of work to create the repository layer. Also, the <code>DbContext</code> class is already a repository pattern, so creating another repository layer is redundant if you do not need to change the database provider. But this pattern still has its advantages. Tests can focus on the application logic without worrying about the database access code. Also, if you need to change the database provider, you only need to change the implementation of the <code>IRepository</code> interface, and there is no need to change the controllers or services.</li>
<li>Testing against a real database provides more benefits. One of the most important benefits is that it can ensure that the database access code works correctly on the database in production. Using a real database is also fast and reliable. However, one challenge is that we need to ensure the isolation for tests because some of them may change the data in the database. So, we need to make sure the <a id="_idIndexMarker974"/>data can be restored or recreated after the tests are completed.</li>
</ul>
<p>In this section, we will use a separate local database for testing, such as a LocalDB database. If your application will run on SQL Server, you can use another SQL Server for testing rather than LocalDB since LocalDB does not behave the same as SQL Server. If your application will run in the cloud, such as Azure, you may use an Azure SQL database. You can use another Azure SQL database for testing but you will need to allocate a small amount of resources for it to save the cost. Keep in mind that the database for testing should keep the same environment as much as possible to avoid unexpected behaviors in production.</p>
<p>Regarding the controllers, we will use the <code>InvoiceDbContext</code> class directly for simplicity; we will learn the repository pattern in future ch<a id="_idTextAnchor391"/>apters.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor392"/>Creating a test fixture</h2>
<p>When we test the <a id="_idIndexMarker975"/>CRUD methods against the database, we need to prepare the database before the tests are executed, and then clean up the database after the tests are completed so that the changes made by the tests will not affect other tests. xUnit provides the <code>IClassFixture&lt;T&gt;</code> interface to create a test fixture, which can be used to prepare and clean up the database for each test class.</p>
<p>First, we need to create a test fixture class in the <code>InvoiceApp.UnitTests</code> project, as follows:</p>
<pre class="source-code">
public class TestDatabaseFixture{
    private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceTestDb;Trusted_Connection=True";
}</pre>
<p>In the <code>TestDatabaseFixture</code> class, we define a connection string to the local database. Using a <code>const</code> string is for simplicity only. In a real application, you may want to use the configuration system to<a id="_idIndexMarker976"/> read the connection string from other sources, such as the <code>appsettings.json</code> file.</p>
<p>Then, we add a method to create the database context object, as follows:</p>
<pre class="source-code">
public InvoiceDbContext CreateDbContext()    =&gt; new(new DbContextOptionsBuilder&lt;InvoiceDbContext&gt;()
            .UseSqlServer(ConnectionString)
            .Options, null);</pre>
<p>We also need a method to initialize the database, as follows:</p>
<pre class="source-code">
public void InitializeDatabase(){
    using var context = CreateDbContext();
    context.Database.EnsureDeleted();
    context.Database.EnsureCreated();
    // Create a few Contacts
    var contacts = new List&lt;Contact&gt;
    {
        // Omitted the code for brevity
    };
    context.Contacts.AddRange(contacts);
    // Create a few Invoices
    var invoices = new List&lt;Invoice&gt;
    {
        // Omitted the code for brevity
    };
    context.Invoices.AddRange(invoices);
    context.SaveChanges();
}</pre>
<p>In the <code>InitializeDatabase()</code> method, we create a new <code>InvoiceDbContext</code> object and then use the <code>EnsureDeleted()</code> method to delete the database if it exists. Then, we use the <code>EnsureCreated()</code> method to create the database. After that, we seed some data into the database. In this example, we create a few <code>Contact</code> and <code>Invoice</code> objects and add them to the database. Finally, we call the <code>SaveChanges()</code> method<a id="_idIndexMarker977"/> to save the changes to the database.</p>
<p>Now, we need to call the <code>InitializeDatabase()</code> method to initialize the database in the constructor of the <code>TestDatabaseFixture</code> class, as follows:</p>
<pre class="source-code">
private static readonly object Lock = new();private static bool _databaseInitialized;
public TestDatabaseFixture()
{
    // This code comes from Mirosoft Docs: https://github.com/dotnet/EntityFramework.Docs/blob/main/samples/core/Testing/TestingWithTheDatabase/TestDatabaseFixture.cs
    lock (Lock)
    {
        if (!_databaseInitialized!)
        {
            InitializeDatabase();
            databaseInitialized = true;
        }
    }
}</pre>
<p>To avoid initializing the database multiple times, we use a static field, <code>_databaseInitialized</code>, to indicate whether the database has been initialized. We also define a static object, <code>Lock</code>, to ensure that the database is initialized only once. The <code>InitializeDatabase()</code> method is used to initialize the database. It will only be called once before the tests are executed.</p>
<p>There are several<a id="_idIndexMarker978"/> important things to note:</p>
<ul>
<li>xUnit creates a new instance of the test class for every test. So, the constructor of the test class is called for every test.</li>
<li>Deleting and recreating the database for each test run may slow down the tests and may not be necessary. If you do not want to delete and recreate the database for each test run, you can comment out the <code>EnsureDeleted()</code> method to allow the database to be reused. However, if you need to frequently change the database schema in the development phase, you may need to delete and recreate the database for each test run to ensure the database schema is up to date.</li>
<li>We use a lock object to ensure the <code>InitializeDatabase()</code> method is only called once for each test run. The reason is that the <code>TextDatabaseFixture</code> class can be used in multiple test classes, and xUnit can run multiple test classes in parallel. Using a lock can help us ensure the seed method is only called once. We will learn <a id="_idIndexMarker979"/>more about parallel test execution in the next section.</li>
</ul>
<p>Now that the test fixture is ready, we can use it in the t<a id="_idTextAnchor393"/>est classes.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor394"/>Using the test fixture</h2>
<p>Next, we will use the test fixture <a id="_idIndexMarker980"/>in the test classes. First, let’s test the <code>GetAll()</code> method of the <code>InvoiceController</code> class. Create a new test class named <code>InvoiceControllerTests</code> in the <code>InvoiceApp.UnitTests</code> project, as follows:</p>
<pre class="source-code">
public class InvoiceControllerTests(TestFixture fixture) : IClassFixture&lt;TestFixture&gt;{
}</pre>
<p>We use dependency injection to inject the <code>TestDatabaseFixture</code> object into the test class. Then, we can use the text fixture to create the <code>InvoiceDbContext</code> object in the test methods, as follows:</p>
<pre class="source-code">
[Fact]public async Task GetInvoices_ShouldReturnInvoices()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoicesAsync();
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Equal(2, returnResult.Count);
    Assert.Contains(returnResult, i =&gt; i.InvoiceNumber =="INV-001");
    Assert.Contains(returnResult, i =&gt; i.InvoiceNumber =="INV-002");
}</pre>
<p>In the <code>GetInvoices_ShouldReturnInvoices()</code> method, we use the fixture to create the <code>InvoiceDbContext</code> object, and then create the <code>InvoiceController</code> object with some mocked dependencies. Then, we call the <code>GetInvoicesAsync()</code> method to get the invoices from the database. Finally, we use the <code>Assert</code> class to verify the result.</p>
<p>The data we use to verify<a id="_idIndexMarker981"/> the controller is the data we seed into the database in the <code>TestDatabaseFixture</code> class. If you change the data in the <code>TestDatabaseFixture</code> class, you also need to change the expected data in the test class.</p>
<p>The <code>GetInvoices_ShouldReturnInvoices()</code> method is a simple <code>Fact</code> test method. We can also use the <code>Theory</code> test method to test the <code>GetInvoicesAsync()</code> method with different parameters. For example, we can test whether the controller can return correct invoices when we pass the <code>status</code> parameter. The test method is as follows:</p>
<pre class="source-code">
[Theory][InlineData(InvoiceStatus.AwaitPayment)]
[InlineData(InvoiceStatus.Draft)]
public async Task GetInvoicesByStatus_ShouldReturnInvoices(InvoiceStatus status)
{
    // Arrange
    await using var dbContext = _fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoicesAsync(status: status);
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Single(returnResult);
    Assert.Equal(status, returnResult.First().Status);
}</pre>
<p>In the preceding <a id="_idIndexMarker982"/>example, we use the <code>Theory</code> attribute to indicate that the test method is a <code>Theory</code> test method. A <code>Theory</code> test method can have one or more <code>InlineData</code> attributes. Each <code>InlineData</code> attribute can pass one value or multiple values to the test method. In this case, we use the <code>InlineData</code> attribute to pass the <code>InvoiceStatus</code> value to the test method. You can use multiple <code>InlineData</code> attributes to pass multiple values to the test method. The<a id="_idIndexMarker983"/> test method will be executed multiple times with different values.</p>
<p>The tests we introduced in this chapter are used to test read-only methods. They do not change the database, so we do not need to worry about the database state. In the next section, we will introduce how to write tests for methods that chan<a id="_idTextAnchor395"/>ge the database.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor396"/>Writing tests for methods that change the database</h2>
<p>If a method <a id="_idIndexMarker984"/>changes the database, we need to ensure that the database is in a known state before we run the test, and also ensure that the database is restored to its original state so that the change will not affect other tests.</p>
<p>For example, a method may delete a record from the database. If the test method deletes a record from the database but does not restore the database after the test, the next test method may fail because the record is missing.</p>
<p>Let’s create a test method for the <code>CreateInvoiceAsync()</code> method of the <code>InvoiceController</code> class. The <code>CreateInvoiceAsync()</code> method creates a new invoice in the database. The test method is as follows:</p>
<pre class="source-code">
[Fact]public async Task CreateInvoice_ShouldCreateInvoice()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    var contactId = dbContext.Contacts.First().Id;
    var invoice = new Invoice
    {
        DueDate = DateTimeOffset.Now.AddDays(30),
        ContactId = contactId,
        Status = InvoiceStatus.Draft,
        InvoiceDate = DateTimeOffset.Now,
        InvoiceItems = new List&lt;InvoiceItem&gt;
        {
            // Omitted for brevity
        }
    };
    var actionResult = await controller.CreateInvoiceAsync(invoice);
    // Assert
    var result = actionResult.Result as CreatedAtActionResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;Invoice&gt;(result.Value);
    var invoiceCreated = await dbContext.Invoices.FindAsync(returnResult.Id);
    Assert.NotNull(invoiceCreated);
    Assert.Equal(InvoiceStatus.Draft, invoiceCreated.Status);
    Assert.Equal(500, invoiceCreated.Amount);
    Assert.Equal(3, dbContext.Invoices.Count());
    Assert.Equal(contactId, invoiceCreated.ContactId);
    // Clean up
    dbContext.Invoices.Remove(invoiceCreated);
    await dbContext.SaveChangesAsync();
}</pre>
<p>In this test <a id="_idIndexMarker985"/>method, we create a new invoice and pass it to the <code>CreateInvoiceAsync()</code> method. Then, we use the <code>Assert</code> class to verify the result. Finally, we remove the invoice from the database and save the changes. Note that the result of the <code>CreateInvoiceAsync()</code> method is a <code>CreatedActionResult</code> object, which contains the created invoice. So, we should convert the result into a <code>CreatedAtActionResult</code> object, and then get the created invoice from the <code>Value</code> property. Also, in this test method, we have asserted that the <code>Amount</code> property of the created invoice is correct based on the invoice items.</p>
<p>When we run the test, an error may occur because the contact ID is incorrect, as shown here:</p>
<pre class="source-code">
Assert.Equal() FailureExpected: ae29a8ef-5e32-4707-8783-b6bc098c0ccb
Actual:   275de2a8-5e0f-420d-c68a-08db59a2942f</pre>
<p>The error says that the <code>CreateInvoiceAsync()</code> method does not behave as expected. We can debug the application to find out why the contact ID is not saved correctly. The reason is that when we created <code>Invoice</code>, we only specified the <code>ContactId</code> property, not the <code>Contact</code> property. So, EF Core could not find the contact with the specified ID, and then it created a new contact with a new ID. To fix this issue, we need to specify the <code>Contact</code> property when we create the <code>Invoice</code> object. Add the following code before calling the <code>dbContext.Invoices.AddAsync()</code> method:</p>
<pre class="source-code">
var contact = await dbContext.Contacts.FindAsync(invoice.ContactId);if (contact == null)
{
    return BadRequest("Contact not found.");
}
invoice.Contact = contact;</pre>
<p>Now, we can run the test again. This time, the test should pass. That is why unit tests are so important. They can help us find bugs early and fix them before we deploy the application to production.</p>
<p>In the preceding<a id="_idIndexMarker986"/> example, the data was created in the test method and then removed from the database after the test. There is another way to manage this scenario: using a transaction. We can use a transaction to wrap the test method, and then roll back the transaction after the test. So, the data created in the test method will not be saved to the database. In this way, we do not need to manually remove the data from the database.</p>
<p>Let’s create a test for the <code>UpdateInvoiceAsync()</code> method of the <code>InvoiceController</code> class. The <code>UpdateInvoiceAsync()</code> method updates an invoice in the database. The test method is as follows:</p>
<pre class="source-code">
[Fact]public async Task  UpdateInvoice_ShouldUpdateInvoice()
{
    // Arrange
    await using var dbContext = fixture.CreateDbContext();
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(dbContext, emailServiceMock.Object);
    // Act
    // Start a transaction to prevent the changes from being saved to the database
    await dbContext.Database.BeginTransactionAsync();
    var invoice = dbContext.Invoices.First();
    invoice.Status = InvoiceStatus.Paid;
    invoice.Description = "Updated description";
    invoice.InvoiceItems.ForEach(x =&gt;
    {
        x.Description = "Updated description";
        x.UnitPrice += 100;
    });
    var expectedAmount = invoice.InvoiceItems.Sum(x =&gt; x.UnitPrice * x.Quantity);
    await controller.UpdateInvoiceAsync(invoice.Id, invoice);
    // Assert
    dbContext.ChangeTracker.Clear();
    var invoiceUpdated = await dbContext.Invoices.SingleAsync(x =&gt; x.Id == invoice.Id);
    Assert.Equal(InvoiceStatus.Paid, invoiceUpdated.Status);
    Assert.Equal("Updated description", invoiceUpdated.Description);
    Assert.Equal(expectedAmount, invoiceUpdated.Amount);
    Assert.Equal(2, dbContext.Invoices.Count());
}</pre>
<p>In the <code>UpdateInvoice_ShouldUpdateInvoice()</code> method, before we call the <code>UpdateInvoiceAsync()</code> method, we start a transaction. After the test method is executed, we do not<a id="_idIndexMarker987"/> commit the transaction, so the transaction will roll back. The changes that are made in the test method will not be saved to the database. In this way, we do not need to manually remove the data from the database.</p>
<p>We also use the <code>ChangeTracker.Clear()</code> method to clear the change tracker. The change tracker is used to track the changes made to the entities. If we do not clear the change tracker, we will get the tracked entities instead of querying the database. So, we need to explicitly clear the change tracker before we query the database.</p>
<p>This approach is convenient when we test the methods that change the database. However, it can lead to a problem: what if the controller (or the service) method already starts a transaction? We cannot wrap a transaction in another transaction. In this case, we must explicitly clean up any changes made to the database after the test method is executed.</p>
<p>We <a id="_idIndexMarker988"/>can use the <code>IDisposable</code> interface to clean up the database in our tests. To do this, we can create a test class that implements the <code>IDisposable</code> interface, and then clean up the database in the <code>Dispose()</code> method. To set up the test context, let’s create a class called <code>TransactionalTestDatabaseFixture</code>, as follows:</p>
<pre class="source-code">
public class TransactionalTestDatabaseFixture{
    private const string ConnectionString = @"Server=(localdb)\mssqllocaldb;Database=InvoiceTransactionalTestDb;Trusted_Connection=True";
    public TransactionalTestDatabaseFixture()
    {
        // This code comes from Microsoft Docs: https://github.com/dotnet/EntityFramework.Docs/blob/main/samples/core/Testing/TestingWithTheDatabase/TransactionalTestDatabaseFixture.cs
        using var context = CreateDbContext();
        context.Database.EnsureDeleted();
        context.Database.EnsureCreated();
        InitializeDatabase();
    }
    public InvoiceDbContext CreateDbContext()
        =&gt; new(new DbContextOptionsBuilder&lt;InvoiceDbContext&gt;()
            .UseSqlServer(ConnectionString)
            .Options, null);
    public void InitializeDatabase()
    {
        using var context = CreateDbContext();
        // Create a few Contacts and Invoices
        // Omitted for brevity
        context.SaveChanges();
    }
    public void Cleanup()
    {
        using var context = CreateDbContext();
        context.Contacts.ExecuteDelete();
        context.Invoices.ExecuteDelete();
        context.SaveChanges();
        InitializeDatabase();
    }
}</pre>
<p>In the<a id="_idIndexMarker989"/> preceding code, we create a database called <code>InvoiceTransactionalTestDb</code> and initialize it. This file is similar to the <code>InvoiceTestDatabaseFixture</code> class, except that it has a <code>Cleanup</code> method, which is used to clean up the database. In the <code>Cleanup</code> method, we delete all the contacts and invoices from the database and then initialize the database to restore the data.</p>
<p>In the <code>InvoiceController.cs</code> file, the <code>UpdateInvoiceStatusAsync</code> method uses a transaction to update the status of an invoice. It is not required; this is purely for demonstration purposes. Let’s create a test class called <code>TransactionalInvoiceControllerTests</code> to test this method, as follows:</p>
<pre class="source-code">
public class TransactionalInvoiceControllerTests(TransactionalTestDatabaseFixture fixture) : IClassFixture&lt;TransactionalTestDatabaseFixture&gt;, IDisposable{
    [Fact]
    public async Task UpdateInvoiceStatusAsync_ShouldUpdateStatus()
    {
        // Arrange
        await using var dbContext = _fixture.CreateDbContext();
        var emailServiceMock = new Mock&lt;IEmailService&gt;();
        var controller = new InvoiceController(dbContext, emailServiceMock.Object);
        // Act
        var invoice = await dbContext.Invoices.FirstAsync(x =&gt; x.Status == InvoiceStatus.AwaitPayment);
        await controller.UpdateInvoiceStatusAsync(invoice.Id, InvoiceStatus.Paid);
        // Assert
        dbContext.ChangeTracker.Clear();
        var updatedInvoice = await dbContext.Invoices.FindAsync(invoice.Id);
        Assert.NotNull(updatedInvoice);
        Assert.Equal(InvoiceStatus.Paid, updatedInvoice.Status);
    }
    public void Dispose()
    {
        _fixture.Cleanup();
    }
}</pre>
<p>In the<a id="_idIndexMarker990"/> preceding code, we use the <code>TransactionalTestDatabaseFixture</code> class to create the database context. This class implements the <code>IDisposable</code> interface and calls the <code>Cleanup()</code> method in the <code>Dispose()</code> method. If we have multiple test methods in one test class, xUnit will create a new instance of the test class for each test method and run them in sequence. Therefore, the <code>Dispose()</code> method will be called after each test method is executed to clean up the database, which will ensure that the changes made in the test methods will not affect other test methods.</p>
<p>What if we<a id="_idIndexMarker991"/> want to share <code>TransactionalTestDatabaseFixture</code> in multiple test classes? By default, xUnit will run the test classes in parallel. If other test classes also need to use this fixture to clean up the database, it may cause a concurrency issue when xUnit initializes the test context. To avoid this problem, we can use the <code>Collection</code> attribute to specify that the test classes that use this fixture belong to the same test collection so that xUnit will not run them in parallel. We’ll discuss the parallelism of xUn<a id="_idTextAnchor397"/>it in the next section.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor398"/>Parallelism of xUnit</h2>
<p>By default, the<a id="_idIndexMarker992"/> latest version of xUnit (v2+) runs tests in parallel. This is because parallelism can improve the performance of the test. If we have a lot of tests, running them in parallel can save a lot of time. Also, it can leverage the multi-core CPU to run the tests. However, we need to understand how xUnit runs tests in parallel, just in case it causes problems.</p>
<p>xUnit <a id="_idIndexMarker993"/>uses a concept called <strong class="bold">test collection</strong> to represent a group of tests. By default, each test class is a unique test <a id="_idIndexMarker994"/>collection. Note that the tests in the same test class will not run in parallel.</p>
<p>For example, in the sample project, we can find an <code>InvoiceControllerTests.cs</code> file and a <code>ContactControllerTests.cs</code> file. So, xUnit will run these two test classes in parallel, but the tests in the same test class will not run in parallel.</p>
<p>We also introduced a <code>TestDatabaseFixture</code> class in the <em class="italic">Creating a test fixture</em> section. A class fixture<a id="_idIndexMarker995"/> is used to share a single test context among all the tests in the same test class. So, if we use a class fixture to create a database context, the database context will be shared among all the tests in the same test class. Currently, we have two test classes that use the <code>TestDatabaseFixture</code> class to provide the database context. Will xUnit create only one instance of the <code>TestDatabaseFixture</code> class for these two test classes?</p>
<p>The answer is no. We can set up a breakpoint in the constructor of the <code>TestDatabaseFixture</code> class, and then debug the tests by right-clicking <code>InvoiceApp.UnitTests</code> in the <strong class="bold">Test Explorer</strong> window of VS 2022 and then clicking <strong class="bold">Debug</strong>, as shown in <em class="italic">Figure 9</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 9.6 – Debug tests in VS 2022" src="img/B18971_09_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Debug tests in VS 2022</p>
<p>You will find that the constructor of the <code>TestDatabaseFixture</code> class is called twice (or more, depending on how many tests use this text fixture). So, we know that xUnit will create a new instance of the <code>TestDatabaseFixture</code> class for each test class as well. That is why we use a lock to ensure that the database is only created once. If we do not use the lock, multiple<a id="_idIndexMarker996"/> test classes will try to initialize the database at the same time, which potentially causes problems.</p>
<p>In the <em class="italic">Writing tests for methods that change the database</em> section, we created a <code>TransactionalTestDatabaseFixture</code> class that can clean up the database. If we apply it to one test class, such as <code>TransactionalInvoiceControllerTests</code>, it will work fine. But what if we want to use it for multiple test classes? By default, xUnit will run these test classes in parallel, which means that multiple test classes will try to clean up the database at the same time. In this case, we do not want to run these test classes in parallel. To do this, we can use the <code>Collection</code> attribute to group these test classes into one collection so that xUnit will not run them in parallel. This can help us avoid the concurrency issue.</p>
<p>Let’s see an example. In the sample project, you will find that the <code>ContactController</code> file has a method named <code>UpdateContactAsync()</code> that uses a transaction. Again, this is not required and is just for demonstration purposes. To use the collection fixture, we need to create a definition for the collection. Let’s create a <code>TransactionalTestsCollection</code> class in the <code>InvoiceApp.UnitTests</code> project, as follows:</p>
<pre class="source-code">
[CollectionDefinition("TransactionalTests")]public class TransactionTestsCollection : ICollectionFixture&lt;TransactionalTestDatabaseFixture&gt;
{
}</pre>
<p>In this class, we<a id="_idIndexMarker997"/> declare that the <code>TransactionalTestDatabaseFixture</code> class is a collection fixture that uses the <code>CollectionDefinition</code> attribute. We also specify a name for this collection, which is <code>TransactionalTests</code>. Then, we use the <code>ICollectionFixture&lt;T&gt;</code> interface to specify that the <code>TransactionalTestDatabaseFixture</code> class is a collection fixture.</p>
<p>After that, we add the <code>Collection</code> attribute to the test classes, which specifies that the <code>TransactionalInvoiceControllerTests</code> and <code>TransactionalContactControllerTests</code> classes belong to the <code>TransactionalTests</code> collection, as follows:</p>
<pre class="source-code">
[Collection("TransactionalTests")]public class TransactionalInvoiceControllerTests : IDisposable
{
    // Omitted for brevity
}
[Collection("TransactionalTests")]
public class TransactionalContactControllerTests : IDisposable
{
    // Omitted for brevity
}</pre>
<p>Now, if we debug the tests, we will find that the constructor of the <code>TransactionalTestDatabaseFixture</code> class is only called once, which means that xUnit will only create one instance of the <code>TransactionalTestDatabaseFixture</code> class for these two test classes. Also, xUnit will not run these two test classes in parallel, which means that the <code>Cleanup</code> method of the <code>TransactionalTestDatabaseFixture</code> class will not be called at the same time. So, we can use the <code>TransactionalTestDatabaseFixture</code> class to clean up the <a id="_idIndexMarker998"/>database for each test method in multiple test classes.</p>
<p>Let’s summarize the key points of this section:</p>
<ul>
<li>By default, each test class is a unique test collection</li>
<li>The tests in the same test class will not run in parallel</li>
<li>If we want to share a single test context among all the tests within the same test class, we can use a class fixture:<ul><li>xUnit creates a new instance of the test class for each test method</li><li>xUnit creates a new instance of the class fixture for each test class and shares the same instance among all the tests in the same test class</li></ul></li>
<li>By default, xUnit runs test classes in parallel if they are not in the same test collection</li>
<li>If we do not want to run multiple test classes in parallel, we can use the <code>Collection</code> attribute to group them into one test collection</li>
<li>If we want to share a single test context among several test classes and clean up the test context after each test method, we can use a collection fixture, and implement the <code>IDisposable</code> interface in each test class to clean up the test context:<ul><li>xUnit creates a new instance of the test class for each test method</li><li>xUnit creates only one instance of the collection fixture for the test collection and shares the same instance among all the tests in the collection</li><li>xUnit <a id="_idIndexMarker999"/>does not run multiple test classes in parallel if they belong to the same test collection</li></ul></li>
</ul>
<p>xUnit provides a lot of features to customize the test execution. If you want to learn more about xUnit, you can check out the official<a id="_idIndexMarker1000"/> docu<a id="_idTextAnchor399"/>mentation at <a href="https://xunit.net/">https://xunit.net/</a>.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor400"/>Using the repository pattern</h2>
<p>So far, you have <a id="_idIndexMarker1001"/>learned how to use a real database to test the database access layer. There is another way to test the database access layer, which is to use a repository pattern to decouple the controllers from the <code>DbContext</code> class. In this section, we will show you how to use the repository pattern to test the database access layer.</p>
<p>The repository pattern<a id="_idIndexMarker1002"/> is a common pattern that’s used to separate the application and the database access layer. Instead of using <code>DbContext</code> directly in the controllers, we can add a separate repository layer to encapsulate the database access logic. The controllers will use the repository layer to access the database, as shown in <em class="italic">Figure 9</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 9.7– Using the repository pattern" src="img/B18971_09_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7– Using the repository pattern</p>
<p>In <em class="italic">Figure 9</em><em class="italic">.7</em>, we can see <a id="_idIndexMarker1003"/>that the application now has no dependency on EF Core. The application (controllers) only depends on the repository layer, and the repository layer depends on EF Core. Therefore, the repository layer can be mocked in the tests, and the controllers can be tested without a real database.</p>
<p>To learn how to use the<a id="_idIndexMarker1004"/> repository pattern for testing, you can look at the sample project in the <code>UnitTestsDemo\UnitTest-v2</code> folder. This project is based on the <code>v1</code> project, and we have added a repository layer to the project.</p>
<p>The <code>IInvoiceRepository</code> interface defines the methods of the <code>Invoice</code> repository, as follows:</p>
<pre class="source-code">
public interface IInvoiceRepository{
    Task&lt;Invoice?&gt; GetInvoiceAsync(Guid id);
    Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10, InvoiceStatus? status = null);
    Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesByContactIdAsync(Guid contactId, int page = 1, int pageSize = 10, InvoiceStatus? status = null);
    Task&lt;Invoice&gt; CreateInvoiceAsync(Invoice invoice);
    Task&lt;Invoice?&gt; UpdateInvoiceAsync(Invoice invoice);
    Task DeleteInvoiceAsync(Guid id);
}</pre>
<p>The implementation of the <code>IInvoiceRepository</code> interface is in the <code>InvoiceRepository</code> class; it uses the <code>DbContext</code> class to access the database. First, we inject the <code>InvoiceDbContext</code> class into the <code>InvoiceRepository</code> class using the constructor injection, as follows:</p>
<pre class="source-code">
public class InvoiceRepository(InvoiceDbContext dbContext) : IInvoiceRepository{
}</pre>
<p>Next, we can implement the <code>IInvoiceRepository</code> interface in the <code>InvoiceRepository</code> class. Here is an example of the <code>GetInvoicesAsync</code> method:</p>
<pre class="source-code">
public async Task&lt;Invoice?&gt; GetInvoiceAsync(Guid id){
    return await dbContext.Invoices.Include(i =&gt; i.Contact)
        .SingleOrDefaultAsync(i =&gt; i.Id == id);
}</pre>
<p>In the <code>GetInvoiceAsync()</code> method, we use a <code>LINQ</code> query to get the invoice by the specified ID. Note <a id="_idIndexMarker1005"/>that we use the <code>Include</code> method to include the <code>Contact</code> property in the query result. This is because we want to get the contact information of the invoice. If we do not want to include the navigation property in the query result, we can remove the <code>Include()</code> method, or add a parameter to the <code>GetInvoiceAsync()</code> method to specify whether to include the navigation property. The <code>Include()</code> method is defined in the <code>Microsoft.EntityFrameworkCore</code> namespace, so we need to add the <code>using Microsoft.EntityFrameworkCore;</code> statement to the <code>InvoiceRepository.cs</code> file.</p>
<p>The implementation of the <code>GetInvoicesAsync()</code> method is as follows:</p>
<pre class="source-code">
public async Task&lt;IEnumerable&lt;Invoice&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10, InvoiceStatus? status = null){
    return await dbContext.Invoices
        .Include(x =&gt; x.Contact)
        .Where(x =&gt; status == null || x.Status == status)
        .OrderByDescending(x =&gt; x.InvoiceDate)
        .Skip((page - 1) * pageSize)
        .Take(pageSize)
        .ToListAsync();
}</pre>
<p>In the preceding <code>GetInvoicesAsync()</code> method, we use some <code>LINQ</code> methods, such as <code>Where()</code>, <code>OrderByDescending()</code>, <code>Skip()</code>, and <code>Take()</code>, to implement the pagination feature. Note that the <code>ToListAsync()</code> method is defined in the <code>Microsoft.EntityFrameworkCore</code> namespace, so do not forget to add the <code>using </code><code>Microsoft.EntityFrameworkCore;</code> statement.</p>
<p>You can find the complete implementation of the <code>InvoiceRepository</code> class in the <code>InvoiceRepository.cs</code> file in the <code>UnitTestsDemo\UnitTest-v2</code> folder.</p>
<p>The implementation of the repository interface is just a class that uses the <code>DbContext</code> class to implement the CRUD operations. Generally, this layer does not contain any business logic. Also, we should note that the <code>GetInvoicesAsync()</code> method returns <code>IEnumerable&lt;Invoice&gt;</code> instead of <code>IQueryable&lt;Invoice&gt;</code>. This is because the <code>IQueryable</code> interface involves EF Core, but the purpose of using the repository pattern is to decouple the application from EF Core. So, we can easily mock the repository layer in the tests.</p>
<p>The controllers now<a id="_idIndexMarker1006"/> depend on the repository layer, as shown here:</p>
<pre class="source-code">
[Route("api/[controller]")][ApiController]
public class InvoiceController(IInvoiceRepository invoiceRepository, IEmailService emailService)
    : ControllerBase
    // GET: api/Invoices
    [HttpGet]
    public async Task&lt;ActionResult&lt;List&lt;Invoice&gt;&gt;&gt; GetInvoicesAsync(int page = 1, int pageSize = 10,
        InvoiceStatus? status = null)
    {
        var invoices = await invoiceRepository.GetInvoicesAsync(page, pageSize, status);
        return Ok(invoices);
    }
    // Omitted for brevity
}</pre>
<p>Now, the controller<a id="_idIndexMarker1007"/> is much cleaner, and there is no dependency on EF Core. We can update the tests so that they use the repository layer instead of the <code>DbContext</code> class. Similar to that in the previous <code>InvoiceControllerTests</code>, we may need a class fixture to manage the test context, as shown here:</p>
<pre class="source-code">
public class TestFixture{
    public List&lt;Invoice&gt; Invoices { get; set; } = new();
    public List&lt;Contact&gt; Contacts { get; set; } = new();
    public TestFixture()
    {
        InitializeDatabase();
    }
    public void InitializeDatabase()
    {
        // Omited for brevity
    }
}</pre>
<p>In this class fixture, we <a id="_idIndexMarker1008"/>have added two lists to mock the database tables. Next, we can mock the tests, like this:</p>
<pre class="source-code">
public class InvoiceControllerTests(TestFixture fixture) : IClassFixture&lt;TestFixture&gt;{
    [Fact]
    public async Task GetInvoices_ShouldReturnInvoices()
    {
        // Arrange
        var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
        repositoryMock.Setup(x =&gt; x.GetInvoicesAsync(It.IsAny&lt;int&gt;(), It.IsAny&lt;int&gt;(), It.IsAny&lt;InvoiceStatus?&gt;()))
            .ReturnsAsync((int page, int pageSize, InvoiceStatus? status) =&gt;
                fixture.Invoices.Where(x =&gt; status == null || x.Status == status)
                    .OrderByDescending(x =&gt; x.InvoiceDate)
                    .Skip((page - 1) * pageSize)
                    .Take(pageSize)
                    .ToList());
        var emailServiceMock = new Mock&lt;IEmailService&gt;();
        var controller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
        // Act
        var actionResult = await controller.GetInvoicesAsync();
        // Assert
        var result = actionResult.Result as OkObjectResult;
        Assert.NotNull(result);
        var returnResult = Assert.IsAssignableFrom&lt;List&lt;Invoice&gt;&gt;(result.Value);
        Assert.NotNull(returnResult);
        Assert.Equal(2, returnResult.Count);
        Assert.Contains(returnResult, i =&gt; i.InvoiceNumber == "INV-001");
        Assert.Contains(returnResult, i =&gt; i.InvoiceNumber == "INV-002");
    }
    // Omited for brevity
}</pre>
<p>In this test<a id="_idIndexMarker1009"/> method, we mock the repository layer and pass it to the controller. It follows the concept of the unit tests: focus on the unit under test and mock the dependencies. You can check the other tests in the source code and try to add more tests to cover the other scenarios, such as creating invoices, updating invoices, deleting invoices, and so on. Note that we use two instances of <code>List&lt;T&gt;</code> to mock the database tables. If the test methods change the data, do not forget to restore the data after the test methods are executed.</p>
<p>The repository pattern is a good practice for decoupling the application from the data access layer, and it also makes it possible to replace the data access layer with another one. It allows us to mock the database access layer for testing purposes. However, it increases the complexity of the application. Also, if we use the repository pattern, we may lose some features of EF Core, such as <code>IQueryable</code>. Finally, the mock behavior may be different from the real behavior. So, we should <a id="_idTextAnchor401"/>consider the trade-offs before using it.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor402"/>Testing the happy path and the sad path</h2>
<p>So far, we have written some tests to cover the happy path. However, we should also test the sad path. In testing, the terms <strong class="bold">happy path</strong> and <strong class="bold">sad path</strong> are <a id="_idIndexMarker1010"/>used to describe different scenarios or test cases:</p>
<ul>
<li><code>GetInvoiceAsync(Guid id)</code> method, the happy path is that the invoice with the specified ID exists in the database, and the method returns the invoice.</li>
<li><code>GetInvoiceAsync(Guid id)</code> method, the sad path is that the invoice with the specified ID does not exist in the database, and the method returns the <code>404 Not </code><code>Found</code> error.</li>
</ul>
<p>By combining both happy path and sad path tests, we can ensure that the code unit works as expected in different scenarios. Here is an <a id="_idIndexMarker1013"/>example of a happy path for <code>the GetInvoiceAsync(Guid </code><code>id)</code> method:</p>
<pre class="source-code">
[Fact]public async Task GetInvoice_ShouldReturnInvoice()
{
    // Arrange
    var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
    repositoryMock.Setup(x =&gt; x.GetInvoiceAsync(It.IsAny&lt;Guid&gt;()))
        .ReturnsAsync((Guid id) =&gt; fixture.Invoices.FirstOrDefault(x =&gt; x.Id == id));
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var controller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
    // Act
    var invoice = fixture.Invoices.First();
    var actionResult = await controller.GetInvoiceAsync(invoice.Id);
    // Assert
    var result = actionResult.Result as OkObjectResult;
    Assert.NotNull(result);
    var returnResult = Assert.IsAssignableFrom&lt;Invoice&gt;(result.Value);
    Assert.NotNull(returnResult);
    Assert.Equal(invoice.Id, returnResult.Id);
    Assert.Equal(invoice.InvoiceNumber, returnResult.InvoiceNumber);
}</pre>
<p>In this test method, we pass the <a id="_idIndexMarker1014"/>ID of the first invoice in the <code>Invoices</code> list to the <code>GetInvoiceAsync(Guid id)</code> method. Since the invoice with the specified ID exists in the database, the method should return the invoice.</p>
<p>Let’s create a sad path<a id="_idIndexMarker1015"/> test for the <code>GetInvoiceAsync(Guid </code><code>id)</code> method:</p>
<pre class="source-code">
[Fact]public async Task GetInvoice_ShouldReturnNotFound()
{
    // Arrange
    var repositoryMock = new Mock&lt;IInvoiceRepository&gt;();
    repositoryMock.Setup(x =&gt; x.GetInvoiceAsync(It.IsAny&lt;Guid&gt;()))
        .ReturnsAsync((Guid id) =&gt; _fixture.Invoices.FirstOrDefault(x =&gt; x.Id == id));
    var emailServiceMock = new Mock&lt;IEmailService&gt;();
    var coentroller = new InvoiceController(repositoryMock.Object, emailServiceMock.Object);
    // Act
    var actionResult = await controller.GetInvoiceAsync(Guid.NewGuid());
    // Assert
    var result = actionResult.Result as NotFoundResult;
    Assert.NotNull(result);
}</pre>
<p>In this test method, we <a id="_idIndexMarker1016"/>pass a new GUID to the <code>GetInvoiceAsync(Guid id)</code> method. Since the invoice with the specified ID does not exist in the database, the method should return a <code>404 Not Found</code> error. We can also create sad path tests for other methods.</p>
<p class="callout-heading">Tip</p>
<p class="callout">What is the difference between <code>as</code> and <code>is</code> in C#?</p>
<p class="callout">The <code>as</code> operator<a id="_idIndexMarker1017"/> is used to perform conversions between compatible types. If the conversion is not possible, the <code>as</code> operator returns <code>null</code> instead of raising an exception. So, in the preceding test, if <code>result</code> is not <code>null</code>, we can see that the result from the controller is <code>NotFoundResult</code>, which is the expected result.</p>
<p class="callout">The <code>is</code> operator<a id="_idIndexMarker1018"/> is used to determine whether an object is compatible with a given type. If the object is compatible, the operator will return <code>true</code>; otherwise, it will return <code>false</code>. This is a useful tool for verifying the type of an object before performing an operation on it.</p>
<p class="callout">From C# 7, we can use <code>is</code> to check and convert the type at the same time. For example, we can use <code>if (result is NotFoundResult notFoundResult)</code> to check whether <code>result</code> is <code>NotFoundResult</code>, and convert it into <code>NotFoundResult</code> at the same time.</p>
<p>With that, we have learned how to write unit tests for the controller. You can check the other tests in the source code and try to add more tests to cover the other scenarios, such as creating invoices, updating invoices, deleting invoices, and so on.</p>
<h1 id="_idParaDest-210"><a id="_idTextAnchor403"/>Summary</h1>
<p>In this chapter, we explored the fundamentals of unit tests for ASP.NET web API applications. We discussed the use of xUnit as the testing framework and <code>Moq</code> as the mocking framework. We learned how to configure test fixtures with xUnit, and how to manage the test data with the test fixture. We also learned how to write unit tests to test the data access layer and the controller.</p>
<p>Unit tests are a great way to ensure that your code unit is working as expected. These tests often use mock objects to isolate the code unit from its dependencies, but this cannot guarantee that the code unit works well with its dependencies. Therefore, we also need to write integration tests to test if the code units can work together with their dependencies. For example, can the controllers handle the requests correctly?</p>
<p>In the next chapter, we will learn how to write integration tests for ASP.NET web API applications.</p>
</div>
</body></html>