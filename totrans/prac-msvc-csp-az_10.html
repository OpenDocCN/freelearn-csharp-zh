<html><head></head><body>
		<div><h1 id="_idParaDest-240" class="chapter-number"><a id="_idTextAnchor239"/>10</h1>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor240"/>All About Testing the Solution</h1>
			<p>When creating microservices and using <strong class="bold">continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>), finding errors early is an important part. Having errors in production is costly, and it’s best to find them as early as <a id="_idIndexMarker753"/>possible. Testing helps reduce costs by finding errors early.</p>
			<p>This chapter covers different kinds of tests needed with microservices solutions. We start creating unit tests, which should be the major tests used because issues are found fast, followed by integration tests, where multiple components of the solution are tested in collaboration. Integration tests can be done in-process where HTTP requests are simulated and in an environment where services are running on the systems, which allows you to test the environment under load.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Create unit tests</li>
				<li>Create .NET Aspire integration tests</li>
				<li>Create end-to-end .NET Playwright tests</li>
			</ul>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>Technical requirements</h1>
			<p>With this chapter, as with the previous chapters, you need an Azure subscription and a Docker Desktop.</p>
			<p>The code for this chapter can be found in this GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</a>.</p>
			<p>In the <code>ch10/final</code> folder, you’ll see these projects with the final result of this chapter.</p>
			<p>These projects are unchanged from previous chapters:</p>
			<ul>
				<li><code>Codebreaker.AppHost</code> – The .NET Aspire host project</li>
				<li><code>Codebreaker.ServiceDefaults</code> – Common service configuration</li>
				<li><code>Codebreaker.Bot</code> – The bot service to run games</li>
			</ul>
			<p>These projects are unchanged from previous chapters, but of special interest for the tests:</p>
			<ul>
				<li><code>Codebreaker.Analyzers</code> – This is the project that contains analyzers to verify game moves and return results</li>
				<li><code>Codebreaker.GameApis</code> – The games API service project</li>
			</ul>
			<p>These projects are new:</p>
			<ul>
				<li><code>Codebreaker.Analyzers.Tests</code> – Unit tests for the analyzer library</li>
				<li><code>Codebreaker.Bot.Tests</code> – Unit tests for the bot service library</li>
				<li><code>Codebreaker.GameAPIs.Tests</code> – Unit tests for the games services project</li>
				<li><code>Codebreaker.GameAPIs.IntegrationTests</code> – In-memory integration tests</li>
				<li><code>Codebreaker.GameAPIs.Playwright</code> – Tests with Microsoft Playwright</li>
			</ul>
			<p>Working through the code with this chapter, you can start using the <code>start</code> folder, which contains the same projects without the test projects.</p>
			<p>To easily deploy the solution to Microsoft Azure, check out the README file in the source code repo of this chapter.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor242"/>Creating unit tests</h1>
			<p>Unit tests are tests that test a <a id="_idIndexMarker754"/>small piece of testable software. Does this functionality behave as expected? These tests should be fast, used directly on the developer system (and run with CI as<a id="_idIndexMarker755"/> well). With the <strong class="bold">Visual Studio Live Unit Testing</strong> feature (part of Visual Studio Enterprise), unit tests run while the code is updated, even before saving the source code.</p>
			<p>The cost of bugs grows during the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>). When bugs are found late (for example, in <a id="_idIndexMarker756"/>production), the cost grows exponentially. For fixing bugs early (for example, while typing the code), Visual Studio can give hints and show errors; as we are already working on the code, it’s not necessary to take the time to dive into the functionality as we are already working on it. For finding bugs with other test types (for example, integration or load tests), the fixes are more expensive – but of course, a lot less expensive than finding a bug in production.</p>
			<p>A goal should be to reduce cost, and thus if some functionality can be verified with unit tests and other test types, prefer unit tests.</p>
			<p>Before we start creating a unit test, what is the heart of the games service in need of unit tests? It’s the analyzer library. There’s some complexity with the game rules, and it’s easy to make some logical errors writing the code. It’s also a place where some refactoring could be done<a id="_idIndexMarker757"/> to increase performance and reduce memory needs. After refactoring, the application should function in the same way.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When I was initially developing the games analyzer library, I created unit tests beforehand and enhanced the unit tests <a id="_idIndexMarker758"/>while developing the algorithms. With <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), unit tests are created before the functionality.</p>
			<p class="callout">Before fixing bugs, I also created new unit tests. Why did the bug occur? Why was it not covered by a test? With many different projects, I see bugs that have been fixed come back with a later version. If there’s a unit test to verify the functionality, the same issue cannot resurface with a new version.</p>
			<p>Next, let’s dive into the <code>Codebreaker</code> code, which needs many unit tests.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/>Exploring the games analyzer library</h2>
			<p>Let’s explore <a id="_idIndexMarker759"/>the <code>GameGuessAnalyzer</code> class in<a id="_idIndexMarker760"/> the <code>Codebreaker</code> analyzer library:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/GameGuessAnalyzer.cs</p>
			<pre class="source-code">
public abstract class GameGuessAnalyzer&lt;TField, TResult&gt; :
  IGameGuessAnalyzer&lt;TResult&gt;
  where TResult : struct
{
  protected readonly IGame _game;
  private readonly int _moveNumber;
  protected TField[] Guesses { get; private set; }
  <strong class="bold">protected GameGuessAnalyzer(IGame game, TField[] guesses, int moveNumber)</strong>
  {
    _game = game;
    Guesses = guesses;
    _moveNumber = moveNumber;
  }
  protected abstract TResult GetCoreResult();
  private void ValidateGuess()
  {
    // code removed for brevity
  }
  protected abstract void SetGameEndInformation(TResult result);
<strong class="bold">  public TResult GetResult()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    ValidateGuess();</strong>
<strong class="bold">    TResult result = GetCoreResult();</strong>
<strong class="bold">    SetGameEndInformation(result);</strong>
<strong class="bold">    return result;</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>The <code>GetResult</code> method is the heart of this class. With the constructor of the <code>GameGuessAnalyzer</code> abstract base class, the game and the guesses are passed with parameters. The <code>GetResult</code> method uses the codes of the game and uses the guesses to return the result – the number of colors that are in the correct position and the number of colors that are correct but<a id="_idIndexMarker761"/> in the wrong position. The implementation of the <code>GetResult</code> method is just an invocation of four methods. The <code>ValidateGuess</code> method analyses the correctness of guesses and throws an exception if the guesses are not correct. The <code>GetCoreResult</code> method is abstract and needs to be implemented by a derived class.</p>
			<p>One of the classes <a id="_idIndexMarker762"/>deriving from the <code>GameGuessAnalyzer</code> class is the <code>ColorGameGuessAnalyzer</code> class. This is used by the <code>Game6x4</code> and <code>Game8x5</code> game types (six colors with four codes and eight colors with five codes):</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Analyzers.Tests/Analyzers/ColorGameGuessAnalyzer.cs</p>
			<pre class="source-code">
public class <strong class="bold">ColorGameGuessAnalyzer</strong>(
  IGame game, ColorField[] guesses, int moveNumber) :
  GameGuessAnalyzer&lt;ColorField, ColorResult&gt;(game, guesses, moveNumber)
{
  protected override <strong class="bold">ValidateGuessValues()</strong>
  {
    // code removed for brevity
  }
  protected override ColorResult <strong class="bold">GetCoreResult()</strong>
  {
    // code removed for brevity
  }
}</pre>
			<p>This class overrides the <code>ValidateGuessValues</code> and the <code>GetCoreResult</code> methods. <code>ValidateGuessValues</code> validates the input data and throws exceptions if the data is not valid. The <code>GetCoreResult</code> method<a id="_idIndexMarker763"/> implements the algorithm for the <code>Codebreaker</code> game, finds if the guesses are correctly placed and if the guesses are correct but incorrectly placed, and<a id="_idIndexMarker764"/> returns the result accordingly.</p>
			<p>Let’s create a unit test project for this library.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>Creating a unit test project</h2>
			<p>Using the .NET CLI, we can <a id="_idIndexMarker765"/>create a new xUnit test project:</p>
			<pre class="console">
dotnet new xunit -o Codebreaker.Analyzers.Tests
cd Codebreaker.Analyzers.Tests
dotnet add reference ..\Codebreaker.Analyzers</pre>
			<p>This command creates a <code>Codebreaker.Analyzers.Tests</code> project with references to xUnit NuGet packages and a project reference to the analyzer project.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I’m mainly using xUnit for unit tests. It’s a matter of choice whether to use <strong class="bold">MSTest</strong>, <strong class="bold">NUnit</strong>, or <strong class="bold">xUnit</strong>; you can use any of these frameworks for unit tests, and all of these are greatly integrated within the .NET tools. I myself switched from MSTest to xUnit with early betas of .NET Core 1.0 when xUnit was available, but MSTest was not ready for the new .NET – and most unit tests from the .NET team themselves are done using xUnit.</p>
			<p>Before creating the first <a id="_idIndexMarker766"/>tests, some preparations need to be done.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor245"/>Mocking the IGame interface</h2>
			<p>With the constructor of the <code>ColorGameGuessAnalyzer</code> class, an object implementing the <code>IGame</code> interface is required with the constructor. A unit test should only test a small functionality <a id="_idIndexMarker767"/>without testing dependencies that are covered by<a id="_idIndexMarker768"/> their own unit tests. When testing the <code>ColorGameGuessAnalyzer</code> class, we don’t want to add a dependency to the <code>Game</code> class while testing the analyzer. What’s needed by the <code>ColorGameGuessAnalyzer</code> class is the <code>IGame</code> interface. To allow the test to run, the <code>IGame</code> interface is implemented by a mocking class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/MockColorGame.cs</p>
			<pre class="source-code">
public class MockColorGame : IGame
{
  public Guid Id { get; init; }
  public int NumberCodes { get; init; }
  public int MaxMoves { get; init; }
  public DateTime? EndTime { get; set; }
  public bool IsVictory { get; set; }
  // code removed for brevity
}</pre>
			<p>The <code>MockColorGame</code> class is just a simple data holder to implement the <code>IGame</code> interface, thus we don’t need to use any mocking library. With another unit test implementation done later, we’ll use <a id="_idIndexMarker769"/>a mocking library to mock functionality that should not be tested by the unit test.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/>Creating test helpers</h2>
			<p>To define common functionality<a id="_idIndexMarker770"/> needed by multiple unit tests, helper methods<a id="_idIndexMarker771"/> are created within the <code>ColorGame6x4AnalyzerTests</code> test class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/Analyzers/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
private static MockColorGame CreateGame(string[] codes) =&gt; new()
{
  GameType = GameTypes.Game6x4,
  NumberCodes = 4,
  MaxMoves = 12,
  IsVictory = false,
  FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
  {
    [FieldCategories.Colors] = [.. TestData6x4.Colors6]
  },
  Codes = codes
};
private static ColorResult <strong class="bold">AnalyzeGame</strong>(
  string[] codes,
  string[] guesses,
  int moveNumber = 1)
{
  MockColorGame game = CreateGame(codes);
<strong class="bold">  ColorGameGuessAnalyzer analyzer = new(game, [.. guesses.</strong>
    <strong class="bold">ToPegs&lt;ColorField&gt;()], moveNumber);</strong>
<strong class="bold">  return analyzer.GetResult();</strong>
}</pre>
			<p>The <code>AnalyzeGame</code> method <a id="_idIndexMarker772"/>receives a string array representing the valid code, a string array representing the guesses, and the move number. This information is used to create a mocked game instance and to invoke the <code>GetResult</code> method of the analyzer class. The result of the<a id="_idIndexMarker773"/> analysis is returned with a <code>ColorResult</code> type. This helper method can now be used to easily create unit tests.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/>Creating a simple unit test</h2>
			<p>The first unit test is <a id="_idIndexMarker774"/>implemented with the <code>GetResult_Should_ReturnThreeWhite</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[Fact]</strong>
public void GetResult_Should_ReturnThreeWhite()
{
  <strong class="bold">ColorResult expectedKeyPegs = new(0, 3);</strong>
  ColorResult? resultKeyPegs = <strong class="bold">AnalyzeGame</strong>(
    [Green, Yellow, Green, Black],
    [Yellow, Green, Black, Blue]
  );
<strong class="bold">  Assert.Equal(expectedKeyPegs, resultKeyPegs);</strong>
}</pre>
			<p>Using xUnit, the <code>Fact</code> attribute declares a method to be a unit test. A unit test consists of three parts: <code>expectedKeyPegs</code> variable. Invoking the <code>AnalyzeGame</code> method is the act. The <code>Green</code> – <code>Yellow</code> – <code>Green</code> – <code>Black</code> code is passed as valid code, and <code>Yellow</code> – <code>Green</code> – <code>Black</code> – <code>Blue</code> as a guess. With this guess, no color is in the correct position, but three colors are correct in the wrong positions, thus three whites should be returned. If this <a id="_idIndexMarker775"/>result is correct, this is verified using the <code>Assert.Equal</code> method.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>Passing test data to unit tests</h2>
			<p>With this scenario, it’s useful to just<a id="_idIndexMarker776"/> define one method that’s used with<a id="_idIndexMarker777"/> different test data to verify the different outcomes:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[InlineData(1, 2, Red, Yellow, Red, Blue)]</strong>
<strong class="bold">[InlineData(2, 0, White, White, Blue, Red)]</strong>
<strong class="bold">[Theory]</strong>
<strong class="bold">public void GetResult_ShouldReturn_InlineDataResults(</strong>
<strong class="bold">  int expectedBlack, int expectedWhite,</strong>
<strong class="bold">  params string[] guessValues)</strong>
{
  string[] code = [Red, Green, Blue, Red];
  ColorResult expectedKeyPegs = new (expectedBlack, expectedWhite);
  ColorResult resultKeyPegs = AnalyzeGame(code, guessValues);
  Assert.Equal(expectedKeyPegs, resultKeyPegs);
}</pre>
			<p>With xUnit, using the <code>Theory</code> attribute instead of the <code>Fact</code> attribute allows the test method to be invoked multiple times, passing different test data. The <code>GetResult_ShouldReturn_InlineResults</code> method uses arguments that are specified with the <code>InlineData</code> attribute. With every <code>InlineData</code> attribute, the parameter values for the arguments defined with the method are passed. Here, two tests are covered with one<a id="_idIndexMarker778"/> implementation. This feature allows for quickly extending test cases by just adding new <code>InlineData</code> attributes.</p>
			<p>Instead of <a id="_idIndexMarker779"/>using the <code>InlineDataAttribute</code> class, a class can be created implementing <code>IEnumerable&lt;object[]&gt;</code> to supply test data:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
public class TestData6x4 : <strong class="bold">IEnumerable&lt;object[]&gt;</strong>
{
  public static readonly string[] Colors6 = [Red, Green, Blue, Yellow,
    Black, White];
<strong class="bold">  public IEnumerator&lt;object[]&gt; GetEnumerator()</strong>
<strong class="bold">  {</strong>
    yield return new object[]
    {
      new string[] { Green, Blue,  Green, Yellow },
      new string[] { Green, Green, Black, White },
      new ColorResult(1, 1) // expected
    };
    yield return new object[]
    {
      new string[] { Red,   Blue,  Black, White },
      new string[] { Black, Black, Red,   Yellow },
      new ColorResult(0, 2)
    };
    // code removed for brevity – more test cases here
  }
  IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
}</pre>
			<p><code>object[]</code> defines all the values for one method invocation. The first argument passed defines the valid code for the <a id="_idIndexMarker780"/>game, the second argument the guess data, and the third argument the expected <a id="_idIndexMarker781"/>result. With every iteration of <code>IEnumerable</code>, a new test run is done. The next code snippet shows the test method implementation using the data class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
<strong class="bold">[Theory]</strong>
<strong class="bold">[ClassData(typeof(TestData6x4))]</strong>
<strong class="bold">public void GetResult_ShouldReturn_UsingClassdata(</strong>
<strong class="bold">  string[] code,</strong>
<strong class="bold">  string[] guess,</strong>
<strong class="bold">  ColorResult expectedKeyPegs)</strong>
<strong class="bold">{</strong>
  ColorResult actualKeyPegs = AnalyzeGame(code, guess);
  Assert.Equal(expectedKeyPegs, actualKeyPegs);
}</pre>
			<p>Instead of using the <code>InlineData</code> attribute, here <code>ClassData</code> is used. Using an object returning the test data is more flexible. The <code>InlineData</code> attribute requires constant values that are stored by<a id="_idIndexMarker782"/> the compiler. With the <code>ClassData</code> attribute, data can <a id="_idIndexMarker783"/>also be created dynamically.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor249"/>Expecting exceptions with a unit test</h2>
			<p>Another test case where we<a id="_idIndexMarker784"/> expect an exception to be thrown is shown in the next code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Analyzers.Tests/ColorGame6x4AnalyzerTests.cs</p>
			<pre class="source-code">
[Fact]
public void GetResult_Should_ThrowOnInvalidGuessValues()
{
  <strong class="bold">Assert.Throws&lt;ArgumentException&gt;</strong>(() =&gt;
    AnalyzeGame(
      ["Black", "Black", "Black", "Black"],
      ["Black", "Der", "Blue", "Yellow"] // "Der" is wrong
  ));
}</pre>
			<p><code>Assert.Throws</code> defines the exception type that should be thrown by the implementation when the test data is passed. If an exception is not thrown, the test fails.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor250"/>Using a mocking library</h2>
			<p>With some classes that<a id="_idIndexMarker785"/> should be tested, it’s great to have a mocking library. The <code>GamesService</code> class injecting the <code>IGamesRepository</code> interface is shown in the following code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/GamesService.cs</p>
			<pre class="source-code">
<strong class="bold">public class GamesService(IGamesRepository dataRepository) : IGamesService</strong>
{
  public async Task&lt;(Game Game, Move Move)&gt; <strong class="bold">SetMoveAsync</strong>(
    Guid id, string gameType, string[] guesses,
    int moveNumber,
    CancellationToken cancellationToken = default)
  {
<strong class="bold">    Game? game = await dataRepository.GetGameAsync(id, </strong>
<strong class="bold">    cancellationToken);</strong>
<strong class="bold">    CodebreakerException.ThrowIfNull(game);</strong>
<strong class="bold">    CodebreakerException.ThrowIfEnded(game);</strong>
<strong class="bold">    CodebreakerException.ThrowIfUnexpectedGameType(game, gameType);</strong>
    Move move = game.ApplyMove(guesses, moveNumber);
<strong class="bold">    await dataRepository.AddMoveAsync(game, move, cancellationToken);</strong>
    return (game, move);
  }
  // code removed for brevity
}</pre>
			<p>With the <code>GamesService</code> class, the <code>IGamesRepository</code> interface is injected using constructor injection. When<a id="_idIndexMarker786"/> testing the <code>SetMoveAsync</code> method, the implementation of the <code>IGamesRepository</code> interface should not be part of this test. There’s another test for the games repository. Instead, a mocking implementation of this class is used for the unit test. The <code>SetMoveAsync</code> method invokes the <code>GetGameAsync</code> method of the <code>IGamesRepository</code> interface. The real implementation of this method should not be part of the test, but we need some different results that can be used with the methods used afterward. When this method returns <code>null</code> because it didn’t find the game, <code>CodebreakerException.ThrowIfNull</code> should throw an exception. If the method returns a game that already ended, the next method should throw an exception because a new move <a id="_idIndexMarker787"/>cannot be set to a game that already ended. The <code>ThrowIfUnexpectedGameType</code> method should throw an exception if the game type passed is different from the game type of the game retrieved. This can easily be solved by using a mocking library.</p>
			<p>Let’s create another xUnit test project named <code>Codebreaker.GameAPIs.Tests</code> to test the <code>GamesService</code> class. To mock the <code>IGamesRepository</code> interface, add the <code>moq</code> NuGet package.</p>
			<p>The following code snippet shows fields for games and game IDs that are used by the unit test:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
public class GamesServiceTests
{
<strong class="bold">  private readonly Mock&lt;IGamesRepository&gt; _gamesRepositoryMock = new();</strong>
  private readonly Guid <strong class="bold">_endedGameId</strong> = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E6");
  private readonly Game <strong class="bold">_endedGame</strong>;
  private readonly Guid <strong class="bold">_running6x4GameId</strong> = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E7");
  private readonly Game <strong class="bold">_running6x4Game</strong>;
  private readonly Guid <strong class="bold">_notFoundGameId </strong>= Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E8");
  private readonly Guid _running6x4MoveId1 = Guid.Parse("4786C27B-3F9A-4C47-9947-F983CF7053E9");
  private readonly string[] _guessesMove1 = ["Red", "Green", "Blue", "Yellow"];</pre>
			<p>The <code>IGamesRepository</code> interface is mocked creating a new instance by using the generic <code>Mock</code> type. After this, games are <a id="_idIndexMarker788"/>predefined for a game not found in the repository (<code>_notFoundGameId</code>), a game that already ended (<code>_endedGame</code>), and a running game that is active (<code>_running6x4Game</code>).</p>
			<p>The constructor of the <code>GamesServiceTests</code> class initializes the game objects:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
public GamesServiceTests()
{
<strong class="bold">  _endedGame</strong> = new(_endedGameId, "Game6x4", "Test", DateTime.Now, 4, 12)
  {
    Codes = ["Red", "Green", "Blue", "Yellow"],
    FieldValues = new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;()
    {
      { FieldCategories.Colors, ["Red", "Green", "Blue", "Yellow", 
<strong class="bold">        </strong>"Purple", "Orange"] }
    },
    EndTime = DateTime.Now.AddMinutes(3)
  };
  // code removed for brevity
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.GetGameAsync(_endedGameId, </strong>
<strong class="bold">     CancellationToken.None)).ReturnsAsync(_endedGame);</strong>
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.GetGameAsync</strong>
  <strong class="bold">(_running6x4GameId, CancellationToken.None)).ReturnsAsync</strong>
  <strong class="bold">(_running6x4Game);</strong>
  _gamesRepositoryMock.<strong class="bold">Setup</strong>(repo =&gt; <strong class="bold">repo.AddMoveAsync</strong>
  <strong class="bold">(_running6x4Game, It.IsAny&lt;Move&gt;(), CancellationToken.None));</strong>
}</pre>
			<p>With the constructor, instances of the different game types are created. The game already ended has the <code>EndTime</code> property set. To specify the behavior of the mocking implementation, the <code>Setup</code> method is invoked. With this, if the <code>GetGameAsync</code> method receives the ended <a id="_idIndexMarker789"/>game ID with the parameter, it returns the configured game instance that already ended. Passing the game ID of the running game, the corresponding instance is returned. With the third invocation of the <code>Setup</code> method, it’s defined that the <code>AddMoveAsync</code> method contains an implementation when passing the running game. <code>It.IsAny&lt;Move&gt;</code> allows us to invoke this method with any <code>Move</code> instance.</p>
			<p>Now, we can implement unit tests. The first unit test is to verify that the <code>SetMoveAsync</code> method throws an exception if the game already ended:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Tests/GamesServiceTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMoveAsync_Should_ThrowWithEndedGame()
{
  GamesService gamesService = new(<strong class="bold">_gamesRepositoryMock.Object</strong>);
  await <strong class="bold">Assert.ThrowsAsync</strong>&lt;CodebreakerException&gt;(async () =&gt;
  {
<strong class="bold">    await gamesService.SetMoveAsync(_endedGameId, "Game6x4", ["Red", </strong>
<strong class="bold">    "Green", "Blue", "Yellow"], 1, CancellationToken.None);</strong>
  });
  <strong class="bold">_gamesRepositoryMock.Verify</strong>(repo =&gt; repo.GetGameAsync(_endedGameId, 
<strong class="bold">   </strong>CancellationToken.None), <strong class="bold">Times.Once</strong>);
}</pre>
			<p>In the <em class="italic">arrange</em> step, the <code>GamesService</code> class is instantiated with the mocking object of the <code>IGamesRepository</code> implementation. With the unit test act – as already used before – <code>Assert.ThrowAsync</code> is used to check if an exception was thrown when invoking the <code>SetMoveAsync</code> method with the specified game that already ended. Another check that is done here<a id="_idIndexMarker790"/> is using the <code>Verify</code> method on the <code>Mock</code> class to check if the method is exactly called once.</p>
			<p>The <code>SetMoveAsync_Should_ThrowWithUnexpcectedGameType</code> and <code>SetMoveAsync_Should_ThorwWithNotFoundGameType</code> unit test methods are very similar, thus are not listed here. Check the source code repo for details.</p>
			<p>The test method to test the normal flow is shown here:</p>
			<pre class="source-code">
[Fact]
public async Task SetMoveAsync_Should_UpdateGameAndAddMove()
{
  GamesService gamesService = new(_gamesRepositoryMock.Object);
  var result = await gamesService.SetMoveAsync(_running6x4GameId, 
<strong class="bold">    </strong>"Game6x4", ["Red", "Green", "Blue", "Yellow"], 1, 
<strong class="bold">    </strong>CancellationToken.None);
<strong class="bold">  Assert.Equal(_running6x4Game, result.Game);</strong>
<strong class="bold">  Assert.Single(result.Game.Moves);</strong>
  _gamesRepositoryMock.Verify(repo =&gt; repo.GetGameAsync
  (_running6x4GameId, CancellationToken.None), Times.Once);
  _gamesRepositoryMock.Verify(repo =&gt; repo.AddMoveAsync
  (_running6x4Game, It.IsAny&lt;Move&gt;(), CancellationToken.None), Times.
  Once);
}</pre>
			<p>The <code>SetMoveAsync_Should_UpdateGameAndAddMove</code> method verifies that the <code>GetGameAsync</code> and <code>AddMoveAsync</code> methods are called once, and with the first move in the game, the <code>Moves</code> property<a id="_idIndexMarker791"/> contains exactly one value.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor251"/>Running unit tests</h2>
			<p>To start unit tests, you can use the <code>dotnet test</code> .NET CLI command to run all the tests. Using Visual Studio, the <strong class="bold">Test</strong> menu is <a id="_idIndexMarker792"/>available to run all the tests. Using <strong class="bold">Test Explorer</strong>, as shown in <em class="italic">Figure 10</em><em class="italic">.1</em>, you can start testing by test, a group of tests, or all tests, see the outcome of every test, debug tests, run tests until they fail, define a playlist of tests, and more:</p>
			<div><div><img src="img/B21217_10_01.jpg" alt="Figure 10.1 – Visual Studio Test Explorer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Visual Studio Test Explorer</p>
			<p>When using Visual Studio 2022 Enterprise Edition, you can start Live Unit Testing. With Live Unit Testing, a unit test runs while you change the source code. Here, you can also monitor which code lines are <a id="_idIndexMarker793"/>covered by a unit test and which lines are missed. <em class="italic">Figure 10</em><em class="italic">.2</em> shows the Visual Studio Code editor with Live Unit Testing turned on, and code line <em class="italic">53</em> missed from all unit tests:</p>
			<div><div><img src="img/B21217_10_02.jpg" alt="Figure 10.2 – Visual Studio Live Unit Testing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Visual Studio Live Unit Testing</p>
			<p>After working through some unit tests, let’s move over to other test types.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor252"/>Creating .NET Aspire integration tests</h1>
			<p>While unit tests should be the primary tests, integration tests not only test a small functionality but include testing<a id="_idIndexMarker794"/> of multiple components within one test, such as including infrastructure – for example, a database.</p>
			<p>.NET Aspire contains a library and test templates using xUnit, which easily allows creating integration tests to directly access the app model.</p>
			<p>Let’s create a .NET Aspire test project using .NET Aspire and xUnit, named <code>Codebreaker.IntegrationTests</code>:</p>
			<pre class="console">
dotnet new aspire-xunit -o Codebreaker.IntegrationTests</pre>
			<p>This project includes references to the <code>Aspire.Hosting.Testing</code> NuGet package, as well as <code>Microsoft.NET.Test.Sdk</code>, xUnit, and <code>xunit.runner.visualstudio</code>. To allow accessing the app model, add a project reference to <code>Codebreaker.AppHost</code>. With the integration test we implement, we need types from the game APIs project, thus we also add a reference to <code>Codebreaker.GameAPIs</code>.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor253"/>Creating asynchronous initialization</h2>
			<p>With all the integration tests of the <a id="_idIndexMarker795"/>game APIs, we need an <code>HttpClient</code> instance. xUnit allows for asynchronous initialization by implementing the <code>IAsyncLifetime</code> interface:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
public class GameAPIsTests : <strong class="bold">IAsyncLifetime</strong>
{
<strong class="bold">  private DistributedApplication? _app;</strong>
<strong class="bold">  private HttpClient? _client;</strong>
  public async Task <strong class="bold">InitializeAsync</strong>()
  {
    // code removed for brevity
  }
  public async Task <strong class="bold">DisposeAsync</strong>()
  {
    if (_app is null) throw new InvalidOperationException();
<strong class="bold">    await _app.DisposeAsync();</strong>
  }
  // code removed for brevity</pre>
			<p>Renaming the class created from the<code> IAsyncLifetime</code> interface defines the  <code>InitializeAsync</code> and <code>DisposeAsync </code>methods. Field members that will be initialized within the InitalizeAsync <a id="_idIndexMarker796"/>method are the <code>DistributedApplication</code> and <code>HttpClient</code> classes. You already know the <code>DistributedApplication</code> class from the app model in the <code>AppHost</code> project. You’ll see how this will be used in the <code>InitalizeAsync</code> method.</p>
			<p>While we didn’t dispose of the <code>DistributedApplication</code> instance in the <code>AppHost</code> project (because there’s only one instance running for the lifetime of the application, and the resources are freed on the application end), it’s important to dispose of it with unit tests, as it initialized providers and file watchers. With many tests, the user limit of <code>INotify</code> instances and the process limit of open file descriptors can be reached – thus, don’t forget to dispose of this resource in test projects.</p>
			<p>Let’s see how to create <code>DistributedApplication</code> and <code>HttpClient</code> classes:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
public async Task InitializeAsync()
{
<strong class="bold">  var appHost = await DistributedApplicationTestingBuilder.</strong>
<strong class="bold">    CreateAsync&lt;Projects.Codebreaker_AppHost&gt;();</strong>
<strong class="bold">  _app = await appHost.BuildAsync();</strong>
<strong class="bold">  await _app.StartAsync();</strong>
<strong class="bold">  </strong><strong class="bold">_client = _app.CreateHttpClient("gameapis");</strong>
}</pre>
			<p>Using <code>DistributedApplicationTestingBuilder</code> (defined in the <code>Aspire.Hosting.Testing</code> namespace), invoking the <code>CreateAsync</code> method, a new instance of <code>DistributedApplicationTestingBuilder</code> is returned. The generic parameter references the <code>Codebreaker</code> <code>AppHost</code> project. Similar to what you’ve seen when using the generic parameter with the projects referenced in the <code>AppHost</code> project, the same<a id="_idIndexMarker797"/> mechanism is used here, referencing the <code>AppHost</code> project itself. Invoking the <code>BuildAsync</code> method returns a <code>DistributedApplication</code> instance that we may forget to dispose of. Using this instance, we can access the app model definition. In the app model specified by the <code>Codebreaker.AppHost</code> project, we have <code>gameapis</code> defined, which is the name of the <code>Codebreaker.GameAPIs</code> project. <code>CreateHttpClient</code> returns an <code>HttpClient</code> object to reference this service. Both the <code>HttpClient</code> and the <code>DistributedApplication</code> objects returned are assigned to field members. Now, we are ready to create tests.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor254"/>Creating a test to verify an HTTP bad request status</h2>
			<p>With the first test, let’s verify if the correct status code is returned when an invalid move number is sent. First, we need to<a id="_idIndexMarker798"/> start a new game:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMove_Should_ReturnBadRequest_WithInvalidMoveNumber()
{
  if (_client is null) throw new InvalidOperationException();
<strong class="bold">  CreateGameRequest request = new(GameType.Game6x4, "test");</strong>
<strong class="bold">  var response = await _client.PostAsJsonAsync("/games", request);</strong>
<strong class="bold">  var gameResponse = await response.Content.</strong>
<strong class="bold">    ReadFromJsonAsync&lt;CreateGameResponse&gt;();</strong>
<strong class="bold">  Assert.NotNull(gameResponse);</strong>
  // code removed for brevity</pre>
			<p>Starting the game, we already use the <code>HttpClient</code> instance and invoke an HTTP <code>POST</code> request, passing the <code>CreateGameRequest</code> object. <code>CreateGameRequest</code> is available in the test project <a id="_idIndexMarker799"/>because we added a project reference to the <code>Codebreaker.GameAPIs</code> project on creation of the test project.</p>
			<p>Continue the implementation of this method by setting a game move:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMove_Should_ReturnBadRequest_WithInvalidMoveNumber()
{
  // code removed for brevity
<strong class="bold">  int moveNumber = 0;</strong>
<strong class="bold">  UpdateGameRequest updateGameRequest = new(gameResponse.Id, </strong>
<strong class="bold">  gameResponse.GameType, gameResponse.PlayerName, moveNumber)</strong>
<strong class="bold">  {</strong>
<strong class="bold">    GuessPegs = ["Red", "Red", "Red", "Red"]</strong>
<strong class="bold">  };</strong>
  string uri = $"/games/{updateGameRequest.Id}";
<strong class="bold">  var updateGameResponse = await _client.PatchAsJsonAsync(uri, </strong>
<strong class="bold">    updateGameRequest);</strong>
<strong class="bold">  Assert.Equal(HttpStatusCode.BadRequest, updateGameResponse.</strong>
<strong class="bold">    StatusCode);</strong>
}</pre>
			<p>We use <code>HttpClient</code> once more – this time to send a <code>PATCH</code> request. Passing <code>moveNumber</code> with a <code>0</code> value<a id="_idIndexMarker800"/> specifies an incorrect move. The first correct move starts with <code>1</code>. This way, we expect to receive a <code>BadRequest</code> result, which is verified using <code>Assert.Equal</code>.</p>
			<p>Let’s create another test to play a complete game.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor255"/>Creating a test to play a complete game</h2>
			<p>The following code snippet shows<a id="_idIndexMarker801"/> an integration test setting multiple moves:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
[Fact]
public async Task SetMoves_Should_WinAGame()
{
  // code removed for brevity
<strong class="bold">  int moveNumber = 1;</strong>
  UpdateGameRequest updateGameRequest = new(gameResponse.Id, 
<strong class="bold">    </strong>gameResponse.GameType, gameResponse.PlayerName, moveNumber)
  {
    GuessPegs = ["Red", "Red", "Red", "Red"]
  };
  string uri = $"/games/{updateGameRequest.Id}";
<strong class="bold">  response = await _client.PatchAsJsonAsync(uri, updateGameRequest);</strong>
  var updateGameResponse = await response.Content.
<strong class="bold">    </strong>ReadFromJsonAsync&lt;UpdateGameResponse&gt;();
  Assert.NotNull(updateGameResponse);
  // code removed for brevity</pre>
			<p>Starting the game is the same as before, thus the code is not shown here. Sending the first move is just a little<a id="_idIndexMarker802"/> bit different in that we send the correct move number. From there, we continue sending a <code>GET</code> request:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
  // code remove for brevity
  if (!<strong class="bold">updateGameResponse.IsVictory</strong>)
  {
    Game? game = await _client.GetFromJsonAsync&lt;Game?&gt;(uri);
    Assert.NotNull(game);
    moveNumber = 2;
<strong class="bold">    updateGameRequest = new UpdateGameRequest(gameResponse.Id, </strong>
<strong class="bold">      gameResponse.GameType, gameResponse.PlayerName, moveNumber)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      GuessPegs = game.Codes</strong>
<strong class="bold">    };</strong>
    response = await _client.PatchAsJsonAsync(uri, updateGameRequest);</pre>
			<p>Before sending a <code>GET</code> request, we check if the game was won with the first move. This should happen about once in 1,296 invocations; thus, it will happen when running the test often. We don’t want to fail the test if the game was won with the first move. If the game has not been won <a id="_idIndexMarker803"/>yet, a <code>GET</code> request is done to find out the correct values, then the correct values are used to make the second move.</p>
			<p>Sending the correct move, we should get a successful result:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.IntegrationTests/GameAPIsTests.cs</p>
			<pre class="source-code">
    // code removed for brevity
    Assert.True(response.IsSuccessStatusCode);
    updateGameResponse = await response.Content.
<strong class="bold">      </strong>ReadFromJsonAsync&lt;UpdateGameResponse&gt;();
    Assert.NotNull(updateGameResponse);
    Assert.True(updateGameResponse.Ended);
    Assert.True(updateGameResponse.IsVictory);
  }
  // delete the game
  response = await _client.DeleteAsync(uri);
  Assert.True(response.IsSuccessStatusCode);
}</pre>
			<p>After sending the second move, the result is verified. Finally, the game is deleted. In between all these invocations, results are verified.</p>
			<p>Run all the integration tests either using the <code>dotnet test</code> .NET CLI command or with Visual Studio Test Explorer, just as before with the unit tests. Just remember not to use integration tests with Live Unit Testing.</p>
			<p>With CI, as covered in <a href="B21217_08.xhtml#_idTextAnchor183"><em class="italic">Chapter 8</em></a>, all these tests should run as well. This can simply be done using <code>dotnet test</code>.</p>
			<p>Using .NET Aspire testing for integration tests has the advantage that the server doesn’t need to be started. However, creating<a id="_idIndexMarker804"/> load tests, testing the solution before a switch to the production environment, and directly sending HTTP requests should be done from a test environment as well. We’ll do this in the next section.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor256"/>Creating end-to-end .NET Playwright tests</h1>
			<p><strong class="bold">Microsoft Playwright</strong> (<a href="https://playwright.dev">https://playwright.dev</a>) offers tools and libraries from Microsoft for web tests, which<a id="_idIndexMarker805"/> include tests on web APIs.</p>
			<p>Playwright offers several tools (including <a id="_idIndexMarker806"/>generating tests by recording actions with web pages, inspecting web pages, generating selectors, and viewing traces), tests across different platforms, and test libraries for TypeScript, JavaScript, Python, .NET, and Java. With UI automation, Playwright can replace manual testers! Here, we’ll use Playwright to test APIs – using .NET!</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor257"/>Creating a test project with Playwright</h2>
			<p>Let’s start creating a test <a id="_idIndexMarker807"/>project with Playwright. Because xUnit has a focus on unit tests and there’s an issue with limiting concurrent test runs, Playwright <a id="_idIndexMarker808"/>supports NUnit and MSTest. Here, we use NUnit:</p>
			<pre class="console">
dotnet new nunit -o Codebreaker.GameAPIs.Playwright
cd Codebreaker.GameAPIs.Playwright
dotnet add package Microsoft.Playwright.NUnit
dotnet build</pre>
			<p>Using <code>dotnet new</code>, we create a new .NET project, this time using NUnit for the testing framework. <code>Microsoft.Playwright.NUnit</code> is the Playwright package for NUnit. After <code>dotnet build</code>, a <code>playwright.ps1</code> PowerShell script file is created in the <code>bin/debug/net8.0</code> folder<a id="_idIndexMarker809"/> that installs required <a id="_idIndexMarker810"/>browsers:</p>
			<pre class="console">
pwsh bin/debug/net8.0/playwright.ps1 install</pre>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor258"/>Creating a context</h2>
			<p>Playwright has its own API for <a id="_idIndexMarker811"/>creating HTTP requests. This needs to be initialized, together with some housekeeping:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[assembly: Category("SkipWhenLiveUnitTesting")]</strong>
namespace Codebreaker.APIs.PlaywrightTests;
[Parallelizable(ParallelScope.Self)]
public class GamesApiTests : <strong class="bold">PlaywrightTest</strong>
{
  private <strong class="bold">IAPIRequestContext</strong>? _requestContext;</pre>
			<p>Because this test class shouldn’t participate in live unit testing, the <code>Category</code> assembly attribute is used to mark the complete assembly with <code>SkipWhenLiveUnitTesting</code>. Contrary to xUnit where the <code>AssemblyTrait</code> attribute was used, NUnit uses the <code>Category</code> attribute.</p>
			<p>With Playwright, the test class needs to derive from the <code>PlaywrightTest</code> base class. The field of type <code>IAPIRequestContext</code> is Playwright’s API to create HTTP requests. This field is initialized with the next source code snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[SetUp]</strong>
public async Task SetupApiTesting()
{
  ConfigurationBuilder configurationBuilder = new();
  configurationBuilder.SetBasePath(
    Directory.GetCurrentDirectory());
  configurationBuilder.AddJsonFile("appsettings.json");
  var config = configurationBuilder.Build();
  if (!int.TryParse(config["ThinkTimeMS"], out _thinkTimeMS))
  {
    _thinkTimeMS = 1000;
  }
  Dictionary&lt;string, string&gt; headers = new()
  {
    { "Accept", "application/json" }
  };
<strong class="bold">  _requestContext = await Playwright.APIRequest.NewContextAsync(new()</strong>
<strong class="bold">  {</strong>
<strong class="bold">    BaseURL = config["BaseUrl"] ?? "http://localhost",</strong>
<strong class="bold">    ExtraHTTPHeaders = headers</strong>
<strong class="bold">  });</strong>
}</pre>
			<p>The <code>SetupAPITesting</code> method is<a id="_idIndexMarker812"/> invoked before every test. With NUnit, such an initialization method needs to be annotated with the <code>Setup</code> attribute. To initialize <code>IAPIRequestContext</code>, the <code>Playwright.APIRequest.NewContextAsync</code> method is invoked. Here, the HTTP headers and the base address for the service are specified. To allow this to be configured with the <code>appsettings.json</code> file, the <code>ConfigurationBuilder</code> class is used. To simulate a think time, <code>_thinkTimeMS</code> is retrieved from the configuration, which is then used before setting every game move.</p>
			<p>As the API context is created, it also needs to be disposed of:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[TearDown]</strong>
public async Task TearDownAPITesting()
{
  if (_requestContext != null)
  {
<strong class="bold">    await _requestContext.DisposeAsync();</strong>
  }
}</pre>
			<p>A method that’s invoked after the test has run is annotated with the <code>TearDown</code> attribute. The context <a id="_idIndexMarker813"/>needs to be disposed of after use.</p>
			<p>After the preparation, let’s create our test.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor259"/>Playing a game with Playwright</h2>
			<p>Tests created with NUnit are<a id="_idIndexMarker814"/> annotated with the <code>Test</code> attribute:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
<strong class="bold">[Test]</strong>
<strong class="bold">[Repeat(20)]</strong>
public async Task PlayTheGameToWinAsync()
{
  // code removed for brevity
  string playerName = "test";
  (Guid id, string[] colors) = await <strong class="bold">CreateGameAsync</strong>(playerName);
  int moveNumber = 1;
  bool gameEnded = false;
  while (moveNumber &lt; 10 &amp;&amp; !gameEnded)
  {
    await Task.Delay(_thinkTimeMS);
    string[] guesses = [.. Random.Shared.GetItems&lt;string&gt;(colors, 4)];
    gameEnded = await <strong class="bold">SetMoveAsync</strong>(id, playerName, moveNumber++, 
    guesses);
  }
  if (!gameEnded)
  {
    await Task.Delay(_thinkTimeMS);
    string[] correctCodes = await <strong class="bold">GetGameAsync</strong>(id, moveNumber – 1);
    gameEnded = await <strong class="bold">SetMoveAsync</strong>(id, playerName, moveNumber++, 
      correctCodes);
  }
  <strong class="bold">Assert.That</strong>(gameEnded, Is.True);
}</pre>
			<p>NUnit uses the <code>Test</code> attribute to specify a test. The <code>Repeat</code> attribute can be used to specify the number of runs the test should be repeated running one test. This attribute is useful in generating a longer load on the server. The <code>PlayTheGameToWin</code> method defines the flow with the API. First, a new game is created invoking the <code>CreateGameAsync</code> method. After <a id="_idIndexMarker815"/>this, for up to 10 moves, moves are placed with the <code>SetMoveAsync</code> method. If – with the randomly chosen guesses – the game is already finished, we are done. Otherwise, information about the game is retrieved using <code>GetGameAsync</code>, and one more time, <code>SetMoveAsync</code> is invoked – this time with the correct move.</p>
			<p>One of these invocations is shown in the next code snippet. For the other ones, check the source code repository:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs.Playwright/GamesAPITests.cs</p>
			<pre class="source-code">
private async Task&lt;bool&gt; SetMoveAsync(Guid id, string playerName, int moveNumber, string[] guesses)
{
  Dictionary&lt;string, object&gt; request = new()
  {
    ["id"] = id.ToString(),
    ["gameType"] = "Game6x4",
    ["playerName"] = playerName,
    ["moveNumber"] = moveNumber,
    ["guessPegs"] = guesses
  };
<strong class="bold">  </strong><strong class="bold">var response = await _requestContext.PatchAsync($"/games/{id}", new()</strong>
<strong class="bold">  </strong><strong class="bold">{</strong>
<strong class="bold">    DataObject = request</strong>
<strong class="bold">  });</strong>
<strong class="bold">  Assert.That(response.Ok, Is.True);</strong>
  var json = await response.JsonAsync();
  JsonElement results = json.Value.GetProperty("results");
<strong class="bold">  Assert.Multiple(() =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    Assert.That(results.EnumerateArray().Count(), </strong>
<strong class="bold">      Is.LessThanOrEqualTo(4));</strong>
<strong class="bold">    </strong><strong class="bold">Assert.That(results.EnumerateArray().All(x =&gt; x.ToString() is </strong>
<strong class="bold">      "Black" or "White"));</strong>
<strong class="bold">  });</strong>
  bool hasEnded = bool.Parse(json.Value.GetProperty("ended").
<strong class="bold">    </strong>ToString());
  return hasEnded;
}</pre>
			<p>The <code>SetMoveAsync</code> method sets a move by using the <code>IAPIRequestContext</code> interface’s <code>PatchAsync</code> method. Depending<a id="_idIndexMarker816"/> on the HTTP verb used, <code>GetAsync</code>, <code>PostAsync</code>… methods are available. The HTTP body that is sent to the service is specified with the <code>DataObject</code> property. The <code>PatchAsync</code> method returns an <code>IAPIResponse</code> response. Using this response, the JSON data can be retrieved using the <code>JsonAsync</code> method. The <code>Ok</code> property that is used with an <code>Assert</code> verification returns <code>true</code> with a status code in the range of 200 to 299.</p>
			<p>With this test in place, we can run the test using <code>dotnet test</code> or with Test Explorer within Visual Studio. Just this time, the service needs to be running!</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor260"/>Creating test loads</h1>
			<p>The Playwright tests can now be used to simulate a user load, to run multiple users concurrently. For this, just compute<a id="_idIndexMarker817"/> resources are needed to run the needed load. By reducing the delay time, a few “virtual users” can be used to simulate the load of a bigger number of real users. How long real users are thinking between moves needs to be analyzed monitoring the solution in production.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Reducing the delay between moves, you can use fewer compute resources to simulate a large number of real users with just a few virtual users. There’s also a good reason to increase the delay time for the time used by real users. In <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>, we’ll enhance the solution with caching. What if the cached game is not available after a user has a long delay between moves? Does the application still behave correctly? You should also run such integration tests.</p>
			<p>Using the <strong class="bold">Microsoft Playwright Testing</strong> cloud service, compute resources are available to test web applications. This <a id="_idIndexMarker818"/>service is – at the time of this writing – not available to test REST APIs. Another service to run load tests is <strong class="bold">Azure Load Testing</strong>. With this tool, you can write <strong class="bold">JMeter</strong> scripts to run the tests or specify web<a id="_idIndexMarker819"/> requests from the web portal. In <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>, we’ll use this service to create load<a id="_idIndexMarker820"/> tests to increase the replica count of the games API. This tool not only runs the load but also gives a great report to show information about all resources interacting with the requests.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the tests covered here can also be used with GitHub actions. After building the .NET libraries and applications, <code>dotnet test</code> should be triggered to start all the unit tests. After deploying the services to the test environment, integration tests should run before the solution is deployed to the next environment – for example, the staging environment. Automated load tests should make sure the solution is working under load.</p>
			<p class="callout">Continuously – for workflows triggered on a timely basis – you should check if new security issues are found in <a id="_idIndexMarker821"/>dependencies, and these dependencies should be updated. For this, with GitHub, just <em class="italic">Dependabot</em> needs to be configured.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor261"/>Summary</h1>
			<p>In this chapter, you learned to create <em class="italic">unit tests</em> to test simple functionality. These tests can be used with Live Unit Testing where test errors immediately show up during development. With unit tests, you learned to use a <em class="italic">mocking library</em> to replace functionality that is not in the scope of the unit test and is covered by a different unit test.</p>
			<p>You learned how .NET Aspire makes <em class="italic">integration tests</em> simple using <code>Aspire.Hosting.Testing</code>. There’s no need to start the service, as the handler of <code>HttpClient</code> is replaced to send requests to the service in-process.</p>
			<p>Using Microsoft Playwright, you created an integration test that makes HTTP requests to the API and can be used to test the solution under load.</p>
			<p>While you monitored metrics data in this chapter, the next chapter expands on this so that you can create your own metric counts and add logging and distributed tracing to the microservices solution.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor262"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li>Martin Fowler on testing microservices: <a href="https://martinfowler.com/articles/microservice-testing">https://martinfowler.com/articles/microservice-testing</a></li>
				<li>Live Unit Testing: <a href="https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing">https://learn.microsoft.com/en-us/visualstudio/test/live-unit-testing</a></li>
				<li>Integration tests: <a href="https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests">https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests</a></li>
				<li><em class="italic">Testing .NET Aspire </em><em class="italic">apps</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/testing</a></li>
				<li>Microsoft Playwright: <a href="https://playwright.dev/">https://playwright.dev/</a></li>
				<li><em class="italic">Guide to Secure .NET Development with OWASP Top </em><em class="italic">10</em>: <a href="https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/">https://learn.microsoft.com/en-us/training/modules/owasp-top-10-for-dotnet-developers/</a></li>
				<li><em class="italic">Working with </em><em class="italic">Dependabot</em>: <a href="https://docs.github.com/en/code-security/dependabot/working-with-dependabot">https://docs.github.com/en/code-security/dependabot/working-with-dependabot</a></li>
			</ul>
		</div>
	</body></html>