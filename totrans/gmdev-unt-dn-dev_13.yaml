- en: '*Chapter 10*: Serialization System and Assets Management in Unity and Azure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, [*Chapter 9*](B17146_09_Final_ASB_ePub.xhtml#_idTextAnchor165),
    *Using Data-Oriented Technology Stack in Unity*, we learned what the data-oriented
    technology stack is and how you can use this technology to take advantage of multicore
    processors to improve the performance of your game. In this chapter, we will cover
    some other important topics in Unity development, namely, **serialization** and
    **asset management** in Unity. Usually, a game not only has code but also consists
    of many different kinds of assets, such as models, textures, and audio. Hence,
    understanding what the serialization system in Unity is and what the assets workflow
    is can help you better develop games with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will also explore an interesting topic
    – how to use the **Azure Cloud storage** services to host the content of a Unity
    game and load the content from the Azure Cloud to the Unity game by using Unity's
    **Addressable Assets system**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following key topics will be included in our learning path:'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization system in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Assets workflow in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the special folders in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Blob storage with Unity's Addressable Assets system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will not only understand the serialization system
    and assets management in Unity, but you will also be familiar with Azure Cloud
    storage services.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds exciting!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this chapter will be covering Azure''s Storage account service, if you
    don''t have an Azure account available, I recommend you set up a free Azure trial
    account first before starting this chapter. You can click the following link to
    create a free Azure trial account with $200 credit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Microsoft Azure page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Microsoft Azure page
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Serialization system in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a game, adding a reliable content saving and loading feature
    is a critical part of the development process. If you're using a game engine editor,
    such as the Unity engine editor, you'll also need some common editor features,
    such as undo, saving editor settings, and more. All of this, whether the game
    saves or loads content at runtime, or whether the developer uses the editor to
    develop the game, is built on **serialization**.
  prefs: []
  type: TYPE_NORMAL
- en: What is Unity's serialization system?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what is `deserialization`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity, there are three serialization formats, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YAML` serialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JSON` serialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML and binary serialization in Unity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assets created by Unity, such as `Scenes` and `Prefabs`, will be saved in `YAML`
    format by default. For example, if we open the Scene of this chapter, namely,
    `Chapter10.unity`, in a text editor such as `OcclusionCullingSettings` and `RenderSettings`.
    If you scroll down, you can also find the GameObjects and components contained
    in this Scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The Scene in YAML format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – The Scene in YAML format
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 10.2*, there is no doubt that the YAML format is human-readable
    and makes it easy for the version control tools to work with. However, YAML is
    a text-based format, so you can also choose to use binary serialization for the
    more efficient use of space and increased security. Let''s perform the following
    steps to set Unity''s serialization mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Project Settings** window by clicking the **Edit | Project Settings...**
    item in the Unity Editor toolbar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Opening the Project Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Opening the Project Settings window
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click the settings panel, as shown in *Figure 10.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The Editor settings panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The Editor settings panel
  prefs: []
  type: TYPE_NORMAL
- en: In the **Asset Serialization** section, we can find that the **Mode** option
    is **Force Text** by default. In this mode, all the assets created by Unity will
    be serialized in YAML format. This is also the recommended setting if you use
    a version management tool such as Git, as using plain text serialization can often
    avoid unresolvable merge conflicts. As shown in *Figure 10.5*, in the drop-down
    window, we can select **Force Binary** mode to convert all the assets to binary
    format, and we can also choose the **Mixed** mode option to retain the serialization
    format of the current assets; that is, the assets that are serialized in binary
    format are still in binary format, and assets that are serialized using YAML format
    are still in YAML format. However, newly created assets will be serialized in
    binary format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Asset Serialization mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Asset Serialization mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can select **Force Binary** mode and check the same Scene file in
    our text editor again. The Scene file is converted to binary format, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The Scene file in binary format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The Scene file in binary format
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, serialization is also an important part of implementing
    the Unity Editor. Not only are the assets created by Unity as used in the game,
    such as game Scenes, serialized by Unity, but the various settings in the Unity
    Editor are also serialized by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project root directory, we can find the `ProjectSettings` folder, which
    is automatically created by the Unity Editor when the project is created, as shown
    in *Figure 10.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – The ProjectSettings folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – The ProjectSettings folder
  prefs: []
  type: TYPE_NORMAL
- en: Double-click this folder to open it. We can find all the settings files of the
    current project here.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – The settings files in the ProjectSettings folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – The settings files in the ProjectSettings folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we still use the text editor to open a settings file, such as `GraphicsSettings.asset`,
    and serialize this file using Unity''s binary serialization mode and text serialization
    mode, respectively. *Figure 10.9* shows the settings file serialized in binary
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – The settings file in binary format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – The settings file in binary format
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, you can see the settings file serialized in YAML format
    in *Figure 10.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The settings file in YAML format'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – The settings file in YAML format
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've discussed Unity's binary serialization and text-based YAML serialization,
    but we haven't covered the JSON serialization provided by Unity yet. Next, let's
    take a look at JSON serialization in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: JsonUtility class and JSON serialization in Unity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have previous experience of developing .NET projects, you are probably
    familiar with JSON serialization. You can choose the solutions provided by .NET,
    such as using the `DataContractJsonSerializer` class defined in the `System.Runtime.Serialization.Json`
    namespace or using the `JsonSerializer` class defined in the `System.Text.Json`
    namespace, and there are also solutions from the open source community, such as
    `Newtonsoft.Json`, which is a very popular JSON framework for .NET. Unity also
    provides game developers with JSON serialization capabilities in Unity development,
    namely, the `JsonUtility` class. We can call `JsonUtility`''s `ToJson` method
    to serialize an object into a JSON string, and conversely, `JsonUtility`''s `FromJson`
    method can deserialize a JSON string into an object. Next, let''s look at an example
    of how to use the `JsonUtility` class in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Scripts` by clicking the **Create | Folder** item
    in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Creating the Scripts folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Creating the Scripts folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the `Scripts` folder to enter it, and then create a new C#
    script in this folder, name it `PlayerData`, and add the following to this script.
    The `PlayerData` struct is used to store the data of a player, and an object of
    it will be serialized to a JSON string later. And you should note that fields
    of the structs or classes should be `public`; otherwise, the Unity serializer
    will ignore these fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we also need to create another C# script in the same folder and name
    it `JSONSerializationSample`. The code in `JSONSerializationSample` is as follows.
    In the `Start` method, we create a new `PlayerData` object and assign values to
    its fields, and then call the `JsonUtility.ToJson` method to serialize this object
    into a JSON string and print the string to the `Console` window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new GameObject in the Scene, attach the `JSONSerializationSample`
    script to it, and run the game in the editor. The JSON string, as shown in the
    following screenshot, will be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – The JSON string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – The JSON string
  prefs: []
  type: TYPE_NORMAL
- en: 'Deserializing a JSON string to an object is fairly straightforward; you just
    need to call `JsonUtility.FromJson<T>`, which is a generic method. If you don''t
    know about generic methods in C#, generic methods are methods declared with type
    parameters. So, let''s go back to `JSONSerializationSample` and update the code
    in the `Start` method. This code will deserialize the JSON string into a new object,
    and the object''s `Name` field will be printed in the **Console** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the game in the editor. The name of this player is printed as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Deserializing the JSON string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Deserializing the JSON string
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want `PlayerData` as a field of another class and you want to serialize
    this class, `PlayerData` needs to be marked with the `[System.Serializable]` attribute,
    otherwise, `PlayerData` as a field won''t be serialized correctly. So, let''s
    go back to `PlayerData` and update the code to add the `[System.Serializable]`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you know how to use the `JsonUtility` class to serialize an object
    to a JSON string and deserialize a JSON string to an object in Unity, it's time
    to discuss the advantages and limitations of Unity's `JsonUtility` class.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages and limitations of Unity's JsonUtility class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's start with the advantages of Unity's `JsonUtility` class. Using the `JsonUtility`
    class in Unity can achieve relatively high performance in terms of serializing
    and deserializing JSON. The `ToJson` method and the `FromJson` method of `JsonUtility`
    use the Unity serializer internally, and it has better support for some built-in
    types of Unity, such as `Vector2` and `Vector3`. In addition, since it is provided
    by the Unity game engine, there is no need to install additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `JsonUtility` has limited functionality compared to other popular
    JSON frameworks such as `Newtonsoft.Json`. The two most obvious limitations are
    that `JsonUtility` does not support the serialization of dictionaries and that
    the root element must be an object, not an array or a list. Let''s look at an
    example of the limitations of the `JsonUtility` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in the `Scripts` folder, name it `TeamData`, and add
    the following to this script. As shown in the following code, this class has two
    fields, a `PlayerData` list and a dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we also need to create another C# script in the same folder and name
    it `JsonUtilityLimitationsSample`. The code in `JsonUtilityLimitationsSample`
    is as follows. In the `Start` method, we create a new `TeamData` object, add an
    element to the `Players` list, and add a key and value to the `Roles` dictionary.
    Then, call the `JsonUtility.ToJson` method to serialize this object into a JSON
    string and print the string to the **Console** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game in the editor; you can find that only the `Players` list is serialized,
    but the `Roles` dictionary is not serialized as expected, as shown in the following
    screenshot. This is because `JsonUtility` does not support serializing dictionaries
    in Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The Roles dictionary is not serialized'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – The Roles dictionary is not serialized
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s go back to `JsonUtilityLimitationsSample` and update the code
    in the `Start` method to try to serialize the `Players` list individually:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the game in the editor again and you will find that the `Players` list is
    not serialized this time, as shown in the following screenshot. This is because
    if using `JsonUtility` for serialization, the root element must be an object,
    not an array or list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The Players list is not serialized'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – The Players list is not serialized
  prefs: []
  type: TYPE_NORMAL
- en: Newtonsoft.Json framework
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is a real headache to encounter the problems mentioned in the preceding
    example during development, so some other JSON frameworks may also be worth trying.
    Next, we will use `Newtonsoft.Json` to modify the preceding example so that the
    `Roles` dictionary in the `TeamData` class and the individual `Players` list can
    be serialized into JSON strings correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: First, if the `Newtonsoft.Json` package is not installed in your project, you
    can install it through Unity's Package Manager. You can open it by clicking the
    **Window | Package Manager** item in the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Opening Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Opening Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: Then, click the **+** in the upper-left corner to open the drop-down menu, and
    select the **Add package from git URL…** item in the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Add package from git URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – Add package from git URL
  prefs: []
  type: TYPE_NORMAL
- en: Enter `com.unity.nuget.newtonsoft-json` in the input box that appears, click
    the **Add** button, and wait for Package Manager to install this package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Adding Newtonsoft.Json'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – Adding Newtonsoft.Json
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing the package in the project, we can use the `Newtonsoft.Json`
    framework in our C# script, so let''s go back to `JsonUtilityLimitationsSample.cs`
    and update the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `Newtonsoft.Json` namespace with the `using` keyword, which provides
    classes and methods for JSON serialization and deserialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Start` method, we replace the `JsonUtility.ToJson` method with the `JsonConvert.SerializeObject`
    method that is defined in the `Newtonsoft.Json` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the game. You will find that the `Roles` dictionary field of the `TeamData`
    object is serialized as expected, while the `Players` list as the root element
    is also serialized correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Newtonsoft.Json works correctly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – Newtonsoft.Json works correctly
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explained what Unity's serialization system is and
    how to use JSON serialization in your Unity project. Now I think you're ready
    to continue exploring how assets in your game project are managed by the Unity
    engine!
  prefs: []
  type: TYPE_NORMAL
- en: The assets workflow in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity's assets workflow is another very interesting topic that is also very
    closely related to serialization. So, what is an `asset` in Unity? If you look
    at a Unity project, you will find that there is a folder called `Assets` in the
    root directory of this project, and an asset is a file stored in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unity development, assets can be divided into the following two categories
    according to their sources:'
  prefs: []
  type: TYPE_NORMAL
- en: External assets that are imported into Unity; the most common in this case are
    `models,` `textures,` and `audio`. They are often created by third-party tools,
    such as `Maya,` `3Ds Max,` and `Photoshop`, and then imported into Unity for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assets created by Unity itself, such as `Prefab` and `Scene` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whether it''s an imported asset or an asset created by Unity, Unity does the
    following three things with them:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity will assign a GUID to this asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, a meta file will be created automatically by Unity to store some additional
    information about the asset, such as the GUID and the import settings of this
    asset. *Figure 10.20* shows an example of an automatically created meta file.
    When a PNG file named `SampleTexture` is imported into the Unity project, Unity
    automatically creates a meta file and names it `SampleTexture.PNG.meta`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.20 – A meta file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.20 – A meta file
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Unity will process the asset file, convert its content into an internal
    representation in Unity, and store the internal representation in the `Library`
    folder in the project root. We will cover this in detail when we introduce the
    `Library` folder later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.21 – The Library folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.21 – The Library folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with an understanding of Unity''s assets workflow, let''s introduce the
    three things involved in this workflow in more detail: GUID and File ID, meta
    files, and the `Libary` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: GUID and File ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GUID and File ID are obviously an important topic when we discuss Unity's asset
    workflow. This is because no matter whether we use Unity to create an asset or
    import an external asset, Unity has to uniquely identify this asset, and this
    unique value is the GUID. File ID is often used together with GUID; it is not
    used to identify an asset like GUID, but is used to identify a reference to another
    object within an object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a brief understanding of GUID and File ID, it's time to move
    on to exploring GUID and File ID in more detail!
  prefs: []
  type: TYPE_NORMAL
- en: GUID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we just mentioned, Unity assigns a GUID to each asset in the `Assets` folder
    as the asset's identifier. We can use a text editor to open the meta file associated
    with this asset to find the GUID of this asset within the Unity engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now perform the following steps to create a new C# script as an asset
    and check the `GUID` of this C# script in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in the `Scripts` folder, name it `AssetSample`, and
    add the following to this script. As shown in the following code, this class has
    a `Texture` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A meta file called `AssetSample.cs.meta` is created next to the C# script file
    in the file explorer, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.22 – The AssetSample.cs.meta file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.22 – The AssetSample.cs.meta file
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AssetSample.cs.meta` file in a text editor, and you will discover
    that the GUID of this C# script asset in Unity is `e35f96b75211edd4bad6451a26675090`,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.23 – The GUID of this C# script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.23 – The GUID of this C# script
  prefs: []
  type: TYPE_NORMAL
- en: After reading this, you should know how to find the GUID of an asset in Unity;
    however, where is the File ID stored, and how does Unity use it to create and
    maintain references between objects? So, let's continue our journey with another
    example.
  prefs: []
  type: TYPE_NORMAL
- en: File ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned earlier that Unity uses a `File ID` to refer to another object
    within an object, which is the unique ID of the object referenced within that
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at an example to learn how to find the `File IDs` and
    how Unity uses the `File IDs` to maintain the reference relationship between objects.
    In this example, we will still use the `AssetSample` script we just created, so
    now let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new GameObject in the Scene and name it `AssetSampleGameObject`.
    You already know that a `Transform` component is automatically created and attached
    to this GameObject, as shown in *Figure 10.24*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Creating an AssetSampleGameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.24 – Creating an AssetSampleGameObject
  prefs: []
  type: TYPE_NORMAL
- en: Attach an `AssetSample` component to `AssetSampleGameObject`, and then assign
    a texture from the `Texture` field of `AssetSample`. Then, attach another `AssetSample`
    component to the same GameObject; however, this time, we set the `AssetSample`
    to **None** and save the Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.25 – Adding AssetSample components to the GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.25 – Adding AssetSample components to the GameObject
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure your project''s **Asset Serialization** mode is now **Force Text**
    (we covered this topic in the *YAML and binary serialization in Unity* section),
    and then use a text editor to open the Scene file from **File Explorer**. You
    will see a lot of content in the Scene file, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Opening the Scene file in a text editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.26 – Opening the Scene file in a text editor
  prefs: []
  type: TYPE_NORMAL
- en: 'This file gives us a lot of information, recording the GameObjects, components,
    and referenced assets in the Scene. So let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we can find the record of the GameObject called `AssetSampleGameObject`
    in the file. In the following screenshot, you can see that there are three components
    attached to this GameObject, with File IDs of `306521988`, `306521989`, and `306521990`,
    respectively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.27 – The AssetSampleGameObject record'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.27 – The AssetSampleGameObject record
  prefs: []
  type: TYPE_NORMAL
- en: If we search these three `File IDs`, we can find records for three components
    in this file – a `Transform` component, which is created and attached to this
    GameObject when the GameObject is created, and two `MonoBehaviour` components,
    which represent C# script components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.28 – File IDs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.28 – File IDs
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the difference between File ID and GUID? If we focus on these two
    `MonoBehaviour` components, we can see that the `m_Script` field of both components
    references the same C# script with a GUID of `e35f96b75211edd4bad6451a26675090`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.29 – The MonoBehaviour components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.29 – The MonoBehaviour components
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can find that although these two component objects refer to the
    same C# script, namely, `AssetSample`, they are two different instances of `AssetSample`;
    the file ID of the first `MonoBehaviour` component object is `306521989`, and
    the file ID of the second `MonoBehaviour` component object is `306521990`.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the `_texture` field of one instance refers to a texture asset, and
    the `_texture` field of the other instance does not refer to any texture asset.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, we learned that Unity uses GUID to identify an asset
    and File ID to identify a referenced object.
  prefs: []
  type: TYPE_NORMAL
- en: Meta files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already know that a meta file records the GUID of its associated asset in
    a Unity project, and that a meta file also records the import settings of this
    asset. In this section, we will talk about meta files that look inconspicuous
    but are actually very important.
  prefs: []
  type: TYPE_NORMAL
- en: Meta files and version management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common mistake developers new to Unity make is not paying attention to these
    autogenerated meta files. One such example is ignoring meta files when using Git
    or other version control systems to manage the version of the Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from the previous section, Unity assigns each asset a GUID,
    uses this GUID to identify the asset, and records this GUID in the meta file.
  prefs: []
  type: TYPE_NORMAL
- en: So, if your version management system does not include meta files, your Unity
    development progress may be disrupted.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let's imagine a scenario where, when a Unity project that
    does not contain meta files is cloned from a remote repository to your colleague's
    local machine, the Unity Editor will reimport those assets and assign them new
    GUIDs and create meta files to store this information. As a result, references
    that previously existed between objects in your Unity project will no longer be
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, assuming that the `AssetSample.cs.meta` meta file of the `AssetSample`
    C# script we created earlier is not managed by the version management system,
    then you will encounter the `Script Missing` error, as shown in *Figure 10.30*,
    after cloning and opening the project on another computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.30 – The Script Missing error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.30 – The Script Missing error
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the script actually exists, but since its GUID has been regenerated,
    the previous reference relationship is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when developing a Unity project, please make sure that the meta files
    are managed by your version management tool.
  prefs: []
  type: TYPE_NORMAL
- en: Import settings in meta files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to storing the GUID of an asset, a meta file also stores the import
    settings of this asset. Of course, the meta files that will be discussed in this
    subsection mainly refer to the meta files of assets created in third-party software
    and that are then imported into the Unity Editor, such as models, textures, and
    audio.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a meta file of an audio asset as an example to see how the import
    settings of the asset are saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The audio asset we are using here is from Unity''s Asset Store and you can
    download it from here: [https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047](https://assetstore.unity.com/packages/audio/sound-fx/weapons/ultra-sci-fi-game-audio-weapons-pack-vol-1-113047).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.31 – Audio pack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.31 – Audio pack
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the audio into the Unity project, we can select the first audio
    file in the `Ultra SF Game Audio Weapons Pack v.1` folder to open the audio''s
    Inspector window in the Unity Editor, which shows the asset''s import settings.
    Then we use a text editor to open the meta file of the same audio asset in the
    folder explorer and, as shown in *Figure 10.32*, we can see that `AudioImporter`
    in the meta file corresponds to the import settings in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.32 – WPN_SCI-FI_FIRE_01 audio''s import settings and meta file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.32 – WPN_SCI-FI_FIRE_01 audio's import settings and meta file
  prefs: []
  type: TYPE_NORMAL
- en: 'The import settings of a texture asset and a model asset are also stored in
    their meta files. The following screenshot shows the import settings for a texture
    and a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.33 – Import settings of a texture (left) and the import settings
    of a model (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.33 – Import settings of a texture (left) and the import settings of
    a model (right)
  prefs: []
  type: TYPE_NORMAL
- en: Since the meta file stores the import settings of the asset, once we modify
    the import settings of the asset in the Unity Editor, the corresponding meta file
    will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: The import settings often affect how Unity processes these assets, so it is
    important to ensure that the import settings can be managed according to the requirements
    of the project. For example, in many mobile game projects, we should check the
    **Force To Mono** option on the audio import settings to reduce the memory usage
    of this audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at how to manage import settings through a C# script
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The AssetPostprocessor class and the import pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides the `AssetPostprocessor` class for game developers to hook into
    the assets import pipeline in Unity. When importing an asset, we can manage the
    import pipeline according to the asset type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will create a new C# script to set the **Force
    To Mono** option enabled in the import settings of all audio files in the Unity
    projec:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a subfolder in the `Scripts` folder and name it `Editor`. This is because
    the C# class that we will create inherits from the `AssetPostprocessor` class,
    which is a class for the editor, so it needs to be placed in an `Editor` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.34 – Creating an Editor folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.34 – Creating an Editor folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the `Editor` folder to enter it, create a new C# script in
    this folder, name it `AssetImporterSample`, and then add the following to this
    script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the code is using the `UnityEditor` namespace. This is because the `AssetPostprocessor`
    class is defined in this namespace, which also means that the `AssetImporterSample`
    C# script is used in the Unity Editor and not at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AssetImporterSample` class inherits the `AssetPostprocessor` class and
    implements the `OnPreprocessAudio` method, which will be called before the audio
    asset is imported. We can also implement other similar methods to be called when
    other asset types will be imported. For example, the `OnPreprocessTexture` method
    will be called before the texture asset is imported, and the `OnPreprocessModel`
    method will be called before the model asset is imported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnPreprocessAudio` method, we can get an instance of `AudioImporter`,
    set the `forceToMono` option to `true`, and then save and re-import the asset
    to ensure that the new import settings for the asset take effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Save the C# script and the Unity Editor should modify the import settings of
    these audio assets in the project and then re-import them, as shown in *Figure
    10.35*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.35 – Importing audio assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.35 – Importing audio assets
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now select an audio file to check its import settings. As shown in *Figure
    10.36*, the new import settings work as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.36 – New import settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.36 – New import settings
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we introduced how to use C# code to manage the asset import
    pipeline. Next, let's explore another assets workflow topic in Unity – the `Library`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The Library folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Unity project, Unity will process and convert the external assets into
    Unity internal format assets and save them in the `Library` folder. Because the
    data stored in the `Library` folder is cached data that can always be regenerated
    from the source asset files based on the import settings, the `Library` folder
    should generally not be included in a version management system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `Library` folder, there are some other Unity folders that
    need to be excluded from version management, including `Temp, Obj,` and `Logs`.
    If you are using Git as your version management tool, you can find the `.gitignore`
    file for Unity projects at this link: [https://github.com/github/gitignore/blob/main/Unity.gitignore](https://github.com/github/gitignore/blob/main/Unity.gitignore).'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `Library` folder in the root directory of your Unity project,
    as shown in *Figure 10.37*. If there is no `Libary` folder in the root directory
    of your Unity project, you need to open the project with the Unity Editor. The
    Unity Editor will import the assets in the `Assets` folder and generate the `Library`
    folder automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.37 – The Library folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.37 – The Library folder
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the `Library` folder to enter it and you will see the `ScriptAssemblies`
    subfolder, which saves the assemblies of the C# code in the project, and you can
    also see the `PackageCache` subfolder, which saves the cache of Unity packages
    used by the project. In addition to these, you also can see the `Artifacts` subfolder,
    where the assets processed by Unity are saved.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.38 – The Artifacts folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.38 – The Artifacts folder
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced Unity's assets workflow, covering topics such
    as GUIDs, File IDs, meta files, and the `Library` folder. Next, let's take a look
    at the special folders created and managed by developers related to assets management
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the special folders in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already covered some of these special folders related to scripting in Unity
    in [*Chapter 2*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025), *Scripting
    Concepts in Unity*. In this section, we will introduce the remaining special folders,
    which are related to asset management in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Resources folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's take a look at the `Resources` folder in Unity. `Resources` is
    a special folder name in Unity, but Unity does not automatically create a `Resources`
    folder for you. If you want to use a `Resources` folder to manage assets, you
    need to create it yourself. It should be noted that there can be multiple `Resources`
    folders in the `Assets` directory in a Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity provides the `Resources.Load` method to load assets in `Resources` folders.
    Next, we will use an example to learn how to use `Resources` folders to manage
    assets:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `Resources` by clicking the **Create | Folder** item
    in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.39 – Creating a Resources folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.39_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.39 – Creating a Resources folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an empty GameObject, name it `SamplePrefab`, and drag it into the `Resources`
    folder to create a new prefab, as shown in *Figure 10.40*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.40 – SamplePrefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.40_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.40 – SamplePrefab
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in the `ResourcesLoadExample`, and add the following
    to this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Start` method, we call the `Resources.Load` method and pass the path
    to the asset to load as an argument to this method, which is `SamplePrefab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, if the prefab asset is loaded, we instantiate it to create a new GameObject
    in the game Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new GameObject and attach the `ResourcesLoadExample` script to it.
    Run the game in the Unity Editor by clicking the **Play** button. We can see that
    a new instance of the prefab is created as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.41 – Loading assets from the Resources folders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.41_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.41 – Loading assets from the Resources folders
  prefs: []
  type: TYPE_NORMAL
- en: 'Through this example, we see that using `Resources` folders to manage assets
    is very convenient, especially when you need to develop a prototype quickly, but
    managing assets in a Unity project by using `Resources` folders is not recommended
    for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: When the Unity Editor builds the game, the assets in `Resources` folders will
    be included in the build, even if the assets are not used, so improper use of
    the `Resources` folder may cause the build game to be too large. In addition,
    it will also affect the game's startup speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Resources` folders will make incremental content upgrades to the game
    very difficult or impossible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an understanding of the `Resources` folders, we know the situations
    in which they will be suitable, such as developing a rapid prototype, as well
    as its limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will continue to introduce another special folder in Unity, namely,
    `StreamingAssets`
  prefs: []
  type: TYPE_NORMAL
- en: StreamingAssets folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unity, `StreamingAssets` is also a special folder name. We actually already
    covered this in [*Chapter 6*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095),
    *Integrating Audio and Video in a Unity Project*. In this subsection, we will
    discuss it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier that Unity will process assets in the `Assets` folder in
    a format that the Unity engine understands, but there is an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The assets in the `StreamingAssets` folder in the Unity project will still be
    in the original format and these assets will not be built into the game along
    with the other assets when Unity builds the game. Instead, all assets in the folder
    will be copied to a specific folder on the target device.
  prefs: []
  type: TYPE_NORMAL
- en: Since the location of this special folder is different on different platforms,
    Unity provides the `Application.streamingAssetsPath` property so that we can access
    the correct path to this folder from C# code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is from the example used in [*Chapter 6*](B17146_06_Final_ASB_ePub.xhtml#_idTextAnchor095),
    *Integrating Audio and Video in a Unity Project*. We can see how to use `Application.streamingAssetsPath`
    in C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the `Resources` folder, Unity does not automatically create the
    `StreamingAssets` folder for you. If you wish to use it, you need to create it
    yourself, as shown in *Figure 10.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.42 – Creating a StreamingAssets folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.42_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.42 – Creating a StreamingAssets folder
  prefs: []
  type: TYPE_NORMAL
- en: Then we can place an audio WAV file in the `StreamingAssets` folder. As you
    can see from the following screenshot, the icon of this WAV file is not the same
    as the icon of an audio clip in Unity that we are already familiar with. This
    is because Unity does not process the WAV file; it still maintains its original
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.43 – Placing a WAV file in the StreamingAssets folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.43_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.43 – Placing a WAV file in the StreamingAssets folder
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the `Resources` folder and the `StreamingAssets`
    folder, which are special folders in Unity, and understood that what they do can
    help you better develop games with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll cover another interesting topic; how to use Azure Blob storage in
    the Azure Cloud with Unity's Addressable Asset system.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Blob storage with Unity's Addressable Asset system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll cover the Azure Blob storage service in Microsoft's Azure
    Cloud and how to use it with Unity's Addressable Asset system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Blob storage** is a type of Azure Storage account in Azure. Other types
    of Azure Storage accounts include **queues**, **file shares**, and **tables**.
    Among them, Blob storage is very suitable for storing large amounts of unstructured
    data such as binary data.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional information and resources about the Azure Storage account
    in Microsoft's Azure Cloud at [https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction](https://docs.microsoft.com/en-us/azure/storage/common/storage-introduction).
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Addressable Asset system, as the name suggests, provides a convenient
    method for loading specific assets, whether on the local or remote server, according
    to a specific address. When discussing the `Resources` folder in the previous
    section, we discussed various limitations when using it in terms of managing assets,
    and the Addressable Asset system can solve these problems very well; for example,
    the size of the game package can be well controlled, there is no need to include
    unnecessary assets in game builds, and assets can be hosted on remote servers,
    such as the Azure Cloud, to incrementally update assets within the game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before the Addressable Asset system was introduced, developers could also use
    `AssetBundles` to manage assets; `AssetBundles` is beyond the scope of what we
    need here, but if you're interested, you can find out more at [https://docs.unity3d.com/Manual/AssetBundlesIntro.html](https://docs.unity3d.com/Manual/AssetBundlesIntro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Well, now we have an understanding of Azure Blob storage and the Addressable
    Asset system. Next, we will explore how to use Azure Blob storage to host assets
    and use the Addressable Asset system to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Azure Blob storage service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, make sure you have an available Azure subscription. You can apply for
    a free Azure trial account on the page introduced at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is ready, we can create our first resource in Azure, namely, an
    **Azure resource group**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new resource group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a resource group is our first resource in the Azure Cloud. This is
    because a resource group is a container for holding other Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a resource group in just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to the Azure portal page with your account at [https://portal.azure.com/](https://portal.azure.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.44 – Azure portal page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.44_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.44 – Azure portal page
  prefs: []
  type: TYPE_NORMAL
- en: The Azure portal page does not display the portal menu by default. We can click
    the **Show portal menu** button in the upper-left corner of the page to open the
    portal menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.45 – Show portal menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.45_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.45 – Show portal menu
  prefs: []
  type: TYPE_NORMAL
- en: Select **Resource groups** from the portal menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.46 – Selecting the Resource groups service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.46_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.46 – Selecting the Resource groups service
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Resource groups** page will then open. Click the **Create** button on
    this page, as shown in *Figure 10.47*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.47 – Creating a resource group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.47_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.47 – Creating a resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you will see the `rg-unitybook-dev-001`. Select the region of the resource
    group as `(Asia Pacific) Australia East` and then click on **Review + create**
    to verify the settings of this resource group and create it, as shown in *Figure
    10.48*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.48 – Creating a resource group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.48_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.48 – Creating a resource group
  prefs: []
  type: TYPE_NORMAL
- en: We've created a resource group in Azure. Next, let's create an Azure Storage
    account resource.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find additional information about the naming convention in Microsoft's
    Azure Cloud at [https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming](https://docs.microsoft.com/en-us/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Azure Storage account resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to set up an Azure Blob storage service, we will need to create an
    Azure Storage account to provide a unique namespace in Azure for the assets that
    will be hosted first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Azure portal page, repeat the steps introduced previously to
    open the portal menu, and then click **Storage accounts** this time, as shown
    in *Figure 10.49*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.49 – Clicking Storage accounts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.49_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.49 – Clicking Storage accounts
  prefs: []
  type: TYPE_NORMAL
- en: 'The Storage accounts page will then open. Click the **Create** button on this
    page, as shown in *Figure 10.50*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.50 – Creating a storage account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.50_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.50 – Creating a storage account
  prefs: []
  type: TYPE_NORMAL
- en: Similar to creating a resource group, on the `unitybookchapter10` and `(Asia
    Pacific) Australia East`, respectively. The other settings can be left as their
    defaults, and then click the **Review + create** button to create the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.51 – Creating a storage account'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.51_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.51 – Creating a storage account
  prefs: []
  type: TYPE_NORMAL
- en: We can click the notifications button in the upper-right corner of the page
    to view the progress of the resource deployment. When the resource is deployed,
    we can click **Go to resource** to go to the resource page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.52 – Notifications'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.52_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.52 – Notifications
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 10.53*, a Storage account named `unitybookchapter10` is
    created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.53 – The Storage account page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.53_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.53 – The Storage account page
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have set up a Storage account resource in Azure. Next, let's
    set up Blob Storage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we mentioned at the beginning of this section, Blob Storage is a type of
    Azure Storage account, so we can find the settings for Blob Storage on the Storage
    account page we just opened. We can perform the following steps to set up Blob
    Storage:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a container, similar to a directory in the filesystem
    on our computers, to organize a group of files, and a container to organize a
    group of blobs on the Azure Cloud. Scroll down the menu on the left side of the
    Storage account page and, in the **Data storage** section, we can see four different
    storage types. Then, select **Containers**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.54 – Selecting containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.54_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.54 – Selecting containers
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the **+ Container** button, as shown in *Figure 10.55*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.55 – Clicking the + Container button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.55_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.55 – Clicking the + Container button
  prefs: []
  type: TYPE_NORMAL
- en: In the `remotedata` as the name of the container, and for simplicity, we set
    **Public access level** to **Blob** to allow anonymous access to blobs inside
    the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.56 – Creating a new container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.56_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.56 – Creating a new container
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For security purposes, you should try to manage access to blobs in a more secure
    way, for example, by using an **access key** for authorization, or by using a
    **Shared Access Signature (SAS)** to delegate access. If you're interested, you
    can find out more at [https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal](https://docs.microsoft.com/en-us/azure/storage/blobs/authorize-data-operations-portal).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up Azure Blob storage, we also need to use the Addressable
    Assets system in Unity to create asset packages and deploy them to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Addressable Assets system package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the Addressable Asset system is not available in a Unity project.
    So, we need to install the `Addressables` package first.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 10.57*, we can find this package in Unity's Package Manager
    and install it in our project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.57 – Installing the Addressables package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.57_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.57 – Installing the Addressables package
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can find the **Addressables** item in the **Window** menu
    of the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.58 – Addressables item'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.58_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.58 – Addressables item
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's build addressable content by using the Addressable Assets system.
  prefs: []
  type: TYPE_NORMAL
- en: Building addressable content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building addressable content that can be hosted on the Azure Cloud sounds complicated,
    but we can break this task down further into the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: First, mark an asset as addressable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, enable the remote catalog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, build the content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's move on to explore the first task.
  prefs: []
  type: TYPE_NORMAL
- en: Marking addressable assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Unity Editor, we can easily mark an asset as addressable. Before we mark
    an addressable asset, let's create a new asset first. We can create a new cube
    in the Scene, name it `SampleContentOnAzure`, and drag it into the **Project**
    window to create a new prefab asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, select this new prefab to open its **Inspector** window and you can see
    the **Addressable** checkbox in the window, as shown in *Figure 10.59*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.59 – Marking an addressable asset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.59_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.59 – Marking an addressable asset
  prefs: []
  type: TYPE_NORMAL
- en: By checking this checkbox, we will mark the prefab asset as addressable.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the remote catalog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before enabling the remote catalog in the Addressable Asset settings, we can
    first create a new profile that defines variables such as `RemoteLoadPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a profile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So, let''s start by creating a profile using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the toolbar, click on **Window | Asset Management | Addressables | Profiles**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.60 – Opening the Profiles window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.60_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.60 – Opening the Profiles window
  prefs: []
  type: TYPE_NORMAL
- en: In the **Addressables Profiles** window, click the **Create** button and select
    **Profile** in the drop-down menu to create a new profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.61 – Creating a new profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.61_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.61 – Creating a new profile
  prefs: []
  type: TYPE_NORMAL
- en: Then, rename this new profile to **AzureCloud** and enter the URL of the Azure
    Blob container in relation to the **RemoteLoadPath** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.62 – Setting up the new profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.62_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.62 – Setting up the new profile
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t know the URL of the Azure Blob container, you can find it on
    the container''s **Properties** page in Azure, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.63 – Container Properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.63_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.63 – Container Properties
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new addressables group
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we also need to create a new **addressables group**, which is a container
    for addressable assets and their data, and can determine whether the assets within
    the group will be hosted on a remote server or stored locally. We can then place
    assets that need to be hosted on a remote server in this new group without changing
    the local location configured in the default group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the toolbar, click on **Window | Asset Management | Addressables | Groups**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.64 – Opening the Groups window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.64_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.64 – Opening the Groups window
  prefs: []
  type: TYPE_NORMAL
- en: In the **Addressables Groups** window, click the **Create** button, then select
    **Group > Packed Assets** to create a new group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.65 – Creating a new group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.65_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.65 – Creating a new group
  prefs: []
  type: TYPE_NORMAL
- en: Rename it to **Azure Remote Group**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.66 – Azure Remote Group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.66_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.66 – Azure Remote Group
  prefs: []
  type: TYPE_NORMAL
- en: Change the active profile from **Default** to **AzureCloud** so that the Addressable
    Assets system can access the variables in **AzureCloud**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.67 – Activating the AzureCloud profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.67_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.67 – Activating the AzureCloud profile
  prefs: []
  type: TYPE_NORMAL
- en: Select the Azure remote group in the **Addressables Groups** window to open
    its **Inspector** window and set **Content Packing & Loading** using the remote
    path defined in the **AzureCloud** profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.68 – Setting up the addressables group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.68_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.68 – Setting up the addressables group
  prefs: []
  type: TYPE_NORMAL
- en: By default, the marked addressable asset will be under **Default Local Group**;
    we need to move it to the Azure remote group we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.69 – Moving the asset to Azure Remote Group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.69_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.69 – Moving the asset to Azure Remote Group
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also need to set a label, `Addressables.LoadResourceLocationsAsync`
    method with this key in C# code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.70 – Setting a label'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.70_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.70 – Setting a label
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've set up the addressables group, next, let's move on to enable
    the ability to build remote content.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Build Remote Catalog checkbox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Back to the toolbar, click on **Window | Asset Management | Addressables | Settings**
    to open the **Addressable Asset Settings** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.71 – Opening the Addressable Asset Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.71_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.71 – Opening the Addressable Asset Settings window
  prefs: []
  type: TYPE_NORMAL
- en: Scroll down the window and you will find the **Content Update** section. Then,
    check the **Build Remote Catalog** checkbox and set the **Build Path** and **Load
    Path** fields, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.72 – The Build Remote Catalog settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.72_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.72 – The Build Remote Catalog settings
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to enable the remote catalog in the Addressable Asset
    system, I think you're ready and can't wait to learn how to build the content.
    Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Building the content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s finally time to build the content with the help of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the **Addressables Groups** window, click **Play Mode Script**,
    and select **Use Existing Build (requires built groups)** in the drop-down menu,
    as shown in *Figure 10.73*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.73 – Setting up the Play mode scripts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.73_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.73 – Setting up the Play mode scripts
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides developers with three build scripts to create play mode data.
    Here, we are using **Use Existing Build** mode, which best matches the game build
    deployed. You can find more information about build scripts in the Addressable
    Asset system at [https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html](mailto:https://docs.unity3d.com/Packages/com.unity.addressables@1.9/manual/AddressableAssetsDevelopmentCycle.html).
  prefs: []
  type: TYPE_NORMAL
- en: Then, click **Build | New Build | Default Build Script** to build the content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.74 – Building the content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.74_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.74 – Building the content
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the build to complete and then you can find the build in the `ServerData`
    folder in your project root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.75 – ServerData'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.75_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.75 – ServerData
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to build addressable content in the Addressable Asset
    system, next, let's move on to deploy the content to the Azure Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying content to the Azure Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To deploy the addressable content we just built to the Azure Cloud, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **remotedata** container we created in Azure and then click
    the **Upload** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.76 – The remotedata container page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.76_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.76 – The remotedata container page
  prefs: []
  type: TYPE_NORMAL
- en: An **Upload blob** panel will then appear. Select the files you want to upload
    and click the **Upload** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.77 – Uploading the content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.77_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.77 – Uploading the content
  prefs: []
  type: TYPE_NORMAL
- en: Wait for the upload to finish and then we can see our addressable content in
    the blobs list in the **remotedata** container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.78 – The addressable content in Azure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.78_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.78 – The addressable content in Azure
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to deploy addressable content to the Azure Cloud, next,
    let's move on to exploring how to load content into your game from Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Loading addressable content from the Azure Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are using the Addressable Asset system to manage assets, loading content
    from the Azure Cloud into the game also needs to use the methods provided by the
    Addressable Asset system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script in the `Scripts` folder, name it `LoadAddressableContentFromAzureCloud`,
    and add the following to this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see in the code, we first provide `_assetKey`, whose value is the
    label of the asset we set in the previous section. Then, we call the `Addressables.LoadResourceLocationsAsync`
    method to load content and `Addressables.InstantiateAsync` to instantiate a GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GameObject, attach the `LoadAddressableContentFromAzureCloud` script
    to it, set the value of `Asset Key` to `Azure`, and then run the game in the Unity
    Editor by clicking the **Play** button. We can see that a new instance of the
    prefab is created as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.79 – Loading the addressable content from the Azure Cloud'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.79_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.79 – Loading the addressable content from the Azure Cloud
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, you learned what the Azure Blob storage service in
    the Microsoft Azure Cloud is and how to use it with Unity's Addressable Asset
    system to host and update game content. This section also brings us to the end
    of the chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've come a long way in this chapter. We started by introducing Unity's serialization
    system, discussing binary serialization, YAML serialization, and JSON serialization
    in Unity. Then we explored the assets workflow in Unity, covering important concepts
    such as GUIDs, File IDs, meta files, the `Library` folder, and how to manage the
    assets import pipeline from C# code. Next, we discussed the `Resources` folder
    and the `StreamingAssets` folder in detail, which are special folders in Unity,
    and understood that what they do can help you better develop games with Unity.
    Finally, we covered quite a bit about Azure Blob storage and Unity's Addressable
    Asset system, from how to create an Azure Blob storage service in the Azure Cloud
    to how to load the addressable content from Azure into a Unity project. It's been
    an amazing journey!
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge you have acquired in this chapter will help you choose the appropriate
    serialization mode in Unity according to your needs, manage assets reasonably,
    and use the Azure Cloud to achieve incremental updates of game content.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue this wonderful journey to explore how
    to create games with Unity, Microsoft Game Dev, and the Azure Cloud.
  prefs: []
  type: TYPE_NORMAL
