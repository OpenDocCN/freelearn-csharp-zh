<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>8 Dependency Injection</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="9">8 Dependency Injection</h1>

<h2 data-number="9.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file39.png" style="width:10em"/></p>
<p>This chapter explores the ASP.NET Core <strong>Dependency Injection</strong> (<strong>DI</strong>) system, how to leverage it efficiently, and its limits and capabilities.We learn to compose objects using DI and delve into the Inversion of Control (IoC) principle. As we traverse the landscape of the built-in DI container, we explore its features and potential uses.Beyond practical examples, we lay down the conceptual foundation of Dependency Injection to understand its purpose, its benefits, and the problems it solves and to lay down the ground for the rest of the book as we rely heavily on DI.We then return to the first three Gang of Four (GoF) design patterns we encountered, but this time, through the lens of Dependency Injection. By refactoring these patterns using DI, we gain a more holistic understanding of how this powerful design tool influences the structure and flexibility of our software.Dependency Injection is a cornerstone in your path toward mastering modern application design and its transformative role in developing efficient, adaptable, testable, and maintainable software.In this chapter, we cover the following topics:</p>
<ul>
<li>What is dependency injection?</li>
<li>Revisiting the Strategy pattern</li>
<li>Understanding guard clauses</li>
<li>Revisiting the Singleton pattern</li>
<li>Understanding the Service Locator pattern</li>
<li>Revisiting the Factory pattern</li>
</ul>


<h2 data-number="9.2">What is dependency injection?</h2>
<p>DI is a way to apply the <strong>Inversion of Control</strong> (<strong>IoC</strong>) principle. IoC is a broader version of the dependency inversion principle (the <em>D</em> in SOLID).The idea behind DI is to move the creation of dependencies from the objects themselves to the <strong>composition root</strong>. That way, we can delegate the management of dependencies to an <strong>IoC container</strong>, which does the heavy lifting.</p>
<blockquote>
<p>An IoC container and a <strong>DI container</strong> are the same thing—they’re just different words people use. I use both interchangeably in real life, but I stick to IoC container in the book because it seems more accurate than DI container.</p>
<blockquote>
<p>IoC is the concept (the principle), while DI is a way of inverting the flow of control (applying IoC). For example, you apply the IoC principle (inverting the flow) by injecting dependencies at runtime (doing DI) using a container. Feel free to use any or both.</p>
</blockquote>
</blockquote>
<p>Next, we define the composition root.</p>

<h3 data-number="9.2.1">The composition root</h3>
<p>A critical concept behind DI is the composition root. The composition root is where we tell the container about our dependencies and their expected lifetime: where we compose our dependency trees. The composition root should be as close to the program's starting point as possible, so from ASP.NET Core 6 onward, the composition root is in the <code>Program.cs</code> file. In the previous versions, it was in the <code>Program</code> or <code>Startup</code> classes.Next, we explore how to leverage DI to create highly adaptable systems.</p>


<h3 data-number="9.2.2">Striving for adaptability</h3>
<p>To achieve a high degree of flexibility with DI, we can apply the following formula, driven by the SOLID principles:Object <code>A</code> should not know about object <code>B</code> that it is using. Instead, <code>A</code> should use an interface, <code>I</code>, implemented by <code>B</code>, and <code>B</code> should be resolved and injected at runtime.Let’s decompose this:</p>
<ul>
<li>Object <code>A</code> should depend on interface <code>I</code> instead of concrete type <code>B</code>.</li>
<li>Instance <code>B</code>, injected into <code>A</code>, should be resolved by the IoC container at runtime.</li>
<li><code>A</code> should not be aware of the existence of <code>B</code>.</li>
<li><code>A</code> should not control the lifetime of <code>B</code>.</li>
</ul>
<blockquote>
<p>We can also inject objects directly without passing by an interface. It all depends on what we inject, in what context, and our requirements. We tackle many use cases throughout the book to help you understand DI.</p>
</blockquote>
<p>Next, we translate this equation into an analogy that helps explain the reasons to use a container.</p>


<h3 data-number="9.2.3">Understanding the use of the IoC container</h3>
<p>To better understand the use of the IoC container and to create an image around the previous adaptability concept, let’s start with a LEGO® analogy where IoC is the equivalent of drawing a plan to build a LEGO®castle:</p>
<ol>
<li>We draw the plan</li>
<li>We gather the blocks</li>
<li>We press the start button on a hypothetical robot builder</li>
<li>The robot assembles the blocks by following our plan</li>
<li>The castle is complete</li>
</ol>
<p>By following this logic, we can create a new 4x4 block with a unicorn painted on its side (concrete type), update the plan (composition root), and then press the restart button to rebuild the castle with that new block inserted into it, replacing the old one without affecting the structural integrity of the castle (program). As long as we respect the 4x4 block contract (interface), everything is updatable without impacting the rest of the castle, leading to great flexibility.Following that idea, if we need to manage every single LEGO® block one by one, it would quickly become incredibly complex! Therefore, managing all dependencies by hand in a project would be super tedious and error-prone, even in the smallest program. This situation is where an IoC container (the hypothetical robot builder) comes into play.</p>


<h3 data-number="9.2.4">The role of an IoC container</h3>
<p>An IoC container manages objects for us. We configure it, and then, when we ask for a service, the container resolves and injects it. On top of that, the container manages the lifetime of dependencies, leaving our classes to do only one thing, the job we designed them to do. No more need to think about their dependencies!The bottom line is that an IoC container is a DI framework that does the auto-wiring for us. We can conceptualize Dependency Injection as follows:</p>
<ol>
<li>The <em>consumer</em> of a dependency states its needs about one or more dependencies (contracts).</li>
<li>The IoC container injects that dependency (implementation) upon creating the <em>consumer</em>, fulfilling its needs at runtime.</li>
</ol>
<p>Next, we explore an code smell that applying Dependency Injection helps us avoid.</p>


<h3 data-number="9.2.5">Code smell – Control Freak</h3>
<p>Control freak is a code smell and even an anti-pattern that forbids us from using the <code>new</code> keyword. Yes, using the <code>new</code> keyword is the code smell! The following code is wrong and can’t leverage DI:</p>
<div><pre><code>namespace CompositionRoot.ControlFreak;
public class Consumer
{
    public void Do()
    {
        var dependency = new Dependency();
        dependency.Operation();
    }
}
public class Dependency
{
    public void Operation()
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<p>The highlighted line shows the anti-pattern in action. To enable the Consumer class to use dependency injection, we could update it like the following:</p>
<div><pre><code>public class Consumer
{
    private readonly Dependency _dependency;
    public DIEnabledConsumer(Dependency dependency)
    {
        _dependency = dependency;
    }
    public void Do()
    {
        _dependency.Operation();
    }
}</code></pre>
</div>
<p>The preceding code removes the new keyword and is now open for modification. The highlighted lines represent the constructor injection pattern we explore subsequently in this chapter.Nevertheless, do not ban the <code>new</code> keyword just yet. Instead, every time you use it, ask yourself whether the object you instantiated using the <code>new</code> keyword is a dependency that could be managed by the container and injected instead.To help with that, I borrowed two terms from Mark Seemann’s book <em>Dependency Injection in .NET</em>; the name <em>Control Freak</em> also comes from that book. He describes the following two categories of dependencies:</p>
<ul>
<li>Stable dependencies</li>
<li>Volatile dependencies</li>
</ul>
<p>Next is my take on defining them.</p>

<h4 data-number="9.2.5.1">Stable dependencies</h4>
<p><strong>Stable dependencies</strong> should not break our application when a new version is released. They should use deterministic algorithms (input <code>X</code> should always produce output <code>Y</code>), and you should not expect to change them with something else in the future.</p>
<blockquote>
<p>Most data structures devoided of behaviors, like Data Transfer Objects (DTOs), fall into this category. You can also consider the .NET BCL as stable dependencies.</p>
</blockquote>
<p>We can still instantiate objects using the <code>new</code> keyword when they fall into this category because the dependencies are stable and unlikely to break anything if they change.Next, we look at their counterpart.</p>


<h4 data-number="9.2.5.2">Volatile dependencies</h4>
<p><strong>Volatile dependencies</strong> can change at runtime, like extendable elements with contextual behaviors. They may also be likely to change for various reasons like new features development.</p>
<blockquote>
<p>Most classes we create, such as data access and business logic code, are volatile dependencies.</p>
</blockquote>
<p>The primary way to break the tight coupling between classes is to rely on interfaces and DI and no longer instantiate those volatile dependencies using the <code>new</code> keyword. Volatile dependencies are why dependency injection is key to building flexible, testable, and maintainable software.</p>


<h4 data-number="9.2.5.3">Conclusion</h4>
<p>To conclude this interlude: don’t be a control freak anymore; those days are behind you!</p>
<blockquote>
<p>When in doubt, inject the dependency instead of using the <code>new</code> keyword.</p>
</blockquote>
<p>Next, we explore the available lifetimes we can attribute to our volatile dependencies.</p>



<h3 data-number="9.2.6">Object lifetime</h3>
<p>Now that we understand we should no longer use the <code>new</code> keyword, we need a way to create those classes. From now on, the IoC container will play that role and manage object instantiation and their lifetime for us.</p>

<h4 data-number="9.2.6.1">What’s an object's lifetime?</h4>
<p>When we create an instance manually, using the <code>new</code> keyword, we create a hold on that object; we know when we create it and when its life ends. That’s the lifetime of the object.Of course, using the <code>new</code> keyword leaves no chance to control these objects from the outside, enhance them, intercept them, or swap them for another implementation—as covered in the preceding <em>Code smell – Control Freak</em> section.</p>


<h4 data-number="9.2.6.2">.NET object lifetime</h4>
<p>With dependency injection, we need to forget about controlling objects and start to think about using dependencies, or more explicitly, depending on their interfaces. In ASP.NET Core, there are three possible lifetimes to choose from:</p>
<table>
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Lifetime</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td>Transient</td>
<td>The container creates a new instance every time.</td>
</tr>
<tr class="odd">
<td>Scoped</td>
<td><p>The container creates an instance per HTTP request and reuses it.</p>
<p>In some rare cases, we can also create custom scopes.</p></td>
</tr>
<tr class="even">
<td>Singleton</td>
<td>The container creates a single instance of that dependency and always reuses that unique object.</td>
</tr>
</tbody>
</table>
Table 8.1: objects lifetime description
<p>We can now manage our volatile dependencies using one of those three scopes. Here are some questions to help you choose:</p>
<ul>
<li>Do I need a single instance of my dependency? Yes? Use the <strong>singleton</strong> lifetime.</li>
<li>Do I need a single instance of my dependency shared over an HTTP request? Yes? Use the <strong>scoped</strong> lifetime.</li>
<li>Do I need a new instance of my dependency every time? Yes? Use the <strong>transient</strong> lifetime.</li>
</ul>
<blockquote>
<p>A general approach to object lifetime is to design the components to be <em>singletons</em>. When impossible, we go for <em>scoped</em>. When <em>scoped</em> is also impossible, go for <em>transient</em>. This way, we maximize instance reuse, lower the overhead of creating objects, lower the memory cost of keeping those objects in memory, and lower the amount of garbage collection needed to remove unused instances.</p>
<blockquote>
<p>For example, we can pick <em>singleton</em> mindlessly for stateless objects, which are the easiest to maintain and less likely to break.</p>
</blockquote>
<blockquote>
<p>For stateful objects, where multiple consumers use the same instance, we must ensure the object is thread-safe if the lifetime is <em>singleton</em> or <em>scoped</em> because multiple consumers could try to access it simultaneously.</p>
</blockquote>
<blockquote>
<p>One essential aspect to consider when choosing a lifetime is the consumers of stateful objects. For example, if we load data related to the current user, we must ensure that data do not leak to other users. To do so, we can define the lifetime of that object to <em>scoped</em>, which is limited to a single HTTP request. If we don’t want to reuse that state between multiple consumers, we can choose a <em>transient</em> lifetime to ensure every consumer gets their own instance.</p>
</blockquote>
</blockquote>
<p>How does that translate into code? .NET offers multiple extension methods to help us configure the lifetimes of our objects, like <code>AddTransient</code>, <code>AddScoped</code>, and <code>AddSingleton</code>, which explicitly state their lifetimes.</p>
<blockquote>
<p>We use the built-in container throughout the book with many of its registration methods, so you should grow familiar with it very quickly. It has good discoverability, so you can explore the possibilities using IntelliSense while writing code or reading the documentation.</p>
</blockquote>
<p>Next, we use those methods and explore how to register dependencies with the container.</p>



<h3 data-number="9.2.7">Registering our dependencies</h3>
<p>In ASP.NET Core, we register our dependencies in the <code>Program.cs</code> file, which represents the composition root. Since the minimal hosting model, the <code>WebApplicationBuilder</code> exposes the <code>Services</code> property we use to add our dependencies to the container. Afterward, .NET creates the container when it builds the <code>WebApplication</code> instance.Next is a minimal <code>Program.cs</code> file depicting this concept:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
// Register dependencies
var app = builder.Build();
// The IoC container is now available
app.Run();</code></pre>
</div>
<p>Then, we use the <code>builder.Services</code> property to register our dependencies in that <code>IServiceCollection</code> implementation. Here’s an example of registering some dependencies:</p>
<div><pre><code>builder.Services.AddSingleton&lt;Dependency1&gt;();
builder.Services.AddSingleton&lt;Dependency2&gt;();
builder.Services.AddSingleton&lt;Dependency3&gt;();</code></pre>
</div>
<p>The preceding code registers the dependencies using the singleton lifetime, so we get the same instance each time we request one.</p>
<blockquote>
<p>Remember to compose the program in the composition root. That removes the need for those pesky <code>new</code> keywords spread around your code base and all the tight coupling that come with them. Moreover, it centralizes the application’s composition into that location, creating the plan to assemble the LEGO® blocks.</p>
</blockquote>
<p>As you may be thinking right now, that can lead to a lot of registration statements in a single location, and you are correct; maintaining such a composition root would be a challenge in almost any application. To address this concern, we introduce an elegant way to encapsulate the registration code next, ensuring it remains manageable.</p>


<h3 data-number="9.2.8">Registering your features elegantly</h3>
<p>As we've just discovered, while we should register dependencies in the composition root, we can also arrange our registration code in a structured manner. For example, we can break down our application's composition into several methods or classes and invoke them from our composition root. Another strategy could be to use an auto-discovery system to automate the registration of certain services.</p>
<blockquote>
<p>The critical part is to centralize the program composition in one place.</p>
</blockquote>
<p>A common pattern in ASP.NET Core is having special methods like <code>Add[Feature name]</code>. These methods register their dependencies, letting us add a group of dependencies with just one method call. This pattern is convenient for breaking down program composition into smaller, easier-to-handle parts, like individual features. This also makes the composition root more readable.</p>
<blockquote>
<p>A feature is the correct size as long as it stays cohesive. If your feature becomes too big, does too many things, or starts to share dependencies with other features, it may be time for a redesign before losing control over it. That’s usually a good indicator of undesired coupling.</p>
</blockquote>
<p>To implement this pattern, we use extension methods, making it trivial. Here’s a guide:</p>
<ol>
<li>Create a static class named <code>[subject]Extensions</code> in the <code>Microsoft.Extensions.DependencyInjection</code> namespace.</li>
<li>Create an extension method that returns the <code>IServiceCollection</code> interface, which allows method calls to be chained.</li>
</ol>
<blockquote>
<p>According to Microsoft's recommendation, we should create the class in the same namespace as the element we extend. In our case, the <code>IServiceCollection</code> interface lives in the <code>Microsoft.Extensions.DependencyInjection</code> namespace.</p>
</blockquote>
<p>Of course, this is not mandatory, and we can adapt this process to our needs. For example, we can define the class in another namespace if we want consumers to add a <code>using</code> statement implicitly. We can also return something else when the registration process can continue beyond that first method, like a builder interface.</p>
<blockquote>
<p>Builder interfaces are used to configure more complex features, like ASP.NET Core MVC. For example, the <code>AddControllers</code> extension method returns an <code>IMvcBuilder</code> interface that contains a <code>PartManager</code> property. Moreover, some extension methods target the <code>IMvcBuilder</code> interface, allowing further configuration of the feature by requiring its registration first; that is, you can’t configure <code>IMvcBuilder</code> before calling <code>AddControllers</code>. You can also design your features to leverage that pattern when needed.</p>
</blockquote>
<p>Let’s explore a demo.</p>

<h4 data-number="9.2.8.1">Project – Registering the Demo Feature</h4>
<p>Let’s explore registering the dependencies of the Demo Feature. That feature contains the following code:</p>
<div><pre><code>namespace CompositionRoot.DemoFeature;
public class MyFeature
{
    private readonly IMyFeatureDependency _myFeatureDependency;
    public MyFeature(IMyFeatureDependency myFeatureDependency)
    {
        _myFeatureDependency = myFeatureDependency;
    }
    public void Operation()
    {
        // use _myFeatureDependency
    }
}
public interface IMyFeatureDependency { }
public class MyFeatureDependency : IMyFeatureDependency { }</code></pre>
</div>
<p>As we can see, there is nothing complex but two empty classes and an interface. Remember that we are exploring the registration of dependencies, not what to do with them or what they can do—yet.Now, we want the container to serve an instance of the <code>MyFeatureDependency</code> class when a dependency requests the <code>IMyFeatureDependency</code> interface as the <code>MyFeature</code> class does. We want a singleton lifetime.To achieve this, in the <code>Program.cs</code> file, we can write the following code:</p>
<div><pre><code>builder.Services.AddSingleton&lt;MyFeature&gt;();
builder.Services.AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;();</code></pre>
</div>
<p>We can also chain the two method calls instead:</p>
<div><pre><code>builder.Services
    .AddSingleton&lt;MyFeature&gt;()
    .AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;()
;</code></pre>
</div>
<p>However, this is not yet elegant. What we want to achieve is this:</p>
<div><pre><code>builder.Services.AddDemoFeature();</code></pre>
</div>
<p>To build that registration method, we can write the following extension method:</p>
<div><pre><code>using CompositionRoot.DemoFeature;
namespace Microsoft.Extensions.DependencyInjection;
public static class DemoFeatureExtensions
{
    public static IServiceCollection AddDemoFeature(this IServiceCollection services)
    {
        return services
            .AddSingleton&lt;MyFeature&gt;()
            .AddSingleton&lt;IMyFeatureDependency, MyFeatureDependency&gt;()
        ;
    }
}</code></pre>
</div>
<p>As highlighted, the registration is the same but uses the <code>services</code> parameter, which is the extended type, instead of the <code>builder.Services</code> (<code>builder</code> does not exist in that class, yet the <code>services</code> parameter is the same object as the <code>builder.Services</code> property).If you are unfamiliar with extension methods, they come in handy for extending existing classes, like we just did. Besides having a static method inside a static class, the <code>this</code> keyword next to the first parameter determines whether it is an extension method.For example, we can build sophisticated libraries that are easy to use with a set of extension methods. Think <code>System.Linq</code> for such a system.Now that we learned the basics of dependency injection, there is one last thing to cover before revisiting the Strategy design pattern.</p>



<h3 data-number="9.2.9">Using external IoC containers</h3>
<p>ASP.NET Core provides an extensible built-in IoC container out of the box. It is not the most powerful IoC container because it lacks some advanced features, but it does the job for most applications.Rest assured; we can change it to another one if need be. You might also want to do that if you are used to another IoC container and want to stick to it.Here’s the strategy I recommend:</p>
<ol>
<li>Use the built-in container, as per Microsoft's recommendation.</li>
<li>When you can’t achieve something with it, look at your design and see if you can redesign your feature to work with the built-in container and simplify your design.</li>
<li>If it is impossible to achieve your goal, see if extending the default container using an existing library or coding the feature yourself is possible.</li>
<li>If it is still impossible, explore swapping it for another IoC container.</li>
</ol>
<p>Assuming the container supports it, it is super simple to swap. The third-party container must implement the <code>IServiceProviderFactory&lt;TContainerBuilder&gt;</code> interface. Then, in the <code>Program.cs</code> file, we must register that factory using the <code>UseServiceProviderFactory&lt;TContainerBuilder&gt;</code> method like this:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Host.UseServiceProviderFactory&lt;ContainerBuilder&gt;(new ContainerBuilderFactory());</code></pre>
</div>
<p>In this case, the <code>ContainerBuilder</code> and <code>ContainerBuilderFactory</code> classes are just wrappers around ASP.NET Core, but your third-party container of choice should provide you with those types. I suggest you visit their documentation to know more.Once that factory is registered, we can configure the container using the <code>ConfigureContainer&lt;TContainerBuilder&gt;</code> method and register our dependencies as usual, like this:</p>
<div><pre><code>builder.Host.ConfigureContainer&lt;ContainerBuilder&gt;((context, builder) =&gt;
{
    builder.Services.AddSingleton&lt;Dependency1&gt;();
    builder.Services.AddSingleton&lt;Dependency2&gt;();
    builder.Services.AddSingleton&lt;Dependency3&gt;();
});</code></pre>
</div>
<p>That’s the only difference; the rest of the <code>Program.cs</code> file remains the same.As I sense you don’t feel like implementing your own IoC container, multiple third-party integrations already exist. Here is a non-exhaustive list taken from the official documentation:</p>
<ul>
<li>Autofac</li>
<li>DryIoc</li>
<li>Grace</li>
<li>LightInject</li>
<li>Lamar</li>
<li>Stashbox</li>
<li>Simple Injector</li>
</ul>
<p>On top of replacing the container entirely, some libraries extend the default container and add functionalities to it. We explore this option in <em>Chapter 11</em>, <em>Structural Patterns</em>.Now that we have covered most of the theory, we revisit the Strategy pattern as the primary tool to compose our applications and add flexibility to our systems.</p>



<h2 data-number="9.3">Revisiting the Strategy pattern</h2>
<p>In this section, we leverage the Strategy pattern to compose complex object trees and use DI to dynamically create those instances without using the <code>new</code> keyword, moving away from being control freaks and toward writing DI-ready code.The Strategy pattern is a behavioral design pattern we can use to compose object trees at runtime, allowing extra flexibility and control over objects’ behavior. Composing our objects using the Strategy pattern makes our classes smaller, easier to test and maintain, and puts us on the SOLID path.From now on, we want to compose objects and lower the amount of inheritance to a minimum. We call that principle <strong>composition over inheritance</strong>. The goal is to inject dependencies (composition) into the current class instead of depending on base class features (inheritance). Additionally, this approach enables us to pull out behaviors and place them in separate classes, adhering to the Single Responsibility Principle (SRP) and Interface Segregation Principle (ISP). We can reuse these behaviors in one or more different classes through their interface, embodying the Dependency Inversion Principle (DIP). This strategy promotes code reuse and composition.The following list covers the most popular ways of injecting dependencies into objects, allowing us to control their behaviors from the outside by composing our objects:</p>
<ul>
<li>Constructor injection</li>
<li>Property injection</li>
<li>Method injection</li>
</ul>
<blockquote>
<p>We can also get dependencies directly from the container. This is known as the Service Locator (anti-)pattern. We explore the Service Locator pattern later in this chapter.</p>
</blockquote>
<p>Let’s look at some theory and then jump into the code to see DI in action.</p>

<h3 data-number="9.3.1">Constructor injection</h3>
<p><strong>Constructor injection</strong> consists of injecting dependencies into the constructor as parameters. This is the most popular and preferred technique by far. Constructor injection is useful for injecting required dependencies; you can add null checks to ensure that, also known as the guard clause (see the <em>Adding a guard clause</em> section).</p>


<h3 data-number="9.3.2">Property injection</h3>
<p>The built-in IoC container does not support <strong>property injection</strong> out of the box. The concept is to inject <strong>optional dependencies</strong> into properties. Most of the time, you want to avoid doing this because property injection leads to optional dependencies, leading to nullable properties, more null checks, and often avoidable code complexity. So when we think about it, it is good that ASP.NET Core left this one out of the built-in container.You can usually remove the property injection requirements by reworking your design, leading to a better design. If you cannot avoid using property injection, use a third-party container or find a way to build the dependency tree yourself (maybe leveraging one of the Factory patterns).Nevertheless, from a high-level view, the container would do something like this:</p>
<ol>
<li>Create a new instance of the class and inject all required dependencies into the constructor.</li>
<li>Find extension points by scanning properties (this could be attributes, contextual bindings, or something else).</li>
<li>For each extension point, inject (set) a dependency, leaving unconfigured properties untouched, hence its definition of an optional dependency.</li>
</ol>
<p>There are a couple of exceptions to the previous statement regarding the lack of support:</p>
<ul>
<li>Razor components (Blazor) support property injection using the <code>[Inject]</code> attribute.</li>
<li>Razor contains the <code>@inject</code> directive, which generates a property to hold a dependency (ASP.NET Core manages to inject it).</li>
</ul>
<p>We can’t call that property injection per se because they are not optional but required, and the <code>@inject</code> directive is more about generating code than doing DI. They are more about an internal workaround than “real” property injection. That is as close as .NET gets from property injection.</p>
<blockquote>
<p>I recommend aiming for constructor injection instead. Not having property injection should not cause you any problems. Often, our need for property injection stems from less-than-optimal design choices, whether from our design strategies or a framework we're utilizing.</p>
</blockquote>
<p>Next, we look at method injection.</p>


<h3 data-number="9.3.3">Method injection</h3>
<p>ASP.NET Core supports method injection only at a few locations, such as in a controller’s actions (methods), the <code>Startup</code> class (if you are using the pre-.NET 6 hosting model), and the middleware’s <code>Invoke</code> or <code>InvokeAsync</code> methods. We cannot liberally use method injection in our classes without some work on our part.Method injection is also used to inject <strong>optional dependencies</strong> into classes. We can also validate those at runtime using null checks or any other required logic.</p>
<blockquote>
<p><strong>I recommend aiming for constructor injection whenever you can</strong>. We should only resort to method injection when it's our sole option or when it brings added value to our design.</p>
<blockquote>
<p>For example, in a controller, injecting a transient service in the only action that needs it instead of using constructor injection could save a lot of useless object instantiation and, by doing so, increase performance (less instantiation and less garbage collection). This can also lower the number of class-level dependencies a single class has.</p>
</blockquote>
</blockquote>
<p>Manually injecting a dependency in a method as an argument is valid. Here’s an example, starting with the classes:</p>
<div><pre><code>namespace CompositionRoot.ManualMethodInjection;
public class Subject
{
    public int Operation(Context context)
    {
        // ...
        return context.Number;
    }
}
public class Context
{
    public required int Number { get; init; }
}</code></pre>
</div>
<p>The preceding code represents the <code>Subject</code> class that consumes an instance of the <code>Context</code> from its <code>Operation</code> method. It then returns the value of its <code>Number</code> property.</p>
<blockquote>
<p>This example follows a similar pattern to injecting an <code>HttpContext</code> into an endpoint delegate. In that case, the <code>HttpContext</code> represents the current HTTP request. In our case, the <code>Context</code> contains only an arbitrary number we use in the consuming code next.</p>
</blockquote>
<p>To test that our code does as it should, we can write the following test:</p>
<div><pre><code>[Fact]
public void Should_return_the_value_of_the_Context_Number_property()
{
    // Arrange
    var subject = new Subject();
    var context = new Context { Number = 44 };
    // Act
    var result = subject.Operation(context);
    // Assert
    Assert.Equal(44, result);
}</code></pre>
</div>
<p>When we run the test, it works. We successfully injected the <code>context</code> into the <code>subject</code>. Now to simulate a more complex system, let’s have a look at a theory that does the same more dynamically:</p>
<div><pre><code>[Theory]
[MemberData(nameof(GetData))]
public void Showcase_manual_method_injection(
    Subject subject, Context context, int expectedNumber)
{
    // Manually injecting the context into the
    // Operation method of the subject.
    var number = subject.Operation(context);
    // Validate that we got the specified context.
    Assert.Equal(expectedNumber, number);
}</code></pre>
</div>
<p>The preceding code showcases the same concept, but xUnit injects the dependencies into the method, which is closer to what would happen in a real program. Remember, we want to remove the <code>new</code> keywords from our life!</p>
<blockquote>
<p>The rest of the implementation is not important. I only pieced the simulation together to showcase this scenario. One interesting detail is that the <code>Subject</code> is always the same (singleton) while the <code>Context</code> is always different (transient), leading to a different outcome every time (<code>Context { Number = 0 }</code>, <code>Context { Number = 1 }</code>, and <code>Context { Number = 2 }</code>).</p>
</blockquote>
<p>Having explored how to inject dependencies, we are ready to roll up our sleeves and dive into hands-on coding.</p>


<h3 data-number="9.3.4">Project – Strategy</h3>
<p>In the Strategy project, we delve into various methods of injecting dependencies, transitioning from the Control Freak approach to a SOLID one. Through this exploration, we evaluate the advantages and drawbacks of each technique.The project takes the form of a travel agency's location API, initially returning only hardcoded cities. We've implemented the same endpoint five times across different controllers to facilitate comparison and trace the progression. Each controller comes in pair except for one. The pairs comprise a base controller that uses an in-memory service (dev) and an updated controller that simulates a SQL database (production). Here’s the breakdown of each controller:</p>
<ul>
<li>The <code>ControlFreakLocationsController</code> instantiates the <code>InMemoryLocationService</code> class using the <code>new</code> keyword.</li>
<li>The <code>ControlFreakUpdatedLocationsController</code> instantiates the <code>SqlLocationService</code> class and its dependency using the <code>new</code> keyword.</li>
<li>The <code>InjectImplementationLocationsController</code> leverages constructor injection to get an instance of the <code>InMemoryLocationService</code> class from the container.</li>
<li>The <code>InjectImplementationUpdatedLocationsController</code> leverages constructor injection to get an instance of the <code>SqlLocationService </code>class from the container.</li>
<li>The <code>InjectAbstractionLocationsController</code> leverages dependency injection and interfaces to let its consumers change its behavior at runtime.</li>
</ul>
<p>The controllers share the same building blocks; let’s start there.</p>

<h4 data-number="9.3.4.1">Shared building blocks</h4>
<p>The <code>Location</code> data structure is the following:</p>
<div><pre><code>namespace Strategy.Models;
public record class Location(int Id, string Name, string CountryCode);</code></pre>
</div>
<p>The <code>LocationSummary</code> DTO returned by the controller is the following:</p>
<div><pre><code>namespace Strategy.Controllers;
public record class LocationSummary(int Id, string Name);</code></pre>
</div>
<p>The service interface is the following and has only one method that returns one or more <code>Location</code> objects:</p>
<div><pre><code>using Strategy.Models;
namespace Strategy.Services;
public interface ILocationService
{
    Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken);
}</code></pre>
</div>
<p>The two implementations of this interface are an in-memory version to use when developing and a SQL version to use when deploying (let’s call this production to keep it simple).The in-memory service returns a predefined list of cities:</p>
<div><pre><code>using Strategy.Models;
namespace Strategy.Services;
public class InMemoryLocationService : ILocationService
{
    public async Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken)
    {
        await Task.Delay(Random.Shared.Next(1, 100), cancellationToken);
        return new Location[] {
            new Location(1, "Paris", "FR"),
            new Location(2, "New York City", "US"),
            new Location(3, "Tokyo", "JP"),
            new Location(4, "Rome", "IT"),
            new Location(5, "Sydney", "AU"),
            new Location(6, "Cape Town", "ZA"),
            new Location(7, "Istanbul", "TR"),
            new Location(8, "Bangkok", "TH"),
            new Location(9, "Rio de Janeiro", "BR"),
            new Location(10, "Toronto", "CA"),
        };
    }
}</code></pre>
</div>
<p>The SQL implementation uses an <code>IDatabase</code> interface to access the data:</p>
<div><pre><code>using Strategy.Data;
using Strategy.Models;
namespace Strategy.Services;
public class SqlLocationService : ILocationService
{
    private readonly IDatabase _database;
    public SqlLocationService(IDatabase database) {
        _database = database;
    }
    public Task&lt;IEnumerable&lt;Location&gt;&gt; FetchAllAsync(CancellationToken cancellationToken) {
        return _database.ReadManyAsync&lt;Location&gt;(
            "SELECT * FROM Location",
            cancellationToken
        );
    }
}</code></pre>
</div>
<p>That database access interface is simply the following:</p>
<div><pre><code>namespace Strategy.Data;
public interface IDatabase
{
    Task&lt;IEnumerable&lt;T&gt;&gt; ReadManyAsync&lt;T&gt;(string sql, CancellationToken cancellationToken);
}</code></pre>
</div>
<p>In the project itself, the <code>IDatabase</code> interface has only the <code>NotImplementedDatabase</code> implementation, which throws a <code>NotImplementedException</code> when its <code>ReadManyAsync</code> method is called:</p>
<div><pre><code>namespace Strategy.Data;
public class NotImplementedDatabase : IDatabase
{
    public Task&lt;IEnumerable&lt;T&gt;&gt; ReadManyAsync&lt;T&gt;(string sql, CancellationToken cancellationToken)
        =&gt; throw new NotImplementedException();
}</code></pre>
</div>
<blockquote>
<p>Since the goal is not learning database access, I mocked that part in a test case in a xUnit test using the controller and the <code>SqlLocationService</code> class.</p>
</blockquote>
<p>With those shared pieces, we can start with the first two controllers.</p>


<h4 data-number="9.3.4.2">Control Freak controllers</h4>
<p>This first version of the code showcases the lack of flexibility that creating dependencies using the <code>new</code> keyword brings when the time to update the application arises. Here’s the initial controller that leverages an in-memory collection:</p>
<div><pre><code>using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class ControlFreakLocationsController : ControllerBase
{
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locationService = new InMemoryLocationService();
        var locations = await locationService
            .FetchAllAsync(cancellationToken);
        return locations
            .Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</code></pre>
</div>
<p>Executing this code works and returns the <code>LocationSummary</code> equivalent of the <code>Location</code> objects returned by the <code>FetchAllAsync</code> method of the <code>InMemoryLocationService</code> class. However, changing the <code>InMemoryLocationService</code> to a <code>SqlLocationService</code> is impossible without changing the code like this:</p>
<div><pre><code>public class ControlFreakUpdatedLocationsController : ControllerBase
{
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var database = new NotImplementedDatabase();
        var locationService = new SqlLocationService(database);
        var locations = await locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</code></pre>
</div>
<p>The changes are highlighted in the two code blocks. We could also create an if statement to load one or the other conditionally, but exporting this to a whole system makes a lot of duplication.<strong>Advantages:</strong></p>
<ul>
<li>It is easy to understand the code and what objects the controller uses.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>The controller is tightly coupled with its dependencies, leading to a lack of flexibility.</li>
<li>Going from <code>InMemoryLocationService</code> to <code>SqlLocationService</code> requires updating the code.</li>
</ul>
<p>Let’s improve on that design next with the next controller pair.</p>


<h4 data-number="9.3.4.3">Injecting an implementation in the controllers</h4>
<p>This second version of the codebase improves flexibility by leveraging dependency injection. In the following controller, we inject the <code>InMemoryLocationService</code> class in its constructor:</p>
<div><pre><code>using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class InjectImplementationLocationsController : ControllerBase
{
    private readonly InMemoryLocationService _locationService;
    public InjectImplementationLocationsController(
        InMemoryLocationService locationService)
    {
        _locationService = locationService;
    }
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locations = await _locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</code></pre>
</div>
<p>Assuming the <strong>InMemoryLocationService</strong> class is registered with the container, running this code would yield the same result as the Control Freak version and return the in-memory cities.</p>
<blockquote>
<p>To register a class with the container, we can do the following:</p>
</blockquote>
<pre><code>builder.Services.AddSingleton&lt;InMemoryLocationService&gt;();</code></pre>
<p>Unfortunately, to change that service for the <code>SqlLocationService</code>, we need to change the code again. This time, however, we must only change the constructor injection code like this:</p>
<div><pre><code>public class InjectImplementationUpdatedLocationsController : ControllerBase
{
    private readonly SqlLocationService _locationService;
    public InjectImplementationUpdatedLocationsController(SqlLocationService locationService)
    {
        _locationService = locationService;
    }
    // ...
}</code></pre>
</div>
<p>This is yet another not ideal outcome.<strong>Advantages:</strong></p>
<ul>
<li>It is easy to understand the code and what objects the controller uses.</li>
<li>Using constructor injection allows changing the dependency in one place, and all the methods get it (assuming we have more than one method).</li>
<li>We can inject subclasses without changing the code.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>The controller is tightly coupled with its dependencies, leading to a lack of flexibility.</li>
<li>Going from <code>InMemoryLocationService</code> to <code>SqlLocationService</code> requires updating the code.</li>
</ul>
<p>We are getting there but still have a last step to make that controller flexible.</p>


<h4 data-number="9.3.4.4">Injecting an abstraction in the controller</h4>
<p>In this last controller, we leverage the SOLID principles, constructor injection, and, inherently, the Strategy pattern to build a controller that we can change from the outside. All we have to do to make the code flexible is inject the interface instead of its implementation, like this:</p>
<div><pre><code>using Microsoft.AspNetCore.Mvc;
using Strategy.Services;
namespace Strategy.Controllers;
[Route("travel/[controller]")]
[ApiController]
public class InjectAbstractionLocationsController : ControllerBase
{
    private readonly ILocationService _locationService;
    public InjectAbstractionLocationsController(ILocationService locationService)
    {
        _locationService = locationService;
    }
    [HttpGet]
    public async Task&lt;IEnumerable&lt;LocationSummary&gt;&gt; GetAsync(CancellationToken cancellationToken)
    {
        var locations = await _locationService.FetchAllAsync(cancellationToken);
        return locations.Select(l =&gt; new LocationSummary(l.Id, l.Name));
    }
}</code></pre>
</div>
<p>The highlighted lines showcase the changes. Injecting the <code>ILocationService</code> interface lets us control if we inject an instance of the <code>InMemoryLocationService</code> class, the <code>SqlLocationService</code> class, or any other implementation we’d like.This is the most flexible possibility we can get.<strong>Advantages:</strong></p>
<ul>
<li>Using constructor injection allows changing the dependency in one place, and all the methods get it (assuming we have more than one method).</li>
<li>Injecting the <code>ILocationService</code> interface allows us to inject any of its implementations without changing the code.</li>
<li>Because of the <code>ILocationService</code> interface, the controller is loosely coupled with its dependencies.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Understanding what objects the controller uses is harder since the dependencies are resolved at runtime. However, this forces us to program against an interface instead (a good thing).</li>
</ul>
<p>Let’s have a look at this flexibility in action.</p>


<h4 data-number="9.3.4.5">Constructing the InjectAbstractionLocationsController</h4>
<p>I created a few xUnit tests to explore the possibilities, making it easy to create classes manually.</p>
<blockquote>
<p>I used Moq to mock implementations. If you are unfamiliar with Moq and want to learn more, I left a link in the <em>Further Reading</em> section.</p>
</blockquote>
<p>Two of the tests refers to the following member, a static <code>Location</code> object:</p>
<div><pre><code>public static Location ExpectedLocation { get; }
    = new Location(11, "Montréal", "CA");</code></pre>
</div>
<p>The test cases are not to assess the correctness of our code but to explore how easy it is to compose the controller differently. Let’s explore the first test case.</p>

<h5 data-number="9.3.4.5.1">Mock_the_IDatabase</h5>
<p>The first is an integration test that injects an instance of the <code>SqlLocationService</code> class into the controller and mocks the database. The fake database returns a collection of one item. That item is the <code>Location</code> instance referenced by the <code>ExpectedLocation</code> property. Here’s that code:</p>
<div><pre><code>var databaseMock = new Mock&lt;IDatabase&gt;();
databaseMock.Setup(x =&gt; x.ReadManyAsync&lt;Location&gt;(It.IsAny&lt;string&gt;(), It.IsAny&lt;CancellationToken&gt;()))
    .ReturnsAsync(() =&gt; new Location[] { ExpectedLocation })
;
var sqlLocationService = new SqlLocationService(
    databaseMock.Object);
var sqlController = new InjectAbstractionLocationsController(
    sqlLocationService);</code></pre>
</div>
<p>The preceding code shows how we can control the dependency we inject into the classes because of how the <code>InjectAbstractionLocationsController</code> was designed. We can’t say the same about the four other controller versions.Next, we call the GetAsync method to verify that everything works as expected:</p>
<div><pre><code>var result = await sqlController.GetAsync(CancellationToken.None);</code></pre>
</div>
<p>Finally, let’s verify we received that collection of one object:</p>
<div><pre><code>Assert.Collection(result,
    location =&gt;
    {
        Assert.Equal(ExpectedLocation.Id, location.Id);
        Assert.Equal(ExpectedLocation.Name, location.Name);
    }
);</code></pre>
</div>
<blockquote>
<p>Optionally, or instead, we could validate the service called the database mock, like this:</p>
</blockquote>
<pre><code>databaseMock.Verify(x =&gt; x
    .ReadManyAsync&lt;Location&gt;(
        It.IsAny&lt;string&gt;(),
        It.IsAny&lt;CancellationToken&gt;()
    ),
    Times.Once()
);</code></pre>
<blockquote>
<p>There are a lot of useful features in the Moq library.</p>
</blockquote>
<p>Validating that the code was correct is not important for this example. The key is to understand the composition of the controller, which the following diagram represents:</p>
<figure>
<img alt="Figure 8.1: Composition of the controller in a test that mocks the IDatabase interface" src="img/file40.png"/><figcaption aria-hidden="true">Figure 8.1: Composition of the controller in a test that mocks the IDatabase interface</figcaption>
</figure>
<p>As we can see from the diagram, the classes depend on interfaces, and we inject implementations when building them. The next two tests are simpler than this, only depending on the <code>ILocationService</code>. Let’s explore the second one.</p>


<h5 data-number="9.3.4.5.2">Use_the_InMemoryLocationService</h5>
<p>Next, we use the in-memory location service to compose the controller like this:</p>
<div><pre><code>var inMemoryLocationService = new InMemoryLocationService();
var devController = new InjectAbstractionLocationsController(
    inMemoryLocationService);</code></pre>
</div>
<p>As we can see from the preceding code, we injected a different service into the controller, changing its behavior. This time, after calling the <code>GetAsync</code> method, the controller returned the ten <code>Location</code> objects from the <code>InMemoryLocationService</code>.The visual representation of our object tree is as follows:</p>
<figure>
<img alt="Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService instance." src="img/file41.png"/><figcaption aria-hidden="true">Figure 8.2: Composition of the controller in a test that injects an InMemoryLocationService instance.</figcaption>
</figure>
<p>It is harder to write assertions for the preceding test because we inject an instance of the <code>InMemoryLocationService</code> class, which ties the result to its implementation. For this reason, we won’t look at that code here. Nonetheless, we succeeded at composing the controller differently. Let’s have a look at the last test case.</p>


<h5 data-number="9.3.4.5.3">Mock_the_ILocationService</h5>
<p>The last unit test mocks the ILocationService directly. The mock service returns a collection of one item. That item is the <code>Location</code> instance referenced by the <code>ExpectedLocation</code> property. Here’s that code:</p>
<div><pre><code>var locationServiceMock = new Mock&lt;ILocationService&gt;();
locationServiceMock.Setup(x =&gt; x.FetchAllAsync(It.IsAny&lt;CancellationToken&gt;())).ReturnsAsync(() =&gt; new Location[] { ExpectedLocation });
var testController = new InjectAbstractionLocationsController(
    locationServiceMock.Object);</code></pre>
</div>
<p>When executing the <code>GetAsync</code> method, we get the same result as in the first test case: a collection of a single test <code>Location</code> object. We can assert the correctness of the method by comparing values like this:</p>
<div><pre><code>Assert.Collection(result,
    location =&gt;
    {
        Assert.Equal(ExpectedLocation.Id, location.Id);
        Assert.Equal(ExpectedLocation.Name, location.Name);
    }
);</code></pre>
</div>
<p>We can also leverage Moq to verify that the controller called the <code>FetchAllAsync</code> method using the following code:</p>
<div><pre><code>locationServiceMock.Verify(x =&gt; x
    .FetchAllAsync(It.IsAny&lt;CancellationToken&gt;()),
    Times.Once()
);</code></pre>
</div>
<p>The object tree of is very similar to the previous diagram but we faked the service implementation, making this a real unit test:</p>
<figure>
<img alt="Figure 8.3: Composition of the controller in a test that mocks the ILocationService interface." src="img/file42.png"/><figcaption aria-hidden="true">Figure 8.3: Composition of the controller in a test that mocks the ILocationService interface.</figcaption>
</figure>
<p>As we explored in this project, with the right design and dependency injection, we can easily compose different object trees using the same building blocks. However, with a bad design, it is hard to impossible to do so without altering the code.</p>
<blockquote>
<p>As you may have noticed, we used the <code>new</code> keyword in the controller to instantiate the DTO. DTOs are stable dependencies. We also explore object mappers in <em>Chapter 15</em>, <em>Object mappers, Aggregate Services, and Façade</em>, which is a way to encapsulate the logic of copying an object into another.</p>
</blockquote>
<p>Let’s conclude before our next subject.</p>




<h3 data-number="9.3.5">Conclusion</h3>
<p>In this section, we saw that the strategy pattern went from a simple behavioral GoF pattern to the cornerstone of dependency injection. We explored different ways of injecting dependencies with a strong focus on constructor injection.Constructor injection is the most commonly used approach as it injects required dependencies, which we want the most. Method injection allows injecting algorithms, shared states, or contexts in a method that could not otherwise access that information. We can use property injection to inject optional dependencies, which should rarely happen.You can see optional dependencies as code smells because if the class has an optional role to play, it also has a primary role resulting in dual responsibilities. Moreover, if a role is optional, it could be better to move it to another class or rethink the system's design in that specific area.To practice what you just learned, you could connect the code sample to a real database, an Azure Table, Redis, a JSON file, or any other data source—tip: code classes that implement the <code>ILocationService</code> interface.</p>
<blockquote>
<p>As we covered, we can inject classes into other classes directly. There is nothing wrong with that. However, I suggest injecting interfaces as your initial approach until you are confident that you have mastered the different architectural principles and patterns covered in this book.</p>
</blockquote>
<p>Next, we explore guard clauses.</p>



<h2 data-number="9.4">Understanding guard clauses</h2>
<p>A guard clause represents a condition the code must meet before executing a method. Essentially, it's a type of code that "guards" against continuing the execution of the method if certain conditions aren't met.In most cases, guard clauses are implemented at the beginning of a method to throw an exception early when the conditions necessary for the method's execution are not satisfied. Throwing an exception allows callers to catch the error without the need to implement a more complex communication mechanism.We already stated that we use constructor injection to inject the required dependencies reliably. However, nothing fully guarantees us that the dependencies are not <code>null</code>. Ensuring a dependency is not <code>null</code> is one of the most common guard clauses, which is trivial to implement. For example, we could check for nulls in the controller by replacing the following:</p>
<div><pre><code>_locationService = locationService;</code></pre>
</div>
<p>With the following:</p>
<div><pre><code>_locationService = locationService ?? throw new ArgumentNullException(nameof(locationService));</code></pre>
</div>
<p>The preceding code uses a <code>throw</code> expression from C# 7 (See <em>Appendix A</em> for more information). The <code>ArgumentNullException</code> type makes it evident that the <code>locationService</code> parameter is <code>null</code>. So if the <code>locationService</code> parameter is <code>null</code>, an <code>ArgumentNullException</code> is thrown; otherwise, the <code>locationService</code> parameter is assigned to the <code>_locationService</code> member.Of course, with the introduction of the nullable reference types (see <em>Appendix A</em>), receiving a <code>null</code> argument is less likely yet still possible.</p>
<blockquote>
<p>A built-in container will automatically throw an exception if it can’t fulfill all dependencies during the instantiation of a class (such as a controller). That does not mean that all third-party containers act the same.</p>
<blockquote>
<p>Moreover, that does not protect you from passing <code>null</code> to a class you manually instantiates, nor that a method will not receive a <code>null</code> value. I recommend adding guards even since they are less mandatory now. The tooling can handle most of the work for us, leading to only a minor time overhead.</p>
</blockquote>
<blockquote>
<p>Furthermore, suppose you are writing code consumed by other projects, like a library. In that case, adding guards is more important since nothing guarantees that the consumers of that code have nullable reference type checks enabled.</p>
</blockquote>
</blockquote>
<p>When we need to validate a parameter and don't need an assignment, like with most parameters of a constructor, we can use the following helper, and the BCL handles the check for us:</p>
<div><pre><code>ArgumentNullException.ThrowIfNull(locationService);</code></pre>
</div>
<p>When we need to validate a string and want to ensure it is not empty, we can use the following instead:ArgumentException.ThrowIfNullOrEmpty(name);Of course, we can always revert to <code>if</code> statements to validate parameters. When doing so, we must ensure we throw relevant exceptions. If no pertinent exceptions exist, we can create one. Creating custom exceptions is a great way to write manageable applications.Next, we revisit an (anti-)pattern while exploring the singleton lifetime replacing it.</p>


<h2 data-number="9.5">Revisiting the Singleton pattern</h2>
<p>The Singleton pattern is obsolete, goes against the SOLID principles, and we replace it with a lifetime, as we’ve already seen. This section explores that lifetime and recreates the good old application state, which is nothing more than a singleton-scoped dictionary.We explore two examples: one about the application state, in case you were wondering where that feature disappeared to. Then, the Wishlist project also uses the singleton lifetime to provide an application-level feature. There are also a few unit tests to play with testability and to allow safe refactoring.</p>

<h3 data-number="9.5.1">Project – Application state</h3>
<p>You might remember the application state if you programmed ASP.NET using .NET Framework or the “good” old classic ASP with VBScript. If you don’t, the application state was a key/value dictionary that allowed you to store data globally in your application, shared between all sessions and requests. That is one of the things that ASP always had and other languages, such as PHP, did not (or do not easily allow).For example, I remember designing a generic reusable typed shopping cart system with classic ASP/VBScript. VBScript was not a strongly typed language and had limited object-oriented capabilities. The shopping cart fields and types were defined at the application level (once per application), and then each user had their own “instance” containing the products in their “private shopping cart” (created once per session).In ASP.NET Core, there is no more <code>Application</code> dictionary. To achieve the same goal, you could use a static class or static members, which is not the best approach; remember that global objects (<code>static</code>) make your application harder to test and less flexible. We could also use the Singleton pattern or create an ambient context, allowing us to create an application-level instance of an object. We could even mix that with a factory to create end-user shopping carts, but we won’t; these are not the best solution either. Another way could be to use one of the ASP.NET Core caching mechanisms, memory cache, or distributed cache, but this is a stretch.We could also save everything in a database to persist the shopping cart between visits, but that is not related to the application state and requires more work, potentially a user account, so we will not do that either.We could save the shopping cart on the client-side using cookies, local storage, or any other modern mechanism to save data on the user’s computer. However, we’d get even further from the application state than using a database.For most cases requiring an application state-like feature, the best approach would be to create a standard class and an interface and then register the binding with a singleton lifetime in the container. Finally, you inject it into the component that needs it, using constructor injection. Doing so allows the mocking of dependencies and changing the implementations without touching the code but the composition root.</p>
<blockquote>
<p>Sometimes, the best solution is not the technically complex ones or design pattern-oriented; the best solution is often the simplest. Less code means less maintenance and fewer tests, resulting in a simpler application.</p>
</blockquote>
<p>Let’s implement a small program that simulates the application state. The API is a single interface with two implementations. The program also exposes part of the API over HTTP, allowing users to get or set a value associated with the specified key. We use the singleton lifetime to ensure the data is shared between all requests.The interface looks like the following:</p>
<div><pre><code>public interface IApplicationState
{
    TItem? Get&lt;TItem&gt;(string key);
    bool Has&lt;TItem&gt;(string key);
    void Set&lt;TItem&gt;(string key, TItem value) where TItem : notnull;
} </code></pre>
</div>
<p>We can get the value associated with a key, associate a value with a key (set), and validate whether a key exists.The <code>Program.cs</code> file contains the code responsible for handling HTTP requests. We can swap the implementations by commenting or uncommenting the first line of the <code>Program.cs</code> file, which is <code>#define USE_MEMORY_CACHE</code>. That changes the dependency registration, as highlighted in the following code:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
#if USE_MEMORY_CACHE
        builder.Services.AddMemoryCache();
        builder.Services.AddSingleton&lt;IApplicationState, ApplicationMemoryCache&gt;();
#else
        builder.Services.AddSingleton&lt;IApplicationState,
ApplicationDictionary&gt;();
#endif
var app = builder.Build();
app.MapGet("/", (IApplicationState myAppState, string key) =&gt;
{
    var value = myAppState.Get&lt;string&gt;(key);
    return $"{key} = {value ?? "null"}";
});
app.MapPost("/", (IApplicationState myAppState, SetAppState dto) =&gt;
{
    myAppState.Set(dto.Key, dto.Value);
    return $"{dto.Key} = {dto.Value}";
});
app.Run();
public record class SetAppState(string Key, string Value);</code></pre>
</div>
<p>Let’s now explore the first implementation.</p>

<h4 data-number="9.5.1.1">First implementation</h4>
<p>The first implementation uses the memory cache system, and I thought it would be educational to show that to you. Caching data in memory is something you might need to do sooner rather than later. However, we are hiding the cache system behind our implementation, which is also educational.Here is the <code>ApplicationMemoryCache</code> class:</p>
<div><pre><code>public class ApplicationMemoryCache : IApplicationState
{
    private readonly IMemoryCache _memoryCache;
    public ApplicationMemoryCache(IMemoryCache memoryCache)
    {
        _memoryCache = memoryCache ?? throw new ArgumentNullException(nameof(memoryCache));
    }
    public TItem Get&lt;TItem&gt;(string key)
    {
        return _memoryCache.Get&lt;TItem&gt;(key);
    }
    public bool Has&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue&lt;TItem&gt;(key, out _);
    }
    public void Set&lt;TItem&gt;(string key, TItem value)
    {
        _memoryCache.Set(key, value);
    }
}</code></pre>
</div>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>The <code>ApplicationMemoryCache</code> class is a thin wrapper over <code>IMemoryCache</code>, hiding the implementation details. Such a wrapper is similar to the Façade and Adapter patterns we explore in <em>Chapter 11</em>, <em>Structural Patterns</em>.</p>
</blockquote>
</blockquote>
<p>This simple class and two lines in our composition root make it an application-wide key-value store; done already! Let’s now explore the second implementation.</p>


<h4 data-number="9.5.1.2">Second implementation</h4>
<p>The second implementation uses <code>ConcurrentDictionary&lt;string, object&gt;</code> to store the application state data and ensure thread safety, as multiple users could use the application state simultaneously. The <code>ApplicationDictionary</code> class is almost as simple as <code>ApplicationMemoryCache</code>:</p>
<div><pre><code>using System.Collections.Concurrent;
namespace ApplicationState;
public class ApplicationDictionary : IApplicationState
{
    private readonly ConcurrentDictionary&lt;string, object&gt; _memoryCache = new();
    public TItem? Get&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue(key, out var item)
            ? (TItem)item
            : default;
    }
    public bool Has&lt;TItem&gt;(string key)
    {
        return _memoryCache.TryGetValue(key, out var item) &amp;&amp; item is TItem;
    }
    public void Set&lt;TItem&gt;(string key, TItem value)
        where TItem : notnull
    {
        _memoryCache.AddOrUpdate(key, value, (k, v) =&gt; value);
    }
}</code></pre>
</div>
<p>The preceding code leverages the <code>TryGetValue</code> and <code>AddOrUpdate</code> methods to ensure thread safety while keeping the logic to a minimum and ensuring we avoid coding mistakes.</p>
<blockquote>
<p>Can you spot the flaw that might cause some problems in this design? See the solution at the end of the project section.</p>
</blockquote>
<p>Let’s explore how to use the implementations.</p>


<h4 data-number="9.5.1.3">Using the implementations</h4>
<p>We can now use any of the two implementations without impacting the rest of the program. That demonstrates the strength of DI when it comes to dependency management. Moreover, we control the lifetime of the dependencies from the composition root.If we were to use the <code>IApplicationState</code> interface in another class, say <code>SomeConsumer</code>, its usage could look similar to the following:</p>
<div><pre><code>namespace ApplicationState;
public class SomeConsumer
{
    private readonly IApplicationState _myApplicationWideService;
    public SomeConsumer(IapplicationState myApplicationWideService)
    {
        _myApplicationWideService = myApplicationWideService ?? throw new ArgumentNullException(nameof(myApplicationWideService));
    }
    public void Execute()
    {
        if (_myApplicationWideService.Has&lt;string&gt;("some-key"))
        {
            var someValue = _myApplicationWideService.Get&lt;string&gt;("some-key");
            // Do something with someValue
        }
        // Do something else like:
        _myApplicationWideService.Set("some-key", "some-value");
        // More logic here
    }
}</code></pre>
</div>
<p>In that code, <code>SomeConsumer</code> depends only on the <code>IApplicationState</code> interface, not <code>ApplicationDictionary</code> or <code>ApplicationMemoryCache</code>, and even less on <code>IMemoryCache</code> or <code>ConcurrentDictionary&lt;string, object&gt;</code>. Using DI allows us to hide the implementation by inverting the flow of dependencies. It also breaks direct coupling between concrete implementations. This approach also promotes programming against interfaces, as recommended by the Dependency Inversion Principle (DIP), and facilitates the creation of open-closed classes, in accordance with the Open/Closed Principle (OCP).Here is a diagram illustrating our application state system, making it visually easier to notice how it breaks coupling:</p>
<figure>
<img alt="Figure 8.2: DI-oriented diagram representing the application state system" src="img/file43.png"/><figcaption aria-hidden="true">Figure 8.2: DI-oriented diagram representing the application state system</figcaption>
</figure>
<p>From this sample, let’s remember that the singleton lifetime allows us to reuse objects between requests and share them application-wide. Moreover, hiding implementation details behind interfaces can improve the flexibility of our design.It is important to note that the singleton scope is only valid in a single process, so you can’t rely purely on in-memory mechanisms for larger applications that span multiple servers. We could use the <code>IDistributedCache</code> interface to circumvent this limitation and persist our application state system to a persistent caching tool, like Redis.</p>
<blockquote>
<p><strong>The flaw</strong>: If we look closely at the <code>Has&lt;TItem&gt;</code> method, it returns true only when an entry is present for the specified key AND has the right type. So we could override an entry of a different type without knowing it exists.</p>
<blockquote>
<p>For example, <code>ConsumerA</code> sets an item of type <code>A</code> for the key <code>K</code>. Elsewhere in the code, <code>ConsumerB</code> looks to see if an item of type <code>B</code> exists for the key <code>K</code>. The method returns <code>false</code> because it’s a different type. <code>ConsumerB</code> overrides the value of the <code>K</code> with an object of type <code>B</code>. Here’s the code representing this:</p>
</blockquote>
</blockquote>
<pre><code>// Arrange
var sp = new ServiceCollection()
    .AddSingleton&lt;IApplicationState, ApplicationDictionary&gt;()
    .BuildServiceProvider()
;
// Step 1: Consumer A sets a string
var consumerA = sp.GetRequiredService&lt;IApplicationState&gt;();
consumerA.Set("K", "A");
Assert.True(consumerA.Has&lt;string&gt;("K")); // true
// Step 2: Consumer B overrides the value with an int
var consumerB = sp.GetRequiredService&lt;IApplicationState&gt;();
if (!consumerB.Has&lt;int&gt;("K")) // Oops, key K exists but it's of type string, not int
{
    consumerB.Set("K", 123);
}
Assert.True(consumerB.Has&lt;int&gt;("K")); // true
// Consumer A is broken!
Assert.False(consumerA.Has&lt;string&gt;("K")); // false</code></pre>
<blockquote>
<p>Improving the design to support such a scenario could be a good practice exercise. You could, for example, remove the <code>TItem</code> type from the <code>Has</code> method or, even better, allow storing multiple items under the same key, as long as their types are different.</p>
</blockquote>
<p>Let’s now explore the next project.</p>



<h3 data-number="9.5.2">Project – Wishlist</h3>
<p>Let’s get into another sample to illustrate using the singleton lifetime and DI. Seeing DI in action should help understand it and then leverage it to create SOLID software.<strong>Context</strong>: The application is a site-wide wishlist where users can add items. Items expire every 30 seconds. When a user adds an existing item, the system must increment the count and reset the item’s expiration time. That way, popular items stay on the list longer, making it to the top. When displayed, the system must sort the items by count (highest count first).</p>
<blockquote>
<p>An expiration time of 30 seconds is very fast, but I’m sure you don’t want to wait days before an item expires when running the app. It is a test config.</p>
</blockquote>
<p>The program is a tiny web API that exposes two endpoints:</p>
<ul>
<li>Add an item to the wishlist (<code>POST</code>).</li>
<li>Read the wishlist (<code>GET</code>).</li>
</ul>
<p>The wishlist interface looks like this:</p>
<div><pre><code>public interface IWishList
{
    Task&lt;WishListItem&gt; AddOrRefreshAsync(string itemName);
    Task&lt;IEnumerable&lt;WishListItem&gt;&gt; AllAsync();
}
public record class WishListItem(string Name, int Count, DateTimeOffset Expiration);</code></pre>
</div>
<p>The two operations are there, and by making them async (returning a <code>Task&lt;T&gt;</code>), we could implement another version that relies on a remote system, such as a database, instead of an in-memory store. Then, the <code>WishListItem</code> record class is part of the <code>IWishList</code> contract; it is the model. To keep it simple, the wishlist only stores the names of items.</p>
<blockquote>
<p><strong>Note</strong></p>
<blockquote>
<p>Trying to foresee the future is not usually a good idea, but designing APIs to be awaitable is generally a safe bet. Other than this, I’d recommend you stick to the simplest code that satisfies the program's needs (KISS). When you try to solve problems that do not exist yet, you usually end up coding a lot of useless stuff, leading to additional unnecessary maintenance and testing time.</p>
</blockquote>
</blockquote>
<p>In the composition root, we must serve the <code>IWishList</code> implementation instance in a singleton scope (highlighted) so all requests share the same instance. Let’s start with the first half of the <code>Program.cs</code> file:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services
    .ConfigureOptions&lt;InMemoryWishListOptions&gt;()
    .AddTransient&lt;IValidateOptions&lt;InMemoryWishListOptions&gt;, InMemoryWishListOptions&gt;()
    .AddSingleton(serviceProvider =&gt; serviceProvider.GetRequiredService&lt;IOptions&lt;InMemoryWishListOptions&gt;&gt;().Value)
    // The singleton registration
    .AddSingleton&lt;IWishList, InMemoryWishList&gt;() 
;</code></pre>
</div>
<blockquote>
<p>If you are wondering where <code>IConfigureOptions</code>, <code>IValidateOptions</code>, and <code>IOptions</code> come from, we cover the ASP.NET Core Options pattern in <em>Chapter 9</em>, <em>Options, Settings, and Configuration</em>.</p>
</blockquote>
<p>Let’s now look at the second half of the <code>Program.cs</code> file that contains the minimal API code to handle the HTTP requests:</p>
<div><pre><code>var app = builder.Build();
app.MapGet("/", async (IWishList wishList) =&gt; 
    await wishList.AllAsync());
app.MapPost("/", async (IWishList wishList, CreateItem? newItem) =&gt;
{
    if (newItem?.Name == null)
    {
        return Results.BadRequest();
    }
    var item = await wishList.AddOrRefreshAsync(newItem.Name);
    return Results.Created("/", item);
});
app.Run();
public record class CreateItem(string? Name);</code></pre>
</div>
<p>The <code>GET</code> endpoint delegates the logic to the injected <code>IWishList</code> implementation and returns the result, while the <code>POST</code> endpoint validates the <code>CreateItem</code> DTO before delegating the logic to the wishlist.To help us implement the <code>InMemoryWishList</code> class, we started by writing some tests to back our specifications up. Since static members are hard to configure in tests (remember globals?), I borrowed a concept from the ASP.NET Core memory cache and created an <code>ISystemClock</code> interface that abstracts away the static call to <code>DateTimeOffset.UtcNow</code> or <code>DateTime.UtcNow</code>.This way, we can program the value of <code>UtcNow</code> in our tests to create expired items. Here’s the clock interface and implementation:</p>
<div><pre><code>namespace Wishlist.Internal;
public interface ISystemClock
{
    DateTimeOffset UtcNow { get; }
}
public class SystemClock : ISystemClock
{
    public DateTimeOffset UtcNow =&gt; DateTimeOffset.UtcNow;
}</code></pre>
</div>
<blockquote>
<p>.NET 8 adds a new <code>TimeProvider</code> class to the <code>System</code> namespace, which does not help us much here. However, if we want to leverage that API, we could update the SystemClock to the following:</p>
</blockquote>
<pre><code>public class CustomClock : ISystemClock
{
    private readonly TimeProvider _timeProvider;
    public CustomClock(TimeProvider timeProvider)
    {
        _timeProvider = timeProvider ?? throw new ArgumentNullException(nameof(timeProvider));
    }
    public DateTimeOffset UtcNow =&gt; _timeProvider.GetUtcNow();
}</code></pre>
<blockquote>
<p>That code leverages the new API, but we’ll stick to our simple implementation instead.</p>
</blockquote>
<p>Let’s look at the outline of the unit tests next because the whole code would take pages and be of low value:</p>
<div><pre><code>namespace Wishlist;
public class InMemoryWishListTest
{
    // Constructor and private fields omitted
    public class AddOrRefreshAsync : InMemoryWishListTest
    {
        [Fact]
        public async Task Should_create_new_item();
        [Fact]
        public async Task Should_increment_Count_of_an_existing_item();
        [Fact]
        public async Task Should_set_the_new_Expiration_date_of_an_existing_item();
        [Fact]
        public async Task Should_set_the_Count_of_expired_items_to_1();
        [Fact]
        public async Task Should_remove_expired_items();
    }
    public class AllAsync : InMemoryWishListTest
    {
        [Fact]
        public async Task Should_return_items_ordered_by_Count_Descending();
        [Fact]
        public async Task Should_not_return_expired_items();
    }
    // Private helper methods omitted
}</code></pre>
</div>
<blockquote>
<p>The full source code is on GitHub: <a href="https://adpg.link/ywy8">https://adpg.link/ywy8</a>.</p>
</blockquote>
<p>In the test class, we can mock the <code>ISystemClock</code> interface and program it to obtain the desired results based on each test case. We can also program some helper methods to make it easier to read the tests. Those helpers use tuples to return multiple values (see <em>Appendix A</em> for more information on language features). Here’s the mock field:</p>
<div><pre><code>private readonly Mock&lt;ISystemClock&gt; _systemClockMock = new();</code></pre>
</div>
<p>Here’s an example of such a helper method setting the clock to the present time and the <code>ExpectedExpiryTime</code> to a later time (<code>UtcNow + ExpirationInSeconds</code> later):</p>
<div><pre><code>private (DateTimeOffset UtcNow, DateTimeOffset ExpectedExpiryTime) SetUtcNow()
{
    var utcNow = DateTimeOffset.UtcNow;
    _systemClockMock.Setup(x =&gt; x.UtcNow).Returns(utcNow);
    var expectedExpiryTime = utcNow.AddSeconds(_options.ExpirationInSeconds);
    return (utcNow, expectedExpiryTime);
}</code></pre>
</div>
<p>Here is an example of another helper method setting the clock and the <code>ExpectedExpiryTime</code> to the past (two-time <code>ExpirationInSeconds</code> for the clock and once <code>ExpirationInSeconds</code> for the <code>ExpectedExpiryTime</code>):</p>
<div><pre><code>private (DateTimeOffset UtcNow, DateTimeOffset ExpectedExpiryTime) SetUtcNowToExpired()
{
    var delay = -(_options.ExpirationInSeconds * 2);
    var utcNow = DateTimeOffset.UtcNow.AddSeconds(delay);
    _systemClockMock.Setup(x =&gt; x.UtcNow).Returns(utcNow);
    var expectedExpiryTime = utcNow.AddSeconds(_options.ExpirationInSeconds);
    return (utcNow, expectedExpiryTime);
}</code></pre>
</div>
<p>We now have five tests covering the <code>AddOrRefreshAsync</code> method and two covering the <code>AllAsync</code> method. Now that we have those failing tests, here is the implementation of the <code>InMemoryWishList</code> class:</p>
<div><pre><code>namespace Wishlist;
public class InMemoryWishList : IWishList
{
    private readonly InMemoryWishListOptions _options;
    private readonly ConcurrentDictionary&lt;string, InternalItem&gt; _items = new();
    public InMemoryWishList(InMemoryWishListOptions options)
    {
        _options = options ?? throw new ArgumentNullException(nameof(options));
    }
    public Task&lt;WishListItem&gt; AddOrRefreshAsync(string itemName)
    {
        var expirationTime = _options.SystemClock.UtcNow.AddSeconds(_options.ExpirationInSeconds);
        _items
            .Where(x =&gt; x.Value.Expiration &lt; _options.SystemClock.UtcNow)
            .Select(x =&gt; x.Key)
            .ToList()
            .ForEach(key =&gt; _items.Remove(key, out _))
        ;
        var item = _items.AddOrUpdate(
            itemName,
            new InternalItem(Count: 1, Expiration: expirationTime),
            (string key, InternalItem item) =&gt; item with {
                Count = item.Count + 1,
                Expiration = expirationTime
            }            
        );
        var wishlistItem = new WishListItem(
            Name: itemName,
            Count: item.Count,
            Expiration: item.Expiration
        );
        return Task.FromResult(wishlistItem);
    }
    public Task&lt;IEnumerable&lt;WishListItem&gt;&gt; AllAsync()
    {
        var items = _items
            .Where(x =&gt; x.Value.Expiration &gt;= _options.SystemClock.UtcNow)
            .Select(x =&gt; new WishListItem(
                Name: x.Key,
                Count: x.Value.Count,
                Expiration: x.Value.Expiration
            ))
            .OrderByDescending(x =&gt; x.Count)
            .AsEnumerable()
        ;
        return Task.FromResult(items);
    }
    private record class InternalItem(int Count, DateTimeOffset Expiration);
}</code></pre>
</div>
<p>The <code>InMemoryWishList</code> class uses <code>ConcurrentDictionary&lt;string, InternalItem&gt;</code> internally to store the items and make the wishlist thread-safe. It also uses a <code>with</code> expression to manipulate and copy the <code>InternalItem</code> record class.The <code>AllAsync</code> method filters out expired items, while the <code>AddOrRefreshAsync</code> method removes expired items. This might not be the most advanced logic ever, but that does the trick.</p>
<blockquote>
<p>You might have noticed that the code is not the most elegant of all, and I left it this way on purpose. While using the test suite, I invite you to refactor the methods of the <code>InMemoryWishList</code> class to be more readable.</p>
<blockquote>
<p>I took a few minutes to refactor it myself and saved it as <code>InMemoryWishListRefactored</code>. You can also uncomment the first line of <code>InMemoryWishListTest.cs</code> to test that class instead of the main one. My refactoring is a way to make the code cleaner, to give you ideas. It is not the only way, nor the best way, to write that class (the “best way” being subjective).</p>
</blockquote>
<blockquote>
<p>Lastly, optimizing for readability and performance are often very different things.</p>
</blockquote>
</blockquote>
<p>Back to DI, the line that makes the wishlist shared between users is in the composition root we explored earlier. As a reference, here it is:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IWishList, InMemoryWishList&gt;();</code></pre>
</div>
<p>Yes, only that line makes all the difference between creating multiple instances and a single shared instance. Setting the lifetime to Singleton allows you to open multiple browsers and share the wishlist.</p>
<blockquote>
<p>To <code>POST</code> to the API, I recommend using the <code>Wishlist.http</code> file in the project or the Postman collection (<a href="https://adpg.link/postman6">https://adpg.link/postman6</a>) that comes with the book. The collection already contains multiple requests you can execute in batches or individually. You can also use the Swagger UI that I added to the project.</p>
</blockquote>
<p>That’s it! All that code to demo what a single line of code in the composition root can do, and we have a working program, as tiny as it may be.</p>


<h3 data-number="9.5.3">Conclusion</h3>
<p>This section explored replacing the classic Singleton pattern with a standard instantiable class registered with a singleton lifetime. We looked at the old application state, learned that it was no more, and implemented two versions of it. We no longer need that, but it was a good way of learning about singletons.We then implemented a wishlist system as a second example. We concluded that the whole thing was working due to and managed by a single line of the composition root: the call to the <code>AddSingleton</code> method. Changing that line could drastically change the system's behavior, making it unusable.From now on, you can see the Singleton pattern as an anti-pattern in .NET, and unless you find strong reasons to implement it, you should stick to normal classes and DI instead. Doing this moves the creation responsibility from the singleton class to the composition root, which is the composition root’s responsibility, leaving the class only one responsibility.Next, we explore the Service Locator anti-pattern/code smell.</p>



<h2 data-number="9.6">Understanding the Service Locator pattern</h2>
<p>Service Locator is an anti-pattern that reverts the IoC principle to its Control Freak roots. The only difference is using the IoC container to build the dependency tree instead of the <code>new</code> keyword.There is some use of this pattern in ASP.NET, and we may argue that there are some reasons for using the Service Locator pattern, but it should happen rarely or never in most applications. For that reason, let’s call the Service Locator pattern a <strong>code smell</strong> instead of an <strong>anti-pattern</strong>.My strong recommendation is <em>don’t use the Service Locator pattern</em> unless you know you are not creating hidden coupling or have no other option. As a rule of thumb, you want to avoid injecting an <code>IServiceProvider</code> in your application’s codebase. Doing so reverts to the classic flow of control and defeats the purpose of dependency injection.A good use of Service Locator could be to migrate a legacy system that is too big to rewrite. So you could build the new code using DI and update the legacy code using the Service Locator pattern, allowing both systems to live together or migrate one into the other, depending on your goal. Fetching dependencies dynamically is another potential use of the Service Locator pattern; we explore this in <em>Chapter 15</em>, <em>Object Mappers, Aggregate Services, and Façade</em>.Without further ado, let’s jump into some more code.</p>

<h3 data-number="9.6.1">Project – ServiceLocator</h3>
<p>The best way to avoid something is to know about it, so let’s see how to implement the Service Locator pattern using <code>IServiceProvider</code> to find a dependency.The service we want to use is an implementation of <code>IMyService</code>. Let’s start with the interface:</p>
<div><pre><code>namespace ServiceLocator;
public interface IMyService : IDisposable
{
    void Execute();
}</code></pre>
</div>
<p>The interface inherits from the <code>IDisposable</code> interface and contains a single <code>Execute</code> method. Here is the implementation, which does nothing more than throw an exception if the instance has been disposed of (we’ll leverage this later):</p>
<div><pre><code>namespace ServiceLocator;
public class MyServiceImplementation : IMyService
{
    private bool _isDisposed = false;
    public void Dispose() =&gt; _isDisposed = true;
    public void Execute()
    {
        if (_isDisposed)
        {
            throw new NullReferenceException("Some dependencies have been disposed.");
        }
    }
}</code></pre>
</div>
<p>Then, let’s add a controller that implements the Service Locator pattern:</p>
<div><pre><code>namespace ServiceLocator;
public class MyController : ControllerBase
{
    private readonly IServiceProvider _serviceProvider;
    public MyController(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));
    }
    [Route("/service-locator")]
    public IActionResult Get()
    {
        using var myService = _serviceProvider
            .GetRequiredService&lt;IMyService&gt;();
        myService.Execute();
        return Ok("Success!");
    }
}</code></pre>
</div>
<p>In the preceding code, instead of injecting <code>IMyService</code> into the constructor, we are injecting <code>IServiceProvider</code>. Then, we use it (highlighted line) to locate the <code>IMyService</code> instance. Doing so shifts the responsibility for creating the object from the container to the consumer (<code>MyController</code>, in this case). <code>MyController</code> should not be aware of <code>IServiceProvider</code> and should let the container do its job without interference.What could go wrong? If we run the application and navigate to <code>/service-locator</code>, everything works as expected. However, if we reload the page, we get an error thrown by the <code>Execute()</code> method because we called <code>Dispose()</code> during the previous request. <code>MyController</code> should not control its injected dependencies, which is the point that I am trying to emphasize here: leave the container to control the lifetime of dependencies rather than trying to be a control freak. Using the Service Locator pattern opens pathways toward those wrong behaviors, which will likely cause more harm than good in the long run.Moreover, even though the ASP.NET Core container does not natively support this, we lose the ability to inject dependencies contextually when using the Service Locator pattern because the consumer controls its dependencies. What do I mean by contextually? Let’s assume we have two classes, <code>A</code> and <code>B</code>, implementing interface <code>I</code>. We could inject an instance of <code>A</code> into <code>Consumer1</code> but an instance of <code>B</code> into <code>Consumer2</code>.Before exploring ways to fix this, here is the <code>Program.cs</code> code that powers this program:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddSingleton&lt;IMyService, MyServiceImplementation&gt;()
    .AddControllers()
;
var app = builder.Build();
app.MapControllers();
app.Run();</code></pre>
</div>
<p>The preceding code enables controller support and registers our service.To fix the controller, we must either remove the using statement or even better: move away from the Service Locator pattern and inject our dependencies instead. Of course, you are reading a dependency injection chapter, so I picked moving away from the Service Locator pattern. Here's what we are about to tackle:</p>
<ul>
<li>Method injection</li>
<li>Constructor injection</li>
<li>Minimal API</li>
</ul>
<p>Let’s start with method injection.</p>

<h4 data-number="9.6.1.1">Implementing method injection</h4>
<p>The following controller uses <em>method injection</em> instead of the Service Locator pattern. Here’s the code that demonstrates this:</p>
<div><pre><code>public class MethodInjectionController : ControllerBase
{
    [Route("/method-injection")]
    public IActionResult GetUsingMethodInjection([FromServices] IMyService myService)
    {
        ArgumentNullException.ThrowIfNull(myService, nameof(myService));
        myService.Execute();
        return Ok("Success!");
    }
}</code></pre>
</div>
<p>Let’s analyze the code:</p>
<ul>
<li>The <code>FromServicesAttribute</code> class tells the model binder about method injection.</li>
<li>We added a guard clause to protect us from <code>null</code>.</li>
<li>Finally, we kept the original code except for the <code>using</code> statement.</li>
</ul>
<blockquote>
<p>Method injection like this is convenient when a controller has multiple actions but only one uses the service.</p>
</blockquote>
<p>Let’s reexplore constructor injection.</p>


<h4 data-number="9.6.1.2">Implementing constructor injection</h4>
<p>At this point, you should be familiar with constructor injection. Nonetheless, next is the controller's code after migrating the Service Locator pattern to constructor injection:</p>
<div><pre><code>namespace ServiceLocator;
public class ConstructorInjectionController : ControllerBase
{
    private readonly IMyService _myService;
    public ConstructorInjectionController(IMyService myService)
    {
        _myService = myService ?? throw new ArgumentNullException(nameof(myService));
    }
    [Route("/constructor-injection")]
    public IActionResult GetUsingConstructorInjection()
    {
        _myService.Execute();
        return Ok("Success!");
    }
} </code></pre>
</div>
<p>When using constructor injection, we ensure that <code>IMyService</code> is not <code>null</code> upon class instantiation. Since it is a class member, it is even less tempting to call its <code>Dispose()</code> method in an action method, leaving that responsibility to the container (as it should be).Let’s analyze the code before moving to the next possibility:</p>
<ul>
<li>We implemented the strategy pattern with constructor injection.</li>
<li>We added a guard clause to ensure no <code>null</code> value could get in at runtime.</li>
<li>We simplified the action to the bare minimum.</li>
</ul>
<p>Both techniques are an acceptable replacement for the Service Locator pattern.</p>


<h4 data-number="9.6.1.3">Implementing a minimal API</h4>
<p>Of course, we can do the same with a minimal API. Here is the code of that endpoint:</p>
<div><pre><code>app.MapGet("/minimal-api", (IMyService myService) =&gt;
{
    myService.Execute();
    return "Success!";
});</code></pre>
</div>
<p>That code does the same as the method injection sample without the guard clause that I omitted because no external consumer will likely inject nulls into it: the endpoint is a delegate passed directly to the <code>MapGet</code> method.Refactoring out the Service Locator pattern is often as trivial as this.</p>



<h3 data-number="9.6.2">Conclusion</h3>
<p>Most of the time, by following the Service Locator anti-pattern, we only hide that we are taking control of objects instead of decoupling our components. The code sample demonstrated a problem when disposing of an object, which could also happen using constructor injection. However, when thinking about it, it is more tempting to dispose of an object that we create than one we inject.Moreover, the service locator takes control away from the container and moves it into the consumer, against the <strong>Open-Closed Principle</strong>. You should be able to update the consumer by updating the composition root’s bindings.In the case of the sample code, we could change the binding, and it would work. In a more advanced case, binding two implementations to the same interface would be tough when contextual injection is required.</p>
<blockquote>
<p>The IoC container is responsible for weaving the program’s thread, connecting its pieces together where each independent piece should be as clueless as possible about the others.</p>
</blockquote>
<p>On top of that, the Service Locator pattern complicates testing. When unit testing your class, you must mock a container that returns a mocked service instead of mocking only the service.One place where I can see its usage justified is in the composition root, where bindings are defined, and sometimes, especially when using the built-in container, we can’t avoid it to compensate for the lack of advanced features. Another good place would be a library that adds functionalities to the container. Other than that, try to stay away!</p>
<blockquote>
<p><strong>Beware</strong></p>
<blockquote>
<p>Moving the service locator elsewhere does not make it disappear; it only moves it around, like any dependency. However, moving it to the composition root can improve the maintainability of that code and remove the tight coupling.</p>
</blockquote>
</blockquote>
<p>Next, we revisit our third and final pattern of this chapter.</p>



<h2 data-number="9.7">Revisiting the Factory pattern</h2>
<p>A factory creates other objects; it is like a literal real-world factory. We explored in the previous chapter how to leverage the Abstract Factory pattern to create families of objects. A factory can be as simple as an interface with one or more <code>Create[Object]</code> methods or, even more, a simple delegate. We explore a DI-oriented simple factory in this section. We are building on top of the Strategy pattern example.In that example, we coded two classes implementing the <code>ILocationService</code> interface. The composition root used the <code>#define</code> preprocessor directive to tell the compiler what bindings to compile. In this version, we want to choose the implementation at runtime.</p>
<blockquote>
<p>Not compiling the code we don’t need is good for many reasons, including security (lowering the attack surface). In this case, we are simply using an alternative strategy useful for many scenarios.</p>
</blockquote>
<p>To achieve our new goal, we can extract the construction logic of the <code>ILocationService</code> interface into a factory.</p>

<h3 data-number="9.7.1">Project – Factory</h3>
<p>In the project, a copy from the Strategy project, we start by renaming the <code>InjectAbstractionLocationsController</code> class to <code>LocationsController</code>. We can then delete the other controllers.Now, we want to change the <code>ILocationService</code> bindings to reflect the following logic:</p>
<ul>
<li>When developing the application, we use the <code>InMemoryLocationService</code> class.</li>
<li>When deploying to any environment, we must use the <code>SqlLocationService</code> class.</li>
</ul>
<p>To achieve this, we use the <code>Environment</code> property of the <code>WebApplicationBuilder</code> object. That property of type <code>IWebHostEnvironment</code> contains some useful properties like the <code>EnvironmentName</code>, and .NET adds extension methods, like the <code>IsDevelopment</code> method that returns true when the <code>EnvironmentName</code> equals <code>Development</code>. Here’s the <code>Program.cs</code> file code:</p>
<div><pre><code>using Factory.Data;
using Factory.Services;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddSingleton&lt;ILocationService&gt;(sp =&gt;
{
    if (builder.Environment.IsDevelopment())
    {
        return new InMemoryLocationService();
    }
    return new SqlLocationService(new NotImplementedDatabase());
});
var app = builder.Build();
app.MapControllers();
app.Run();</code></pre>
</div>
<p>The preceding code is fairly straightforward; it registers a delegate to act as a factory, which builds the appropriate service based on the ASP.NET Core <code>Environment</code>.</p>
<blockquote>
<p>We are using the <code>new</code> keyword here, but is this wrong? The composition root is where we should create or configure elements, so instantiating objects there is correct, as it is to use the Service Locator pattern. It is best to avoid the <code>new</code> keyword and the Service Locator pattern whenever possible, but using the default container makes it harder than with a full-featured third-party one. Nevertheless, we can avoid doing that in many cases, and even if we must use the <code>new</code> keyword and the Service Locator pattern, we often don’t need a third-party container.</p>
</blockquote>
<p>When we run the program, the right instance is injected into the controller based on the logic we added to the factory. The flow is similar to the following:</p>
<ol>
<li>The application starts.</li>
<li>A client sends an HTTP request to the controller (<code>GET /travel/locations</code>).</li>
<li>ASP.NET Core creates the controller and leverages the IoC container to inject the <code>ILocationService</code> dependency.</li>
<li>Our factory creates the correct instance based on the current environment.</li>
<li>The action method runs, and the client receives the response.</li>
</ol>
<p>We could also create a factory class and an interface, as explored in the previous chapter. However, in this case, it would likely just create noise.</p>
<blockquote>
<p>An essential thing to remember is that <em>moving code around your codebase does not make that code, logic, dependencies, or coupling disappear</em>. Coding a factory doesn’t make all your design issues disappear. Moreover, adding more complexity adds a cost to your project, so factory or not, each time you try to break tight coupling or remove a dependency, ensure that you are not just moving the responsibility elsewhere or overengineering your solution.</p>
</blockquote>
<p>Of course, to keep our composition root clean, we could create an extension method that does the registration, like an <code>AddLocationService</code> method. I’ll leave you to try this one out, find other ways to improve the project, or even improve one of your own projects.The possibilities are almost endless when you think about the Factory patterns. Now that you’ve seen a few in action, you may find other uses for a factory when injecting some classes with complex instantiation logic into other objects.</p>



<h2 data-number="9.8">Summary</h2>
<p>This chapter delved into Dependency Injection, understanding its crucial role in crafting adaptable systems. We learned how DI applies the Inversion of Control principle, shifting dependency creation from the objects to the composition root. We explored the IoC container's role in object management, service resolution and injection, and dependency lifetime management. We tackled the Control Freak anti-pattern, advocating for dependency injection over using the <code>new</code> keyword.We revisited the Strategy pattern and explored how to use it with Dependency Injection to compose complex object trees. We learned about the principle of composition over inheritance, which encourages us to inject dependencies into the classes instead of relying on base class features and inheritance. We explored different ways of injecting dependencies into objects, including constructor injection, property injection, and method injection.We learned that a guard clause is a condition that must be met before a method is executed, often used to prevent null dependencies. We explored how to implement guard clauses. We also discussed the importance of adding guard clauses, as nullable reference type checks offer no guarantee at runtime.We revisited the Singleton pattern and how to replace it with a lifetime. We explored two examples utilizing the singleton lifetime to provide application-level features.We delved into the Service Locator pattern, often considered an anti-pattern, as it can create hidden coupling and revert the Inversion of Control principle. We learned that avoiding using the Service Locator pattern is generally best. We explored how to implement the Service Locator pattern and discussed the potential issues that could arise. We revisited the Factory pattern and learned how to build a simple, DI-oriented factory that replaces the object creation logic of the IoC container.<strong>Here are the key takeaways from this substantial chapter</strong>:</p>
<ul>
<li>Dependency Injection is a technique applying the Inversion of Control principle for effective dependency management and lifetime control.</li>
<li>An IoC container resolves and manages dependencies, offering varying control over object behavior.</li>
<li>We can categorize dependencies into stable and volatile, the latter justifying DI.</li>
<li>The lifetime of a service is Transient, Scoped, or Singleton.</li>
<li>Dependency injection allows us to avoid the Control Freak anti-pattern and stop creating objects with the <code>new</code> keyword, improving flexibility and testability.</li>
<li>The Service Locator pattern often creates hidden coupling and should be avoided but in the composition root.</li>
<li>The composition root is where we register our service bindings with the IoC container; in the <code>Program.cs</code> file.</li>
<li>Composing objects using the Strategy pattern alongside constructor injection facilitates handling complex object trees, emphasizing the principle of composition over inheritance.</li>
<li>On top of constructor injection, there’s also method injection and property injection, which are less supported. It is best to prioritize constructor injection over the others.</li>
<li>Guard clauses safeguard method execution from unmet conditions.</li>
<li>It is better to avoid the Singleton pattern in favor of binding a class and an interface with a singleton lifetime in the container.</li>
<li>The Factory pattern is ideal for creating objects with complex instantiation logic.</li>
<li>Moving code around doesn't eliminate dependencies or coupling; it's important not to overengineer solutions.</li>
</ul>
<p>In subsequent sections, we explore tools that add functionalities to the default built-in container. Meanwhile, we explore options, settings, and configurations in the next chapter. These ASP.NET Core patterns aim to make our lives easier when managing such common problems.</p>


<h2 data-number="9.9">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>What are the three DI lifetimes that we can assign to objects in ASP.NET Core?</li>
<li>What is the composition root for?</li>
<li>Is it true that we should avoid the <code>new</code> keyword when instantiating volatile dependencies?</li>
<li>What is the pattern that we revisited in this chapter that helps compose objects to eliminate inheritance?</li>
<li>Is the Service Locator pattern a design pattern, a code smell, or an anti-pattern?</li>
<li>What is the principle of composition over inheritance?</li>
</ol>


<h2 data-number="9.10">Further reading</h2>
<p>Here are some links to build upon what we have learned in the chapter:</p>
<ul>
<li>Moq: <a href="https://adpg.link/XZv8">https://adpg.link/XZv8</a></li>
<li>If you need more options, such as contextual injections, you can check out an open-source library I built. It adds support for new scenarios: <a href="https://adpg.link/S3aT">https://adpg.link/S3aT</a></li>
<li>Official documentation, Default service container replacement: <a href="https://adpg.link/5ZoG">https://adpg.link/5ZoG</a></li>
</ul>


<h2 data-number="9.11">Answers</h2>
<ol>
<li>Transient, Scoped, Singleton.</li>
<li>The composition root holds the code that describes how to compose the program’s object graph—the types bindings.</li>
<li>Yes, it is true. Volatile dependencies should be injected instead of instantiated.</li>
<li>The Strategy pattern.</li>
<li>The Service Locator pattern is all three. It is a design pattern used by DI libraries internally but becomes a code smell in application code. If misused, it is an anti-pattern with the same drawbacks as using the <code>new</code> keyword directly.</li>
<li>The principle of composition over inheritance encourages us to inject dependencies into classes and use them instead of relying on base class features and inheritance. This approach promotes flexibility and code reuse. It also negates the need for the LSP.</li>
</ol>


</body>
</html>
