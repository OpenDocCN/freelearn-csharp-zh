<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-51"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-52"><a id="_idTextAnchor052"/>Data Binding Building Blocks in .NET MAUI</h1>
<p>In the previous chapters, we familiarized ourselves with the core concepts of the MVVM pattern and explored the fundamentals of .NET MAUI. With the knowledge of MVVM principles and .NET MAUI’s capabilities, we can now start looking at how to apply MVVM to .NET MAUI.</p>
<p>Data binding, a crucial component in .NET MAUI, is the key enabler of the MVVM pattern. In this chapter, we <a id="_idIndexMarker182"/>will focus on the fundamental concepts, components, and techniques that facilitate data binding in .NET MAUI. These critical elements link the View and ViewModel layers of your application, enabling efficient communication and ensuring a clean separation of concerns.</p>
<p>In the course of this chapter, we will cover the following topics:</p>
<ul>
<li>Key components for data binding</li>
<li>Binding modes and the <strong class="bold">INotifyPropertyChanged</strong> interface</li>
<li>Handling interactions with the <strong class="bold">ICommand</strong> interface</li>
</ul>
<p>By the end of this chapter, you will have a solid understanding of the essential data-binding building blocks that come with .NET MAUI. This will help you understand the inner workings of data binding in .NET MAUI and what role each component plays. With this foundation in place, you will be well equipped to explore more advanced topics and techniques in the following chapters.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>Throughout this chapter, we will add functionality to the <strong class="bold">Recipes!</strong> app. All required assets needed to follow along, including all the code used in this chapter, can be found on GitHub at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter03</a>.</p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor054"/>Key components for data binding</h1>
<p>Let’s first turn our attention to the core components that enable data binding in .NET MAUI: <code>BindableObject</code>, <code>BindableProperty</code>, and <code>BindingContext</code>. These components work in harmony <a id="_idIndexMarker183"/>to establish and manage the connections between your Views and ViewModels. Understanding the role and functionality of these elements is crucial, as they form the backbone of data binding in .NET MAUI.</p>
<p>Let’s quickly discuss the elements that play a role in data binding.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor055"/>Elements of data binding</h2>
<p>Before we dive into the key components, let’s go through the elements that we need to understand to effectively <a id="_idIndexMarker184"/>work with data binding in .NET MAUI applications. These elements play a vital role in facilitating communication between the View and ViewModel layers, enabling seamless synchronization of data and user interactions:</p>
<ul>
<li><code>INotifyPropertyChanged</code> interface. This interface <a id="_idIndexMarker185"/>ensures that the View is notified whenever the data in the ViewModel changes, allowing the UI to update accordingly. It’s essential to understand that implementing the <code>INotifyPropertyChanged</code> interface is not strictly required for a property to act as a binding source. In fact, any property, regardless of its enclosing class implementing <code>INotifyPropertyChanged</code> or not, can serve as a binding source.</li>
<li><code>BindableProperty</code> on a UI element – or another <code>BindableObject</code> – that you may want to connect to the binding <a id="_idIndexMarker186"/>source. In .NET MAUI, most UI elements, such as labels, text boxes, and buttons, derive from the <code>Microsoft.Maui.Controls.BindableObject</code> class, which enables them to serve as a binding target. As opposed to the binding source, not every property can be <a id="_idIndexMarker187"/>a binding target, only properties of type <code>BindableProperty</code> on a class that inherits from a <code>BindableObject</code>.</li>
<li><strong class="bold">Binding context</strong>: The binding context establishes the relationship between the ViewModel and the View. It serves as a reference point for the data binding engine, providing a <a id="_idIndexMarker188"/>connection to the ViewModel instance. The binding context is usually set at the page level or on individual UI elements. By default, child elements inherit the context from their parent.</li>
<li><strong class="bold">Binding path</strong>: The binding path is an expression that specifies the property of the <a id="_idIndexMarker189"/>binding source that need to be bound to the binding target. In the simplest case, the binding path refers to a single property name in the ViewModel, but it can also include more complex expressions, such as property chains or indexers. The combination of the binding path and the binding context form the binding source.</li>
<li><strong class="bold">Binding mode</strong>: The binding mode determines the direction of data flow between the binding <a id="_idIndexMarker190"/>source and target, as we saw earlier in <a href="B20941_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is the MVVM </em><em class="italic">Design Pattern?</em></li>
<li><strong class="bold">ValueConverter</strong>: A value converter modifies the data between the ViewModel and the View <a id="_idIndexMarker191"/>and vice versa. It allows us to convert the data value that is being bound and is particularly useful when the ViewModel’s data type does not match the data type expected by the UI element in the View.</li>
</ul>
<p>Throughout this and <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .NET MAUI</em>, all aspects of data binding will be thoroughly discussed.</p>
<p>Let’s first take a look at the core component that makes data binding possible in .NET MAUI.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>BindableObject</h2>
<p>In .NET MAUI, the <code>Microsoft.Maui.Controls.BindableObject</code> class is the base class for <a id="_idIndexMarker192"/>objects that leverage data binding. It provides <a id="_idIndexMarker193"/>the foundation to enable data binding with UI elements and other objects by implementing essential properties, methods, and events related to the binding process. It is, in fact, the cornerstone of data-binding functionality in .NET MAUI, which is a crucial component of applying the MVVM pattern. It allows us to connect the View and the ViewModel, allowing them to communicate and stay in sync with each other without direct coupling.</p>
<p>Most UI elements <a id="_idIndexMarker194"/>in .NET MAUI, such as labels, buttons, and <a id="_idIndexMarker195"/>text boxes, are derived from the <code>BindableObject</code> class. This inheritance enables these elements to participate in data binding.</p>
<p>In essence, the <code>BindableObject</code> stores instances of <code>Microsoft.Maui.Controls.BindableProperty</code> and manages the <code>BindingContext</code>. These are crucial aspects to enable effective data binding, which in turn fosters seamless communication between the View and ViewModel, facilitating MVVM.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>BindableProperty</h2>
<p><code>BindableProperty</code> is a special kind of property that can act as a binding target. It basically is an advanced <a id="_idIndexMarker196"/>CLR property, a property on steroids, if you will. Ultimately, a <a id="_idIndexMarker197"/>bindable property serves as a container for storing data related to the property, such as its default value and validation logic. It also provides a mechanism to enable data binding and property change notifications. It is associated with a public instance property, which serves as the interface for getting and setting the value of the bindable property. Many properties of UI elements in .NET MAUI are bindable properties, which allows us to set their values through data binding or using styles.</p>
<p>As an example, let’s look at the <code>Text</code> property of <code>Label</code>:</p>
<pre class="source-code">
public partial class Label : View ...
{
    ....
    public static readonly BindableProperty TextProperty =
        BindableProperty.Create(nameof(Text),
            typeof(string), typeof(Label), default(string),
            propertyChanged: OnTextPropertyChanged);
    ...
    public string Text
    {
        get { return (string)GetValue(TextProperty); }
        set { SetValue(TextProperty, value); }
    }
    static void OnTextPropertyChanged(
        BindableObject bindable,
        object oldvalue, object newvalue)
    {
        ...
    }
    ...
}</pre> <p>Let’s start by <a id="_idIndexMarker198"/>looking at the <code>Text</code> property. This is just a CLR property, but <a id="_idIndexMarker199"/>instead of storing and retrieving the value from a backing field, it does the following:</p>
<ul>
<li>The getter retrieves the value by calling the <code>GetValue</code> method, passing in <code>TextProperty</code>. This <code>GetValue</code> method is a method on the <code>BindableObject</code> base class that <code>Label</code> inherits from.</li>
<li>The setter calls the <code>SetValue</code> method of <code>BindableObject</code>, passing in <code>TextProperty</code> and the given value.</li>
</ul>
<p>The <code>TextProperty</code> used in the <code>GetValue</code> and <code>SetValue</code> methods is a <code>BindableProperty</code>. It’s static and belongs to the <code>Label</code> class. As mentioned earlier, <code>BindableProperty</code> is a sort of “container” that holds various bits of information about the property, including its value.</p>
<p>Let’s break <a id="_idIndexMarker200"/>down this <code>TextProperty</code>. This property is defined as a public <a id="_idIndexMarker201"/>static field of type <code>BindableProperty</code>. It is instantiated by calling the <code>BindableProperty.Create</code> method, passing in the following values:</p>
<ul>
<li><code>BindableProperty</code> field. In this particular case, <code>nameof(Text)</code> is used to refer to the <code>Text</code> property of the <code>Label</code> class.</li>
<li><code>Type</code> and defines the data type of the property that the bindable property is referring to. As the <code>Text</code> property is of type <code>string</code>, <code>typeof(string)</code> is passed in as a value.</li>
<li><code>Type</code>. It refers to the owner type of the property, which is the class that the property belongs to. In this particular example, the <code>Text</code> property is defined in the <code>Label</code> class, so this type is passed as a value.</li>
<li><code>defaultValue</code> parameter, which is of type <code>object</code>. This parameter is optional and allows us to provide a default value to the bindable property. In this case, <code>default(string)</code> is passed, which means <code>NULL</code> will be the default value.</li>
<li><strong class="bold">OnTextpropertyChanged</strong>: Optionally, we can provide a delegate that needs to be called when the value of the property changes.</li>
</ul>
<p>The <code>BindableProperty.Create</code> method has a lot more optional parameters that you can provide if needed.</p>
<p class="callout-heading">More about bindable properties</p>
<p class="callout">In <a href="B20941_11.xhtml#_idTextAnchor182"><em class="italic">Chapter 11</em></a>, <em class="italic">Creating MVVM-Friendly Controls</em>, we will look at building our own controls. Understanding the concept of a <code>BindableProperty</code> is essential when it comes to creating MVVM-friendly controls. So, you can expect to dive deeper into this in that chapter.</p>
<p>The concept of a <code>BindableProperty</code> can be a little overwhelming or hard to understand to start <a id="_idIndexMarker203"/>with. For now, just remember that all of the UI elements inherit <a id="_idIndexMarker204"/>from <code>BindableObject</code> and that many of their properties are bindable properties, allowing us to use them as a binding target.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor058"/>BindingContext</h2>
<p>A <code>BindableObject</code> has a <code>BindingContext</code> property of type <code>object</code>, which acts as the glue between the <a id="_idIndexMarker205"/>binding source and the binding <a id="_idIndexMarker206"/>target. It points the data binding engine to an instance of a class that serves as the binding source. When you set the <code>BindingContext</code> property on a <code>BindableObject</code>, such as a .NET MAUI page or a UI element, you are specifying the source object for data binding expressions within that object’s scope. Child elements within that scope will inherit the <code>BindingContext</code> by default unless a different <code>BindingContext</code> is explicitly set for them.</p>
<p>When the <code>BindingContext</code> is set on a <code>BindableObject</code>, the data-binding engine will resolve all bindings having their <code>Source</code> set to the <code>BindingContext</code>. Also, when the value of the <code>BindingContext</code> property changes, these bindings are reevaluated using the updated <code>BindingContext</code>.</p>
<p>Now that we’ve discussed all the core components that allow us to do data binding in .NET MAUI, let’s see how to define and use them.</p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor059"/>Data binding in practice</h2>
<p>Before we can start <a id="_idIndexMarker207"/>writing our data binding, we first need to add our ViewModels to our solution. In order to fully embrace the separation of concerns, let’s put them into a separate project:</p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click on your solution and select <strong class="bold">Add</strong> | <strong class="bold">New Project…</strong>.</li>
<li>Select <strong class="bold">Class Library</strong> from the list of project templates and click <strong class="bold">Next</strong>.</li>
<li>Enter <code>Recipes.Client.Core</code> under <strong class="bold">Project name</strong> and click <strong class="bold">Next</strong>.</li>
<li>Select <code>.NET 8.0</code> as <strong class="bold">Framework</strong> and click <strong class="bold">Create</strong>.</li>
</ol>
<p>Once the project <a id="_idIndexMarker208"/>is created, let’s delete <code>Class1.cs</code>, which was created by default. Next, we want to add our ViewModels to this project. In order to keep everything nice and organized, let’s first create a <code>ViewModels</code> folder to put all of our ViewModels in:</p>
<ol>
<li>Right-click <a id="_idIndexMarker209"/>on the <code>Recipes.Client.Core</code> project in the <code>ViewModels</code>.</li>
<li>Right-click on the newly added folder and select <code>RecipeDetailViewModel</code>, and add the following code:<pre class="source-code">
namespace Recipes.Client.Core.ViewModels;
public class RecipeDetailViewModel
{
    public string Title { get; set; } = "Classic Caesar Salad";
}</pre><p class="list-inset"><code>RecipeDetailViewModel</code> represents the details of a recipe. For now, it only contains a <code>Title</code> property, which we now give a hardcoded value of <code>"Classic </code><code>Caesar Salad"</code>.</p></li> </ol>
<p>Next, we need to add a reference to this <code>Recipes.Client.Core</code> project from the <code>Recipes.Mobile</code> project. To do this, simply right-click on the <code>Recipes.Mobile</code> project, select <code>Recipes.Client.Core</code> project.</p>
<p>As a very last step, before <a id="_idIndexMarker210"/>we dive into data binding, we need to add a new page to our <code>Recipes.Mobile</code> project:</p>
<ol>
<li>Right-click the project name and select <strong class="bold">Add</strong> | <strong class="bold">New Item…</strong>.</li>
<li>Select <code>RecipeDetailPage.xaml</code>.</li>
<li>Open <code>App.xaml.cs</code> and, in the constructor, assign an instance of <code>RecipeDetailPage</code> to the <code>MainPage</code> property:<pre class="source-code">
public App()
{
    InitializeComponent();
    <strong class="bold">MainPage = new RecipeDetailPage();</strong>
}</pre><p class="list-inset">This ensures that on startup, the mobile app will show our newly created <code>RecipeDetailPage</code>.</p></li> <li>Finally, in the code-behind of <code>RecipeDetailPage</code>, we need to assign its <code>BindingContext</code> property to <a id="_idIndexMarker211"/>an instance of <code>RecipeDetailViewModel</code>:<pre class="source-code">
using Recipes.Client.Core.ViewModels;
namespace Recipes.Mobile;
public partial class RecipeDetailPage : ContentPage
{
    public RecipeDetailPage()
    {
        InitializeComponent();
        <strong class="bold">BindingContext = new RecipeDetailViewModel();</strong>
    }
}</pre></li> </ol>
<p>Now, we can focus on <code>RecipeDetailPage</code> and start implementing some data bindings. Data bindings can be defined in code using C# and in XAML. Both have their cons and their pros, but essentially it comes down to preference. You can even mix and match both approaches if you want, although I wouldn’t recommend doing that. Most commonly, data bindings are defined in XAML, minimizing the amount of code in the code-behind. Nevertheless, let’s first see how we can define data bindings in C#.</p>
<h3>Data binding in C#</h3>
<p>Let’s go to <a id="_idIndexMarker212"/>our new <code>RecipeDetailPage.xaml</code> file and start updating some <a id="_idIndexMarker213"/>XAML:</p>
<ol>
<li>Remove any default XAML elements inside the <code>ContentPage</code> tag.</li>
<li>Add the following elements inside <code>ContentPage</code>:<pre class="source-code">
&lt;ScrollView&gt;
    &lt;VerticalStackLayout Padding="10"&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ScrollView&gt;</pre><p class="list-inset">We are keeping the UI very simple and straightforward for now. That’s why we are going to put everything in a <code>VerticalStackLayout</code>, which organizes child elements in a vertical stack. We’re surrounding the <code>VerticalStackLayout</code> with a <code>ScrollView</code> in order to make sure we get scrollbars when not everything fits on the screen.</p></li> <li>Add a <code>Label</code> to the <code>VerticalStackLayout</code> with the name <code>lblTitle</code>:<pre class="source-code">
&lt;Label <strong class="bold">x:Name="lblTitle"</strong>
    FontAttributes="Bold" FontSize="22" /&gt;</pre><p class="list-inset">This label will be showing the recipe’s title.</p></li> <li>In the code-behind, within the constructor of <code>RecipeDetailPage</code>, we can now add data-binding code so that the value of the <code>Title</code> property of the <code>RecipeDetailViewModel</code> is shown in the <code>lblTitle</code> label:<pre class="source-code">
lblTitle.SetBinding(
    Label.TextProperty,
    nameof(RecipeDetailViewModel.Title),
    BindingMode.OneWay);</pre><p class="list-inset">Because we <a id="_idIndexMarker214"/>have given the <code>Label</code> the name <code>lblTitle</code>, a <a id="_idIndexMarker215"/>field with this name is generated, which allows us to access this label from the code-behind. By calling the <code>SetBinding</code> method, we can define and apply a binding.</p></li> <li>Run the app and you should see the <code>Title</code> of <code>RecipeDetailViewModel</code>, which is currently hardcoded as <code>"Classic Caesar Salad"</code> on the screen.</li>
</ol>
<p>By looking at the first data binding we’ve just implemented, you should be able to identify most of the data binding elements we’ve discussed earlier:</p>
<ul>
<li><code>SetBinding</code> method is a method on the <code>BindableObject</code> class. The first parameter the <code>SetBinding</code> method needs is a <code>BindableProperty</code>. In this case, we are passing in the static <code>Label.TextProperty</code>, which corresponds to the <code>Text</code> instance property of a <code>Label</code>. The instance of the <code>BindableObject</code> we are calling the <code>SetBinding</code> method on, together with the <code>BindableProperty</code> we’re specifying as the first parameter, form the binding target.</li>
<li><code>SetBinding</code> method expects is the property path to bind to. This, together with the <code>BindingContext</code>, forms the binding source – but what is the <code>BindingContext</code> in this case? As we don’t explicitly specify the <code>BindingContext</code> on the <code>Label</code>, the <code>BindingContext</code> is inherited from <code>lblTitle</code>’s parent, which is <code>RecipeDetailPage</code>. Therefore, the <code>BindingContext</code> of the label is also the instance of <code>RecipeDetailViewModel</code>.</li>
<li><code>BindingMode</code> is the third parameter in this example. This one, however, is optional. In this case, we are setting the <code>BindingMode</code> to <code>OneTime</code>. In <a href="B20941_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is the MVVM Design Pattern?</em>, we briefly discussed different binding modes, and we will discuss binding modes in a bit more depth later on in this chapter.</li>
</ul>
<p>Defining data binding in code is quite easy and straightforward. However, most of the time, data bindings <a id="_idIndexMarker216"/>are defined in XAML. Personally, I think defining them in XAML <a id="_idIndexMarker217"/>feels more natural and requires less context switching when creating your UI with XAML. So, let’s have a look!</p>
<h3>Data binding in XAML</h3>
<p>As we are going to write <a id="_idIndexMarker218"/>our data binding in XAML, we can delete or comment out the binding code <a id="_idIndexMarker219"/>that we added to the constructor of <code>RecipeDetailPage</code> in <em class="italic">step 4</em> of the previous section.</p>
<p>We can now switch to <code>RecipeDetailPage.xaml</code> and update the label by removing the <code>x:Name</code> property <a id="_idIndexMarker220"/>and adding the <code>Text</code> property, which contains a <strong class="bold">Binding </strong><strong class="bold">markup extension</strong>:</p>
<pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    <code>x:Name</code> property. Of course, if you need a reference to the label for any other reason (for example, you have some animation logic in the code-behind that animates the label), you need to keep the <code>x:Name</code> property.</p>
<p>But more importantly, let’s take a look at the <code>Binding</code> markup extension that we’ve set to the <code>Text</code> property of the label.</p>
<p class="callout-heading">XAML markup extensions</p>
<p class="callout">XAML markup extensions are a feature of XAML that allows you to provide values for properties during the <a id="_idIndexMarker221"/><a id="_idIndexMarker222"/>parsing of the XAML markup more dynamically and flexibly. Markup extensions use curly braces (<code>{}</code>) to enclose their syntax and enable you to add more complex logic or functionality to the XAML itself.</p>
<p class="callout">Markup extensions can be used to reference resources, create bindings, or even instantiate objects, among other things. They allow you to extend the capabilities of the XAML language.</p>
<p class="callout">A lot more <a id="_idIndexMarker223"/>about markup extensions can be found in the docs: <a href="https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions">https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions</a>.</p>
<p>The <code>Binding</code> markup extension is used to create a data binding between the <code>Text</code> property of the label and the <code>Title</code> property of the binding source. The binding source, in this case, is an instance of <code>RecipeDetailViewModel</code>, which is set as the <code>BindingContext</code> of the control’s parent, <code>RecipeDetailPage</code>.</p>
<p>The <code>Path=Title</code> part <a id="_idIndexMarker224"/>of the binding expression specifies that the <code>Title</code> property <a id="_idIndexMarker225"/>from the binding source should be used as the source of the binding. In this scenario, you can omit <code>Path=</code> and simply use <code>Title</code>, as the binding expression is smart enough to recognize it as a property path. So, the binding expression can be written as follows:</p>
<pre class="source-code">
&lt;Label
    FontAttributes="Bold"
    FontSize="22"
    <code>Mode=</code>, we can indicate the binding mode, just like we did in the previous example; we’re setting it to <code>OneTime</code> in this example.</p>
<p>Apart from <code>Path</code> and <code>Mode</code>, there are more properties to the binding markup extension, such as <code>Source</code>, which allows us to point to another binding source, <code>Converter</code>, <code>TargetNullValue</code>, and others. <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .NET MAUI</em>, will cover all of this in much more detail.</p>
<p>Now, let’s take a look at the different binding modes in more detail and how to reflect changes from the binding source automatically in the binding target.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Binding modes and the INotifyPropertyChanged interface</h1>
<p>In <a href="B20941_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">What Is the MVVM Design Pattern</em>, we already discussed how data can flow:</p>
<ul>
<li><strong class="bold">One-way</strong>: From ViewModel to View</li>
<li><strong class="bold">One-way-to-source</strong>: From View to ViewModel</li>
<li><strong class="bold">One-time</strong>: Only once from ViewModel to View</li>
<li><strong class="bold">Two-way</strong>: From ViewModel to View and from View to ViewModel</li>
</ul>
<p>Now, let’s take a look at how this is handled in .NET MAUI.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor061"/>Binding modes in .NET MAUI</h2>
<p>.NET MAUI supports <a id="_idIndexMarker226"/>all of these data flows, represented <a id="_idIndexMarker227"/>through the <code>Microsoft.Maui.Controls.BindingMode</code> enum: <code>OneWay</code>, <code>OneWayToSource</code>, <code>OneTime</code> and <code>TwoWay</code>. There is in fact a fifth value as well: <code>Default</code>. Remember when we talked about bindable properties earlier in this chapter? When creating a bindable property, there are some optional values we can set. One of those optional parameters is <code>defaultBindingMode</code>. This allows us to set a default binding mode on a bindable property. On <code>Entry</code>, for example, it makes sense to have the default binding mode on the <code>Text</code> property set to <code>TwoWay</code>, as it shows the value of the binding source, and the user is able to update the value as well. The <code>Text</code> property on a <code>Label</code>, on the other hand, is read-only, so the default binding mode there is <code>OneWay</code>. Now, going back to the <code>BindingMode</code> enum and more specifically, the <code>Default</code> value, when we don’t specify a binding mode or use <code>Default</code>, the data-binding engine will use the binding mode that is specified as the default one on the bindable property of the binding target.</p>
<p>In the context of data binding and the various binding modes in .NET MAUI, it’s crucial to have an efficient way <a id="_idIndexMarker228"/>to inform the UI about changes to the ViewModel’s <a id="_idIndexMarker229"/>properties. The <code>INotifyPropertyChanged</code> interface addresses this need by providing a mechanism for your ViewModel to notify the UI when a property value has been updated.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>INofityPropertyChanged</h2>
<p>The <code>INotifyPropertyChanged</code> interface, part of the <code>System.ComponentModel</code> namespace, allows your binding source to communicate property<a id="_idIndexMarker230"/> changes to the binding target. This interface isn’t specific to .NET MAUI; it’s part of the .NET <code>PropertyChanged</code> event when the object that is being bound to implements the <code>INotifyPropertyChanged</code> interface. When the event is triggered, the engine will update the UI accordingly.</p>
<p>To implement the <code>INotifyPropertyChanged</code> interface, your ViewModel must include a <code>PropertyChanged</code> event, which can be triggered whenever a property’s value changes. Furthermore, you typically create a method, usually called <code>OnPropertyChanged</code>, that triggers this event while providing the name of the altered property as a parameter. This method should be called within the property setter, immediately after the property value is updated:</p>
<pre class="source-code">
public class SampleViewModel : <strong class="bold">INotifyPropertyChanged</strong>
{
    private string _title = string.Emtpty;
    public string Title
    {
        get =&gt; _title;
        set
        {
            if(_title != value)
            {
                _title = value;
                <strong class="bold">OnPropertyChanged(nameof(Title));</strong>
            }
        }
    }
    public void <strong class="bold">OnPropertyChanged</strong>(string propertyName)
        =&gt;<strong class="bold"> PropertyChanged?.Invoke(this,</strong>
<strong class="bold">            new PropertyChangedEventArgs(propertyName));</strong>
    public event PropertyChangedEventHandler? <strong class="bold">PropertyChanged</strong>;
}</pre> <p>As you can see in the preceding sample, this <code>SampleViewModel</code> implements the <code>INotifyPropertyChanged</code> interface, which requires us to implement the <code>PropertyChanged</code> event of the <code>PropertyChangedEventHandler</code> type. The <code>PropertyChanged</code> event can easily be invoked by calling the <code>OnPropertyChanged</code> method and passing in the name of the property that has been changed. When looking at the <a id="_idIndexMarker232"/>code, in the setter of the <code>Title</code> property, the <code>OnPropertyChanged</code> method is called when a new value is assigned to the property’s backing field, passing in the name of the property. When calling the <code>PropertyChanged</code> event, the current instance of the <code>SampleViewModel</code> is passed-in as the sender through the <code>this</code> keyword, followed by an instance of <code>PropertyChangedEventArgs</code>, which requires the name of the updated property. Through this event, the data-binding engine gets notified about the updated property and can, depending on the data-binding mode, update the binding target automatically.</p>
<p><code>CallerMemberNameAttribute</code> is something that is very commonly used as an attribute on the <code>propertyName</code> parameter of the <code>OnPropertyChanged</code> method. This attribute automatically obtains the name of the method or property that calls the attributed <a id="_idIndexMarker233"/>method. This facilitates calling the <code>PropertyChanged</code> event from the property’s setter even more, as the name of the property doesn’t need to be explicitly passed as a parameter:</p>
<pre class="source-code">
public class SampleViewModel : INotifyPropertyChanged
{
    ...
    public string Title
    {
        get =&gt; _title;
        set
        {
            if(_title != value)
            {
                _title = value;
                <strong class="bold">OnPropertyChanged();</strong>
            }
        }
    }
    public void OnPropertyChanged<strong class="bold">([CallerMemberName]string? propertyName = null)</strong>
        =&gt; PropertyChanged?.Invoke(this,
            new PropertyChangedEventArgs(propertyName));
...
}</pre> <p>As the <code>Title</code> property calls the <code>OnPropertyChanged</code> method, without providing an explicit value as a <a id="_idIndexMarker234"/>parameter, the name of the caller  – <code>Title</code> in this case – will be passed in as a value. In <a href="B20941_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Community Toolkits</em>, we’ll see how we can eliminate a lot of the ceremony here when triggering the <code>PropertyChanged</code> event.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor063"/>Different binding modes in action</h2>
<p>In the example earlier in this chapter, we bound the <code>Title</code> property of our <code>RecipeDetailViewModel</code> one time to the <code>Text</code> property of a <code>Label</code>. This means that the binding source is set only when the <code>BindingContext</code> of the binding target is set or when the <code>BindingContext</code> is assigned a new instance. In the context of our current setup, <code>BindingContext</code>, the initial value of the <code>Title</code> property is bound right away. However, any subsequent changes made to the <code>Title</code> property (such as updating it after the ViewModel loads data) won’t be reflected in the UI due to the nature of one-time data binding. This won’t be a problem for us right now since we’re working with <a id="_idIndexMarker235"/>static data for demonstration purposes, but it’s something to be aware of in a real-world application. As we progress through this book, we will revise this binding mode to handle such situations more effectively.</p>
<p>Let’s add some more code and discuss the other binding modes. First, let’s add an additional <code>IngredientsListViewModel</code> and extend our <code>RecipeDetailViewModel</code> with a property of that type:</p>
<ol>
<li>In the <code>ViewModels</code> folder in the <code>Recipes.Client.Core</code> project and select <strong class="bold">Add</strong> | <strong class="bold">Class…</strong>.</li>
<li>Enter <code>IngredientsListViewModel.cs</code> as name and click <strong class="bold">Add</strong>.</li>
<li>Let the class implement the <code>INotifyPropertyChanged</code> interface and add the <code>OnPropertyChanged</code> method. Add the following code to the newly created class:<pre class="source-code">
public class IngredientsListViewModel : INotifyPropertyChanged
{
    public void OnPropertyChanged([CallerMemberName]string?  propertyName = null)
        =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    public event PropertyChangedEventHandler? PropertyChanged;}</pre><p class="list-inset">This is a typical implementation of the <code>INotifyPropertyChanged</code> interface with the <code>PropertyChangedEvent</code> and an <code>OnPropertyChanged</code> method that triggers the implemented <code>PropertyChhanged</code> event.</p></li> <li>Next, we can <a id="_idIndexMarker236"/>add the <code>NumberOfServings</code> property, as shown in the following snippet. For brevity, the implementation of the <code>INotifyPropertyChanged</code> interface is left out:<pre class="source-code">
public class IngredientsListViewModel : INotifyPropertyChanged
{
    private int _numberOfServings = 4;
    public int NumberOfServings
    {
        get =&gt; _numberOfServings;
        set
        {
            if(_numberOfServings != value)
            {
                _numberOfServings = value;
                OnPropertyChanged();
            }
        }
    }
...
    //ToDo: add list of Ingredients
}</pre><p class="list-inset"><code>IngredientsListViewModel</code> contains a list of all ingredients and the quantities of them that are needed for a particular recipe. It also contains a <code>NumberOfServings</code> property, which indicates the number of servings for which the listed ingredients and their quantities are intended. The user should be able to adjust <a id="_idIndexMarker237"/>the number of servings in the UI and see how the quantity of the ingredients is being updated according to the selected amount. We will add the list of ingredients later.</p></li> <li>Move over to <code>RecipeDetailViewModel</code> and add an <code>IngredientsList</code> property of type <code>IngredientsListViewModel</code> and assign it a new instance by default:<pre class="source-code">
public IngredientsListViewModel
        IngredientsList { get; set; } = new ();</pre><p class="list-inset">With this updated code in place, we can now go to <code>RecipeDetailPage</code> and focus on the XAML again. We want to update the UI to allow users to choose the desired number of servings. For this use case, we will create a <code>OneWay</code> and a <code>TwoWay</code> data binding.</p><p class="list-inset">Go to <code>RecipeDetail</code> and add the following XAML below the <code>Label</code> that shows the recipe’s title:</p><pre class="source-code">&lt;HorizontalStackLayout Padding="10"&gt;
    &lt;Label Text="Number of servings:"
        VerticalOptions="Center" /&gt;
    &lt;Label
        Margin="10,0" FontAttributes="Bold"
        <strong class="bold">Text="{Binding IngredientsList.NumberOfServings, Mode=OneWay}"</strong>
        VerticalOptions="Center" /&gt;
    &lt;Stepper
        BackgroundColor="{OnPlatform WinUI={StaticResource Primary}}"
        Maximum="8" Minimum="1"
        <strong class="bold">Value="{Binding IngredientsList.NumberOfServings, Mode=TwoWay}"</strong> /&gt;
&lt;/HorizontalStackLayout&gt;</pre></li> </ol>
<p>Let’s have a look <a id="_idIndexMarker238"/>at the binding statements that we’ve added through this code:</p>
<ul>
<li>The <code>Text</code> property of the label is bound to the <code>NumberOfServings</code> property using the following binding statement: <code>{Binding IngredientsList.NumberOfServings, Mode=OneWay}</code>. The label displays the currently selected number of servings. The <code>NumberOfServings</code> property is part of the <code>IngredientsList</code> property on <code>RecipeDetailViewModel</code>, which is why the binding path is set to <code>IngredientsList.NumberOfServings</code>.<p class="list-inset">Since the user can change the number of servings, we use the <code>OneWay</code> binding mode. This ensures that when the value of <code>NumberOfServings</code> is updated, the UI reflects the change accordingly.</p></li>
<li>The <code>Value</code> property of the <code>Stepper</code> control is bound to the <code>NumberOfServings</code> property using the following binding statement: <code>{Binding IngredientsList.NumberOfServings, Mode=TwoWay}</code>. <code>Stepper</code> allows the user to adjust the currently selected number of servings.<p class="list-inset">Since the user can change the number of servings and the ViewModel should update accordingly, we use the <code>TwoWay</code> binding mode. This ensures that not only the UI reflects the <code>NumberOfServings</code> property’s value but also that the ViewModel is updated when the user modifies the number of servings via the <code>Stepper</code> control.</p><p class="list-inset">Increments or decrements to the <code>NumberOfServings</code> property made using <code>Stepper</code> will be reflected in the previously discussed label due to <code>OneWay</code> binding, and the property triggers the <code>PropertyChanged</code> event.</p></li>
</ul>
<p>In the XAML code, both bindings target properties within the <code>IngredientsList</code> property. In this <a id="_idIndexMarker239"/>example, all child elements of <code>HorizontalStackLayout</code> are bound to properties of the <code>IngredientsList</code> property in <code>RecipeDetailViewModel</code>. Since child elements inherit the binding context from their parent, it’s possible to move the binding to the <code>IngredientsList</code> property one level up, if desired:</p>
<pre class="source-code">
&lt;HorizontalStackLayout Padding="10" <strong class="bold">BindingContext="{Binding IngredientsList}"</strong>&gt;
    &lt;Label Text="Number of servings:"
        VerticalOptions="Center" /&gt;
    &lt;Label
        Margin="10,0" FontAttributes="Bold"
        <strong class="bold">Text="{Binding NumberOfServings, Mode=OneWay}"</strong>
        VerticalOptions="Center" /&gt;
    &lt;Stepper
        BackgroundColor="{OnPlatform WinUI={StaticResource Primary}}"
        Maximum="8" Minimum="1"
        <strong class="bold">Value="{Binding NumberOfServings, Mode=TwoWay}"</strong>/&gt;
&lt;/HorizontalStackLayout&gt;</pre> <p>In the preceding example, we are binding the <code>BindingContext</code> of <code>HorizontalStackLayout</code> to the <code>IngredientsList</code> property of <code>RecipeDetailViewModel</code>. This allows us to simplify the binding statements on the child elements. Of course, you can only do this when all the child elements have the same binding source.</p>
<p>As a final example, let’s implement a <code>OneWayToSource</code> data binding in our <strong class="bold">Recipes!</strong> app. Here our aim is to <a id="_idIndexMarker240"/>show the allergen information for each recipe. As not everyone is interested in viewing this information, we will not show it by default. However, we want to allow the user to tick a box to get this information:</p>
<ol>
<li>Go to <code>RecipesDetailViewModel</code> and let it implement <code>INotifyPropertyChanged</code>:<pre class="source-code">
public class RecipeDetailViewModel : INotifyPropertyChanged
{
    ...
    public event PropertyChangedEventHandler? PropertyChanged;
}</pre></li> <li>Create an <code>OnPropertyChanged</code> method that accepts <code>propertyName</code> as a parameter and calls the <code>PropertyChanged</code> event, just like we did in <code>IngredientsListViewModel</code>:<pre class="source-code">
public void OnPropertyChanged([CallerMemberName] string? propertyName = null)
            =&gt; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));</pre></li> <li>Now, let’s add a <code>ShowAllergenInformation</code> property of type <code>bool</code>. This property will be <a id="_idIndexMarker241"/>responsible for the visibility of the allergen information on <code>RecipeDetailPage</code>:<pre class="source-code">
private bool _showAllergenInformation;
public bool ShowAllergenInformation
{
    get =&gt; _showAllergenInformation;
    set
    {
        if (_showAllergenInformation!= value)
        {
            _showAllergenInformation = value;
            OnPropertyChanged();
        }
    }
}</pre></li> <li>This property triggers the <code>PropertyChanged</code> event when its value changes. This allows us to bind it to the <code>IsVisible</code> property of a <code>VisualElement</code> so that whenever the value on the ViewModel changes, the UI element’s visibility is updated automatically.</li>
<li>Finally, we can go to <code>RecipeDetailPage</code> and add the following XAML between the label that shows the recipe’s title and the <code>HorizontalStackLayout</code> that is bound to <code>IngredientsList</code>:<pre class="source-code">
&lt;VerticalStackLayout Padding="10"&gt;
    &lt;HorizontalStackLayout&gt;
        &lt;Label
            FontAttributes="Italic"
            Text="Show Allergen information"
            VerticalOptions="Center" /&gt;
        &lt;CheckBox <strong class="bold">IsChecked="{Binding ShowAllergenInformation, Mode=OneWayToSource}"</strong> /&gt;
    &lt;/HorizontalStackLayout&gt;
    &lt;Label <strong class="bold">IsVisible="{Binding ShowAllergenInformation, Mode=OneWay}"</strong>
        Text="ToDo: add allergen information" /&gt;
&lt;/VerticalStackLayout&gt;
"Show Allergen Information"</strong>, followed by a checkbox that the user can toggle if they want to view the recipe’s allergen information. The <code>IsChecked</code> property is bound using the <code>OneWayToSource</code> mode to the <code>ShowAllergenInformation</code> property in the ViewModel. This means that when the user checks the box, the property will update accordingly.</pre><p class="list-inset">Additionally, we bind the same <code>ShowAllergenInformation</code> property using the <code>OneWay</code> mode to the <code>IsVisible</code> property of a label. This label will eventually display the allergen information. As a result, when the user toggles the checkbox, it updates the <code>ShowAllergenInformation</code> property in the ViewModel, which in turn triggers <code>PropertyChangedEvent</code>. This event will be picked up by the binding engine, which will update the <code>IsVisible</code> property of <a id="_idIndexMarker243"/>the label, allowing the allergen information to be displayed or hidden based on the user’s preference.</p></li> </ol>
<p class="callout-heading">INotifyPropertyChanged is not a requirement for the binding source</p>
<p class="callout">It is important to note that a binding target should always be a <code>BindableProperty</code> on a class that inherits from the <code>BindableObject</code>. The binding source, on the other hand, can be any property of any class. Most of the time, the binding source’s class implements the <code>INotifyPropertyChanged</code> interface, but that’s not a requirement. Only when using <code>OneWay</code> and <code>TwoWay</code> binding modes in scenarios where the values on the binding source can update and need to be reflected in the UI does the <code>INotifyPropertyChanged</code> interface need to be implemented. Alternatively, setting the <code>BindingContext</code> again would also update all the values, but that means everything needs to be reevaluated, which might not be a good idea.</p>
<p>Now that we’ve seen how .NET MAUI supports data binding and different binding modes, let’s see how we can handle user interactions.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Handling interactions with the ICommand interface</h1>
<p>In most applications, user interaction plays a vital role. Common interactions include clicking buttons, selecting items from a list, toggling switches, and more. To handle these interactions <a id="_idIndexMarker244"/>effectively while <a id="_idIndexMarker245"/>adhering to the MVVM pattern, it’s essential to utilize a robust mechanism that encapsulates the necessary logic within the ViewModel. The <code>ICommand</code> interface is designed specifically for this purpose, enabling you to manage user interactions in a clean and maintainable way while ensuring a clear separation of concerns between the View and the ViewModel. In this section, we’ll explore how to implement and use <code>ICommand</code> to handle user interactions in your .NET MAUI application.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>The ICommand interface</h2>
<p>The <code>ICommand</code> interface plays a crucial role in handling user interactions within the context of the MVVM pattern in .NET MAUI applications. <code>ICommand</code> is part of the <code>System.Windows.Input</code> namespace <a id="_idIndexMarker246"/>and allows you to encapsulate the logic for executing a specific action and determining whether that action can be executed in a ViewModel. Again, this interface isn’t specific to .NET MAUI; it’s an integral part of the .NET BCL.</p>
<p><code>ICommand</code> has two main members: <code>Execute</code> and <code>CanExecute</code>:</p>
<ul>
<li><strong class="bold">Execute (object parameter)</strong>: This method is what gets executed when the command <a id="_idIndexMarker247"/>is invoked. Through an optional parameter, additional data can be passed in if needed.</li>
<li><strong class="bold">CanExecute (object parameter)</strong>: This method indicates whether the command <a id="_idIndexMarker248"/>can be executed in its current state or not. Optionally, a parameter can be passed in if needed.</li>
</ul>
<p><code>ICommand</code> also exposes an event called <code>CanExecute</code> method changes, signaling the UI to re-evaluate whether the command can be executed. This enables automatic enabling/disabling of UI elements (such as buttons) based on the current state of the application.</p>
<p>To use <code>ICommand</code> in your ViewModel, you can create a custom command class that implements the <code>ICommand</code> interface or use a built-in command class such as <code>Microsoft.Maui.Controls.Command</code>. There are also third-party implementations available such as <code>CommunityToolkit.Mvvm.Input.RelayCommand</code> from the MVVM Toolkit, which we will dive into in more detail in <a href="B20941_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Community Toolkits</em>. Typically, these implementations contain a method called <code>ChangeCanExecute</code> or <code>NotifyCanExecuteChanged</code>, which is called the <code>CanExecuteChanged</code> event.</p>
<p>Now that you’re familiar with the <code>ICommand</code> interface and its role in a ViewModel, it’s time to see it in action.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Putting it into action</h2>
<p>As a simple <a id="_idIndexMarker249"/>demonstration, we want to allow users to add or remove a recipe as a favorite. For this, let’s add two buttons to <code>RecipeDetailPage</code>, right below the <code>VerticalStackLayout</code> that contains the <code>CheckBox</code> element to display the allergen information:</p>
<pre class="source-code">
&lt;VerticalStackLayout&gt;
    &lt;Button <strong class="bold">Command="{Binding AddAsFavoriteCommand}"</strong> Text="Add as favorite" /&gt;
    &lt;Button <strong class="bold">Command="{Binding RemoveAsFavoriteCommand}"</strong> Text="Remove as favorite" /&gt;
&lt;/VerticalStackLayout&gt;</pre> <p>The first button’s <code>Command</code> property binds to the <code>AddAsFavoriteCommand</code> property on our binding source, <code>RecipeDetailViewModel</code>. This button should allow a user to mark a recipe as a favorite when the recipe is not yet favorited. The second button does the exact opposite: it should allow a user to remove a recipe as a favorite. Let’s take a look at the implementation of both commands:</p>
<ol>
<li>In <code>RecipeDetailViewModel</code>, we can add an <code>IsFavorite</code> property:<pre class="source-code">
private bool _isFavorite = false;
public bool IsFavorite
{
    get =&gt; _isFavorite;
    private set
    {
        if (_isFavorite != value)
        {
            _isFavorite = value;
            OnPropertyChanged();
        }
    }
}</pre><p class="list-inset">This property holds a <code>bool</code> value to indicate whether the user has marked this recipe as a favorite or not.</p></li> <li>Next, we need to add the two commands, <code>AddAsFavoriteCommand</code> and <code>RemoveAsFavoriteCommand</code>:<pre class="source-code">
public ICommand AddAsFavoriteCommand
{
    get;
}
public ICommand RemoveAsFavoriteCommand
{
    get;
}</pre><p class="list-inset">These are the two properties of type <code>ICommand</code> that the <code>Command</code> properties of the buttons bind to.</p></li> <li>Now, we need to instantiate both commands. Whilst .NET contains an <code>ICommand</code> interface, it <a id="_idIndexMarker250"/>doesn’t contain a concrete implementation. .NET MAUI, on the other hand, does have one! In order to access this implementation from the <code>Recipes.Client.Core</code> project, we need to configure the project to use the .NET MAUI framework.<p class="list-inset">In the <code>Recipes.Client.Core</code> project. This should open up the associated <code>csproj</code> file, wherein you need to add <code>&lt;UseMaui&gt;true&lt;/UseMaui&gt;</code>:</p><pre class="source-code">
&lt;PropertyGroup&gt;
  &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
  &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
<strong class="bold">  &lt;UseMaui&gt;true&lt;/UseMaui&gt;</strong>
  &lt;Nullable&gt;enable&lt;/Nullable&gt;
&lt;/PropertyGroup&gt;</pre><p class="list-inset">This allows us to access .NET MAUI-specific libraries from our <code>Core</code> project, such as <code>Microsoft.Maui.Controls.Command</code>, which implements <code>ICommand</code>.</p></li> <li>In the <a id="_idIndexMarker251"/>constructor of <code>RecipeDetailViewModel</code>, we can now instantiate <code>AddAsFavoriteCommand</code> and <code>RemoveAsFavoriteCommand</code>:<pre class="source-code">
private void AddAsFavorite() =&gt; IsFavorite = true;
private void RemoveAsFavorite() =&gt; IsFavorite = false;
private bool CanAddAsFavorite()
    =&gt; !IsFavorite;
private bool CanRemoveAsFavorite()
    =&gt; IsFavorite;
public RecipeDetailViewModel()
{
<strong class="bold">    AddAsFavoriteCommand =</strong>
<strong class="bold">        new Command(AddAsFavorite, CanAddAsFavorite);</strong>
<strong class="bold">    RemoveAsFavoriteCommand =</strong>
<strong class="bold">        new Command(RemoveAsFavorite, CanRemoveAsFavorite);</strong>
}</pre><p class="list-inset">In this example, we have two commands on the ViewModel: <code>AddAsFavoriteCommand</code> and <code>RemoveAsFavoriteCommand</code>. Each command is created with an associated <code>Action</code> and a <code>Func&lt;bool&gt;</code> to determine its executability.</p><p class="list-inset"><code>AddAsFavoriteCommand</code> has an <code>AddAsFavorite</code> method as its action, which simply sets the <code>IsFavorite</code> property to <code>true</code>. Its <code>CanExecute</code> method is determined by the <code>CanAddAsFavorite</code> method, which returns <code>true</code> when the <code>IsFavorite</code> property has a value of <code>false</code>.</p><p class="list-inset">On the other<a id="_idIndexMarker252"/> hand, <code>RemoveAsFavoriteCommand</code> has a <code>RemoveAsFavorite</code> method as its action, which sets the <code>IsFavorite</code> property to <code>false</code>. The <code>CanRemoveAsFavorite</code> method is provided as the <code>CanExecute</code> check for this command, and it returns <code>true</code> when the <code>IsFavorite</code> property has a value of <code>true</code>.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that it is up to the control to check and adhere to the <code>CanExecute</code> method. It should not be a thing to blindly rely on, as it might not be implemented or work the way you expect. Make sure to read the control’s documentation and test it thoroughly.</p>
<p class="list-inset">In summary, when the <code>IsFavorite</code> property is <code>true</code>, only <code>RemoveAsFavoriteCommand</code> can be executed, while  <code>AddAsFavoriteCommand</code> cannot be. Conversely, when the <code>IsFavorite</code> property is <code>false</code>, <code>AddAsFavoriteCommand</code> can be executed, and <code>RemoveAsFavoriteCommand</code> cannot be. This ensures that the appropriate command is available for execution based on the current state of the <code>IsFavorite</code> property.</p>
<ol>
<li value="5">There is just one piece of the puzzle missing: whenever the <code>IsFavorite</code> property’s value changes, the <code>CanExecute</code> method of both commands needs to be re-evaluated. In order to do that, we need to update the setter of the <code>IsFavorite</code> property:<pre class="source-code">
if (_isFavorite != value)
{
    _isFavorite = value;
    OnPropertyChanged();
    <strong class="bold">((Command)AddAsFavoriteCommand).ChangeCanExecute();</strong>
    <strong class="bold">((Command)RemoveAsFavoriteCommand).ChangeCanExecute();</strong>
}</pre></li> </ol>
<p>With all this code in place, we can run the app again. By default, only the first button (bound to <code>AddAsFavoriteCommand</code>) is enabled when the recipe is not a user favorite. Upon clicking this button, the <code>IsFavorite</code> property is updated, and the <code>ChangeCanExecute</code> method is called for both commands. As a result, the first button becomes disabled, while the second button (bound to <code>RemoveAsFavoriteCommand</code>) is automatically enabled. This ensures that the correct button is <a id="_idIndexMarker253"/>enabled or disabled based on the <code>IsFavorite</code> property.</p>
<p>Alternatively, we could also use a single command and use a <code>CommandParameter</code> to handle the toggling of the <code>IsFavorite</code> property:</p>
<ol>
<li>For that, let’s add a new <code>SetFavoriteCommand</code> property of type <code>ICommand</code> and initialize it in the constructor of <code>RecipeDetailViewModel</code>:<pre class="source-code">
public RecipeDetailViewModel()
{
    ...
    SetFavoriteCommand =
        new Command&lt;bool&gt;(SetFavorite, CanSetFavorite);
}
private bool CanSetFavorite(bool isFavorite)
    =&gt; IsFavorite != isFavorite;
private void SetFavorite(bool isFavorite)
    =&gt; IsFavorite = isFavorite;</pre><p class="list-inset">By assigning the command to an instance of <code>Command&lt;bool&gt;</code>, we are specifying that we expect a parameter of type bool in both the <code>Execute</code> and <code>CanExecute</code> methods.</p></li> <li>In the setter of the <code>IsFavorite</code> property, we now need to call the <code>CanExecuteChanged</code> method of <code>SetFavoriteCommand</code>.</li>
<li>Finally, we can update <a id="_idIndexMarker254"/>the binding statements on both buttons:<pre class="source-code">
&lt;Button
    <strong class="bold">Command="{Binding SetFavoriteCommand}"</strong>
    <strong class="bold">CommandParameter="{x:Boolean true}"</strong>
    Text="Add as favorite" /&gt;
&lt;Button
    <strong class="bold">Command="{Binding SetFavoriteCommand}"</strong>
    <strong class="bold">CommandParameter="{x:Boolean false}"</strong>
    Text="Remove as favorite" /&gt;</pre><p class="list-inset">Both buttons call the same command, but they each pass in a different parameter, which gets passed to both the <code>Execute</code> and <code>CanExecute</code> methods.</p></li> </ol>
<p class="callout-heading">UseMaui and MVVM best practices</p>
<p class="callout">In this chapter, we introduced the <code>UseMaui</code> property in our <code>Core</code> project, which may seem to contradict our previous statements about ViewModels being framework-agnostic. While adhering to the MVVM pattern, it is recommended to keep the ViewModels free from any framework-specific dependencies. However, in this specific case, we have opted for a more practical approach to demonstrate an implementation of <code>ICommand</code> through the <code>Microsoft.Maui.Controls.Command</code> class. In a strictly MVVM-compliant scenario, you would want to avoid such dependencies in your ViewModels to ensure maximum flexibility and maintainability.</p>
<p class="callout">In <a href="B20941_05.xhtml#_idTextAnchor086"><em class="italic">Chapter 5</em></a>, <em class="italic">Community Toolkits</em>, we will take a look at the possibility of how to improve this code so that it follows these best practices more closely.</p>
<p>As a little extra, we also might want to display an icon indicating whether a recipe is a favorite or not. The visibility of this icon can be bound to the <code>IsFavorite</code> property. When toggling this <a id="_idIndexMarker255"/>property through the buttons and commands we’ve just created, the icon’s visibility will be updated as well:</p>
<ol>
<li>First, let’s add the <code>Chapter 03</code><code>/Assets/favorite.png</code> file to the <code>Resources/Images</code> folder in the <code>favorite.png</code> file. You might need to adjust the file type filter in the file picker popup to include <code>.</code><code>png</code> file.</li>
<li>In <code>RecipeDetailPage.xaml</code>, add the following XAML directly below the <code>Label</code> displaying the recipe’s title:<pre class="source-code">
&lt;Image
    Margin="5" HeightRequest="35"
    IsVisible="{Binding IsFavorite}"
    Source="favorite.png" WidthRequest="35" /&gt;</pre><p class="list-inset">Now when we tap the <strong class="bold">Add as favorite</strong> or <strong class="bold">Remove as favorite</strong> button, you should see the favorite icon appearing or disappearing.</p></li> </ol>
<p>The <code>ICommand</code> interface plays a vital role in implementing the MVVM. By encapsulating user interactions within commands, it promotes a clean separation of concerns between the View and ViewModel. This allows for more maintainable, testable, and modular code. As demonstrated, <code>ICommand</code>, along with its <code>CanExecute</code> functionality, ensures that the appropriate actions are available to users based on the application’s state, further enhancing the user experience. By leveraging <code>ICommand</code>, developers can effectively implement the MVVM pattern.</p>
<p>As we’ve explored the <code>ICommand</code> interface, you may be interested to know that there are additional tools <a id="_idIndexMarker256"/>and resources available for implementing MVVM in .NET MAUI. Thanks to the fantastic .NET and .NET MAUI community, various Community Toolkits provide even more support for the MVVM pattern in your projects.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we delved into the core components that enable the MVVM pattern in .NET MAUI. We discussed the essential building blocks, including <code>BindableObject</code>, <code>BindableProperty</code>, and <code>BindingContext</code>, and how they facilitate seamless communication between the View and ViewModel. Furthermore, we examined the importance of the <code>INotifyPropertyChanged</code> interface in notifying the UI of changes in ViewModel properties and demonstrated how the <code>ICommand</code> interface helps handle user interactions in a decoupled manner. By understanding these fundamental concepts, it becomes evident why .NET MAUI and the MVVM pattern are such a harmonious match.</p>
<p>As we move on to <a href="B20941_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Data Binding in .NET MAUI</em>, we will take a closer look at data binding, diving deeper into topics such as value converters, fallback values, element and relative binding, multi-bindings, and compiled bindings. This will enable you to leverage the full power of data binding. Let’s continue our journey!</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Bindable properties: <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties">https://learn.microsoft.com/dotnet/maui/fundamentals/bindable-properties</a></li>
<li>The <code>BindableObject</code> class: <a href="https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject">https://learn.microsoft.com/dotnet/api/microsoft.maui.controls.bindableobject</a></li>
<li>The <code>INotifyPropertyChanged</code> interface: <a href="https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged">https://learn.microsoft.com/dotnet/api/system.componentmodel.inotifypropertychanged</a></li>
</ul>
</div>
</div></body></html>