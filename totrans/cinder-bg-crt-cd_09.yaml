- en: Chapter 9. Enter Sound – Adding Sound and Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。进入声音 - 添加声音和音频
- en: In this chapter, we will talk a bit about the concept of sound in creative coding.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论创意编程中的声音概念。
- en: 'In this chapter we will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: How to load and play sound in Cinder
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Cinder中加载和播放声音
- en: How to modify sound in real time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实时修改声音
- en: How to use audio data to draw and animate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用音频数据来绘制和动画
- en: How to make use of live sound input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用实时声音输入
- en: Loading and playing a sound file
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和播放声音文件
- en: There are several ways of using sound in creative coding. One way is to use
    audio samples, another one is to use live input, and then there is the possibility
    of generating sound from scratch. Nevertheless, a lot more possibilities emerge
    when you start to combine all of these approaches.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在创意编程中，使用声音有几种方式。一种方式是使用音频样本，另一种方式是使用实时输入，然后还有从头生成声音的可能性。然而，当你开始组合所有这些方法时，会出现更多可能性。
- en: In this chapter, we will learn to load, play, and visualize audio files and
    capture live input. To get started, open TinderBox and make another project with
    the name `BasicAudio`. Open `xcode/BasicAudio.xcodeproj` (`vc10\BasicAudio.sln`
    on Windows). Open `BasicAudioApp.cpp` in the editor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何加载、播放和可视化音频文件以及捕获实时输入。要开始，打开TinderBox并创建一个名为`BasicAudio`的新项目。打开编辑器中的`xcode/BasicAudio.xcodeproj`（在Windows上是`vc10\BasicAudio.sln`）。在编辑器中打开`BasicAudioApp.cpp`。
- en: 'To use the basic audio features of Cinder, we have to import the appropriate
    libraries:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Cinder的基本音频功能，我们必须导入适当的库：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This particular one contains all the code that is needed to load and play back
    an audio file. Go and find your own audio file (`mp3` or `wav` will work), and
    place it in the project's `assets` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子包含了加载和回放音频文件所需的所有代码。去找你自己的音频文件（`mp3`或`wav`都行），并将其放置在项目的`assets`文件夹中。
- en: 'We will need an `audio::SourceRef` object for storing the reference to the
    audio source that we will use in our code. Add the following line to your class
    declaration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`audio::SourceRef`对象来存储我们将要在代码中使用的音频源的引用。将以下行添加到你的类声明中：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet into the `setup()` method implementation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`setup()`方法实现中：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will load the audio file into the computer memory as the `audio::Source`
    object and save a reference in the `src` variable. Then, we can play the sound
    by using the `audio::Output::play()` class method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把音频文件加载到计算机内存中作为`audio::Source`对象，并将引用保存在`src`变量中。然后，我们可以通过使用`audio::Output::play()`类方法来播放声音。
- en: Compile and run our application. You should hear the sound. There are some limitations
    with this way of playing the sound back. It is not possible to apply the loop
    control to it in any other way (except for setting and getting the volume).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。你应该能听到声音。以这种方式回放声音有一些限制。无法以任何其他方式（除了设置和获取音量）应用循环控制。
- en: Using tracks
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轨道
- en: The Cinder `Track` class provides more control over a sound file. Let's go over
    a couple of features of the `Track` class that we might use most often.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder的`Track`类提供了对声音文件更多的控制。让我们回顾一下`Track`类的一些我们可能最常使用的功能。
- en: 'To loop the loaded audio file, we will need to add a `Track` object to the
    `Output` object and save the returned track reference so that we can use it to
    control the sound later. Add a variable for storing the track reference in the
    class declaration:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要循环播放加载的音频文件，我们需要向`Output`对象添加一个`Track`对象，并保存返回的轨道引用，以便我们可以用它来控制声音。在类声明中添加一个用于存储轨道引用的变量：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Replace the code in the `setup()` method implementation with the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将`setup()`方法实现中的代码替换为以下内容：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will basically do the same as before for now, except that it will store
    the `audio::Source` pointer as a separate track in the `audio::Output` object.
    The `addTrack()` function has another parameter, `autoplay`, which is automatically
    set to `true` if we don''t provide the other value. Let''s try to set it to `false`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这基本上与之前相同，只是它将`audio::Source`指针作为单独的轨道存储在`audio::Output`对象中。`addTrack()`函数还有一个参数，`autoplay`，如果我们不提供其他值，它将自动设置为`true`。让我们尝试将其设置为`false`：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we set the `autoplay` parameter to `false`, audio file is not played after
    it is loaded. We can use this approach if we want the audio file to be played
    at some other point of the application flow. Use the following code to play it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`autoplay`参数设置为`false`，音频文件在加载后不会播放。如果我们想在应用程序流程的某个其他点播放音频文件，可以使用以下代码：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We used the arrow syntax here because the track reference is just a C++ pointer
    to the actual `Track` object. All other properties of the track are accessed in
    the same manner.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用箭头语法，因为音轨引用只是指向实际`Track`对象的C++指针。所有其他音轨属性都以相同的方式访问。
- en: We can add more than one track to the `Output` object by creating a new audio
    source object and adding it to the `audio::Output` pointer. We won't do it now,
    but keep in mind that this is possible in case we want to create some kind of
    multilayer audio application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的音频源对象并将其添加到`audio::Output`指针中，向`Output`对象添加多个音轨。我们现在不会这样做，但请记住，如果我们想创建某种多层级音频应用程序，这是可能的。
- en: Changing track parameters
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改音轨参数
- en: 'Next thing that we want to do is to make the audio file play again after it
    has finished playing. It is possible by setting the looping of the track to `true`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们想要做的是在音频文件播放完毕后再次播放。这可以通过将音轨的循环设置为`true`来实现：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will make the track loop infinite.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使音轨循环无限。
- en: Another thing that we might want to do is to change the track volume. You can
    think of the `Output` volume as the master volume and the `Track` volumes as individual
    track volumes of a mixer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想做的一件事是更改跟踪音量。你可以把`Output`音量看作是主音量，而`Track`音量则看作是混音器中各个音轨的独立音量。
- en: 'To change the volume, use the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改音量，请使用以下代码：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can use variables to dynamically change the volume of the sound. Let's do
    that for both master and track volumes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用变量动态地更改声音的音量。让我们为主音量和音轨音量都这样做。
- en: 'Add the following lines to the class declaration of the app:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到应用程序的类声明中：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With these lines of code, we declare two floats that will store the master and
    track volumes and a `mouseMove` method override of the `AppBasic` class that will
    let us respond to mouse movements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些代码行，我们声明了两个浮点数，用于存储主音量和跟踪音量，以及`AppBasic`类的`mouseMove`方法重写，这将使我们能够响应鼠标移动。
- en: 'Let''s go to the `setup()` method implementation and initialize the `masterVol`
    and `trackVol` variables, additionally change the raw values of `trackRef->setVolume()`
    and `audio::Output::setVolume()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到`setup()`方法实现，初始化`masterVol`和`trackVol`变量，此外更改`trackRef->setVolume()`和`audio::Output::setVolume()`的原始值：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the implementation of the `mouseMove` method at the end of the file, before
    the `CINDER_APP_BASIC()` call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，在`CINDER_APP_BASIC()`调用之前添加`mouseMove`方法的实现：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An `event` object of the type `MouseEvent` is passed to this method. We can
    get the current location of the mouse cursor at the time of the event as well
    as many other parameters that the `event` object holds. We will stick to the mouse
    `x` and `y` coordinates for now and use them for changing the volume.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类型为`MouseEvent`的事件对象传递给此方法。我们可以获取事件发生时鼠标光标的当前位置以及事件对象持有的许多其他参数。我们现在将坚持使用鼠标`x`和`y`坐标，并使用它们来更改音量。
- en: For changing the master volume, we are using the `x` coordinate. We are using
    the `y` coordinate for the track volume.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更改主音量，我们使用`x`坐标。我们使用`y`坐标来更改音轨音量。
- en: As volume of the sound in Cinder is defined in a range from `0.0f` to `1.0f`,
    we need to transform the mouse positions in this kind of form. To do that, we
    need to divide the actual mouse position with its maximum range that is the width
    and height of the window. So, if the mouse `x` position is `0` and window width
    is `100`, after dividing the coordinate with the window width (0/100) we get `0`.
    If the mouse `x` position is `100`, we get `1`. Additionally, if the mouse `x`
    position is `50`, we get `0.5` (50/100).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cinder中的音量定义在`0.0f`到`1.0f`的范围内，我们需要将鼠标位置转换为这种形式。为此，我们需要将实际鼠标位置除以其最大范围，即窗口的宽度和高度。因此，如果鼠标`x`位置是`0`且窗口宽度是`100`，在将坐标除以窗口宽度（0/100）后，我们得到`0`。如果鼠标`x`位置是`100`，我们得到`1`。另外，如果鼠标`x`位置是`50`，我们得到`0.5`（50/100）。
- en: As the mouse positions and window dimensions are returned as `int` values, we
    will need to cast one of the values to `float` for a successful floating point
    number operation. That is why there is `(float)` before the `event.getX()/getWindowWidth()`
    and `event.getY()/getWindowHeight()` parts of the code, it casts the `int` value
    returned by `event.getX()` to `float`. Finally, we set the master volume and track
    volume with `audio::Output::setVolume(masterVol);` and `trackRef->setVolume(trackVol);`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于鼠标位置和窗口尺寸以`int`值返回，我们需要将其中一个值转换为`float`以进行成功的浮点数运算。这就是为什么在代码的`event.getX()/getWindowWidth()`和`event.getY()/getWindowHeight()`部分前面有`(float)`，它将`event.getX()`返回的`int`值转换为`float`。最后，我们使用`audio::Output::setVolume(masterVol);`和`trackRef->setVolume(trackVol);`设置主音量和轨道音量。
- en: Compile and run our application. Move the mouse, you should hear how the volume
    of the sound is changing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。移动鼠标，你应该能听到声音的音量是如何变化的。
- en: 'Next useful feature that we might want to learn is jumping to a certain position
    of the time of the track. To do that, we will use the `mouseDrag` method of the
    `AppBasic` class. Let''s declare an override of it by adding the following line
    to the class declaration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可能想要学习的一个有用功能是跳转到轨道的某个特定位置。为此，我们将使用`AppBasic`类的`mouseDrag`方法。让我们通过在类声明中添加以下行来声明它的重写：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s implement that. Add the following code at the end of the file, before
    the `CINDER_APP_BASIC()` call:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现它。在文件的末尾，在`CINDER_APP_BASIC()`调用之前添加以下代码：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the application window's width is being mapped to the duration
    of the track. The `x` position of the mouse is being transformed to a specific
    time in the audio track. The `trackRef->setTime(time)` part of the code sets the
    position of the track playhead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，应用程序窗口的宽度被映射到轨道的持续时间。鼠标的`x`位置被转换成音频轨道中的特定时间。代码中的`trackRef->setTime(time)`部分设置了轨道播放头的位置。
- en: Compile and run our application. You should be able to do live seeking now.
    Click and drag to try that out.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序。你现在应该能够进行实时搜索了。点击并拖动来尝试一下。
- en: Visualizing audio
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化音频
- en: There is one important thing missing in our creative sound application—the visual
    side of it. Let's create a simple equalizer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的创意声音应用程序中，缺少一个重要的东西——它的视觉方面。让我们创建一个简单的均衡器。
- en: First, we will need to enable the PCM buffering of the audio track.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启用音频轨道的PCM缓冲。
- en: '**PCM** stands for **pulse code modulation** and it is a method for digitally
    representing sampled analog signals. An analog audio signal is the fluctuation
    of voltage inside a conductor. A digital representation of that are samples or
    bytes with floating point values usually from `-1` to `1`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**PCM**代表**脉冲编码调制**，它是一种数字表示采样模拟信号的方法。模拟音频信号是导体内部电压的波动。它的数字表示是样本或字节，通常具有从`-1`到`1`的浮点值。'
- en: In the world of audio sampling there is a term, sampling rate, which represents
    the amount of samples or values being sampled each second. The PCM values and
    sampling rate of an audio file determine its playback speed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在音频采样世界中，有一个术语，采样率，它表示每秒被采样的样本或值的数量。音频文件的PCM值和采样率决定了其播放速度。
- en: 'To enable PCM buffering and be able to read PCM values during application runtime,
    add the following code in the `setup()` method''s declaration before `trackRef->play()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用PCM缓冲并在应用程序运行时读取PCM值，请在`setup()`方法声明中`trackRef->play()`之前添加以下代码：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Second, we need a variable that will serve as a pointer to the track's PCM buffer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要一个变量，它将作为轨道PCM缓冲区的指针。
- en: A PCM buffer is the secret place in computer memory where the raw values of
    the sound wave coming out from our speakers reside. Before any sound is sent to
    the audio output, it is kept in the buffer for some time. When the sound is played,
    the buffer is cleared and filled again with new audio data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: PCM缓冲区是计算机内存中的一个秘密地方，其中存储着从我们的扬声器输出的原始声音波形的值。在任何声音发送到音频输出之前，它被保存在缓冲区中一段时间。当播放声音时，缓冲区被清除并再次用新的音频数据填充。
- en: 'We will need to access the PCM buffer to read the raw waveform values from
    it. Add the following line to the class declaration to add a variable that will
    serve as a reference to it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要访问PCM缓冲区以从中读取原始波形值。将以下行添加到类声明中，以添加一个作为其引用的变量：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Third, we need to get a copy of the most recent buffer in each frame. Add the
    following code to the `update()` method implementation:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我们需要在每个帧中获取最新缓冲区的副本。将以下代码添加到`update()`方法实现中：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, change the `draw()` method implementation as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `draw()` 方法实现修改如下：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and run our application, you should see an image as shown in the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行我们的应用程序，你应该会看到一个如图所示的图像：
- en: '![Visualizing audio](img/9564_09_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![可视化音频](img/9564_09_01.jpg)'
- en: Using audio input
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频输入
- en: 'How about using a microphone or line-in as the audio source? No problem. To
    make this possible, we will need to import the audio `Input` library:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用麦克风或线路输入作为音频源怎么样？没问题。为了实现这一点，我们需要导入音频 `Input` 库：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are going to extend our current application so that we can switch between
    live input and playback of the loaded file. We will need to declare two new variables
    for this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的当前应用程序，以便可以在实时输入和加载的文件播放之间切换。为此，我们需要声明两个新变量：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first variable represents our sound input, and we will use the second one
    as a switch.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个变量代表我们的声音输入，我们将使用第二个作为开关。
- en: 'Next, we have to initialize the `input` variable, so go to the `setup()` method
    implementation and add the following line there:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须初始化 `input` 变量，因此前往 `setup()` 方法实现并添加以下行：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This assigns the default audio input to the `input` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将默认音频输入分配给 `input` 变量。
- en: 'Let''s use the `mouseDown` method override and fill it with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `mouseDown` 方法重写并填充以下代码：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These lines of code handle the switching between live and loaded input. Every
    time the mouse is clicked, the `useInput` variable is inverted from `false` to
    `true` or vice versa. Depending on the value we get, we enable the live or loaded
    input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码处理实时和加载输入之间的切换。每次鼠标点击时，`useInput` 变量从 `false` 切换到 `true` 或相反。根据我们得到的值，我们启用实时或加载输入。
- en: 'Finally, replace the code in the `update()` method implementation as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `update()` 方法实现中的代码替换如下：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These lines of code get the current PCM buffer. If the `useInput` variable is
    set to `true`, we use the PCM buffer of the live input, if not, we use the PCM
    buffer of the loaded track.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码获取当前的 PCM 缓冲区。如果 `useInput` 变量设置为 `true`，我们使用实时输入的 PCM 缓冲区，如果不是，我们使用加载轨道的
    PCM 缓冲区。
- en: Compile and run the application. Click on the window to enable live input. Click
    again to return to the loaded sound.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行应用程序。点击窗口以启用实时输入。再次点击以返回到加载的声音。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we learned the basics of audio in Cinder. We learned how to
    load and play back an audio file, how to change its volume, and seek and visualize
    the PCM buffer. We also learned how to use live input audio data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Cinder 中音频的基础知识。我们学习了如何加载和播放音频文件，如何更改其音量，以及如何搜索和可视化 PCM 缓冲区。我们还学习了如何使用实时输入音频数据。
- en: With this knowledge, now we are able to create audio-reactive applications that
    are capable of analyzing almost any kind of sound in real time and provide high
    performance visual feedback. Audio analysis is a broad topic and you may want
    to study it further. Try to Google "FFT", "octave analysis", or "beat tracking",
    for example. It is also possible to use some kind of third-party audio processing
    library, if the features that Cinder provides in terms of audio processing are
    not enough for you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，现在我们能够创建音频反应式应用程序，能够实时分析几乎任何类型的音频并提供高性能的视觉反馈。音频分析是一个广泛的话题，你可能想进一步研究。例如，尝试搜索“FFT”、“分频分析”或“节拍跟踪”。如果你对
    Cinder 提供的音频处理功能不满意，也可以使用某种第三方音频处理库。
