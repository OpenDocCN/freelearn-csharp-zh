- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure Functions and Side Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 3*](B21069_03.xhtml#_idTextAnchor095)! Here, we’ll dive
    deep into the world of pure functions in C#. This chapter is all about helping
    you understand the concept of pure functions, their practical application, and
    how to use them effectively in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick breakdown of what to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies to minimize side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking pure functions with the `Pure` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you move through the content, keep an eye out for actionable insights and
    data-driven recommendations. Approach this chapter with an eagerness to learn;
    by the end, you’ll have a solid foundation to write efficient and clean C# programs.
  prefs: []
  type: TYPE_NORMAL
- en: As I recommended in the previous chapter, I propose that you check your level
    of knowledge and look at the following three tasks. If you have any doubts about
    how to solve them, it is better to read this chapter right now. And if you are
    100% sure that you can solve them with your eyes closed, maybe it will be more
    beneficial to proceed with the less familiar topics for now. Let’s jump right
    in!
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Refactoring to a pure function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Steve’s tower defense game calculates damage based on a global difficulty modifier.
    Refactor this function to make it pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Isolating side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game loads enemy data from a file, processes it, and updates the game state.
    Refactor this function to isolate its side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Using a Pure attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refactor the following method by making it a pure function and marking it with
    the `Pure` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If these tasks are easy, you might want to consider reading topics that are
    new to you first. If you have any questions or are not sure about the correct
    answers, don’t worry – next, we’ll dive into the concept of pure functions and
    side effects while using the characters from the previous chapter – Julia and
    Steve.
  prefs: []
  type: TYPE_NORMAL
- en: A week later, Julia called Steve and said that if he wanted to continue learning
    functional programming, he needed to understand the logic of pure functions and
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Pure functions are functions that have deterministic output and no
    observable side effects – in other words, no actions happen outside the given
    scope of a function. This makes them predictable and easy to test, as well as
    key attributes for efficient software development. In C# code, we do this through
    the use of immutability and keywords such as* `readonly`*,* `const`*, and* `static`*.
    Also, there is a special attribute for marking* *pure functions.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Wow! This is all very exciting, but I don’t understand any of it. Could
    you give me something to read* *about it?*'
  prefs: []
  type: TYPE_NORMAL
- en: Julia gave him articles and Steve began to read.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions are important in functional programming. They have two main
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deterministic output**: For any given input, a pure function will always
    yield the same output, making its behavior extremely predictable. This characteristic
    simplifies the process of testing and debugging since the output of the function
    is always consistent given the same set of inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No observable side effects**: A pure function does not influence or is influenced
    by an external state. This means it doesn’t modify any external variables or data
    structures, or even carry out I/O operations. The function’s sole effect is the
    computation it performs and the result it delivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two properties make pure functions similar to mathematical functions.
    A mathematical function, *f(x) = y*, produces a result, *y*, that relies solely
    on the input, *x*, and doesn’t alter or is altered by anything outside of the
    function. In programming, a pure function can be seen as a self-contained unit
    that transforms input into output without any interference from or to the external
    world.
  prefs: []
  type: TYPE_NORMAL
- en: By adhering to these properties, pure functions facilitate the creation of code
    that is more robust, maintainable, and less prone to bugs. Let’s examine these
    benefits and practical examples of pure functions further.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a function that determines how many books need to be printed to reach
    a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function always gives the same result with the same inputs and doesn’t
    change anything outside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example can be filtering out books of a particular genre:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function is also pure. If you give it the same list of books, it will always
    return the same list of titles.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pure functions offer several significant advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictability and ease of testing**: Due to their deterministic nature,
    pure functions are highly predictable, making it easy to write unit tests. You
    always know what output to expect for a specific input, and there’s no need to
    mock or set up external dependencies for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reusability and modularity**: Pure functions, when designed to focus
    on a specific task in line with the single-responsibility principle, become highly
    reusable. As they don’t depend on external states, you can move these functions
    without worrying about breaking the code or enhancing its modularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of debugging and maintenance**: Without shared state or side effects,
    debugging pure functions is just a breeze. If there’s an issue, it’s usually within
    the function itself, making it easy to spot and fix. The isolation of pure functions
    also facilitates maintenance and updates as you can change a function without
    affecting other parts of your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons of pure functions and non-pure functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When analyzing pure functions alongside non-pure functions, the strengths and
    weaknesses of each become evident. To illustrate, let’s examine Konstatos’ tower
    defense mobile game as an example. In this game, different units take different
    amounts of damage from towers based on their defense against each type of tower.
    Each unit class can have a dictionary that contains these damage changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To figure out the damage a tower does to a unit, the unit class has a function
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At first, you might think this function is pure. But because it uses the `_damageModifiers`
    variable, which can change, the output can also change, even if the input stays
    the same. This means the function depends on something outside of it, which isn’t
    good for pure functions. This can lead to mistakes and makes testing and fixing
    problems harder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can make the function pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, by giving `damageModifiers` directly to the function, it doesn’t depend
    on anything outside of it. This means that if you give it the same input, you’ll
    always get the same output.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering if it makes sense to give a dictionary to a function
    when the function can already see it. That’s a fair point. But doing it this way
    means the function doesn’t secretly rely on something other than its parameters,
    which makes our code cleaner and easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the distinctions between these two types of functions and prioritizing
    the use of pure functions can enhance your code’s quality. As you delve deeper
    into functional programming in C#, this understanding will prove invaluable. Up
    next, we’ll discuss side effects in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on his tower defense game, Steve noticed some unexpected behavior.
    Units were taking inconsistent damage from towers. After some investigation, he
    realized the damage calculation function relied on a global variable that could
    change unpredictably - a classic side effect.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects in programming refer to any application state changes that occur
    outside the function being executed. These changes could include modifying a global
    or static variable, changing the original value of function parameters, performing
    I/O operations, or even throwing an exception. Side effects make the behavior
    of a function dependent on the context, reducing predictability and potentially
    increasing bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Common sources of side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing code, it’s good to know where side effects might come from. Side
    effects can make code unpredictable. Let’s break down some common sources.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Problem: Using global variables can lead to unexpected changes. If a function
    changes a global variable, it can affect other parts of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`UpdateUserScore` changes the `UserScores` dictionary. Since this dictionary
    is accessible everywhere, other functions might also change it. This makes our
    function unpredictable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: Instead of global variables, it’s better to use function arguments
    or put the state inside objects. For example, here, as we did before, it is better
    to pass the dictionary as a parameter to eliminate the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: The out and ref parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Problem: Using `out` and `ref` in C# can change the original data that’s given
    to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `UpgradeTower` method not only updates the `Damage` and `Hitpoints` values
    but also changes the reference so that it no longer points to the original `Tower`
    object. Of course, it is almost impossible to see code like this in real life;
    usually, it isn’t so straightforward and is hidden inside other methods. This
    code is a simplified and slightly ugly version of real code to show you the idea
    behind using `ref` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: Instead of changing the data, it’s a good idea to return a new value.
    Here, we could rename the method to `GetLeveledUpTower` and make it return a new
    tower.'
  prefs: []
  type: TYPE_NORMAL
- en: I/O operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Problem: Doing things such as saving to a file or a database will change data
    outside your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `SaveGameProgressToFile` function saves game progress data to a file. This
    kind of action can fail if, for example, there’s no space left on the disk. So,
    it’s a side effect because it relies on something outside our function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: It’s helpful to keep logic separate from actions such as saving data.
    This makes the code clearer and easier to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Problem: Consider a function that calculates the damage dealt by a tower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `CalculateDamage` function throws an exception if the tower or unit is `null`.
    Throwing an exception changes the regular flow of our program. If not handled,
    it can terminate the application or lead to unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution: The best way to go here is to use the `Either` monad. However, before
    we discuss it, you can use a nullable type called `double?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this `CalculateDamage` method, if the tower or unit is `null`, the method
    returns `null`; otherwise, it calculates the damage and returns it. This way,
    we avoid the side effect of breaking the flow with exceptions for common scenarios.
    However, the code that uses this method must be also modified so that it can handle
    the situation when `null` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how exceptions can be a source of side effects helps in making design
    choices that keep our C# code clearer and more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences of side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The presence of side effects in your code can lead to various issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decreased predictability**: Functions with side effects are less predictable
    because their output can change based on the external state. This decreased predictability
    makes it harder to understand what a function does just by looking at it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased difficulty in testing and debugging**: Functions with side effects
    are harder to test since they require the correct external state to produce the
    expected result. Debugging is also more complex because an issue in the function
    could be due to an external state change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency issues**: Concurrency problems can arise when multiple threads
    access and modify shared state simultaneously, leading to unexpected results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although it might not look instantly bad, with time, these consequences tend
    to snowball, making your project very expensive to develop and support.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to minimize side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While side effects in real-world applications are unavoidable, the key is to
    control and isolate them to make your code more manageable and predictable. This
    section focuses on strategies to minimize side effects by using `readonly`, `const`,
    `static`, and immutability in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Favor immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Immutability is a powerful way to minimize side effects. Immutable objects
    are objects whose state can’t be changed after they’re created. In C#, strings
    are a prime example of immutability. Every operation on a string results in a
    new string, and the original string remains unchanged. This principle can be expanded
    to other data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, `originalBook` is created as an instance of `Book` with
    a specific title and author and `updatedBook` is a new instance of `Book` that
    was created using the `with` expression. The `with` expression is used to create
    a new record with some properties modified from an existing record. Here, it creates
    a new `Book` value with the same `Title` value as `originalBook` but with `Author`
    set to `"Robert` `C. Martin"`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach maintains immutability because `originalBook` remains unchanged,
    and any “modification” results in a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: Use readonly and const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`readonly` and `const` are two keywords in C# that can make your fields and
    variables unchangeable, thereby reducing the potential for side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const` variables are implicitly static and should be used when the value is
    known at compile time and will never change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, `readonly` variables can be either instance-level or static,
    and their values can be set at runtime (for instance, inside constructors), but
    not changed afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use functional programming principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programming principles are designed to help minimize side effects.
    Besides pure functions and immutability, principles such as expressions over statements,
    the use of higher-order functions, and function composition can also aid in this
    mission. While we are already acquainted with the former, higher-order functions
    and function composition will be discussed in later chapters. So, let’s just keep
    moving – applying these principles can greatly enhance the predictability and
    maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulate side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When side effects are unavoidable, it’s crucial to isolate them. For instance,
    if a function must write to a file, that should be its sole responsibility. All
    other logic should be separated into pure functions as much as possible. This
    way, the side effects are contained, and the rest of your code remains unaffected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The idea here is to isolate side effects, making them predictable, visible,
    and manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to minimize side effects are key to building reliable, efficient,
    and maintainable software. By implementing these strategies, we inch closer to
    the functional programming paradigm, harnessing its strengths and benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll discuss how to use the `Pure` attribute to mark pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Marking pure functions with the Pure attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the role of pure functions and side effects in our code is crucial
    for effective functional programming in C#. But how do we communicate our intent
    that a function should be pure? This is where the `Pure` attribute comes into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Pure attribute in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, the `Pure` attribute is defined in the `System.Diagnostics.Contracts`
    namespace and serves as a declarative tag to indicate that a method is pure. A
    pure method is one that, given the same inputs, will always return the same output
    and does not produce any observable side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the `Pure` attribute is primarily intended for
    use in code contracts and static checking tools. The runtime and compiler don’t
    enforce the purity of a method, and this attribute does not change the method’s
    behavior in any way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a function that calculates the royalty amount for a
    book based on its price and the royalty percentage. It’s a pure function since
    it always returns the same output for the same input and doesn’t have any observable
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of marking functions as pure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marking functions as pure using the `Pure` attribute brings several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clarity and intention**: By marking a function as pure, you communicate your
    intention to other developers that this function should remain side-effect-free'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pure` attribute to help identify potential issues in your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimization opportunities**: While the C# compiler doesn’t currently take
    advantage of this, in some languages and scenarios, knowing that a function is
    pure can enable additional compiler optimizations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caveats and considerations when using the Pure attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When marking functions as pure, keep the following points in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pure` attribute does not enforce purity. You can mark a method as pure, and
    it can still have side effects. The attribute is more of a communication and analysis
    tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pure` attribute cannot be used with void methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pure` attribute has no impact on the method’s runtime behavior. It’s mainly
    used by certain static analysis tools, such as code contracts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By marking your functions with the `Pure` attribute, you make a promise about
    your function’s behavior, helping others (and tools) understand your code better.
    However, it’s crucial to remember that the attribute is a tool, not a panacea.
    The responsibility for ensuring a function’s purity still lies primarily with
    the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test Steve’s understanding, Julia presented him with three coding challenges
    related to pure functions and side effects. “These exercises will help solidify
    the concepts,” she explained. “Give them a try and let me know if you have any
    questions.”
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve’s tower defense game calculates damage based on a global difficulty modifier.
    Refactor this function to make it pure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Steve’s game loads enemy data from a file, processes it, and updates the game
    state. Refactor this function to isolate its side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Refactor the following method by making it a pure function and marking it with
    the `Pure` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These exercises should help solidify your understanding of the concepts we’ve
    covered. Keep practicing, keep experimenting, and remember – every line of code
    you write is a step forward on your journey to mastering functional programming
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions to the exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pure function should not depend on or modify any state outside its scope.
    So, instead of relying on the global `difficultyModifier` value, we should pass
    it as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To isolate side effects, we’ll separate the pure logic from the I/O operations
    and state mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one is a bit tricky because the function is already pure. All we need
    to do is add the `Pure` attribute to communicate that intention to other developers
    and analysis tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These solutions adhere to the principles of functional programming, ensuring
    minimized side effects and clarity of code behavior.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s cover some dos and don’ts for utilizing pure functions and
    minimizing side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the dos:'
  prefs: []
  type: TYPE_NORMAL
- en: Strive to write more pure functions as they’re predictable and straightforward
    to understand and test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolate side effects – that is, keep them separate from pure code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `readonly`, `const`, and `static` modifiers to promote immutability and
    reduce side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Pure` attribute to communicate intent, aiding in code analysis and
    maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the don’ts:'
  prefs: []
  type: TYPE_NORMAL
- en: Overuse global state as it leads to high coupling and increases the risk of
    side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify inputs inside a function. This alteration can lead to unexpected behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forget that the `Pure` attribute doesn’t enforce purity. It’s a promise that
    the developer needs to fulfill.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore the context. Sometimes, a non-pure function can provide a better solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into the world of functional programming in C# has been a stimulating
    journey, and we’re only just getting started. In this chapter, we explored the
    pivotal concepts of pure functions and side effects and their respective roles
    in writing cleaner, more predictable, and maintainable code. Let’s reinforce the
    knowledge we’ve gained and map out the course moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions stand as a beacon of certainty in the unpredictable universe
    of software. They have a clear-cut contract – the same input always yields the
    same output, and they remain uninvolved with the state outside their scope. This
    simplicity makes them predictable, easy to test, and more amenable to parallelization
    and optimization.
  prefs: []
  type: TYPE_NORMAL
- en: However, the real world is filled with side effects – reading and writing to
    a database, calling an API, modifying a global variable – the list goes on. Side
    effects are inevitable, but when uncontrolled, they can unleash chaos, making
    the code hard to reason about and test. To mitigate this problem in functional
    programming, we must wrap pure functions with impure code, thus protecting them
    from having side effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about a new type of function – honest functions.
    We’ll talk about what are they, how to use them in C#, and what danger nullable
    references can bring.
  prefs: []
  type: TYPE_NORMAL
