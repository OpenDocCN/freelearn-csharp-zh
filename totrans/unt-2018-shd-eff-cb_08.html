<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mobile Shader Adjustment</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6">In the next two chapters, we are going to take a look at making the shaders that we write in a performance-friendly manner for different platforms. We won't be talking about any one platform specifically, but we are going to break down the elements of shaders we can adjust in order to make them more optimized for mobiles and efficient on any platform in general. These techniques range from understanding what Unity offers in terms of built-in variables that reduce the overhead of the shaders memory to learning about ways in which we can make our own shader code more efficient. This chapter will cover the following recipes:</span><br class="calibre7"/></p>
<ul class="calibre11">
<li class="calibre12">Techniques to make shaders more efficient</li>
<li class="calibre12">Profiling your shaders</li>
<li class="calibre12">Modifying our shaders for mobile</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            <article>
                
<p class="calibre3">Learning the art of optimizing your shaders will come up in just about any game project that you work on. There will always come a point in any production where a shader needs to be optimized, or maybe it needs to use fewer textures but produces the same effect. As a technical artist or shader programmer, you have to understand these core fundamentals to optimize your shaders so that you can increase the performance of your game while still achieving the same visual fidelity. Having this knowledge can also help in setting the way in which you write your shader from the start. For instance, by knowing that the game built using your shader will be played on a mobile device, we can automatically set all our <kbd class="calibre13">Lighting</kbd> functions to use a half-vector as the view direction or set all of our float variable types to fixed or half so as to reduce the amountof memory used. These, and many other techniques, all contribute to your shaders running efficiently on your target hardware. Let's begin our journey and start learning how to optimize our shaders.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Techniques to make shaders more efficient</h1>
                
            
            <article>
                
<p class="calibre3">What is a cheap shader? When first asked the question, it might be a little tough to answer, as there are many elements that go into making a more efficient shader. It could be the amount of memory used up by your variables. It could be the amount of textures the shader is using. It could also be that our shader is working fine, but we can actually produce the same visual effect with half the amount of data by reducing the amount of code we are using or data we are creating. We are going to explore a few of these techniques in this recipe and show how they can be combined to make your shader fast and efficient but still produce the high-quality visuals everyone expects from games today, whether on a mobile or PC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">In order to get this recipe started, we need to gather a few resources together. So, let's perform the following tasks:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene and fill it with a simple sphere object and single directional light.</li>
<li value="2" class="calibre12">Create a new shader (<kbd class="calibre13">OptimizedShader01</kbd>) and material (<span><kbd class="calibre13">OptimizedShader01Mat</kbd>) </span>and assign the shader to the material.</li>
<li value="3" class="calibre12">We then need to assign the material we just created to our sphere object in our<br class="title-page-name"/>
new scene:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00167.jpeg" class="calibre126"/></div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Finally, modify the shader so that it uses a diffuse texture and normal map and includes your own custom <kbd class="calibre13">Lighting</kbd> function. </li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _NormalMap ("Normal Map", 2D) = "bump" {}<br class="title-page-name"/>}<br class="title-page-name"/>  <br class="title-page-name"/>SubShader <br class="title-page-name"/>{<br class="title-page-name"/>  Tags { "RenderType"="Opaque" }<br class="title-page-name"/>  LOD 200<br class="title-page-name"/>    <br class="title-page-name"/>  CGPROGRAM<br class="title-page-name"/>  #pragma surface surf SimpleLambert <br class="title-page-name"/><br class="title-page-name"/>  sampler2D _MainTex;<br class="title-page-name"/>  sampler2D _NormalMap;<br class="title-page-name"/><br class="title-page-name"/>  struct Input <br class="title-page-name"/>  {<br class="title-page-name"/>    float2 uv_MainTex;<br class="title-page-name"/>    float2 uv_NormalMap;<br class="title-page-name"/>  };<br class="title-page-name"/>    <br class="title-page-name"/>  inline float4 LightingSimpleLambert (SurfaceOutput s, <br class="title-page-name"/>                                       float3 lightDir, <br class="title-page-name"/>                                       float atten)<br class="title-page-name"/>  {<br class="title-page-name"/>   float diff = max (0, dot (s.Normal, lightDir));<br class="title-page-name"/>      <br class="title-page-name"/>   float4 c;<br class="title-page-name"/>   c.rgb = s.Albedo * _LightColor0.rgb * (diff * atten * 2);<br class="title-page-name"/>   c.a = s.Alpha;<br class="title-page-name"/>   return c;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>  {<br class="title-page-name"/>    fixed4 c = tex2D (_MainTex, IN.uv_MainTex);<br class="title-page-name"/>  <br class="title-page-name"/>    o.Albedo = c.rgb;<br class="title-page-name"/>    o.Alpha = c.a;<br class="title-page-name"/>    o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));<br class="title-page-name"/>  }<br class="title-page-name"/>  ENDCG<br class="title-page-name"/>} <br class="title-page-name"/>FallBack "Diffuse"</pre>
<ol start="5" class="calibre15">
<li class="calibre12" value="5">Lastly, assign a base and normal map to your material <span>(I used the <kbd class="calibre13">MudRockey</kbd> texture included in the assets for <a href="part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 1</a>, <em class="calibre2">Post Processing Stack</em>)</span>. You should now have a setup similar to the following screenshot.</li>
<li class="calibre12" value="6">This setup will allow us to take a look at some of the basic concepts that go into optimizing shaders using Surface Shaders in Unity:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00168.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">We are going to build a simple <kbd class="calibre13">DiffuseShader</kbd> to take a look at a few ways in which you can optimize your shaders in general.</p>
<p class="calibre3">First, we'll optimize our variable types so that they use less memory when they are<br class="calibre7"/>
processing data:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's begin with the <kbd class="calibre13">struct Input</kbd> in our shader. Currently, our UVs are being stored in a variable of the <kbd class="calibre13">float2</kbd> type.</li>
</ol>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Remember that floats provide the highest form of precision at a full 32 bits of memory. This is needed for complex trigonometry or exponents, but if you can handle less precision, it's much better to use either a half or a fixed instead. The half type provides up to 3 digits of precision using half the size, or 16 bits of memory. That means we can have a <kbd class="calibre13">half2</kbd> with the same amount of memory of a single float. We need to change this to use <kbd class="calibre13">half2</kbd> instead:</li>
</ol>
<pre class="cdpaligncenter2">struct Input <br class="title-page-name"/>{<br class="title-page-name"/>    half2 uv_MainTex;<br class="title-page-name"/>    half2 uv_NormalMap;<br class="title-page-name"/>};</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">We can then move to our <kbd class="calibre13">Lighting</kbd> function and reduce the variables' memory footprint by changing their types to the following:</li>
</ol>
<pre class="calibre18">inline fixed4 LightingSimpleLambert (SurfaceOutput s, fixed3 lightDir, fixed atten)<br class="title-page-name"/>{<br class="title-page-name"/>  fixed diff = max (0, dot(s.Normal, lightDir));<br class="title-page-name"/>      <br class="title-page-name"/>  fixed4 c;<br class="title-page-name"/>  c.rgb = s.Albedo * _LightColor0.rgb * (diff * atten * 2);<br class="title-page-name"/>  c.a = s.Alpha;<br class="title-page-name"/>  return c;<br class="title-page-name"/>}</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12"> In this case, we are using the lowest precision type of <kbd class="calibre13">fixed</kbd>, which is only 11  bits as compared to the <kbd class="calibre13">float</kbd> type's 32. This is useful for simple calculations such as color or texture data, which is perfect for this particular case.</li>
</ol>
<div class="packt_infobox">In case you'd like a refresher on the fixed type as well as all of the other types we are using, please check out <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre31">Chapter 2</a>, <em class="calibre21">Creating Your First Shader</em>, or look at <a href="https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html" class="calibre31">https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html</a>. </div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Finally, we can complete this optimization pass by updating the variables in our <kbd class="calibre13">surf()</kbd> function. Since we're using texture data, it's fine for us to use a <kbd class="calibre13">fixed4</kbd> here instead:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/>  fixed4 c = tex2D (_MainTex, IN.uv_MainTex);<br class="title-page-name"/>    <br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  o.Alpha = c.a;<br class="title-page-name"/>  o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_NormalMap));<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">Now that we have our variables optimized, we are going to take advantage of a built-in <kbd class="calibre13">Lighting</kbd> function variable so that we can control how lights are processed by this shader. By doing this, we can greatly reduce the number of lights the shader processes. Modify the <kbd class="calibre13">#pragma</kbd> statement in your shader with the following code:</li>
</ol>
<pre class="cdpaligncenter2">CGPROGRAM<br class="title-page-name"/>#pragma surface surf SimpleLambert <strong class="calibre1">noforwardadd</strong></pre>
<ol start="7" class="calibre15">
<li class="calibre12" value="7">We can optimize this further by sharing UVs between the normal map and diffuse texture. To do this, we simply change the UV lookup in our <kbd class="calibre13">UnpackNormal()</kbd> function to use <kbd class="calibre13">_MainTex</kbd> UVs instead of the UVs of <kbd class="calibre13">_NormalMap</kbd>:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/>  fixed4 c = tex2D (_MainTex, IN.uv_MainTex);<br class="title-page-name"/>  <br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  o.Alpha = c.a;<br class="title-page-name"/>  o.Normal = UnpackNormal(tex2D(_NormalMap,<strong class="calibre1"> IN.uv_MainTex</strong>));<br class="title-page-name"/>}</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">As we have removed the need for the normal map UVs, we need to make sure that we remove the normal map UV code from the <kbd class="calibre13">Input</kbd> <kbd class="calibre13">struct</kbd>:</li>
</ol>
<pre class="cdpaligncenter2">struct Input <br class="title-page-name"/>{<br class="title-page-name"/>  half2 uv_MainTex;<br class="title-page-name"/>};</pre>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">Finally, we can further optimize this shader by telling the shader that it only works with certain renderers:</li>
</ol>
<pre class="cdpaligncenter2">CGPROGRAM<br class="title-page-name"/>#pragma surface surf SimpleLambert <strong class="calibre1">exclude_path:prepass</strong> noforwardadd</pre>
<p class="calibre3">The result of our optimization passes show us that we really don't notice a difference in the visual quality, but we have reduced the amount of time it takes for this shader to be drawn to the screen. You will learn about finding out how much time it takes for a shader to render in the next recipe, but the idea to focus on here is that we achieve the same result with fewer data. So keep this in mind when creating your shaders. The following screenshot shows us the final result of our shader:</p>
<div class="cdpaligncenter1"><img src="../images/00169.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have seen the ways in which we can optimize our shaders, let's dive in a bit deeper and really understand how all of these techniques work, why we should use them, and look at a couple of other techniques that you can try for yourself in your own shaders.</p>
<p class="calibre3">Let's first focus our attention on the size of the data each of our variables is storing when we declare them. If you are familiar with programming, then you will understand that you can declare values or variables with different sizes of types. This means that a float actually has a maximum size in memory. The following description will describe these variable types in much more detail:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Float</strong>: A float is a full 32-bit precision value and is the slowest of the three<br class="title-page-name"/>
different types we see here. It also has its corresponding values of <kbd class="calibre13">float2</kbd>, <kbd class="calibre13">float3</kbd>, and <kbd class="calibre13">float4</kbd>, which allow us to store multiple floats in one variable.</li>
<li class="calibre12"><strong class="calibre1">Half</strong>: The half variable type is a reduced 16-bit floating point value and is suitable for store UV values and color values and much faster than using a float value. As with the float type, it has its corresponding values, which are <kbd class="calibre13">half2</kbd>, <kbd class="calibre13">half3</kbd>, and <kbd class="calibre13">half4</kbd>.</li>
<li class="calibre12"><strong class="calibre1">Fixed</strong>: A fixed value is the smallest in size of the three types, but can be used for lighting calculations and colors and has the corresponding values of <kbd class="calibre13">fixed2</kbd>, <kbd class="calibre13">fixed3</kbd>, and <kbd class="calibre13">fixed4</kbd>.</li>
</ul>
<div class="packt_tip">For more information on working with array types for shaders, check out the <em class="calibre21">Using packed arrays</em> recipe from <a href="part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre31">Chapter 3</a>, <em class="calibre21">Surface Shaders and Texture Mapping</em>.</div>
<p class="calibre3">Our second phase of optimizing our simple shader was to declare the <kbd class="calibre13">noforwardadd</kbd> value to our <kbd class="calibre13">#pragma</kbd> statement. This is basically a switch that automatically tells Unity that any object with this particular shader receives only per-pixel light from a single directional light. Any other lights that are calculated by this shader will be forced to be processed as per-vertex lights using <em class="calibre14">spherical harmonic</em> values produced internally by Unity. This is especially obvious when we place another light in the scene to light our sphere object because our shader is doing a per-pixel operation using the normal map.</p>
<p class="calibre3">This is great, but what if you wanted to have a bunch of directional lights in the scene and control over which of these lights is used for the main per-pixel light? Well, if you notice, each light has a <span class="calibre6">Render Mode</span> drop-down. If you click on this drop-down, you will see a couple of flags that can be set. These are <span class="calibre6">Auto</span>, <span class="calibre6">Important</span>, and <span class="calibre6">Not Important</span>. By selecting a light, you can tell Unity that a light should be considered more as a per-pixel light than a per-vertex light, by setting its render mode to <span class="calibre6">Important</span> and vice versa. If you leave a light set to <span class="calibre6">Auto</span>, then you will let Unity decide the best course of action:</p>
<p class="cdpaligncenter3"><img src="../images/00170.jpeg" class="calibre127"/></p>
<p class="calibre3">Place another light in your scene and remove the texture that is currently in the main texture for our shader. You will notice that the second point light does not react with the normal map, only the directional light that we created first. The concept here is that you save on per-pixel operations by just calculating all extra lights as vertex lights, and save performance by just calculating the main directional light as a per-pixel light. The following diagram visually demonstrates this concept as the point light is not reacting with the normal map:</p>
<div class="cdpaligncenter"><img src="../images/00171.jpeg" class="calibre128"/></div>
<p class="calibre3">Finally, we did a bit of cleaning up and simply told the normal map texture to use the main texture's UV values, and we got rid of the line of code that pulled in a separate set of UV values specifically for the normal map. This is always a nice way to simplify your code and clean up any unwanted data.</p>
<p class="calibre3">We also declared <kbd class="calibre13">exclude_pass: prepass</kbd> in our <kbd class="calibre13">#pragma</kbd> statement so that this<br class="calibre7"/>
shader wouldn't accept any custom lighting from the deferred renderer. This means that we can really use this shader effectively in the forward renderer only, which is set in the main camera's settings.</p>
<p class="calibre3">By taking a bit of time, you will be amazed at how much a shader can be optimized. You have seen how we can pack grayscale textures into a single RGBA texture as well as use lookup textures to fake lighting. There are many ways in which a shader can be optimized, which is why it is always an ambiguous question to ask in the first place, but knowing these different optimization techniques, you can cater your shaders to your game and target platform, ultimately resulting in very streamlined shaders and a nice steady frame rate.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Profiling your shaders</h1>
                
            
            <article>
                
<p class="calibre3">Now that we know how we can reduce the overhead that our shaders might take, let's take a look at how to find problematic shaders in a scene where you might have a lot of shaders or a ton of objects, shaders, and scripts, all running at the same time. To find a single object or shader among a whole game can be quite daunting, but Unity provides us with its built-in <span class="calibre6">Profiler</span>. This allows us to actually see, on a frame-by-frame basis, what is happening in the game, and each item that is being used by the GPU and CPU.</p>
<p class="calibre3">Using the <span class="calibre6">Profiler</span>, we can isolate items such as shaders, geometry, and general rendering items using its interface to create blocks of profiling jobs. We can filter out items until we are looking at the performance of just a single object. This then lets us see the effects on the CPU and GPU that the object has while it is performing its functions at runtime.</p>
<p class="calibre3">Let's take a look through the different sections of the <span class="calibre6">Profiler</span> and learn how to debug our scenes and, most importantly, our shaders.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Let's use our <span class="calibre6">Profiler</span> by getting a few assets ready and launching the <span class="calibre6">Profiler</span> window:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's use the scene from the last recipe and launch the Unity <span>Profiler</span> from <span>Window </span>| <span>Profiler</span> or <em class="calibre2"><span>Ctrl</span></em> + <em class="calibre2"><span>7</span></em>. Feel free to drag and drop or move it so you can see it well. I personally put it at the same spot as the <span>Inspector</span> tab.</li>
<li value="2" class="calibre12">Let's also duplicate our sphere a couple more times to see how that affects our rendering.</li>
<li value="3" class="calibre12">From the <span>Profiler</span> tab, click on the <span>Deep Profile</span> option to get additional information about the project and then play your game!</li>
</ol>
<p class="calibre3">You should see something similar to the following image:</p>
<div class="cdpaligncenter1"><img src="../images/00172.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">To use the <span class="calibre6">Profiler</span>, we will take a look at some of the UI elements of this window. Before we hit Play, let's take a look at how to get the information we need from the <span class="calibre6">Profiler</span>:</p>
<ol class="calibre15">
<li value="1" class="calibre12">First, click on the larger blocks in the <span>Profiler</span> window called <span>GPU Usage</span>, <span>CPU Usage</span>, and <span>Rendering</span>. You will find these blocks on the left-hand side of the upper window:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00173.jpeg" class="calibre25"/></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Using these blocks, we can see different data specific to those major functions of our game. The <span>CPU Usage</span> is showing us what most of our scripts are doing, as well as physics and overall rendering. The <span>GPU Usage</span> block is giving us detailed information about the elements that are specific to our lighting, shadows, and render queues. Finally, the <span>Rendering</span> block is giving us information about the drawcalls and amount of geometry we have in our scene at any one frame.</li>
</ol>
<div class="packt_tip"><span class="calibre27">If you do not see the GPU Usage option, click on <span class="calibre27">Add Profiler</span></span> | <span class="calibre27"><span class="calibre27">GPU</span>. It is possible that it may not show up if your graphics card drivers are not up to date.</span></div>
<p class="calibre26">By clicking on each of these blocks, we can isolate the type of data we see during our profiling session.</p>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Now, click on the tiny colored blocks in one of these <span>Profile</span> blocks and hit Play, or <em class="calibre2"><span>Ctrl</span></em> + <em class="calibre2"><span>P</span></em>, to run the scene.</li>
<li value="4" class="calibre12">This lets us dive down even deeper into our profiling session so that we can filter out what is being reported back to us. While the scene is running, uncheck all of the boxes, except for <span>Opaque</span> <span>in the</span> <span>GPU Usage</span> <span>block. Notice that we can now see just how much time is being used to render the objects that are set to the <span>Render Queue</span> of <span>Opaque</span>:</span></li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00174.jpeg" class="calibre25"/></div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Another great function of the <span>Profiler</span> window is the action of clicking and dragging in the graph view.</li>
<li value="6" class="calibre12">This will automatically pause your game so that you can further analyze a certain spike in the graph to find out exactly which item is causing the performance problem. Click and drag around in the graph view to pause the game and see the effect of using this functionality:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00175.jpeg" class="calibre129"/></div>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Turning our attention now towards the lower half of the <span>Profiler</span> window, you will notice that there is a dropdown item available when we have the <span>GPU Block</span> selected. We can expand this to get even more detailed information about the current active profiling session and, in this case, more information about what the camera is currently rendering and how much time it is taking up:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00176.jpeg" class="calibre25"/></div>
<div class="packt_tip">If you click on the button that says <span class="calibre27">No Details</span> and changes the option to <span class="calibre27">Show Related Objects</span>, you can see what objects are being used in the functions being called.</div>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">This gives us a complete look at the inner workings of what Unity is processing in this particular frame. In this case, we can see that our three spheres with our optimized shader are taking roughly <span>0.066</span> milliseconds to draw to the screen, they are taking up fifteen drawcalls, and this process is taking <span>8.4%</span> of the GPU's time in every frame (the numbers will likely be different depending on what hardware you have for your computer). It's this type of information we can use to diagnose and solve performance issues with regard to shaders. Let's conduct a test to see the effects of adding one more texture to our shader and blending two diffuse textures together using a <kbd class="calibre13">lerp</kbd> <span>function. You will see the effects in the <span>Profiler</span> pretty clearly.</span></li>
</ol>
<ol start="9" class="calibre15">
<li value="9" class="calibre12">Modify the <kbd class="calibre13">Properties</kbd> block of your shader with the following code to give us another texture to use:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  _BlendTex("Blend Texture", 2D) = "white" {}<br class="title-page-name"/>  _NormalMap ("Normal Map", 2D) = "bump" {}<br class="title-page-name"/>}</pre>
<ol start="10" class="calibre15">
<li value="10" class="calibre12">Then let's feed our texture to <kbd class="calibre13">CGPROGRAM</kbd>:</li>
</ol>
<pre class="calibre18">sampler2D _MainTex;<br class="title-page-name"/>sampler2D _NormalMap;<br class="title-page-name"/><strong class="calibre1">sampler2D _BlendTex;</strong></pre>
<ol start="11" class="calibre15">
<li value="11" class="calibre12">Now it's time to update our <kbd class="calibre13">surf()</kbd> function accordingly so that we blend our diffuse textures together:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/>  fixed4 c = tex2D (_MainTex, IN.uv_MainTex);<br class="title-page-name"/>  fixed4 blendTex = tex2D(_BlendTex, IN.uv_MainTex);<br class="title-page-name"/><br class="title-page-name"/>  c = lerp(c, blendTex, blendTex.r);<br class="title-page-name"/><br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  o.Alpha = c.a;<br class="title-page-name"/>  o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_MainTex));<br class="title-page-name"/>}</pre>
<p class="calibre26">Once you save your modifications in your shader and return to Unity's editor, we can run our game and see the increase in milliseconds of our new shader.</p>
<ol start="12" class="calibre15">
<li value="12" class="calibre12">Attach a new texture inside of your <kbd class="calibre13">Blend Texture</kbd>:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00177.jpeg" class="calibre130"/></div>
<ol start="13" class="calibre15">
<li value="13" class="calibre12">Press Play to start the game again with the <span>Profiler</span> turned on. Press Play once you have returned to Unity and let's take a look at the results in our <span>Profiler</span><span>:</span></li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00178.jpeg" class="calibre131"/></div>
<p class="calibre3">You can see now that the amount of time to render our <span class="calibre6">Opaque</span> Shaders in this scene is taking <span class="calibre6">0.069</span> milliseconds, up from <span class="calibre6">0.066</span> milliseconds. By adding another texture and using the <kbd class="calibre13">lerp()</kbd> function, we increased the render time for our spheres. While it's a small change, imagine having 20 shaders all working in different ways on different objects.</p>
<p class="calibre3">Using the information given here, you can pinpoint areas that are causing performance decreases more quickly and solve these issues using the techniques from the previous recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">While it's completely out of the scope of this book to describe how this tool actually works internally, we can surmise that Unity has given us a way to view the computer's performance while our game is running. Basically, this window is tied very tightly to the CPU and GPU to give us real-time feedback of how much time is being taken for each of our scripts, objects, and render queues. Using this information, we have seen that we can track the efficiency of our shader writing to eliminate problem areas and code.</p>
<p class="calibre3">It's important to note that games running with the <span class="calibre6">Profiler</span> open, as well as from within the editor in general, will make the game slightly slower than it would be when compiled and running in a normal situation. You might even see the <span class="calibre6">Editor</span> in the <span class="calibre6">Profilers</span> list of CPU expenses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            <article>
                
<p class="calibre3">It is also possible to profile specifically for mobile platforms. Unity provides us with a couple of extra features when the Android or iOS build target is set in the <span class="calibre6">Build Settings</span>. We can actually get real-time information from our mobile devices while the game is running. This becomes very useful because you are able to profile directly on the device itself instead of profiling directly in your editor. To find out more about this process, refer to Unity's documentation at the following link:<span class="calibre6"><br class="calibre7"/>
<a href="http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html" class="calibre10">http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html</a>.<a href="http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html" class="calibre10"><br class="title-page-name"/></a></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modifying our shaders for mobile</h1>
                
            
            <article>
                
<p class="calibre3">Now that we have seen quite a broad set of techniques for making really optimized shaders, let's take a look at writing a nice, high-quality shader targeted for a mobile device. It is actually quite easy to make a few adjustments to the shaders we have written so that they run faster on a mobile device. This includes elements such as using the <kbd class="calibre13">approxview</kbd> or <kbd class="calibre13">halfasview Lighting</kbd> function variables. We can also reduce the amount of textures we need and even apply better compression for the textures we are using. By the end of this recipe, we will have a nicely optimized normal-mapped, Specular Shader for use in our mobile games.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Before we begin, let's get a fresh new scene and fill it with some objects to apply our <kbd class="calibre13">MobileShader</kbd>:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene and fill it with a default sphere and single directional light.</li>
<li value="2" class="calibre12">Create a new material (<kbd class="calibre13">MobileMat</kbd>) and shader (<kbd class="calibre13">MobileShader</kbd>), and assign the shader to the material.</li>
<li value="3" class="calibre12">Finally, assign the material to our sphere object in our scene.</li>
</ol>
<p class="calibre3">When completed, you should have a scene similar to the one in the following screenshot:</p>
<div class="cdpaligncenter1"><img src="../images/00179.jpeg" class="calibre132"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">For this recipe, we will write a mobile-friendly shader from scratch and discuss the elements that make it more mobile friendly:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Let's first populate our <kbd class="calibre13">Properties</kbd> block with the textures required. In this case, we are going to use a single <kbd class="calibre13">_Diffuse</kbd> texture with the gloss map in its alpha channel, <kbd class="calibre13">Normal map</kbd>, and a slider for specular intensity:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _Diffuse ("Base (RGB) Specular Amount (A)", 2D) = "white" {}<br class="title-page-name"/>  _SpecIntensity ("Specular Width", Range(0.01, 1)) = 0.5<br class="title-page-name"/>  _NormalMap ("Normal Map", 2D) = "bump"{}<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Our next task is to set up our <kbd class="calibre13">#pragma</kbd> declarations. This will simply turn certain features of the Surface Shader on and off, ultimately making the shader cheaper or more expensive:</li>
</ol>
<pre class="calibre18">CGPROGRAM<br class="title-page-name"/><strong class="calibre1">#pragma surface surf MobileBlinnPhong exclude_path:prepass nolightmap noforwardadd halfasview</strong></pre>
<div class="packt_tip">The highlighted line should be on one line.</div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Next, remove the <kbd class="calibre13">#pragma target 3.0</kbd> line, as we are not using any of the features of it.</li>
<li value="4" class="calibre12">We then need to make the connection between our <kbd class="calibre13">Properties</kbd> block and <kbd class="calibre13">CGPROGRAM</kbd>. This time, we are going to use the fixed variable type for our specular intensity slider in order to reduce its memory usage:</li>
</ol>
<pre class="calibre18">sampler2D _Diffuse;<br class="title-page-name"/>sampler2D _NormalMap;<br class="title-page-name"/>fixed _SpecIntensity;</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">In order for us to map our textures to the surface of our object, we need to get some UVs. In this case, we are going to get only one set of UVs to keep the amount of data in our shader down to a minimum:</li>
</ol>
<pre class="calibre18">struct Input <br class="title-page-name"/>{<br class="title-page-name"/>  half2 uv_Diffuse;<br class="title-page-name"/>};</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">The next step is to fill in our <kbd class="calibre13">Lighting</kbd> function using a few of the new input variables that are available to us when using the new <kbd class="calibre13">#pragma</kbd> declarations:</li>
</ol>
<pre class="calibre18">inline fixed4 LightingMobileBlinnPhong (SurfaceOutput s, fixed3 lightDir, fixed3 halfDir, fixed atten)<br class="title-page-name"/>    {<br class="title-page-name"/>      fixed diff = max (0, dot (s.Normal, lightDir));<br class="title-page-name"/>      fixed nh = max (0, dot (s.Normal, halfDir));<br class="title-page-name"/>      fixed spec = pow (nh, s.Specular*128) * s.Gloss;<br class="title-page-name"/>      <br class="title-page-name"/>      fixed4 c;<br class="title-page-name"/>      c.rgb = (s.Albedo * _LightColor0.rgb * diff + _LightColor0.rgb * spec) * (atten*2);<br class="title-page-name"/>      c.a = 0.0;<br class="title-page-name"/>      return c;<br class="title-page-name"/>    }</pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Finally, we complete the shader by creating the <kbd class="calibre13">surf()</kbd> function and processing the final color of our surface:</li>
</ol>
<pre class="calibre18">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/>  fixed4 diffuseTex = tex2D (_Diffuse, IN.uv_Diffuse);<br class="title-page-name"/>  o.Albedo = diffuseTex.rgb;<br class="title-page-name"/>  o.Gloss = diffuseTex.a;<br class="title-page-name"/>  o.Alpha = 0.0;<br class="title-page-name"/>  o.Specular = _SpecIntensity;<br class="title-page-name"/>  o.Normal = UnpackNormal(tex2D(_NormalMap, IN.uv_Diffuse));<br class="title-page-name"/>}</pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">When finished with the code portion of this recipe, save your shader and return to the Unity editor to let the shader compile. If no errors occurred, assign some properties for the <span>Base</span> and <span>Normal Map</span> properties:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00180.jpeg" class="calibre25"/></div>
<ol start="9" class="calibre15">
<li class="calibre12" value="9">Add a few point lights and some copies of the new object and you should see a result similar to the following screenshot:</li>
</ol>
<div class="cdpaligncenter1"><img src="../images/00181.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">So, let's begin the description of this shader by explaining what it does and doesn't do. First, it excludes the deferred lighting pass. This means that if you created a <kbd class="calibre13">Lighting</kbd> function that was connected to the deferred renderer's <kbd class="calibre13">prepass</kbd>, it wouldn't use that particular <kbd class="calibre13">Lighting</kbd> function and would look for the default <kbd class="calibre13">Lighting</kbd> function like the ones that we have been creating thus far in this book.</p>
<p class="calibre3">This particular shader does not support <em class="calibre14">lightmapping</em> by Unity's internal light-mapping system. This just keeps the shader from trying to find light maps for the object that the shader is attached to, making the shader more performance-friendly because it is not having to perform the lightmapping check.</p>
<p class="calibre3">We included the <kbd class="calibre13">noforwardadd</kbd> declaration so that we process only per-pixel textures with a single directional light. All other lights are forced to become per-vertex lights and will not be included in any per-pixel operations you might do in the <kbd class="calibre13">surf()</kbd> function.</p>
<p class="calibre3">Finally, we are using the <kbd class="calibre13">halfasview</kbd> declaration to tell Unity that we aren't going to use the main <kbd class="calibre13">viewDir</kbd> parameter found in a normal <kbd class="calibre13">Lighting</kbd> function. Instead, we are going to use the half vector as the view direction and process our specular with this. This becomes much faster for the shader to process as it will be done on a per-vertex basis. It isn't completely accurate when it comes to simulating specular in the real world, but visually, on a mobile device, it looks just fine and the shader is more optimized.</p>
<p class="calibre3">It's techniques like these that make a shader more efficient and cleaner, codewise. Always make sure that you are using only the data you need while weighing this against your target hardware and the visual quality that the game requires. In the end, a cocktail of these techniques is what ultimately makes up your shaders for your games.</p>


            </article>

            
        </section>
    </body></html>