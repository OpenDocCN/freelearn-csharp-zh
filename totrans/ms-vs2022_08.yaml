- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Cloud Integration and Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the advanced realm of cloud integration
    and services, highlighting how Visual Studio 2022 serves as a powerful tool to
    develop and manage cloud-based applications. In today’s digital ecosystem, cloud
    computing has become a cornerstone, enabling scalable, resilient, and highly available
    applications. To stay ahead, developers must not only build robust applications
    but also seamlessly integrate them with various cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll learn how to harness the power of various cloud
    services, streamline our development workflows, and ensure that our applications
    are optimized for cloud environments. Whether it’s deploying serverless functions
    on Azure, integrating Google Cloud services, or leveraging the extensive tools
    provided by AWS, this chapter will equip you with the knowledge and skills needed
    to excel in advanced cloud development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring . NET Aspire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Azure Functions development in Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Google Cloud Tools for Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the AWS Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin our journey toward mastering cloud integration and building cutting-edge
    cloud-based applications together.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an optimal experience, consider having the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google Cloud Platform subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch08](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch08)
  prefs: []
  type: TYPE_NORMAL
- en: Exploring .NET Aspire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In November 2023, as part of .NET 8, Microsoft introduced .NET Aspire. The motivation
    of Microsoft is to make .NET one of the most productive platforms for building
    cloud-native applications. This technology seamlessly integrates with popular
    containerization platforms such as Docker and Kubernetes, facilitating the management
    of applications and their deployment in cloud-native environments. In this section,
    we will explore what .NET Aspire is and how Visual Studio guides us through its
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Aspire represents a sophisticated suite of tools engineered to facilitate
    the construction of observable, robust, and scalable applications tailored for
    cloud environments. Designed with a focus on cloud-specific requirements, this
    cohesive framework seeks to ease the process of developing cloud-native solutions
    by offering a coherent array of utilities and methodologies. Central aspects of
    .NET Aspire encompass the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A cloud-specific framework** : Tailored to address the unique hurdles encountered
    during cloud application development, .NET Aspire underscores the importance of
    being easily observable, ready for deployment, and capable of operating across
    distributed systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component-based design** : Presented as a series of NuGet packages, these
    components cater to distinct needs within cloud computing, allowing developers
    to incorporate only those elements essential for their projects. This modular
    structure not only enhances adaptability but also boosts productivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A streamlined development workflow** : By introducing a uniform set of tools
    and practices, .NET Aspire simplifies the assembly of .NET applications suited
    for the cloud. It features pre-configured modules for databases such as Redis
    and PostgreSQL, thereby easing their integration into projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced developer tools** : The toolkit enriches the development life cycle
    through project templates and integrations with Visual Studio and the .NET CLI,
    making the initiation and administration of applications more straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Aspire allows us to manage the organization and linkage of different parts
    of an application, making the assembly of interconnected services and the identification
    of available resources less cumbersome. It provides standardized components by
    delivering NuGet packages that resolve common issues associated with cloud deployments,
    offering predefined setups for tasks such as monitoring, diagnostics, and data
    transmission.
  prefs: []
  type: TYPE_NORMAL
- en: By introducing well-structured project templates to enhance the organization
    of applications and expedite the setup phase, and featuring pivotal projects such
    as Application Host and Default Services, .NET Aspire caters to professionals
    looking to construct applications that are scalable, fault-tolerant, and maintainable
    within cloud infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Its dedication to cloud-centric development positions it as a significant asset
    within the .NET community, empowering developers to harness the full potential
    of cloud technologies for their software solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore what Visual Studio has prepared for us regarding .NET Aspire.
    To do this, we will create a new project with the **.NET Aspire Starter Application**
    template. For this example, we will name it **SampleAspireProject** .
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 8.1 – The .NET Aspire Starter Application \uFEFFtemplate](img/B22218_08_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The .NET Aspire Starter Application template
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new project, Visual Studio will open an **Overview** page,
    providing links to Microsoft documentation about building and deploying our app
    and service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Aspire Overview page](img/B22218_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Aspire Overview page
  prefs: []
  type: TYPE_NORMAL
- en: On the same page, we can find more tabs; the second one is **Connected Services**
    . By clicking on this option, we can access two options that allow us to add service
    dependencies and service references.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Connected Services](img/B22218_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Connected Services
  prefs: []
  type: TYPE_NORMAL
- en: Upon clicking the **Add a service dependency** link, a window opens up that
    allows us to select an Azure service to add to our solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Adding a dependency](img/B22218_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Adding a dependency
  prefs: []
  type: TYPE_NORMAL
- en: Note that to be able to complete the process of adding a dependency, we need
    a valid Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the **Connected Service** , and click on the **Add a service reference**
    link. This will give us access to a window that enables us to select between three
    API specifications – **OpenAPI** , **gRPC** , and **WCF** **Web Service** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Adding a service reference](img/B22218_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Adding a service reference
  prefs: []
  type: TYPE_NORMAL
- en: 'The template we have used sets up four projects for our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ApiService** : ASP.NET Core minimal APIs, serving as the backend logic layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AppHost** : This is the project that hosts the configuration of our solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ServiceDefaults** : Represents the shared project that contains default configurations
    and potential objects used across multiple services in the solutions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web** : This Blazor project is dedicated to frontend development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Starter application components](img/B22218_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Starter application components
  prefs: []
  type: TYPE_NORMAL
- en: The **AppHost** project is set as the starring project by default. So, when
    we launch the solution, the .NET Aspire template opens the **SampleAspireApp**
    **dashboard** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The .NET Aspire dashboard](img/B22218_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The .NET Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard provides crucial information about our solution through different
    metrics, such as logs, traces, and environment configuration. In the **Resources**
    panel, we can access each endpoint of our solution. In this template project,
    we retrieve **apiservice** and **webfrontend** in the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: After the local development of our cloud-native solution, we can directly publish
    it to our Azure platform. Note that we need an Azure Developer CLI installed.
    To create a publish profile, we can reopen the **Overview** window from the top
    bar menu ( **Project** | **Overview** ).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Publish profiles](img/B22218_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Publish profiles
  prefs: []
  type: TYPE_NORMAL
- en: By using Visual Studio through .NET Aspire, we have set up a cloud-native application
    ready to be deployed. In the next section, we will explore Azure Functions development
    in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Azure Functions development in Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio provides several built-in templates for the Azure platform. As
    Azure Functions is the most popular cloud-native feature of Microsoft, we will
    focus on it in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Put simply, Azure Functions is a serverless computing service offered by Microsoft
    Azure that allows developers to run small pieces of code without worrying about
    the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions is designed to respond to events from a variety of sources,
    including HTTP requests, timers, database changes, and many other Azure services.
    This event-driven model enables us to build applications that react to real-time
    data changes, automate tasks, and integrate with other systems seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to ensure that the Azure development workload is installed on
    our Visual Studio instance by navigating to the Visual Studio Installer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – An Azure development workload](img/B22218_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – An Azure development workload
  prefs: []
  type: TYPE_NORMAL
- en: Once the workload is installed, we can start by creating a new Azure Functions
    project, and for this example, we will name it **SampleAzureFunction** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – An Azure Function project](img/B22218_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – An Azure Function project
  prefs: []
  type: TYPE_NORMAL
- en: For the next step, Visual Studio will lead us to an **Additional information**
    window, where we are asked to configure the worker, trigger, and authorization
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Choosing an Azure Functions trigger](img/B22218_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Choosing an Azure Functions trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore and understand the different trigger options offered by Azure
    Functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Http trigger** : Allows you to create an HTTP endpoint that can be called
    to execute the function. This is useful for creating RESTful APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Http trigger with OpenAPI** : Similar to the HTTP trigger but includes built-in
    support for OpenAPI (formerly Swagger), making it easier to design and document
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT Hub trigger** : Enables functions to respond to events sent to an IoT
    Hub event stream. Useful for processing telemetry data from IoT devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kafka output** : Writes a message to a Kafka topic. This is used when you
    want to publish messages to a Kafka topic from an Azure Functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kafka trigger** : Consumes messages from a Kafka topic. This is useful for
    processing incoming messages from Kafka topics within an Azure Function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue trigger** : Executes a function whenever a new message is added to
    an Azure Queue Storage queue. Ideal for processing queued tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RabbitMQ trigger** : Consumes messages from a RabbitMQ queue. This is useful
    for integrating with RabbitMQ-based applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SendGrid** : Allows you to send emails directly from an Azure Function using
    SendGrid’s email service. This is particularly useful for sending notifications
    or alerts via email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Bus Queue trigger** : Responds to messages from a Service Bus queue.
    This is ideal for processing messages asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Bus Topic trigger** : Responds to messages published to a Service
    Bus topic. This is useful for implementing pub/sub patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SignalR** : Enables running real-time messaging web apps in a serverless
    environment. It’s great for scenarios requiring real-time updates to clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL input binding** : Retrieves data from a SQL database and passes it to
    a function’s input parameters. This is useful for querying databases and processing
    the results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL output binding** : Writes data to a SQL database. This is useful for
    updating databases based on a function’s execution logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timer trigger** : Runs a function on a schedule, such as every minute, hour,
    or day. This is perfect for periodic tasks such as backups or reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have chosen the function type, we have to select the level of authorization
    to rule our Azure Function. The three types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function** : This level restricts access to only those users who have been
    granted specific permissions to invoke a function. It’s typically used when we
    want to control access to our function more granularly than what’s provided by
    the other two levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anonymous** : This level allows any client (authenticated or not) to call
    a function without needing to provide credentials. It’s useful for public APIs
    or functions that don’t require authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin** : This level grants full administrative privileges to the function,
    allowing it to perform actions on behalf of the caller as if they were logged
    in as an administrator. It should be used cautiously due to its broad permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we are all set, we can develop the logic of our function, and to respond
    to our stakeholders, the next step is to publish it to our Azure subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project in **Solution Explorer** and select **Publish** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, choose **Azure** as the target and click **Next** . Finally, select **Azure
    Function App (Windows)** for the specific target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Publishing a specific target](img/B22218_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Publishing a specific target
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to choose a unique name for our function app to ensure that it
    doesn’t duplicate any existing names globally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we’ll select our Azure subscription from the available options. We can
    either pick an existing resource group or create a new one. For the plan type,
    we’ll opt for the **Consumption** plan to guarantee cost-effective execution based
    on actual usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will choose a region that is geographically close to our users or services
    for better performance. If required, we will set up a general-purpose storage
    account. We’ll also enable **Application Insights** to monitor and diagnose our
    function app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During deployment, we need to make sure to select the **Run from package** option.
    This allows our function app to execute directly from the deployment package,
    enhancing performance and simplifying the deployment process. After reviewing
    all our settings, we’ll click **Publish** to begin the deployment. A success message
    will appear once the deployment is completed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will go to the Azure portal and navigate to our function app to
    ensure that it is running correctly. Through the portal, we can monitor logs,
    test endpoints, and manage our function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As Azure is part of the Microsoft ecosystem, other cloud platforms can be used
    in our overall enterprise solution. Next, let’s begin to explore how we can enhance
    our Google Cloud Platform development with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Google Cloud Tools for Visual Studio 2022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Cloud Platform** ( **GCP** ) is a public cloud computing service developed
    by Google, offering a variety of cloud-based solutions. Just like other cloud
    platforms, these include services for computing, storage, networking, big data,
    machine learning, and the **Internet of Things** ( **IoT** ). GCP allows us and
    businesses to create and deploy applications and services using Google’s robust
    infrastructure, benefiting from the scalability, flexibility, and security of
    Google’s worldwide network. In this section, we will explore the GCP extension
    for Visual Studio 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the extension by going to **Extension Manager** through
    the top-bar menu ( **Extension** | **Manage extensions…** ) and searching for
    **Google** **Cloud Tools** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Extension Manager | Google Cloud Tools](img/B22218_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Extension Manager | Google Cloud Tools
  prefs: []
  type: TYPE_NORMAL
- en: As with each installation of new Visual Studio extensions, we need to close
    our instance after we have clicked on the **Install** button to launch the beginning
    of the modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have installed the Google Cloud Tools extension, we can connect to
    our Google account to deploy our project to App Engine. We achieve that by launching
    Google Cloud Explorer through the top-bar menu ( **Tools** | **Google Cloud Tools**
    | **Show Google** **Cloud Explorer** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Show Google Cloud Explorer](img/B22218_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Show Google Cloud Explorer
  prefs: []
  type: TYPE_NORMAL
- en: That opens up a new window to enter the information for our valid Google account.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Add a new account](img/B22218_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Add a new account
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have an integrated deployment assistant within the extension that deploys
    your application to the following compatible targets:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute Engine for ASP.NET applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible App Engine and Google Kubernetes Engine for ASP.NET Core applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deployment assistant automatically detects compatible targets for our project
    and guides us through the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment assistant can be called by selecting **Tools** | **Google Cloud
    Tools** | **Publish [PROJECT-NAME] to Google Cloud** , or by right-clicking on
    the project node in **Solution Explorer** and clicking on **Publish [PROJECT-NAME]**
    **to Google** .
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **Publish [PROJECT-NAME] to Google Cloud** menu item will only
    be enabled if the start-up project of the solution is compatible with Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment assistant displays the deployment targets on Google Cloud that
    are compatible with the selected project.
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to change the project, we can open Cloud Explorer by clicking on
    **Tools** | **Google Cloud Tools** | **Open Cloud Explorer** and select the project
    we want to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Choosing a product to publish](img/B22218_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Choosing a product to publish
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that ASP.NET 4.x applications only run on Windows VMs on Compute Engine.
    To deploy our ASP.NET 4.x application on Compute Engine, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the deployment assistant by clicking on **Tools** | **Google Cloud Tools**
    | **Publish [PROJECT-NAME] to** **Google Cloud** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Compute Engine** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Windows VM** instance and deployment credentials. The **Windows
    VM** must run **Internet Information Services** ( **IIS** )and be able to run
    ASP.NET 4.x applications, such as a VM ASP.NET created by the deployment manager.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the credentials for deployment. To create Windows credentials, click
    on **Manage Credentials** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Publish** to create our application and deploy it to the selected
    VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deployment progress is displayed in the Visual Studio output window, and
    a progress indicator is shown in the system tray status bar of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: The Deployment of ASP.NET Core applications can be run in a Docker container
    so that your application can be deployed in the flexible App Engine and **Google
    Kubernetes Engine** ( **GKE** ) environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy to the flexible environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the deployment assistant by clicking on **Tools** | **Google Cloud Tools**
    | **Publish [PROJECT-NAME] to** **Google Cloud** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **App Engine Flex** to deploy the app to App Engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of our application’s version and traffic management choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Publishing AspNetCore to App Engine](img/B22218_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Publishing AspNetCore to App Engine
  prefs: []
  type: TYPE_NORMAL
- en: The default version name is based on the current system time. We can specify
    another name. Note that, if we specify an existing version name, the previous
    version will be overwritten. The **Promoting version** checkbox allows us to choose
    whether this application version should receive 100% of the traffic. If this box
    is checked, the new application will receive all the traffic immediately after
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Publish** to create your application and deploy it to the flexible
    App Engine environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there we go – our application is deployed, and the progress is displayed
    in the Visual Studio output window.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy to **GKE** , follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the deployment assistant by clicking on **Tools** | **Google Cloud Tools**
    | **Publish [PROJECT-NAME] to** **Google Cloud** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Container Engine** to deploy our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a cluster for deployment, and enter the deployment name of your application,
    its version, and the number of replicated instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Publishing AspNetCore to Kubernetes Engine](img/B22218_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Publishing AspNetCore to Kubernetes Engine
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the three checkboxes allowing us to fine-tune our service:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Expose a service** option refers to the ability to make our application
    accessible from outside the Kubernetes cluster. Essentially, it creates a Kubernetes
    service that exposes our application to external traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Make service public** option is closely related to **Expose a service**
    and specifically refers to making the exposed service publicly accessible on the
    internet. When we choose to expose our application as a service and make it public,
    GKE assigns a public IP address to your service, allowing external clients to
    access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting **Open site after publishing** will automatically open a web browser
    window pointing to the URL of our newly deployed application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a cluster, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Create new cluster** . We will be redirected to the cluster creation
    page in the Google Cloud console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the cluster in Visual Studio, click on **Refresh clusters** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deployment name is used when creating the Kubernetes deployment or, if selected,
    the name of the Kubernetes service that will run our application on the cluster.
    We can modify the name to make it more descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we use a name that already exists, the old deployment will be updated
    instead of creating a new one. The default version name is based on the current
    system time. We can specify another name.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to expose a Kubernetes service on the internet. By exposing a
    public service on the internet, we get a public IP address that we can use to
    access our service outside of our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Publish** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And there we go – our application is containerized in a Docker image and deployed
    within our container. If our application is an exposed service, Visual Studio
    will wait for the service’s IP address to become available.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen how easy it is to deploy our applications to Google Cloud
    Platform gracefully with Google Cloud Tools, we will move on to the cloud platform
    of Amazon through the AWS Toolkit in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the AWS Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AWS Toolkit for Visual Studio is an extension designed to enhance the development
    experience for creating, testing, and deploying .NET applications on **WS** .
    In this section, we will explore how this extension simplifies working with AWS
    services within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to install the extension by going to **Extension Manager** through
    the top-bar menu ( **Extension** | **Manage extensions…** ) and searching for
    **AWS Toolkit with** **Amazon Q** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – AWS Toolkit with Amazon Q](img/B22218_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – AWS Toolkit with Amazon Q
  prefs: []
  type: TYPE_NORMAL
- en: As with each installation of new Visual Studio extensions, we need to close
    our instance after we have clicked on the **Install** button to launch the begin
    the modification.
  prefs: []
  type: TYPE_NORMAL
- en: Key AWS services that are integrated through the toolkit include **Amazon Simple
    Storage Service** ( **S3** ), **Amazone Elastic Compute Cloud** ( **EC2** ), AWS
    Elastic Beanstalk, and Amazon DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Once the extension is installed, we can start to configure it through the top-bar
    menu – **Extensions** | **AWS Toolkit** | **Getting Started** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – AWS Toolkit | Getting Started](img/B22218_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – AWS Toolkit | Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: 'That will allow us to connect to our AWS subscription to set up both of the
    main features of the AWS Toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS Explorer** : A central hub for navigating through AWS services, monitoring
    storage, and managing resources directly from Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Q** : Represents a comprehensive suite of AI-powered tools designed
    to facilitate better decision-making, increase productivity, and streamline operations
    across various domains within an organization, leveraging the power of generative
    AI and deep integration with AWS services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.21 – AWS Getting Started](img/B22218_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – AWS Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS Explorer is designed to provide us with a seamless way to interact with
    various AWS services directly from our development environment. It acts as a bridge
    between the local development environment and the cloud, allowing us to perform
    tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and managing AWS resources** : It allows us to easily create new
    instances on Amazon EC2, manage storage buckets in Amazon S3, and configure settings
    without leaving Visual Studio. We can now retrieve four project templates about
    AWS by adding a new project to our solution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.22 – An AWS project template](img/B22218_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – An AWS project template
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploying applications** : With support for AWS Lambda, we can deploy functions
    and applications to our AWS subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and management** : Through integration with AWS CloudFormation,
    we can manage infrastructure as code, ensuring consistency, repeatability, and
    version control over our AWS deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s consider a scenario where we want to deploy a simple serverless function
    using AWS Lambda with this toolset. Here’s how we might do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write the function locally** : First, we write a.NET Core function locally,
    testing it thoroughly to ensure that it works as expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Configure the deployment settings** : Using AWS Explorer, we configure the
    deployment settings, including selecting the appropriate runtime (.NET Core),
    setting up any necessary environment variables, and specifying the IAM role that
    will execute the function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deploy the function** : With just a few clicks or commands, we deploy the
    function to AWS Lambda. The AWS Explorer handles the packaging of the function
    code, uploading it to AWS, and configuring the necessary triggers or event sources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitor and manage** : Post-deployment, we can use the AWS Explorer to monitor
    the function’s performance, view logs, and make updates or changes as needed,
    all from within our development environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example illustrates how the AWS Explorer integrates with AWS services to
    simplify the development life cycle for .NET Core applications on AWS, providing
    a unified interface to create, deploy, and manage cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the advanced aspects of cloud integration and services
    using Visual Studio 2022. Emphasizing the importance of cloud computing in modern
    application development, we provided a detailed guide on leveraging Visual Studio’s
    powerful tools and extensions to build and manage cloud-based applications directly
    through the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this chapter, we mark the end of the second part of our journey
    in mastering core development skills. From advanced web development to multi-platform,
    machine learning, and now the advanced cloud, we have covered how Visual Studio
    enhances our cutting-edge development.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll continue to expand our horizons, delving into
    the world of DevOps, starting by handling advanced Git Workflow directly within
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Streamlining Collaborative Development with DevOps Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this third part, we focus on how Visual Studio streamlines modern DevOps
    workflows. You’ll explore how Visual Studio simplifies advanced Git workflows,
    automates continuous integration with GitHub Actions, and facilitates seamless
    collaboration through Azure DevOps. Additionally, you’ll leverage Visual Studio’s
    container tools for Docker, empowering you to optimize development, testing, and
    deployment within a unified DevOps environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B22218_09.xhtml#_idTextAnchor141) , *Handling Advanced Git Workflows*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B22218_10.xhtml#_idTextAnchor152) , *Continuous Integration
    with GitHub Actions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B22218_11.xhtml#_idTextAnchor159) , *Collaborative Development
    with Azure DevOps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B22218_12.xhtml#_idTextAnchor169) , *Visual Studio Container
    Tools for Docker*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
