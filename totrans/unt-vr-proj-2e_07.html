<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Locomotion and Comfort</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6">Up to this point in this book, the player's point-of-view camera has been stationary. In this chapter, we'll start to move around as we consider various techniques for locomotion and teleportation. </span>First, we'll dig deeper into the Unity standard character components, and then we move ourselves into a controllable first-person character and explore techniques to move around in the virtual world. We'll also discuss practices for managing motion sickness and sense of self within VR.</p>
<p class="calibre3">In this chapter, we will discuss the following topics:</p>
<ul class="calibre11">
<li class="calibre12">Unity's character objects and components</li>
<li class="calibre12">Glide locomotion</li>
<li class="calibre12">Comfort mode locomotion</li>
<li class="calibre12">Teleportation</li>
<li class="calibre12">Issues around VR motion sickness</li>
</ul>
<div class="packttip">Note that the projects in this chapter are separate and not directly required by the other chapters in this book. If you decide to skip any of it or not save your work, that's OK.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Unity characters</h1>
                </header>
            
            <article>
                
<p class="calibre3">A first-person character is such a key asset in a VR project that we really should understand its components inside out. So, before we go about building one for our project, it would be a good idea to take a close look at the built-in components and standard assets that Unity provides.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unity components</h1>
                </header>
            
            <article>
                
<p class="calibre3">As you probably know, each Unity game object contains a set of associated <strong class="calibre5">components</strong>. Unity includes many types of built-in components, which you can see by browsing the <span class="calibre6">Component</span> menu in the main menu bar. Each component adds properties and behaviors to the object that it belongs to. A component's properties are accessible via the Unity editor's <span class="calibre6">Inspector</span> panel and scripts. A script attached to a game object is also a type of a component and may have properties that you can set in the <span class="calibre6">Inspector</span> panel.</p>
<p class="calibre3">The component types used to implement first-person characters include the <strong class="calibre5">Camera</strong>, <strong class="calibre5">Character Controller</strong>, and/or <strong class="calibre5">Rigidbody</strong>, and various scripts. Let's review each of these standard components.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Camera component</h1>
                </header>
            
            <article>
                
<p class="calibre3">The Camera component specifies the viewing parameters that are used to render the scene on each frame update. Any object with a Camera component is considered a <kbd class="calibre13">camera</kbd> object. Naturally, we've been using a camera in our scenes since we started, and we've been accessing it in the scripts that we've written.</p>
<p class="calibre3">A stereographic VR camera object renders two views, one for each eye. In VR, the camera controller scripts read data from the headset's motion sensors and positional tracking to determine the current head pose (position, direction, and rotation) and set the camera's transform appropriately.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Rigidbody component</h1>
                </header>
            
            <article>
                
<p class="calibre3">When you add a Rigidbody component to any Unity game object, it will benefit from the calculations that are performed by the <strong class="calibre5">physics engine</strong>. Rigidbody components have parameters for gravity, mass, and drag, among others. During gameplay, the physics engine calculates each rigid object's <em class="calibre14">momentum</em> (mass, speed, and direction).</p>
<p class="calibre3">Rigid objects interact with other rigid objects. For example, if they collide, they'll bounce off each other and the parameters of the interaction can be controlled with a <strong class="calibre5">physic material</strong> with properties such as friction and bounciness factors.</p>
<p class="calibre3">Rigidbodies can be flagged as <em class="calibre14">kinematic</em>, which is usually only used when the object is driven by animation or scripts. Collisions will not affect kinematic objects, but they will still affect the motion of other rigidbodies. It's mostly used when objects are chained together with <em class="calibre14">joints</em>, like the ones connecting a humanoid's bones or a swinging pendulum.</p>
<p class="calibre3">Any rigid object, given a child camera object, becomes a rigid first-person character. Then, you can add scripts to handle user input to move, jump, look around, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Character Controller component</h1>
                </header>
            
            <article>
                
<p class="calibre3">Like a Rigidbody, the <strong class="calibre5">Character Controller</strong> (<strong class="calibre5">CC</strong>) is used for <em class="calibre14">collision detection</em> and c<em class="calibre14">haracter movement</em>. It needs scripts to handle the user input to move, jump, and look around, too. However, it doesn't automatically have the physics built in.</p>
<p class="calibre3">The CC component is specifically designed for character objects because characters in a game often are not really expected to behave the same as other physics-based objects. It can be used instead of, or in addition to, a Rigidbody.</p>
<p class="calibre3">The CC component has a built-in <strong class="calibre5">Capsule Collider</strong> behavior to detect collisions. However, it doesn't automatically use the physics engine to <em class="calibre14">respond</em> to the collision.</p>
<p class="calibre3">For example, if a CC object hits a rigid object such as a wall, it will just stop. It won't bounce. If a rigid object, such as a flying brick, hits a CC object, the brick will get deflected (bounce) based on its own properties, but the CC object will not be affected. Of course, if you want to include behavior like this on the CC object, you can program that in your own scripts.</p>
<p class="calibre3">The CC component does have an especially good support for one force in its scripting API-<em class="calibre14">gravity</em>. Built-in parameters are specifically related to keeping the object's feet on the ground. For example, the <span class="calibre6">Step Offset</span> parameter defines how tall a step the character can hop onto rather than being an obstacle that blocks his way. Similarly, the <span class="calibre6">Slope Limit</span> parameter says how big an incline is too steep and whether it should be treated like a wall. In your scripts, you can use the <kbd class="calibre13">Move()</kbd> method and the <kbd class="calibre13">IsGrounded</kbd> variable to implement character behavior.</p>
<p class="calibre3">Unless you script it, a CC object has no momentum and can stop on a dime. It feels very precise, but this could also lead to a jerky movement. The opposite is true for Rigidbody objects, which feel more fluid because they have momentum, acceleration/deceleration, and obey the laws of physics. In VR, we'd ideally like some combination of the two, if we use it at all.</p>
<p class="calibre3">Using physics to move yourself through a VR scene is not always best. <span class="calibre6">As we'll see, a</span>lternative locomotion techniques may not use physics at all, such as <em class="calibre14">teleportation</em>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unity Standard Assets</h1>
                </header>
            
            <article>
                
<p class="calibre3">The <span class="calibre6">Characters</span> package in Unity <span class="calibre6">Standard Assets</span> comes with a number of third- and first-person character prefab objects. These prefab objects are compared in the following table:</p>
<table border="1" class="calibre36">
<tbody class="calibre37">
<tr class="calibre38">
<td class="calibre39">
<div class="CDPAlignLeft">Prefab</div>
</td>
<td class="calibre39">
<p class="calibre3">Components</p>
</td>
</tr>
<tr class="calibre38">
<td class="calibre39">
<div class="mce-root1"><img src="assets/d0940b8a-38a4-4b13-969a-4b1b5cac138b.png" class="calibre24"/></div>
</td>
<td class="calibre39">
<div class="mce-root1"><img src="assets/a8740890-7967-42fd-af07-5609c393eac4.png" class="calibre24"/></div>
</td>
</tr>
<tr class="calibre38">
<td class="calibre39">
<div class="mce-root1"><img src="assets/490989ab-841b-495a-9204-5646b413ac21.png" class="calibre24"/></div>
</td>
<td class="calibre39">
<div class="mce-root1"><img src="assets/1032403f-6ec8-4c8b-b24f-aa129728c7a5.png" class="calibre24"/></div>
</td>
</tr>
<tr class="calibre38">
<td class="calibre39">
<div class="mce-root1"><img src="assets/bfab0187-3824-4c3b-a5f7-a48911127869.png" class="calibre24"/></div>
</td>
<td class="calibre39">
<div class="mce-root1"><img src="assets/85e9a57d-f56a-445a-889c-a68517db4061.png" class="calibre24"/></div>
</td>
</tr>
<tr class="calibre38">
<td class="calibre39">
<div class="mce-root1"><img src="assets/44832510-485f-43ea-a8e5-6752cd33d34f.png" class="calibre24"/></div>
</td>
<td class="calibre39">
<div class="mce-root1"><img src="assets/569cf22a-f936-4118-aa06-9b2b11755af7.png" class="calibre24"/></div>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">Let's discuss this in more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ThirdPersonController</h1>
                </header>
            
            <article>
                
<p class="calibre3">We've already used both of the third-person prefabs, <kbd class="calibre13">ThirdPersonController</kbd> and <kbd class="calibre13">AIThirdPersonController</kbd>, in <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10"><span>Chapter 2</span></a>, <em class="calibre14">Content, Objects, and Scale</em>, and <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10"><span>Chapter 4</span></a>, <em class="calibre14">Gaze-Based Control</em>, respectively.</p>
<p class="calibre3">The <kbd class="calibre13">ThirdPersonController</kbd> prefab has child objects that define the character's body, namely our friend Ethan. He is a rigged avatar (from the <kbd class="calibre13">.fbx</kbd> file), which means that humanoid animations can be applied to make him walk, run, jump, and so on.</p>
<p class="calibre3">The <kbd class="calibre13">ThirdPersonController</kbd> prefab uses a Rigidbody for physics and Capsule Collider for collision detection.</p>
<p class="calibre3">It has two scripts. A <kbd class="calibre13">ThirdPersonUserControl</kbd> script takes user input, such as thumbstick presses, and tells the character to move, jump, and so on. A <kbd class="calibre13">ThirdPersonCharacter</kbd> script implements physics movements and calls the animations that are needed for running, crouching, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">AIThirdPersonController</h1>
                </header>
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">AIThirdPersonController</kbd> prefab is identical to the <kbd class="calibre13">ThirdPersonController</kbd> prefab, but the former adds a <kbd class="calibre13">NavMeshAgent</kbd> and an <kbd class="calibre13">AICharacterControl</kbd> script, which constrains where and how the character can move around the scene. If you recall, in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10"><span>Chapter 4</span></a>, <em class="calibre14">Gaze-Based Control</em>, we used the <kbd class="calibre13">AICharacterController</kbd> to make Ethan walk around the scene and avoid bumping into objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First-person FPSController</h1>
                </header>
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">FPSController</kbd> prefab is a first-person controller that uses both a CC component and a Rigidbody. It has a child camera attached to it. When the character moves, the camera moves with it.</p>
<div class="packttip">The core distinction between third-person controller prefabs and first-person controller prefabs is the <strong class="calibre1">child object</strong>. Third-person controller prefabs have a rigged humanoid child object, while first-person controller prefabs have a camera child object.</div>
<p class="calibre3">Its body mass is set to a low value (<kbd class="calibre13">1</kbd>) and <kbd class="calibre13">IsKinematic</kbd> is enabled. This means that it will have limited momentum and does not react to other rigid objects, but it can be driven by animations.</p>
<p class="calibre3">Its <kbd class="calibre13">FirstPersonController</kbd> script offers a plethora of parameters for running, jumping, audio footsteps, and more. The script also includes parameters and animations for a <em class="calibre14">head bob</em>, which bounces the camera in a natural way when the character is moving. If you use the <kbd class="calibre13">FPSController</kbd> script in your VR project, <em class="calibre14">be sure to disable any head bob features</em> or you might need to clean the puke off your keyboard!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RigidBodyFPSController</h1>
                </header>
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">RigidBodyFPSController</kbd> prefab is a first-person controller with a Rigidbody but no CC component. Like <kbd class="calibre13">FPSController</kbd>, it has a child camera object. When the character moves, the camera moves with it.</p>
<p class="calibre3">A <kbd class="calibre13">RigidBodyFPSController</kbd> prefab's body mass is more substantial, set to 10, and is not kinematic. That is, it <em class="calibre14">can</em> get bounced around when it collides with other objects. It has a separate Capsule Collider component with the <kbd class="calibre13">ZeroFriction</kbd> physic material. The <kbd class="calibre13">RigidBodyFirstPersonController</kbd> script is different from the <kbd class="calibre13">FPSController</kbd> one, but the former has a lot of similar parameters.</p>
<div class="packtinfobox"><strong class="calibre1">Why am I going through all of this detail here?<br class="title-page-name"/></strong>If you've built any non-VR projects in Unity, then you've most likely used these prefabs. However, you might not have paid much attention to how they're assembled. Virtual reality is experienced from the first-person perspective. Our implementation toolbox is Unity. It is important to understand Unity's tools that manage and control this first-person experience.<strong class="calibre1"><br class="title-page-name"/></strong></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using glide locomotion</h1>
                </header>
            
            <article>
                
<p class="calibre3">For our locomotion features in this chapter, let's take an <em class="calibre14">agile</em> approach to development. This means (in part) that we'll start by defining our new feature, or story, with a set of requirements. Then, we'll incrementally build and test this feature, one requirement at a time, by iterating and refining our work as we go along. Experimentation is not only allowed, it's encouraged.</p>
<div class="packtinfobox"><strong class="calibre1">Agile software development</strong> is a broad term for methodologies that encourage small incremental and iterative development in a fashion that's easy to respond to changing and refined requirements. See the Agile Manifesto at <a href="http://agilemanifesto.org/" class="calibre20">http://agilemanifesto.org/</a><span>.</span></div>
<p class="calibre3">The feature we want to implement is this: as a first-person character, when I start walking, I will move through the scene in the direction I am looking until I indicate to stop walking. Here are the requirements to achieve this feature:</p>
<ul class="calibre11">
<li class="calibre12">Move in the direction you're looking</li>
<li class="calibre12">Keep your feet on the ground</li>
<li class="calibre12">Don't pass through solid objects</li>
<li class="calibre12">Don't fall off the edge of the world</li>
<li class="calibre12">Step over small objects and handle uneven terrain</li>
<li class="calibre12">Start and stop moving by clicking an input button</li>
</ul>
<p class="calibre3">This sounds reasonable.</p>
<p class="calibre3">To begin, i<span class="calibre6">f you have a saved version of the scene from <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, you can start with that. Or, build a similar simple new scene containing a ground plane, some 3D objects as obstacles, and a copy of your <kbd class="calibre13">MeMyselfEye</kbd> prefab.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Move in the direction you're looking</h1>
                </header>
            
            <article>
                
<p class="calibre3">We already have a <kbd class="calibre13">MeMyselfEye</kbd> object containing the camera rig. We're going to turn it into a first-person controller. Our first requirement is to move about the scene in the direction you're looking. Add a script named <kbd class="calibre13">GlideLocomotion</kbd>. Keeping it simple, let's start by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">MeMyselfEye</kbd> object in the <span>Hierarchy</span> panel</li>
<li class="calibre12">In the <span>Inspector</span> panel, select <span>Add Component</span> | <span>New Script</span> and name it <kbd class="calibre13">GlideLocomotion</kbd></li>
</ol>
<p class="calibre3">Then, open the script and code it, as follows:</p>
<pre class="calibre18">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour <br class="title-page-name"/>{ 
  public float velocity = 0.4f; 
 
  void Update () <br class="title-page-name"/>  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
    transform.position += moveDirection; 
  } 
} </pre>
<p class="calibre3">The normal walking speed for humans is about 1.4 meters per second. In VR, that could make you feel sick. Let's travel a lot slower than that, at 0.4 m/s. During <kbd class="calibre13">Update()</kbd>, we check the current direction in which the player is looking (<kbd class="calibre13">camera.transform.forward</kbd>) and move the <kbd class="calibre13">MeMyselfEye</kbd> transform position in this direction at the current velocity.</p>
<p class="calibre3">Note the coding shortcuts for the self-modification of a variable (<kbd class="calibre13">*=</kbd> and <kbd class="calibre13">+=</kbd>). The last two lines of the preceding code could have been written out like this:</p>
<pre class="calibre18">moveDirection = moveDirection * velocity * Time.deltaTime; 
transform.position = transform.position  + moveDirection; </pre>
<p class="calibre3">Here, I used the <kbd class="calibre13">*=</kbd> and <kbd class="calibre13">+=</kbd> operators instead. Save the script and the scene and try it in VR.</p>
<p class="calibre3">When you look forward, you move forward. Look left, move left. Look right, move right. It works!</p>
<p class="calibre3">Look up... <em class="calibre14">Whoa!! Did you expect that?! We're freakin' flying!</em> You can move up, down, and all around as if you're Superman or piloting a drone. Presently, <kbd class="calibre13">MeMyselfEye</kbd> has no mass and physics and does not respond to gravity. Nonetheless, it meets our requirement to move in the direction you're looking. So, let's continue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keep your feet on the ground</h1>
                </header>
            
            <article>
                
<p class="calibre3">The next requirement wants you to keep your feet on the ground. We know that <kbd class="calibre13">GroundPlane</kbd> is flat and positioned at <span class="calibre6">Y</span> = <kbd class="calibre13">0</kbd>. So, let's just add this simple constraint to the <kbd class="calibre13">GlideLocomotion</kbd> script, as follows:</p>
<pre class="calibre18">  void Update () <br class="title-page-name"/>  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
<strong class="calibre1">    moveDirection.y = 0f;</strong> 
    transform.position += moveDirection; 
  } </pre>
<p class="calibre3">Save the script and try it in VR.</p>
<p class="calibre3">Not bad. Now, we can move around the <span class="calibre6">Y</span> = <kbd class="calibre13">0</kbd> plane.</p>
<p class="calibre3">On the other hand, you're like a ghost, readily passing through the cube, sphere, and the other objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Don't pass through solid objects</h1>
                </header>
            
            <article>
                
<p class="calibre3">The third requirement states <em class="calibre14">don't pass through solid objects</em>. Here's an idea. Give it a Rigidbody component, a collider, and let the physics engine take care of it. Follow these steps:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">MeMyselfEye</kbd> object in the <span>Hierarchy</span> panel</li>
<li class="calibre12">In the <span>Inspector</span> panel, navigate to <span>Add Component</span> | <span>Physics</span> | <span>Rigidbody</span></li>
<li class="calibre12">Then <span>Add Component | Physics | Capsule Collider</span></li>
<li class="calibre12">Set the Capsule Collider <span>Height</span> to <span>2</span></li>
<li class="calibre12">If your Character Controller's capsule collider (green mesh in the Scene window) extends through the ground plane, adjusts its<span> </span><span>Center Y</span><span> </span>to <kbd class="calibre13">1</kbd></li>
</ol>
<p class="calibre3">Try it in VR.</p>
<p class="calibre3"><em class="calibre14">Whoa!! What the...?</em> It was going fine there for a second, but as soon as you knock into the cube, you go spinning out of control in wild directions, like a spacewalk gone bad in the movie <em class="calibre14">Gravity</em>. Well, that's a Rigidbody for you. Forces are being applied in all directions and axes. Let's add some constraints as follows.</p>
<p class="calibre3">In the <span class="calibre6">Inspector</span> panel's <span class="calibre6">Rigidbody</span> pane, check off the checkboxes for <span class="calibre6">Freeze Position: Y</span> and <span class="calibre6">Freeze Rotation: X</span> and <span class="calibre6">Z</span>.</p>
<p class="calibre3">Try it in VR.</p>
<p class="calibre3">Now that's pretty nice! You're able to move by looking in a direction, you're not flying (<span class="calibre6">Y</span> position constrained), and you don't pass through solid objects. Instead, you slide past them since only the <span class="calibre6">Y</span> rotation is allowed.</p>
<p class="calibre3">If your <kbd class="calibre13">KillTarget</kbd> script is still running (from <a href="b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml" target="_blank" class="calibre10"><span>Chapter 2</span></a>, <em class="calibre14">Content, Objects, and Scale</em>), you should be able to stare at Ethan until he explodes. Do it, make Ethan explode... <em class="calibre14">Whoa!</em> We just got blown out of here by the explosion, spinning out of control in wild directions again. Maybe we're just not ready for this powerful physics engine yet. We can probably address this in the scripting, but for the time being, let's abandon the Rigidbody idea. We'll come back to it in the next chapter.</p>
<p class="calibre3">You may recall that CC includes a Capsule Collider and supports movement that is constrained by collisions. We'll try that instead, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In the <span>Inspector</span> panel, click on the <span>Rigidbody</span> pane's <em class="calibre2">gear</em> icon and select <span>Remove Component</span></li>
<li class="calibre12">Also, remove its <span>Capsule Collider</span> component</li>
<li class="calibre12">In the <span>Inspector</span> panel, navigate to <span>Add Component</span> | <span>Physics</span> | <span>Character Controller</span></li>
<li class="calibre12">If your Character Controller's capsule collider (green mesh in the Scene window) extends through the ground plane, adjusts its <span>Center Y</span> to <kbd class="calibre13">1</kbd></li>
</ol>
<p class="calibre3">Modify the <kbd class="calibre13">GlideLocomotion</kbd> script, as follows:</p>
<pre class="calibre18">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour <br class="title-page-name"/>{ 
  public float velocity = 0.4f; 
 
<strong class="calibre1">  private CharacterController character;<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre1">  void Start () <br class="title-page-name"/>  {<br class="title-page-name"/></strong><strong class="calibre1">    character = GetComponent&lt;CharacterController&gt;();<br class="title-page-name"/></strong><strong class="calibre1">  }</strong> 
 
  void Update () <br class="title-page-name"/>  { 
    Vector3 moveDirection = Camera.main.transform.forward; 
    moveDirection *= velocity * Time.deltaTime; 
    moveDirection.y = 0.0f; 
<strong class="calibre1">    character.Move(moveDirection);</strong> 
  } 
}</pre>
<p class="calibre3">Instead of updating <kbd class="calibre13">transform.position</kbd> directly, we called the built-in <kbd class="calibre13">CharacterController.Move()</kbd> function and let it do it for us. It knows that the characters should behave with certain constraints.</p>
<p class="calibre3">Save the script and try it in VR.</p>
<p class="calibre3">This time, when we bump into objects (a cube or sphere), we kind of go over it and then remain in the air. The <kbd class="calibre13">Move()</kbd> function does not apply gravity to the scene for us. We need to add that to the script, which isn't so hard (see the Unity API docs at <a href="http://docs.unity3d.com/ScriptReference/CharacterController.Move.html" class="calibre10"><span>http://docs.unity3d.com/ScriptReference/CharacterController.Move.html</span></a>).</p>
<p class="calibre3">However, there is a simpler way. The <kbd class="calibre13">CharacterController.SimpleMove()</kbd> function applies gravity to the move for us. Just replace the whole <kbd class="calibre13">Update()</kbd> function with the following one-liner:</p>
<pre class="calibre18">    <strong class="calibre1">  void Update () <br class="title-page-name"/>      {</strong>
    <strong class="calibre1">    character.SimpleMove(Camera.main.transform.forward * velocity);</strong>
    <strong class="calibre1">  }</strong>
  </pre>
<p class="calibre3">The <kbd class="calibre13">SimpleMove()</kbd> function takes care of gravity and also handles <kbd class="calibre13">Time.deltaTime</kbd>. So, all that we need to give it is the movement direction vector. Also, since it's introducing gravity, we don't need the <span class="calibre6">Y</span> = <kbd class="calibre13">0</kbd> constraint either. Much simpler.</p>
<p class="calibre3">Save the script and try it in VR.</p>
<p class="calibre3">Awesome! I think we've met all the requirements so far. <em class="calibre14">Just don't go walking off the edge...</em></p>
<div class="packttip">The exercises in this section assume you're using VR in seated or standing mode, not room-scale. We're modifying the whole MyMyselfEye rig as we move the player. In room-scale, that's moving the play area bounds as well. Since we're attaching the collider to the MyMyselfEye position, if you physically step away from the center of the play area, the collider will not be aligned with your actual body position. Later on, w<span>e will address issues of locomotion with room-scale VR.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Don't fall off the edge of the world</h1>
                </header>
            
            <article>
                
<p class="calibre3">Now that we have gravity, if we walk off the edge of the ground plane, you'll fall into oblivion. Fixing this isn't a first-person character thing. Just add some railings to the scene.</p>
<p class="calibre3">Use cubes, scaling them to the desired thickness and length and moving them into position. Go ahead and do it. I won't give you the step-by-step instructions for it. For example, I used these transforms:</p>
<ul class="calibre11">
<li class="calibre12"><span>Scale</span>: <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">10.0</kbd></li>
<li class="calibre12">Railing 1: <span>Position</span>: <kbd class="calibre13">-5</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">0</kbd></li>
<li class="calibre12">Railing 2: <span>Position</span>: <kbd class="calibre13">5</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">0</kbd></li>
<li class="calibre12">Railing 3: <span>Position</span>: <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">-5</kbd>; <span>Rotation</span>: <kbd class="calibre13">0</kbd>, <kbd class="calibre13">90</kbd>, <kbd class="calibre13">0</kbd></li>
<li class="calibre12">Railing 4: <span>Position</span>: <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>, <kbd class="calibre13">5</kbd>; <span>Rotation</span>: <kbd class="calibre13">0</kbd>, <kbd class="calibre13">90</kbd>, <kbd class="calibre13">0</kbd></li>
</ul>
<p class="calibre3">Try it in VR. Try to walk through the railings. Whew! This is safer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stepping over small objects and handling uneven terrain</h1>
                </header>
            
            <article>
                
<p class="calibre3">While we're at it, add a few things to walk on and over, such as a ramp and other obstacles. The result will look like this:</p>
<div class="mce-root1"><img class="calibre24" src="assets/216d0ee2-2f12-4c85-8a59-38ca4a4ea4ad.png"/></div>
<p class="calibre3">Try it in VR. Walk up the ramp and step off the cube. Hey, this is fun!</p>
<p class="calibre3"><span class="calibre6">The CC component is taking care of the requirement to step over small objects and handle uneven terrain. You might want to tinker with its</span> <span class="calibre6">Slope Limit</span> <span class="calibre6">and</span> <span class="calibre6">Step Offset</span> <span class="calibre6">settings.</span></p>
<p class="calibre3"><strong class="calibre5">Caution</strong>: Glide locomotion can cause motion sickness, especially for players who are susceptible. Please use it with caution in your apps. This may become especially noticeable as you glide up the ramp and then jump off the block onto the ground plane. On the other hand, some people love rollercoaster VR! Also, giving the player control of the locomotion through a mechanic as simple as a button press can go a long way in helping reduce queasiness and motion sickness, which we'll add next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting and stopping movement</h1>
                </header>
            
            <article>
                
<p class="calibre3">The next requirement is <em class="calibre14">to start and stop moving by clicking an input button</em>. We'll look for a button press using the logical <kbd class="calibre13">"Fire1"</kbd> button. If you want to use a different button, or if you're targeting a platform that does not have a mapping to <kbd class="calibre13">"Fire1"</kbd> please refer to <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>, under the topic <em class="calibre14">Basic button input</em>. </p>
<p class="calibre3">Modify the <kbd class="calibre13">GlideLocomotion</kbd> script as follows:</p>
<pre class="calibre18">using UnityEngine; 
 
public class GlideLocomotion : MonoBehaviour <br class="title-page-name"/>{ 
  public float velocity = 0.7f; <br class="title-page-name"/> 
  private CharacterController controller; <br class="title-page-name"/>  <strong class="calibre1">private bool isWalking = false;</strong> <br class="title-page-name"/> 
  void Start() <br class="title-page-name"/>  { 
    controller = GetComponent&lt;CharacterController&gt; (); 
  } 
 
  void Update () { 
<strong class="calibre1">    if (<span>Input.GetButtonDown("Fire1")</span>) <br class="title-page-name"/>        isWalking = true;<br class="title-page-name"/>    else if (Input.GetButtonUp("Fire1"))<br class="title-page-name"/>        isWalking = false;<br class="title-page-name"/></strong><strong class="calibre1"><br class="title-page-name"/></strong><strong class="calibre1">    if (isWalking) {<br class="title-page-name"/></strong>      controller.SimpleMove (Camera.main.transform.forward * velocity);<br class="title-page-name"/>    }
  } 
} </pre>
<p class="calibre3">On Daydream, you may call <kbd class="calibre13">GvrControllerInput.ClickButtonDown</kbd> and <kbd class="calibre13">ClickButtonUp</kbd> instead.</p>
<p class="calibre3">By adding a Boolean <kbd class="calibre13">isWalking</kbd> flag, we can switch the forward movement on and off, which can be signaled by a key press.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding comfort mode locomotion</h1>
                </header>
            
            <article>
                
<p class="calibre3">We have mentioned the potential of motion sickness several times already in this chapter, and earlier in this book. In general, the more control you give the player in moving around within VR the better off she'll be and reduce the risk of feeling queasy. Offering a button to start/stop motion is one step, as we just saw. Another is what's commonly referred to as <em class="calibre14">comfort mode</em>.</p>
<p class="calibre3">It's been discovered that using glide locomotion around curves is worse that simply going in a straight line. So, one technique for getting around in a VR scene is only allow forward motion, regardless of which direction the player is looking, and then use the thumbstick to change direction. Also, rather than allow the thumbstick to change the direction angle continuously, we limit it to fixed angle steps of 30 degrees, for example. We'll add this to our <kbd class="calibre13">GlideLocomotion</kbd> script as follows. </p>
<p class="calibre3">At the top of the class, add the following variables:</p>
<pre class="calibre18"> public float comfortAngle = 30f;<br class="title-page-name"/><span> private bool hasRotated = true;</span></pre>
<p class="calibre3">Then in <kbd class="calibre13">Update()</kbd>, add the following statements:</p>
<pre class="calibre18">  void Update()<br class="title-page-name"/>  {<br class="title-page-name"/>    if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>      isWalking = true;<br class="title-page-name"/>    else if (Input.GetButtonUp("Fire1"))<br class="title-page-name"/>      isWalking = false;<br class="title-page-name"/><br class="title-page-name"/>    if (isWalking)<br class="title-page-name"/>      <strong class="calibre1">character.SimpleMove(transform.forward * velocity);</strong><br class="title-page-name"/><br class="title-page-name"/>    float axis = Input.GetAxis("Horizontal"); <br class="title-page-name"/>    if (axis &gt; 0.5f)<br class="title-page-name"/>    {<br class="title-page-name"/>      if (!hasRotated)<br class="title-page-name"/>        transform.Rotate(0, comfortAngle, 0);<br class="title-page-name"/>      hasRotated = true;<br class="title-page-name"/>    }<br class="title-page-name"/>    else if (axis &lt; -0.5f)<br class="title-page-name"/>    {<br class="title-page-name"/>      if (!hasRotated)<br class="title-page-name"/>        transform.Rotate(0, -comfortAngle, 0);<br class="title-page-name"/>      hasRotated = true;<br class="title-page-name"/>    } <br class="title-page-name"/>    else<br class="title-page-name"/>    {<br class="title-page-name"/>      hasRotated = false;<br class="title-page-name"/>    }<br class="title-page-name"/>  }</pre>
<p class="calibre3">Now, when the <kbd class="calibre13">"Fire1"</kbd> button is pressed and <kbd class="calibre13">isWalking</kbd> is true, we move the <kbd class="calibre13">MeMyselfEye</kbd> forward in the direction indicated in its transform, rather than the <kbd class="calibre13">Camera</kbd> look directions, changing the line to <kbd class="calibre13">character.SimpleMove(transform.forward * velocity)</kbd>.</p>
<p class="calibre3">When the user pushes the thumbstick to the right, that is, the logical <kbd class="calibre13">"Horizontal"</kbd> axis is positive, we will rotate the rig clockwise by 30 degrees (<kbd class="calibre13">comfortAngle</kbd>). When the thumbstick is pressed left, we rotate counter-clockwise. We check for greater than 0.5 rather than exactly 1.0 so the player does not need to jam the stick all the way to the edge.</p>
<p class="calibre3">We don't want to keep rotating, again and again, each update while the joystick is pressed, so we set a flag, <kbd class="calibre13">hasRotated</kbd>, and then ignore the axis until it comes to rest at the zero position. Then, we'll allow the player to press it again.</p>
<p class="calibre3">The result is a comfortable navigation mechanic where one button moves you forward and another lets you change direction in large increments. </p>
<p class="calibre3">For your reference, some button mappings used in this mechanic are as follows:</p>
<ul class="calibre11">
<li class="calibre12">In OpenVR on HTC VIVE, <kbd class="calibre13">"Fire1"</kbd> is the menu button on one controller, <kbd class="calibre13">"Horizontal"</kbd> is touching the touchpad on the other controller. </li>
<li class="calibre12">In OpenVR on Oculus, <kbd class="calibre13">"Fire1"</kbd> is the right controller's <span>B</span> button, <kbd class="calibre13">"Horizontal"</kbd> is the left controller thumbstick. </li>
<li class="calibre12">On Daydream, you should modify the code to use <kbd class="calibre13">GvrControllerInput</kbd>. To detect horizontal clicks on the touchpad, call <kbd class="calibre13">GvrControllerInput.TouchPosCentered</kbd>, which returns a <kbd class="calibre13">Vector2</kbd>, and check <kbd class="calibre13">x</kbd> for values between <kbd class="calibre13">-1</kbd> and <kbd class="calibre13">1</kbd>. For example, replace the call to GetAxis with the following:</li>
</ul>
<pre class="calibre18">    Vector2 touchPos = GvrControllerInput.TouchPosCentered;<br class="title-page-name"/>    float axis = touchPos.x;<br class="title-page-name"/>    if (axis &gt; 0.5f) ...</pre>
<p class="calibre3">You're encouraged to extend the <kbd class="calibre13">ButtonTest()</kbd> function used in the beginning of <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>, to determine which button mappings, axes, and SDK functions work best for your target VR device.</p>
<p class="calibre3"><span class="calibre6">We just implemented glide locomotion, where you move forward smoothly in the direction you're looking, or with comfort mode, in the direction your body is facing, while your head can look around. </span><span class="calibre6">Comfort mode reduces the chance of motion sickness by having you change the direction you're facing in jumps of 30-degree angles. But even that may not be comfortable enough, and some developers (and players) prefer no gliding at all, and instead let you just <em class="calibre14">teleport</em> from one location to another.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other locomotion considerations</h1>
                </header>
            
            <article>
                
<p class="calibre3">If you want to offer your players a VR ride, you can define a predefined <em class="calibre14">track</em> to glide along, like a guided tour of a building or art gallery. T<span class="calibre6">racks can be 3D, moving you up and down too, with gravity, </span>such as VR roller coasters, or without gravity, such as a space tour. We do not recommend this mechanic except for the most hardcore thrill seekers as it has a good chance of causing motion sickness. </p>
<p class="calibre3"><span class="calibre6">Another technique for comfort during locomotion is <strong class="calibre5">Tunneling</strong>. During the movement, the camera is cropped with a vignette and simple background, like a grid, is displayed in the player's peripheral vision, so the user only sees what is directly before them. Eliminating peripheral vision while moving can reduce the chance of motion sickness.</span></p>
<p class="calibre3">For vertical locomotion, apps have implemented a climbing mechanic, using your hands to reach, grab, and pull yourself up. Mountain climbing simulation games such as The Climb (<a href="http://www.theclimbgame.com/" class="calibre10">http://www.theclimbgame.com/</a>) takes this idea to the next level (literally!), providing a number of different reach mechanics and grip types to grab onto.</p>
<p class="calibre3">Other apps have also tried using your hands, not for climbing, but for walking. For example, reaching and pulling like a rope, or swinging your arms like a runner, or even a circular pulling motion like you're operating a wheelchair.</p>
<p class="calibre3">Of course, there are hardware devices, such as that implement locomotion mechanisms using your feet to walk and run. Examples include:</p>
<ul class="calibre11">
<li class="calibre12">VR treadmills such as Virtuix Omni (<a href="http://www.virtuix.com/" class="calibre10">http://www.virtuix.com/</a>) and <span>VR Virtualizer (<a href="https://www.cyberith.com/" class="calibre10">https://www.cyberith.com/</a>), where you walk in place with your feet and legs to walk and run in VR.</span></li>
<li class="calibre12">Exercise bikes such as VirZoom (<a href="https://www.virzoom.com/" class="calibre10">https://www.virzoom.com/</a>) where you can bike and even hang glide in VR.</li>
<li class="calibre12">Body tracking sensors can be used not just for player locomotion but also motion capture for creating character animations. Devices include Optitrack (<a href="http://optitrack.com/motion-capture-virtual-reality/" class="calibre10">http://optitrack.com/motion-capture-virtual-reality/</a>), Perception Neuron (<a href="https://neuronmocap.com/" class="calibre10">https://neuronmocap.com/</a>), ProVR (<a href="http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html" class="calibre10">http://www.vrs.org.uk/virtual-reality-gear/motion-tracking/priovr.html</a>), and others.</li>
</ul>
<p class="calibre3">You probably need to write your app specifically for that device as there are no standards for these body tracking devices, but they're certainly a lot of fun.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Techniques for teleportation</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6"><strong class="calibre5">Pointer teleportation</strong> is a mechanic where you point to a location you want to go to, and you jump there. No gliding. You just teleport to the new location. A laser beam or arc may be drawn, along with a teleport location receptacle to indicate where you may go.</span></p>
<p class="calibre3">As we've seen in previous chapters, we can make our own scripts. But since this is a core feature of VR applications, teleportation components are often included with device SDK toolkits. We'll write our own and consider some provided ones afterward.</p>
<p class="calibre3"><span class="calibre6">To begin, i</span><span class="calibre6">f you have a saved version of the scene from <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, you can start with that. You may disable a few objects that we do not need, including <kbd class="calibre13">Ethan</kbd> and <kbd class="calibre13">WalkTarget</kbd>. Or, build a similar simple new scene containing a ground plane, some 3D objects as obstacles, and a copy of your <kbd class="calibre13">MeMyselfEye</kbd> prefab.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looking to teleport</h1>
                </header>
            
            <article>
                
<p class="calibre3">The mechanic we'll implement for our homegrown teleportation will work on any VR platform, using gaze-based pointing. Similar to how we controlled Ethan the zombie in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, we'll cast a ray from the player's camera view to the ground plane to choose a move-to location.</p>
<p class="calibre3">In our script, we'll use button press to initiate the teleport and release to jump there if you've selected a valid location. Alternatively, you could consider other input such as<span class="calibre6"> a forward push of the thumbstick using</span> <kbd class="calibre13">Input.GetAxis</kbd>(v<em class="calibre14">ertical</em>) .</p>
<p class="calibre3"><span class="calibre6">First, let's create a teleport marker (similar to the WalkTarget one), as follows:</span></p>
<ol class="calibre15">
<li class="calibre12">Add an empty game object to the<span> </span><span>Hierarchy</span><span> </span>panel, and rename it<span> </span><kbd class="calibre13">TeleportMarker</kbd>.</li>
<li class="calibre12">Reset its<span> </span><span>Transform</span><span> </span>values to position (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>) (using the gear icon in the upper-right of the Transform pane).</li>
<li class="calibre12">Right-click on the mouse and navigate to<span> </span><span>3D Object</span> |<span> </span><span>Cylinder</span>. This will create a cylindrical object parented by<span> </span><kbd class="calibre13">TeleportMarker</kbd>. </li>
<li class="calibre12">Reset its transform and change the<span> </span><span>Scale</span><span> </span><span>to (</span><kbd class="calibre13">0.4</kbd><span>,</span><span> </span><kbd class="calibre13">0.05</kbd><span>,</span><span> </span><kbd class="calibre13">0.4</kbd><span>). This will create a flat disk with a diameter of</span><span> </span><kbd class="calibre13">0.4</kbd><span>.</span></li>
<li class="calibre12">Disable or remove its<span> </span><span>Capsule Collider</span>.</li>
</ol>
<p class="calibre3">For now, we'll use the default material. Or, you could decorate your marker with another material. (For example, if you have Steam <kbd class="calibre13">InteractionSystem</kbd> installed, try the <kbd class="calibre13">TeleportPointVisible</kbd> material. If you have Daydream Elements installed, try the <kbd class="calibre13">TeleportGlow</kbd> material.)</p>
<p class="calibre3">Now, let's write the script:</p>
<ol class="calibre15">
<li class="calibre12">Select the<span> </span><kbd class="calibre13">MeMyselfEye</kbd><span> </span><span>object in the</span><span> </span><span>Hierarchy</span><span> </span><span>panel</span></li>
<li class="calibre12">Disable or remove the <kbd class="calibre13">GlideLocomotion</kbd> component, if present</li>
<li class="calibre12">Select<span> </span><span>Add Component</span><span> </span>|<span> </span><span>New Script</span><span> </span>and name it<span> </span><kbd class="calibre13">LookTeleport</kbd></li>
</ol>
<p class="calibre3">Write the script as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class LookTeleport : MonoBehaviour<br class="title-page-name"/>{<br class="title-page-name"/>    public GameObject target;<br class="title-page-name"/>    public GameObject ground;<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        Transform camera = Camera.main.transform;<br class="title-page-name"/>        Ray ray;<br class="title-page-name"/>        RaycastHit hit;<br class="title-page-name"/><br class="title-page-name"/>        if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>        {<br class="title-page-name"/>          // start searching<br class="title-page-name"/>          target.SetActive(true);<br class="title-page-name"/>        }<br class="title-page-name"/>        else if (Input.GetButtonUp("Fire1")) <br class="title-page-name"/>        {<br class="title-page-name"/>          // done searching, teleport player<br class="title-page-name"/>          target.SetActive(false);<br class="title-page-name"/>          transform.position = target.transform.position;<br class="title-page-name"/>        }<br class="title-page-name"/>        else if (target.activeSelf)<br class="title-page-name"/>        {<br class="title-page-name"/>          ray = new Ray(camera.position, camera.rotation * Vector3.forward);<br class="title-page-name"/>          if (Physics.Raycast(ray, out hit) &amp;&amp; <br class="title-page-name"/>              (hit.collider.gameObject == ground))<br class="title-page-name"/>          {<br class="title-page-name"/>            // move target to look-at position<br class="title-page-name"/>            target.transform.position = hit.point;<br class="title-page-name"/>          }<br class="title-page-name"/>          else<br class="title-page-name"/>          {<br class="title-page-name"/>            // not looking a ground, reset target to player position<br class="title-page-name"/>            target.transform.position = transform.position;<br class="title-page-name"/>          }<br class="title-page-name"/>       }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">The script works as follows:</p>
<ul class="calibre11">
<li class="calibre12">When the player clicks, targeting begins, and the target marker is made visible (<kbd class="calibre13">SetActive(true)</kbd>).</li>
<li class="calibre12">While targeting, we identify what the player is looking at (<kbd class="calibre13">Raycast</kbd>). And if it's the ground, we position the target there (<kbd class="calibre13">hit.point</kbd>). Otherwise, the target is reset to the player's position.</li>
<li class="calibre12">When the player stops pressing the button, the target is hidden. And we position the player to the target's current position, thus completing the teleportation.</li>
</ul>
<p class="calibre3"><span class="calibre6">Notice that we are using the <kbd class="calibre13">TeleportMarker</kbd> target to store the state of our teleport mechanic while in targeting mode. When the target is active, we're targeting. When we exit targeting, we use the target's position as the new player position.</span></p>
<p class="calibre3"><span class="calibre6">Save the script and in Unity:</span></p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">GroundPlane</kbd> object onto the Ground slot</li>
<li class="calibre12">Drag the <kbd class="calibre13">TeleportMarker</kbd> object onto the Target slot</li>
</ol>
<p class="calibre3">Press <span class="calibre6">Play</span>. Pressing the input button will activate the target marker, which moves as you look. On releasing the button, you teleport to that position. You can cancel the teleport by looking at something other than the ground and releasing the button.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleporting between surfaces</h1>
                </header>
            
            <article>
                
<p class="calibre3">In the previous script, we're using a plain Raycast to determine where to place the <kbd class="calibre13">TeleportMarker</kbd>. This really only works on Plane objects. For any other 3D object, the hit point might be any surface, not just the topside walkable one. </p>
<p class="calibre3">An alternative approach is to use NavMesh to identify surfaces you can teleport to within the scene. Back in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, we generated a NavMesh for Ethan's <kbd class="calibre13">AIThirdPersonController</kbd> to control where he's allowed to roam. This time, we also use the NavMesh to determine where we (<kbd class="calibre13">MeMyselfEye</kbd>) can go. Feel free to go back and review our conversations about NavMesh.</p>
<p class="calibre3">The advantage of this approach is the available teleportation locations can be a subset of the ground plane. There can be can be multiple other object surfaces and even complex terrains. The teleportation locations will be limited to valid flat or slightly sloped surfaces. </p>
<p class="calibre3">In case you skipped that section, or if you've rearranged objects in your scene since then, we will regenerate the NavMesh now:</p>
<ol class="calibre15">
<li class="calibre12">Select the<span> </span><span>Navigation</span><span> </span>panel. If it's not already a tab in your editor, open the Navigation window from the main menu by navigating to<span> </span><span>Window</span><span> </span>|<span> </span><span>Navigation</span>.</li>
<li class="calibre12">Select its<span> </span><span>Object</span><span> </span>tab.</li>
<li class="calibre12">Select the <span>Ground Plane</span> in <span>Hierarchy</span>, then in the <span>Navigation</span> window's <span>Object</span> pane, check the <span>Navigation Static</span> checkbox. (Alternatively, you can use the object's <span>Inspector</span> window <span>Static</span> drop-down list.)</li>
<li class="calibre12">Repeat step 3 for each of the objects that should block your possible teleportation locations: the cubes, sphere, and so on.</li>
</ol>
<p class="calibre3">For demonstration, we will now also add a second story platform:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, create a new 3D <span>Cube</span> and name it Overlook</li>
<li class="calibre12">Set its <span>Scale</span> to (<kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">0.1</kbd>, <kbd class="calibre13">5</kbd>) and its <span>Position</span> to (<kbd class="calibre13">4</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">0.5</kbd>)</li>
<li class="calibre12">In the <span>Navigation</span> window, select the <span>Object</span> tab and check <span>Navigation Static</span> for the overlook, then</li>
<li class="calibre12">Select the <span>Bake</span> tab and click on the<span> </span><span>Bake</span><span> </span><span>button at the bottom of the panel</span></li>
</ol>
<p class="calibre3">Note that its height (<span class="calibre6">Y Scale</span>) of the platform is greater than <span class="calibre6">Agent Height</span> (2) in the <span class="calibre6">Navigation</span> Bake settings. This will ensure the player can go both beneath the platform and on top of it. In the <span class="calibre6">Scene</span> window, you can see the areas in blue defined by the NavMesh, shown next, including a nice lookout area on the second story platform:</p>
<div class="mce-root1"><img src="assets/e6f1877b-cbad-4ccd-8ef3-1a22c5c9ce4e.png" class="calibre24"/></div>
<p class="calibre3">We can now modify the script to find our teleport target position on the NavMesh rather than the ground plane. Unfortunately, Unity does not provide a <kbd class="calibre13">Raycast</kbd> function for directly finding a hit point on the NavMesh. Instead, we find a hit point, as usual, using Physics colliders (which may be on the side or bottom of an object, not just the walkable surface), and then call <kbd class="calibre13">NavMesh.SamplePosition</kbd> to find the hit point position on the NavMesh. Modify the <kbd class="calibre13">LookTeleport</kbd> script as follows.</p>
<p class="calibre3">Add the following line at the top of your script to access the NavMesh API:</p>
<pre class="calibre18">using UnityEngine.AI;</pre>
<p class="calibre3">Now, modify <kbd class="calibre13">Update()</kbd> as follows:</p>
<pre class="calibre18">  if (Physics.Raycast(ray, out hit))<br class="title-page-name"/>  {<br class="title-page-name"/>    NavMeshHit navHit;<br class="title-page-name"/>    if (NavMesh.SamplePosition(hit.point, out navHit, 1.0f, NavMesh.AllAreas))<br class="title-page-name"/>      target.transform.position = navHit.position;<br class="title-page-name"/>  }</pre>
<p class="calibre3">The call to <kbd class="calibre13">NavMesh.SamplePosition</kbd> takes the <kbd class="calibre13">hit.point</kbd> and finds the closest point on the NavMesh, within a given radius (we gave 1.0). </p>
<p class="calibre3">Press <span class="calibre6">Play</span>. Now, you can set the <kbd class="calibre13">TeleportMarker</kbd> not only on the walkable surface of the <kbd class="calibre13">GroundPlane</kbd> but also on top of the Overlook!</p>
<p class="calibre3">One more thing. Doing a <kbd class="calibre13">Physics.Raycast</kbd> can get quite expensive, especially in scenes with a lot of objects. You can limit the Raycast search by providing a layer mask. For example, create a layer named <kbd class="calibre13">Teleport</kbd> and set this layer for both <kbd class="calibre13">GroundPlane</kbd> and Overlook game objects. Then, modify the Raycast call as follows:</p>
<pre class="calibre18">  if (Physics.Raycast(ray, out hit, LayerMask.GetMask("Teleport")))</pre>
<p class="calibre3">This will limit our Raycast to just the surfaces overlaid by the NavMesh, namely the ground plane and overlook.</p>
<p class="calibre3">The next scenario we'll consider is not permitting free roaming at all, but setting up a limited set of teleportation locations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleport spawn points</h1>
                </header>
            
            <article>
                
<p class="calibre3">It is very common in VR applications to limit teleportation to only specific predefined locations within the scene. In that case, you would not need any free-roaming glide locomotion or arbitrary teleportation targets. Instead, you can define the specific teleportation spawn points. Let's see how to do this.</p>
<p class="calibre3">First, let's create a <kbd class="calibre13">TeleportSpawn</kbd> prefab to mark our locations:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, create a 3D <span>Sphere</span> and name it <kbd class="calibre13">TeleportSpawn</kbd></li>
<li class="calibre12">Reset its transform (<span>gear icon</span> | <span>Reset</span>)</li>
<li class="calibre12">Set its <span>Scale</span> to <kbd class="calibre13">0.4</kbd>, <kbd class="calibre13">0.4</kbd>, <kbd class="calibre13">0.4</kbd></li>
<li class="calibre12">Set its <span>Position</span> to something like (<kbd class="calibre13">2</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">3</kbd>)</li>
<li class="calibre12">Create a new layer named <kbd class="calibre13">TeleportSpawn</kbd> from <span>Inspector</span> | <span>Layers</span> | <span>Add Layer</span> and fill in the name in an empty slot</li>
<li class="calibre12">Select the <kbd class="calibre13">TeleportSpawn</kbd> object in Hierarchy again, and now set its layer (<span>Layers</span> | <span>TeleportSpawn</span>) to the one we just defined</li>
</ol>
<p class="calibre3">Let's <span class="calibre6">quickly</span><span class="calibre6"> </span><span class="calibre6">make a material:</span></p>
<ol class="calibre15">
<li class="calibre12">In your Materials folder, right-click to <span>Create</span> a new <span>Material</span> and name it <kbd class="calibre13">Teleport Material</kbd></li>
<li class="calibre12">Set its <span>Rendering Mode</span> to <span>Transparent</span></li>
<li class="calibre12">Set its <span>Albedo</span> color and give it a low alpha (such as 30) so it's translucent, such as our pale green (<kbd class="calibre13">70</kbd>, <kbd class="calibre13">230</kbd>, <kbd class="calibre13">70</kbd>, <kbd class="calibre13">30</kbd>)</li>
<li class="calibre12">Drag the material onto the <kbd class="calibre13">TeleportSpawn</kbd> object</li>
</ol>
<p class="calibre3"><span class="calibre6">For this exercise, we'll replace the <kbd class="calibre13">LookTeleport</kbd> component on <kbd class="calibre13">MeMyselfEye</kbd> with a new <kbd class="calibre13">LookSpawnTeleport</kbd> one:</span></p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, select <kbd class="calibre13">MeMyselfEye</kbd></li>
<li class="calibre12">Disable the <kbd class="calibre13">LookTeleport</kbd> component, if present</li>
<li class="calibre12">Add <span>Component | New Script</span> and name it <kbd class="calibre13">LookSpawnTeleport</kbd></li>
</ol>
<p class="calibre3">Write the new script as follows:</p>
<pre class="calibre18">using UnityEngine;<br class="title-page-name"/><br class="title-page-name"/>public class LookSpawnTeleport : MonoBehaviour <br class="title-page-name"/>{<br class="title-page-name"/>  private Color saveColor;<br class="title-page-name"/>  private GameObject currentTarget;<br class="title-page-name"/><br class="title-page-name"/>    void Update()<br class="title-page-name"/>    {<br class="title-page-name"/>        Transform camera = Camera.main.transform;<br class="title-page-name"/>        Ray ray;<br class="title-page-name"/>        RaycastHit hit;<br class="title-page-name"/>        GameObject hitTarget;<br class="title-page-name"/><br class="title-page-name"/>        ray = new Ray(camera.position, camera.rotation * <br class="title-page-name"/>        Vector3.forward);<br class="title-page-name"/>        if (Physics.Raycast(ray, out hit, 10f, <br class="title-page-name"/>              LayerMask.GetMask("TeleportSpawn")))<br class="title-page-name"/>        {<br class="title-page-name"/>            hitTarget = hit.collider.gameObject;<br class="title-page-name"/>            if (hitTarget != currentTarget) <br class="title-page-name"/>            {<br class="title-page-name"/>                Unhighlight();<br class="title-page-name"/>                Highlight(hitTarget);<br class="title-page-name"/>            }<br class="title-page-name"/><br class="title-page-name"/>            if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>            {<br class="title-page-name"/>                transform.position = hitTarget.transform.position;<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>        else if (currentTarget != null)<br class="title-page-name"/>        {<br class="title-page-name"/>            Unhighlight();<br class="title-page-name"/>        }<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">The <kbd class="calibre13">Update()</kbd> function does a Raycast to see if any of the spawn point objects is selected. If so, the object is highlighted (unhighlighting any previous ones). Then, if the <kbd class="calibre13">Fire1</kbd> button is pressed, it teleports the player to that location. </p>
<p class="calibre3">We add a couple of private helper functions, <kbd class="calibre13">Highlight()</kbd> and <kbd class="calibre13">Unhighlight()</kbd>. The first <span class="calibre6">highlights an object by modifying its material color, making it more opaque (alpha 0.8). Unhighlight restores the original color when you look away:</span></p>
<pre class="calibre18">    private void Highlight(GameObject target)<br class="title-page-name"/>    {<br class="title-page-name"/>        Material material = target.GetComponent&lt;Renderer&gt;().material;<br class="title-page-name"/>        saveColor = material.color;<br class="title-page-name"/>        Color hiColor = material.color;<br class="title-page-name"/>        hiColor.a = 0.8f; // more opaque<br class="title-page-name"/>        material.color = hiColor;<br class="title-page-name"/>        currentTarget = target;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    private void Unhighlight()<br class="title-page-name"/>    {<br class="title-page-name"/>        if (currentTarget != null)<br class="title-page-name"/>        {<br class="title-page-name"/>          Material material = currentTarget.GetComponent&lt;Renderer&gt;().material;<br class="title-page-name"/>          material.color = saveColor;<br class="title-page-name"/>          currentTarget = null;<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre3">OK, now let's place a few of the markers around the scene:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">TeleportSpawn</kbd> object from Hierarchy to your <kbd class="calibre13">Prefabs</kbd> folder in the <span>Project Assets</span></li>
<li class="calibre12">Duplicate <kbd class="calibre13">TeleportSpawn</kbd> three times</li>
<li class="calibre12"><span>Position</span> one of them at (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-1.5</kbd>) (the default <kbd class="calibre13">MeMyselfEye</kbd> position)</li>
<li class="calibre12">Move the others to suitable locations, such as (<kbd class="calibre13">2</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">3</kbd>), (<kbd class="calibre13">-4</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>), and if you have the Overlook, (<kbd class="calibre13">3.5</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">0</kbd>)</li>
</ol>
<p class="calibre3">Alright! Press <span class="calibre6">Play</span>. When you look at a spawn point, it highlights. When you press the <kbd class="calibre13">Fire1</kbd> button, you teleport to the location.</p>
<p class="calibre3">It may be useful to add a reticle (small cursor) at the center of your camera view to help focus the player's attention on the teleport objects, as we did in <a href="36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml" target="_blank" class="calibre10">Chapter 6</a>, <em class="calibre14">World Space UI,</em> under the topic <em class="calibre14">The reticle cursor</em>.</p>
<p class="calibre3">Although the teleport works, it may be nice if it also sets your view direction. One way to do this is to carefully place the <kbd class="calibre13">TeleportSpawn</kbd> objects facing the direction we want the player to face, and setting the player's transform rotation, in addition to position.</p>
<p class="calibre3">To give a visual clue for the direction the spawn point is facing, we'll add a graphic. We have included an image file,<span class="calibre6"> </span><kbd class="calibre13">flip-flops.png</kbd>, with this book. Otherwise, use anything that indicates a forward direction. Perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">Import the<span> </span><kbd class="calibre13">flip-flops.png</kbd><span> </span>texture by dragging it into your <kbd class="calibre13">Project Textures</kbd> folder (or navigating to<span> </span><span>Import New Asset...</span>).</li>
<li class="calibre12">Create a new material in the <span>Material folder </span>and name it <kbd class="calibre13">FlipFlops</kbd>.</li>
<li class="calibre12">Drag the <kbd class="calibre13">flip-flops</kbd> texture onto the<span> </span><kbd class="calibre13">FlipFlops</kbd><span> </span>material's<span> </span><span>Albedo</span><span> </span>map and choose<span> </span><span>Rendering Mode</span><span> </span>as<span> </span><span>Cutout</span>.</li>
<li class="calibre12">Select the <kbd class="calibre13">TeleportSpawn</kbd> object in <span>Hierarchy</span>.</li>
<li class="calibre12">Create a child<span> </span><span>Quad</span><span> </span>object (right-click <span>Create</span> |<span><span> </span><span>3D Object</span><span> </span></span>|<span><span> </span><span>Quad</span></span>).</li>
<li class="calibre12">Drag the <kbd class="calibre13">FlipFlops</kbd> material onto the <kbd class="calibre13">Quad</kbd>.</li>
<li class="calibre12">Set the Quad's<span> </span><span><span>Transform</span><span> </span><span>Position</span></span><span> </span>to (<kbd class="calibre13">0</kbd>,<span> </span><kbd class="calibre13">.01</kbd>,<span> </span><kbd class="calibre13">0</kbd>) and its<span> </span><span>Rotation</span><span> </span>to (<kbd class="calibre13">90</kbd>,<span> </span><kbd class="calibre13">0</kbd>,<span> </span><kbd class="calibre13">0</kbd>) so that it lies flat on the ground plane.</li>
</ol>
<ol start="8" class="calibre15">
<li class="calibre12">Select the parent <kbd class="calibre13">TeleportSpawn</kbd> object and in Inspector, press <span>Apply</span> to save these changes to the prefab. Now all the spawns will have feet. </li>
<li class="calibre12">Note that for the one up on the Overlook, you can adjust its Quad so it's visible from below, such as <span>Position</span> (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">-0.2</kbd>, <kbd class="calibre13">0</kbd>) and <span>Rotation</span> (<kbd class="calibre13">-90</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">180</kbd>)</li>
</ol>
<p class="calibre3">The modification to our script to apply the rotation is trivial:</p>
<pre class="calibre18">            if (Input.GetButtonDown("Fire1"))<br class="title-page-name"/>            {<br class="title-page-name"/>                transform.position = hitTarget.transform.position;<br class="title-page-name"/>                transform.rotation = hitTarget.transform.rotation;<br class="title-page-name"/>            }</pre>
<p class="calibre3">There it is, a gaze-based teleportation system with predefined spawn points, as shown here in the <span class="calibre6">Scene</span> window:</p>
<div class="mce-root1"><img src="assets/6e2f7fd4-7437-410a-9f78-5d726a596fe5.png" class="calibre60"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other teleport considerations</h1>
                </header>
            
            <article>
                
<p class="calibre3">There's a lot more that can be said and done with teleportation. You may prefer to select the location using hand controllers rather than gaze. It is common to show the teleport pointer using an arced laser beam (using a Bezier curve). The teleport spawn point is often rendered using a glow or fiery effect. Many of these features have already been built and provided using higher-level VR toolkits (see next topic).</p>
<p class="calibre3">Blink teleport is a technique that does a fade-out fade-in between the change in player position. It is said to provide an additional degree of comfort. We won't show the code here, but there are several techniques for implementing fades for VR, such as creating a screen-space canvas that covers the entire camera with a black panel, and lerping its alpha channel as it fades (see <a href="https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html" class="calibre10">https://docs.unity3d.com/ScriptReference/Mathf.Lerp.html</a>). Some have even found fading with a literal blink effect is quite natural, where you rapidly fade out from top to bottom, and fade in bottom to top, like an eyelid closing and opening.</p>
<p class="calibre3">Another technique is to provide a third-person view of the scene from above, sometimes called a <strong class="calibre5">mini-map</strong>, <strong class="calibre5">god view</strong><em class="calibre14">,</em> or <strong class="calibre5">dollhouse view</strong>. From this perspective, the player could point to a new location to teleport. This mini version of the scene could be an object the player uses as a tool in the main scene, or you transition to this view mode during the teleportation selection process.</p>
<p class="calibre3">You can also teleport to a different scene. Combined with the blink fade in/out, you call <kbd class="calibre13">SceneManager.LoadScene("OtherSceneName")</kbd> rather than simply changing the transform position. Note, you must add the other scene to the <span class="calibre6">Build Settings Scenes to Build</span> list (see <a href="https://github.com/thestonefox/VRTK" class="calibre10">https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html</a>). </p>
<p class="calibre3">Clever use of teleportation and the player's direction can lead to efficient use of limited play space and give the perception of the VR space being much larger than actually in real life. For example, in room-scale VR, if you have the player walk toward the edge of the play space and enter an elevator (teleport), she could be facing the back of the elevator going in and must turn around when the doors open on the new level and can now physically walk forward. In fact, infinite corridors and connected rooms could be implemented this way while maintaining player immersion.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleportation toolkits</h1>
                </header>
            
            <article>
                
<p class="calibre3"><span class="calibre6">We have explored several different locomotion and teleportation mechanics. All of them use your gaze direction for selection. This is sometimes the best choice. Sometimes it's not. It certainly is the lowest common denominator between various VR devices, from high-end HTC VIVE and Oculus Rift to the low-end Google Cardboard, gaze-based selection with a simple click will always be available. </span></p>
<p class="calibre3">It is likely you will prefer to use the hand controller for selection. High-end systems include two positionally tracked controllers, one for each hand. Lower-end devices, such as Google Daydream, include a single 3DOF "laser pointer" controller. <span class="calibre6">Another reason we avoided implementing with controllers so far is the coding varies greatly from one device to the next. Also, the device-specific toolkits often come with components and prefabs that implement this mechanic, optimized for their particular platform, including high-performance shaders for rendering arced laser beams and teleportation markers.</span></p>
<p class="calibre3">In this section, we will show how to implement teleportation using these higher-level components, using SteamVR Interaction System and Google Daydream Elements. If you're not using one of these, please see the toolkits project with your target device, or consider a generalized toolkit such as the open source VRTK (<a href="https://github.com/thestonefox/VRTK" class="calibre10">https://github.com/thestonefox/VRTK</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleporting with SteamVR Interaction System</h1>
                </header>
            
            <article>
                
<p class="calibre3">The SteamVR Interaction System we first introduced in <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em> includes easy to use teleport components. If you are using SteamVR SDK, i<span class="calibre6">t can be found in the </span><kbd class="calibre13">Assets/SteamVR/InteractionSystem/Teleport/</kbd><span class="calibre6"> folder. The teleport tools include a lot of extras we didn't get a chance to implement ourselves, including materials, models, prefabs, scripts, shaders, sounds, textures, haptics, oh my!</span></p>
<p class="calibre3">Specifically, the teleport toolkit includes:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">Teleporting</kbd> prefab: Teleportation controller, add one per scene</li>
<li class="calibre12"><kbd class="calibre13">TeleportPoint</kbd> prefab:<strong class="calibre1"> </strong>Locations you want to teleport to, add one for each location</li>
<li class="calibre12"><kbd class="calibre13">TeleportArea</kbd> component: Add to a game object, such as a Plane, to allow teleporting anywhere on that area</li>
</ul>
<p class="calibre3"><span class="calibre6">Interaction System includes its own </span><kbd class="calibre13">Player</kbd><span class="calibre6"> camera rig which replaces the default </span><kbd class="calibre13">[CameraRig]</kbd><span class="calibre6"> we have been using, as follows:</span></p>
<ol class="calibre15">
<li class="calibre12">Locate the<span> </span><kbd class="calibre13">Player</kbd><span> </span>prefab in<span> </span><kbd class="calibre13">SteamVR/InteractionSystem/Core/Prefabs</kbd></li>
<li class="calibre12">Drag it as a child of<span> </span><kbd class="calibre13">MeMyselfEye</kbd><span> </span>in your scene<span> </span><span>Hierarchy</span></li>
<li class="calibre12">Delete or disable the<span> </span><kbd class="calibre13">[CameraRig]</kbd><span> </span>object</li>
</ol>
<p class="calibre3"> </p>
<ol start="4" class="calibre15">
<li class="calibre12">Drag a copy of <kbd class="calibre13">Teleporting</kbd> prefab <span>from Project</span> <kbd class="calibre13">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</kbd><span> </span>as a child of <kbd class="calibre13">MeMyselfEye</kbd> (this controller can actually go anywhere in the scene)</li>
<li class="calibre12">Select the <span>Player</span> in <span>Hierarchy</span>, and drag its parent <kbd class="calibre13">MeMyselfEye</kbd> onto its <span>Tracking Origin Transform</span> slot</li>
</ol>
<p class="calibre3">This last step is important. The toolkit's teleportation components change the position of the <kbd class="calibre13">Player</kbd> object by default. We want to teleport the Player parent, <kbd class="calibre13">MeMyselfEye</kbd>, when we teleport. This might also be used if in your game, for example, the player is sitting in the cockpit of vehicle and you intend to teleport the whole vehicle, not just the Player itself.</p>
<p class="calibre3">If you followed the projects earlier in this chapter, disable the things we won't be using here:</p>
<ol class="calibre15">
<li class="calibre12">On <kbd class="calibre13">MyMyselfEye</kbd>, disable or remove the <span>Look Teleport</span> and <span>Look Spawn Teleport</span> components</li>
<li class="calibre12">Disable or delete each of the <kbd class="calibre13">TeleportSpawn</kbd> objects</li>
</ol>
<p class="calibre3">Now, for each teleport location:</p>
<ol class="calibre15">
<li class="calibre12">Drag a copy of the <kbd class="calibre13">TeleportPoint</kbd> prefab from Project <kbd class="calibre13">Assets/SteamVR/InteractionSystem/Teleport/Prefabs</kbd> into the Hierarchy</li>
<li class="calibre12">Place one where you want in the scene. As previously, we used (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">-1.5</kbd>), (<kbd class="calibre13">2</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">3</kbd>), (<kbd class="calibre13">-4</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>), and on the Overlook (<kbd class="calibre13">3.5</kbd>, <kbd class="calibre13">2.5</kbd>, <kbd class="calibre13">0</kbd>)</li>
</ol>
<p class="calibre3">That's it! Press <span class="calibre6">Play</span>. The teleport points do not show until you press the button on your controller, then they glow, a dashed laser arc lets you choose one, and you go there. In the Game window shown here, I am teleporting to the Overlook location:</p>
<div class="mce-root1"><img src="assets/1a63a4c3-8a3a-4468-9af3-d3737417b404.png" class="calibre61"/></div>
<p class="calibre3">Please review the many options on the Teleport component. You can modify or replace materials used for highlighting teleport points, sounds, and other effects. The Teleport Arc component has options for rendering the laser arc, and the <kbd class="calibre13">TeleportPoints</kbd> themselves can each be modified separately.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Teleporting with Daydream Elements</h1>
                </header>
            
            <article>
                
<p class="calibre3">The Google Daydream Elements package we first introduced in <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>,<span class="calibre6"> </span><em class="calibre14">Handy Interactables</em> includes some teleport components. If you are targeting Google Daydream, you can install the separate Daydream Elements download from GitHub (<a href="https://github.com/googlevr/daydream-elements/releases" class="calibre10">https://github.com/googlevr/daydream-elements/releases</a>). And documentation can be found on the Elements site (<a href="https://developers.google.com/vr/elements/teleportation" class="calibre10">https://developers.google.com/vr/elements/teleportation</a>).</p>
<p class="calibre3">Once imported into your project, i<span class="calibre6">t can be found in the </span><kbd class="calibre13">Assets/DaydreamElements/Elements/Teleport/</kbd><span class="calibre6"> folder. There is a demo scene, <span class="calibre6">Teleport</span></span>, and associated materials, models, prefabs, scripts, shaders, and textures.</p>
<p class="calibre3"><span class="calibre6">Out of the box, the tools are pretty generic and very customizable. T</span>he primary prefab is <kbd class="calibre13">TeleportController</kbd>, which does all the work. <span class="calibre6">The user input used to trigger teleport behavior can be configured in the Unity Editor by filling the component slots, as shown here:</span></p>
<div class="mce-root1"><img src="assets/c0b48a82-4c23-4594-a210-38c2abd5ffa7.png" class="calibre24"/></div>
<p class="calibre3">You can extend the teleporter by changing its <em class="calibre14">detector</em>, <em class="calibre14">visualizer</em>, and <em class="calibre14">transition</em> classes.</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Detector</strong>: Such as the <kbd class="calibre13">ArcTeleportDetector</kbd> does a curved arc Raycast to find objects in the scene and limits the hit to horizontal surfaces with adequate space to "fit" the player, so you do not teleport into walls.</li>
<li class="calibre12"><strong class="calibre1">Visualizer</strong>: Such as the <kbd class="calibre13">ArcTeleportVisualizer</kbd>, renders the arc when teleport is triggered.</li>
<li class="calibre12"><strong class="calibre1">Transition</strong>: Such as <kbd class="calibre13">LinearTeleportTransition</kbd>, animates the player to the new location. This could be modified to implement a blink effect, for example.</li>
</ul>
<p class="calibre3">To add it to your scene:</p>
<ol class="calibre15">
<li class="calibre12">Drag the <kbd class="calibre13">TeleportController</kbd> prefab into your <span>Hierarchy</span> as child of <span>Player</span> (for us that <kbd class="calibre13">MeMyselfEye</kbd> <span>| GVRCameraRig | Player</span>)</li>
<li class="calibre12">Reset its <span>Transform</span>, if necessary</li>
<li class="calibre12">Drag the <kbd class="calibre13">MeMyselfEye</kbd> object onto the <kbd class="calibre13">TeleportController</kbd> component's <span>Player</span> transform slot</li>
<li class="calibre12">Drag <kbd class="calibre13">GvrControllerPointer</kbd> (or whichever controller game object you're using) onto the <span>Controller</span> transform slot</li>
</ol>
<p class="calibre3">Press <span class="calibre6">Play</span> and you can teleport all around your scene. There is no need to place specific teleport targets.</p>
<p class="calibre3">By default, the <kbd class="calibre13">TeleportController</kbd> will work by letting you land on any object in the scene that has a collider. You can limit the objects considered by the detector's Raycast by specifying the layer(s). Also, if you want arbitrarily shaped target areas that are not necessarily game objects in your scene, you can add sets of objects with just colliders, no renderers. This is how the teleport areas on the islands are implemented in the Daydream Elements teleport demo.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resetting center and position </h1>
                </header>
            
            <article>
                
<p class="calibre3">Sometimes in VR, the view presented in the headset is not quite in sync with your body's orientation. Device SDKs provide functions to reset the orientation of the headset with respect to the real-world space. This is often referred to as the<span class="calibre6"> </span><strong class="calibre5">recentering</strong><span class="calibre6"> </span>of the view.</p>
<p class="calibre3">Unity provides an API call that maps to the underlying device SDK to recenter the device, <kbd class="calibre13">UnityEngine.VR.InputTracking.Recenter()</kbd>. This function will center tracking to the current position and orientation of the HMD. It only works with seated and standing experiences. Room scale experiences are not affected.</p>
<p class="calibre3"><span class="calibre6">At the time of this writing, Recenter does not work in SteamVR, even for seated configuration. The solution is to call the following code instead:</span></p>
<pre class="calibre18"><span>Valve.VR.OpenVR.System.ResetSeatedZeroPose();</span><br class="title-page-name"/><span>Valve.VR.OpenVR.Compositor.SetTrackingSpace(Valve.VR.ETrackingUniverseOrigin.TrackingUniverseSeated);</span></pre>
<p class="calibre3">The Daydream controller has reset built into the underlying system (press and hold the system button). This is because unwanted drift is so common on mobile VR devices. Also, for Cardboard (and <span class="calibre6">Daydream users</span> without a controller), there is a standard floor canvas menu you should include in your player rig (as we did in <a href="5f03c1ec-a1bc-4ec8-bf4b-dc7a4492aba4.xhtml" target="_blank" class="calibre10">Chapter 3</a>, <em class="calibre14">VR Build and Run</em>), that includes a reset and recenter buttons.</p>
<p class="calibre3">On other systems, you can choose a button that triggers a call to<span class="calibre6"> </span><kbd class="calibre13">Recenter</kbd> as needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Supporting room scale teleportation</h1>
                </header>
            
            <article>
                
<p class="calibre3">As mentioned, the Unity Recenter function does not have any affect on room scale setups. We assume that room scale players are standing and mobilized, so they can just turn themselves to face "forward" within the VR scene.</p>
<p class="calibre3">When teleporting, however, we are moving the player to a new location, and possibly to an entirely different scene. When we reposition MyMyselfEye or any parent of the positionally tracked camera, the player is not necessary located at origin of that rig. If the player teleports to a new location, his whole play space should be ported and the player should end up standing on the virtual location he specifically chose.</p>
<p class="calibre3">The following function will compensate the teleport transform to the player's relative pose within the playspace. As written, it assumes it is a component on the MeMyselfEye player root object:</p>
<pre class="calibre18">private void TeleportRoomscale( Vector3 targetPosition )<br class="title-page-name"/>{<br class="title-page-name"/>    Transform camera = Camera.main.transform;<br class="title-page-name"/>    float cameraAngle = camera.eulerAngles.y;<br class="title-page-name"/>    transform.Rotate( 0f, -cameraAngle, 0f);<br class="title-page-name"/>    Vector3 offsetPos = camera.position - transform.position;<br class="title-page-name"/>    transform.position = targetPosition.position - offsetPos;<br class="title-page-name"/>}</pre>
<p class="calibre3">To use it in our previous teleport script examples, replace the <kbd class="calibre13">transform.position = target.transform.position;</kbd> <span class="calibre6">line</span><span class="calibre6"> </span><span class="calibre6">with a call to</span> <kbd class="calibre13">TeleportRoomscale( target.transform.position )</kbd> <span class="calibre6">instead. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing VR motion sickness</h1>
                </header>
            
            <article>
                
<p class="calibre3">VR motion sickness, or simulator sickness, is a real symptom and a concern for virtual reality. Researchers, psychologists, and technologists with a wide array of specializations and PhDs are studying the problem to better understand the underlying causes and find solutions.</p>
<p class="calibre3">A cause of VR motion sickness is a lag in screen updates, or latency, when you're moving your head. Your brain expects the world around you to change exactly in sync. Any perceptible delay can make you feel uncomfortable, to say the least.</p>
<p class="calibre3">Latency can be reduced by faster rendering of each frame, keeping to the recommended frames per second. Device manufacturers see this as their problem to solve, in both hardware and device driver software. GPU and chip manufacturers see it as a processor performance and throughput problem. We will undoubtedly see leaps and bounds of improvements over the coming years.</p>
<p class="calibre3">At the same time, as VR developers, we need to be aware of latency and other causes of VR motion sickness. Developers need to look at it like it's our problem too because ultimately, it comes down to performance and ergonomics. With an ongoing dichotomy of mobile VR versus desktop VR, there will always be upper bounds on the performance of devices that our players will be using. In <a href="c938e975-93f3-4435-9d99-9f76bbbd0a98.xhtml" target="_blank" class="calibre10">Chapter 13</a>, <em class="calibre14">Optimizing for Performance and Comfort</em>, we dive into the technical details of the rendering pipeline and performance.</p>
<p class="calibre3">But it's not just technology. I can get nauseous riding a real-world roller coaster. So, why wouldn't a VR one have a similar effect? Things to consider that help improve your players' comfort and safety include game mechanics and user experience design such as the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Don't move fast</strong>: When moving or animating a first-person character, don't move too fast. High-speed first-person shooter games that work on gaming consoles and desktop PCs may not work out so well in VR.</li>
<li class="calibre12"><strong class="calibre1">Look forward</strong>: When moving through a scene, if you're looking to the side rather than straight ahead, you're more likely to feel nauseous.</li>
<li class="calibre12"><strong class="calibre1">Don't turn your head too fast</strong>: Discourage users from turning their head quickly with the VR headset on. The latency in updating the HMD screen is aggravated by larger changes in the viewport in small time slices.</li>
<li class="calibre12"><strong class="calibre1">Offer comfort mode</strong>: When a scene requires you to quickly turn yourself a lot of times, provide a ratcheted rotation mechanism, also known as comfort mode, which lets you change the direction in which you look in larger increments.</li>
<li class="calibre12"><strong class="calibre1">Use fade or blink</strong> cuts during teleportation and scene changes. When fading, go to a dark color, as white can be startling.</li>
<li class="calibre12"><strong class="calibre1">Use tunneling</strong> or other techniques during locomotion. Reduce what is visible in the peripheral vision by masking the camera except what is just in front of you.</li>
<li class="calibre12"><strong class="calibre1">Use a third-person camera</strong>: If you have high-speed action but you don't necessarily intend to give the user a thrill ride, use a third-person camera view.</li>
<li class="calibre12"><strong class="calibre1">Stay grounded</strong>: Provide visual cues that help the user stay grounded, such as horizon lines, nearby objects in your field of view, and relative fixed-position objects, such as dashboards and body parts.</li>
<li class="calibre12"><strong class="calibre1">Provide an option to recenter the view</strong>: Mobile VR devices, in particular, are subject to drift and the need to be recentered on occasion. With wired VR devices, it helps you avoid getting tangled in HMD wires. As a safety issue, recentering your view relative to the real world may help you avoid hitting furniture and walls in the physical space.</li>
<li class="calibre12"><strong class="calibre1">Don't use cut scenes</strong>: In traditional games (and movies), a technique that can be used to transition between levels is to show a 2D cutscene movie. This does not work in VR if the head motion detection is disabled. It breaks the immersion and can cause nausea. An alternative is to simply fade to black and then open the new scene.</li>
<li class="calibre12"><strong class="calibre1">Optimize rendering performance</strong>: It behooves all VR developers to understand the underlying causes of latency-specifically rendering performance-and what you can do to optimize it, such as lowering the poly count and choosing lighting models carefully. Learn to use performance monitoring tools in order to keep the frames per second within the expected and acceptable limits. More on this will be discussed in <span><a href="df997d92-d63c-4701-9786-da7ba54082b6.xhtml" target="_blank" class="calibre10">Chapter 10</a>, <em class="calibre2">Using All 360 Degrees</em>.</span></li>
<li class="calibre12"><strong class="calibre1">Encourage users to take breaks</strong>: Alternatively, you can maybe just provide a puke-bag with your game! Or not.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre3">In this chapter, we explored many different ways of moving around within your virtual environments. We started by examining Unity's components that support conventional third-person and first-person characters and quickly realized most of those capabilities are not too useful in VR. For instance, we don't want the app to bob our head up and down as we walk, and we don't necessarily want to go jumping off buildings either. Moving around is important, but player comfort is more so. You don't want to induce motion sickness.</p>
<p class="calibre3">Locomotion is moving smoothly and linearly across the scene, akin to walking. Using gaze-based mechanics, we implemented moving in the direction you're looking and used input buttons to start and stop. Then, we separated the locomotion from head direction, always moving "forward" and using a separate input (thumbpad) to change the angle our body is facing. With this <em class="calibre14">comfort mode</em>, you can locomote and still look around. </p>
<p class="calibre3">Jumping to a new location is called teleportation. We started again with a gaze-based mechanic, letting you select a teleport location where you're looking. We implemented a couple ways of constraining where you are allowed to teleport, using NavMesh and using teleport spawn points. Then, we looked at some teleportation toolkits, from SteamVR and Google Daydream, which provide a rich set of capabilities, as well as a juicy user experience that is not trivial to implement from scratch. If you're targeting a different platform, such as Oculus, there are similar tools.</p>
<p class="calibre3">In <span class="calibre6">the next chapter</span>,<em class="calibre14"> </em>we'll explore the Unity physics engine more and implement some interactive games. </p>


            </article>

            
        </section>
    </body></html>