<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0; Building a Gallery Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1.  Building a Gallery Application </h1></div></div></div><p>This chapter will walkthrough native development with Xamarin by building an iOS and Android application that will read from your local gallery files, and display them in a <span class="strong"><strong>UITableView</strong></span> and <span class="strong"><strong>ListView.</strong></span> The following topics will be covered in this chapter:</p><p>Expected knowledge:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating iOS provision certificates</li><li class="listitem" style="list-style-type: disc">iOS development</li><li class="listitem" style="list-style-type: disc">Objective-C</li><li class="listitem" style="list-style-type: disc">Creating keystores</li><li class="listitem" style="list-style-type: disc">Android development</li><li class="listitem" style="list-style-type: disc">Java</li></ul></div><p>In this chapter you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating an iOS project</li><li class="listitem" style="list-style-type: disc">Creating a UIViewController and UITableView</li><li class="listitem" style="list-style-type: disc">Customizing a cell's appearance</li><li class="listitem" style="list-style-type: disc">Creating an Android project</li><li class="listitem" style="list-style-type: disc">Creating an XML interface and ListView</li><li class="listitem" style="list-style-type: disc">Shared projects</li><li class="listitem" style="list-style-type: disc">Custom row appearance</li><li class="listitem" style="list-style-type: disc">Bitmap functions</li><li class="listitem" style="list-style-type: disc">The ALAssetLibrary</li><li class="listitem" style="list-style-type: disc">Adding the iOS photo screen</li><li class="listitem" style="list-style-type: disc">Adding the Android photo screen</li></ul></div><div class="section" title="Create an iOS project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec7"/>Create an iOS project</h1></div></div></div><p>Let's begin our Xamarin journey; we will start by setting up our iOS project in Xamarin Studio:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by opening Xamarin Studio and creating a new iOS project. To do so, we simply select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Solution</strong></span> and select an <span class="strong"><strong>iOS Single View App</strong></span>; we must also give it a name and add the bundle ID you want in order to run your application.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note3"/>Note</h3><p>It is recommended that for each project, a new bundle ID is created, along with a developer provisioning profile for each project.</p></div></div></li><li class="listitem">Now that we have created the iOS project, you will be taken to the following screen:</li></ol></div><div class="mediaobject"><img src="graphics/B05293_01_01.jpg" alt="Create an iOS project"/></div><p>Doesn't this look familiar? Yes, it is our <code class="literal">AppDelegate</code> file; notice the <code class="literal">.cs</code> on the end; because we are using C#, all our code files will have this extension (no more <code class="literal">.h</code> or <code class="literal">.m</code> files).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip4"/>Tip</h3><p>Before we go any further, spend a few minutes moving around the IDE, expanding the folders, and exploring the project structure; it is very similar to an iOS project created in XCode.</p></div></div></div></div>
<div class="section" title="Creating a UIViewController and UITableView"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"/>Creating a UIViewController and UITableView</h1></div></div></div><p>Now that we have our new iOS project, we are going to start by creating a <code class="literal">UIViewController</code>. Right-click on the project file, select <span class="strong"><strong>Add</strong></span> | <span class="strong"><strong>New File</strong></span>, and select <span class="strong"><strong>ViewController</strong></span> from the <span class="strong"><strong>iOS</strong></span> menu selection in the left-hand box:</p><div class="mediaobject"><img src="graphics/B05293_01_02.jpg" alt="Creating a UIViewController and UITableView"/></div><p>You will notice three files generated, a <code class="literal">.xib</code>, a <code class="literal">.cs</code>, and a <code class="literal">.designer.cs</code> file. We don't need to worry about the third file; this is automatically generated based upon the other two files.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip5"/>Tip</h3><p>Right-click on the project item and select <span class="strong"><strong>Reveal in Finder</strong></span>,</p></div></div><div class="mediaobject"><img src="graphics/B05293_01_03.jpg" alt="Creating a UIViewController and UITableView"/></div><p>This will bring up the finder where you will double-click on the <code class="literal">GalleryCell.xib</code> file; this will bring up the user interface designer in XCode. You should see automated text inserted into the document to help you get started.</p><p>Firstly, we must set our namespace accordingly, and import our libraries with using statements. In order to use the iOS user interface elements, we must import the <code class="literal">UIKit</code> and <code class="literal">CoreGraphics</code> libraries. Our class will inherit the <code class="literal">UIViewController</code> class in which we will override the <code class="literal">ViewDidLoad</code> function:</p><pre class="programlisting">namespace Gallery.iOS  
{ 
    using System; 
    using System.Collections.Generic; 
 
    using CoreGraphics; 
    using UIKit; 
 
    public partial class MainController : UIViewController 
    { 
        private UITableView _tableView; 
 
        private TableSource _source; 
 
        private ImageHandler _imageHandler; 
 
        public MainController () : base ("MainController", null) 
        { 
            _source = new TableSource (); 
 
            _imageHandler = new ImageHandler (); 
            _imageHandler.AssetsLoaded += handleAssetsLoaded; 
        } 
 
        private void handleAssetsLoaded (object sender, EventArgs e) 
        { 
            _source.UpdateGalleryItems (_imageHandler.CreateGalleryItems()); 
            _tableView.ReloadData (); 
        } 
 
        public override void ViewDidLoad () 
        { 
            base.ViewDidLoad (); 
 
            var width = View.Bounds.Width; 
            var height = View.Bounds.Height; 
 
            tableView = new UITableView(new CGRect(0, 0, width, height)); 
            tableView.AutoresizingMask = UIViewAutoresizing.All; 
            tableView.Source = _source; 
 
            Add (_tableView); 
        } 
    } 
} 
</pre><p>Our first UI element created is <code class="literal">UITableView</code>. This will be used to insert into the <code class="literal">UIView</code> of the <code class="literal">UIViewController</code>, and we also retrieve width and height values of the <code class="literal">UIView</code> to stretch the <code class="literal">UITableView</code> to fit the entire bounds of the <code class="literal">UIViewController</code>. We must also call <code class="literal">Add</code> to insert the <code class="literal">UITableView</code> into the <code class="literal">UIView</code>. In order to fill the list with data, we need to create a <code class="literal">UITableSource</code> to contain the list of items to be displayed in the list. We will also need an object called <code class="literal">GalleryModel</code>; this will be the model of data to be displayed in each cell.</p><p>Follow the previous process for adding two new <code class="literal">.cs</code> files; one will be used to create our <code class="literal">UITableSource</code> class and the other for the <code class="literal">GalleryModel</code> class. In <code class="literal">TableSource.cs</code>, first we must import the <code class="literal">Foundation</code> library with the <code class="literal">using</code> statement:</p><pre class="programlisting">using Foundation; 
</pre><p>Now for the rest of our class. Remember, we have to override specific functions for our <code class="literal">UITableSource</code> to describe its behavior. It must also include a list for containing the item view-models that will be used for the data displayed in each cell:</p><pre class="programlisting">public class TableSource : UITableViewSource  
    { 
        protected List&lt;GalleryItem&gt; galleryItems; 
        protected string cellIdentifier = "GalleryCell"; 
 
        public TableSource (string[] items) 
        { 
            galleryItems = new List&lt;GalleryItem&gt; (); 
        } 
    } 
</pre><p>We must override the <code class="literal">NumberOfSections</code> function; in our case, it will always be one because we are not having list sections:</p><pre class="programlisting">        public override nint NumberOfSections (UITableView tableView) 
        { 
            return 1; 
        } 
</pre><p>To determine the number of list items, we return the count of the list:</p><pre class="programlisting">        public override nint RowsInSection (UITableView tableview, nint section) 
        { 
            return galleryItems.Count; 
        } 
</pre><p>Then we must add the <code class="literal">GetCell</code> function; this will be used to get the <code class="literal">UITableViewCell</code> to render for a particular row. But before we do this, we need to create a custom <code class="literal">UITableViewCell</code>.</p></div>
<div class="section" title="Customizing a cell's appearance"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec9"/>Customizing a cell's appearance</h1></div></div></div><p>We are now going to design our cells that will appear for every model found in the <code class="literal">TableSource</code> class. Add a new <code class="literal">.cs</code> file for our custom <code class="literal">UITableViewCell</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>We are not going to use a <code class="literal">.xib</code> and simply build the user interface directly in code using a single <code class="literal">.cs</code> file.</p></div></div><p>Now for the implementation:</p><pre class="programlisting">public class GalleryCell: UITableViewCell   
    { 
        private UIImageView _imageView; 
 
        private UILabel _titleLabel; 
 
        private UILabel _dateLabel; 
 
        public GalleryCell (string cellId) : base (UITableViewCellStyle.Default, cellId) 
        { 
            SelectionStyle = UITableViewCellSelectionStyle.Gray; 
 
            _imageView = new UIImageView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
 
            _titleLabel = new UILabel ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
 
            _dateLabel = new UILabel ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
 
            ContentView.Add (imageView); 
            ContentView.Add (titleLabel); 
            ContentView.Add (dateLabel); 
        } 
    } 
</pre><p>Our constructor must call the base constructor, as we need to initialize each cell with a cell style and cell identifier. We then add a <code class="literal">UIImageView</code> and two <code class="literal">UILabels</code> for each cell, one for the filename and one for the date. Finally, we add all three elements to the main content view of the cell.</p><p>When we have our initializer, we add the following:</p><pre class="programlisting">public void UpdateCell (GalleryItem gallery) 
        { 
            _imageView.Image = UIImage.LoadFromData (NSData.FromArray (gallery.ImageData)); 
            _titleLabel.Text = gallery.Title; 
            _dateLabel.Text = gallery.Date; 
        } 
 
        public override void LayoutSubviews () 
        { 
            base.LayoutSubviews (); 
 
            ContentView.TranslatesAutoresizingMaskIntoConstraints = false; 
 
            // set layout constraints for main view 
            AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|[imageView(100)]|", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("imageView", imageView))); 
            AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|[titleLabel]|", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("titleLabel", titleLabel))); 
            AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|-10-[imageView(100)]-10-[titleLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("imageView", imageView, "titleLabel", titleLabel))); 
            AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|-10-[imageView(100)]-10-[dateLabel]-10-|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("imageView", imageView, "dateLabel", dateLabel))); 
        } 
</pre><p>Our first function, <code class="literal">UpdateCell</code>, simply adds the model data to the view, and our second function overrides the <code class="literal">LayoutSubViews</code> method of the <code class="literal">UITableViewCell</code> class (equivalent to the <code class="literal">ViewDidLoad</code> function of a <code class="literal">UIViewController</code>).</p><p>Now that we have our cell design, let's create the properties required for the view-model. We only want to store data in our <code class="literal">GalleryItem</code> model, meaning we want to store images as byte arrays. Let's create a property for the item model:</p><pre class="programlisting">namespace Gallery.iOS 
{ 
    using System; 
 
    public class GalleryItem 
    { 
        public byte[] ImageData; 
 
        public string ImageUri; 
 
        public string Title; 
 
        public string Date; 
 
        public GalleryItem () 
        { 
        } 
    } 
} 
</pre><p>Now back to our <code class="literal">TableSource</code> class. The next step is to implement the <code class="literal">GetCell</code> function:</p><pre class="programlisting">public override UITableViewCell GetCell (UITableView tableView, NSIndexPath indexPath) 
        { 
            var cell = (GalleryCell)tableView.DequeueReusableCell (CellIdentifier); 
            var galleryItem = galleryItems[indexPath.Row]; 
 
            if (cell == null) 
            {  
                // we create a new cell if this row has not been created yet 
                cell = new GalleryCell (CellIdentifier);  
            } 
 
            cell.UpdateCell (galleryItem); 
 
            return cell; 
        } 
</pre><p>Notice the cell reuse on the <code class="literal">if</code> statement; you should be familiar with this type of approach, it is a common pattern for reusing cell views and is the same as the Objective-C implementation (this is a very basic cell reuse implementation). We also call the <code class="literal">UpdateCell</code> method to pass in the required <code class="literal">GalleryItem</code> data to show in the cell. Let's also set a constant height for all cells. Add the following to your <code class="literal">TableSource</code> class:</p><pre class="programlisting">public override nfloat GetHeightForRow (UITableView tableView, NSIndexPath indexPath) 
        { 
            return 100; 
        } 
</pre><p>So what is next?</p><pre class="programlisting">public override void ViewDidLoad () 
{ 
.. 
table.Source = new TableSource(); 
.. 
} 
</pre><p>Let's stop development and have a look at what we have achieved so far. We have created our first <code class="literal">UIViewController</code>, <code class="literal">UITableView</code>, <code class="literal">UITableViewSource</code>, and <code class="literal">UITableViewCell</code>, and bound them all together. Fantastic!</p><p>We now need to access the local storage of the phone to pull out the required gallery items. But before we do this, we are going to create an Android project and replicate what we have done with iOS.</p></div>
<div class="section" title="Creating an Android project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating an Android project</h1></div></div></div><p>Our first step is to create new general Android app:</p><div class="mediaobject"><img src="graphics/B05293_01_04.jpg" alt="Creating an Android project"/></div><p>The first screen you will land on is <code class="literal">MainActivity</code>. This is our starting activity, which will inflate the first user interface; take notice of the configuration attributes:</p><pre class="programlisting">[Activity (Label = "Gallery.Droid", MainLauncher = true, Icon = "@mipmap/icon")] 
</pre><p>The <code class="literal">MainLauncher</code> flag indicates the starting activity; one activity must have this flag set to <code class="literal">true</code> so the application knows what activity to load first. The <code class="literal">icon</code> property is used to set the application icon, and the <code class="literal">Label</code> property is used to set the text of the application, which appears in the top left of the navigation bar:</p><pre class="programlisting">namespace Gallery.Droid 
{ 
    using Android.App; 
    using Android.Widget; 
    using Android.OS; 
 
    [Activity (Label = "Gallery.Droid", MainLauncher = true, Icon = "@mipmap/icon")] 
    public class MainActivity : Activity 
    { 
        int count = 1; 
 
        protected override void OnCreate (Bundle savedInstanceState) 
        { 
            base.OnCreate (savedInstanceState); 
 
            // Set our view from the "main" layout resource 
            SetContentView (Resource.Layout.Main); 
        } 
    } 
} 
</pre><p>The formula for our activities is the same as Java; we must override the <code class="literal">OnCreate</code> method for each activity where we will inflate the first XML interface <code class="literal">Main.xml</code>.</p></div>
<div class="section" title="Creating an XML interface and ListView"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Creating an XML interface and ListView</h1></div></div></div><p>Our starting point is the <code class="literal">main.xml</code> sheet; this is where we will be creating the <code class="literal">ListView</code>:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
    android:orientation="vertical" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent"&gt; 
    &lt;ListView 
        android:id="@+id/listView" 
        android:layout_width="fill_parent" 
        android:layout_height="fill_parent" 
        android:layout_marginBottom="10dp" 
        android:layout_marginTop="5dp" 
        android:background="@android:color/transparent" 
        android:cacheColorHint="@android:color/transparent" 
        android:divider="#CCCCCC" 
        android:dividerHeight="1dp" 
        android:paddingLeft="2dp" /&gt; 
&lt;/LinearLayout&gt; 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip7"/>Tip</h3><p>The <code class="literal">main.xml</code> file should already be in the <span class="strong"><strong>resource</strong></span> | <span class="strong"><strong>layout</strong></span> directory, so simply copy and paste the previous code into this file.</p></div></div><p>Excellent! We now have our starting activity and interface, so now we have to create a <code class="literal">ListAdapter</code> for our <code class="literal">ListView</code>. An adapter works very much like a <code class="literal">UITableSource</code>, where we must override functions to determine cell data, row design, and the number of items in the list.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note8"/>Note</h3><p>Xamarin Studio also has an Android GUI designer.</p></div></div><p>Right-click on the Android project and add a new empty class file for our adapter class. Our class must inherit the <code class="literal">BaseAdapter</code> class, and we are going to override the following functions:</p><pre class="programlisting">public override long GetItemId(int position); 
 
public override View GetView(int position, View convertView, ViewGroup parent); 
</pre><p>Before we go any further, we need to create a model for the objects used to contain the data to be presented in each row. In our iOS project, we created a <code class="literal">GalleryItem</code> to hold the byte array of image data used to create each <code class="literal">UIImage</code>. We have two approaches here: we could create another object to do the same as the <code class="literal">GalleryItem</code>, or even better, why don't we reuse this object using a shared project?</p></div>
<div class="section" title="Shared projects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Shared projects</h1></div></div></div><p>We are going to delve into our first technique for sharing code between different platforms. This is what Xamarin wants us to achieve, and reuse as much code as possible. The biggest disadvantage when developing natively is two different language, and we can't reuse anything.</p><p>Let's create our first shared project:</p><div class="mediaobject"><img src="graphics/B05293_01_05.jpg" alt="Shared projects"/></div><p>Our shared project will be used to contain the <code class="literal">GalleryItem</code> model, so whatever code we include in this shared project can be accessed by both the iOS and Android projects:</p><div class="mediaobject"><img src="graphics/B05293_01_06.jpg" alt="Shared projects"/></div><p>In the preceding screenshot, have a look at the <span class="strong"><strong>Solution</strong></span> explorer, and notice how the shared project doesn't contain anything more than <code class="literal">.cs</code> code sheets. Shared projects do not have any references or components, just code that is shared by all platform projects. When our native projects reference these shared projects, any libraries being referenced via <code class="literal">using</code> statements come from the native projects.</p><p>Now we must have the iOS and Android projects reference the shared project; right-click on the <span class="strong"><strong>References</strong></span> folder and select <span class="strong"><strong>Edit References</strong></span>:</p><div class="mediaobject"><img src="graphics/B05293_01_07.jpg" alt="Shared projects"/></div><p>Select the shared project you just created and we can now reference the <code class="literal">GalleryItem</code> object from both projects.</p></div>
<div class="section" title="Custom row appearance"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Custom row appearance</h1></div></div></div><p>Let's get back to the <code class="literal">ListAdapter</code> implementation and design our <code class="literal">ListView</code> row appearance. Open the <span class="strong"><strong>Resources</strong></span> | <span class="strong"><strong>Layout</strong></span> folder, create a new <code class="literal">.xml</code> file for the cell appearance, call it <code class="literal">CustomCell.xml</code>, and copy in the following XML code:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
    android:orientation="horizontal" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:weightSum="4"&gt; 
    &lt;LinearLayout 
        android:orientation="vertical" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" 
        android:layout_weight="1"&gt; 
        &lt;ImageView 
            android:id="@+id/image" 
            android:layout_width="100dp" 
            android:layout_height="100dp" 
            android:adjustViewBounds="true" /&gt; 
    &lt;/LinearLayout&gt; 
    &lt;LinearLayout 
        android:orientation="vertical" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" 
        android:layout_weight="3" 
        android:weightSum="2"&gt; 
        &lt;TextView 
            android:id="@+id/title" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" /&gt; 
        &lt;TextView 
            android:id="@+id/date" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" /&gt; 
    &lt;/LinearLayout&gt; 
&lt;/LinearLayout&gt; 
</pre><p>We are creating the same layout as the custom cell made for iOS, but in Android we will use the <code class="literal">ImageView</code> and <code class="literal">TextView</code> objects. Now that we have our custom cell, we can implement the the <code class="literal">GetView</code> function. The <code class="literal">GetView</code> function is exactly like the <code class="literal">GetCell</code> function in the preceding <code class="literal">UITableSource</code> implementation. Open up the <code class="literal">ListAdapter.cs</code> file and continue with the list adapter implementation:</p><pre class="programlisting">public class ListAdapter : BaseAdapter 
    { 
        private List&lt;GalleryItem&gt; _items; 
        private Activity _context; 
 
        public ListAdapter(Activity context) : base() 
        { 
            _context = context; 
            _items = new List&lt;GalleryItem&gt;(); 
        } 
 
        public override Java.Lang.Object GetItem (int position) 
        { 
            return null; 
        } 
 
        public override long GetItemId(int position) 
        { 
            return position; 
        } 
 
        public override int Count 
        { 
            get 
            { 
                return items.Count;  
            } 
        } 
} 
</pre><p>We override the <code class="literal">Count</code> property and functions <code class="literal">GetItemId</code> and <code class="literal">GetItem</code>, to return the number of gallery items in our list. These override functions are exactly the same as the overrides in Java for any <code class="literal">BaseAdapter</code> inherited class. Now for the <code class="literal">GetView</code> function:</p><pre class="programlisting">public override View GetView(int position, View convertView, ViewGroup parent) 
        { 
            View view = convertView; // re-use an existing view, if one is available 
 
            if (view == null) 
            { 
                // otherwise create a new one 
                view = context.LayoutInflater.Inflate(Resource.Layout.CustomCell, null); 
            } 
 
            // set image 
            var imageView = view.FindViewById&lt;ImageView&gt; (Resource.Id.image); 
            BitmapHelpers.CreateBitmap (imageView, _items [position].ImageData); 
 
            // set labels 
            var titleTextView = view.FindViewById&lt;TextView&gt; (Resource.Id.title); 
            titleTextView.Text = _items[position].Title; 
            var dateTextView = view.FindViewById&lt;TextView&gt; (Resource.Id.date); 
            dateTextView.Text = _items[position].Date; 
 
            return view; 
        } 
 
        private async void createBitmap(ImageView imageView, byte[] imageData) 
        { 
            try 
            { 
                if (imageData != null)  
                { 
                    var bm = await BitmapFactory.DecodeByteArrayAsync(imageData, 0, imageData.Length); 
                    if (bm != null)  
                    { 
                        imageView.SetImageBitmap(bm); 
                    } 
                } 
            } 
            catch (Exception e)  
            { 
                Console.WriteLine ("Bitmap creation failed: " + e); 
            } 
        } 
</pre><p>Notice in the <code class="literal">GetView</code> function we are using the <code class="literal">CustomCell</code> layout for each row; we also have a <code class="literal">private</code> method for creating our bitmaps from each model's byte array.</p><p>If we have a look at the current implementation, what do we notice here?</p><p>We are creating a bitmap every time the cell requires this data again for the view; is this efficient? No, we should be reusing bitmaps and memory as much as possible.</p><p>This tends to be a common issue with Android <code class="literal">ListView</code>.</p><p>What is the most memory efficient way to reuse bitmaps across hundreds of items in a <code class="literal">ListView</code> while scrolling and staying smooth as we move down the list at various speeds? How can we tackle this problem? Let's have a look at how we can approach this problem.</p><p>Firstly, we need to implement an object called <code class="literal">ImageHandler</code>. This will contain the logic for retrieving byte arrays from all gallery images on an Android device. Create a new file, name it <code class="literal">ImageHandler</code>, and start importing these namespaces:</p><pre class="programlisting">namespace Gallery.Droid 
{ 
    using System; 
    using System.Collections.Generic; 
 
    using Android.Database; 
    using Android.Content; 
    using Android.Provider; 
 
    using Gallery.Shared; 
 
    public static class ImageHandler 
    { 
    } 
} 
</pre><p>This class will include a function, <code class="literal">GetFiles</code>, which will create gallery items based upon the items pulled from any device's gallery using the <code class="literal">ContentResolver</code> interface:</p><pre class="programlisting">public static IEnumerable&lt;GalleryItem&gt; GetFiles(Context context) 
        { 
            ContentResolver cr = context.ContentResolver; 
 
            string[] columns = new string[]  
            { 
                MediaStore.Images.ImageColumns.Id, 
                MediaStore.Images.ImageColumns.Title, 
                MediaStore.Images.ImageColumns.Data, 
                MediaStore.Images.ImageColumns.DateAdded, 
                MediaStore.Images.ImageColumns.MimeType, 
                MediaStore.Images.ImageColumns.Size, 
            }; 
             
            var cursor = cr.Query(MediaStore.Images.Media.ExternalContentUri, columns, null, null, null); 
 
            int columnIndex = cursor.GetColumnIndex(columns[2]); 
 
            int index = 0; 
 
            // create max 100 items 
            while (cursor.MoveToNext () &amp;&amp; index &lt; 100)  
            { 
                index++; 
 
                var url = cursor.GetString(columnIndex); 
 
                var imageData = createCompressedImageDataFromBitmap (url); 
 
                yield return new GalleryItem ()  
                { 
                    Title = cursor.GetString(1), 
                    Date = cursor.GetString(3), 
                    ImageData = imageData, 
                    ImageUri = url, 
                }; 
            } 
        } 
</pre><p>Using <code class="literal">ContentResolver</code> (used to access the content model), we resolve <span class="strong"><strong>URIs</strong></span> to specific content providers. A content provider provides queries to content, in our case image files. We simply create an access query off the main context's <code class="literal">ContentResolver</code> instance, and we provide an array of columns for the query to retrieve (for example, file titles, file data, file size, and so on). The first parameter is as follows:</p><pre class="programlisting">"MediaStore.Images.Media.ExternalContentUri" 
</pre><p>This is used for retrieving the URI to each piece of content returned from the query. Finally, we now have a cursor to iterate through, exactly like an <code class="literal">Enumerable</code>, which will loop to the end until there are no more items, and for each iteration we pull the data and URI columns and create a new <code class="literal">GalleryItem</code>. You will notice a little trick here with the <code class="literal">yield</code> keyword: if we call this function, it will actually return the entire <code class="literal">Enumerable</code> from start to finish. Calling the function starts <span class="emphasis"><em>for each-ing</em></span> over the object; the function is called again until it <span class="emphasis"><em>yields</em></span>. In the return from calling this function, we get an <code class="literal">Enumerable</code> of all the items retrieved from the query as gallery items with image information and local URI.</p></div>
<div class="section" title="Bitmap functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Bitmap functions</h1></div></div></div><p>What about the byte data? First, let's implement our <code class="literal">BitmapHelpers</code>; these will include two global functions to help with bitmap processing:</p><pre class="programlisting">public static int CalculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) 
        { 
            // Raw height and width of image 
            float height = options.OutHeight; 
            float width = options.OutWidth; 
            double inSampleSize = 1D; 
 
            if (height &gt; reqHeight || width &gt; reqWidth) 
            { 
                int halfHeight = (int)(height / 2); 
                int halfWidth = (int)(width / 2); 
 
                // Calculate a inSampleSize that is a power of 2 - the decoder will use a value that is a power of two anyway. 
                while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) 
                { 
                    inSampleSize *= 2; 
                } 
            } 
 
            return (int)inSampleSize; 
        } 
 
        public static async void CreateBitmap(ImageView imageView, byte[] imageData) 
        { 
            try 
            { 
                if (imageData != null)  
                { 
                    var bm = await BitmapFactory.DecodeByteArrayAsync(imageData, 0, imageData.Length); 
                    if (bm != null)  
                    { 
                        imageView.SetImageBitmap(bm); 
                    } 
                } 
            } 
            catch (Exception e)  
            { 
                Console.WriteLine ("Bitmap creation failed: " + e); 
            } 
        } 
</pre><p>Our first function will determine the best sample size by the requested width and height. This is a very good technique for reducing the resources required to load an image into memory. Our next function is used to create a bitmap for the <code class="literal">ImageView</code> that is passed in from the byte data.</p><p>The next step is to create this image data using the <code class="literal">private</code> method <code class="literal">createCompressedImageDataFromBitmap</code>:</p><pre class="programlisting">private static byte[] createCompressedImageDataFromBitmap(string url) 
        { 
            BitmapFactory.Options options = new BitmapFactory.Options (); 
            options.InJustDecodeBounds = true; 
            BitmapFactory.DecodeFile (url, options); 
            options.InSampleSize = BitmapHelpers.CalculateInSampleSize (options, 1600, 1200); 
            options.InJustDecodeBounds = false; 
 
            Bitmap bm = BitmapFactory.DecodeFile (url, options); 
 
            var stream = new MemoryStream (); 
            bm.Compress (Bitmap.CompressFormat.Jpeg, 80, stream); 
            return stream.ToArray (); 
        } 
</pre><p>This method will take the image URI and decode the bitmap options in order to sample the smallest possible size for the dimensions provided.</p><p>We have to make sure that we flag <code class="literal">InJustDecodeBounds</code> so this bitmap is not loaded into memory while we are retrieving the options information. This approach is very useful for reducing images to the size we require, thus saving memory. We then compress the image by 80% into a JPEG and convert the stream into a byte array for our <code class="literal">GalleryItem</code> model.</p><p>Now let's go back to the <code class="literal">adapter</code> class and add this method to fill in the items of our <code class="literal">ListAdapter</code>:</p><pre class="programlisting">public ListAdapter(Activity context) : base() 
        { 
            _context = context; 
            _items = new List&lt;GalleryItem&gt;(); 
 
            foreach (var galleryitem in ImageHandler.GetFiles (_context)) 
            { 
                _items.Add (galleryitem); 
            } 
        } 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note9"/>Note</h3><p>Remember we must have a reference in our list adapter to the main context.</p></div></div><p>Now for the final piece of the puzzle, connecting the adapter to our list view. Open up the <code class="literal">MainActivity.cs</code> file and update the code list like so:</p><pre class="programlisting">public class MainActivity : Activity 
    { 
        private ListAdapter _adapter; 
 
        protected override void OnCreate (Bundle savedInstanceState) 
        { 
            base.OnCreate (savedInstanceState); 
 
            SetContentView (Resource.Layout.Main); 
 
            _adapter = new ListAdapter (this); 
 
            var listView = FindViewById&lt;ListView&gt; (Resource.Id.listView); 
            listView.Adapter = adapter; 
        } 
    } 
</pre><p>And voila! Try running the application and watching the <code class="literal">ListView</code> update with the images in your device's <span class="strong"><strong>Gallery</strong></span> folder. Congratulations! You have just developed your first <code class="literal">Xamarin.Android</code> application. Now we must replicate this approach for the iOS version.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Notice the challenge with context switching when jumping back and forth between Android and iOS; it can get confusing. Luckily, with Xamarin we keep to just one programming language, which helps reduce the complexity.</p></div></div></div>
<div class="section" title="The ALAssetLibrary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>The ALAssetLibrary</h1></div></div></div><p>Jumping back into our iOS, we are going to use the <code class="literal">ALAssetsLibrary</code> class and call the Enumerate function by passing in the group type <code class="literal">ALAssetsGroupType.SavedPhoto</code>, the enumeration result delegate <code class="literal">GroupEnumerator</code>, and the error action that will be performed if an exception occurs.</p><p>Start by adding in a new <code class="literal">.cs</code> file for our iOS image handler:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>We are not going to use a static class with this object.</p></div></div><pre class="programlisting">namespace Gallery.iOS 
{ 
    using System; 
    using System.Threading; 
 
    using UIKit; 
    using AssetsLibrary; 
    using Foundation; 
 
    /// &lt;summary&gt; 
    /// Image handler. 
    /// &lt;/summary&gt; 
    public class ImageHandler 
    { 
        /// &lt;summary&gt; 
        /// The asset library. 
        /// &lt;/summary&gt; 
        ALAssetsLibrary _assetLibrary; 
 
        /// &lt;summary&gt; 
        /// Initializes a new instance of the &lt;see cref="Gallery.iOS.ImageHandler"/&gt; class. 
        /// &lt;/summary&gt; 
        public ImageHandler () 
        { 
            _assetLibrary = new ALAssetsLibrary(); 
            _assetLibrary.Enumerate(ALAssetsGroupType.SavedPhotos, GroupEnumerator, Console.WriteLine); 
        }  
    } 
} 
</pre><p>In our constructor, we create the new instance of the <code class="literal">ALAssetsLibrary</code> and call the <code class="literal">Enumerate</code> function; now let's add the <code class="literal">GroupEnumerator</code> delegate:</p><pre class="programlisting">private void GroupEnumerator(ALAssetsGroup assetGroup, ref bool shouldStop) 
        { 
            if (assetGroup == null) 
            { 
                shouldStop = true; 
                NotifyAssetsLoaded (); 
 
                return; 
            } 
 
            if (!shouldStop) 
            { 
                assetGroup.Enumerate(AssetEnumerator); 
                shouldStop = false; 
            } 
        } 
 
        private void AssetEnumerator(ALAsset asset, nint index, ref bool shouldStop) 
        { 
            if (asset == null) 
            { 
                shouldStop = true; 
                return; 
            } 
 
            if (!shouldStop) 
            { 
                // add asset name to list 
                _assets.Add (asset.ToString()); 
                shouldStop = false; 
            } 
        } 
 
   private void NotifyAssetsLoaded() 
        { 
            if (AssetsLoaded != null) 
            { 
                AssetsLoaded (this, EventArgs.Empty); 
            } 
        } 
</pre><p>Notice the call to notify our event handler. This signals we have reached the end of the <code class="literal">asset</code> library, and we have retrieved all <code class="literal">ALAsset</code> in our gallery. We can now pull out a list of the file names, so we need to add another function that will pull out the <code class="literal">ALAsset</code> object synchronously:</p><pre class="programlisting">public ALAsset SynchronousGetAsset(string filename) 
        { 
            ManualResetEvent waiter = new ManualResetEvent(false); 
            NSError error = null; 
            ALAsset result = null; 
            Exception exception;  
 
            ThreadPool.QueueUserWorkItem ((object state) =&gt; assetLibrary.AssetForUrl (new NSUrl (filename), (ALAsset asset) =&gt;  
                { 
                    result = asset; 
                    waiter.Set (); 
                },  
                e =&gt;  
                { 
                    error = e; 
                    waiter.Set (); 
                })); 
 
 
            if(!waiter.WaitOne (TimeSpan.FromSeconds (10))) 
                throw  new Exception("Error Getting Asset : Timeout, Asset=" + filename); 
 
            if (error != null) 
                throw new Exception (error.Description); 
 
            return result; 
        } 
</pre><p>Finally, we need a public function that will pull all the byte arrays and <code class="literal">NSURL</code> into an <code class="literal">Enumerable</code> of gallery items that we will use to populate the <code class="literal">UITableView</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>As this is only a demo, we are only going to take the first 100 items. If you would like another challenge, remove <code class="literal">Take(100)</code>, and see if you can adjust the code to load thousands of images more efficiently.</p></div></div><pre class="programlisting">foreach (var file in _assets.Take(100))  
            { 
                using (var asset = SynchronousGetAsset (file)) 
                { 
                    if (asset != null)  
                    { 
                        var thumbnail = asset.Thumbnail; 
                        var image = UIImage.FromImage (thumbnail); 
                        var jpegData = image.AsJPEG ().ToArray (); 
 
                        yield return new GalleryItem ()  
                        { 
                            Title = file, 
                            Date = asset.Date.ToString(), 
                            ImageData = jpegData, 
                            ImageUri = asset.AssetUrl.ToString () 
                        }; 
                    } 
                } 
            } 
        } 
</pre><p>Let's look a bit more closely at this function. We use the <code class="literal">asset</code> library object to pull out all the filenames we have in our gallery, then for each filename we pull out the <code class="literal">ALAsset</code> object, and from this we create a <code class="literal">GalleryItem</code> object for each, which takes the image data as a byte array from the <code class="literal">ALAsset</code> and the <code class="literal">NSURL</code> of the asset. Now let's create an instance of the <code class="literal">ImageHandler</code> inside our <code class="literal">TableSource</code>:</p><pre class="programlisting">        private ImageHandler _imageHandler; 
 
        public TableSource (string[] items) 
        { 
            _galleryItems = new List&lt;GalleryItem&gt; (); 
            _imageHandler = new ImageHandler (); 
 
            foreach (var galleryItem in imageHandler.GetFiles ())  
            { 
                _galleryItems.Add (galleryItem); 
            } 
        } 
</pre><p>Excellent! Now we have our gallery items ready to display inside the table.</p><p>For the final piece of the iOS project, let's go back to our <code class="literal">AppDelegate.cs</code> file. We still need to implement the <code class="literal">FinishedLaunching</code> method. Our root controller is going to be a <code class="literal">UINavigationController</code>, which will use the <code class="literal">MainController</code> as the starting <code class="literal">UIViewController</code>:</p><pre class="programlisting">public override bool FinishedLaunching (UIApplication application, NSDictionary launchOptions) 
        { 
            _window = new UIWindow (UIScreen.MainScreen.Bounds); 
 
            MainController mainController = new MainController(); 
 
            var rootNavigationController = new UINavigationController(); 
            rootNavigationController.PushViewController(mainController, false); 
 
            _window.RootViewController = rootNavigationController; 
            _window.MakeKeyAndVisible (); 
 
            return true; 
        } 
</pre><p>We also adjust the window bounds the main screen bounds and call the function on the window at the very end of <code class="literal">MakeKeyAndVisible</code>.</p></div>
<div class="section" title="Adding the iOS photo screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Adding the iOS photo screen</h1></div></div></div><p>Now that we have our list page, we want to add another <code class="literal">UIViewController</code> for displaying selected photos. Let's add a new <code class="literal">UIViewController</code> and call it <code class="literal">PhotoController</code>. In <code class="literal">PhotoController</code>, we are going to build a screen that simply displays the same content in the <code class="literal">PhotoCell</code>, but a bit larger.</p><p>First, let's add the navigation flow from <code class="literal">MainController</code> to <code class="literal">PhotoController</code>. We are going to be pushing a new <code class="literal">PhotoController</code> whenever a row is selected. Open up <code class="literal">TableSource.cs</code> and add the following; at the top, we need to add an <code class="literal">EventHandler</code>:</p><pre class="programlisting">public event EventHandler&lt;GalleryItem&gt; 
 ItemSelected; 
</pre><p>Whenever the row is selected we want to fire this event:</p><pre class="programlisting">public override void RowSelected (UITableView tableView, NSIndexPath indexPath) 
        { 
            if (ItemSelected != null) 
            { 
                ItemSelected (this, galleryItems[indexPath.Row]); 
            } 
 
            tableView.DeselectRow (indexPath, true); 
        } 
</pre><p>Whenever the row is selected, we want to fire this event and pass the gallery item for the index path row. Now we need to handle this event in the <code class="literal">MainController</code> class to push a new <code class="literal">PhotoController</code> on the navigation stack, but before we do this we need to implement <code class="literal">PhotoController</code>:</p><pre class="programlisting">public partial class PhotoController : UIViewController 
    { 
        /// &lt;summary&gt; 
        /// The image view. 
        /// &lt;/summary&gt; 
        private UIImageView _imageView; 
 
        /// &lt;summary&gt; 
        /// The title label. 
        /// &lt;/summary&gt; 
        private UILabel _titleLabel; 
 
        /// &lt;summary&gt; 
        /// The date label. 
        /// &lt;/summary&gt; 
        private UILabel _dateLabel; 
 
        /// &lt;summary&gt; 
        /// Initializes a new instance of the &lt;see cref="Gallery.iOS.PhotoController"/&gt; class. 
        /// &lt;/summary&gt; 
        public PhotoController (ALAsset asset) : base ("PhotoController", null) 
        { 
            _imageView = new UIImageView() 
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
                ContentMode = UIViewContentMode.ScaleAspectFit 
            }; 
 
            _titleLabel = new UILabel ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
 
            _dateLabel = new UILabel ()  
            { 
                TranslatesAutoresizingMaskIntoConstraints = false, 
            }; 
 
            _imageView.Image = new UIImage(asset.DefaultRepresentation.GetFullScreenImage ()); 
            _titleLabel.Text = asset.DefaultRepresentation.Filename; 
            _dateLabel.Text = asset.Date.ToString(); 
        } 
</pre><p>This is very similar to our <code class="literal">GalleryCell</code> presentation, but this controller will stack the elements vertically and force the image to scale to fit, keeping the image's correct ratio to avoid any warping. Now let's add <code class="literal">ViewDidLoad</code> to lay out the views:</p><pre class="programlisting">public override void ViewDidLoad () 
        { 
            base.ViewDidLoad (); 
 
            View.Add (_imageView); 
            View.Add (_titleLabel); 
            View.Add (_dateLabel); 
 
            // set layout constraints for main view 
            View.AddConstraints (NSLayoutConstraint.FromVisualFormat("V:|[imageView]-10-[titleLabel(50)]-10-[dateLabel(50)]|", NSLayoutFormatOptions.DirectionLeftToRight, null, new NSDictionary("imageView", imageView, "titleLabel", titleLabel, "dateLabel", dateLabel))); 
 
            View.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|[imageView]|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("imageView", imageView))); 
            View.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|[titleLabel]|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("titleLabel", titleLabel))); 
            View.AddConstraints (NSLayoutConstraint.FromVisualFormat("H:|[dateLabel]|", NSLayoutFormatOptions.AlignAllTop, null, new NSDictionary ("dateLabel", dateLabel))); 
        } 
</pre><p>There's nothing new here; we are simply adding the three elements and setting our layout constraints accordingly. We stretch all elements to the entire width of the view and stack elements down the pages with the image view on top and a dynamic size based upon the aspect size of the image.</p><p>Finally, the last step is to add the event handler whenever a row is selected. We use <code class="literal">ImageHandler</code> to fetch <code class="literal">ALAsset</code> by the title (filename) in the gallery item, then pass this into the constructor of a new <code class="literal">PhotoController</code> and update the constructor of <code class="literal">MainController</code>:</p><pre class="programlisting">        public MainController () : base ("MainController", null) 
        { 
            _source = new TableSource (); 
 
            _source.ItemSelected += (sender, e) =&gt;  
            { 
                var asset = _imageHandler.SynchronousGetAsset (e.Title); 
                NavigationController.PushViewController (new PhotoController (asset), true); 
            }; 
 
            _imageHandler = new ImageHandler (); 
            _imageHandler.AssetsLoaded += handleAssetsLoaded; 
        } 
</pre><p>Excellent! Now run the application and try selecting a few items in the list; you will be navigated to a new <code class="literal">PhotoController</code> which will display the selected <code class="literal">ALAsset</code> image with its filename and date information.</p></div>
<div class="section" title="Adding the Android photo screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Adding the Android photo screen</h1></div></div></div><p>Implementing a photo view for cell selections is very similar, although with Android we will be using an intent to create a new activity, which in turn will inflate a new view to display the image and details. Let's start by adding a new XML called <code class="literal">photo_view.xml</code>, and paste in the following code:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;LinearLayout  
    android:orientation="vertical" 
    android:layout_width="match_parent" 
    android:layout_height="match_parent" 
    android:weightSum="4"&gt; 
    &lt;LinearLayout 
        android:orientation="vertical" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" 
        android:layout_weight="1"&gt; 
        &lt;ImageView 
            android:id="@+id/image_photo" 
            android:scaleType="centerCrop" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:adjustViewBounds="true" /&gt; 
    &lt;/LinearLayout&gt; 
    &lt;LinearLayout 
        android:orientation="vertical" 
        android:layout_width="match_parent" 
        android:layout_height="match_parent" 
        android:layout_weight="3" 
        android:weightSum="2"&gt; 
        &lt;TextView 
            android:id="@+id/title_photo" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" /&gt; 
        &lt;TextView 
            android:id="@+id/date_photo" 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:layout_weight="1" /&gt; 
    &lt;/LinearLayout&gt; 
&lt;/LinearLayout&gt; 
</pre><p>The layout is very much the same as the <code class="literal">custom_cell.xml</code> sheet, although we are going to stack items vertically and set the following two properties to keep the correct image aspect ratio:</p><pre class="programlisting">android:adjustViewBounds="true" 
android:scaleType="centerCrop" 
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Make sure XML sheets do not contain the same IDs as any other XML sheet.</p></div></div><p>Now that we have our user interface for the <code class="literal">PhotoActivity</code>, let's add the new activity:</p><pre class="programlisting">[Activity (Label = "Gallery.Droid", Icon = "@mipmap/icon")] 
    public class PhotoActivity : Activity 
    { 
        /// &lt;summary&gt; 
        /// Raises the create event. 
        /// &lt;/summary&gt; 
        /// &lt;param name="savedInstanceState"&gt;Saved instance state.&lt;/param&gt; 
        protected override void OnCreate (Bundle savedInstanceState) 
        { 
            base.OnCreate (savedInstanceState); 
 
            // Set our view from the "main" layout resource 
            SetContentView (Resource.Layout.Photo); 
 
            var imageData = Intent.GetByteArrayExtra ("ImageData"); 
            var title = Intent.GetStringExtra ("Title") ?? string.Empty; 
            var date = Intent.GetStringExtra ("Date") ?? string.Empty; 
 
            // set image 
            var imageView = FindViewById&lt;ImageView&gt; (Resource.Id.image_photo); 
            BitmapHelpers.CreateBitmap (imageView, imageData); 
 
            // set labels 
            var titleTextView = FindViewById&lt;TextView&gt; (Resource.Id.title_photo); 
            titleTextView.Text = title; 
            var dateTextView = FindViewById&lt;TextView&gt; (Resource.Id.date_photo); 
            dateTextView.Text = date; 
        } 
    } 
</pre><p>Looking at this new activity, what can we see? Notice the attributes at the top:</p><pre class="programlisting">[Activity (Label = "Gallery.Droid", Icon = "@mipmap/icon")] 
</pre><p>There is no <code class="literal">MainLauncher</code> tag because this is not our starting activity. We then add the <code class="literal">intent.GetExtras</code> for the image data and strings required to display on our <code class="literal">Photo</code> interface.</p><p>Now we need to make one addition to the <code class="literal">ListAdapter</code> class:</p><pre class="programlisting">public GalleryItem GetItemByPosition (int position) 
{ 
     return _items[position]; 
} 
</pre><p>When an item in the list is selected, we need to be able to access the selected <code class="literal">GalleryItem</code>. Our next step is to add the <code class="literal">ItemClick</code> delegate for the <code class="literal">ListView</code>. Open up the <code class="literal">MainActivity</code> class and add the following to the <code class="literal">OnCreate</code> function:</p><pre class="programlisting">listView.ItemClick += (object sender, AdapterView.ItemClickEventArgs e) =&gt;  
            { 
                var galleryItem = adapter.GetItemByPosition (e.Position); 
                var photoActivity = new Intent(this, typeof(PhotoActivity)); 
                photoActivity.PutExtra ("ImageData", galleryItem.ImageData); 
                photoActivity.PutExtra ("Title", galleryItem.Title); 
                photoActivity.PutExtra ("Date", galleryItem.Date); 
                StartActivity(photoActivity); 
            }; 
</pre><p>Place this after we set the list adapter. When an item is clicked, we simply pull out the gallery item from our adapter by the position passed from the <code class="literal">ItemClickEventArgs</code>. Once we have the gallery item, we create the new <code class="literal">PhotoActivity</code> intent and pass the extras.</p><p>That is all; run the application and play around selecting cells to display the <code class="literal">PhotoActivity</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we built a gallery application on both iOS and Android using native development with Xamarin. We learnt how to setup projects in Xamarin Studio and code using the native frameworks in C#. In the next chapter, we will build a text to speech service using <code class="literal">Xamarin.Forms</code>.</p><p>Try improving on this code and make this function asynchronous; the more background processing we have at this stage, the better. These are the small improvements we should take time with, as combining all these small additions can create a real difference to the speed of your application.</p><p>As this is only a demo, we are only going to take the first 100 items. If you would like another challenge, remove <code class="literal">Take(100)</code>, and see if you can adjust the code to load thousands of images more  efficiently.</p></div></body></html>