- en: Implement a Replay System with the Command Pattern
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use a classic design pattern named Command to implement
    a replay system for our racing game. Its mechanism will record the player's controller
    inputs and the corresponding timestamp. This approach will permit us to play back
    the recorded inputs in the proper order and with the correct timing.
  prefs: []
  type: TYPE_NORMAL
- en: Replay features are often a must-have in racing games. With the Command pattern,
    we are going to implement this system in a scalable and modular manner. This pattern
    proposes a mechanism that permits encapsulating information needed to perform
    an "action" or trigger a state change. It also decouples the requester of an "action"
    from the object that will perform it. This encapsulation and decoupling permit
    us to queue action requests so we can execute them at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: All of this might sound very abstract, but once we implement the system's core
    components, it will be made clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a replay system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a replay system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following chapter is hands-on, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/3wAWYpb](https://bit.ly/3wAWYpb)[.](https://bit.ly/3wAWYpb)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a platform game in which you can jump over obstacles when you press
    the space bar. In this scenario, every time you press that input key, you are
    asking the character on the screen to change states and perform a jump action.
    In code, we could implement a simple `InputHandler`, which would listen for a
    space bar input from the player, and when the player hits it, we would call `CharacterController`
    to trigger the jump action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following very simplified pseudo-code sums up what we have in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this approach can get the job done, but if we wanted to record,
    undo, or replay an input from the player at a later time, it could become complicated.
    However, the Command pattern permits us to decouple the object that invokes the
    operation from the one that knows how to execute it. In other words, our `InputHandler`
    doesn't need to know what exact action needs to be taken when the player presses
    the space bar. It just needs to make sure that the correct *command* is executed
    and let the Command pattern mechanism do its magic behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudo-code shows the difference in the way we implement `InputHandler`
    when we are using the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are not just invoking `CharacterController` directly when
    the player presses the space bar. We are actually encapsulating all the information we
    need to perform the jump action into an object that we could put in a queue and
    re-invoke at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following diagram, which illustrates an implementation of
    the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1055bba6-6fa4-4b50-92da-48f9440eb790.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – UML diagram of the Command pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'Trying to learn about the Command pattern by looking at a diagram is not the
    right approach, but it does help us isolate the fundamental classes that are participating
    in this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoker` is an object that knows how to execute a command and can also do
    the bookkeeping of executed commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Receiver` is a type of object that can receive commands and execute them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandBase` is an abstract class that an individual `ConcreteCommand` class
    must inherit, and it exposes an `Execute()` method that `Invoker` can call to
    execute a specific command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each participant in the pattern has a distinct responsibility and a role to
    play. A solid implementation of the Command pattern should allow us to encapsulate
    action requests as an object that can be queued and executed immediately or at
    a later time.
  prefs: []
  type: TYPE_NORMAL
- en: The Command pattern is a part of the Behavioral pattern family; its close cousins
    are Memento, Observer, and Visitor. These types of patterns are often concerned
    with the assignment of responsibilities and how objects communicate with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are some of the benefits of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoupling**: The pattern permits the decoupling of the object that invokes
    the operation from the one that knows how to execute it. This layer of separation
    allows the addition of an intermediary that will be able to bookkeep and sequence
    operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequencing**: The Command pattern facilitates the process of queuing user
    inputs, which permits the implementation of undo/redo features, macros, and command
    queues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a potential drawback of the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: It takes numerous classes to implement this pattern as each
    command is a class in itself. And it takes a good understanding of the pattern
    to maintain code built with it. In most cases, this is not an issue, but if you
    are using the Command pattern without a specific goal in mind, it can become an
    unnecessary layer of complexity and verbosity in your code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits and drawbacks are usually contextual; the ones presented in this book
    are general, and not absolutes. Therefore, it's essential when choosing a pattern
    to analyze its benefits and drawbacks in the context of your own project, and
    to not consider or reject one based on general statements.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a shortlist of possible uses for the Command pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Undo**: Implementing an undo/redo system that you find in most text and image
    editors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Macro**: A macro recording system with which players can record a sequence
    of attack or defensive combos. Then, assign them on an input key to execute them
    automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation:** Automate processes or behaviors by recording a set of commands
    that a bot will automatically and sequentially execute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, it's a good pattern for features related to storing, timing,
    and sequencing user inputs. And if you get very creative with it, you could create
    some compelling game systems and mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are fun to use if you don't worry too much about staying true
    to the original academic descriptions. If you don't lose the original intent of
    the pattern while experimenting with it, you should retain its core benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a replay system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before describing the replay system design that we will be implementing in this
    chapter, we have to declare some specifications about our game that can influence
    the way in which we will implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifications to keep in mind are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deterministic**: Everything in our game is deterministic, which means we
    don''t have any entities with random behaviors, and that makes our replay system
    simpler to implement because we don''t have to worry about recording positions
    or states of entities that move in our scene like enemy drones. We know they will
    move and behave the same way during the replay sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics**: We are minimizing the use of the physics features of the Unity
    engine as our entities'' movements are not determined by any physical properties
    or interactions. Therefore, we do not have to worry about unexpected behaviors
    when objects collide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Digital**: All our inputs are digital, so we do not bother to capture or
    handle granular analog input data from a joystick or trigger button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Precision**: We tolerate a lack of precision in the timing of when we replay
    inputs. Therefore, we do not expect the inputs to replay precisely within the
    same timeframe as they were recorded. *This tolerance level is subject to change
    depending on several factors related to the desired level of precision of the
    replay feature.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering all these specifications, the replay system we are going to implement
    will only record the player's inputs but not the bike's current position. Because
    there are no in-between locations that the bike might be at, depending on the
    player's input, it will be on one rail or the other. Also, another essential detail
    to note is the fact that the bike does not move forward. It is the track that
    moves toward the player's position to give the illusion of movement and speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, if we record the player''s controller inputs from the start and
    end of a race, then we could simulate a replay of the player''s gameplay by replaying
    the recorded inputs at the beginning of a new race. We have a diagram that illustrates
    the mechanism behind the replay system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a1df14e-86fb-485c-b8de-c79880fb233f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Diagram of the replay system
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the diagram, `InputRecorder` records and serializes the inputs
    so that `ReplaySystem` can replay them later on. During a replay sequence, `ReplaySystem`
    acts similarly to a bot as it takes control of the bike and automatically maneuvers
    it by replaying the player's inputs. It is a simple form of automation that gives
    the illusion that we are watching a replay video.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement a simplified version of the system we
    just reviewed, and we will use the Command pattern as its foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a replay system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section includes pseudo-code for the sake of simplicity and readability.
    If you wish to review a complete implementation in the context of an actual game
    project, open the `FPP` folder in the GitHub project. The link can be found under
    the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to build up a simple input replay system prototype
    using the Command pattern as the foundation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the replay system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation will be done in two parts. In the first part, we will code
    the core components of the Command pattern and then we will integrate the elements
    that are necessary to test the replay system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we are implementing a base abstract class named `Command`, which
    has a singular method named `Execute()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we are going to write three concrete command classes that will derive from
    the `Command` base class, and then we will implement the `Execute()` method. Each
    of them encapsulates an action to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first one toggles the turbocharger on `BikeController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two commands are the `TurnLeft` and `TurnRight` commands. Each
    represents a different action and is mapped to a specific input key, as we are
    going to see when we implement `InputHandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command represents the right turn action and, as its name implies,
    this turns the bike to the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have completed the encapsulation of each command into individual
    classes, it is time to code the critical ingredient that will make our replay
    system work – `Invoker`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Invoker` is an attentive bookkeeper; it keeps track of the commands that have
    been executed in a ledger. We represent this ledger in code in the form of `SortedList`,
    a native C# sorted collection with a key/value structure. This list will keep
    track of when a specific command was executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this class is very long, we will review it in two segments. The following
    is the first part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the `Invoker` class, we add a command to the `_recordedCommands`
    sorted list every time `Invoker` executes a new one. However, we only do this
    when we start recording because we want to record the player inputs at specific
    moments, such as at the start of the race.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next section of the `Invoker` class, we are going to implement the
    replay behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you may have already noticed, we are using `FixedUpdate()` to record and
    replay commands. This might seem strange as we usually use `Update()` to listen
    for player inputs. However, `FixedUpdate()` has the advantage of running in fixed
    time steps and is helpful for time-dependent but frame rate-independent tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we know that the default engine time step is 0.02 seconds, and our
    timestamps will be in similar increments as we use `Time.fixedDeltaTime` to record
    the time of executed commands.
  prefs: []
  type: TYPE_NORMAL
- en: However, this also means that we lose precision during the recording phase,
    as our timestamp is bound to Unity's time-step settings. This loss of precision
    is tolerable in the context of this example. However, it could become an issue
    if there are significant inconsistencies between the game play and replay sequences.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, we might need to consider a solution that includes `Update()`,
    `Time.deltaTime`, and a value that will permit us to set the degree of precision
    when comparing the recording and replay time. However, this is beyond the scope
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We should take note that we are giving `Invoker` the responsibility of bookkeeping
    but also replaying. It can be argued that we have broken the single responsibility
    principle by giving `Invoker` too many responsibilities. In this context, this
    is not an issue; it is just a code example for educational purposes. Still, it
    would be wise to encapsulate the responsibilities of recording, saving, and replaying
    commands in a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the replay system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the core ingredients of the Command pattern and our replay
    system in place, it is time to test whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first class we will implement is `InputHandler`. Its primary responsibility
    is to listen for the player''s inputs and invoke the appropriate commands. However,
    because of its length, we will review it in two parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this section of the class, we are initializing our commands and mapping them
    to specific inputs. Notice that we are passing an instance of `BikeController`
    in the command's constructor. `InputHandler` is only aware that `BikeController`
    exists, but does not need to know how it functions. It is the responsibility of
    the individual command classes to call the proper public methods of the bike's
    controller depending on the desired action. In the `Update()` loop, we listen
    for specific key inputs and call on `Invoker` to execute a command associated
    with a particular input.
  prefs: []
  type: TYPE_NORMAL
- en: This segment of code is what makes it possible to record the inputs of the player.
    We do not call `BikeController` directly, and we do not execute the commands.
    Instead, we allow `Invoker` to act like an intermediary and do all the work. This
    approach permits it to keep records of the player inputs in the background for
    later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final part of the `InputHandler` class, we are adding some GUI debug
    buttons that will help us test the replay system. This segment of code is for
    debugging and testing purposes only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For our final class, we will implement a skeleton version of the `BikeController`
    class for testing purposes. It acts like a receiver in the context of the Command
    pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The overall purpose and structure of the class are self-explanatory. `ToggleTurbo()`
    and `Turn()` are public methods that get called by the command classes. However,
    `ResetPosition()` is for debugging and testing purposes only and can be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this code in your instance of Unity, you need to complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new empty Unity scene that includes at least one light and camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a 3D GameObject to the new scene, such as a cube, and make it visible from
    the scene's main camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the `InputHandler` and `BikeController` classes to the new GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At runtime, if you have copied all the classes we have just reviewed in your
    project, you should see the following on your screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6930a7ab-085c-4dc5-8f7a-aced6162fbd0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Screenshot of the code in action inside Unity
  prefs: []
  type: TYPE_NORMAL
- en: When you start recording, you will be able to move the cube on a horizontal
    axis. Each input entered can be replayed in the same sequence and timing they
    were recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We completed the process of building a quick input replay system by using the
    Command pattern as our foundation. Of course, the code example in this chapter
    is not production-ready and very limited. Nevertheless, the goal of this chapter
    was to learn how to use the Command pattern with Unity, and not design an entire
    replay system.
  prefs: []
  type: TYPE_NORMAL
- en: In the game prototype project in the `FPP` folder of the GitHub project, we
    did implement a more advanced example of a replay system that includes serialization
    and a rewind feature. We recommend checking it out and, of course, modify it at
    your discretion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will review some alternatives solutions and approaches
    that we could have used to build our replay system.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if the Command pattern was perfectly suited for our use case, there are
    some alternative patterns and solutions we could have considered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memento:** The Memento pattern provides the ability to roll back an object
    to a previous state. This was not our first choice for our replay system because
    we are focusing on recording inputs and queuing them for replay at a later time,
    which is very compatible with the design intention of the Command pattern. However,
    if we implemented a system with a rollback to the previous state feature, the
    Memento pattern will probably be our first choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queue/Stack**: Queues and stacks are not patterns, but data structures, but
    we could simply encode all our inputs and store them in a queue directly in our
    `InputHandler` class. It would have been more straightforward and less verbose
    than using the Command pattern. The choice between implementing a system with
    or without conventional design patterns is very contextual. If a system is simple
    enough, then the added verbosity and complexity that a design pattern might bring
    might exceed the potential benefits of using it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a simple, but functional, replay system by using
    the Command pattern. Our goal with this chapter was not to show how to build a
    robust replay system, but instead showcase how to use the Command pattern to create
    something in Unity that might be useful for a game project.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you will research alternative ways of implementing the Command pattern
    that might be better than shown in this book because, like most things in programming,
    there is no single way of doing things. Nevertheless, at least this chapter offers
    a first approach to using the Command pattern with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the book, we will start optimizing our code with the Object
    pool. An essential aspect of a good racing game is consistent performance and
    frame rate. Everything must run smoothly at every moment, or it might cause our
    game to feel slow and sluggish.
  prefs: []
  type: TYPE_NORMAL
