- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using Masks, Scrollbars, and Scroll Views
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用遮罩、滚动条和滚动视图
- en: We’ve learned how to make UI that has all of its components visible on the screen
    at once, but often you will have UI elements that are off-screen or off-menu and
    not visible until you navigate to them or reveal them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何创建所有组件都同时显示在屏幕上的 UI，但通常您会有一些 UI 元素在屏幕之外或菜单之外，直到您导航到它们或揭示它们才可见。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: How to use masks to hide portions of UI Images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用遮罩隐藏 UI 图像的部分
- en: Using Scrollbars and accessing their properties via code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滚动条并通过代码访问它们的属性
- en: Utilizing the UI Scroll View to create scrollable menus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 UI 滚动视图创建可滚动菜单
- en: Creating a settings menu with a mask and scrolling text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用遮罩和滚动文本创建设置菜单
- en: Note
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: All the examples shown in this chapter can be found within the Unity project
    provided in the code bundle. They can be found within the scene labeled **Chapter12**.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有示例都可以在提供的 Unity 项目中的代码包中找到。它们可以在标记为 **Chapter12** 的场景中找到。
- en: Each example image has a caption stating the example number within the scene.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例图像都有一个标题，说明场景中的示例编号。
- en: In the scene, each example is on its own Canvas, and some of the Canvases are
    deactivated. To view an example on a deactivated Canvas, simply select the checkbox
    next to the Canvas’ name in the **Inspector**. Each Canvas is also given its own
    Event System. This will cause errors if you have more than one Canvas activated
    at a time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中，每个示例都在自己的 Canvas 上，其中一些 Canvas 被禁用。要查看禁用 Canvas 上的示例，只需在 **Inspector**
    中选择 Canvas 名称旁边的复选框。每个 Canvas 也都有自己的事件系统。如果您同时激活多个 Canvas，这将会导致错误。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的相关代码和资产文件：[https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2012)
- en: Using masks
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用遮罩
- en: Masks affect the visibility of objects within their shape. If an object is affected
    by a mask, any part of it outside the mask’s restricted area will be invisible.
    The visible area of a mask can either be determined by an Image with the **Mask**
    component or a Rect Transform with the **Rect Mask** **2D** component.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 遮罩会影响其形状内对象的可见性。如果一个对象受到遮罩的影响，其遮罩限制区域外的任何部分都将不可见。遮罩的可见区域可以由具有 **遮罩** 组件的图像或具有
    **Rect Mask** **2D** 组件的 Rect Transform 确定。
- en: 'With UI, masking can be used for scrolling menus, so items that exist outside
    of the menu’s area will not be visible. It is also used to *cut out* images. For
    example, the following image shows a cat’s image being cut out by a circular mask:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 UI，遮罩可用于创建滚动菜单，因此存在于菜单区域之外的项目将不可见。它还用于 *裁剪* 图像。例如，以下图像显示了一个猫的图像被圆形遮罩裁剪出来：
- en: '![Figure 12.1: Circular Mask Example in the Chapter12 scene](img/B18327_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：第 12 章场景中的圆形遮罩示例](img/B18327_12_01.jpg)'
- en: 'Figure 12.1: Circular Mask Example in the Chapter12 scene'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：第 12 章场景中的圆形遮罩示例
- en: You may note that the edges of the cat with the mask don’t look great. To avoid
    this, ensure that you use sprites with appropriate image resolutions and try different
    filtering modes on the Sprite’s **Import Settings**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到带有遮罩的猫的边缘看起来不太好。为了避免这种情况，请确保您使用具有适当图像分辨率的精灵，并在精灵的 **导入设置** 中尝试不同的过滤模式。
- en: The Mask component
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遮罩组件
- en: The **Mask** component can be added to any UI object with an **Image** component.
    If it is added to a UI object that doesn’t have an **Image** component, it won’t
    function since it needs an **Image** to determine the restricted area.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 **遮罩** 组件添加到具有 **Image** 组件的任何 UI 对象。如果将其添加到没有 **Image** 组件的 UI 对象，则它将无法工作，因为它需要一个
    **Image** 来确定限制区域。
- en: 'The **Mask** component can be added to a UI object by selecting **Add Component**
    | **UI** | **Mask** within the **Inspector**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 **Inspector** 中选择 **添加组件** | **UI** | **遮罩** 来将 **遮罩** 组件添加到 UI 对象：
- en: '![Figure 12.2: The Mask component](img/B18327_12_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2：遮罩组件](img/B18327_12_02.jpg)'
- en: 'Figure 12.2: The Mask component'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：遮罩组件
- en: Any children of the UI object containing the **Mask** component will then have
    their visibility restricted to only the area within the opaque area of the **Source
    Image** on its **Image** component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 包含**Mask**组件的UI对象的任何子对象，其可见性将被限制在其**Image**组件上的**Source Image**不透明区域内的区域。
- en: 'In the following image, the object named `Mask` is a UI Image with a **Mask**
    component added to it. As you can see, the purple triangle on the left of the
    Panel is only partially visible, while the green triangle on the right is fully
    visible. The green triangle is fully visible because it is not a child of the
    UI Image that contains a **Mask** component:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，名为`Mask`的对象是一个带有**Mask**组件的UI Image。如图所示，面板左侧的紫色三角形只有部分可见，而右侧的绿色三角形完全可见。绿色三角形完全可见，因为它不是包含**Mask**组件的UI
    Image的子对象：
- en: '![Figure 12.3: The Mask Component Example in the Chapter12 scene](img/B18327_12_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：第12章场景中的Mask组件示例](img/B18327_12_03.jpg)'
- en: 'Figure 12.3: The Mask Component Example in the Chapter12 scene'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：第12章场景中的Mask组件示例
- en: You have the option to hide the **Source Image** that defines the **Mask** component’s
    visibility area. If you deselect **Show Mask Graphic**, the parent’s **Source
    Image** will not be visible. It’s important to note that changing the opacity
    on the **Source Image** does not affect the **Mask** component’s functionality.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择隐藏定义**Mask**组件可见区域的**Source Image**。如果您取消选择**Show Mask Graphic**，则父对象的**Source
    Image**将不可见。重要的是要注意，在**Source Image**上更改不透明度不会影响**Mask**组件的功能。
- en: Rect Mask 2D component
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rect Mask 2D组件
- en: Using the **Mask** component allows you to restrict the visible area to a non-rectangular
    shape. However, if you want to restrict the visible area to a rectangular shape
    and don’t want to use an image to restrict the visible area, you can use a **Rect
    Mask** **2D** component.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Mask**组件可以限制可见区域为非矩形形状。然而，如果您想将可见区域限制为矩形形状，并且不想使用图像来限制可见区域，则可以使用**Rect Mask**
    **2D**组件。
- en: 'The Rect Mask 2D component can be added to a UI Object by selecting **Add Component**
    | **UI** | **Rect Mask 2D** within the **Inspector**, as shown in the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在**Inspector**中选择**Add Component** | **UI** | **Rect Mask 2D**将**Rect Mask
    2D**组件添加到UI对象中，如下所示：
- en: '![Figure 12.4: A Rect Mask 2D component](img/B18327_12_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：Rect Mask 2D组件](img/B18327_12_04.jpg)'
- en: 'Figure 12.4: A Rect Mask 2D component'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：Rect Mask 2D组件
- en: Notice that the component allows you to adjust **Padding** and **Softness**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该组件允许您调整**Padding**和**Softness**。
- en: When a **Rect Mask 2D** component is added to a GameObject, the visibility of
    its children will be affected by the shape of its Rect Transform. An **Image**
    component is not required on the parent object for the **Rect Mask 2D** component
    to function properly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当将**Rect Mask 2D**组件添加到GameObject中时，其子对象的可见性将受到其Rect Transform形状的影响。对于**Rect
    Mask 2D**组件能够正常工作，父对象上不需要添加**Image**组件。
- en: 'In the following image, an `Empty` UI GameObject is created and a **Rect Mask
    2D** component is added to it. It is then given a child UI Image. As you can see,
    the triangle is masked by the Rect Transform area:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中，创建了一个`Empty` UI GameObject，并向其添加了**Rect Mask 2D**组件。然后给它添加了一个子UI Image。如图所示，三角形被Rect
    Transform区域所蒙版：
- en: '![Figure 12.5: A Rect Mask 2D Component Example in the Chapter12 scene](img/B18327_12_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：第12章场景中的Rect Mask 2D组件示例](img/B18327_12_05.jpg)'
- en: 'Figure 12.5: A Rect Mask 2D Component Example in the Chapter12 scene'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：第12章场景中的Rect Mask 2D组件示例
- en: If you want to apply a mask to a rectangular shape, I highly recommend that
    you use the **Rect Mask 2D** component rather than the standard **Mask** component,
    as it is more performant.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对一个矩形形状应用蒙版，我强烈建议您使用**Rect Mask 2D**组件而不是标准的**Mask**组件，因为它性能更优。
- en: It’s important to note that, as implied by the name **Rect Mask 2D**, this mask
    will only work on 2D objects. You can read more about its limitations at [https://docs.unity3d.com/Manual/script-RectMask2D.xhtml](https://docs.unity3d.com/Manual/script-RectMask2D.xhtml).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，正如**Rect Mask 2D**的名称所暗示的，此蒙版仅适用于2D对象。您可以在[https://docs.unity3d.com/Manual/script-RectMask2D.xhtml](https://docs.unity3d.com/Manual/script-RectMask2D.xhtml)上了解更多关于其限制的信息。
- en: As I stated earlier, one common use for a mask is to create a menu with objects
    that *spill out* of the visible area. Creating these types of menus requires scrollbars
    and scroll views, so let’s look at those components now.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，蒙版的一个常见用途是创建具有超出可见区域的对象的菜单。创建此类菜单需要滚动条和滚动视图，因此现在让我们看看这些组件。
- en: Implementing UI Scrollbars
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UI滚动条
- en: The **UI Scrollbar** object allows the user to drag a handle along a path. The
    position of the handle on the path affects the position of an image or object
    within a usable area.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI 滚动条**对象允许用户沿着路径拖动一个手柄。手柄在路径上的位置会影响图像或对象在可用区域内的位置。'
- en: If you’re having trouble seeing what a scroll bar is from the preceding description,
    here’s an easier explanation with context. It is most commonly used in video games
    with menus that have a lot of information within a viewable area that is smaller
    than the area that all the information takes up.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从前面的描述中难以理解滚动条，这里有一个带有上下文的简单解释。它最常用于视频游戏中的菜单，这些菜单在可视区域内包含大量信息，而该信息占用的区域小于可视区域。
- en: To create a UI Scrollbar, select `Sliding Area`. The `Sliding Area` also has
    a child named `Handle`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建UI滚动条，选择 `Sliding Area`。`Sliding Area` 也有一个名为 `Handle` 的子组件。
- en: The `Sliding Area` child is an empty GameObject. Its purpose is to ensure that
    its child, the `Handle`, is correctly positioned and aligned. The `Handle` is
    a UI Image. It represents the interactable area of the Scrollbar.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sliding Area` 子组件是一个空GameObject。它的目的是确保其子组件，即 `Handle`，被正确定位和校准。`Handle` 是一个UI
    Image。它代表滚动条的交互区域。'
- en: If you want to change the appearance of the Scrollbar’s background and `Handle`,
    you need to change the `Handle` child, respectively.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更改滚动条背景和 `Handle` 的外观，你需要分别更改 `Handle` 子组件。
- en: The Scrollbar component
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动条组件
- en: 'The parent Scrollbar object has a **Scrollbar** component. It has all the properties
    common to the interactable UI objects, along with a few that are exclusive to
    Scrollbars:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 父滚动条对象有一个 **Scrollbar** 组件。它具有所有交互式UI对象共有的属性，以及一些仅限于滚动条的属性：
- en: '![Figure 12.6: The properties of the Scrollbar component](img/B18327_12_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6：滚动条组件的属性](img/B18327_12_06.jpg)'
- en: 'Figure 12.6: The properties of the Scrollbar component'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：滚动条组件的属性
- en: A Scrollbar’s `0` and `1`. Scrollbars are used to move objects that take up
    more room than the viewable space. Due to this, the Scrollbar’s position should
    easily translate to a percentage or a value between `0` and `1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动条的 `0` 和 `1`。滚动条用于移动占用空间大于可视空间的物体。因此，滚动条的位置应容易转换为百分比或 `0` 到 `1` 之间的值。
- en: The `Handle` is assigned to this property. You›ll note that the Rect Transform
    component on the `Handle` GameObject has the `Handle` is affected by the Scrollbar.
    The position of the Scrollbar’s `Handle` is tied to the **Value** property of
    the **Scrollbar** component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handle` 被分配到这个属性。你会注意到 `Handle` GameObject 上的 Rect Transform 组件受滚动条的影响。滚动条的
    `Handle` 位置与 **Scrollbar** 组件的 **Value** 属性相关联。'
- en: '![Figure 12.7: The Rect Transform component on the Handle GameObject](img/B18327_12_07.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7：Handle GameObject 上的 Rect Transform 组件](img/B18327_12_07.jpg)'
- en: 'Figure 12.7: The Rect Transform component on the Handle GameObject'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：Handle GameObject 上的 Rect Transform 组件
- en: 'The **Direction** property allows you to select the orientation of the Scrollbar.
    The available options are the same as with a Slider and translate accordingly:
    **Left To Right**, **Right To Left**, **Bottom To Top**, and **Top** **To Bottom**.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**方向**属性允许你选择滚动条的方向。可用的选项与滑块相同，并相应地翻译：**从左到右**、**从右到左**、**从下到上**和**从上到下**。'
- en: The `Sliding Area` taken up by the Scrollbar’s `Handle`. This can be any `float`
    value from `0` to `1`. I recommend that you choose a value relative to the size
    of the objects being scrolled so that the Scrollbar’s movement feels more intuitive.
    This means that the larger the scrollable area is, the smaller the Scrollbar `Handle`
    becomes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动条的 `Handle` 占用的 `Sliding Area`。这可以是 `0` 到 `1` 之间的任何 `float` 值。我建议你选择一个与滚动对象的大小成比例的值，这样滚动条的运动感觉会更直观。这意味着可滚动区域越大，滚动条的
    `Handle` 就越小。
- en: The **Number of Of Steps** property is used if you want the Scrollbar to have
    staggered, discrete steps and don’t want it to have continuously controlled movement.
    This is used if you want your scrollbar to move the scrolling objects to specific
    locations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**步数数量**属性用于当你想要滚动条有间隔的、离散的步骤，而不希望它有连续控制运动时。这用于当你想要你的滚动条将滚动对象移动到特定位置时。'
- en: Often, you will see a scroll area represented by dots (like the dots that identify
    which home screen you are viewing on an iOS device). This can be achieved using
    a `0`. Setting this value to `0` will allow for continuously controlled movement
    rather than staggered discrete steps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会看到一个由点（如 iOS 设备上识别你正在查看哪个主屏幕的点）表示的滚动区域。这可以通过设置 `0` 来实现。将此值设置为 `0` 将允许进行连续控制移动，而不是跳跃的离散步骤。
- en: Examples of creating continuous and discrete Scrollbars are provided in the
    *Examples* section at the end of this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的 *示例* 部分提供了创建连续和离散滚动条的示例。
- en: Scrollbar default event – On Value Changed (Single)
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动条默认事件 - 值改变（单个）
- en: The `Handle` is moved. It can accept a `float` argument.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handle` 被移动了。它可以接受一个 `float` 参数。'
- en: 'When a public function has a `float` parameter, it will appear twice within
    the function’s dropdown list of **On Value Changed (Single)** events: once within
    a **Static Parameters** list and again within the **Dynamic float** list, as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个公共函数有一个 `float` 参数时，它将在函数的 **值改变（单个）** 事件下拉列表中显示两次：一次在 **静态参数** 列表中，再次在 **动态
    float** 列表中，如下面的屏幕截图所示：
- en: '![Figure 12.8: Static Parameters and Dynamic float methods](img/B18327_12_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8：静态参数和动态 float 方法](img/B18327_12_08.jpg)'
- en: 'Figure 12.8: Static Parameters and Dynamic float methods'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8：静态参数和动态 float 方法
- en: If the function is selected from the `float` as an argument within the event.
    The event will then only send the value within that box. In the example shown
    in the following screenshot, the only value that will ever be sent to the `ScrollbarWithParameter()`
    function will be `0`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数在事件中作为 `float` 参数被选中。那么事件将只发送那个框内的值。在下面的屏幕截图示例中，将发送给 `ScrollbarWithParameter()`
    函数的唯一值将是 `0`。
- en: '![Figure 12.9: Example of a Static Parameters method in the Inspector](img/B18327_12_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9：检查器中静态参数方法的示例](img/B18327_12_09.jpg)'
- en: 'Figure 12.9: Example of a Static Parameters method in the Inspector'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：检查器中静态参数方法的示例
- en: If you want the Scrollbar’s value to be sent as an argument to a function that
    has a parameter, you must select the function from the **Dynamic** **float** list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望滚动条的值作为参数发送给一个具有参数的函数，你必须从 **动态** **float** 列表中选择该函数。
- en: 'The following functions and image represent the Scrollbar example found in
    the `Chapter12` scene that triggers events that call functions with and without
    parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数和图像代表了在 `Chapter12` 场景中找到的滚动条示例，该示例触发调用带参数和不带参数的函数的事件：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the following screenshot, the third option shows the function chosen from
    the **Dynamic float** list and will send the value of the **Value** property as
    an argument to the function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图，第三个选项显示了从 **动态 float** 列表中选择的功能，并将 **值** 属性的值作为参数发送给函数：
- en: '![Figure 12.10: Events on Scrollbar Example in the Chapter12 scene](img/B18327_12_10.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10：第 12 章场景中的滚动条事件示例](img/B18327_12_10.jpg)'
- en: 'Figure 12.10: Events on Scrollbar Example in the Chapter12 scene'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10：第 12 章场景中的滚动条事件示例
- en: Now that we’ve reviewed how to implement a UI Scrollbar in Unity, let’s look
    at UI Scroll Views.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何在 Unity 中实现 UI 滚动条，让我们看看 UI 滚动视图。
- en: Implementing UI Scroll View
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UI滚动视图
- en: The **UI Scroll View** object creates a scrollable area along with two child
    UI Scrollbars. The scrollable area can be scrolled using the scrollbars, by dragging
    the area within the Scroll View, or using the scroll wheel on the mouse.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI 滚动视图** 对象创建了一个可滚动区域，并附带两个子 UI 滚动条。可滚动区域可以通过滚动条、拖动滚动视图内的区域或使用鼠标的滚轮进行滚动。'
- en: To create a UI Scroll View, select `Viewport`, `Scrollbar Horizontal`, and `Scrollbar
    Vertical`. The `Viewport` object also has a child named `Content`. The `Scrollbar
    Horizontal` and `Scrollbar Vertical` children have the same parent/child relationship
    as default UI Scrollbars, as discussed in the previous section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 UI 滚动视图，请选择 `Viewport`、`Scrollbar Horizontal` 和 `Scrollbar Vertical`。`Viewport`
    对象还有一个名为 `Content` 的子对象。`Scrollbar Horizontal` 和 `Scrollbar Vertical` 子对象与默认 UI
    滚动条的关系相同，如前文所述。
- en: Even though the UI Scroll View comes with two `Scrollbar` children by default,
    you don’t have to use both Scrollbars with your `Scroll View`. In fact, you don’t
    have to use Scrollbars at all! Refer to the *Scroll Rect component* section for
    further details.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UI滚动视图默认带有两个 `Scrollbar` 子对象，但你不必在 `Scroll View` 中使用这两个滚动条。实际上，你甚至不需要使用滚动条！有关更多详细信息，请参阅
    *Scroll Rect 组件* 部分。
- en: 'The `Viewport` child object is a UI Image with a `Viewport` has the `Viewport`
    applies a mask to an area within the `Scroll View`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`视口`子对象是一个UI图像，其`视口`应用了一个遮罩到`滚动视图`内的一个区域：'
- en: '![](img/B18327_12_11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18327_12_11.jpg)'
- en: 'Figure 12.11: A UI Scroll View Viewport'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：UI滚动视图视口
- en: This will make the items within the `Scroll View` only viewable within the defined
    area (between the Scrollbars). You cannot change most of the `Viewport`, because
    this area is set based on how you have the settings of your `Scroll View` set
    in its **Scroll Rect** component (refer to the *Implementing UI Scrollbar* section
    for more details).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`滚动视图`内的项目仅在定义的区域内（滚动条之间）可见。您不能更改大多数的`视口`，因为这个区域是基于您在`滚动视图`的**滚动矩形**组件中设置的`滚动视图`设置来确定的（有关更多详细信息，请参阅*实现UI滚动条*部分）。
- en: The child of `Viewport` is an empty `Rect Transform` named `Content`. This will
    act as the holder of all the items you wish to place within `Scroll View`. You
    can think of the `Content` as the things that will be moving around within the
    `Scroll View`. As you can see from the following image, the Rect Transform of
    `Content` is larger than the viewable area defined by `Viewport`, since the objective
    of a `Scroll View` is to have items outside of the viewable area.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`视口`的子对象是一个名为`内容`的空`矩形变换`。这将成为您希望在`滚动视图`内放置的所有项目的容器。您可以将`内容`视为将在`滚动视图`内移动的东西。如您从以下图像中看到的，`内容`的矩形变换比由`视口`定义的可视区域大，因为`滚动视图`的目标是使项目超出可视区域。'
- en: '![Figure 12.12: A UI Scroll View Content](img/B18327_12_12.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12：UI滚动视图内容](img/B18327_12_12.jpg)'
- en: 'Figure 12.12: A UI Scroll View Content'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：UI滚动视图内容
- en: To add items to the `Scroll View`, you simply add children to the `Content`
    object. Since `Content` is a child of `Viewport`, any of its children will also
    be affected by the `Viewport`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`滚动视图`添加项目，您只需将子对象添加到`内容`对象中。由于`内容`是`视口`的子对象，其任何子对象都将受到`视口`的影响。
- en: 'The following example shows four images added as children of `Content`. `Content`
    has also been given a **Vertical Layout** **Group** component:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了作为`内容`子对象的四个图像。`内容`还添加了一个**垂直布局****组**组件：
- en: '![Figure 12.13: A Scroll View example in the Chapter13 scene](img/B18327_12_13.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13：第13章场景中的滚动视图示例](img/B18327_12_13.jpg)'
- en: 'Figure 12.13: A Scroll View example in the Chapter13 scene'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：第13章场景中的滚动视图示例
- en: In the preceding image, you can see that when the `Viewport`, all items are
    visible. When you are setting up your `Scroll View`, I highly recommend that you
    disable the `Viewport` so that you can see the general layout of the items you
    are placing and re-enable it when you are done laying out all the items.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，您可以看到当`视口`启用时，所有项目都是可见的。当您设置`滚动视图`时，我强烈建议您禁用`视口`，以便您可以看到您放置的项目的一般布局，并在完成所有项目的布局后重新启用它。
- en: You should also adjust the Rect Transform area of `Content` to enclose all of
    its child items or use a `Content` does not fully encompass all the items, scrolling
    the `Scroll View` may not show the items outside of its viewable area.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应调整`内容`的`矩形变换`区域，以包含其所有子项，或者使用`内容`不完整地包含所有项目，这样在滚动`滚动视图`时可能不会显示其可视区域外的项目。
- en: '`Scroll View` contains an `Scroll View` (the gray rectangle that encapsulates
    everything), change the `Scroll View`. You can change the appearance of the Scrollbars
    by adjusting the appearance of the `Scrollbar Horizontal` and `Scrollbar Vertical`
    children, as described in the *Implementing UI* *Scrollbar* section.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`滚动视图`包含一个`滚动视图`（包围所有内容的灰色矩形），更改`滚动视图`。您可以通过调整`Scrollbar Horizontal`和`Scrollbar
    Vertical`子对象的显示外观来更改滚动条的显示外观，如*实现UI滚动条*部分所述。'
- en: Now that we understand the intent and setup of a Scroll Rect, let’s look at
    the individual properties of the Scroll Rect component.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了滚动矩形的意图和设置，让我们来看看滚动矩形组件的各个属性。
- en: Scroll Rect component
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动矩形组件
- en: 'The behavior of the `Scroll View` is determined by the Scroll Rect component
    on the Scroll View parent object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`滚动视图`的行为由滚动视图父对象上的`滚动矩形`组件决定：'
- en: '![Figure 12.14: The Scroll Rect component](img/B18327_12_14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14：滚动矩形组件](img/B18327_12_14.jpg)'
- en: 'Figure 12.14: The Scroll Rect component'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：滚动矩形组件
- en: Note that the Scroll Rect component doesn’t have the **Interactable**, **Transition**,
    or **Navigation** properties that all the other UI components in this chapter
    (and previous chapters) have!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，滚动矩形组件没有本章（以及前几章）中所有其他UI组件都有的**交互性**、**过渡**或**导航**属性！
- en: I’ll discuss the properties slightly out of order to make them easier to discuss.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将按顺序讨论属性，以便更容易讨论。
- en: The `Content` by default. The `Viewport` by default.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下是`内容`。默认情况下是`视口`。
- en: If you are creating a scrollable area without using the UI Scroll View, the
    **Viewport** and **Content** properties must be assigned and the Rect Transform
    assigned to **Viewport** must be a parent of the Rect Transform assigned to **Content**,
    for the **Scroll Rect** component to function property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在创建一个不使用UI滚动视图的可滚动区域，则必须分配**视口**和**内容**属性，并且分配给**视口**的矩形变换必须是分配给**内容**的矩形变换的父级，以便**滚动矩形**组件正常工作。
- en: Movement properties
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动属性
- en: There are three properties related to how the `Content` in the `Scroll View`
    will move. The `Scroll View` moves at its boundaries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个属性与`滚动视图`中的`内容`如何移动相关。`滚动视图`在其边界处移动。
- en: There are three `Content`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个`内容`。
- en: When `Content`. The `Content` once the edges of Rect Transform of `Content`
    have been reached. However, when `Content`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当`内容`。一旦达到`内容`矩形变换的边缘。然而，当`内容`。
- en: When `Content` is dragged past its boundary, it will bounce into place once
    the player stops dragging. This will also bounce if the scroll wheel is used.
    When **Elastic** is selected, the subproperty **Elasticity** becomes accessible.
    The **Elasticity** property determines the intensity of the bounce.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当`内容`被拖动超过其边界时，玩家停止拖动后，它将弹回原位。如果使用滚动轮，也会发生弹跳。当选择**弹性**时，子属性**弹性**变为可访问。**弹性**属性决定了弹跳的强度。
- en: When **Clamped** is selected as the **Movement Type**, the Content will not
    be draggable past its boundary and no bounce will occur.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择**固定**作为**移动类型**时，内容将无法拖动超过其边界，并且不会发生弹跳。
- en: Properties concerning scrolling speed
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与滚动速度相关的属性
- en: Selecting the `Content` continue to move after the player has stopped dragging.
    `Content` movement initialized by the Scrollbars or mouse scroll wheel. When `Content`
    will stop moving after the player has ceased dragging. A `0` will stop the `Content`
    the instant the player stops dragging, and a `1` will never stop. By default,
    `0.135`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`内容`后，在玩家停止拖动后继续移动。`内容`的移动由滚动条或鼠标滚轮初始化。当玩家停止拖动后，`内容`将停止移动。一个`0`将在玩家停止拖动时立即停止`内容`，而一个`1`将永远不会停止。默认值为`0.135`。
- en: The **Scroll Sensitivity** property determines how far the Content will move
    with each turn of the scroll wheel. The higher the number, the further the content
    will move with a turn, making it appear to move more quickly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**滚动灵敏度**属性决定了每次滚动轮转动时内容将移动多远。数字越高，内容每次转动移动的距离就越远，看起来移动得越快。'
- en: If you want to disable the use of the mouse scroll wheel for the Scroll View,
    set `0`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想禁用鼠标滚轮在滚动视图中的使用，请设置`0`。
- en: Properties of the Scrollbars
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动条属性
- en: You can set properties for the way your horizontal and vertical scrollbars react
    separately. The `Scrollbar Horizontal` child and `Scrollbar Vertical` child, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为您的水平和垂直滚动条的反应方式分别设置属性。分别是`Scrollbar Horizontal`子项和`Scrollbar Vertical`子项。
- en: If you only want to use drag on the Scroll View area and don’t want scrollbars,
    you can simply set the `None` or delete the `Scrollbar Horizontal` and `Scrollbar
    Vertical` objects from the scene.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想在滚动视图区域使用拖动，而不想使用滚动条，您只需将`None`设置为属性，或者简单地从场景中删除`Scrollbar Horizontal`和`Scrollbar
    Vertical`对象。
- en: Under each Scrollbar assignment, you can set the **Visibility** and **Spacing**
    properties of the respective Scrollbar.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个滚动条分配下，您可以设置相应滚动条的**可见性**和**间距**属性。
- en: 'The **Visibility** property has three options: **Permanent**, **Auto Hide**,
    and **Auto Hide And Expand Viewport**. When **Permanent** is selected for the
    **Visibility** property, the respective Scrollbar will remain visible, even if
    it is not needed, if its corresponding movement is allowed. For example, as shown
    in the following screenshot, if **Horizontal** movement is allowed, and the **Horizontal
    Scrollbar**’s **Visibility** is set to **Permanent**, the respective scrollbar
    will be visible, even though it is not necessary (no horizontal movement can be
    achieved):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**可见性**属性有三个选项：**永久显示**、**自动隐藏**和**自动隐藏并扩展视口**。当为**可见性**属性选择**永久显示**时，相应的滚动条将始终可见，即使不需要，如果允许其相应的移动。例如，如图所示，如果允许**水平**移动，并且将**水平滚动条**的**可见性**设置为**永久显示**，则相应的滚动条将可见，尽管这不是必要的（无法实现水平移动）：'
- en: '![Figure 12.15: Adjusting the Scrollbars in the Scroll Rect](img/B18327_12_15.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15：调整滚动矩形中的滚动条](img/B18327_12_15.jpg)'
- en: 'Figure 12.15: Adjusting the Scrollbars in the Scroll Rect'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：调整滚动矩形中的滚动条
- en: However, referencing the same image, you can see that if **Horizontal** movement
    is deactivated, setting the **Horizontal Scrollbar**’s **Visibility** to **Permanent**
    removes it from the Scroll View entirely. It is also deactivated in the **Hierarchy**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，参考同一图像，你可以看到如果**水平**移动被禁用，将**水平滚动条**的**可见性**设置为**永久显示**，将完全从滚动视图中移除。它也在**层次结构**中禁用。
- en: When **Auto Hide** is selected for the **Visibility** property, the respective
    Scrollbar will become invisible and deactivate in the **Hierarchy** when the game
    is played if it is not needed (meaning that there is no movement in that direction
    required) or if the respective axis movement is disabled.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当为**可见性**属性选择**自动隐藏**时，如果不需要（意味着在该方向上不需要移动）或如果相应的轴移动被禁用，相应的滚动条将在游戏播放时变得不可见并在**层次结构**中禁用。
- en: The `Viewport` object has a **Mask** component, this will cause the mask’s area
    to expand to cover the area that was initially being taken up by the Scrollbar.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewport`对象有一个**遮罩**组件，这将导致遮罩区域扩展以覆盖最初由滚动条占据的区域。'
- en: The `-3`, which means the two Rect Transforms overlap slightly. If you want
    to change the position of the **Viewport**, you have to do so with this property,
    since the properties related to the **Viewport**’s position are disabled in its
    Rect Transform component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`-3`，这意味着两个矩形变换略微重叠。如果你想要改变**Viewport**的位置，你必须使用这个属性，因为与**Viewport**位置相关的属性在其矩形变换组件中被禁用。'
- en: Scroll Rect default event – On Value Changed (Vector2)
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动矩形默认事件 – 值更改（Vector2）
- en: The Scroll Rect component’s default event is the `Content` area of the `Scroll
    View` is moved by dragging, scrolling with the mouse scroll wheel, or scrolling
    with one of the Scrollbars. It accepts a `Vector2` position as an argument and,
    as with the other events discussed in this chapter, you can choose to pass no
    argument, a static argument, or a dynamic argument.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动矩形组件的默认事件是`Scroll View`的`Content`区域通过拖动、使用鼠标滚轮滚动或使用其中一个滚动条进行滚动。它接受一个`Vector2`位置作为参数，并且，就像本章中讨论的其他事件一样，你可以选择传递无参数、静态参数或动态参数。
- en: If you want to send the `Vector2` position of `Content` to a function, you’d
    send it to a function with a `Vector2` parameter from the `1.0` in the corresponding
    coordinate and the last position having a value of `0.0` in the corresponding
    coordinate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将`Content`的`Vector2`位置发送到函数，你需要将其发送到一个具有`Vector2`参数的函数，从相应的坐标中的`1.0`开始，到最后位置在相应坐标中的值为`0.0`。
- en: 'Let’s consider the following function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下函数：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the previous function is selected from the `Vector2` values printed in the
    **Console**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从**控制台**中打印的`Vector2`值中选择前面的功能：
- en: '![Figure 12.16: Values of the Scroll Rect based on position](img/B18327_12_16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16：基于位置的滚动矩形值](img/B18327_12_16.jpg)'
- en: 'Figure 12.16: Values of the Scroll Rect based on position'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：基于位置的滚动矩形值
- en: Now that we’ve looked at the various UI elements, let’s look at some examples
    of implementing them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一些UI元素，让我们看看一些实现它们的示例。
- en: Examples
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: I mentioned earlier in this chapter that a common usage of masks and scroll
    views is a menu with multiple items in it. So, for this chapter, we’ll only create
    one example, a scroll view from a pre-existing menu, by mimicking the layout of
    the Scroll View UI object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章前面提到，遮罩和滚动视图的常见用法是包含多个项目的菜单。因此，在本章中，我们只创建一个示例，即通过模仿滚动视图UI对象的布局，从一个现有的菜单创建一个滚动视图。
- en: Making a scroll view from a pre-existing menu
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有菜单创建滚动视图
- en: To help organize the project, duplicate the `Chapter11-Examples` scene that
    you created in the last chapter; rename it `Chapter12-Examples`. Open `Chapter12-Examples`
    and complete the following example within that scene.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助组织项目，复制你在上一章中创建的`Chapter11-Examples`场景；将其重命名为`Chapter12-Examples`。打开`Chapter12-Examples`并在其中完成以下示例。
- en: 'I want to be able to add more items to my `Inventory Panel` and allow the player
    to scroll through the items. I could create a new UI Scroll View item and update
    it to look like my current `Inventory Panel`, but that would be more hassle than
    it’s worth. So, instead, I will convert the current `Inventory Panel` to a scrollable
    view. After it is complete, it will look like the following figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我想能够向我的`Inventory Panel`添加更多项目，并允许玩家滚动查看这些项目。我可以创建一个新的UI滚动视图项目，并更新它以看起来像当前的`Inventory
    Panel`，但这会比值得的麻烦更多。所以，相反，我将当前的`Inventory Panel`转换为可滚动视图。完成后，它将看起来如下所示：
- en: '![Figure 12.17: The scrollable menu we will build](img/B18327_12_17.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图12.17：我们将构建的可滚动菜单](img/B18327_12_17.jpg)'
- en: 'Figure 12.17: The scrollable menu we will build'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：我们将构建的可滚动菜单
- en: This Panel can have its view adjusted by dragging the area beside the food items.
    I could have added a vertical scrollbar to control the movement, but I wanted
    to show you how simple it is to make a draggable area without one. It also just
    looks a little nicer without a scrollbar.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板可以通过拖动食物项旁边的区域来调整其视图。我本可以添加一个垂直滚动条来控制移动，但我想要展示如何在不使用滚动条的情况下创建可拖动区域。而且，没有滚动条看起来也更美观。
- en: 'To make the `Inventory Panel` scrollable, complete the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`Inventory Panel`可滚动，完成以下步骤：
- en: Right now, the `Pause Panel` is in the way. Let’s disable it by deselecting
    the checkbox in its `Inventory Panel` more easily.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，`Pause Panel`挡在路上了。让我们通过取消选中其`Inventory Panel`中的复选框来更容易地禁用它。
- en: 'For the scrollable view to really work, we need more items in our inventory.
    Select all the children of `Inventory Holder` named `Item Holder` and duplicate
    them with *Ctrl* + *D*. Now, with all the duplicates selected, rename them `Item
    Holder`, so we don’t have the numbered suffix added to each of them. You should
    now have twice as many items in your `Inventory Holder`, and you should see the
    following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使可滚动视图真正工作，我们需要在库存中添加更多项目。选择名为`Item Holder`的`Inventory Holder`的所有子项，并使用*Ctrl*
    + *D*进行复制。现在，所有复制的项目都被选中，将它们重命名为`Item Holder`，这样就不会给每个项目添加编号后缀。现在，你的`Inventory
    Holder`中应该有两倍的项目，你应该看到以下内容：
- en: '![Figure 12.18: The result after Step 2](img/B18327_12_18.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图12.18：第二步后的结果](img/B18327_12_18.jpg)'
- en: 'Figure 12.18: The result after Step 2'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：第二步后的结果
- en: 'To get a scrollable view, we need to add a few more items to the scene that
    can be parents of the content we want to scroll. There is a very specific parent/child
    relationship you want to follow with each item having the specific components
    to create a scrollable view, as demonstrated in the following diagram:![Figure
    12.19: The Hierarchy layout to create a scrollable menu](img/B18327_12_19.jpg)'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获得可滚动的视图，我们需要在场景中添加一些额外的项目，这些项目可以成为我们想要滚动的内容的父项。每个项目都需要特定的组件来创建可滚动的视图，你需要遵循非常具体的父/子关系，如下面的图所示：![图12.19：创建可滚动菜单的层次布局](img/B18327_12_19.jpg)
- en: 'Figure 12.19: The Hierarchy layout to create a scrollable menu'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.19：创建可滚动菜单的层次布局
- en: Let’s start with the object that will hold the `Inventory Panel`, right-click,
    and select `Inventory Panel`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们从将包含`Inventory Panel`的对象开始，右键单击并选择`Inventory Panel`。
- en: Rename the new item `Scroll Rect` and reposition it in the `Inventory Banner`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新项目重命名为`Scroll Rect`，并在`Inventory Banner`中重新定位它。
- en: Give the `Scroll Rect` GameObject the **Scroll Rect** component, with **Add
    Component** | **UI** | **Scroll Rect** in its Inspector.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`Scroll Rect`游戏对象添加`Scroll Rect`组件，在它的检查器中选择**添加组件** | **UI** | **Scroll Rect**。
- en: Now, let’s create the item that will hold the `Scroll Rect` and select `Scroll
    Rect`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个将包含`Scroll Rect`的项目，并选择`Scroll Rect`。
- en: Rename the new Image `Viewport`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的图像重命名为`Viewport`。
- en: '`Inventory Holder` is visually in the way right now, so disable it momentarily.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Inventory Holder`现在在视觉上挡住了，所以暂时禁用它。'
- en: Add the `uiElements_38` image to the `Viewport`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`uiElements_38`图像添加到`Viewport`中。
- en: Adjust the Rect Transform of `Scroll Rect` so that it stretches to fill its
    parent’s Rect Transform.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`滚动矩形`的Rect Transform，使其填充其父级的Rect Transform。
- en: '![Figure 12.20: The Rect Transform of the Scroll Rect object](img/B18327_12_20.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20：滚动矩形对象的Rect Transform](img/B18327_12_20.jpg)'
- en: 'Figure 12.20: The Rect Transform of the Scroll Rect object'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：滚动矩形对象的Rect Transform
- en: 'Adjust the Rect Transform properties of `Viewport`, as follows:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`Viewport`的Rect Transform属性，如下所示：
- en: '![Figure 12.21: The Rect Transform of the Scroll Rect object](img/B18327_12_21.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21：滚动矩形对象的Rect Transform](img/B18327_12_21.jpg)'
- en: 'Figure 12.21: The Rect Transform of the Scroll Rect object'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：滚动矩形对象的Rect Transform
- en: Give `Viewport` the **Mask** component, with **Add Component** | **UI** | **Mask**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`Viewport`添加**遮罩**组件，通过**添加组件** | **UI** | **遮罩**。
- en: Re-enable `Inventory Holder` and rename it `Content`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用`Inventory Holder`并将其重命名为`Content`。
- en: 'Set the alpha of the `Content` to `0` so that the background is invisible.
    You should see the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Content`的透明度设置为`0`，以便背景不可见。你应该看到以下内容：
- en: '![Figure 12.22: The results of Step 11](img/B18327_12_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图12.22：步骤11的结果](img/B18327_12_22.jpg)'
- en: 'Figure 12.22: The results of Step 11'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：步骤11的结果
- en: 'Now, drag `Content` in the `Viewport`. Doing so should make the mask instantly
    apply to all of the children of `Content`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`Content`拖动到`Viewport`中。这样做应该会立即将遮罩应用到`Content`的所有子元素上：
- en: '![Figure 12.23: The results of Step 12](img/B18327_12_23.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图12.23：步骤12的结果](img/B18327_12_23.jpg)'
- en: 'Figure 12.23: The results of Step 12'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：步骤12的结果
- en: 'Position `Content` so that the food at the top of the list appears fully within
    the Mask area:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Content`定位，使列表顶部的食物完全位于遮罩区域内：
- en: '![Figure 12.24: How to position the Content](img/B18327_12_24.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24：如何定位Content](img/B18327_12_24.jpg)'
- en: 'Figure 12.24: How to position the Content'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：如何定位Content
- en: Now, all that is left to do is to have a properly functioning scrollable area
    to set up the properties on the `Scroll Rect` and drag `Content` and `Viewport`
    into their appropriate slots on the `Scroll` `Rect` component.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是设置`滚动矩形`上的属性，并将`Content`和`Viewport`拖到`滚动``矩形`组件的适当槽位中。
- en: 'Disable **Horizontal** movement because we only want the menu to move vertically.
    Set **Movement Type** to **Clamped** so that the menu doesn’t stretch and bounce
    and stays within the appropriate bounds. Your **Scroll Rect** component should
    now look as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**水平**移动，因为我们只想让菜单垂直移动。将**移动类型**设置为**固定**，这样菜单就不会拉伸和弹跳，并保持在适当的范围内。你的**滚动矩形**组件现在应该如下所示：
- en: '![Figure 12.25: Assigning the Content and Viewport](img/B18327_12_25.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25：分配Content和Viewport](img/B18327_12_25.jpg)'
- en: 'Figure 12.25: Assigning the Content and Viewport'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：分配Content和Viewport
- en: Re-enable the `Pause Menu` object so that our `Pause Menu` will function in
    the game.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启用`Pause Menu`对象，以便我们的`Pause Menu`在游戏中能够正常工作。
- en: If you play the game, the `Inventory Panel` should now have items that scroll
    when you drag beside them. Remember that you bring up the `Inventory Panel` by
    pressing the *I* key on your keyboard. As we have drag and drop functionality
    on our individual items, to scroll, we have to drag the area of `Content` that
    does not have a food item on it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩游戏，现在`Inventory Panel`应该有当你拖动它们时可以滚动的物品。记住，你可以通过按键盘上的*I*键打开`Inventory Panel`。由于我们在单个物品上实现了拖放功能，为了滚动，我们必须拖动`Content`上没有食物项的区域。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered how to hide the visibility of UI elements as well as use
    Scroll Views to create containers that hold more items than the screen can hold
    at one time. There are still quite a few more interactable UI elements, however.
    In the next chapter, we will look at the remaining interactive UI elements provided
    by the Unity UI system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何隐藏UI元素的可见性以及使用滚动视图创建容器，这些容器可以容纳比屏幕一次能显示的更多物品。然而，仍然还有相当多的可交互UI元素。在下一章中，我们将探讨Unity
    UI系统提供的剩余交互UI元素。
