<html><head></head><body>
<div id="_idContainer142" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-132"><a id="_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-133" class="calibre5"><a id="_idTextAnchor140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Optimizing the Game Using Unity’s Profiler, Frame Debugger, and Memory Profiler</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Welcome to </span><a href="B22017_09_split_000.xhtml#_idTextAnchor139" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.4.1">Chapter 9</span></em></span></a><span class="kobospan" id="kobo.5.1"> of your Unity game development journey, where we will explore optimizing game performance using Unity’s Profiler, Frame Debugger, and Memory Profiler. </span><span class="kobospan" id="kobo.5.2">In this chapter, we will learn how to identify and address performance bottlenecks, optimize rendering, and manage memory efficiently. </span><span class="kobospan" id="kobo.5.3">We’ll cover Unity’s profiling tools, dive into performance optimization techniques such as physics, audio, AI, and scripting optimizations, and delve into memory management and optimization, including Memory Profiler usage and asset importing optimizations. </span><span class="kobospan" id="kobo.5.4">Mastering these skills will ensure smooth gameplay and an immersive </span><span><span class="kobospan" id="kobo.6.1">player experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we’re going to cover the following </span><span><span class="kobospan" id="kobo.8.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Introducing Unity </span><span><span class="kobospan" id="kobo.10.1">profiling tools</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Performance </span><span><span class="kobospan" id="kobo.12.1">optimization techniques</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.13.1">Memory management </span><span><span class="kobospan" id="kobo.14.1">and optimization</span></span></li>
</ul>
<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.16.1">You will need to install the following to follow along with me in </span><span><span class="kobospan" id="kobo.17.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.18.1">Primary IDE – Visual Studio 2022</span></strong><span class="kobospan" id="kobo.19.1">: The tutorials and code samples have been crafted using Visual Studio 2022. </span><span class="kobospan" id="kobo.19.2">Ensure it’s installed so that you can follow along seamlessly. </span><span class="kobospan" id="kobo.19.3">Feel free to explore Rider or other IDEs if you prefer, though the instructions are tailored for </span><span><span class="kobospan" id="kobo.20.1">Visual Studio.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.21.1">Unity version 2022.3.13</span></strong><span class="kobospan" id="kobo.22.1">: Download and install Unity, choosing version 2022.3.13 for optimal compatibility with the </span><span><span class="kobospan" id="kobo.23.1">provided content.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">The code files of this chapter can be found </span><span><span class="kobospan" id="kobo.25.1">at: </span></span><a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.26.1">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2009</span></span></a><span><span class="kobospan" id="kobo.27.1">.</span></span></p>
<h1 id="_idParaDest-135" class="calibre5"><a id="_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.28.1">Introducing Unity profiling tools</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">Welcome </span><a id="_idIndexMarker549" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.30.1">to Unity’s profiling tools! </span><span class="kobospan" id="kobo.30.2">These tools are essential for understanding and improving the performance of our games. </span><span class="kobospan" id="kobo.30.3">They provide valuable insights into how our games are running and help us optimize them for a smoother experience across different devices </span><span><span class="kobospan" id="kobo.31.1">and platforms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">So, why do we need to utilize profiling tools? </span><span class="kobospan" id="kobo.32.2">Profiling tools are invaluable assets in the quest for optimization, which is the process of fine-tuning our games to run as efficiently as possible. </span><span class="kobospan" id="kobo.32.3">These tools act as our detective companions in the world of game development, helping us investigate and identify areas where our game might be slowing down or using too much memory. </span><span class="kobospan" id="kobo.32.4">By using these tools, we can make targeted improvements to our game’s performance, ensuring that players have a seamless and enjoyable </span><span><span class="kobospan" id="kobo.33.1">gaming experience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">So, what does optimization mean in game development? </span><span class="kobospan" id="kobo.34.2">Optimization is the process of making our games run as efficiently as possible, involving finding ways to reduce unnecessary computations, minimize memory usage, and improve rendering performance. </span><span class="kobospan" id="kobo.34.3">Just like a well-organized city ensures smooth traffic flow and efficient resource management, optimization ensures that our game’s code and graphics work together harmoniously to deliver a captivating experience to players. </span><span class="kobospan" id="kobo.34.4">This optimization is crucial because it directly impacts the player’s experience. </span><span class="kobospan" id="kobo.34.5">No one wants to play a game that lags, stutters, or crashes unexpectedly. </span><span class="kobospan" id="kobo.34.6">By optimizing our games, we can ensure that they run smoothly on a variety of hardware configurations, providing players with a consistent and enjoyable gaming experience across </span><span><span class="kobospan" id="kobo.35.1">different platforms.</span></span></p>
<h2 id="_idParaDest-136" class="calibre7"><a id="_idTextAnchor143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.36.1">Exploring Unity’s profiling tools in depth</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.37.1">Unity’s profiling tools</span><a id="_idIndexMarker550" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.38.1"> offer a comprehensive suite of features to help us understand and improve our game’s performance. </span><span class="kobospan" id="kobo.38.2">The Profiler allows us to analyze CPU and GPU usage in real time, giving us valuable insights into where optimizations are needed. </span><span class="kobospan" id="kobo.38.3">The Frame Debugger, on the other hand, helps us visualize how our game’s graphics </span><span><span class="kobospan" id="kobo.39.1">are rendered.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">In the upcoming sections, we’ll take a closer look at each of these profiling tools and learn how to use them effectively to optimize our games. </span><span class="kobospan" id="kobo.40.2">So, let’s get ready to dive into the world of </span><span><span class="kobospan" id="kobo.41.1">Unity profiling!</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.42.1">The Profiler</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.43.1">The Profiler in</span><a id="_idIndexMarker551" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.44.1"> Unity is like a helpful detective for your </span><a id="_idIndexMarker552" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">game. </span><span class="kobospan" id="kobo.45.2">It checks how the game is doing – for example, how much the computer is thinking (CPU), how the graphics are doing (GPU), and how much memory is used. </span><span class="kobospan" id="kobo.45.3">It’s like a tool to catch issues and make your game </span><span><span class="kobospan" id="kobo.46.1">work better.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">To open the Profiler, go to </span><strong class="bold"><span class="kobospan" id="kobo.48.1">Window</span></strong><span class="kobospan" id="kobo.49.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.50.1">Analysis</span></strong><span class="kobospan" id="kobo.51.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.52.1">Profiler</span></strong><span class="kobospan" id="kobo.53.1">. </span><span class="kobospan" id="kobo.53.2">A new window will appear, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.54.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.55.1">.1</span></em></span><span><span class="kobospan" id="kobo.56.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer113">
<span class="kobospan" id="kobo.57.1"><img alt="Figure 9.1 – The Profiler" src="image/B22017_09_01.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.58.1">Figure 9.1 – The Profiler</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.59.1">Now that we’ve opened the Profiler, let’s dive into how </span><span><span class="kobospan" id="kobo.60.1">it works.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.61.1">Understanding the functionality of Unity’s Profiler</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.62.1">The Profiler in </span><a id="_idIndexMarker553" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.63.1">Unity works by continuously monitoring different aspects of your game’s performance while it’s running. </span><span class="kobospan" id="kobo.63.2">It collects data on CPU usage, GPU usage, memory allocation, rendering performance, and more, allowing us to gain insights into how our game is utilizing </span><span><span class="kobospan" id="kobo.64.1">system resources.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">When you open the Profiler in Unity, it displays a variety of graphs and charts that visualize this data in real time. </span><span class="kobospan" id="kobo.65.2">These graphs show metrics such as CPU usage over time, memory usage by different components of the game, and the time it takes to render </span><span><span class="kobospan" id="kobo.66.1">each frame.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">The Profiler gathers this data by instrumenting your game code with profiling markers. </span><span class="kobospan" id="kobo.67.2">These markers track the time it takes for specific functions and operations to execute, allowing us to identify performance bottlenecks and areas </span><span><span class="kobospan" id="kobo.68.1">for optimization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">For example, if the Profiler shows a spike in CPU usage during gameplay, we can use the Profiler’s </span><strong class="bold"><span class="kobospan" id="kobo.70.1">Call Stacks</span></strong><span class="kobospan" id="kobo.71.1"> view to pinpoint which functions are consuming the most CPU time. </span><span class="kobospan" id="kobo.71.2">It can then analyze the code within those functions to identify inefficiencies or areas </span><span><span class="kobospan" id="kobo.72.1">for optimization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">Similarly, if the Profiler detects excessive memory usage, we can use the memory allocation view to identify where memory is being allocated and deallocated in the code. </span><span class="kobospan" id="kobo.73.2">This can help identify memory leaks or inefficient memory usage patterns that may be </span><span><span class="kobospan" id="kobo.74.1">impacting performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.75.1">Overall, the Profiler in Unity provides us with valuable insights into our game’s performance, allowing us to identify and address issues that could impact the player experience. </span><span class="kobospan" id="kobo.75.2">By using the Profiler effectively, we can optimize our games to run smoothly and efficiently on a variety of platforms </span><span><span class="kobospan" id="kobo.76.1">and devices.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.77.1">In Unity, optimizing the performance of your game is crucial for delivering a smooth and immersive player experience. </span><span class="kobospan" id="kobo.77.2">The Unity Profiler is a powerful tool that offers insights into various aspects of your game’s performance through its diverse modules, each focusing on different areas </span><span><span class="kobospan" id="kobo.78.1">of analysis.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.79.1">The main modules of the Unity Profiler are </span><span><span class="kobospan" id="kobo.80.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.81.1">CPU Profiler</span></strong><span class="kobospan" id="kobo.82.1">: This</span><a id="_idIndexMarker554" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.83.1"> module monitors the CPU usage of your </span><a id="_idIndexMarker555" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.84.1">game during runtime. </span><span class="kobospan" id="kobo.84.2">It helps identify performance bottlenecks related to scripting, physics calculations, rendering, and other </span><span><span class="kobospan" id="kobo.85.1">CPU-intensive tasks.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.86.1">GPU Profiler</span></strong><span class="kobospan" id="kobo.87.1">: The</span><a id="_idIndexMarker556" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.88.1"> GPU Profiler focuses on monitoring</span><a id="_idIndexMarker557" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.89.1"> the GPU usage of your game. </span><span class="kobospan" id="kobo.89.2">It provides information about rendering performance, including the time spent on drawing calls, shaders, and </span><span><span class="kobospan" id="kobo.90.1">graphics-related computations.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.91.1">Memory Profiler</span></strong><span class="kobospan" id="kobo.92.1">: This</span><a id="_idIndexMarker558" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.93.1"> module tracks memory usage </span><a id="_idIndexMarker559" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.94.1">in your game, including allocations, deallocations, and memory leaks. </span><span class="kobospan" id="kobo.94.2">It helps identify areas where memory is being used inefficiently or where resources are not </span><span><span class="kobospan" id="kobo.95.1">managed properly.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.96.1">Audio Profiler</span></strong><span class="kobospan" id="kobo.97.1">: The </span><a id="_idIndexMarker560" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.98.1">Audio Profiler monitors the performance</span><a id="_idIndexMarker561" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.99.1"> of audio-related operations in your game, such as playing audio clips, mixing audio channels, and processing audio effects. </span><span class="kobospan" id="kobo.99.2">It helps optimize audio performance and troubleshoot any issues related to </span><span><span class="kobospan" id="kobo.100.1">audio playback.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.101.1">Physics Profiler</span></strong><span class="kobospan" id="kobo.102.1">: This </span><a id="_idIndexMarker562" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1">module focuses on analyzing</span><a id="_idIndexMarker563" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.104.1"> the performance of physics calculations in your game. </span><span class="kobospan" id="kobo.104.2">It provides insights into the time spent on physics simulations, collisions, rigid body dynamics, and other </span><span><span class="kobospan" id="kobo.105.1">physics-related computations.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.106.1">UI Profiler</span></strong><span class="kobospan" id="kobo.107.1">: The </span><a id="_idIndexMarker564" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.108.1">UI Profiler is specifically designed to analyze</span><a id="_idIndexMarker565" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.109.1"> the performance of </span><strong class="bold"><span class="kobospan" id="kobo.110.1">user interface</span></strong><span class="kobospan" id="kobo.111.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.112.1">UI</span></strong><span class="kobospan" id="kobo.113.1">) elements in your game. </span><span class="kobospan" id="kobo.113.2">It helps identify UI-related bottlenecks, such as layout calculations, rendering overhead, and </span><span><span class="kobospan" id="kobo.114.1">event handling.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.115.1">Network Profiler</span></strong><span class="kobospan" id="kobo.116.1">: The</span><a id="_idIndexMarker566" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.117.1"> Network Profiler monitors </span><a id="_idIndexMarker567" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.118.1">network activity in your game, including data transmission, latency, and network-related events. </span><span class="kobospan" id="kobo.118.2">It helps optimize network performance and troubleshoot issues related to multiplayer networking or </span><span><span class="kobospan" id="kobo.119.1">online gameplay.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.120.1">Rendering Profiler</span></strong><span class="kobospan" id="kobo.121.1">: This</span><a id="_idIndexMarker568" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.122.1"> module focuses on analyzing </span><a id="_idIndexMarker569" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.123.1">rendering performance in your game. </span><span class="kobospan" id="kobo.123.2">It provides insights into rendering overhead, draw calls, batching, and other </span><span><span class="kobospan" id="kobo.124.1">graphics-related optimizations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.125.1">Collectively, these modules provide a comprehensive view of your game’s performance, allowing you to identify and address performance issues effectively. </span><span class="kobospan" id="kobo.125.2">By using the Unity Profiler’s various modules, we can optimize our games for better performance, smoother gameplay, and enhanced </span><span><span class="kobospan" id="kobo.126.1">player experiences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.127.1">In this chapter, we will focus on the CPU Profiler and learn how to use it to identify performance related to </span><span><span class="kobospan" id="kobo.128.1">the CPU.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.129.1">The CPU Profiler module</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.130.1">The </span><a id="_idIndexMarker570" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.131.1">CPU Profiler module</span><a id="_idIndexMarker571" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.132.1"> is an essential tool in Unity for analyzing the performance of your game. </span><span class="kobospan" id="kobo.132.2">It provides a detailed breakdown of where your game spends its time during runtime, including areas such as rendering, scripting, and animation. </span><span class="kobospan" id="kobo.132.3">This section delves into various aspects of the CPU Profiler module, covering chart categories, the module details pane, live settings, </span><span><span class="kobospan" id="kobo.133.1">and more.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.134.1">Chart categories</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.135.1">The </span><strong class="bold"><span class="kobospan" id="kobo.136.1">CPU Usage</span></strong><span class="kobospan" id="kobo.137.1"> Profiler module’s chart categorizes the time spent on the game’s main thread into nine</span><a id="_idIndexMarker572" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.138.1"> categories. </span><span class="kobospan" id="kobo.138.2">These categories are </span><strong class="bold"><span class="kobospan" id="kobo.139.1">Rendering</span></strong><span class="kobospan" id="kobo.140.1">, </span><strong class="bold"><span class="kobospan" id="kobo.141.1">Scripts</span></strong><span class="kobospan" id="kobo.142.1">, </span><strong class="bold"><span class="kobospan" id="kobo.143.1">Physics</span></strong><span class="kobospan" id="kobo.144.1">, </span><strong class="bold"><span class="kobospan" id="kobo.145.1">Animation</span></strong><span class="kobospan" id="kobo.146.1">, </span><strong class="bold"><span class="kobospan" id="kobo.147.1">GarbageCollector</span></strong><span class="kobospan" id="kobo.148.1">, </span><strong class="bold"><span class="kobospan" id="kobo.149.1">VSync</span></strong><span class="kobospan" id="kobo.150.1">, </span><strong class="bold"><span class="kobospan" id="kobo.151.1">Global Illumination</span></strong><span class="kobospan" id="kobo.152.1">, </span><strong class="bold"><span class="kobospan" id="kobo.153.1">UI</span></strong><span class="kobospan" id="kobo.154.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.155.1">Others</span></strong><span class="kobospan" id="kobo.156.1">. </span><span class="kobospan" id="kobo.156.2">By understanding the distribution of time across these categories, we can pinpoint areas of improvement and optimize our game’s </span><span><span class="kobospan" id="kobo.157.1">performance accordingly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.158.1">By understanding each part and its role or impact, we can easily pinpoint the problem areas in scripts or animations. </span><span class="kobospan" id="kobo.158.2">This allows us to focus our work on addressing these specific issues. </span><span class="kobospan" id="kobo.158.3">You can refer to </span><span><em class="italic"><span class="kobospan" id="kobo.159.1">Figure 9</span></em></span><em class="italic"><span class="kobospan" id="kobo.160.1">.2</span></em><span class="kobospan" id="kobo.161.1"> for the charts and their </span><span><span class="kobospan" id="kobo.162.1">defined colors:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer114">
<span class="kobospan" id="kobo.163.1"><img alt="Figure 9.2 – CPU module" src="image/B22017_09_02.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.164.1">Figure 9.2 – CPU module</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.165.1">In the</span><a id="_idIndexMarker573" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.166.1"> following table, I have listed each category, along with common activities that may occur within it, indicating the time spent or the impact </span><span><span class="kobospan" id="kobo.167.1">on performance:</span></span></p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.168.1">Category</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.169.1">Activities Performed in </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.170.1">Real Time</span></strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.171.1">Rendering</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.172.1">Processing data for the GPU and waiting for GPU operations. </span><span class="kobospan" id="kobo.172.2">It includes tasks such as rendering meshes, handling shaders, managing textures, and other </span><span><span class="kobospan" id="kobo.173.1">graphics-related computations.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.174.1">Scripts</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.175.1">MonoBehaviour</span></strong><span class="kobospan" id="kobo.176.1"> update methods and coroutine executions. </span><span class="kobospan" id="kobo.176.2">It involves executing script code, handling game logic, and managing interactions between </span><span><span class="kobospan" id="kobo.177.1">game objects.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.178.1">Physics</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.179.1">Executing physics simulations and related processes. </span><span class="kobospan" id="kobo.179.2">including collision detection, rigid body interactions, joint handling, and other </span><span><span class="kobospan" id="kobo.180.1">physics-related calculations.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.181.1">Animation</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.182.1">Animation system processing and performance considerations, including processing keyframes, blend trees, animation state transitions, and other </span><span><span class="kobospan" id="kobo.183.1">animation-related tasks.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.184.1">GarbageCollector</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.185.1">Garbage collection and memory allocation activities, which include memory allocation, deallocating unused memory, managing object life cycles, and optimizing </span><span><span class="kobospan" id="kobo.186.1">memory usage.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.187.1">VSync</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.188.1">Waiting for vertical synchronization activities. </span><span class="kobospan" id="kobo.188.2">This includes syncing the frame rate of the game with the refresh rate of the display, ensuring smooth and </span><span><span class="kobospan" id="kobo.189.1">tear-free rendering.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.190.1">Global Illumination</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.191.1">Global illumination includes calculations related to lighting in scenes, such as lightmap baking, real-time GI computations, light probes, and </span><span><span class="kobospan" id="kobo.192.1">reflection probes.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.193.1">UI</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.194.1">UI activities involve rendering and interactive elements, such as canvases, text elements, buttons, panels, and other </span><span><span class="kobospan" id="kobo.195.1">UI components.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.196.1">Others</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.197.1">These are additional CPU activities that are not part of the other categories. </span><span class="kobospan" id="kobo.197.2">This can include various engine tasks, editor-related activities, audio processing, networking tasks, and other miscellaneous computations that occur during runtime but don’t fit into the </span><span><span class="kobospan" id="kobo.198.1">defined categories.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">Understanding </span><a id="_idIndexMarker574" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.200.1">the activities within each category allows us to target specific areas based on our optimization requirements for </span><span><span class="kobospan" id="kobo.201.1">the project.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.202.1">Module details pane</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">You</span><a id="_idIndexMarker575" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.204.1"> have the option to display the selected frame in three different views, allowing you to discern how to switch between them, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.205.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.206.1">.3</span></em></span><span><span class="kobospan" id="kobo.207.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer115">
<span class="kobospan" id="kobo.208.1"><img alt="Figure 9.3 – Views dropdown" src="image/B22017_09_03.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.209.1">Figure 9.3 – Views dropdown</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.210.1">Let’s understand how these </span><span><span class="kobospan" id="kobo.211.1">views work:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.212.1">Timeline</span></strong><span class="kobospan" id="kobo.213.1">: This view provides an overview of time distribution across different threads on a single time axis, aiding visualization of </span><span><span class="kobospan" id="kobo.214.1">parallel execution</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.215.1">Hierarchy</span></strong><span class="kobospan" id="kobo.216.1">: This view groups timing data by internal hierarchical structure, offering detailed insights into function calls and </span><span><span class="kobospan" id="kobo.217.1">memory allocations</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.218.1">Raw Hierarchy</span></strong><span class="kobospan" id="kobo.219.1">: This is similar to the </span><strong class="bold"><span class="kobospan" id="kobo.220.1">Hierarchy</span></strong><span class="kobospan" id="kobo.221.1"> view but provides additional details about performance warnings and </span><span><span class="kobospan" id="kobo.222.1">thread groupings</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.223.1">Now that we’re aware of the available views in the Profiler, we can switch between them to gain a better understanding of how the </span><span><span class="kobospan" id="kobo.224.1">frame operates.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.225.1">Using Live settings while profiling</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.226.1">The “Live” setting in the Unity CPU Profiler provides a dynamic and immediate view of performance metrics as we interact with our game, enabling efficient on-the-fly analysis </span><span><span class="kobospan" id="kobo.227.1">and optimization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.228.1">Let’s enable Live settings</span><a id="_idIndexMarker576" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.229.1"> and see how </span><span><span class="kobospan" id="kobo.230.1">it works:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.231.1">Enable the Live setting in the CPU Profiler module before you </span><span><span class="kobospan" id="kobo.232.1">start recording.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.233.1">As we interact with our game and trigger different events, the Profiler immediately displays real-time information about the current frame in the </span><span><span class="kobospan" id="kobo.234.1">details pane.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.235.1">We can see how each action affects CPU usage, memory allocation, and other performance </span><span><span class="kobospan" id="kobo.236.1">metrics instantly.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.237.1">This real-time feedback allows us to identify performance bottlenecks quickly, make adjustments on the fly, and see the impact of </span><span><span class="kobospan" id="kobo.238.1">optimizations immediately.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.239.1">We can also enable the </span><strong class="bold"><span class="kobospan" id="kobo.240.1">Show Full Scripting Method Names</span></strong><span class="kobospan" id="kobo.241.1"> option to display the full method names. </span><span class="kobospan" id="kobo.241.2">This can be particularly useful when you’re dealing with complex scripts or when you need precise visibility into the functions being executed. </span><span class="kobospan" id="kobo.241.3">You can enable this option through the settings, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.242.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.243.1">.4</span></em></span><span><span class="kobospan" id="kobo.244.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer116">
<span class="kobospan" id="kobo.245.1"><img alt="Figure 9.4 – Show Full Scripting Method Names" src="image/B22017_09_04.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.246.1">Figure 9.4 – Show Full Scripting Method Names</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.247.1">Before diving into the practical part, it’s essential to understand common </span><span><span class="kobospan" id="kobo.248.1">Profiler markers.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.249.1">Common markers</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">Unity’s code</span><a id="_idIndexMarker577" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.251.1"> is instrumented with various Profiler markers, offering insights into performance-critical tasks and areas of optimization. </span><span class="kobospan" id="kobo.251.2">By leveraging these markers, we can identify bottlenecks and streamline performance-critical operations, enhancing the overall efficiency and responsiveness of </span><span><span class="kobospan" id="kobo.252.1">our games.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.253.1">Unity’s code is marked with numerous Profiler indicators that offer insights into the performance of your game. </span><span class="kobospan" id="kobo.253.2">These markers are invaluable for identifying bottlenecks and optimizing your code. </span><span class="kobospan" id="kobo.253.3">Let’s delve into the main categories of Profiler markers and </span><span><span class="kobospan" id="kobo.254.1">their functions:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.255.1">Main thread </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.256.1">base markers</span></strong></span><span><span class="kobospan" id="kobo.257.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.258.1">The </span><a id="_idIndexMarker578" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1">main thread base markers serve to differentiate between time spent on your game and time devoted to Editor and Profiler tasks. </span><span class="kobospan" id="kobo.259.2">These markers are crucial for understanding the timing of frames on the main thread. </span><span class="kobospan" id="kobo.259.3">Here are </span><span><span class="kobospan" id="kobo.260.1">some examples:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">PlayerLoop</span></strong><span class="kobospan" id="kobo.262.1">: Contains samples originating from your game’s main loop. </span><span class="kobospan" id="kobo.262.2">When targeting the Editor while the Player is active, </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">PlayerLoop</span></strong><span class="kobospan" id="kobo.264.1"> samples the nest </span><span><span class="kobospan" id="kobo.265.1">under </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.266.1">EditorLoop</span></strong></span><span><span class="kobospan" id="kobo.267.1">.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.268.1">EditorLoop</span></strong><span class="kobospan" id="kobo.269.1"> (Editor-only marker): Contains samples from the Editor’s main loop when profiling a player in the Editor. </span><strong class="source-inline1"><span class="kobospan" id="kobo.270.1">EditorLoop</span></strong><span class="kobospan" id="kobo.271.1"> samples indicate time spent rendering and running the Editor alongside </span><span><span class="kobospan" id="kobo.272.1">the Player.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">Profiler.CollectEditorStats</span></strong><span class="kobospan" id="kobo.274.1"> (Editor-only marker): Includes samples related to collecting statistics for active Profiler modules. </span><span class="kobospan" id="kobo.274.2">These samples provide insight into the overhead that’s incurred by the Player when collecting </span><span><span class="kobospan" id="kobo.275.1">module statistics.</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.276.1">Editor-only markers</span></strong></span><span><span class="kobospan" id="kobo.277.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.278.1">Certain </span><a id="_idIndexMarker579" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.279.1">markers exclusively appear when profiling in Unity Editor, offering insights into Editor-specific activities such as security checks and Prefab-related tasks. </span><span class="kobospan" id="kobo.279.2">Here is </span><span><span class="kobospan" id="kobo.280.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.281.1">GetComponentNullErrorWrapper</span></strong><span class="kobospan" id="kobo.282.1">: A marker exclusive to the Unity Editor, aiding in identifying null </span><span><span class="kobospan" id="kobo.283.1">component usage</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.284.1">Script </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.285.1">update markers</span></strong></span><span><span class="kobospan" id="kobo.286.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.287.1">Unless you’re utilizing the Job System, most scripting code falls under these markers. </span><span class="kobospan" id="kobo.287.2">They </span><a id="_idIndexMarker580" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.288.1">cover various </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">MonoBehaviour</span></strong><span class="kobospan" id="kobo.290.1"> update methods and coroutine executions. </span><span class="kobospan" id="kobo.290.2">Here is </span><span><span class="kobospan" id="kobo.291.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.292.1">BehaviourUpdate</span></strong><span class="kobospan" id="kobo.293.1">: Contains all samples of </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">MonoBehaviour.Update</span></strong></span><span><span class="kobospan" id="kobo.295.1"> methods</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.296.1">Rendering and </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.297.1">VSync markers</span></strong></span><span><span class="kobospan" id="kobo.298.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.299.1">These</span><a id="_idIndexMarker581" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.300.1"> markers reveal CPU activities related to processing data for the GPU and waiting for GPU operations to complete. </span><span class="kobospan" id="kobo.300.2">Here is </span><span><span class="kobospan" id="kobo.301.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">WaitForTargetFPS</span></strong><span class="kobospan" id="kobo.303.1">: Indicates the time spent waiting for the targeted FPS specified </span><span><span class="kobospan" id="kobo.304.1">by </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.305.1">Application.targetFrameRate</span></strong></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.306.1">Backend </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.307.1">scripting markers</span></strong></span><span><span class="kobospan" id="kobo.308.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.309.1">These</span><a id="_idIndexMarker582" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.310.1"> markers highlight scripting backend activities, aiding in troubleshooting issues related to garbage collection and memory allocation. </span><span class="kobospan" id="kobo.310.2">Here is </span><span><span class="kobospan" id="kobo.311.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">GC.Alloc</span></strong><span class="kobospan" id="kobo.313.1">: Represents an allocation in the managed heap, subject to automatic </span><span><span class="kobospan" id="kobo.314.1">garbage collection</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.315.1">Multithreading markers</span></strong></span><span><span class="kobospan" id="kobo.316.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.317.1">These </span><a id="_idIndexMarker583" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.318.1">markers focus on thread synchronization and the Job System, offering information about parallel processing and sync points. </span><span class="kobospan" id="kobo.318.2">Here is </span><span><span class="kobospan" id="kobo.319.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.320.1">Idle</span></strong><span class="kobospan" id="kobo.321.1">: Contains samples indicating the length of time a Worker Thread </span><span><span class="kobospan" id="kobo.322.1">remains inactive</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.323.1">Physics markers</span></strong></span><span><span class="kobospan" id="kobo.324.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.325.1">Physics markers </span><a id="_idIndexMarker584" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.326.1">provide insights into the execution of physics simulations and related processes such as collision detection and joint handling. </span><span class="kobospan" id="kobo.326.2">Here is </span><span><span class="kobospan" id="kobo.327.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.328.1">Physics.FetchResults</span></strong><span class="kobospan" id="kobo.329.1">: Contains samples that collect the results of the physics simulation from the </span><span><span class="kobospan" id="kobo.330.1">physics engine</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.331.1">Animation markers</span></strong></span><span><span class="kobospan" id="kobo.332.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.333.1">These</span><a id="_idIndexMarker585" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.334.1"> markers pertain to the Animation system, offering details on animation processing stages and performance considerations. </span><span class="kobospan" id="kobo.334.2">Here is </span><span><span class="kobospan" id="kobo.335.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">Director.PrepareFrame</span></strong><span class="kobospan" id="kobo.337.1">: Schedules and awaits </span><strong class="source-inline1"><span class="kobospan" id="kobo.338.1">Director.PrepareFrameJob</span></strong><span class="kobospan" id="kobo.339.1"> jobs, evaluating the state machines for active </span><span><span class="kobospan" id="kobo.340.1">Animator components</span></span></li></ul></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.341.1">Performance warnings</span></strong></span><span><span class="kobospan" id="kobo.342.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.343.1">The CPU Profiler</span><a id="_idIndexMarker586" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.344.1"> identifies common performance issues and displays warnings to alert developers, helping them optimize their code effectively. </span><span class="kobospan" id="kobo.344.2">Here is </span><span><span class="kobospan" id="kobo.345.1">an example:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">Animation.DestroyAnimationClip</span></strong><span class="kobospan" id="kobo.347.1">: Indicates a performance issue with calls related to destroying </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">AnimationClips</span></strong><span class="kobospan" id="kobo.349.1">, triggering </span><span><span class="kobospan" id="kobo.350.1">resource-intensive operations</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.351.1">With a thorough understanding of these Profiler markers, we can pinpoint performance bottlenecks and optimize our Unity games for enhanced efficiency </span><span><span class="kobospan" id="kobo.352.1">and responsiveness.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.353.1">You can learn more about common markers in the official Unity </span><span><span class="kobospan" id="kobo.354.1">documentation: </span></span><a href="https://docs.unity3d.com/Manual/profiler-markers.html" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.355.1">https://docs.unity3d.com/Manual/profiler-markers.html</span></span></a><span><span class="kobospan" id="kobo.356.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.357.1">By becoming familiar with the common markers, we’ve seen that they prove to be invaluable tools in our optimization journey. </span><span class="kobospan" id="kobo.357.2">They allow us to concentrate on specific areas efficiently, ensuring that our efforts are both effective </span><span><span class="kobospan" id="kobo.358.1">and precise.</span></span></p>
<h2 id="_idParaDest-137" class="calibre7"><a id="_idTextAnchor144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.359.1">Understanding the profiling process</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.360.1">Let’s discuss</span><a id="_idIndexMarker587" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.361.1"> general tips for the profiling process, including how to identify bottlenecks and gain a better understanding of the </span><span><span class="kobospan" id="kobo.362.1">entire process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Profiling is most effective when it’s used at three </span><span><span class="kobospan" id="kobo.364.1">specific times:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.365.1">Establish a baseline by profiling before implementing </span><span><span class="kobospan" id="kobo.366.1">major changes</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.367.1">Track changes during development and ensure they do not negatively impact performance or exceed </span><span><span class="kobospan" id="kobo.368.1">resource budgets</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.369.1">After development, profile again to confirm that the changes that have been made have achieved the desired improvements </span><span><span class="kobospan" id="kobo.370.1">in performance</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.371.1">Avoid profiling until you identify issues in your game. </span><span class="kobospan" id="kobo.371.2">Additionally, refrain from excessive profiling; determine the required frame rate for your game. </span><span class="kobospan" id="kobo.371.3">Each frame should adhere to a time budget aligned with your target </span><strong class="bold"><span class="kobospan" id="kobo.372.1">frames per second</span></strong><span class="kobospan" id="kobo.373.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.374.1">FPS</span></strong><span class="kobospan" id="kobo.375.1">). </span><span class="kobospan" id="kobo.375.2">For instance, a game aiming for 30 FPS should consume less than 33.33 ms per frame (1,000 ms divided by 30 FPS). </span><span class="kobospan" id="kobo.375.3">Similarly, targeting 60 FPS allows for 16.66 ms </span><span><span class="kobospan" id="kobo.376.1">per frame.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.377.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.378.1">Achieving the most precise profiling outcomes necessitates running and profiling builds directly on the intended target devices.Top </span><span><span class="kobospan" id="kobo.379.1">of Form</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.380.1">Identifying bottlenecks</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.381.1">You </span><a id="_idIndexMarker588" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.382.1">should determine whether your game is CPU- or GPU-bound so that you can focus your optimization efforts correctly. </span><span class="kobospan" id="kobo.382.2">For instance, note that </span><a id="_idIndexMarker589" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.383.1">while VSync is optional on all platforms, it’s typically enabled on mobile devices and may contribute to CPU </span><span><span class="kobospan" id="kobo.384.1">time waiting.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.385.1">VSync</span></strong><span class="kobospan" id="kobo.386.1">, short for </span><strong class="bold"><span class="kobospan" id="kobo.387.1">Vertical Synchronization</span></strong><span class="kobospan" id="kobo.388.1">, is a graphics technology that synchronizes</span><a id="_idIndexMarker590" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.389.1"> the frame rate of a game with the refresh rate of the monitor or display device. </span><span class="kobospan" id="kobo.389.2">This synchronization prevents issues such as screen tearing, where parts of different frames appear on the screen simultaneously, leading to a visually jarring experience. </span><span class="kobospan" id="kobo.389.3">VSync ensures that each frame is displayed in full before the next frame is rendered, creating a smoother and more visually pleasing experience for </span><span><span class="kobospan" id="kobo.390.1">the player.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.391.1">The </span><a id="_idIndexMarker591" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.392.1">performance</span><a id="_idIndexMarker592" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.393.1"> of a project is determined by the chip or thread that requires the most time to process. </span><span class="kobospan" id="kobo.393.2">This area is where optimization efforts should be concentrated. </span><span class="kobospan" id="kobo.393.3">For instance, consider a game with a target frame time budget of 16.66 ms with </span><span><span class="kobospan" id="kobo.394.1">VSync enabled:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.395.1">If the CPU frame time (excluding VSync) is 10 ms and the GPU time is 12 ms, there’s no issue as both are </span><span><span class="kobospan" id="kobo.396.1">within budget.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.397.1">If the CPU frame time is 20 ms and the GPU time is 12 ms, the CPU performance needs to be optimized as the GPU won’t benefit from optimization. </span><span class="kobospan" id="kobo.397.2">Consider transferring some CPU tasks to </span><span><span class="kobospan" id="kobo.398.1">the GPU.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.399.1">If the CPU frame time is 8 ms and the GPU time is 20 ms, focus on optimizing the GPU workload as it </span><span><span class="kobospan" id="kobo.400.1">is GPU-bound.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.401.1">If both the CPU and GPU times are at 20 ms, you’re bound by both and need to optimize them below 16.66 ms to achieve a frame rate of </span><span><span class="kobospan" id="kobo.402.1">60 FPS.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.403.1">We’ll learn more about CPU- and GPU-bound issues in the </span><span><span class="kobospan" id="kobo.404.1">following subsections.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.405.1">CPU-bound issues</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.406.1">It’s considered</span><a id="_idIndexMarker593" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.407.1"> a CPU-bound issue when the CPU time exceeds the allocated time budget. </span><span class="kobospan" id="kobo.407.2">Let’s walk through an example to illustrate how to identify and resolve such issues using the Profiler. </span><span class="kobospan" id="kobo.407.3">Utilizing the </span><strong class="bold"><span class="kobospan" id="kobo.408.1">Timeline</span></strong><span class="kobospan" id="kobo.409.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.410.1">Hierarchy</span></strong><span class="kobospan" id="kobo.411.1"> views in the Profiler helps us gain a clearer understanding of the specific issue. </span><span class="kobospan" id="kobo.411.2">Refer to </span><span><em class="italic"><span class="kobospan" id="kobo.412.1">Figure 9</span></em></span><em class="italic"><span class="kobospan" id="kobo.413.1">.5</span></em><span class="kobospan" id="kobo.414.1"> for detailed information on a </span><span><span class="kobospan" id="kobo.415.1">spike frame:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer117">
<span class="kobospan" id="kobo.416.1"><img alt="Figure 9.5 – A spike frame" src="image/B22017_09_05.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.417.1">Figure 9.5 – A spike frame</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.418.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.419.1">gfx.waitForCommandsFromMainThread</span></strong><span class="kobospan" id="kobo.420.1"> marker indicates a potential bottleneck on the main thread that affects overall performance. </span><span class="kobospan" id="kobo.420.2">This occurs when the render </span><a id="_idIndexMarker594" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.421.1">thread waits for commands from the main thread, suggesting that tasks or commands that are being processed on the CPU are taking longer. </span><span class="kobospan" id="kobo.421.2">Consequently, the game experiences a CPU-bound issue, causing delays in rendering. </span><span class="kobospan" id="kobo.421.3">Addressing these bottlenecks and optimizing CPU-bound issues can significantly enhance game performance </span><span><span class="kobospan" id="kobo.422.1">and responsiveness.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.423.1">Identify the CPU bottleneck by analyzing which thread is the most active. </span><span class="kobospan" id="kobo.423.2">Profiling helps pinpoint bottlenecks accurately for focused optimization. </span><span class="kobospan" id="kobo.423.3">Guesswork can lead to ineffective optimizations or even </span><span><span class="kobospan" id="kobo.424.1">worsen performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">The primary threads for identifying performance issues typically include </span><span><span class="kobospan" id="kobo.426.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.427.1">The main thread</span></strong><span class="kobospan" id="kobo.428.1">: This</span><a id="_idIndexMarker595" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.429.1"> thread handles game logic and script execution, including tasks related to physics, animation, UI, and rendering. </span><span class="kobospan" id="kobo.429.2">It accounts for a significant portion of the </span><span><span class="kobospan" id="kobo.430.1">processing time.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.431.1">The render thread</span></strong><span class="kobospan" id="kobo.432.1">: This</span><a id="_idIndexMarker596" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.433.1"> thread is responsible for processing scene elements during rendering, such as camera culling, depth sorting, and draw call batching. </span><span class="kobospan" id="kobo.433.2">It converts Unity’s scene representation into specific graphics API calls for </span><span><span class="kobospan" id="kobo.434.1">GPU rendering.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.435.1">The job worker threads</span></strong><span class="kobospan" id="kobo.436.1">: These threads utilize the C# Job System to offload specific</span><a id="_idIndexMarker597" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.437.1"> tasks onto separate Worker Threads, reducing the main thread’s workload. </span><span class="kobospan" id="kobo.437.2">Various Unity systems, such as physics, animation, and rendering, also leverage the Job System for </span><span><span class="kobospan" id="kobo.438.1">improved performance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">You need </span><a id="_idIndexMarker598" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.440.1">to identify any loops in your code where spikes occur, determine what is causing the high CPU usage or prolonged processing time, and investigate if it corresponds to a common marker in the Profiler. </span><span class="kobospan" id="kobo.440.2">Understanding the meaning of these markers helps you address the issue effectively. </span><span class="kobospan" id="kobo.440.3">Optimize your code based on your findings, monitor the Profiler again after applying fixes, and continue this iterative process until you achieve your target </span><span><span class="kobospan" id="kobo.441.1">frame rate.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.442.1">GPU-bound issues</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.443.1">If your</span><a id="_idIndexMarker599" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.444.1"> game experiences prolonged activity in Profiler markers such as </span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">Gfx WaitForPresentOnGfxThread</span></strong><span class="kobospan" id="kobo.446.1">, indicating idle time for the render thread, and simultaneously shows markers such as </span><strong class="source-inline"><span class="kobospan" id="kobo.447.1">Gfx PresentFrame</span></strong><span class="kobospan" id="kobo.448.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">&lt;GraphicsAPIName&gt; WaitForLastPresent</span></strong><span class="kobospan" id="kobo.450.1">, it suggests a GPU-bound scenario. </span><span class="kobospan" id="kobo.450.2">In this context, GPU-boundness is characterized by heavy GPU utilization and potential delays in frame rendering </span><span><span class="kobospan" id="kobo.451.1">and presentation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.452.1">If your game appears to be heavily using the GPU, you can use the Frame Debugger to quickly examine the batches of draw calls that are sent to the GPU. </span><span class="kobospan" id="kobo.452.2">I’ll discuss this tool in more detail in the next section. </span><span class="kobospan" id="kobo.452.3">However, it’s essential to note that while the Frame Debugger provides insights into scene construction, it doesn’t offer specific GPU timing details. </span><span class="kobospan" id="kobo.452.4">So, you can switch between the Profiler and the Frame Debugger to fix any issues related </span><span><span class="kobospan" id="kobo.453.1">to GPU.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.454.1">Let’s explore the factors that can lead to GPU performance issues in our projects. </span><span class="kobospan" id="kobo.454.2">The following are some </span><span><span class="kobospan" id="kobo.455.1">common issues:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.456.1">Complex particle systems with a high number of particles or intricate behaviors can impact </span><span><span class="kobospan" id="kobo.457.1">GPU performance</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.458.1">Real-time reflections or refractions, particularly in scenes with many reflective surfaces, can </span><span><span class="kobospan" id="kobo.459.1">be GPU-intensive</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.460.1">Shader permutations or shader variants for different materials or effects can increase GPU workload, especially if they’re not </span><span><span class="kobospan" id="kobo.461.1">managed efficiently</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.462.1">Dynamic weather or environmental effects, such as rain, fog, or dynamic skies, can add GPU overhead if they’re </span><span><span class="kobospan" id="kobo.463.1">not optimized</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.464.1">Dynamic Occlusion culling and visibility calculations can affect GPU performance, especially in scenes with complex geometry or many </span><span><span class="kobospan" id="kobo.465.1">moving objects</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.466.1">High screen resolutions, especially 4K displays or retina displays on mobile devices, can put a heavy load on </span><span><span class="kobospan" id="kobo.467.1">the GPU</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.468.1">Here are</span><a id="_idIndexMarker600" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.469.1"> some useful tips while using </span><span><span class="kobospan" id="kobo.470.1">the Profiler:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.471.1">Turn off the </span><strong class="bold"><span class="kobospan" id="kobo.472.1">VSync</span></strong><span class="kobospan" id="kobo.473.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.474.1">Others</span></strong><span class="kobospan" id="kobo.475.1"> categories in the </span><strong class="bold"><span class="kobospan" id="kobo.476.1">CPU Usage</span></strong><span class="kobospan" id="kobo.477.1"> Profiler module. </span><span class="kobospan" id="kobo.477.2">The </span><strong class="bold"><span class="kobospan" id="kobo.478.1">VSync</span></strong><span class="kobospan" id="kobo.479.1"> marker indicates periods of inactivity in the CPU’s main thread, and hiding these markers can enhance the clarity of your </span><span><span class="kobospan" id="kobo.480.1">profiling analysis.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.481.1">Disable </span><strong class="bold"><span class="kobospan" id="kobo.482.1">VSync</span></strong><span class="kobospan" id="kobo.483.1"> in your project build to gain a clear understanding of the interactions between the main thread, render thread, and GPU. </span><span class="kobospan" id="kobo.483.2">Profiling a build with </span><strong class="bold"><span class="kobospan" id="kobo.484.1">VSync</span></strong><span class="kobospan" id="kobo.485.1"> disabled can simplify the interpretation of </span><span><span class="kobospan" id="kobo.486.1">profiler data.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.487.1">Be mindful of when to conduct profiling in either Play mode or Editor mode. </span><span class="kobospan" id="kobo.487.2">Utilize Play mode for profiling game performance and Editor mode for monitoring Unity Editor processes. </span><span class="kobospan" id="kobo.487.3">Profiling the Editor can aid in identifying performance bottlenecks and </span><span><span class="kobospan" id="kobo.488.1">improving productivity.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.489.1">Opt for profiling in the Editor when you need to quickly iterate on resolving performance issues. </span><span class="kobospan" id="kobo.489.2">After identifying problems, use Play mode profiling to efficiently iterate on changes and </span><span><span class="kobospan" id="kobo.490.1">validate solutions.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.491.1">Optimizing graphics</span><a id="_idIndexMarker601" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.492.1"> performance and identifying rendering bottlenecks in Unity becomes streamlined and efficient with the powerful capabilities of the Frame Debugger tool. </span><span class="kobospan" id="kobo.492.2">We’ll dive deeper into this in the </span><span><span class="kobospan" id="kobo.493.1">next section.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.494.1">The Frame Debugger</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">The</span><a id="_idIndexMarker602" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.496.1"> Frame Debugger is a powerful tool that’s used for analyzing and debugging the rendering </span><a id="_idIndexMarker603" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.497.1">process of a frame in your game. </span><span class="kobospan" id="kobo.497.2">It allows you to inspect each step involved in rendering, such as draw calls, batching, textures, and materials. </span><span class="kobospan" id="kobo.497.3">This tool is crucial for optimizing graphics performance and identifying </span><span><span class="kobospan" id="kobo.498.1">rendering bottlenecks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.499.1">You can open the </span><strong class="bold"><span class="kobospan" id="kobo.500.1">Frame Debugger</span></strong><span class="kobospan" id="kobo.501.1"> tool from the </span><strong class="bold"><span class="kobospan" id="kobo.502.1">Window</span></strong><span class="kobospan" id="kobo.503.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.504.1">Analysis</span></strong><span class="kobospan" id="kobo.505.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.506.1">Frame </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.507.1">Debugger</span></strong></span><span> </span><span><span class="kobospan" id="kobo.508.1">menu:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer118">
<span class="kobospan" id="kobo.509.1"><img alt="Figure 9.6 – Frame Debugger" src="image/B22017_09_06.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.510.1">Figure 9.6 – Frame Debugger</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.511.1">Now that we’ve learned how to open the Frame Debugger, let’s explore how it works and what </span><span><span class="kobospan" id="kobo.512.1">it does.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.513.1">Understanding how the Frame Debugger operates</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.514.1">The </span><a id="_idIndexMarker604" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.515.1">Frame Debugger works by intercepting and analyzing the rendering commands that are sent to the graphics API (for example, DirectX or OpenGL). </span><span class="kobospan" id="kobo.515.2">It captures information about each draw call, including the shaders, textures, materials, and meshes involved. </span><span class="kobospan" id="kobo.515.3">This captured data is then presented in a visual interface, allowing developers to inspect and understand the rendering pipeline of </span><span><span class="kobospan" id="kobo.516.1">a frame.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">The Frame Debugger operates in real time, meaning you can pause the game in Play mode, analyze the current frame’s rendering, and make optimizations on </span><span><span class="kobospan" id="kobo.518.1">the fly.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.519.1">Exploring the key functions of the Frame Debugger</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.520.1">The </span><a id="_idIndexMarker605" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.521.1">primary functions of the Frame Debugger are </span><span><span class="kobospan" id="kobo.522.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.523.1">Capturing and displaying each draw call that’s made during the </span><span><span class="kobospan" id="kobo.524.1">rendering process</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.525.1">Showing how objects are batched together for optimized </span><span><span class="kobospan" id="kobo.526.1">rendering performance</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.527.1">Providing details about the shaders, textures, materials, and meshes that are used </span><span><span class="kobospan" id="kobo.528.1">in rendering</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.529.1">Identifying render targets and offscreen </span><span><span class="kobospan" id="kobo.530.1">render textures</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">Let’s explore the Frame Debugger. </span><span class="kobospan" id="kobo.531.2">This is what the </span><strong class="bold"><span class="kobospan" id="kobo.532.1">Frame Debugger</span></strong><span class="kobospan" id="kobo.533.1"> window </span><span><span class="kobospan" id="kobo.534.1">looks like:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer119">
<span class="kobospan" id="kobo.535.1"><img alt="Figure 9.7 – The Frame Debugger window has been enabled" src="image/B22017_09_07.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.536.1">Figure 9.7 – The Frame Debugger window has been enabled</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.537.1">After enabling </span><a id="_idIndexMarker606" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.538.1">the Frame Debugger, the game will pause, and you’ll be able to view all graphics-related details for that frame. </span><span class="kobospan" id="kobo.538.2">This includes every draw call from the initial black screen to the current scene. </span><span class="kobospan" id="kobo.538.3">In Unity 2022, which is the version we’re using, the Frame Debugger features an </span><strong class="bold"><span class="kobospan" id="kobo.539.1">Output / Mesh</span></strong><span class="kobospan" id="kobo.540.1"> section with two tabs: one displaying the full output or current state of the graphics/scene, and the other showing the drawn mesh, such as the example of a palm tree in this instance. </span><span class="kobospan" id="kobo.540.2">You can see this mesh in </span><span><em class="italic"><span class="kobospan" id="kobo.541.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.542.1">.8</span></em></span><span><span class="kobospan" id="kobo.543.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer120">
<span class="kobospan" id="kobo.544.1"><img alt="Figure 9.8 – Mesh Preview" src="image/B22017_09_08.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.545.1">Figure 9.8 – Mesh Preview</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.546.1">The details </span><a id="_idIndexMarker607" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.547.1">about each draw call will be presented in a separate section that contains important information such as </span><strong class="bold"><span class="kobospan" id="kobo.548.1">RenderTarget</span></strong><span class="kobospan" id="kobo.549.1">, </span><strong class="bold"><span class="kobospan" id="kobo.550.1">Vertices</span></strong><span class="kobospan" id="kobo.551.1">, </span><strong class="bold"><span class="kobospan" id="kobo.552.1">Indices</span></strong><span class="kobospan" id="kobo.553.1">, and </span><span><strong class="bold"><span class="kobospan" id="kobo.554.1">Used Shader</span></strong></span><span><span class="kobospan" id="kobo.555.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer121">
<span class="kobospan" id="kobo.556.1"><img alt="Figure 9.9 – The Details section" src="image/B22017_09_09.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.557.1">Figure 9.9 – The Details section</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.558.1">Additionally, the </span><a id="_idIndexMarker608" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.559.1">Frame Debugger includes sections for the used </span><strong class="bold"><span class="kobospan" id="kobo.560.1">Textures</span></strong><span class="kobospan" id="kobo.561.1">, </span><strong class="bold"><span class="kobospan" id="kobo.562.1">Vectors</span></strong><span class="kobospan" id="kobo.563.1">, </span><strong class="bold"><span class="kobospan" id="kobo.564.1">Floats</span></strong><span class="kobospan" id="kobo.565.1">, and other sections, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.566.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.567.1">.10</span></em></span><span><span class="kobospan" id="kobo.568.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer122">
<span class="kobospan" id="kobo.569.1"><img alt="Figure 9.10 – The other sections in the Frame Debugger" src="image/B22017_09_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.570.1">Figure 9.10 – The other sections in the Frame Debugger</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.571.1">Once you have identified the contents of the frame, the optimization process depends on employing specific strategies and techniques tailored to the unique aspects of each game. </span><span class="kobospan" id="kobo.571.2">Addressing issues requires thorough research to pinpoint areas for optimization, and this process often involves iterative steps to achieve optimal performance. </span><span class="kobospan" id="kobo.571.3">One of the most important ways to reduce draw calls is to use batching. </span><span class="kobospan" id="kobo.571.4">Let’s take a </span><span><span class="kobospan" id="kobo.572.1">closer look.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.573.1">Draw call batching</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.574.1">Draw call batching </span><a id="_idIndexMarker609" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.575.1">refers to a technique that’s used for optimizing draw calls by merging meshes, allowing Unity to render them in fewer draw calls. </span><span class="kobospan" id="kobo.575.2">Unity </span><a id="_idIndexMarker610" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.576.1">offers two default draw call </span><span><span class="kobospan" id="kobo.577.1">batching methods:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.578.1">Static batching</span></strong></span><span><span class="kobospan" id="kobo.579.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.580.1">In this process, Unity combines and renders static </span><span><span class="kobospan" id="kobo.581.1">GameObjects together.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.582.1">Static batching in </span><a id="_idIndexMarker611" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1">Unity refers to the process of optimizing draw calls by combining meshes either at build time or during runtime. </span><span class="kobospan" id="kobo.583.2">When using static batching, it’s essential to ensure that certain criteria are met for GameObjects to be eligible for </span><span><span class="kobospan" id="kobo.584.1">static batching:</span></span></p><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.585.1">The GameObject must </span><span><span class="kobospan" id="kobo.586.1">be active</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.587.1">It should have a </span><strong class="bold"><span class="kobospan" id="kobo.588.1">Mesh Filter</span></strong><span class="kobospan" id="kobo.589.1"> component that is enabled and references a mesh with a vertex count greater </span><span><span class="kobospan" id="kobo.590.1">than 0</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.591.1">The GameObject should also have a </span><strong class="bold"><span class="kobospan" id="kobo.592.1">Mesh Renderer</span></strong><span class="kobospan" id="kobo.593.1"> component that is enabled and uses a material without a shader that </span><span><span class="kobospan" id="kobo.594.1">disables batching</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.595.1">Meshes that are to be batched together must share the same </span><span><span class="kobospan" id="kobo.596.1">vertex attributes</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.597.1">When utilizing static batching, Unity allows the entire batch of meshes to be transformed collectively, such as moving, rotating, or scaling them as a single entity. </span><span class="kobospan" id="kobo.597.2">However, transformations cannot be applied to individual meshes within </span><span><span class="kobospan" id="kobo.598.1">the batch.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.599.1">It’s worth noting that enabling read/write access for the mesh is necessary to use runtime static batching effectively. </span><span class="kobospan" id="kobo.599.2">Overall, static batching is a useful technique for optimizing draw calls and improving performance in </span><span><span class="kobospan" id="kobo.600.1">Unity projects.</span></span></p></li>
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.601.1">Dynamic batching</span></strong></span><span><span class="kobospan" id="kobo.602.1">:</span></span><p class="calibre3"><span class="kobospan" id="kobo.603.1">Dynamic batching is a </span><a id="_idIndexMarker612" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.604.1">process where Unity combines small </span><a id="_idIndexMarker613" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.605.1">meshes by transforming their vertices on the CPU and grouping similar vertices, ultimately rendering them in a single </span><span><span class="kobospan" id="kobo.606.1">draw call.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.607.1">To enable dynamic batching for meshes in Unity, follow </span><span><span class="kobospan" id="kobo.608.1">these steps:</span></span></p><ol class="calibre18"><li class="upper-roman"><span class="kobospan" id="kobo.609.1">Navigate to </span><strong class="bold"><span class="kobospan" id="kobo.610.1">Edit</span></strong><span class="kobospan" id="kobo.611.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.612.1">Project Settings</span></strong><span class="kobospan" id="kobo.613.1"> | </span><span><strong class="bold"><span class="kobospan" id="kobo.614.1">Player</span></strong></span><span><span class="kobospan" id="kobo.615.1">.</span></span></li><li class="upper-roman"><span class="kobospan" id="kobo.616.1">In the </span><strong class="bold"><span class="kobospan" id="kobo.617.1">Other Settings</span></strong><span class="kobospan" id="kobo.618.1"> section, activate the </span><strong class="bold"><span class="kobospan" id="kobo.619.1">Dynamic </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.620.1">Batching</span></strong></span><span><span class="kobospan" id="kobo.621.1"> option.</span></span></li></ol><p class="calibre3"><span class="kobospan" id="kobo.622.1">Unity will automatically group moving meshes into a single draw call if they meet the </span><span><span class="kobospan" id="kobo.623.1">specified criteria.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.624.1">Dynamic batching in Unity doesn’t work on GameObjects with mirrored transformations in their </span><strong class="bold"><span class="kobospan" id="kobo.625.1">Transform</span></strong><span class="kobospan" id="kobo.626.1"> components. </span><span class="kobospan" id="kobo.626.2">For instance, if one GameObject has a scale of 1 and another has a scale of -1, Unity cannot batch them together.Top </span><span><span class="kobospan" id="kobo.627.1">of Form</span></span></p></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.628.1">In general, Unity combines draw calls for GameObjects using identical materials, so it’s crucial to maximize batching efficiency by sharing materials among multiple GameObjects. </span><span class="kobospan" id="kobo.628.2">If you have two material assets that are almost identical except for their textures, consider merging the textures into a single, larger texture within the same atlas. </span><span class="kobospan" id="kobo.628.3">This allows you to use a single material asset instead of two. </span><span class="kobospan" id="kobo.628.4">When accessing shared material properties from a C# script, ensure that you use </span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">Renderer.sharedMaterial</span></strong><span class="kobospan" id="kobo.630.1"> instead of </span><strong class="source-inline"><span class="kobospan" id="kobo.631.1">Renderer.material</span></strong><span class="kobospan" id="kobo.632.1">. </span><span class="kobospan" id="kobo.632.2">Using </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">Renderer.material</span></strong><span class="kobospan" id="kobo.634.1"> creates a duplicate of the material, preventing Unity from batching draw calls for </span><span><span class="kobospan" id="kobo.635.1">that renderer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">The following are the additional methods you can utilize to decrease the number of draw </span><span><span class="kobospan" id="kobo.637.1">call batches:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.638.1">Use Occlusion culling to eliminate objects that are hidden behind foreground elements and minimize overdraw. </span><span class="kobospan" id="kobo.638.2">Keep in mind that this may increase CPU processing, so use the Profiler to evaluate the impact of transferring the workload from GPU </span><span><span class="kobospan" id="kobo.639.1">to CPU.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.640.1">Employ GPU instancing to reduce batches, particularly for numerous objects that share the same mesh and material. </span><span class="kobospan" id="kobo.640.2">Limiting the number of models in your scene can enhance performance, and with careful implementation, you can create a complex scene </span><span><span class="kobospan" id="kobo.641.1">without repetitiveness.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.642.1">Leverage the SRP Batcher to decrease GPU setup between draw calls by grouping </span><strong class="bold"><span class="kobospan" id="kobo.643.1">Bind</span></strong><span class="kobospan" id="kobo.644.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.645.1">Draw</span></strong><span class="kobospan" id="kobo.646.1"> GPU commands. </span><span class="kobospan" id="kobo.646.2">To maximize SRP batching benefits, utilize multiple Materials but restrict them to a few compatible shader variants, such as the </span><strong class="bold"><span class="kobospan" id="kobo.647.1">Lit</span></strong><span class="kobospan" id="kobo.648.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.649.1">Unlit</span></strong><span class="kobospan" id="kobo.650.1"> shaders in the </span><strong class="bold"><span class="kobospan" id="kobo.651.1">Universal Render Pipeline</span></strong><span class="kobospan" id="kobo.652.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.653.1">URP</span></strong><span class="kobospan" id="kobo.654.1">) and </span><strong class="bold"><span class="kobospan" id="kobo.655.1">High Definition Render Pipeline</span></strong><span class="kobospan" id="kobo.656.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.657.1">HDRP</span></strong><span class="kobospan" id="kobo.658.1">), minimizing variations between </span><span><span class="kobospan" id="kobo.659.1">keyword combinations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.660.1">Utilizing these</span><a id="_idIndexMarker614" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.661.1"> techniques can significantly enhance rendering performance and streamline the development process in </span><span><span class="kobospan" id="kobo.662.1">Unity games.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.663.1">Now, let’s explore the optimization techniques for various categories in any game to </span><span><span class="kobospan" id="kobo.664.1">improve performance.</span></span></p>
</div>


<div id="_idContainer142" class="calibre2">
<h1 id="_idParaDest-138" class="calibre5"><a id="_idTextAnchor145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.665.1">Performance optimization techniques</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.666.1">In this </span><a id="_idIndexMarker615" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.667.1">section, we will delve into the crucial aspects of performance optimization techniques in Unity. </span><span class="kobospan" id="kobo.667.2">Performance optimization plays a pivotal role in ensuring that your game runs smoothly, utilizes system resources efficiently, and delivers a seamless experience to players. </span><span class="kobospan" id="kobo.667.3">By implementing optimization techniques, analyzing performance data, and adopting efficient scripting practices, developers can significantly enhance their game’s performance and overall quality. </span><span class="kobospan" id="kobo.667.4">Let’s explore these skills in detail to understand how they contribute to creating high-performance games </span><span><span class="kobospan" id="kobo.668.1">in Unity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.669.1">The following subsections cover key areas for </span><span><span class="kobospan" id="kobo.670.1">optimization techniques.</span></span></p>
<h2 id="_idParaDest-139" class="calibre7"><a id="_idTextAnchor146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.671.1">Physics and collisions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.672.1">To </span><a id="_idIndexMarker616" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.673.1">boost the performance and efficiency of physics and collisions in Unity, strategic optimization techniques play a crucial role. </span><span class="kobospan" id="kobo.673.2">Here, we’ll explore two such techniques and detail their respective problems, solutions, examples, </span><span><span class="kobospan" id="kobo.674.1">and outcomes:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.675.1">Collision </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.676.1">layer masking</span></strong></span><span><span class="kobospan" id="kobo.677.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.678.1">Problem</span></strong><span class="kobospan" id="kobo.679.1">: There are </span><a id="_idIndexMarker617" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.680.1">unnecessary collision checks between objects that don’t interact with each other, leading to wasted </span><span><span class="kobospan" id="kobo.681.1">computational resources.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.682.1">Solution</span></strong><span class="kobospan" id="kobo.683.1">: Use collision layer masking to specify which layers should interact with each other, avoiding unnecessary </span><span><span class="kobospan" id="kobo.684.1">collision checks.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.685.1">How it works</span></strong><span class="kobospan" id="kobo.686.1">: Assign different layers to objects based on their interaction requirements. </span><span class="kobospan" id="kobo.686.2">Configure the physics settings to only enable collisions between specific layers that need </span><span><span class="kobospan" id="kobo.687.1">to interact.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.688.1">Example</span></strong><span class="kobospan" id="kobo.689.1">: Let’s consider a 2D platformer game where the player character interacts with</span><a id="_idIndexMarker618" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.690.1"> enemies, collectibles, and environmental obstacles. </span><span class="kobospan" id="kobo.690.2">By assigning different layers to these objects (for example, Player, Enemy, Collectible, and Obstacle), you can configure the physics settings to enable collisions only between specific layers. </span><span class="kobospan" id="kobo.690.3">Here’s </span><span><span class="kobospan" id="kobo.691.1">an example:</span></span><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.692.1">The Player layer interacts with the Enemy and Obstacle layers but not with the </span><span><span class="kobospan" id="kobo.693.1">Collectible layer</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.694.1">The Enemy layer interacts with the Player and Obstacle layers but not with the </span><span><span class="kobospan" id="kobo.695.1">Collectible layer</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.696.1">The Collectible layer does not interact with the Player, Enemy, or </span><span><span class="kobospan" id="kobo.697.1">Obstacle layers:</span></span></li></ul></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer123">
<span class="kobospan" id="kobo.698.1"><img alt="Figure 9.11 – Physics settings" src="image/B22017_09_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.699.1">Figure 9.11 – Physics settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.700.1">In your scripts, when performing collision checks using raycasts or collider triggers, you can </span><a id="_idIndexMarker619" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.701.1">apply layer masks to filter out unnecessary collisions. </span><span class="kobospan" id="kobo.701.2">For instance, when you’re checking for enemy collisions, you can specify a layer mask that includes only the Enemy layer, ignoring collisions with collectibles </span><span><span class="kobospan" id="kobo.702.1">or obstacles.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.703.1">Result</span></strong><span class="kobospan" id="kobo.704.1">: A reduced number of collision checks and improved performance by eliminating unnecessary </span><span><span class="kobospan" id="kobo.705.1">physics calculations.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.706.1">In Unity, optimizing</span><a id="_idIndexMarker620" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.707.1"> physics and collisions through collision layer masking involves strategically assigning layers, configuring physics settings, and applying layer masks to streamline collision checks and </span><span><span class="kobospan" id="kobo.708.1">enhance performance.</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.709.1">Simplified </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.710.1">collision detection</span></strong></span><span><span class="kobospan" id="kobo.711.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.712.1">Problem</span></strong><span class="kobospan" id="kobo.713.1">: Full </span><a id="_idIndexMarker621" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.714.1">physics calculations for collision detection on objects that don’t require realistic physical interactions can </span><span><span class="kobospan" id="kobo.715.1">be resource-intensive.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.716.1">Solution</span></strong><span class="kobospan" id="kobo.717.1">: Use triggers as simplified collision detection for </span><span><span class="kobospan" id="kobo.718.1">non-essential objects.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.719.1">How it works</span></strong><span class="kobospan" id="kobo.720.1">: Triggers in Unity are collider components that detect when another collider enters or exits their volume without physically colliding with them. </span><span class="kobospan" id="kobo.720.2">They are ideal for scenarios where you need to detect interactions without simulating </span><span><span class="kobospan" id="kobo.721.1">physical forces.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.722.1">Example</span></strong><span class="kobospan" id="kobo.723.1">: In a game where collectible coins are scattered around the level, instead of using rigid body-based collisions for the coins, you can attach trigger colliders to them. </span><span class="kobospan" id="kobo.723.2">When the player’s character overlaps with a coin’s trigger collider, you can handle the collection logic without the need for full </span><span><span class="kobospan" id="kobo.724.1">physics calculations.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.725.1">Result</span></strong><span class="kobospan" id="kobo.726.1">: Using triggers reduces the computational overhead associated with physics calculations for objects that only require collision detection without physical responses. </span><span class="kobospan" id="kobo.726.2">This leads to improved performance, especially in scenarios with a large number of </span><span><span class="kobospan" id="kobo.727.1">non-essential objects.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.728.1">This technique is beneficial for optimizing performance in scenarios where objects do not require detailed physics interactions but still need basic collision detection functionality. </span><span class="kobospan" id="kobo.728.2">By using simplified collision detection methods, you can conserve computational resources and improve overall performance in your </span><span><span class="kobospan" id="kobo.729.1">Unity project.</span></span></p></li>
</ul>
<h2 id="_idParaDest-140" class="calibre7"><a id="_idTextAnchor147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.730.1">Audio</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.731.1">Optimizing </span><a id="_idIndexMarker622" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.732.1">audio in Unity is crucial for maintaining a smooth and immersive gameplay experience. </span><span class="kobospan" id="kobo.732.2">Let’s explore an advanced technique to </span><a id="_idIndexMarker623" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.733.1">reduce memory usage and improve audio performance in </span><span><span class="kobospan" id="kobo.734.1">your game:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.735.1">Audio </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.736.1">compression technique</span></strong></span><span><span class="kobospan" id="kobo.737.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.738.1">Problem</span></strong><span class="kobospan" id="kobo.739.1">: Large audio files can consume significant memory, leading to </span><span><span class="kobospan" id="kobo.740.1">performance issues.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.741.1">Solution</span></strong><span class="kobospan" id="kobo.742.1">: Compress audio files using formats such as Ogg Vorbis or MP3 to reduce memory </span><a id="_idIndexMarker624" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.743.1">usage without compromising </span><a id="_idIndexMarker625" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.744.1">quality. </span><span class="kobospan" id="kobo.744.2">You can learn more about Unity’s importing settings by referring to the official Unity documentation </span><span><span class="kobospan" id="kobo.745.1">at </span></span><span><span class="kobospan" id="kobo.746.1">https://docs.unity3d.com/Manual/class-AudioClip.html#:~:text=Whenever%20importing%20a%20file%2C%20Unity,to%20the%20original%20as%20possible</span></span><span><span class="kobospan" id="kobo.747.1">:</span></span></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer124">
<span class="kobospan" id="kobo.748.1"><img alt="Figure 9.12 – Imported audio settings" src="image/B22017_09_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.749.1">Figure 9.12 – Imported audio settings</span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.750.1">Example</span></strong><span class="kobospan" id="kobo.751.1">: Compressing background music and sound effects in </span><span><span class="kobospan" id="kobo.752.1">a game.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.753.1">Result</span></strong><span class="kobospan" id="kobo.754.1">: Reduced memory footprint, faster loading times, and </span><span><span class="kobospan" id="kobo.755.1">smoother gameplay.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.756.1">By employing</span><a id="_idIndexMarker626" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.757.1"> advanced audio optimization </span><a id="_idIndexMarker627" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.758.1">techniques such as compression and streaming, you can significantly enhance your game’s performance while maintaining high-quality </span><span><span class="kobospan" id="kobo.759.1">audio output.</span></span></p>
<h2 id="_idParaDest-141" class="calibre7"><a id="_idTextAnchor148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.760.1">UI</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.761.1">I covered</span><a id="_idIndexMarker628" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.762.1"> this topic in detail in </span><a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.763.1">Chapter 5</span></em></span></a><span class="kobospan" id="kobo.764.1">, </span><em class="italic"><span class="kobospan" id="kobo.765.1">Designing Optimized User Interfaces with C# for Unity Games</span></em><span class="kobospan" id="kobo.766.1">. </span><span class="kobospan" id="kobo.766.2">You can check it out for more details. </span><span class="kobospan" id="kobo.766.3">Optimizing UI is a crucial part of performance, especially in mobile games, as it directly impacts user experience and device </span><span><span class="kobospan" id="kobo.767.1">resource utilization.</span></span></p>
<h2 id="_idParaDest-142" class="calibre7"><a id="_idTextAnchor149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.768.1">Networking and multiplayer</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.769.1">Optimizing </span><a id="_idIndexMarker629" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.770.1">networking and multiplayer functionality in Unity games is crucial for ensuring smooth gameplay experiences across various devices and player interactions. </span><span class="kobospan" id="kobo.770.2">Here, we’ll explore key techniques and strategies for enhancing networking performance </span><a id="_idIndexMarker630" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.771.1">and implementing effective multiplayer mechanics in </span><span><span class="kobospan" id="kobo.772.1">Unity games:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.773.1">Latency </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.774.1">compensation techniques</span></strong></span><span><span class="kobospan" id="kobo.775.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.776.1">Problem</span></strong><span class="kobospan" id="kobo.777.1">: Latency can cause delays in multiplayer games, leading to synchronization issues and </span><span><span class="kobospan" id="kobo.778.1">gameplay inconsistencies.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.779.1">Solution</span></strong><span class="kobospan" id="kobo.780.1">: Implement latency compensation techniques to mitigate the effects of network latency on gameplay. </span><span class="kobospan" id="kobo.780.2">This depends on the networking solution you have implemented. </span><span class="kobospan" id="kobo.780.3">You can refer to their documentation for specific networking solutions, such </span><span><span class="kobospan" id="kobo.781.1">as Photon.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.782.1">Example</span></strong><span class="kobospan" id="kobo.783.1">: Use techniques such as client-side prediction, interpolation, and lag compensation to predict and smooth out the movement of networked objects based on input and </span><span><span class="kobospan" id="kobo.784.1">network data.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.785.1">Results</span></strong><span class="kobospan" id="kobo.786.1">: Improved responsiveness and synchronization in multiplayer games, reducing the impact of network latency on player experience and enhancing </span><span><span class="kobospan" id="kobo.787.1">gameplay smoothness.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.788.1">Network </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.789.1">object pooling</span></strong></span><span><span class="kobospan" id="kobo.790.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.791.1">Problem</span></strong><span class="kobospan" id="kobo.792.1">: Excessive instantiation and destruction of networked objects can lead to network </span><a id="_idIndexMarker631" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.793.1">congestion and </span><span><span class="kobospan" id="kobo.794.1">performance issues.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.795.1">Solution</span></strong><span class="kobospan" id="kobo.796.1">: Implement network object pooling to reuse existing networked objects instead of creating and destroying </span><span><span class="kobospan" id="kobo.797.1">them frequently.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.798.1">Example</span></strong><span class="kobospan" id="kobo.799.1">: In </span><a id="_idIndexMarker632" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.800.1">a multiplayer game, instead of instantiating and destroying bullets each time they are fired, use an object pool to recycle bullets. </span><span class="kobospan" id="kobo.800.2">When a bullet is no longer needed, it is returned to the pool and can be </span><span><span class="kobospan" id="kobo.801.1">reused later.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.802.1">Results</span></strong><span class="kobospan" id="kobo.803.1">: Reduced network overhead and improved performance due to fewer object instantiations and destructions, leading to smoother </span><span><span class="kobospan" id="kobo.804.1">gameplay experiences.</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.805.1">These techniques are instrumental in optimizing networking within Unity games as they effectively minimize network overhead, enhance data transmission efficiency, and contribute to a more satisfying multiplayer experience for players. </span><span class="kobospan" id="kobo.805.2">The effectiveness of these optimizations, however, is contingent upon the specific networking solution that’s implemented within </span><span><span class="kobospan" id="kobo.806.1">the game.</span></span></p>
<h2 id="_idParaDest-143" class="calibre7"><a id="_idTextAnchor150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.807.1">AI and pathfinding</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.808.1">Effective</span><a id="_idIndexMarker633" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.809.1"> AI and pathfinding techniques are pivotal for creating immersive and engaging gameplay experiences in Unity games. </span><span class="kobospan" id="kobo.809.2">We’ll </span><a id="_idIndexMarker634" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.810.1">explore two key solutions: A* (A-star) pathfinding and hierarchical pathfinding, along with behavior trees and state machines, to optimize AI navigation </span><span><span class="kobospan" id="kobo.811.1">and behaviors:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.812.1">Using </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.813.1">behavior trees</span></strong></span><span><span class="kobospan" id="kobo.814.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.815.1">Problem</span></strong><span class="kobospan" id="kobo.816.1">: Inefficient pathfinding algorithms can lead to high computational overhead and slow performance, especially in complex game environments with </span><span><span class="kobospan" id="kobo.817.1">dynamic obstacles.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.818.1">Example</span></strong><span class="kobospan" id="kobo.819.1">: Implementing the A* algorithm in Unity using the </span><span><span class="kobospan" id="kobo.820.1">NavMesh system.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.821.1">How it works</span></strong><span class="kobospan" id="kobo.822.1">: A* is a popular pathfinding algorithm that efficiently finds the shortest path between two points on a graph or grid. </span><span class="kobospan" id="kobo.822.2">In Unity, the NavMesh </span><a id="_idIndexMarker635" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.823.1">system utilizes A* for AI navigation, allowing agents to navigate dynamic environments while </span><span><span class="kobospan" id="kobo.824.1">avoiding obstacles.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.825.1">Result</span></strong><span class="kobospan" id="kobo.826.1">: Improved AI navigation performance, reduced computational cost, and smoother movement of AI agents in complex </span><span><span class="kobospan" id="kobo.827.1">game scenes.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.828.1">Using state machines for </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.829.1">AI behavior</span></strong></span><span><span class="kobospan" id="kobo.830.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.831.1">Problem</span></strong><span class="kobospan" id="kobo.832.1">: AI</span><a id="_idIndexMarker636" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.833.1"> behaviors lacking realism and diversity can result in predictable and monotonous </span><span><span class="kobospan" id="kobo.834.1">gameplay experiences.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.835.1">Example</span></strong><span class="kobospan" id="kobo.836.1">: Implementing state machines for AI </span><span><span class="kobospan" id="kobo.837.1">character behaviors.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.838.1">How it works</span></strong><span class="kobospan" id="kobo.839.1">: State machines model AI behaviors as a set of states, transitions, and actions. </span><span class="kobospan" id="kobo.839.2">Each state represents a specific behavior or condition, and transitions define how AI agents switch between states based on environmental stimuli or </span><span><span class="kobospan" id="kobo.840.1">internal variables.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.841.1">Here’s a simplified structure of a state machine for </span><span><span class="kobospan" id="kobo.842.1">AI behavior:</span></span></p><p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.843.1">State interface/class</span></strong></span><span><span class="kobospan" id="kobo.844.1">:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.845.1">Enter</span></strong><span class="kobospan" id="kobo.846.1">: The </span><a id="_idIndexMarker637" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.847.1">method that’s called when entering </span><span><span class="kobospan" id="kobo.848.1">the state</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.849.1">Update</span></strong><span class="kobospan" id="kobo.850.1">: The method that’s called during each update cycle while in </span><span><span class="kobospan" id="kobo.851.1">the state</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.852.1">Exit</span></strong><span class="kobospan" id="kobo.853.1">: The method that’s called when exiting </span><span><span class="kobospan" id="kobo.854.1">the state</span></span></li></ul><p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.855.1">Concrete states</span></strong></span><span><span class="kobospan" id="kobo.856.1">:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.857.1">Idle State</span></strong><span class="kobospan" id="kobo.858.1">: This</span><a id="_idIndexMarker638" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.859.1"> represents the AI being idle, with its own </span><strong class="source-inline1"><span class="kobospan" id="kobo.860.1">Enter</span></strong><span class="kobospan" id="kobo.861.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.862.1">Update</span></strong><span class="kobospan" id="kobo.863.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.864.1">Exit</span></strong><span class="kobospan" id="kobo.865.1"> methods specific to </span><span><span class="kobospan" id="kobo.866.1">idle behavior.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.867.1">Attack State</span></strong><span class="kobospan" id="kobo.868.1">: Represents the AI attacking, with its own </span><strong class="source-inline1"><span class="kobospan" id="kobo.869.1">Enter</span></strong><span class="kobospan" id="kobo.870.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.871.1">Update</span></strong><span class="kobospan" id="kobo.872.1">, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.873.1">Exit</span></strong><span class="kobospan" id="kobo.874.1"> methods specific to </span><span><span class="kobospan" id="kobo.875.1">attack behavior</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.876.1">Other states as needed, each with their own </span><span><span class="kobospan" id="kobo.877.1">behavior methods</span></span></li></ul><p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.878.1">State </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.879.1">machine manager</span></strong></span><span><span class="kobospan" id="kobo.880.1">:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.881.1">Current State</span></strong><span class="kobospan" id="kobo.882.1">: Keeps</span><a id="_idIndexMarker639" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.883.1"> track of the AI’s </span><span><span class="kobospan" id="kobo.884.1">current state</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.885.1">Change State</span></strong><span class="kobospan" id="kobo.886.1">: This method transitions the AI from one state to another by updating the </span><strong class="source-inline1"><span class="kobospan" id="kobo.887.1">Current </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.888.1">State</span></strong></span><span><span class="kobospan" id="kobo.889.1"> variable</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.890.1">Update</span></strong><span class="kobospan" id="kobo.891.1">: The method to be called in each update cycle, which, in turn, calls the </span><strong class="source-inline1"><span class="kobospan" id="kobo.892.1">Update</span></strong><span class="kobospan" id="kobo.893.1"> method of the </span><span><span class="kobospan" id="kobo.894.1">current state</span></span></li></ul><p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.895.1">Usage</span></strong></span><span><span class="kobospan" id="kobo.896.1">:</span></span></p><ul class="calibre16"><li class="calibre11"><span class="kobospan" id="kobo.897.1">Initialize the AI with an initial state (for example, </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.898.1">Idle State</span></strong></span><span><span class="kobospan" id="kobo.899.1">)</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.900.1">During each update cycle, call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.901.1">Update</span></strong><span class="kobospan" id="kobo.902.1"> method of the state machine manager to execute the behavior of the </span><span><span class="kobospan" id="kobo.903.1">current state</span></span></li><li class="calibre11"><span class="kobospan" id="kobo.904.1">When conditions change (for example, the AI detects an enemy), use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.905.1">Change State</span></strong><span class="kobospan" id="kobo.906.1"> method to switch to the appropriate state (for example, </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.907.1">Attack State</span></strong></span><span><span class="kobospan" id="kobo.908.1">)</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.909.1">This structure outlines the components and their relationships in a state machine for AI behavior. </span><span class="kobospan" id="kobo.909.2">You can implement this structure in any programming language by creating classes/interfaces for states, implementing a manager to handle state transitions, and integrating them into your </span><span><span class="kobospan" id="kobo.910.1">AI system.</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.911.1">Result</span></strong><span class="kobospan" id="kobo.912.1">: Modular and organized AI behavior design, easier debugging and maintenance of AI logic, and improved adaptability to changing </span><span><span class="kobospan" id="kobo.913.1">game conditions.</span></span></li></ul></li>
</ul>
<h2 id="_idParaDest-144" class="calibre7"><a id="_idTextAnchor151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.914.1">Build size</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.915.1">Efficient </span><a id="_idIndexMarker640" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.916.1">build size is crucial for delivering optimized and polished Unity games to players. </span><span class="kobospan" id="kobo.916.2">Let’s explore a technique known as build size reduction through asset compression to enhance </span><span><span class="kobospan" id="kobo.917.1">build efficiency:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.918.1">Build </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.919.1">size reduction</span></strong></span><span><span class="kobospan" id="kobo.920.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.921.1">Problem</span></strong><span class="kobospan" id="kobo.922.1">: Large </span><a id="_idIndexMarker641" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.923.1">build sizes can lead to longer download times and increased storage requirements </span><span><span class="kobospan" id="kobo.924.1">for players.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.925.1">Solution</span></strong><span class="kobospan" id="kobo.926.1">: Implement asset compression techniques such as texture compression, audio compression, and code stripping to reduce the overall size of the build. </span><span class="kobospan" id="kobo.926.2">For texture compression, it’s recommended to use dimensions that are powers of two, such as 64x64. </span><span class="kobospan" id="kobo.926.3">This approach is beneficial for compression, resulting in reduced memory usage and a smaller final </span><span><span class="kobospan" id="kobo.927.1">build size.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.928.1">Example</span></strong><span class="kobospan" id="kobo.929.1">: Use texture compression formats such as ETC2 for Android builds and ASTC for iOS builds to significantly reduce the size of texture assets without compromising quality. </span><span class="kobospan" id="kobo.929.2">The size of the texture is shown in the </span><span><span class="kobospan" id="kobo.930.1">following figures:</span></span></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer125">
<span class="kobospan" id="kobo.931.1"><img alt="Figure 9.13 – Before using the compression format" src="image/B22017_09_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.932.1">Figure 9.13 – Before using the compression format</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer126">
<span class="kobospan" id="kobo.933.1"><img alt="Figure 9.14 – After using a compression format" src="image/B22017_09_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.934.1">Figure 9.14 – After using a compression format</span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.935.1">Result</span></strong><span class="kobospan" id="kobo.936.1">: Reduced build size, faster download times, and improved performance on devices with </span><span><span class="kobospan" id="kobo.937.1">limited storage.</span></span></li>
</ul>
<h2 id="_idParaDest-145" class="calibre7"><a id="_idTextAnchor152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.938.1">Rendering</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.939.1">Optimizing </span><a id="_idIndexMarker642" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.940.1">rendering is essential for delivering visually stunning games while maintaining optimal performance. </span><span class="kobospan" id="kobo.940.2">Let’s explore two powerful techniques: a </span><strong class="bold"><span class="kobospan" id="kobo.941.1">level of detail</span></strong><span class="kobospan" id="kobo.942.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.943.1">LOD</span></strong><span class="kobospan" id="kobo.944.1">) system for efficient mesh rendering and Occlusion Culling to minimize unnecessary rendering, resulting in enhanced performance </span><a id="_idIndexMarker643" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.945.1">and </span><span><span class="kobospan" id="kobo.946.1">visual quality:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.947.1">LOD system</span></strong></span><span><span class="kobospan" id="kobo.948.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.949.1">Problem</span></strong><span class="kobospan" id="kobo.950.1">: High-poly models and complex scenes can lead to performance issues, especially on </span><span><span class="kobospan" id="kobo.951.1">lower-end devices.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.952.1">Solution</span></strong><span class="kobospan" id="kobo.953.1">: Implement a LOD system where objects have multiple versions with varying levels of detail. </span><span class="kobospan" id="kobo.953.2">The system switches to lower-detail versions as objects move farther from the camera, reducing the </span><span><span class="kobospan" id="kobo.954.1">rendering workload.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.955.1">Example</span></strong><span class="kobospan" id="kobo.956.1">: Use Unity’s </span><strong class="bold"><span class="kobospan" id="kobo.957.1">LOD Group</span></strong><span class="kobospan" id="kobo.958.1"> component to create LOD levels for meshes, ensuring smooth transitions between LOD levels based on camera distance. </span><span class="kobospan" id="kobo.958.2">Ensure that you have the necessary meshes ready by either requesting them from artists, utilizing assets from the asset store, or creating them manually if you possess the skills. </span><span class="kobospan" id="kobo.958.3">It’s important to create low-poly meshes from the original ones to </span><span><span class="kobospan" id="kobo.959.1">optimize performance:</span></span></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer127">
<span class="kobospan" id="kobo.960.1"><img alt="Figure 9.15 – The LOD Group component" src="image/B22017_09_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.961.1">Figure 9.15 – The LOD Group component</span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.962.1">Result</span></strong><span class="kobospan" id="kobo.963.1">: Improved performance by reducing the number of polygons that are rendered without compromising </span><span><span class="kobospan" id="kobo.964.1">visual quality.</span></span></li>
</ul>
<ul class="calibre10">
<li class="calibre11"><span><strong class="bold"><span class="kobospan" id="kobo.965.1">Occlusion culling</span></strong></span><span><span class="kobospan" id="kobo.966.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.967.1">Problem</span></strong><span class="kobospan" id="kobo.968.1">: Rendering </span><a id="_idIndexMarker644" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.969.1">off-screen </span><a id="_idIndexMarker645" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.970.1">objects consumes resources and affects performance, even though they are not visible to </span><span><span class="kobospan" id="kobo.971.1">the player.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.972.1">Solution</span></strong><span class="kobospan" id="kobo.973.1">: Use Occlusion culling to prevent objects that are occluded by other objects or not within the player’s view frustum from </span><span><span class="kobospan" id="kobo.974.1">being rendered.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.975.1">Example</span></strong><span class="kobospan" id="kobo.976.1">: Configure Occlusion culling volumes in Unity to define areas where Occlusion culling should be applied, optimizing rendering by skipping </span><span><span class="kobospan" id="kobo.977.1">occluded objects:</span></span></li></ul></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer128">
<span class="kobospan" id="kobo.978.1"><img alt="Figure 9.16 – The camera before the starting line" src="image/B22017_09_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.979.1">Figure 9.16 – The camera before the starting line</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer129">
<span class="kobospan" id="kobo.980.1"><img alt="Figure 9.17 – The camera after the starting line" src="image/B22017_09_17.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.981.1">Figure 9.17 – The camera after the starting line</span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.982.1">Result</span></strong><span class="kobospan" id="kobo.983.1">: Reduced </span><a id="_idIndexMarker646" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.984.1">rendering workload, improved frame rates, and</span><a id="_idIndexMarker647" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.985.1"> enhanced overall performance, especially in </span><span><span class="kobospan" id="kobo.986.1">complex scenes.</span></span></li>
</ul>
<h2 id="_idParaDest-146" class="calibre7"><a id="_idTextAnchor153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.987.1">Scripting</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.988.1">Efficient</span><a id="_idIndexMarker648" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.989.1"> scripting practices are crucial for optimizing game performance and ensuring smooth gameplay experiences. </span><span class="kobospan" id="kobo.989.2">Let’s explore two powerful techniques: object pooling for efficient object management and coroutine optimization to enhance coroutine performance, resulting in improved overall game performance </span><span><span class="kobospan" id="kobo.990.1">and responsiveness.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.991.1">Object pooling</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.992.1">Let’s consider a</span><a id="_idIndexMarker649" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.993.1"> solution for </span><span><span class="kobospan" id="kobo.994.1">object pooling:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.995.1">Problem</span></strong><span class="kobospan" id="kobo.996.1">: Instantiating and destroying objects frequently during gameplay can lead to performance overhead due to memory allocation and </span><span><span class="kobospan" id="kobo.997.1">garbage collection.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.998.1">Solution</span></strong><span class="kobospan" id="kobo.999.1">: Implement object pooling, where a set of pre-allocated objects is reused instead of you having to instantiate and destroy </span><span><span class="kobospan" id="kobo.1000.1">them repeatedly.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1001.1">Example</span></strong><span class="kobospan" id="kobo.1002.1">: Create an object pool manager script in Unity that manages pools of objects, such as bullets, enemies, or particles. </span><span class="kobospan" id="kobo.1002.2">Activate and deactivate objects from the pool as needed instead of creating </span><span><span class="kobospan" id="kobo.1003.1">new instances.</span></span><p class="calibre3"><span class="kobospan" id="kobo.1004.1">Let’s explore </span><a id="_idIndexMarker650" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1005.1">an example of how to</span><a id="_idIndexMarker651" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1006.1"> utilize </span><strong class="source-inline"><span class="kobospan" id="kobo.1007.1">ObjectPoolManager</span></strong><span class="kobospan" id="kobo.1008.1"> and understand</span><a id="_idIndexMarker652" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.1009.1">its functionality.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.1010.1">In the following code block, the </span><strong class="source-inline"><span class="kobospan" id="kobo.1011.1">ObjectPoolManager</span></strong><span class="kobospan" id="kobo.1012.1"> class is responsible for handling all operations related to the pooled objects. </span><span class="kobospan" id="kobo.1012.2">To make it accessible from other scripts, we will implement it as </span><span><span class="kobospan" id="kobo.1013.1">a singleton:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1014.1">
 public class ObjectPoolManager : MonoBehaviour
   {
       // Static instance of the ObjectPoolManager
       private static ObjectPoolManager instance;
       // Property to access the ObjectPoolManager instance
       public static ObjectPoolManager Instance
       {
           get
           {
               if (instance == null)
               {
                   instance = FindObjectOfType&lt;ObjectPoolManager&gt;();
                   // If not found, create a new GameObject and add the ObjectPoolManager script to it
                   if (instance == null)
                   {
                       GameObject obj = new GameObject("ObjectPoolManager");
                       instance = obj.AddComponent&lt;ObjectPoolManager&gt;();
                   }
               }
               return instance;
           }
       }
       private void Awake()
       {
           if (instance != null &amp;&amp; instance != this)
           {
               Destroy(gameObject);
           }
           else
           {
               instance = this;
               DontDestroyOnLoad(gameObject);
           }
       }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1015.1">This script uses a static </span><strong class="source-inline"><span class="kobospan" id="kobo.1016.1">Instance</span></strong><span class="kobospan" id="kobo.1017.1"> property to implement the singleton pattern for </span><strong class="source-inline"><span class="kobospan" id="kobo.1018.1">ObjectPoolManager</span></strong><span class="kobospan" id="kobo.1019.1">. </span><span class="kobospan" id="kobo.1019.2">It also includes an </span><strong class="source-inline"><span class="kobospan" id="kobo.1020.1">Awake</span></strong><span class="kobospan" id="kobo.1021.1"> method to ensure that only one instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.1022.1">ObjectPoolManager</span></strong><span class="kobospan" id="kobo.1023.1"> exists in the scene and persists between scene changes </span><span><span class="kobospan" id="kobo.1024.1">if needed.</span></span></p><p class="calibre3"><span class="kobospan" id="kobo.1025.1">In the following code block, I will</span><a id="_idIndexMarker653" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1026.1"> continue implementing the logic related to the object pooling by </span><strong class="source-inline"><span class="kobospan" id="kobo.1027.1">GetPooledObject</span></strong><span class="kobospan" id="kobo.1028.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1029.1">ReturnToPool</span></strong><span class="kobospan" id="kobo.1030.1"> functions of </span><span><span class="kobospan" id="kobo.1031.1">the objects:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1032.1">        // Define a dictionary to store object pools
        private Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; objectPools = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();
        // Create or retrieve an object from the pool based on the name of it
        public GameObject GetPooledObject(string objectName)
        {
            if (objectPools.ContainsKey(objectName))
            {
                if (objectPools[objectName].Count &gt; 0)
                {
                    GameObject obj = objectPools[objectName].Dequeue();
                    obj.SetActive(true);
                    return obj;
                }
            }
            Debug.LogWarning("No available object in the pool with name: " + objectName);
            return null;
        }
        // Return an object to the pool
        public void ReturnToPool(string objectName, GameObject obj)
        {
            obj.SetActive(false);
            objectPools[objectName].Enqueue(obj);
        }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1033.1">Here’s an</span><a id="_idIndexMarker654" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1034.1"> explanation for </span><span><span class="kobospan" id="kobo.1035.1">each part:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1036.1">private Dictionary&lt;string, Queue&lt;GameObject&gt;&gt; objectPools = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();</span></strong><span class="kobospan" id="kobo.1037.1">: This line declares a private dictionary named </span><strong class="source-inline1"><span class="kobospan" id="kobo.1038.1">objectPools</span></strong><span class="kobospan" id="kobo.1039.1"> that stores object pools based on their names. </span><span class="kobospan" id="kobo.1039.2">Each name corresponds to a queue </span><span><span class="kobospan" id="kobo.1040.1">of GameObjects.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1041.1">public GameObject GetPooledObject(string objectName)</span></strong><span class="kobospan" id="kobo.1042.1">: This method retrieves an object from the object pool based on its name. </span><span class="kobospan" id="kobo.1042.2">It checks if an object pool with the given name exists and if there are available objects in the pool. </span><span class="kobospan" id="kobo.1042.3">If available, it dequeues an object, activates it, and returns it. </span><span class="kobospan" id="kobo.1042.4">If no object is available, it logs a warning and </span><span><span class="kobospan" id="kobo.1043.1">returns null.</span></span></li><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1044.1">public void ReturnToPool(string objectName, GameObject obj)</span></strong><span class="kobospan" id="kobo.1045.1">: This method returns an object to the object pool based on its name. </span><span class="kobospan" id="kobo.1045.2">It deactivates the object and enqueues it back into the corresponding object </span><span><span class="kobospan" id="kobo.1046.1">pool queue.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.1047.1">Lastly, I’ll create a function to instantiate pooled objects from other scripts, as demonstrated</span><a id="_idIndexMarker655" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1048.1"> in the following </span><span><span class="kobospan" id="kobo.1049.1">code block:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1050.1">  // Create an object pool for a specific prefab so I can dynamically add object to the pool in runtime
  public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)
  {
      if (!objectPools.ContainsKey(objectName))
      {
          objectPools[objectName] = new Queue&lt;GameObject&gt;();
          for (int i = 0; i &lt; poolSize; i++)
          {
              GameObject obj = Instantiate(prefab);
              obj.SetActive(false);
              objectPools[objectName].Enqueue(obj);
          }
      }
      else
      {
          Debug.LogWarning("Object pool with name " + objectName + " already exists.");
      }
  }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1051.1">Here’s an explanation of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1052.1">CreateObjectPool</span></strong></span><span><span class="kobospan" id="kobo.1053.1"> method:</span></span></p><ul class="calibre16"><li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.1054.1">public void CreateObjectPool(GameObject prefab, int poolSize, string objectName)</span></strong><span class="kobospan" id="kobo.1055.1">: This method creates an object pool for a specific prefab with a given pool size and object name. </span><span class="kobospan" id="kobo.1055.2">It checks if an object pool with the same name already exists. </span><span class="kobospan" id="kobo.1055.3">If not, it creates a new queue in the dictionary and instantiates objects based on the prefab to populate </span><span><span class="kobospan" id="kobo.1056.1">the pool.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.1057.1">Here’s an example of </span><a id="_idIndexMarker656" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1058.1">how to use </span><span><span class="kobospan" id="kobo.1059.1">this manager:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.1060.1">public class ExampleUsage : MonoBehaviour
 {
     public GameObject prefabToPool;
     public int poolSize = 10;
     public string objectName = "MyTag";
     void Start()
     {
         // Create an object pool with the specified prefab, pool size, and tag
         ObjectPoolManager.Instance.CreateObjectPool(prefabToPool, poolSize, objectName);
         // Get an object from the pool
         GameObject obj = ObjectPoolManager.Instance.GetPooledObject(objectName);
         if (obj != null)
         {
             // Use the object
             obj.transform.position = Vector3.zero;
         }
         // Return the object to the pool
         ObjectPoolManager.Instance.ReturnToPool(objectName, obj);
     }
 }</span></pre></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1061.1">Result</span></strong><span class="kobospan" id="kobo.1062.1">: Reduced</span><a id="_idIndexMarker657" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1063.1"> memory overhead, improved performance, and smoother gameplay experience, especially in scenarios with frequent object creation </span><span><span class="kobospan" id="kobo.1064.1">and destruction.</span></span></li>
</ul>
<h3 class="calibre9"><span class="kobospan" id="kobo.1065.1">Coroutine optimization</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1066.1">Now, let’s consider a </span><a id="_idIndexMarker658" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1067.1">solution for </span><span><span class="kobospan" id="kobo.1068.1">coroutine optimization:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1069.1">Problem</span></strong><span class="kobospan" id="kobo.1070.1">: Using coroutines extensively without optimization can lead to performance issues, especially when you’re dealing with long-running or </span><span><span class="kobospan" id="kobo.1071.1">frequent coroutines.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1072.1">Solution</span></strong><span class="kobospan" id="kobo.1073.1">: Optimize coroutines by employing techniques such as using </span><strong class="source-inline1"><span class="kobospan" id="kobo.1074.1">WaitForSeconds</span></strong><span class="kobospan" id="kobo.1075.1"> instead of </span><strong class="source-inline1"><span class="kobospan" id="kobo.1076.1">WaitForSecondsRealtime</span></strong><span class="kobospan" id="kobo.1077.1">, minimizing </span><strong class="source-inline1"><span class="kobospan" id="kobo.1078.1">WaitForSeconds</span></strong><span class="kobospan" id="kobo.1079.1"> calls, and avoiding nested coroutines where possible. </span><span class="kobospan" id="kobo.1079.2">Additionally, consider defining or caching </span><strong class="source-inline1"><span class="kobospan" id="kobo.1080.1">WaitForSeconds</span></strong><span class="kobospan" id="kobo.1081.1"> instances to avoid creating new instances each time the coroutine is executed, which can improve memory efficiency. </span><span class="kobospan" id="kobo.1081.2">The following code block shows an example of how to </span><span><span class="kobospan" id="kobo.1082.1">define </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1083.1">WaitForSeconds</span></strong></span><span><span class="kobospan" id="kobo.1084.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1085.1">
// Define WaitForSeconds as a variable
    private WaitForSeconds waitShort = new WaitForSeconds(2f);</span></pre></li> <li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1086.1">Example</span></strong><span class="kobospan" id="kobo.1087.1">: Refactor coroutine-heavy scripts to reduce the number of coroutine instances, optimize yield instructions, and use alternatives such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1088.1">InvokeRepeating</span></strong><span class="kobospan" id="kobo.1089.1"> for </span><span><span class="kobospan" id="kobo.1090.1">repetitive tasks.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1091.1">Result</span></strong><span class="kobospan" id="kobo.1092.1">: Improved </span><a id="_idIndexMarker659" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1093.1">performance by reducing coroutine overhead, smoother gameplay, and better frame rates, especially in complex scenes with many coroutines </span><span><span class="kobospan" id="kobo.1094.1">running simultaneously.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1095.1">We now know about some common issues and their appropriate solutions. </span><span class="kobospan" id="kobo.1095.2">In the next section, we’ll move on and learn how to </span><span><span class="kobospan" id="kobo.1096.1">optimize memory.</span></span></p>
<h1 id="_idParaDest-147" class="calibre5"><a id="_idTextAnchor154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1097.1">Memory management and optimization</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1098.1">Memory profiling in </span><a id="_idIndexMarker660" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1099.1">Unity involves utilizing tools such as the Memory Profiler module and package to analyze and optimize memory usage, allowing us to identify areas for improvement and enhance overall performance. </span><span class="kobospan" id="kobo.1099.2">You’ll learn more about the Memory Profiler package in </span><span><span class="kobospan" id="kobo.1100.1">this section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1101.1">You can analyze </span><a id="_idIndexMarker661" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1102.1">memory usage in your Unity application through two methods. </span><span class="kobospan" id="kobo.1102.2">First, the Memory Profiler module provides essential insights into memory usage, highlighting areas where your application consumes memory. </span><span class="kobospan" id="kobo.1102.3">Second, by integrating the Memory Profiler package into your project, you gain access to an enhanced </span><strong class="bold"><span class="kobospan" id="kobo.1103.1">Memory Profiler</span></strong><span class="kobospan" id="kobo.1104.1"> window within Unity Editor. </span><span class="kobospan" id="kobo.1104.2">This advanced tool allows for more detailed analysis, including storing and comparing snapshots to identify memory leaks and examining memory layouts to detect </span><span><span class="kobospan" id="kobo.1105.1">fragmentation issues.</span></span></p>
<h2 id="_idParaDest-148" class="calibre7"><a id="_idTextAnchor155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1106.1">The Memory Profiler</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1107.1">The </span><a id="_idIndexMarker662" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1108.1">Memory Profiler in Unity is a tool that’s used for analyzing and optimizing memory usage in Unity projects. </span><span class="kobospan" id="kobo.1108.2">It helps us understand how our game uses memory and identify areas where memory can </span><span><span class="kobospan" id="kobo.1109.1">be optimized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1110.1">You need to install this package into your project. </span><span class="kobospan" id="kobo.1110.2">Go to the </span><strong class="bold"><span class="kobospan" id="kobo.1111.1">Package Manager</span></strong><span class="kobospan" id="kobo.1112.1"> window and select </span><strong class="bold"><span class="kobospan" id="kobo.1113.1">Memory Profiler</span></strong><span class="kobospan" id="kobo.1114.1">, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1115.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1116.1">.18</span></em></span><span><span class="kobospan" id="kobo.1117.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer130">
<span class="kobospan" id="kobo.1118.1"><img alt="Figure 9.18 – Installing the Memory Profiler package" src="image/B22017_09_18.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1119.1">Figure 9.18 – Installing the Memory Profiler package</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1120.1">Wait for </span><a id="_idIndexMarker663" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1121.1">Unity to finish installing the Memory Profiler package, then open it from the </span><strong class="bold"><span class="kobospan" id="kobo.1122.1">Window</span></strong><span class="kobospan" id="kobo.1123.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1124.1">Analysis</span></strong><span class="kobospan" id="kobo.1125.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1126.1">Memory Profiler</span></strong><span class="kobospan" id="kobo.1127.1"> menu. </span><span class="kobospan" id="kobo.1127.2">If this is your first time using it in your project, an empty window will open, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1128.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1129.1">.19</span></em></span><span><span class="kobospan" id="kobo.1130.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer131">
<span class="kobospan" id="kobo.1131.1"><img alt="Figure 9.19 – The Memory Profiler panel" src="image/B22017_09_19.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1132.1">Figure 9.19 – The Memory Profiler panel</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1133.1">Now that we’ve</span><a id="_idIndexMarker664" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1134.1"> learned how to open the Memory Profiler, let’s explore how it works and what </span><span><span class="kobospan" id="kobo.1135.1">it does.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.1136.1">Understanding how the Memory Profiler operates</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.1137.1">The </span><a id="_idIndexMarker665" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1138.1">Memory Profiler works by monitoring and recording memory allocations and usage in real time while your Unity project is running. </span><span class="kobospan" id="kobo.1138.2">It tracks various metrics, such as heap size, memory allocations by type, instance counts, and memory leaks. </span><span class="kobospan" id="kobo.1138.3">It provides a detailed breakdown of memory usage, allowing developers to pinpoint areas of high memory consumption and potential </span><span><span class="kobospan" id="kobo.1139.1">memory leaks.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.1140.1">Exploring the key functions of the Memory Profiler</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.1141.1">The </span><a id="_idIndexMarker666" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1142.1">primary functions of the Memory Profiler are </span><span><span class="kobospan" id="kobo.1143.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1144.1">Tracks memory allocations</span></strong><span class="kobospan" id="kobo.1145.1">: The Memory Profiler tracks memory allocations made by your game, including heap memory, object instances, and </span><span><span class="kobospan" id="kobo.1146.1">resource usage</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1147.1">Identifies memory leaks</span></strong><span class="kobospan" id="kobo.1148.1">: It helps identify memory leaks by highlighting objects that are not properly disposed of or released </span><span><span class="kobospan" id="kobo.1149.1">from memory</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1150.1">Analyzes memory usage by type</span></strong><span class="kobospan" id="kobo.1151.1">: You can see a breakdown of memory usage by different types of objects, scripts, textures, and other assets in </span><span><span class="kobospan" id="kobo.1152.1">your project</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1153.1">Provides instance counts</span></strong><span class="kobospan" id="kobo.1154.1">: The Memory Profiler shows how many instances of each object type are currently in memory, helping you understand memory </span><span><span class="kobospan" id="kobo.1155.1">consumption patterns</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1156.1">Offers insights into resource usage</span></strong><span class="kobospan" id="kobo.1157.1">: It provides insights into how resources such as textures, audio clips, and other assets contribute to </span><span><span class="kobospan" id="kobo.1158.1">memory usage</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1159.1">Now, let’s learn how to use the </span><span><span class="kobospan" id="kobo.1160.1">Memory Profiler.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1161.1">Using the Memory Profiler</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1162.1">Before</span><a id="_idIndexMarker667" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1163.1"> we dive into the Memory Profiler, it’s crucial to consider and adhere to the memory limitations of your target devices in multiplatform development. </span><span class="kobospan" id="kobo.1163.2">Design scenes and levels within the specified memory budget for each device to ensure optimal performance based on hardware capabilities. </span><span class="kobospan" id="kobo.1163.3">Setting clear limits and guidelines helps maintain compatibility </span><span><span class="kobospan" id="kobo.1164.1">across platforms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1165.1">The Memory Profiler package offers comprehensive memory analysis capabilities. </span><span class="kobospan" id="kobo.1165.2">Utilize it to store and compare snapshots for identifying memory leaks and optimizing your application’s memory layout. </span><span class="kobospan" id="kobo.1165.3">Unlike the Memory Profiler module, this package extends its functionality to include managed memory analysis, snapshot saving, comparison, and detailed memory </span><a id="_idIndexMarker668" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1166.1">content exploration with </span><span><span class="kobospan" id="kobo.1167.1">visual breakdowns:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer132">
<span class="kobospan" id="kobo.1168.1"><img alt="Figure 9.20 – The Summary tab in the Memory Profiler" src="image/B22017_09_20.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1169.1">Figure 9.20 – The Summary tab in the Memory Profiler</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1170.1">The </span><strong class="bold"><span class="kobospan" id="kobo.1171.1">Summary</span></strong><span class="kobospan" id="kobo.1172.1"> tab provides an overview of the memory status in the </span><span><span class="kobospan" id="kobo.1173.1">chosen snapshot(s).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1174.1">Once you click on any area of the summary, further details about it will appear in the </span><span><span class="kobospan" id="kobo.1175.1">right-hand panel.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1176.1">Another tab we</span><a id="_idIndexMarker669" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1177.1"> should consider is </span><strong class="bold"><span class="kobospan" id="kobo.1178.1">Unity Objects</span></strong><span class="kobospan" id="kobo.1179.1">, which showcases Unity objects that are utilizing memory, along with their respective allocations in native and managed memory, and the combined total. </span><span class="kobospan" id="kobo.1179.2">You can utilize this data to spot duplicate memory entries or pinpoint objects with significant memory usage. </span><span class="kobospan" id="kobo.1179.3">You can also utilize the search bar to filter entries in the table based on your specified text. </span><span class="kobospan" id="kobo.1179.4">This can be seen in </span><span><em class="italic"><span class="kobospan" id="kobo.1180.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1181.1">.21</span></em></span><span><span class="kobospan" id="kobo.1182.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer133">
<span class="kobospan" id="kobo.1183.1"><img alt="Figure 9.21 – The Unity Objects tab in the Memory Profiler" src="image/B22017_09_21.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1184.1">Figure 9.21 – The Unity Objects tab in the Memory Profiler</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1185.1">Lastly, The </span><strong class="bold"><span class="kobospan" id="kobo.1186.1">All Of Memory</span></strong><span class="kobospan" id="kobo.1187.1"> tab is exclusive to </span><strong class="bold"><span class="kobospan" id="kobo.1188.1">Single Snapshot</span></strong><span class="kobospan" id="kobo.1189.1"> mode, providing a comprehensive </span><a id="_idIndexMarker670" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1190.1">breakdown of all tracked memory in the snapshot. </span><span class="kobospan" id="kobo.1190.2">It visualizes memory usage, showcasing sizable portions managed either by Unity or the platform. </span><span class="kobospan" id="kobo.1190.3">This tab is instrumental in discerning non-Unity-related memory consumption and uncovering potential memory issues not evident in the </span><strong class="bold"><span class="kobospan" id="kobo.1191.1">Unity </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1192.1">Objects</span></strong></span><span><span class="kobospan" id="kobo.1193.1"> tab:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer134">
<span class="kobospan" id="kobo.1194.1"><img alt="Figure 9.22 – The All Of Memory tab in the Memory Profiler" src="image/B22017_09_22.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1195.1">Figure 9.22 – The All Of Memory tab in the Memory Profiler</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1196.1">You can identify</span><a id="_idIndexMarker671" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1197.1"> optimization candidates by following </span><span><span class="kobospan" id="kobo.1198.1">these steps:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.1199.1">Open a snapshot by referring to the instructions for </span><span><span class="kobospan" id="kobo.1200.1">opening snapshots.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1201.1">Access the </span><strong class="bold"><span class="kobospan" id="kobo.1202.1">Unity </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1203.1">Objects</span></strong></span><span><span class="kobospan" id="kobo.1204.1"> tab.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1205.1">Ensure the table is sorted in descending order, which is the default setting in the </span><strong class="bold"><span class="kobospan" id="kobo.1206.1">Memory Profiler</span></strong><span class="kobospan" id="kobo.1207.1"> window. </span><span class="kobospan" id="kobo.1207.2">If the sort order has been changed, select the </span><strong class="bold"><span class="kobospan" id="kobo.1208.1">Total Size</span></strong><span class="kobospan" id="kobo.1209.1"> column header to revert to descending order for this process. </span><span class="kobospan" id="kobo.1209.2">This arrangement highlights objects with the highest memory usage at the top of </span><span><span class="kobospan" id="kobo.1210.1">the table.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.1211.1">You can search through the results in one of </span><span><span class="kobospan" id="kobo.1212.1">two ways:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1213.1">Expand groups to view individual objects within </span><span><span class="kobospan" id="kobo.1214.1">each group</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1215.1">Consider enabling the </span><strong class="bold"><span class="kobospan" id="kobo.1216.1">Flatten hierarchy</span></strong><span class="kobospan" id="kobo.1217.1"> property to exclusively display individual objects in </span><span><span class="kobospan" id="kobo.1218.1">the table</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1219.1">If you’re uncertain </span><a id="_idIndexMarker672" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1220.1">about which objects might use excessive memory, leave the </span><strong class="bold"><span class="kobospan" id="kobo.1221.1">Flatten hierarchy</span></strong><span class="kobospan" id="kobo.1222.1"> property disabled and inspect the groups to identify the largest objects. </span><span class="kobospan" id="kobo.1222.2">Enable this property if most assets are understood but there’s a suspicion of a few outliers consuming too </span><span><span class="kobospan" id="kobo.1223.1">much memory.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1224.1">Additionally, enable the </span><strong class="bold"><span class="kobospan" id="kobo.1225.1">Show Potential Duplicates Only</span></strong><span class="kobospan" id="kobo.1226.1"> property to identify objects flagged by the Memory Profiler as potential duplicates. </span><span class="kobospan" id="kobo.1226.2">Utilize the </span><strong class="bold"><span class="kobospan" id="kobo.1227.1">References</span></strong><span class="kobospan" id="kobo.1228.1"> component and </span><strong class="bold"><span class="kobospan" id="kobo.1229.1">Selection Details</span></strong><span class="kobospan" id="kobo.1230.1"> component for detailed insights into these objects. </span><span class="kobospan" id="kobo.1230.2">This information helps differentiate expected duplicates, such as multiple instances of a Prefab in a scene, from problematic duplicates, such as unintentionally created objects or instances not disposed of correctly </span><span><span class="kobospan" id="kobo.1231.1">by Unity.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1232.1">Here are some </span><a id="_idIndexMarker673" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1233.1">considerations when it comes to </span><span><span class="kobospan" id="kobo.1234.1">memory profiling:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1235.1">Use different memory usage based on settings such as quality levels, graphics tiers, and AssetBundle variants, especially on more </span><span><span class="kobospan" id="kobo.1236.1">powerful devices.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1237.1">Quality Level</span></strong><span class="kobospan" id="kobo.1238.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1239.1">Graphics</span></strong><span class="kobospan" id="kobo.1240.1"> settings can impact the size of RenderTextures that are used for </span><span><span class="kobospan" id="kobo.1241.1">shadow maps.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1242.1">Resolution scaling affects screen buffers, RenderTextures, and </span><span><span class="kobospan" id="kobo.1243.1">post-processing effects.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1244.1">Texture quality settings influence the size of </span><span><span class="kobospan" id="kobo.1245.1">all textures.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1246.1">Maximum LOD can impact models and </span><span><span class="kobospan" id="kobo.1247.1">other elements.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1248.1">AssetBundle variants such as HD and SD versions can result in different asset sizes based on the </span><span><span class="kobospan" id="kobo.1249.1">device’s specifications.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1250.1">The target device’s screen resolution affects the dimensions of RenderTextures that are utilized for </span><span><span class="kobospan" id="kobo.1251.1">post-processing effects.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1252.1">The supported Graphics API can affect shader sizes based on </span><span><span class="kobospan" id="kobo.1253.1">API-specific variants.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1254.1">Content generated dynamically during gameplay, such as procedural levels, can significantly impact memory usage. </span><span class="kobospan" id="kobo.1254.2">Monitor the memory footprint of dynamically generated assets to ensure efficient </span><span><span class="kobospan" id="kobo.1255.1">memory management.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1256.1">Conduct thorough testing on target devices with varying specifications, screen resolutions, and hardware configurations to identify and address memory issues specific to </span><span><span class="kobospan" id="kobo.1257.1">each platform.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1258.1">By considering</span><a id="_idIndexMarker674" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1259.1"> these aspects and conducting comprehensive memory profiling, you can optimize memory usage across different platforms, ensuring optimal performance and resource utilization in your </span><span><span class="kobospan" id="kobo.1260.1">Unity projects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1261.1">One effective method to</span><a id="_idIndexMarker675" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1262.1"> improve memory optimization in Unity is by optimizing the import settings </span><span><span class="kobospan" id="kobo.1263.1">for assets.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.1264.1">Importing models</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.1265.1">Importing models is a</span><a id="_idIndexMarker676" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1266.1"> critical aspect of 3D game development, and optimizing this process can significantly enhance memory usage and overall performance. </span><span class="kobospan" id="kobo.1266.2">In this section, we’ll explore key settings, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1267.1">Figure 9</span></em></span><em class="italic"><span class="kobospan" id="kobo.1268.1">.</span></em><em class="italic"><span class="kobospan" id="kobo.1269.1">23</span></em><span class="kobospan" id="kobo.1270.1">, that can be adjusted to achieve these </span><span><span class="kobospan" id="kobo.1271.1">optimizations effectively:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer135">
<span class="kobospan" id="kobo.1272.1"><img alt="Figure 9.23 – The model’s settings" src="image/B22017_09_23.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1273.1">Figure 9.23 – The model’s settings</span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1274.1">Mesh Compression</span></strong><span class="kobospan" id="kobo.1275.1"> is a setting that determines the level of compression that’s applied to imported mesh data. </span><span class="kobospan" id="kobo.1275.2">It </span><a id="_idIndexMarker677" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1276.1">affects the file size of the mesh asset and can impact both memory usage and </span><span><span class="kobospan" id="kobo.1277.1">rendering performance:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1278.1">Options</span></strong><span class="kobospan" id="kobo.1279.1">: Unity </span><a id="_idIndexMarker678" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1280.1">provides three options for </span><span><strong class="bold"><span class="kobospan" id="kobo.1281.1">Mesh Compression</span></strong></span><span><span class="kobospan" id="kobo.1282.1">:</span></span><ul class="calibre16"><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1283.1">Off</span></strong><span class="kobospan" id="kobo.1284.1">: No compression is applied, resulting in larger file sizes but potentially better </span><span><span class="kobospan" id="kobo.1285.1">rendering performance.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1286.1">Low</span></strong><span class="kobospan" id="kobo.1287.1">: Applies a basic compression algorithm to reduce file size while still maintaining visual quality. </span><span class="kobospan" id="kobo.1287.2">This is suitable for many cases as it doesn’t have a significant impact on </span><span><span class="kobospan" id="kobo.1288.1">rendering performance.</span></span></li><li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1289.1">Medium/High</span></strong><span class="kobospan" id="kobo.1290.1">: Utilizes more advanced compression techniques to further reduce file size. </span><span class="kobospan" id="kobo.1290.2">However, higher compression levels may lead to slightly lower rendering performance due to additional </span><span><span class="kobospan" id="kobo.1291.1">decompression overhead.</span></span></li></ul></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1292.1">Best practices</span></strong><span class="kobospan" id="kobo.1293.1">: Use </span><strong class="bold"><span class="kobospan" id="kobo.1294.1">Mesh Compression</span></strong><span class="kobospan" id="kobo.1295.1"> judiciously based on the specific requirements of your game. </span><span class="kobospan" id="kobo.1295.2">For complex models or those with intricate details, consider using </span><strong class="bold"><span class="kobospan" id="kobo.1296.1">Low</span></strong><span class="kobospan" id="kobo.1297.1"> compression to balance file size reduction with rendering performance. </span><span class="kobospan" id="kobo.1297.2">Test different compression levels to find the optimal balance for </span><span><span class="kobospan" id="kobo.1298.1">your project.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1299.1">The </span><strong class="bold"><span class="kobospan" id="kobo.1300.1">Read/Write Enabled</span></strong><span class="kobospan" id="kobo.1301.1"> setting</span><a id="_idIndexMarker679" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1302.1"> determines whether the mesh data can be accessed and modified at runtime. </span><span class="kobospan" id="kobo.1302.2">Enabling this setting allows scripts to read and modify mesh properties </span><span><span class="kobospan" id="kobo.1303.1">during gameplay:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1304.1">Impact on performance and memory</span></strong><span class="kobospan" id="kobo.1305.1">: Enabling Read/Write for a mesh increases memory usage because the mesh data needs to be stored in a format that allows runtime modifications. </span><span class="kobospan" id="kobo.1305.2">However, it can also provide flexibility for dynamic mesh operations, such as deformation or procedural </span><span><span class="kobospan" id="kobo.1306.1">mesh generation.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1307.1">Best practices</span></strong><span class="kobospan" id="kobo.1308.1">: Only enable Read/Write for meshes that require runtime modifications. </span><span class="kobospan" id="kobo.1308.2">For static meshes that do not change during gameplay, leave this setting disabled to reduce </span><span><span class="kobospan" id="kobo.1309.1">memory overhead.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1310.1">The </span><strong class="bold"><span class="kobospan" id="kobo.1311.1">Optimize Mesh</span></strong><span class="kobospan" id="kobo.1312.1"> setting</span><a id="_idIndexMarker680" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1313.1"> determines whether Unity applies additional optimizations to the imported mesh data to improve </span><span><span class="kobospan" id="kobo.1314.1">rendering performance:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1315.1">Effect on performance and memory</span></strong><span class="kobospan" id="kobo.1316.1">: Enabling </span><strong class="bold"><span class="kobospan" id="kobo.1317.1">Optimize Mesh</span></strong><span class="kobospan" id="kobo.1318.1"> allows Unity to perform optimizations such as vertex welding, which reduces the number of vertices in the mesh </span><a id="_idIndexMarker681" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1319.1">without significantly affecting visual quality. </span><span class="kobospan" id="kobo.1319.2">This can lead to improved rendering performance by reducing the workload on </span><span><span class="kobospan" id="kobo.1320.1">the GPU.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1321.1">Best practices</span></strong><span class="kobospan" id="kobo.1322.1">: Enable </span><strong class="bold"><span class="kobospan" id="kobo.1323.1">Optimize Mesh</span></strong><span class="kobospan" id="kobo.1324.1"> for meshes that can benefit from vertex reduction without compromising visual fidelity. </span><span class="kobospan" id="kobo.1324.2">This is particularly useful for models with redundant or overlapping vertices as it can significantly reduce memory usage and enhance </span><span><span class="kobospan" id="kobo.1325.1">rendering performance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1326.1">Setting the </span><strong class="bold"><span class="kobospan" id="kobo.1327.1">Animation Type</span></strong><span class="kobospan" id="kobo.1328.1"> option to </span><strong class="bold"><span class="kobospan" id="kobo.1329.1">None</span></strong><span class="kobospan" id="kobo.1330.1"> for a static game object in the </span><strong class="bold"><span class="kobospan" id="kobo.1331.1">Rig</span></strong><span class="kobospan" id="kobo.1332.1"> tab can have a positive impact on both performance and memory usage. </span><span class="kobospan" id="kobo.1332.2">When you choose </span><strong class="bold"><span class="kobospan" id="kobo.1333.1">None</span></strong><span class="kobospan" id="kobo.1334.1">, Unity skips any processing related to animation rigging and does not allocate resources for animation-related calculations during runtime. </span><span class="kobospan" id="kobo.1334.2">This can be seen in </span><span><em class="italic"><span class="kobospan" id="kobo.1335.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1336.1">.24</span></em></span><span><span class="kobospan" id="kobo.1337.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer136">
<span class="kobospan" id="kobo.1338.1"><img alt="Figure 9.24 – The Rig tab in the model settings" src="image/B22017_09_24.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1339.1">Figure 9.24 – The Rig tab in the model settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1340.1">Let’s look at how setting </span><strong class="bold"><span class="kobospan" id="kobo.1341.1">Animation Type</span></strong><span class="kobospan" id="kobo.1342.1"> to </span><strong class="bold"><span class="kobospan" id="kobo.1343.1">None</span></strong><span class="kobospan" id="kobo.1344.1"> can affect performance </span><span><span class="kobospan" id="kobo.1345.1">and memory.</span></span></p>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1346.1">Performance impact</span></strong></span><span><span class="kobospan" id="kobo.1347.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1348.1">By </span><a id="_idIndexMarker682" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1349.1">setting </span><strong class="bold"><span class="kobospan" id="kobo.1350.1">Animation Type</span></strong><span class="kobospan" id="kobo.1351.1"> to </span><strong class="bold"><span class="kobospan" id="kobo.1352.1">None</span></strong><span class="kobospan" id="kobo.1353.1">, Unity avoids processing animation data and calculations for </span><a id="_idIndexMarker683" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1354.1">the game object. </span><span class="kobospan" id="kobo.1354.2">This reduces the workload on the CPU and GPU, especially during the rendering and animation </span><span><span class="kobospan" id="kobo.1355.1">playback phases.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1356.1">Since there are no animation updates to perform, Unity can optimize the rendering pipeline by skipping unnecessary computations related to bone transformations, blend shapes, or animation </span><span><span class="kobospan" id="kobo.1357.1">state updates.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1358.1">This optimization can lead to smoother frame rates and improved overall performance, particularly for static objects that do not require any </span><span><span class="kobospan" id="kobo.1359.1">animation functionality.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1360.1">Memory impact</span></strong></span><span><span class="kobospan" id="kobo.1361.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1362.1">Setting </span><strong class="bold"><span class="kobospan" id="kobo.1363.1">Animation Type</span></strong><span class="kobospan" id="kobo.1364.1"> to </span><strong class="bold"><span class="kobospan" id="kobo.1365.1">None</span></strong><span class="kobospan" id="kobo.1366.1"> also has a memory-saving benefit. </span><span class="kobospan" id="kobo.1366.2">Unity does not allocate memory for storing animation clips, rigging data, or animation-related components (for example, Animator or Animation Controller) for game objects with this </span><span><span class="kobospan" id="kobo.1367.1">setting applied.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1368.1">This reduction in memory usage can be significant, especially for scenes with multiple static objects or large models that do not need </span><span><span class="kobospan" id="kobo.1369.1">animation features.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1370.1">By minimizing memory allocation for animation-related resources, you free up more memory for other game assets and reduce the overall memory footprint of your </span><span><span class="kobospan" id="kobo.1371.1">Unity project.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1372.1">Best practices</span></strong></span><span><span class="kobospan" id="kobo.1373.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1374.1">Set </span><strong class="bold"><span class="kobospan" id="kobo.1375.1">Animation Type</span></strong><span class="kobospan" id="kobo.1376.1"> to </span><strong class="bold"><span class="kobospan" id="kobo.1377.1">None</span></strong><span class="kobospan" id="kobo.1378.1"> for static game objects or models that do not require animation functionality. </span><span class="kobospan" id="kobo.1378.2">This is particularly effective for environment props, static scenery elements, or </span><span><span class="kobospan" id="kobo.1379.1">architectural models.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1380.1">For dynamic objects that require animation, such as characters or interactive elements, choose the appropriate </span><strong class="bold"><span class="kobospan" id="kobo.1381.1">Animation Type</span></strong><span class="kobospan" id="kobo.1382.1"> based on their animation requirements (for example, </span><strong class="bold"><span class="kobospan" id="kobo.1383.1">Generic</span></strong><span class="kobospan" id="kobo.1384.1">, </span><strong class="bold"><span class="kobospan" id="kobo.1385.1">Humanoid</span></strong><span class="kobospan" id="kobo.1386.1">, </span><strong class="bold"><span class="kobospan" id="kobo.1387.1">Legacy</span></strong><span class="kobospan" id="kobo.1388.1">, and </span><span><span class="kobospan" id="kobo.1389.1">so on).</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1390.1">Regularly review and optimize animation settings for each game object to ensure efficient use of resources and </span><span><span class="kobospan" id="kobo.1391.1">improved performance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1392.1">In summary, setting </span><strong class="bold"><span class="kobospan" id="kobo.1393.1">Animation Type</span></strong><span class="kobospan" id="kobo.1394.1"> to </span><strong class="bold"><span class="kobospan" id="kobo.1395.1">None</span></strong><span class="kobospan" id="kobo.1396.1"> for static game objects can be a beneficial optimization</span><a id="_idIndexMarker684" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1397.1"> strategy as it reduces both CPU/GPU workload and memory usage in your </span><span><span class="kobospan" id="kobo.1398.1">Unity project.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1399.1">Lastly, when </span><a id="_idIndexMarker685" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1400.1">considering the </span><strong class="bold"><span class="kobospan" id="kobo.1401.1">Anim. </span><span class="kobospan" id="kobo.1401.2">Compression</span></strong><span class="kobospan" id="kobo.1402.1"> option in the </span><strong class="bold"><span class="kobospan" id="kobo.1403.1">Animation</span></strong><span class="kobospan" id="kobo.1404.1"> tab of model settings in Unity, choosing between </span><strong class="bold"><span class="kobospan" id="kobo.1405.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1406.1"> or </span><strong class="bold"><span class="kobospan" id="kobo.1407.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1408.1"> can indeed have an impact on both performance and memory usage. </span><span class="kobospan" id="kobo.1408.2">This can be seen in </span><span><em class="italic"><span class="kobospan" id="kobo.1409.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1410.1">.25</span></em></span><span><span class="kobospan" id="kobo.1411.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer137">
<span class="kobospan" id="kobo.1412.1"><img alt="Figure 9.25 – The Animation tab in the model settings" src="image/B22017_09_25.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1413.1">Figure 9.25 – The Animation tab in the model settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1414.1">Let’s look </span><a id="_idIndexMarker686" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1415.1">at how each</span><a id="_idIndexMarker687" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1416.1"> option affects </span><span><span class="kobospan" id="kobo.1417.1">your project.</span></span></p>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1418.1">Optimal Compression</span></strong></span><span><span class="kobospan" id="kobo.1419.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1420.1">Performance impact</span></strong><span class="kobospan" id="kobo.1421.1">: </span><strong class="bold"><span class="kobospan" id="kobo.1422.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1423.1"> aims to reduce the size of animation clips while preserving visual quality. </span><span class="kobospan" id="kobo.1423.2">This can result in improved performance during runtime, especially for devices with limited processing power or </span><span><span class="kobospan" id="kobo.1424.1">memory bandwidth.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1425.1">Memory impact</span></strong><span class="kobospan" id="kobo.1426.1">: By compressing animation data efficiently, </span><strong class="bold"><span class="kobospan" id="kobo.1427.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1428.1"> reduces the memory footprint of animation clips. </span><span class="kobospan" id="kobo.1428.2">This can be beneficial for projects with many animations or large animation files, leading to lower memory usage and better </span><span><span class="kobospan" id="kobo.1429.1">resource management.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1430.1">Keyframe Reduction</span></strong></span><span><span class="kobospan" id="kobo.1431.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1432.1">Performance impact</span></strong><span class="kobospan" id="kobo.1433.1">: </span><strong class="bold"><span class="kobospan" id="kobo.1434.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1435.1"> focuses on minimizing the number of keyframes in </span><a id="_idIndexMarker688" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1436.1">animation clips while maintaining smooth motion. </span><span class="kobospan" id="kobo.1436.2">This can lead to improved performance by reducing the computational overhead of interpolating between keyframes during </span><span><span class="kobospan" id="kobo.1437.1">animation playback.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1438.1">Memory impact</span></strong><span class="kobospan" id="kobo.1439.1">: While </span><strong class="bold"><span class="kobospan" id="kobo.1440.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1441.1"> can help save memory by reducing </span><a id="_idIndexMarker689" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1442.1">the data needed for animation playback, it may not be as efficient in terms of memory optimization as </span><strong class="bold"><span class="kobospan" id="kobo.1443.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1444.1">. </span><span class="kobospan" id="kobo.1444.2">However, it can still contribute to lowering the overall memory usage of </span><span><span class="kobospan" id="kobo.1445.1">animation clips.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1446.1">Best practices</span></strong></span><span><span class="kobospan" id="kobo.1447.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1448.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1449.1">: Use </span><strong class="bold"><span class="kobospan" id="kobo.1450.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1451.1"> for animations that require a balance between file size reduction and visual quality. </span><span class="kobospan" id="kobo.1451.2">It’s suitable for a wide range of animations and can offer significant memory and </span><span><span class="kobospan" id="kobo.1452.1">performance benefits.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1453.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1454.1">: Consider </span><strong class="bold"><span class="kobospan" id="kobo.1455.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1456.1"> for animations where reducing the number of keyframes won’t significantly impact visual fidelity. </span><span class="kobospan" id="kobo.1456.2">This option can be particularly useful for repetitive or simple animations, helping to streamline memory usage and improve </span><span><span class="kobospan" id="kobo.1457.1">playback performance.</span></span></li>
</ul>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1458.1">Choosing the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1459.1">right option</span></strong></span><span><span class="kobospan" id="kobo.1460.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1461.1">Evaluate the animation requirements of your project and choose the compression option that best suits your needs. </span><strong class="bold"><span class="kobospan" id="kobo.1462.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1463.1"> is generally recommended for most scenarios due to its balanced approach to reducing file size and memory usage while maintaining </span><span><span class="kobospan" id="kobo.1464.1">visual quality.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1465.1">Regularly </span><a id="_idIndexMarker690" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1466.1">test animations with different compression settings to find the optimal balance between performance, memory usage, and visual fidelity for your specific </span><span><span class="kobospan" id="kobo.1467.1">project requirements.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1468.1">In conclusion, both </span><strong class="bold"><span class="kobospan" id="kobo.1469.1">Optimal Compression</span></strong><span class="kobospan" id="kobo.1470.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1471.1">Keyframe Reduction</span></strong><span class="kobospan" id="kobo.1472.1"> in the </span><strong class="bold"><span class="kobospan" id="kobo.1473.1">Anim. </span><span class="kobospan" id="kobo.1473.2">Compression</span></strong><span class="kobospan" id="kobo.1474.1"> option can impact performance and memory in Unity. </span><span class="kobospan" id="kobo.1474.2">Choose the compression setting that aligns with your project’s animation complexity, visual quality standards, and target platform capabilities to achieve the </span><span><span class="kobospan" id="kobo.1475.1">best results.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1476.1">To automate this process, we can create an asset </span><strong class="source-inline"><span class="kobospan" id="kobo.1477.1">PostProcessor</span></strong><span class="kobospan" id="kobo.1478.1"> script, which is an editor script that allows us to set default settings for importing assets. </span><span class="kobospan" id="kobo.1478.2">The following is an example code block demonstrating a </span><strong class="source-inline"><span class="kobospan" id="kobo.1479.1">CustomMeshPostProcessor</span></strong><span class="kobospan" id="kobo.1480.1"> class that achieves the desired default settings when importing meshes. </span><span class="kobospan" id="kobo.1480.2">Simply create this script and place it in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1481.1">Editor</span></strong><span class="kobospan" id="kobo.1482.1"> folder of your project. </span><span class="kobospan" id="kobo.1482.2">Once implemented, the script will automatically apply these settings when importing new models. </span><span class="kobospan" id="kobo.1482.3">Feel free to customize it and add more settings as needed for </span><span><span class="kobospan" id="kobo.1483.1">your game:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1484.1">
using UnityEditor;
using UnityEngine;
public class CustomMeshPostprocessor : AssetPostprocessor
{
    void OnPreprocessModel()
    {
        ModelImporter importer = assetImporter as ModelImporter;
        importer.isReadable = false; // Set Read/Write option to disabled
        importer.meshCompression = ModelImporterMeshCompression.Medium; // Set Mesh Compression to Medium
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1485.1">Overall, optimizing</span><a id="_idIndexMarker691" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1486.1"> the import settings for models in Unity is crucial for achieving efficient memory usage and overall performance in your game. </span><span class="kobospan" id="kobo.1486.2">By carefully configuring these settings and following best practices, you can significantly enhance the user experience while maintaining optimal </span><span><span class="kobospan" id="kobo.1487.1">resource utilization.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.1488.1">Importing textures</span></h4>
<p class="calibre3"><span class="kobospan" id="kobo.1489.1">The</span><a id="_idIndexMarker692" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1490.1"> topic of importing textures is highly impactful in optimizing both game and memory performance, with notable effects extending to UI performance as well. </span><span class="kobospan" id="kobo.1490.2">The available settings are shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1491.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1492.1">.26</span></em></span><span><span class="kobospan" id="kobo.1493.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer138">
<span class="kobospan" id="kobo.1494.1"><img alt="Figure 9.26 – Texture settings" src="image/B22017_09_26.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1495.1">Figure 9.26 – Texture settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1496.1">When importing textures into Unity, two key settings that can impact performance and memory </span><a id="_idIndexMarker693" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1497.1">usage are </span><strong class="bold"><span class="kobospan" id="kobo.1498.1">Read/Write</span></strong><span class="kobospan" id="kobo.1499.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1500.1">GenerateMipMaps</span></strong><span class="kobospan" id="kobo.1501.1">. </span><span class="kobospan" id="kobo.1501.2">Let’s delve into each setting and understand </span><span><span class="kobospan" id="kobo.1502.1">their effects.</span></span></p>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1503.1">Read/Write</span></strong></span><span><span class="kobospan" id="kobo.1504.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1505.1">Performance impact</span></strong><span class="kobospan" id="kobo.1506.1">: Enabling </span><strong class="bold"><span class="kobospan" id="kobo.1507.1">Read/Write</span></strong><span class="kobospan" id="kobo.1508.1"> allows scripts to access and modify texture data at </span><a id="_idIndexMarker694" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1509.1">runtime. </span><span class="kobospan" id="kobo.1509.2">While this flexibility can be beneficial for certain features, such as dynamic texture updates or procedural generation, it comes with a performance cost. </span><span class="kobospan" id="kobo.1509.3">Each texture marked as </span><strong class="bold"><span class="kobospan" id="kobo.1510.1">Read/Write</span></strong><span class="kobospan" id="kobo.1511.1"> consumes additional memory and may require more processing power </span><span><span class="kobospan" id="kobo.1512.1">during runtime.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1513.1">Memory impact</span></strong><span class="kobospan" id="kobo.1514.1">: Textures with </span><strong class="bold"><span class="kobospan" id="kobo.1515.1">Read/Write</span></strong><span class="kobospan" id="kobo.1516.1"> enabled occupy more memory compared to those without this option. </span><span class="kobospan" id="kobo.1516.2">This is because Unity allocates space for both the texture data and an additional copy that can be modified at runtime. </span><span class="kobospan" id="kobo.1516.3">As a result, enabling </span><strong class="bold"><span class="kobospan" id="kobo.1517.1">Read/Write</span></strong><span class="kobospan" id="kobo.1518.1"> for multiple textures can lead to increased memory usage, especially on </span><span><span class="kobospan" id="kobo.1519.1">resource-constrained platforms.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1520.1">GenerateMipMaps</span></strong></span><span><span class="kobospan" id="kobo.1521.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1522.1">Performance impact</span></strong><span class="kobospan" id="kobo.1523.1">: Generating</span><a id="_idIndexMarker695" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1524.1"> MipMaps creates a series of pre-calculated texture levels (MipMaps) that improve rendering quality and performance. </span><span class="kobospan" id="kobo.1524.2">However, this process requires additional computational resources during texture import or runtime generation, impacting loading times and </span><span><span class="kobospan" id="kobo.1525.1">initial performance.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1526.1">Memory impact</span></strong><span class="kobospan" id="kobo.1527.1">: Including MipMaps increases the memory footprint of textures since each MipMap level adds to the total texture size. </span><span class="kobospan" id="kobo.1527.2">While MipMaps enhance rendering performance by providing optimized texture sampling at different distances, they also consume more memory, especially for large textures with numerous </span><span><span class="kobospan" id="kobo.1528.1">MipMap levels.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1529.1">Best practices</span></strong></span><span><span class="kobospan" id="kobo.1530.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1531.1">Read/Write</span></strong><span class="kobospan" id="kobo.1532.1">: Only enable </span><strong class="bold"><span class="kobospan" id="kobo.1533.1">Read/Write</span></strong><span class="kobospan" id="kobo.1534.1"> for textures that require runtime modification or dynamic updates. </span><span class="kobospan" id="kobo.1534.2">For static textures used as sprites, backgrounds, or UI elements, disable </span><strong class="bold"><span class="kobospan" id="kobo.1535.1">Read/Write</span></strong><span class="kobospan" id="kobo.1536.1"> to conserve memory and </span><span><span class="kobospan" id="kobo.1537.1">improve performance.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1538.1">GenerateMipMaps</span></strong><span class="kobospan" id="kobo.1539.1">: Use </span><strong class="bold"><span class="kobospan" id="kobo.1540.1">GenerateMipMaps</span></strong><span class="kobospan" id="kobo.1541.1"> for textures that will benefit from improved rendering quality and performance, such as textures used for 3D models or distant terrain. </span><span class="kobospan" id="kobo.1541.2">Consider the trade-off between enhanced visual fidelity and increased memory usage when deciding whether to </span><span><span class="kobospan" id="kobo.1542.1">include MipMaps.</span></span></li>
</ul>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1543.1">Choosing the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1544.1">right settings</span></strong></span><span><span class="kobospan" id="kobo.1545.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1546.1">Evaluate the specific</span><a id="_idIndexMarker696" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1547.1"> requirements of each texture in your project. </span><span class="kobospan" id="kobo.1547.2">Enable </span><strong class="bold"><span class="kobospan" id="kobo.1548.1">Read/Write</span></strong><span class="kobospan" id="kobo.1549.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1550.1">GenerateMipMaps</span></strong><span class="kobospan" id="kobo.1551.1"> judiciously based on whether the texture needs runtime modification and whether MipMaps are necessary for </span><span><span class="kobospan" id="kobo.1552.1">optimized rendering.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1553.1">Regularly monitor the memory usage and performance impact of textures with different settings to optimize resource utilization and maintain efficient </span><span><span class="kobospan" id="kobo.1554.1">runtime behavior.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1555.1">In conclusion, managing </span><strong class="bold"><span class="kobospan" id="kobo.1556.1">Read/Write</span></strong><span class="kobospan" id="kobo.1557.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.1558.1">GenerateMipMaps</span></strong><span class="kobospan" id="kobo.1559.1"> settings when you’re importing textures into Unity is crucial for balancing performance, memory usage, and visual quality. </span><span class="kobospan" id="kobo.1559.2">Selecting the appropriate settings based on the intended usage of each texture helps optimize resource allocation and enhances overall </span><span><span class="kobospan" id="kobo.1560.1">application performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1561.1">Another aspect to</span><a id="_idIndexMarker697" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1562.1"> consider is compression settings, which vary based on the target platform, each with its unique configurations. </span><span class="kobospan" id="kobo.1562.2">While specific platform settings are extensive and platform-dependent, there are some general tips for </span><span><span class="kobospan" id="kobo.1563.1">optimizing compression.</span></span></p>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1564.1">Maximum size</span></strong></span><span><span class="kobospan" id="kobo.1565.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1566.1">Adjusting </span><a id="_idIndexMarker698" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1567.1">the maximum size of textures determines their dimensions upon import. </span><span class="kobospan" id="kobo.1567.2">Higher resolutions offer better visual quality but consume more memory. </span><span class="kobospan" id="kobo.1567.3">Consider the device’s capabilities and the texture’s intended use to strike a balance between quality </span><span><span class="kobospan" id="kobo.1568.1">and performance.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1569.1">Best practice</span></strong><span class="kobospan" id="kobo.1570.1">: Set the maximum size based on the target platform and the texture’s role in the game. </span><span class="kobospan" id="kobo.1570.2">Use lower resolutions for background elements or distant objects to </span><span><span class="kobospan" id="kobo.1571.1">conserve memory.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1572.1">Resize algorithm</span></strong></span><span><span class="kobospan" id="kobo.1573.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1574.1">The </span><a id="_idIndexMarker699" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1575.1">resize algorithm dictates how textures are scaled when their dimensions exceed the maximum size. </span><span class="kobospan" id="kobo.1575.2">Different algorithms may impact image quality and </span><span><span class="kobospan" id="kobo.1576.1">memory usage.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1577.1">Best practice</span></strong><span class="kobospan" id="kobo.1578.1">: Choose an algorithm that suits the texture type. </span><span class="kobospan" id="kobo.1578.2">Use sharper algorithms for detailed textures and smoother ones for gradients or patterns to </span><span><span class="kobospan" id="kobo.1579.1">preserve quality.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1580.1">Format</span></strong></span><span><span class="kobospan" id="kobo.1581.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1582.1">Texture format determines how the image data is stored, impacting compression, memory usage, and visual fidelity. </span><span class="kobospan" id="kobo.1582.2">Common formats include PNG, JPG, and TGA, each with its compression levels and </span><span><span class="kobospan" id="kobo.1583.1">quality trade-offs.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1584.1">Best practice</span></strong><span class="kobospan" id="kobo.1585.1">: Select a </span><a id="_idIndexMarker700" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1586.1">format based on the texture’s content and usage. </span><span class="kobospan" id="kobo.1586.2">Use PNG for lossless quality, JPG for photographic textures with compression, and TGA for high-quality images </span><span><span class="kobospan" id="kobo.1587.1">with transparency.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1588.1">Compression</span></strong></span><span><span class="kobospan" id="kobo.1589.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1590.1">Compression</span><a id="_idIndexMarker701" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1591.1"> methods reduce texture size and memory footprint. </span><span class="kobospan" id="kobo.1591.2">Unity offers options such as </span><strong class="bold"><span class="kobospan" id="kobo.1592.1">Normal Quality</span></strong><span class="kobospan" id="kobo.1593.1">, </span><strong class="bold"><span class="kobospan" id="kobo.1594.1">High Quality</span></strong><span class="kobospan" id="kobo.1595.1">, and </span><strong class="bold"><span class="kobospan" id="kobo.1596.1">Low Quality</span></strong><span class="kobospan" id="kobo.1597.1"> for compression, each affecting image quality and memory </span><span><span class="kobospan" id="kobo.1598.1">usage differently.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1599.1">Best practice</span></strong><span class="kobospan" id="kobo.1600.1">: Choose compression settings based on performance requirements and visual standards. </span><span class="kobospan" id="kobo.1600.2">Use higher-quality compression for critical textures and lower quality for background or </span><span><span class="kobospan" id="kobo.1601.1">non-critical elements.</span></span></li>
</ul>
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.1602.1">Crunch compression</span></strong></span><span><span class="kobospan" id="kobo.1603.1">:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1604.1">Crunch compression is an additional method to further reduce texture file sizes while </span><a id="_idIndexMarker702" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1605.1">maintaining acceptable quality. </span><span class="kobospan" id="kobo.1605.2">It’s beneficial for optimizing memory usage, especially on </span><span><span class="kobospan" id="kobo.1606.1">resource-constrained platforms.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1607.1">Best practice</span></strong><span class="kobospan" id="kobo.1608.1">: Enable crunch compression for textures where file size reduction is crucial, such as UI elements or frequently used textures. </span><span class="kobospan" id="kobo.1608.2">Balance the compression level to preserve visual quality while minimizing </span><span><span class="kobospan" id="kobo.1609.1">memory impact.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1610.1">Remember, these</span><a id="_idIndexMarker703" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1611.1"> settings may vary in impact based on the platform, so testing and iteration are key. </span><span class="kobospan" id="kobo.1611.2">Regularly monitor memory usage and performance metrics to fine-tune texture settings for optimal results on each </span><span><span class="kobospan" id="kobo.1612.1">target platform.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1613.1">By carefully configuring importing settings, you can reduce memory usage and improve overall performance in your </span><span><span class="kobospan" id="kobo.1614.1">Unity project.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1615.1">Another crucial technique for memory optimization in Unity is utilizing </span><span><span class="kobospan" id="kobo.1616.1">sprite atlases.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.1617.1">Sprite Atlases</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.1618.1">Sprite Atlases in Unity</span><a id="_idIndexMarker704" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1619.1"> are essential tools for optimizing memory and performance, especially for UI elements. </span><span class="kobospan" id="kobo.1619.2">They allow you to combine multiple sprites into a single image, reducing draw calls and texture memory usage. </span><span class="kobospan" id="kobo.1619.3">Let’s learn how to use Sprite Atlases effectively while considering their best practices and impact on memory </span><span><span class="kobospan" id="kobo.1620.1">and performance.</span></span></p>
<h4 class="calibre17"><span class="kobospan" id="kobo.1621.1">Creating a Sprite Atlas</span></h4>
<p class="callout-heading"><span class="kobospan" id="kobo.1622.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1623.1">Make sure you have the </span><strong class="bold"><span class="kobospan" id="kobo.1624.1">2D Sprite</span></strong><span class="kobospan" id="kobo.1625.1"> package installed in your project via </span><span><strong class="bold"><span class="kobospan" id="kobo.1626.1">Package Manager</span></strong></span><span><span class="kobospan" id="kobo.1627.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1628.1">In</span><a id="_idIndexMarker705" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1629.1"> your </span><strong class="bold"><span class="kobospan" id="kobo.1630.1">Project</span></strong><span class="kobospan" id="kobo.1631.1"> tab, right-click and select </span><strong class="bold"><span class="kobospan" id="kobo.1632.1">Create</span></strong><span class="kobospan" id="kobo.1633.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1634.1">2D</span></strong><span class="kobospan" id="kobo.1635.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1636.1">Sprite Atlas</span></strong><span class="kobospan" id="kobo.1637.1">, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1638.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1639.1">.27</span></em></span><span><span class="kobospan" id="kobo.1640.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer139">
<span class="kobospan" id="kobo.1641.1"><img alt="Figure 9.27 – Sprite Atlas" src="image/B22017_09_27.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1642.1">Figure 9.27 – Sprite Atlas</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1643.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1644.1">Make sure you’ve enabled the </span><strong class="bold"><span class="kobospan" id="kobo.1645.1">Sprite Packer</span></strong><span class="kobospan" id="kobo.1646.1"> option in </span><strong class="bold"><span class="kobospan" id="kobo.1647.1">Edit</span></strong><span class="kobospan" id="kobo.1648.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1649.1">Project Settings</span></strong><span class="kobospan" id="kobo.1650.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.1651.1">Editor</span></strong><span class="kobospan" id="kobo.1652.1"> so that you can start using </span><span><span class="kobospan" id="kobo.1653.1">this package.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1654.1">Enable </span><strong class="bold"><span class="kobospan" id="kobo.1655.1">Sprite Packer</span></strong><span class="kobospan" id="kobo.1656.1">, as</span><a id="_idIndexMarker706" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1657.1"> shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1658.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1659.1">.28</span></em></span><span><span class="kobospan" id="kobo.1660.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer140">
<span class="kobospan" id="kobo.1661.1"><img alt="Figure 9.28 – Enabling Sprite Packer in Project Settings" src="image/B22017_09_28.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1662.1">Figure 9.28 – Enabling Sprite Packer in Project Settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1663.1">After </span><a id="_idIndexMarker707" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1664.1">creating the sprite atlas, navigate to it to begin adding textures. </span><span class="kobospan" id="kobo.1664.2">Click on the </span><strong class="bold"><span class="kobospan" id="kobo.1665.1">+</span></strong><span class="kobospan" id="kobo.1666.1"> sign to select individual textures or a folder containing textures. </span><span class="kobospan" id="kobo.1666.2">Then, click on </span><strong class="bold"><span class="kobospan" id="kobo.1667.1">Pack Preview</span></strong><span class="kobospan" id="kobo.1668.1"> to combine them into an atlas file, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.1669.1">Figure 9</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.1670.1">.29</span></em></span><span><span class="kobospan" id="kobo.1671.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer141">
<span class="kobospan" id="kobo.1672.1"><img alt="Figure 9.29 – Sprite Atlas settings" src="image/B22017_09_29.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1673.1">Figure 9.29 – Sprite Atlas settings</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1674.1">Here are </span><a id="_idIndexMarker708" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1675.1">some best practices you </span><span><span class="kobospan" id="kobo.1676.1">should consider:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.1677.1">Merge frequently used sprites into a single Sprite Atlas to minimize draw calls and </span><span><span class="kobospan" id="kobo.1678.1">enhance performance</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1679.1">Use the packing options in the </span><strong class="bold"><span class="kobospan" id="kobo.1680.1">Sprite Packer</span></strong><span class="kobospan" id="kobo.1681.1"> window to optimize how sprites are packed within the atlas, minimizing </span><span><span class="kobospan" id="kobo.1682.1">wasted space</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.1683.1">Avoid including excessively large sprites or unnecessary sprites in the atlas to keep the atlas’ </span><span><span class="kobospan" id="kobo.1684.1">size manageable</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1685.1">Sprite Atlases have </span><a id="_idIndexMarker709" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1686.1">an impact on memory and performance. </span><span class="kobospan" id="kobo.1686.2">Let’s take a </span><span><span class="kobospan" id="kobo.1687.1">closer look:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1688.1">Memory</span></strong><span class="kobospan" id="kobo.1689.1">: Sprite Atlases help conserve memory by reducing the number of individual textures that are loaded into memory. </span><span class="kobospan" id="kobo.1689.2">However, be mindful of the total size of the Sprite Atlas as it still occupies memory based on its dimensions </span><span><span class="kobospan" id="kobo.1690.1">and content.</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.1691.1">Performance</span></strong><span class="kobospan" id="kobo.1692.1">: Sprite Atlases improve performance by reducing the number of draw calls required to render UI elements. </span><span class="kobospan" id="kobo.1692.2">This is especially beneficial for complex UIs with </span><span><span class="kobospan" id="kobo.1693.1">numerous sprites.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1694.1">Sprite Atlases primarily affect UI elements in terms of memory and performance. </span><span class="kobospan" id="kobo.1694.2">They are designed to optimize the rendering of 2D graphics, so their impact on other aspects of your game, such as 3D models or audio, is minimal. </span><span class="kobospan" id="kobo.1694.3">However, for UI-heavy games or applications, properly utilizing Sprite Atlases can significantly enhance performance and </span><span><span class="kobospan" id="kobo.1695.1">memory management.</span></span></p>
<h1 id="_idParaDest-149" class="calibre5"><a id="_idTextAnchor156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1696.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1697.1">In this chapter, we embarked on a journey to optimize our game’s performance using Unity’s powerful profiling tools. </span><span class="kobospan" id="kobo.1697.2">Building upon the skills we’ve already acquired, we delved into an introduction to Unity profiling tools, reinforcing our ability to identify performance bottlenecks and apply optimization techniques to significantly enhance our game’s performance. </span><span class="kobospan" id="kobo.1697.3">This chapter further deepened our understanding of memory management and optimization, guiding us on how to effectively manage memory usage and optimize memory performance in our game. </span><span class="kobospan" id="kobo.1697.4">Through practical exercises and insights, we solidified our mastery of the Profiler, Frame Debugger, and Memory Profiler, ensuring that our game runs smoothly </span><span><span class="kobospan" id="kobo.1698.1">and efficiently.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1699.1">Looking ahead to </span><a href="B22017_10.xhtml#_idTextAnchor157" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1700.1">Chapter 10</span></em></span></a><span class="kobospan" id="kobo.1701.1">, we will discover a treasure trove of tips and tricks to enhance our Unity development skills using C#. </span><span class="kobospan" id="kobo.1701.2">The next chapter focuses on productivity-boosting shortcuts, advanced techniques and workflows, and troubleshooting common challenges in Unity development. </span><span class="kobospan" id="kobo.1701.3">We will learn how to utilize shortcuts for efficient development, apply advanced techniques to enhance our game development processes, and troubleshoot and find solutions to common challenges we may encounter. </span><span class="kobospan" id="kobo.1701.4">This chapter will equip us with valuable insights that we can implement to improve our workflow, overcome challenges, and unlock new possibilities in Unity game development </span><span><span class="kobospan" id="kobo.1702.1">using C#.</span></span></p>
</div>
</body></html>