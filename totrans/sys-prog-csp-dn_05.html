<html><head></head><body>
		<div id="_idContainer023">
			<h1 class="chapter-number" id="_idParaDest-111"><a id="_idTextAnchor111"/>5</h1>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>The One with the  Filesystem Chronicles</h1>
			<p><em class="italic">File Systems </em><span class="No-Break"><em class="italic">and IO</em></span></p>
			<p>Computers are incredible machines, but they have one downside. If the power goes off, they forget everything. If we do not want to lose our work, we must store it elsewhere. We can print data, put it on the network, or store it in permanent storage. This is the most common option. Of course, we need to have a way to get data into the CPU. We can read data from a file or a network. We can even use the keyboard to enter data. This is something that both you (a programmer) and I (a writer) are very <span class="No-Break">familiar with.</span></p>
			<p>When we are <a id="_idIndexMarker333"/>programming software, we refer to the concept of <strong class="bold">streams</strong>. A stream represents a sequence of data elements made available over time. This sequence can be stored on a disk, it can be data flowing over network wires, or it can be the state of a memory chip. Data must flow back and forth no matter what physical medium we use. This chapter handles that topic, covering streams, files, and other ways<a id="_idIndexMarker334"/> of <strong class="bold">Input and </strong><span class="No-Break"><strong class="bold">Output</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IO</strong></span><span class="No-Break">).</span></p>
			<p>One thing that we will not dive into in this chapter is the topic of networking. Networking is such a different concept that a separate chapter will deal with this topic. You can find all the low-level networking details in <a href="B20924_09.xhtml#_idTextAnchor181"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. However, the concepts of data handling over that network are the same for files and other media. So, the principles laid out here <span class="No-Break">still apply.</span></p>
			<p>In this chapter, we cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>How to work with files <span class="No-Break">using .NET</span></li>
				<li>How to use Win32 APIs to work with <span class="No-Break">the filesystem</span></li>
				<li>How to work with Directory <span class="No-Break">and Path</span></li>
				<li>Why and how we should use asynchronous  <span class="No-Break">IO</span></li>
				<li>How to use encryption <span class="No-Break">and compression</span></li>
			</ul>
			<p>We have a lot of ground to cover, so let’s <span class="No-Break">dive in!</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>To view all the code in this chapter, you can visit the following <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter05</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor114"/>File writing basics</h1>
			<p>There <a id="_idIndexMarker335"/>cannot be anything more straightforward than writing to a file, right? That’s why I think that that is a good starting point. Here is the code to <span class="No-Break">do so:</span></p>
			<pre class="source-code">
var path = System.IO.Path.GetTempPath();
var fileName = "WriteLines.txt";
var fullPath = Path.Combine(path, fileName);
File.WriteAllText(fullPath, "Hello, System Programmers");</pre>			<p>The first line gets the system <strong class="source-inline">temp</strong> path. Then we specify the filename, add that to the <strong class="source-inline">temp</strong> path, and write a line of text to <span class="No-Break">that file.</span></p>
			<p>This example is simple enough, but it already shows something useful. First, we can get to the <strong class="source-inline">temp</strong> folder quickly; we don’t have to specify where that is in our code. Second, we can combine the filename and the path without worrying about the path separator. On Windows, the parts of the path are separated by a backslash, while on Linux, this is a forward slash. The CLR figures out what it should use and uses the <span class="No-Break">correct one.</span></p>
			<p>The <strong class="source-inline">File.WriteAllText</strong> then takes that data and creates a file, opens it, writes the string, and closes the file. If the file is already there, the system <span class="No-Break">overwrites it.</span></p>
			<p>If we wanted to have a temporary filename instead of <strong class="source-inline">WriteLines.Text</strong>, the code could have been <span class="No-Break">even easier:</span></p>
			<pre class="source-code">
var path = System.IO.Path.GetTempFileName();
File.WriteAllText(path, "Hello, System Programmers");</pre>			<p>The system looks up the path for <strong class="source-inline">temp</strong> files, generates a new file with a unique filename, and uses that to write the string. The downside is that we now have no idea which file it is. We have to log that somewhere; otherwise, our <strong class="source-inline">temp</strong> folder will fill up quickly with unused files (most operating systems clean up the <strong class="source-inline">temp</strong> folder though, so no real <span class="No-Break">worries there).</span></p>
			<p>You can<a id="_idIndexMarker336"/> obviously use any folder you want. However, if you want to use some of the special folders, such as the <strong class="source-inline">Documents</strong> folder on Windows, the system can help you get to those as well. Have a look at the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
var path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
var fileName = "WriteLines.txt";
var fullPath = Path.Combine(path, fileName);
File.WriteAllText(fullPath, "Hello, System Programmers");</pre>			<p>This code looks up the location of <strong class="source-inline">My Documents</strong> on my machine and returns that so that I can write the file to that location. You can choose from a long list of special locations, all of which are part of the <strong class="source-inline">SpecialFolder</strong> enum. I will not list all of them; you can find them <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/system.environment.specialfolder?view=net-8.0</span></a><span class="No-Break">.</span></p>
			<p>This way of writing files is effortless. However, as we have seen many times before, ease comes with less control. As systems programmers, we want all the control we can get. Let’s take back <span class="No-Break">some control.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor115"/>FileStream</h2>
			<p>The static <strong class="source-inline">File</strong> class is <a id="_idIndexMarker337"/>easy to use and very convenient if you quickly want to write something to, or read something from, a file. However, it <a id="_idIndexMarker338"/>is not the fastest way. At least, it is not the fastest if we are referring to execution time. As systems programmers, we are very interested in speed, even if it means giving up on ease <span class="No-Break">of coding.</span></p>
			<p>The following example is about 20% faster than the previous one, but it does the same things. It just needs a few <span class="No-Break">more lines:</span></p>
			<pre class="source-code">
var fileName = Path.GetTempFileName();
var info = new UTF8Encoding(true).GetBytes("Hello, System Developers!");
using FileStream? fs = File.Create(fileName, info.Length);
try
{
    fs.Write(info, 0, info.Length);
}
finally
{
    fs.Close();
}</pre>			<p>This <a id="_idIndexMarker339"/>sample uses the <strong class="source-inline">FileStream</strong> that <strong class="source-inline">File.Create()</strong> returns. We can, of course, create one ourselves. Replace the line where we<a id="_idIndexMarker340"/> created the <strong class="source-inline">FileStream</strong> through <strong class="source-inline">File</strong> with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
using var fs = new FileStream(
    path: fileName,
    mode: FileMode.Create,
    access: FileAccess.Write,
    share: FileShare.None,
    bufferSize:0x1000,
    options: FileOptions.Asynchronous);</pre>			<p>I have used the most extensive overload here to show you some of the options that you can use. Most are self-explanatory, but I want to highlight two parameters: <strong class="bold">share</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">options</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Share</strong> is a flag that tells the operating system how to share the file while we use it. It has the <span class="No-Break">following options:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">None</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
						<td class="No-Table-Style">
							<p>No sharing is allowed. Any other process trying to access the file will fail to <span class="No-Break">do so.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Read</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
						<td class="No-Table-Style">
							<p>Other processes can read the file while we are still <span class="No-Break">using it.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Write</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
						<td class="No-Table-Style">
							<p>Other processes might write to the file at the <span class="No-Break">same time.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ReadWrite</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>3</p>
						</td>
						<td class="No-Table-Style">
							<p>This combines the <strong class="source-inline">Read</strong> and <span class="No-Break"><strong class="source-inline">Write</strong></span><span class="No-Break"> flags.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Delete</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>4</p>
						</td>
						<td class="No-Table-Style">
							<p>This allows requests for deletion of the file while we are <span class="No-Break">using it.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Inheritable</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">16</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The file handle is inheritable by child processes. However, this does not work on <span class="No-Break">Win32 applications.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1: Share options for files</p>
			<p>Although <a id="_idIndexMarker341"/>specifying a flag from this list might indicate that other processes can do things with our files while we use them, there is no guarantee that these other processes can actually do so. Usually, they need other permissions <span class="No-Break">as well.</span></p>
			<p><strong class="source-inline">Delete</strong> is a nice flag. It <a id="_idIndexMarker342"/>allows for deletion while we are still working with the file. That could lead to weird situations. If we create a file and specify that we allow deletion, we might write to the file while another process has already deleted it. The system does not complain and continues running. However, you will end up without that file, which means losing your data forever. Let me show you what <span class="No-Break">I mean:</span></p>
			<pre class="source-code">
using System.Text;
var fileName = Path.GetTempFileName();
var info = new UTF8Encoding(true).GetBytes("Hello fellow System Developers!");
using (var fs = new FileStream(
    path: fileName,
    mode: FileMode.Create,
    access: FileAccess.Write,
    share: FileShare.Delete, // We allow other processes to delete the                               //file.
    bufferSize: 0x1000,
    options: FileOptions.Asynchronous))
{
    try
    {
        fs.Write(info, 0, info.Length);
        Console.WriteLine($"Wrote to the file. Now try to delete it.             You can find it here:\n{fileName}");
        Console.ReadKey();
        fs.Write(info);
        Console.WriteLine("Done with all the writing");
        Console.ReadKey();
    }
    finally
    {
        fs.Close();
    }
}
Console.WriteLine("Done.");
Console.ReadKey();</pre>			<p>This example is straightforward. We will first get a temporary filename. Then, we will get the bytes that form <a id="_idIndexMarker343"/>our payload. After that, we will create an instance of the <strong class="source-inline">FileStream</strong>, setting a couple of properties as we <span class="No-Break">do so.</span></p>
			<p>One of them is the <strong class="source-inline">Share</strong> option. We have set it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">FileShare.Delete</strong></span><span class="No-Break">.</span></p>
			<p>We will write <a id="_idIndexMarker344"/>some data to the file and then pause the program. If you run it, this is the moment to take the output that tells you the name and location of the file and delete it. You should notice that you can do that. Then continue the program. As you can see, the following line writes the same data again to the file we just deleted. Nothing happens. Really, nothing happens. There are no errors, but no data is written <span class="No-Break">anywhere either.</span></p>
			<p>In most cases, this is a behavior you would want to avoid. However, maybe your use case calls for just this kind of behavior. In that case, now you know how to <span class="No-Break">do this.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor116"/>Even faster – Win32</h2>
			<p>There<a id="_idIndexMarker345"/> is a faster way to write files. If we remove the overhead of the CLR, we can write files about 20% faster. A 20% increase in speed can mean the difference between a sluggish application and one that seems lightning-fast. As<a id="_idIndexMarker346"/> usual, this comes with a price. All the good things the CLR provides us with are now in our own hands. We have to do a lot more work. However, if you are looking for the fastest way to write data to a file, the<strong class="source-inline"> </strong>Win32 approach is, again, the best way to <span class="No-Break">do this.</span></p>
			<p>We will begin by declaring <span class="No-Break">some constants:</span></p>
			<pre class="source-code">
private const uint GENERIC_WRITE = 0x40000000;
private const uint CREATE_ALWAYS = 0x00000002;
private const uint FILE_APPEND_DATA = 0x00000004;</pre>			<p><strong class="source-inline">GENERIC_WRITE</strong> tells the system that we want to write to a file. <strong class="source-inline">CREATE_ALWAYS</strong> specifies that we want to create a new file every time we call this. <strong class="source-inline">FILE_APPEND_DATA</strong> means that we want to add to the current file (which doesn’t make much sense, since we just created <span class="No-Break">the file).</span></p>
			<p>It is time to import the <span class="No-Break">Win32 APIs:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll", SetLastError = true)]
private static extern SafeFileHandle CreateFile(
    string lpFileName,
    uint dwDesiredAccess,
    uint dwShareMode,
    IntPtr lpSecurityAttributes,
    uint dwCreationDisposition,
    uint dwFlagsAndAttributes,
    IntPtr hTemplateFile);
[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool WriteFile(
    SafeFileHandle hFile,
    byte[] lpBuffer,
    uint nNumberOfBytesToWrite,
    out uint lpNumberOfBytesWritten,
    IntPtr lpOverlapped);
[DllImport("kernel32.dll", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool CloseHandle(SafeFileHandle hObject);</pre>			<p>We will <a id="_idIndexMarker347"/>import three methods from <strong class="source-inline">kernel32.dll</strong>. <strong class="source-inline">CreateFile</strong> creates a file, <strong class="source-inline">WriteFile</strong> writes to that file, and <strong class="source-inline">CloseHandle</strong> closes <a id="_idIndexMarker348"/>handles and, in our case, the handle to <span class="No-Break">the file.</span></p>
			<p>That is all we need to write. Let me show you how <span class="No-Break">that works:</span></p>
			<pre class="source-code">
public void WriteToFile(string fileName, string textToWrite)
{
    var fileHandle = CreateFile(
        fileName,
        GENERIC_WRITE,
        0,
        IntPtr.Zero,
        CREATE_ALWAYS,
        FILE_APPEND_DATA,
        IntPtr.Zero);
    if (!fileHandle.IsInvalid)
        try
        {
            var bytes = Encoding.ASCII.GetBytes(textToWrite);
            var writeResult = WriteFile(
                fileHandle,
                bytes,
                (uint)bytes.Length,
                out var bytesWritten,
                IntPtr.Zero);
        }
        finally
        {
            // Always close the handle once you are done
            CloseHandle(fileHandle);
        }
    else
        Console.WriteLine("Failed to open file.");
}</pre>			<p>With the<a id="_idIndexMarker349"/> knowledge you have right now, you should be able to follow along. We will first create a file with the correct parameters. If that works, we will get the bytes we want to write and then use <strong class="source-inline">WriteFile</strong> to do the actual writing. After that, we will close the handle. We do that in the <strong class="source-inline">finally</strong> block; handles are expensive and they lock access to the file. We want to close it so other processes can access <span class="No-Break">the file.</span></p>
			<p>You are<a id="_idIndexMarker350"/> partially correct if you think that this does not look too bad. This was very simple. However, I omitted a lot of things, such as error checking. Do you remember what I told you about performance? I said in the previous chapters that file IO takes forever compared to normal CPU operations. Thus, we must use the asynchronous approach as much as we can. You can do that with Win32, but that is pretty complex. I will not show you how to do that here, but if you do a quick search on the Win32 API, <strong class="source-inline">CreateFile</strong>, and <strong class="source-inline">FILE_FLAG_OVERLAPPED</strong>, you can find out how it all works. In short, you will have to check everything yourself. My advice is to stick to the CLR functions. We will discuss asynchronous I/O later in <span class="No-Break">this chapter.</span></p>
			<p>We have learned how to write to files and all that goes with doing that. However, that is only one part of the story. Let’s move to the other half of the equation: reading <span class="No-Break">a file.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>File reading basics</h1>
			<p>Great. We<a id="_idIndexMarker351"/> have written a file. Now we should be able to read it as well, right? Okay, let’s dive into that. We will start with a simple example: a file with some lines of text that we want to read into <span class="No-Break">a string:</span></p>
			<pre class="source-code">
public string ReadFromFile(string fileName)
{
    var text = File.ReadAllText(fileName);
    return text;
}</pre>			<p>I can’t <a id="_idIndexMarker352"/>make it simpler than this. We have the static <strong class="source-inline">ReadAllText</strong> method, which takes a filename and reads all text into the string. Then we return that. Keep in mind that not all files contain text. I even dare to say that <em class="italic">most</em> files do not contain text. They are binary. Now, technically, a <strong class="source-inline">text</strong> file is also a <strong class="source-inline">binary</strong> file. So, let’s read the file again, but now by reading the actual bytes. I use the <strong class="source-inline">FileStream</strong> this time, so we have a bit more control over what <span class="No-Break">is happening:</span></p>
			<pre class="source-code">
public string ReadWithStream(string fileName)
{
    byte[] fileContent;
    using (FileStream fs = File.OpenRead(fileName))
    {
        fileContent = new byte[fs.Length];
        fs.Read(fileContent, 0, (int)fs.Length);
        fs.Close();
    }
    return Encoding.ASCII.GetString(fileContent);
}</pre>			<p>The nice thing about the <strong class="source-inline">FileStream</strong> is that it knows the length of the stream. That means that we can allocate enough space for our array to contain all <span class="No-Break">the data.</span></p>
			<p>We will read all data through one call to <strong class="source-inline">fs.Read()</strong>, giving it the byte array, the start position <strong class="source-inline">0</strong>, and the total number of bytes to read. Again, we will close the stream when we are done <span class="No-Break">with it.</span></p>
			<p>Last, we will convert the file to a string, assuming the contents are <span class="No-Break">ASCII characters.</span></p>
			<p>This way of reading works fine if you have a relatively small file. In that case, you can read it all in <a id="_idIndexMarker353"/>one go. However, if the file is too big, you must read it <span class="No-Break">in chunks.</span></p>
			<p>For that, the <strong class="source-inline">Read()</strong> method helps you by telling you how much data it has read. You can create a loop and iterate through the <span class="No-Break">complete file.</span></p>
			<p>We can rewrite the part where we read the file <span class="No-Break">like this:</span></p>
			<pre class="source-code">
fileContent = new byte[fs.Length];
int i = 0;
int bytesRead=0;
do
{
    var myBuffer = new byte[1];
    bytesRead = fs.Read(myBuffer, 0, 1);
    if(bytesRead &gt; 0)
        fileContent[i++] = myBuffer[0];
}while(bytesRead &gt; 0);
fs.Close();</pre>			<p>This is a silly way to do this, but it illustrates my point. We will keep reading the file until we have all the data, in which case <strong class="source-inline">fs.Read()</strong> <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Reading binary data</h2>
			<p>If you have a <strong class="source-inline">binary</strong> file that <a id="_idIndexMarker354"/>you know the structure of, you can use a  <strong class="source-inline">BinaryReader</strong> <span class="No-Break">to help.</span></p>
			<p>Binary data is usually much more memory-efficient than text data. Since we, as systems programmers, are always searching for more efficient code, this is worth <span class="No-Break">looking into.</span></p>
			<p>Let’s assume that I have the following class. This doesn’t mean anything special; it is just a <span class="No-Break">data collection:</span></p>
			<pre class="source-code">
class MyData
{
    public int Id { get; set; }
    public double SomeMagicNumber { get; set; }
    public bool IsThisAGoodDataSet { get; set; }
    public MyFlags SomeFlags { get; set; }
    public string? SomeText { get; set; }
}
[Flags]
public enum MyFlags
{
    FlagOne,
    FlagTwo,
    FlagThree
}</pre>			<p>Let us <a id="_idIndexMarker355"/>assume that I have created an instance of this class with the properties <strong class="source-inline">42</strong>, <strong class="source-inline">3.1415</strong>, <strong class="source-inline">True</strong>, <strong class="source-inline">MyFlags.One | MyFlags.Three</strong> and <strong class="source-inline">Hello, Systems Programmers</strong>. I can write it to a file using JSON serialization. That results in a file of 114 bytes. If I use a binary format, I can shrink it down to 44 bytes. That is a considerable saving, especially when putting that data on <span class="No-Break">a network.</span></p>
			<p>Reading that file is straightforward using the <strong class="source-inline">BinaryReader</strong> class. Let me <span class="No-Break">show you:</span></p>
			<pre class="source-code">
public MyData Read(string fileName)
{
    var myData = new MyData();
    using var fs = File.OpenRead(fileName);
    try
    {
        using BinaryReader br = new(fs);
        myData.Id = br.ReadInt32();
        myData.IsThisAGoodDataSet = br.ReadBoolean();
        myData.SomeMagicNumber = br.ReadDouble();
        myData.SomeFlags = (MyFlags)br.ReadInt32();
        myData.SomeText = br.ReadString();
    }
    finally
    {
        fs.Close();
    }
    return myData;
}</pre>			<p>Doing it this<a id="_idIndexMarker356"/> way means that you have to be very careful. You have to know the structure of the file precisely. You are responsible for getting all data in the correct order and knowing each field’s type exactly. However, doing it this way ensures efficiency and can save you many <span class="No-Break">CPU cycles.</span></p>
			<p>We now know all about how to read and write files. However, files are not the only things we can find in file systems. We need a way to organize all those files. That brings us to the next topic in <span class="No-Break">IO: directories!</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Directory operations</h1>
			<p>Imagine having <a id="_idIndexMarker357"/>a file system with one root folder. All files on your drive are stored there. You would have a tough time finding all your files. Luckily, operating systems all support the notion of folders or directories. The CLR helps us by giving us two classes to work with paths, folders, and directories: <strong class="bold">Path</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Directory</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>The Path class</h2>
			<p><strong class="source-inline">Path</strong> is a<a id="_idIndexMarker358"/> class that has helper methods for dealing with<a id="_idIndexMarker359"/> paths. With <strong class="source-inline">Path</strong>, I mean the string that denotes the name of a directory. You should use the <strong class="source-inline">Directory</strong> class when dealing with the actual directory <span class="No-Break">and files.</span></p>
			<p>We have already seen the <strong class="source-inline">Path</strong> class in previous samples. I used it to get a temporary filename and the name of the <strong class="source-inline">Documents</strong> folder. I also used it to combine a path and a filename to avoid dealing with path <span class="No-Break">separators myself.</span></p>
			<p>There are quite a few handy<a id="_idIndexMarker360"/> methods and properties in the <strong class="source-inline">Path</strong> class. You can see some of the most-used ones in the <span class="No-Break">following table.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-4">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.Combine</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Combines two or more strings into <span class="No-Break">a path</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ath.GetFileName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the filename and extension of the specified <span class="No-Break">path string</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetFileNameWithoutExtension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the filename of the specified path string without <span class="No-Break">the extension</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetExtension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the extension (including the period) of the specified <span class="No-Break">path string</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetDirectoryName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the directory information for the specified <span class="No-Break">path string</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetFullPath</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Converts a relative path to an <span class="No-Break">absolute path</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetTempPath</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the path to the system’s <span class="No-Break">temporary folder</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetRandomFileName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a random filename that is not already <span class="No-Break">in use</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetInvalidFileNameChars</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an array of characters that are not allowed in filenames on the <span class="No-Break">current platform</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.GetInvalidPathChars</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an array of characters that are not allowed in path strings on the <span class="No-Break">current platform</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.ChangeExtension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Changes the extension of a <span class="No-Break">file path</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.HasExtension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether a path includes a <span class="No-Break">filename extension</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.IsPathRooted</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets a value indicating whether the specified path string contains <span class="No-Break">a root</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Path.DirectorySeparatorChar</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A platform-specific separator character that is used in <span class="No-Break">path strings</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2: The Path class and its methods and properties</p>
			<p>As you can see, the <strong class="source-inline">Path</strong> class <a id="_idIndexMarker361"/>has a set of nice and convenient helpers. We will encounter them again when we investigate other platforms, but for now, please remember to use them as much <span class="No-Break">as possible.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor121"/>The Directory class</h2>
			<p>The <strong class="source-inline">Directory</strong> class<a id="_idIndexMarker362"/> deals with the actual directory in <a id="_idIndexMarker363"/>your filesystem. This class works closely with the <strong class="source-inline">Path</strong> class. If you need to specify the directory’s name (and thus its location), you would use the <span class="No-Break"><strong class="source-inline">Path</strong></span><span class="No-Break"> class.</span></p>
			<p>Let’s assume that we want to list all images in our <strong class="source-inline">Pictures</strong> folder on our Windows machine. You would do that <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var imagesPath =
Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
string[] allFiles =
    Directory.GetFiles(
        path: imagesPath,
        searchPattern: "*.jPg",
        searchOption: SearchOption.AllDirectories);
foreach (string file in allFiles)
{
    Console.WriteLine(file);
}</pre>			<p>I use <strong class="source-inline">Environment.SpecialFolder.MyPictures</strong> here to identify the folder that has all <a id="_idIndexMarker364"/>my pictures. The actual path depends on your operating system, the username, and how you have set up your machine. That means there are a lot of possible <a id="_idIndexMarker365"/>variations, but we need not bother much about that. Let the operating system figure that out, as long as we get the <span class="No-Break">correct folder.</span></p>
			<p>I used the <strong class="source-inline">Directory.GetFiles()</strong> method to iterate through that folder. I want all the JPEG images I have collected in all subfolders. Notice how I spelled the extension in the <strong class="source-inline">searchPattern</strong> variable: <strong class="source-inline">*.jPg</strong>. On Windows, filenames are not case-sensitive. On Linux, they are. So, on a Linux-based machine, this would not work. Okay, it will work, but it does not return all the files you might expect to get. Unfortunately, <strong class="source-inline">GetFiles()</strong> cannot set up a filter for case insensitivity. If you want to get all JPG images, no matter what their extensions look like, you have to do this <span class="No-Break">another way:</span></p>
			<pre class="source-code">
var regex = new Regex(@"\.jpe?g$", RegexOptions.IgnoreCase);
var allFiles =
    Directory.EnumerateFiles(imagesPath)
        .Where(file =&gt; regex.IsMatch(file));</pre>			<p>I have created a <a id="_idIndexMarker366"/>regular expression here, saying I want to filter on strings that end in <strong class="source-inline">.jpg</strong> or <strong class="source-inline">jpeg</strong> and ignore the case. Then I use <strong class="source-inline">Directory.EnumerateFiles()</strong> and apply the <strong class="source-inline">Where()</strong> LINQ operator to apply the <span class="No-Break"><strong class="source-inline">regex</strong></span><span class="No-Break"> filter.</span></p>
			<p>This method works fine on all platforms. You could have avoided the <strong class="source-inline">regex</strong> filter by using the following code, which is more verbose but, I assume, more readable to <span class="No-Break">many people:</span></p>
			<pre class="source-code">
var files = Directory.EnumerateFiles(imagesPath)
    .Where(file =&gt; file.EndsWith(".jpg",
StringComparison.OrdinalIgnoreCase) ||
                   file.EndsWith(".jpeg",
StringComparison.OrdinalIgnoreCase));</pre>			<p>I have collected <a id="_idIndexMarker367"/>the most-used methods and properties of the <strong class="source-inline">Directory</strong> class <a id="_idIndexMarker368"/>for you in the <span class="No-Break">following table:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-3">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method </strong><span class="No-Break"><strong class="bold">or property</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.CreateDirectory</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates all directories and subdirectories in the specified path unless they <span class="No-Break">already exist</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory. Delete</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes the specified directory and, optionally, any subdirectories and files in <span class="No-Break">the directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.Exists</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Determines whether the given path refers to an existing directory on <span class="No-Break">the disk</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetCurrentDirectory</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the current working directory of <span class="No-Break">the application</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetDirectories</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the names of subdirectories (including their paths) in the <span class="No-Break">specified directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetFiles</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the names of files (including their paths) in the <span class="No-Break">specified directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetFileSystemEntries</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the names of all the files and subdirectories in a <span class="No-Break">specified directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetLastAccessTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the date and time when the specified file or directory was <span class="No-Break">last accessed</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetLastWriteTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the date and time when the specified file or directory was last <span class="No-Break">written to</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.GetParent</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves the parent directory of the specified path, including both absolute and <span class="No-Break">relative paths</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.Move</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves a file or a directory and its contents to a <span class="No-Break">new location</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.SetCreationTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the creation date and time for the specified file <span class="No-Break">or directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.SetCurrentDirectory</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the application’s current working directory to the <span class="No-Break">specified directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.SetLastAccessTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the date and time when the specified file or directory was <span class="No-Break">last accessed</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Directory.SetLastWriteTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sets the date and time when the specified file or directory was last <span class="No-Break">written to</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.3: The methods and properties of the Directory class</p>
			<p>The <strong class="source-inline">Directory</strong> has <a id="_idIndexMarker369"/>some nice helpers and properties. You<a id="_idIndexMarker370"/> could figure out all of these properties yourself, but why bother if the CLR is friendly enough to help you? These properties will also be beneficial when we move to other platforms <span class="No-Break">later on.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>The DirectoryInfo class</h2>
			<p>There is <a id="_idIndexMarker371"/>one more <a id="_idIndexMarker372"/>class I want to discuss: the <strong class="source-inline">DirectoryInfo</strong> class. The difference between <strong class="source-inline">Directory</strong> and <strong class="source-inline">DirectoryInfo</strong> is that the former uses static methods, whereas the latter is used as an instance. <strong class="source-inline">Directory</strong> returns information about directories as strings. <strong class="source-inline">DirectoryInfo</strong> returns objects with much more information. Let me give you <span class="No-Break">an example:</span></p>
			<pre class="source-code">
var imagesPath = Environment.GetFolderPath(
    Environment.SpecialFolder.MyPictures);
var directoryInfo = new DirectoryInfo(imagesPath);
Console.WriteLine(directoryInfo.FullName);
Console.WriteLine(directoryInfo.CreationTime);
Console.WriteLine(directoryInfo.Attributes);</pre>			<p>I created an instance of the <strong class="source-inline">DirectoryInfo</strong> class and gave it the path to our <strong class="source-inline">images</strong> folder. This instance has a lot of valuable properties, such as the full name, time of creation, attributes, and many more. I have listed the most-used properties and methods in <a id="_idIndexMarker373"/>the <span class="No-Break">following table.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table004-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Method </strong><span class="No-Break"><strong class="bold">or property</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Create</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Creates <span class="No-Break">a directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Delete</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes this instance of a <strong class="source-inline">DirectoryInfo</strong>, specifying whether to delete subdirectories <span class="No-Break">and files</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Exists</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets a value indicating whether the <span class="No-Break">directory exists</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Extension</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the string representing the extension part of <span class="No-Break">the directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.FullName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the full path of the directory <span class="No-Break">or file</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the name of this <span class="No-Break"><strong class="source-inline">DirectoryInfo</strong></span><span class="No-Break"> instance</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Parent</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the parent directory of a <span class="No-Break">specified subdirectory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Root</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gets the root portion of <span class="No-Break">a path</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.GetFiles</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a file list from the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.GetDirectories</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns the subdirectories of the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.GetFileSystemInfos</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves an array of <strong class="source-inline">FileSystemInfo</strong> objects representing the files and subdirectories of the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.MoveTo</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Moves a <strong class="source-inline">DirectoryInfo</strong> instance and its contents to a <span class="No-Break">new path</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Refresh</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Refreshes the state of <span class="No-Break">the object</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.EnumerateFiles</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of file information in the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.EnumerateDirectories</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of directory information in the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryInfo.Enumerate FileSystemInfos</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns an enumerable collection of file system information in the <span class="No-Break">current directory</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.4: DirectoryInfo properties and methods</p>
			<p>As you <a id="_idIndexMarker374"/>can see, <strong class="source-inline">Path</strong>, <strong class="source-inline">Directory</strong>, and <strong class="source-inline">DirectoryInfo</strong> can <a id="_idIndexMarker375"/>greatly help when dealing <span class="No-Break">with files.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/>File system monitoring</h1>
			<p>As<a id="_idIndexMarker376"/> systems programmers, we must find ways to communicate with our apps. After all, there is no user interface wherein the user can indicate their <span class="No-Break">desired actions.</span></p>
			<p>Most apps in that category listen to network ports or have other ways for systems to communicate with them. One of those ways is to wait for changes in files <span class="No-Break">or directories.</span></p>
			<p>Keeping an eye on files or folders is a fairly common scenario. For instance, we could build a system that processes the files that we get through an email system. As soon as a file is delivered as an attachment, the mail client places it in a directory and our system picks <span class="No-Break">it up.</span></p>
			<p>This means that we need to have a way to keep an eye on that folder. Luckily, that is not too hard to do. It does require some explanation, so let me walk you <span class="No-Break">through it.</span></p>
			<p>We will begin with the class that other classes <span class="No-Break">interact with:</span></p>
			<pre class="source-code">
internal class MyFolderWatcher : Idisposable
{
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            // Dispose managed state (managed objects).
        }
    }
     ~MyFolderWatcher()
    {
        Dispose(false);
    }
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
}</pre>			<p>We will need to <a id="_idIndexMarker377"/>clean up some resources later, so I have implemented the <strong class="source-inline">IDisposable</strong> interface here. The class that we need to clean up is an instance of the <strong class="source-inline">FileSystemWatcher</strong> type. This class, when instantiated, keeps an eye on a folder and, optionally, a filter for the filenames. If something of interest happens there, the <strong class="source-inline">FileSystemWatcher</strong> notifies us. It is up to us to define what “something of <span class="No-Break">interest” means.</span></p>
			<p>Let’s set it up as a private member of <span class="No-Break">our class:</span></p>
			<pre class="source-code">
private FileSystemWatcher? _watcher;</pre>			<p>We could change our <strong class="source-inline">Dispose</strong>(bool disposing) method to clean this up, but I will hold on to that for now. We need to do more than just dispose of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FileSystemWatcher</strong></span><span class="No-Break">.</span></p>
			<p>A <strong class="source-inline">FileSystemWatcher</strong> is resource-intensive. Keeping an eye on a folder can lead to much CPU pressure. Therefore, we must be sure to only enable it when we <span class="No-Break">need it.</span></p>
			<p>Then, we will add a method that enables the watcher and set <span class="No-Break">some settings:</span></p>
			<pre class="source-code">
public void SetupWatcher(string pathToWatch)
{
    if(_watcher != null)
        throw new InvalidOperationException(
            "The watcher has already been set up");
    if(!Path.Exists(pathToWatch))
        throw new ArgumentOutOfRangeException(
            nameof(pathToWatch),
            "The path does not exist");
    // Set the folder to keep an eye on
    _watcher = new FileSystemWatcher(pathToWatch);
    // We only want notifications when a file is created or
    // when it has changed.
    _watcher.NotifyFilter =
        NotifyFilters.FileName |
        NotifyFilters.LastWrite;
    // Set the callbacks
    _watcher.Created += WatcherCallback;
    _watcher.Changed += WatcherCallback;
    // Start watching
    _watcher.EnableRaisingEvents = true;
}</pre>			<p>We will start <a id="_idIndexMarker378"/>with two checks. First, we will see whether the watcher has not already been created. If it has, we will throw an error. The second is to check whether the supplied path exists <span class="No-Break">or not.</span></p>
			<p>If those two checks both pass, we will create an instance of the <strong class="source-inline">FileSystemWatcher</strong> class and give it the path we want <span class="No-Break">to monitor.</span></p>
			<p>You can specify <a id="_idIndexMarker379"/>what you want to monitor. This is controlled by the <strong class="source-inline">NotifyFilter</strong> property. This property takes an enum or a combination of the <strong class="source-inline">NotifyFilter</strong> enums. You can see what your options are in the <span class="No-Break">following table.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table005">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">NotifyFilters enum</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Attributes</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the attributes of the file <span class="No-Break">or folder</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">CreationTime</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes to the creation times of files <span class="No-Break">and directories</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">DirectoryName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the names <span class="No-Break">of directories</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">FileName</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the names <span class="No-Break">of files</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LastAccess</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes to the last access times of files <span class="No-Break">and directories</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LastWrite</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes to the last write times of files <span class="No-Break">and directories</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Security</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Monitors changes in the security settings of files <span class="No-Break">and directories</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Size</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Watches for changes in the sizes of files <span class="No-Break">and directories</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.5: NotifyFilters options</p>
			<p>I am only interested in new or changed files in our folder. So, I have given it the <strong class="source-inline">NotifyFilters.FileName</strong> | <strong class="source-inline">NotifyFilters.LastWrite</strong> value. The <strong class="source-inline">FileName</strong> of a file changes, of course, when you first create the file. I could also have chosen <strong class="source-inline">CreationTime</strong>, which hardly ever changes. I will also keep a watch on <strong class="source-inline">LastWrite</strong>, which tells me when a file <span class="No-Break">has changed.</span></p>
			<p>After this, I will<a id="_idIndexMarker380"/> give the <strong class="source-inline">_watcher</strong> a callback to call when either of the two events I care about are raised. Since all events share the same signature, I can get away with just one method. That method is what we will look at next. However, before we do that, we need to start the watcher by setting <strong class="source-inline">_watcher.EnableRaisingEvents</strong> to <strong class="source-inline">True</strong>. The next piece of code contains the body of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">eventhandler</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
private void WatcherCallback(object sender, FileSystemEventArgs e)
{
    switch (e.ChangeType)
    {
        case WatcherChangeTypes.Created:
            FileAdded?.Invoke(this, new FileCreatedEventArgs                 (e.FullPath));
            break;
        case WatcherChangeTypes.Changed:
            FileChanged?.Invoke(this, new
                FileChangedEventArgs(e.FullPath));
            break;
    }
}</pre>			<p>When the watcher calls this callback, we get an instance of the <strong class="source-inline">FileSystemEventArgs</strong> class. This class contains a field called <strong class="source-inline">ChangeType</strong> that indicates what type of change triggered this call. It also contains the full path and name of the file affected in the <span class="No-Break"><strong class="source-inline">FullPath</strong></span><span class="No-Break"> property.</span></p>
			<p>We will switch on that <strong class="source-inline">ChangeType</strong> field and call one of the two event handlers for our class. Those two event handlers that are part of our class look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public event EventHandler&lt;FileCreatedEventArgs&gt;? FileAdded;
public event EventHandler&lt;FileChangedEventArgs&gt;? FileChanged;</pre>			<p>The <strong class="source-inline">FileCreatedEventArgs</strong> and <strong class="source-inline">FileChangedEventArgs</strong> types for the <strong class="source-inline">EventHandler</strong> are straightforward as well. I could have used only one type. However, for future<a id="_idIndexMarker381"/> uses, I decided to give them distinct classes that I might extend at some point with more information. They look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public class FileCreatedEventArgs : EventArgs
{
    public FileCreatedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
    public string FilePath { get; }
}
public class FileChangedEventArgs : EventArgs
{
    public FileChangedEventArgs(string filePath)
    {
        FilePath = filePath;
    }
    public string FilePath { get; }
}</pre>			<p><strong class="source-inline">FileSystemWatcher</strong> implements <strong class="source-inline">IDisposable</strong>. So, we must dispose of it when we no longer use it. We need to rewrite our own <strong class="source-inline">Dispose(bool disposing)</strong> method to look<a id="_idIndexMarker382"/> <span class="No-Break">like this:</span></p>
			<pre class="source-code">
protected virtual void Dispose(bool disposing)
{
    if (!disposing) return;
    if (_watcher == null)
        return;
    // Stop raising events
    _watcher.EnableRaisingEvents = false;
    // Clean whoever has subscribed to us
    // to prevent memory leaks
    FileAdded = null;
    FileChanged = null;
    _watcher.Dispose();
    _watcher = null;
}</pre>			<p>After doing some checks, we will stop the system from receiving any events. Then we will clear the events. If we do not do this, other objects might hold a reference to our class and thus prevent this class from being freed <span class="No-Break">from memory.</span></p>
			<p>When that is done, we dispose of <strong class="source-inline">_watcher</strong> and set it <span class="No-Break">to null.</span></p>
			<p>That’s it. If you run it from your program, give it a folder, and attach some <strong class="source-inline">eventhandlers</strong> to it, you will be able to see what happens when you add or change files in <span class="No-Break">that folder.</span></p>
			<p>It is almost perfect. Almost – but <span class="No-Break">not quite.</span></p>
			<p>If you add a file, you will get multiple events. If you think about that, it makes sense. After all, a file is created on the file system and then it is changed immediately. If you wanted to, you could change our class to consider that. It is not hard to do, so I will leave that up <span class="No-Break">to you.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Asynchronous I/O</h1>
			<p>I have said it<a id="_idIndexMarker383"/> before, but this is so important that I have to repeat it here: IO is slow. Every piece of code that works with IO should be done asynchronously. Luckily, most of the classes in the <strong class="source-inline">System.IO</strong> namespace have asynchronous members that we can use <span class="No-Break">with async/await.</span></p>
			<p>I would be happy if Microsoft decided to mark all non-asynchronous methods in <strong class="source-inline">System.IO</strong> <span class="No-Break">as obsolete.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>The naïve approach</h2>
			<p>Most of the<a id="_idIndexMarker384"/> methods you know in <strong class="source-inline">System.IO</strong> have an asynchronous version. So, just add the <strong class="source-inline">async</strong> postfix to the method name and await <span class="No-Break">it. Simple!</span></p>
			<p>On second thought, no. It is not <span class="No-Break">that simple.</span></p>
			<p>Let me show you <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public async Task CreateBigFileNaively(string fileName)
{
    var stream = File.CreateText(fileName);
    for (int i = 0; i &lt; Int32.MaxValue; i++)
    {
            var value = $"This is line {i}";
            Console.Writeline(value);
            await stream.WriteLineAsync(value);
                await Task.Delay(10);
    }
    Console.WriteLine("Closing the stream");
    stream.Close();
    await stream.DisposeAsync();
}</pre>			<p>This method<a id="_idIndexMarker385"/> creates a file and then writes a string line to it. Once finished, it closes the file and nicely disposes of it. It does that asynchronously. So this is the way things should <span class="No-Break">be, right?</span></p>
			<p>Let’s use <span class="No-Break">this method:</span></p>
			<pre class="source-code">
var asyncSample = new AsyncSample();
await asyncSample.CreateBigFileNaively(@"c:\temp\bigFile.txt");</pre>			<p>Add these two lines to your main Console application. Run it and let it run for a few seconds. Note what line is written to the file on the screen (it should say something to the effect of <em class="italic">This is the line n</em>, where <strong class="source-inline">n</strong> is the number of the line). Then press <em class="italic">Ctrl</em> + <em class="italic">C</em> to cancel the operation. The program will stop. Now, please open the file and see how far it got. There is a big chance that you will see that the last line written on the file is not the number that you saw on <span class="No-Break">the screen.</span></p>
			<p>Why is that, you might wonder? The CLR ensures that performance is as high as possible for our code. So, all data written to a file system is buffered into a cache before it is sent to the SSD or other media. After all, writing to storage is slow. However, since we killed the process, the CLR did not have time to flush <span class="No-Break">the cache.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/>Using CancellationTokens</h2>
			<p>Of course, this<a id="_idIndexMarker386"/> would not happen often in the real world. However, you might want to cancel a long-running IO process, and then you might <span class="No-Break">encounter this.</span></p>
			<p>There is a solution to this. Remember the chapter where we talked about threads? Remember that I said that there was this thing called a <strong class="source-inline">CancellationToken</strong>? That is the one that <span class="No-Break">we need.</span></p>
			<p>Let’s rewrite<a id="_idIndexMarker387"/> the code that writes the file. Let’s remove the <strong class="source-inline">naïve</strong> from the method name; we know <span class="No-Break">better now:</span></p>
			<pre class="source-code">
public async Task CreateBigFile(string fileName, CancellationToken cancellationToken)
{
    var stream = File.CreateText(fileName);
    for (int i = 0; i &lt; Int32.MaxValue; i++)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            Console.WriteLine("We are being cancelled");
            break;
        }
        else
        {
            var value = $"This is line {i}";
            Console.WriteLine(value);
            await stream.WriteLineAsync(value);
            try
            {
                await Task.Delay(10, cancellationToken);
            }
            catch (TaskCanceledException)
            {
                Console.WriteLine("We are being cancelled");
                break;
            }
        }
    }
    Console.WriteLine("Closing the stream");
    stream.Close();
    await stream.DisposeAsync();
}</pre>			<p>We have <a id="_idIndexMarker388"/>added quite a bit of code here. Let me walk you through it. First, we added a parameter of the <strong class="source-inline">CancellationToken</strong> type to the method. We will constantly check to see whether <strong class="source-inline">Cancel</strong> has been requested in our loop. If so, we will print the message on the screen and graciously exit <span class="No-Break">the loop.</span></p>
			<p>In the <strong class="source-inline">Task.Delay()</strong>, we also passed the <strong class="source-inline">CancellationToken</strong>. After all, while the system waits for this delay, the cancellation can also be requested. However, when that happens during a <strong class="source-inline">Task.Delay()</strong>, the CLR will throw an exception of the <strong class="source-inline">TaskCanceledException</strong> type. We have to catch that to prevent our program from crashing and stopping. That’s why we have the <strong class="source-inline">try..catch</strong> block here. We need that <strong class="source-inline">try..catch</strong> block to prevent the exception from bubbling up the <span class="No-Break">call stack.</span></p>
			<p>We have to mimic breaking up the loop from the outside. Change the code that calls this method into <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var cancellationTokenSource = new
CancellationTokenSource();
ThreadPool.QueueUserWorkItem((_) =&gt;
{
    Thread.Sleep(10000);
    Console.WriteLine("About to cancel the operation");
    cancellationTokenSource.Cancel();
});
var asyncSample = new AsyncSample();
await asyncSample.CreateBigFile(
    @"c:\temp\bigFile.txt",
    cancellationTokenSource.Token);</pre>			<p>First, we <a id="_idIndexMarker389"/>will create a new <strong class="source-inline">CancellationtokenSource</strong>. Then, we will pull a thread from the <strong class="source-inline">ThreadPool</strong> and give it something to do. After waiting for 10 seconds, it will request <span class="No-Break">a cancellation.</span></p>
			<p>The call to <strong class="source-inline">CreateBigFile</strong> now has <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">CancellationTokenSource</strong></span><span class="No-Break">.</span></p>
			<p>Run it and see that it stops after 10 seconds. Notice which line it stopped on and check the actual file to see whether that was the last line written to it. On my machine, this <span class="No-Break">works nicely.</span></p>
			<p>Remember: when dealing with asynchronous file handling, no matter what you do, try to use a <strong class="source-inline">CancellationSourceToken</strong>. Also, be sure that you deal with any side effects. Be sure to clean up after the cancellation has been requested so that the CLR can properly flush the cache and clean up <span class="No-Break">its resources.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor127"/>BufferedStream</h2>
			<p>The<a id="_idIndexMarker390"/> CLR is pretty good at maximizing performance for your I/O operations. As we saw, it can cache data before writing to external devices. This caching speeds up our code since we no longer have to wait for the slow write operations to finish. However, the CLR makes an educated guess about those caches. Sometimes it gets it wrong. If we know the size of the data we want to write, we can use that knowledge to get even more performance out of <span class="No-Break">our application.</span></p>
			<p>Let’s say that we have a system that writes the following record to <span class="No-Break">the I/O:</span></p>
			<pre class="source-code">
internal readonly record struct DataRecord
{
    public int Id { get; init; }
    public DateTime LogDate { get; init; }
    public double Price { get; init; }
}</pre>			<p>This block is 24 bytes long. We can quickly determine that by adding up the sizes of <strong class="source-inline">int</strong>, <strong class="source-inline">DateTime</strong>, <span class="No-Break">and double.</span></p>
			<p>If we write that to a file, the CLR will cache it until the systems find a suitable moment to do the actual writing of the data to the storage. However, we can improve that. We can use the <strong class="source-inline">BufferedStream</strong> class to write this data to a buffer first. Then the CLR can flush that buffer to the underlying storage when it thinks it is the best time. The advantage here is that we control the size of that buffer or cache. If we specify the size just right, we will not waste memory. However, we are also not making it too small so that it flushes too often. It is just right <span class="No-Break">for us.</span></p>
			<p>The code to do that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public async Task WriteBufferedData(string fileName)
{
    var data = new DataRecord
    {
        Id = 42,
        LogDate = DateTime.UtcNow,
        Price = 12.34
    };
    await using FileStream stream = new(fileName, FileMode.CreateNew,     FileAccess.Write);
    await using BufferedStream bufferedStream = new(stream,
    Marshal.SizeOf&lt;DataRecord&gt;());
    await using BinaryWriter writer = new(bufferedStream);
    writer.Write(data.Id);
    writer.Write(data.LogDate.ToBinary());
    writer.Write(data.Price);
}</pre>			<p>First, we will create a <strong class="source-inline">FileStream</strong>. This <strong class="source-inline">FileStream</strong> is the actual handle to the file we are<a id="_idIndexMarker391"/> writing to. Then, we will create a <strong class="source-inline">BufferedStream</strong> and give it the <strong class="source-inline">FileStream</strong> and the size of the record that we want to write. After that, we will create a <strong class="source-inline">BinaryWriter</strong> to take our data and write it to the buffer as efficiently <span class="No-Break">as possible.</span></p>
			<p>When that has all been set up, we will do <span class="No-Break">the writing.</span></p>
			<p class="callout-heading">A word of warning</p>
			<p class="callout">If you are not sure of the size of the data, having a <strong class="source-inline">BufferedStream</strong> might work against you. <strong class="source-inline">BufferedStream</strong> works best if you are doing a lot of smaller, frequent writes of data that you know the size of. Otherwise, the cache management is best left to <span class="No-Break">the CLR.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>File system security</h1>
			<p>Files are<a id="_idIndexMarker392"/> where we store things. Those things might not be for everybody to see. Sometimes, we must hide data or ensure that only programs that we trust can access it. OSs can help. Every OS has a way of handling access to files and directories. You can generally allow or disallow read- or write access <span class="No-Break">to them.</span></p>
			<p>However, what happens when you want to share files? Let us assume that you want to transfer data over a wire or store it on another drive such as a removable USB drive. In that case, ensuring that level of security is quite challenging. This means that you might have to encrypt data to prevent it from <span class="No-Break">being abused.</span></p>
			<p class="callout-heading">Security – a topic of its own</p>
			<p class="callout">I am only covering the basics of security and encryption here. This is not a complete guide to this complicated and extensive topic. There have been hundreds of books written on this topic alone. I want you to know that you can do security and encryption. However, if you want to take this seriously, I suggest that you go out and find a few good resources on those topics and learn <span class="No-Break">from there.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor129"/>Encryption basics</h2>
			<p>Basically, we<a id="_idIndexMarker393"/> have two encryption flavors: <strong class="bold">symmetric</strong> and <strong class="bold">asymmetric</strong> algorithms. Although<a id="_idIndexMarker394"/> there are many<a id="_idIndexMarker395"/> similarities between them, one big difference is in how they <span class="No-Break">handle keys.</span></p>
			<p>Let’s discuss an elementary sample. We’ll say that you have a message and want to transmit it to someone else. Since the contents of the message are sensitive, you do not want anyone else to be able to read it, so you decided to encrypt it. That means that you will change the contents of your message so that nobody can make any sense of it. The recipient then decrypts it to change your text into something intelligible. We call the text that people can actually read and <a id="_idIndexMarker396"/>understand <strong class="bold">cleartext</strong>. In contrast, the encrypted, unreadable text is something<a id="_idIndexMarker397"/> we call <strong class="bold">ciphertext</strong>. People read cleartext; ciphertext <span class="No-Break">needs decrypting.</span></p>
			<p>This way of protecting information is not new. Julius Caesar did such a thing over 2,000 years ago. He used a straightforward substitution algorithm. All he did was take a piece of text he wanted to send to his commanders in the field and then shift all characters left or right by a certain number of positions. The number here is what we call <span class="No-Break">his key.</span></p>
			<p>So, if Ceasar chose a key of <strong class="source-inline">3</strong>, all As in his message would become Ds. The character B would become an E, and <span class="No-Break">so on.</span></p>
			<p>If you knew the key, you could take his ciphertext and reverse the operation to get back to <span class="No-Break">the cleartext.</span></p>
			<p>The problem here is to transmit the actual number to use. Both parties need to know the key, or things never work out. You need a secure way of telling the other person which key to use so that they can decrypt your ciphertext <span class="No-Break">into cleartext.</span></p>
			<p>If you know the other person, sharing this key is not hard. You can walk up to them, give them the key on a piece of paper in a sealed envelope, and tell them to open it only when they receive the encrypted message. These days, however, that is a lot harder to do. Computers do not know the other computer they want to talk to. It is hard to exchange <span class="No-Break">keys safely.</span></p>
			<p>A possible solution for this is asymmetric encryption and decryption. This solution is complicated, but the basis is this: you have two keys. One key is used to encrypt the data and another is used to decrypt the data. One of the keys is kept private and the other is made public. The private key is yours and yours alone. You use it to encrypt a file. Anyone with the public key can then decrypt it. Of course, if you want the message to only be read by one other party, you can reverse this. You can request that the other party share their public key with you. You would then take that key and encrypt the message. Now, only the other party can decrypt it again with their <span class="No-Break">private key.</span></p>
			<p>Symmetric algorithms<a id="_idIndexMarker398"/> are much faster than asymmetric ones. However, they face the issue of key sharing. This issue is why most algorithms combine the two methods. They use an asymmetric algorithm to encrypt a key, which can be used for symmetric encryption. The key is relatively tiny, so encrypting and decrypting can be done reasonably quickly. Then that symmetric key is used to encrypt the complete message. This way, the symmetric key can be part of the message. It is encrypted itself, so only the intended recipient can decrypt the key and, thus, the rest of <span class="No-Break">the message.</span></p>
			<p>If this sounds complicated, I have some good news: the CLR has many classes to help us do this. They are pretty simple to use <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Symmetric encryption and decryption</h2>
			<p>Let’s see <a id="_idIndexMarker399"/>whether we can encrypt and decrypt<a id="_idIndexMarker400"/> a simple message in <span class="No-Break">C# code:</span></p>
			<pre class="source-code">
public static void EncryptFileSymmetric(string inputFile, string outputFile, string key)
{
    using (FileStream inputFileStream = new
    FileStream(inputFile, FileMode.Open, FileAccess.Read))
    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key);
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = keyBytes;
            aesAlg.GenerateIV();
            byte[] ivBytes = aesAlg.IV;
            outputFileStream.Write(ivBytes, 0, ivBytes.Length);
            using (CryptoStream csEncrypt = new
               CryptoStream(outputFileStream,                aesAlg.CreateEncryptor(),
                       CryptoStreamMode.Write))
            {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead =
                   inputFileStream.Read(buffer,                    0, buffer.Length)) &gt; 0)
                {
                    csEncrypt.Write(buffer, 0, bytesRead);
                }
            }
        }
    }
}</pre>			<p>This<a id="_idIndexMarker401"/> method<a id="_idIndexMarker402"/> takes the names of an input file, an output file, and a key. Then, it opens the input file, reads its contents, encrypts it, and writes the cyphertext to the <span class="No-Break">output file.</span></p>
			<p>The way this works is <span class="No-Break">pretty straightforward.</span></p>
			<p>First, we will create the two streams. Then we will take the key and generate its byte array. The key must be a 128-bit, 192-bit, or 256-bit array. In other words, it has to be 16, 24, or 32 bytes long. The longer the key, the harder it is to hack. However, a long key also slows down the encryption and decryption processes. The choice <span class="No-Break">is yours.</span></p>
			<p>We will <a id="_idIndexMarker403"/>create an<a id="_idIndexMarker404"/> instance of the <strong class="source-inline">Aes</strong> class. <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>) is <a id="_idIndexMarker405"/>widely considered a good and safe encryption algorithm. To make things even safer, the key we will use is augmented<a id="_idIndexMarker406"/> with an <strong class="bold">Initialization Vector</strong> (<strong class="bold">IV</strong>). You can think of this as something we add to the key to make it less readable. We will write that IV as the first thing in <span class="No-Break">our file.</span></p>
			<p>Then, we will create an instance of the <strong class="source-inline">CryptoStream</strong> class. This class helps us write encrypted data, as you can see in the ensuing code block. We will take arrays of bytes and write them to the <strong class="source-inline">CryptoStream</strong> class. Since we initialized the <strong class="source-inline">CryptoStream</strong> class with our AES class (well, the result of the call to <strong class="source-inline">CreateEncryptor</strong> of that class, to be more precise), it uses our key to <span class="No-Break">encrypt data.</span></p>
			<p>Decrypting is also simple. It works along the same principle: get the files from the key, read the IV from the file, then decrypt the rest and store it in a new file. That looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public static void DecryptFileSymmetric(string inputFile, string outputFile, string key)
{
    using (FileStream inputFileStream = new FileStream(inputFile,     FileMode.Open, FileAccess.Read))
    using (FileStream outputFileStream = new FileStream(outputFile,     FileMode.Create, FileAccess.Write))
    {
        byte[] keyBytes = Encoding.UTF8.GetBytes(key);
        using (Aes aesAlg = Aes.Create())
        {
            byte[] ivBytes = new byte[aesAlg.BlockSize / 8];
            inputFileStream.Read(ivBytes, 0,
               ivBytes.Length);
            aesAlg.Key = keyBytes;
            aesAlg.IV = ivBytes;
            using (CryptoStream csDecrypt =
                   new CryptoStream(outputFileStream,
                   aesAlg.CreateDecryptor(), CryptoStreamMode.Write))
            {
                byte[] buffer = new byte[4096];
                int bytesRead;
                while ((bytesRead =
                inputFileStream.Read(buffer, 0, buffer.Length)) &gt; 0)
                {
                    csDecrypt.Write(buffer, 0, bytesRead);
                }
            }
        }
    }
}</pre>			<p>Instead of <a id="_idIndexMarker407"/>getting<a id="_idIndexMarker408"/> an <strong class="source-inline">Encryptor</strong> from the <strong class="source-inline">CryptoStream</strong>, we now get a <strong class="source-inline">Decryptor</strong>. The rest should be self-explanatory <span class="No-Break">by now.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Asymmetric encryption and decryption</h2>
			<p>In the previous<a id="_idIndexMarker409"/> example, we generated a <a id="_idIndexMarker410"/>simple 128-bit, 192-bit, or 256-bit key. For instance, you can pass it a string such as <strong class="source-inline">SystemSoftware42</strong> and get the bytes. The same key is used for encrypting <span class="No-Break">and decrypting.</span></p>
			<p>For asymmetric encryption, keys are a bit harder to get. However, there are helper classes for that, so it’s not hard to do in practice. Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
public static (string, string) GenerateKeyPair()
{
    using RSA rsa = RSA.Create();
    byte[] publicKeyBytes = rsa.ExportRSAPublicKey();
    byte[] privateKeyBytes = rsa.ExportRSAPrivateKey();
    string publicKeyBase64 = Convert.ToBase64String(publicKeyBytes);
    string privateKeyBase64 = Convert.ToBase64String(privateKeyBytes);
    return (publicKeyBase64, privateKeyBase64);
}</pre>			<p>I used the <strong class="source-inline">RSA</strong> class<a id="_idIndexMarker411"/> to generate the key pair. The <strong class="bold">Rivest, Shamir, and Adleman</strong> (<strong class="bold">RSA</strong>) class was <a id="_idIndexMarker412"/>named after the three cryptographers <a id="_idIndexMarker413"/>who invented <span class="No-Break">this algorithm.</span></p>
			<p>We will create an instance of <strong class="source-inline">RSA</strong> by calling <strong class="source-inline">Create()</strong>. Then, we will call <strong class="source-inline">ExportRSAPublicKey()</strong> and <strong class="source-inline">ExportRSAPrivateKey()</strong> to get the generated keys out <span class="No-Break">of it.</span></p>
			<p>Since the keys are byte arrays, we will use <strong class="source-inline">ToBase64String()</strong> to make them more or less readable. That makes it easier to share <span class="No-Break">the keys.</span></p>
			<p>Now that we have a key pair, we can use it to encrypt a message. Of course, we can also decrypt it again. That code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public static byte[] EncryptWithPublicKey(
    byte[] data,
    byte[] publicKeyBytes)
{
    using RSA rsa = RSA.Create();
    rsa.ImportRSAPublicKey(publicKeyBytes, out _);
    return rsa.Encrypt(data, RSAEncryptionPadding.OaepSHA256);
}
public static byte[] DecryptWithPrivateKey(
    byte[] encryptedData,
    byte[] privateKeyBytes)
{
    using RSA rsa = RSA.Create();
    rsa.ImportRSAPrivateKey(privateKeyBytes, out _);
    return rsa.Decrypt(encryptedData, RSAEncryptionPadding.    OaepSHA256);
}</pre>			<p>This <a id="_idIndexMarker414"/>code is <a id="_idIndexMarker415"/>simple enough. I only want to point out the last parameter in the <strong class="source-inline">rsa.Encrypt()</strong> and <strong class="source-inline">rsa.Decrypt()</strong> methods. We will use padding here to add extra data to the results (and we will remove it again when decrypting). This padding makes it harder for attackers to try to hack <span class="No-Break">our message.</span></p>
			<p>You can use the three methods combined <span class="No-Break">like this:</span></p>
			<pre class="source-code">
(string, string) keyPair = Encryption.GenerateKeyPair();
keyPair.Item1.Dump();
keyPair.Item2.Dump();
var publicKey = Convert.FromBase64String(keyPair.Item1);
var privateKey = Convert.FromBase64String(keyPair.Item2);
string message = "This is the text that we, as System Programmers,     want to secure.";
byte[] messageBytes = Encoding.UTF8.GetBytes(message);
byte[] encryptedBytes = Encryption.EncryptWithPublicKey(messageBytes,     publicKey);
string encrypted = Encoding.UTF8.GetString(encryptedBytes);
encrypted.Dump(ConsoleColor.DarkYellow);
byte[] decryptedBytes = Encryption.    DecryptWithPrivateKey(encryptedBytes, privateKey);
string decrypted = Encoding.UTF8.GetString(decryptedBytes);
decrypted.Dump(ConsoleColor.DarkYellow);</pre>			<p>First, we will create a key pair. Our method returns that pair as strings so we can print them (I am again using our handy <strong class="source-inline">Dump()</strong> extension method). However, the keys need to be in a binary format, so I am reverting them to <span class="No-Break">byte arrays.</span></p>
			<p>I will <a id="_idIndexMarker416"/>define <a id="_idIndexMarker417"/>the message I want to encrypt, get the bytes of that message, and encrypt it. Then, I will print the encrypted message. If you do this, I think you will agree that it is hard to see the actual message. It is a mess <span class="No-Break">of characters.</span></p>
			<p>Then, we will reverse it by calling <strong class="source-inline">DecryptWithPrivateKey()</strong>. This method returns <span class="No-Break">our string.</span></p>
			<p>If we send the <strong class="source-inline">Base64</strong> version of our public key to someone and then transmit the encoded message, they can decode it with that public key. They would be sure that we sent that message; no one, other than us, can generate a message that can be decrypted by that public key but us. After all, private and public keys are a pair. You need one to encrypt so the second <span class="No-Break">can decrypt.</span></p>
			<p>Julius Caesar would be proud <span class="No-Break">of us!</span></p>
			<p>However, we have one more thing to talk about. We need to lose weight. Well, not us personally, but the payload in our files could benefit from this. Let’s talk about <span class="No-Break">file compression.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/>File compression</h1>
			<p>Files can get <a id="_idIndexMarker418"/>quite large. As we have already discussed, file IO and network IO take a long time, especially compared to CPUs’ speeds. Anything we can do to minimize the time it takes to read from or write to IO could be worth it. This is even true if it means that we must make the CPU do a lot more. Of course, you need to measure this and see whether that also applies in your situation, but sometimes, sacrificing CPU time to speed up IO can make a <span class="No-Break">huge difference.</span></p>
			<p>One of the ways to do this is by limiting the amount of data we write in a file or a network stream. That can be done <span class="No-Break">using compression.</span></p>
			<p>In the CLR, you have a choice. You can use <strong class="source-inline">DeflateStream</strong> or <strong class="source-inline">GZipStream</strong> to do this. <strong class="source-inline">GZipStream</strong> uses <strong class="source-inline">DeflateStream</strong> internally, so <strong class="source-inline">DeflateStream</strong> is obviously faster. <strong class="source-inline">GZipStream</strong>, however, produces compressed files that can be read by external software. GZip is a standardized <span class="No-Break">compression algorithm.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>Compressing some data</h2>
			<p>Let’s compress <a id="_idIndexMarker419"/>a string <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">GZipStream</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public async Task&lt;byte[]&gt; CompressString(string input,
    CancellationToken cancellationToken)
{
    // Get the payload as bytes
    byte[] data =
    System.Text.Encoding.UTF8.GetBytes(input);
    // Compress to a MemoryStream
    await using var ms = new MemoryStream();
    await using var compressionStream = new GZipStream(ms,
    CompressionMode.Compress);
    await compressionStream.WriteAsync(data, 0,
    data.Length, cancellationToken);
    await compressionStream.FlushAsync(cancellationToken);
    // Get the compressed data.
    byte[] compressedData = ms.ToArray();
    return compressedData;
}</pre>			<p>Since compression and decompression might take a long time to finish, we really should use the <strong class="source-inline">Async/Await</strong> <span class="No-Break">pattern here.</span></p>
			<p>We will take<a id="_idIndexMarker420"/> some strings that we want to compress and pass them to the input variable. I use a <strong class="source-inline">MemoryStream</strong> in this example, but you could use any stream you like. Most real-world examples use a <strong class="source-inline">FileStream</strong> of <span class="No-Break">some sort.</span></p>
			<p>I will create an instance of the <strong class="source-inline">GZipStream</strong> class and give it the <strong class="source-inline">MemoryStream</strong> instance. This memory stream is where it writes the data. I will also tell the class that I want to <span class="No-Break">compress data.</span></p>
			<p>Then I just write data to it, flush the buffers, and get the bytes out <span class="No-Break">of it.</span></p>
			<p>That’s it! I have just compressed <span class="No-Break">a string.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Decompressing some data</h2>
			<p>Decompressing <a id="_idIndexMarker421"/>is just as easy. Look at the following <span class="No-Break">code sample:</span></p>
			<pre class="source-code">
public async Task&lt;string&gt; DecompressString(byte[] input,
    CancellationToken cancellationToken)
{
    // Write the data into a memory stream
    await using var ms = new MemoryStream();
    await ms.WriteAsync(input, cancellationToken);
    await ms.FlushAsync(cancellationToken);
    ms.Position = 0;
    // Decompress
    await using var decompressionStream = new GZipStream(ms,     CompressionMode.Decompress);
    await using var resultStream = new MemoryStream();
    await decompressionStream.CopyToAsync(resultStream,     cancellationToken);
    // Convert to readable text.
    byte[] decompressedData = resultStream.ToArray();
    string decompressedString =
    System.Text.Encoding.UTF8.GetString(decompressedData);
    return decompressedString;
}</pre>			<p>Here, I used two<a id="_idIndexMarker422"/> instances of the <strong class="source-inline">MemoryStream</strong> class. I used one as the source of the data and one as the destination of the uncompressed data. Again, please use any stream <span class="No-Break">you want.</span></p>
			<p>You can use these methods <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
var cts = new CancellationTokenSource();
var myText = "This is some text that I want to compress.";
var compression = new Compression();
var compressed = await compression.CompressString(myText, cts.Token);
var decompressed = await
    compression.DecompressString(compressed, cts.Token);
decompressed.Dump(ConsoleColor.DarkYellow);</pre>			<p>That was not too hard, <span class="No-Break">was it?</span></p>
			<p>However, we are<a id="_idIndexMarker423"/> not done yet. The data that we want to store or read needs to be in a certain format. If you have a C# class with data in it, you cannot simply write that to a file. We need to translate that somehow. That’s where serialization <span class="No-Break">comes in.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/>Serialization – JSON and Binary</h1>
			<p>Earlier in this <a id="_idIndexMarker424"/>chapter, we saw how to write binary data to a stream. We can call all the <strong class="source-inline">write</strong> methods to write all sorts of types to a file. However, that can be pretty hard and also quite error-prone. You have to keep track of the format of the data. One simple mistake will make your <span class="No-Break">files unreadable.</span></p>
			<p>A better way would be to serialize your data in a format that the streams can understand. There are two ways to do that: <strong class="bold">JSON</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Binary</strong></span><span class="No-Break">.</span></p>
			<p>JSON is simple: most programming languages and platforms understand it. JSON has become the de facto standard for displaying a structure in text. In most places, JSON has replaced XML. JSON is smaller and <span class="No-Break">more lightweight.</span></p>
			<p>However, it can be even more lightweight. You can also serialize your data as a binary stream. That requires more coding but usually results in much smaller files and data streams. Again, that might be precisely what we, as system programmers, are <span class="No-Break">looking for.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>JSON serialization</h2>
			<p>To<a id="_idIndexMarker425"/> serialize an object to the JSON format, people used to<a id="_idIndexMarker426"/> turn to <strong class="source-inline">NewtonSoft.JSON</strong> by default. <strong class="source-inline">NewtonSoft.JSON</strong> was the library of choice. It was easy to use (and still is) and offered many features that people liked, such as custom converters. However, Microsoft has since released <strong class="source-inline">System.Text.Json</strong>, which does the same but is much more efficient. As system programmers, we care about memory efficiency and speed, so I will focus on that <span class="No-Break">one here.</span></p>
			<p>Before we can <a id="_idIndexMarker427"/>serialize something, we need something to serialize. The advantage of <strong class="source-inline">System.Text.Json</strong> is that I do not need to change my classes with attributes. The framework is smart enough to figure out what is needed and <span class="No-Break">does that.</span></p>
			<p>I will use the <a id="_idIndexMarker428"/>same data class we saw earlier in this chapter in these examples. However, to save you from flipping th<a id="_idTextAnchor137"/>rough pages, I present it to you here <span class="No-Break">once again:</span></p>
			<pre class="source-code">
class MyData
{
    public int Id { get; set; }
    public double SomeMagicNumber { get; set; }
    public bool IsThisAGoodDataSet { get; set; }
    public MyFlags SomeFlags { get; set; }
    public string? SomeText { get; set; }
}
[Flags]
public enum MyFlags
{
    FlagOne,
    FlagTwo,
    FlagThree
}</pre>			<p>If we want to serialize this to JSON to store it as text and later reread it, we will use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
public string SerializeToJSon(MyData myData)
{
    var options = new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    var result =
    System.Text.Json.JsonSerializer.Serialize(myData,options );
    return result;
}</pre>			<p>The code <a id="_idIndexMarker429"/>presented here is pretty straightforward. We will take the <strong class="source-inline">MyData</strong> class and give it to the static <strong class="source-inline">Serialize</strong> method, <strong class="source-inline">System.Text.Json.JsonSerializer</strong>. There are a couple of overloads for this method. I will <a id="_idIndexMarker430"/>use the one that takes an instance of the <strong class="source-inline">JsonSerializerOptions</strong> class. This way, I can format the output. I will set the <strong class="source-inline">WriteIdented</strong> property to <strong class="source-inline">True</strong>. I would get the whole string on one line if I had not done that. Granted, that would have saved me a couple of newline and tab characters, but for readability, I <span class="No-Break">prefer this.</span></p>
			<p>We will get the following result if we run this with some values in <span class="No-Break">our class:</span></p>
			<pre class="source-code">
{
  "id": 42,
  "someMagicNumber": 3.1415,
  "isThisAGoodDataSet": true,
  "someFlags": 2,
  "someText": "This is some text that we want to serialize"
}</pre>			<p>Deserializing, thereby<a id="_idIndexMarker431"/> reversing the process, is just <span class="No-Break">as simple:</span></p>
			<pre class="source-code">
public MyData DeserializeFromJSon(string json)
{
    var options = new JsonSerializerOptions
    {
        WriteIndented = true,
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase
    };
    var result = System.Text.Json.JsonSerializer.        Deserialize&lt;MyData&gt;(json, options);
    return result!;
}</pre>			<p>As you can see, the <a id="_idIndexMarker432"/>process is <span class="No-Break">simple enough.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor138"/>Binary serialization</h2>
			<p>It is not the <a id="_idIndexMarker433"/>most efficient way to encode an object so you can <a id="_idIndexMarker434"/>store it in a file. It is relatively fast, but the actual data is also pretty large. Binary formatting is more work and the result is not human-readable, but it does lead to smaller files. That means that the time spent reading and writing data to a slow storage medium is significantly reduced. Of course, the tradeoff is that the CPU gets a bit busier, but that might be worth it. As always, measure and then decide whether this applies to <span class="No-Break">your situation.</span></p>
			<p>In .NET Framework, before the days of .NET Core and .NET, we had a class named <strong class="source-inline">BinaryFormatter</strong>. That class, however, is now marked as obsolete. There are serious security concerns associated with that class, so Microsoft decided to get rid <span class="No-Break">of it.</span></p>
			<p>There are third-party packages you can use to achieve the same goal. However, if you do not want to use those, you can always do it yourself. We already discussed the <strong class="source-inline">BinaryWriter</strong> class and its methods. There is nothing wrong with using that class, but the downside is that you must write all the code, writing and reading each field or property. The <strong class="source-inline">BinaryFormatter</strong> class did that. That was quite handy, to <span class="No-Break">be honest.</span></p>
			<p>The best package<a id="_idIndexMarker435"/> these days to achieve the same thing is <strong class="source-inline">protobuf-net</strong>. This package is available on NuGet, making it easy to install in your project. If you want to use <strong class="source-inline">protobuf-net</strong>, you must annotate your classes before you can serialize them. Using our <strong class="source-inline">MyData</strong> class again, it would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[ProtoContract]
public class MyData
{
    [ProtoMember(1)]
    public int Id { get; set; }
    [ProtoMember(2)]
    public double SomeMagicNumber { get; set; }
    [ProtoMember(3)]
    public bool IsThisAGoodDataSet { get; set; }
    [ProtoMember(4)]
    public MyFlags SomeFlags { get; set; }
    [ProtoMember(5)]
    public string? SomeText { get; set; }
}</pre>			<p>We have <a id="_idIndexMarker436"/>decorated the class with the <strong class="source-inline">ProtoContract</strong> attribute. Then, we decorated the properties with the <strong class="source-inline">ProtoMember</strong> attribute. This attribute can have associated data, but the first one is mandatory. This is the tag and it defines where the field is stored in the file. There is no hard rule on the numbering or the order aside from one: you cannot start with 0. Yes. Indeed. I heard you gasp there. This is the only example I can think of in programming where starting with 0 is forbidden. If you want to start with 42, you can do that. However, the number has to be a positive integer, and 0 is not a <span class="No-Break">positive integer.</span></p>
			<p>Serializing and deserializing are simple. You have to ensure that the data is available in a memory stream or can be written to a memory stream, but that is the only slightly complicated<a id="_idIndexMarker437"/> thing. This is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
public async Task&lt;byte[]&gt; SerializeToBinary(MyData myData)
{
    await using var stream = new MemoryStream();
    ProtoBuf.Serializer.Serialize(stream, myData);
    return stream.ToArray();
}
public async Task&lt;MyData&gt; DeserializeFromBinary(byte[] payLoad)
{
    await using var stream = new MemoryStream(payLoad);
    var myData =
        ProtoBuf.Serializer.Deserialize&lt;MyData&gt;(stream);
    return myData;
}</pre>			<p>That is it. I promised you that it would be simple, <span class="No-Break">didn’t I?</span></p>
			<p>If I take the<a id="_idIndexMarker438"/> same data as in the JSON serialization and compare the sizes, I can see that the binary version is much smaller. Even if I use the option not to write intended files, thus saving on newlines and tabs, the JSON version is 131 bytes. In comparison, the binary version is only 60 bytes long. That is a <span class="No-Break">big difference!</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor139"/>Next steps</h1>
			<p>I/O is essential for all software. No software runs in isolation, especially software written for systems. After all, these applications do not have a traditional user interface; they are meant to be used by other software. The only way to communicate with that software is by exchanging data in one way <span class="No-Break">or another.</span></p>
			<p>This chapter has looked at ways to serialize and deserialize data to and from storage. We saw that JSON is simple and produces human-readable data. However, the data can be pretty big. In contrast, the binary version results in much smaller data, but that data is not human-readable anymore. Additionally, it requires a third-party package. What is the best solution? That depends on your use cases! It doesn’t matter whether you use files or a network connection; they are all approaches of I/O. In this chapter, you saw how to do that efficiently, quickly, <span class="No-Break">and safely.</span></p>
			<p>However, one way that is much more efficient for systems software to communicate is through direct communication over <strong class="bold">Interprocess Communications</strong> (<strong class="bold">IPC</strong>). IPC is a perfect way for systems software to establish an interface layer that other software can talk to or listen to. It is also the topic of the <span class="No-Break">next chapter.</span></p>
		</div>
	</body></html>