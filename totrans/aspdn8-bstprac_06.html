<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-130"><a id="_idTextAnchor137"/>6</h1>
<h1 id="_idParaDest-131"><a id="_idTextAnchor138"/>Best Practices with Web User Interfaces</h1>
<p>When creating a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) with ASP.NET 8, it can be intimidating since most developers are so used to working with C#. There are a lot of factors to consider when creating a web application, such as avoiding duplication, recognizing similar interfaces for reusable components, creating a structured website, and making it easier for search engines to index the site—a process known as <strong class="bold">search engine </strong><strong class="bold">optimization</strong> (<strong class="bold">SEO</strong>).</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Using a task runner</li>
<li>Applying standards to UIs</li>
<li>Introducing Buck’s coffee shop project</li>
</ul>
<p>In the first section, we’ll examine why a task runner is so important to developers, how to set it up and run it automatically, and how to bundle and minify scripts. Then, in the next section, we’ll review a number of common standards with ASP.NET 8 sites, including centralizing links, keeping controllers and Razor Pages small, why <code>ViewComponent</code> classes are better than the <code>HTMLHelper</code> class or partials, replacing HTML helpers with tag helpers, and why creating SEO-friendly URLs are important.</p>
<p>Finally, we’ll create a new project called <em class="italic">Buck’s Coffee Shop</em>, applying everything we’ve covered.</p>
<p>By the end of this chapter, we’ll know how to include client-side resources into a task runner, implement common practices for UIs, understand how to build additional functionality into an existing web application using the Task Runner tool, consolidate links using extension methods, and extend HTML by creating our own HTML Tags.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor139"/>Technical requirements</h1>
<p>Even with a simple web UI, the Visual Studio family of products creates an easy way to build web applications using IntelliSense. We recommend using your favorite editor to view the GitHub repository. We recommend the following:</p>
<ul>
<li>Visual Studio (latest version)</li>
<li>Visual Studio Code</li>
<li>JetBrains Rider</li>
</ul>
<p>The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with the code.</p>
<p>The code for <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a> is located in Packt Publishing’s GitHub repository, found at <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor140"/>Using a task runner</h1>
<p>In this section, we’ll explain <a id="_idIndexMarker308"/>what a task runner is, what its responsibilities are, how to automatically execute it when building the solution, and provide some examples of how to use it.</p>
<p>As developers, we are always looking for better ways to quickly automate tasks. With JavaScript frameworks, this task is essential, especially when building the solution in a <strong class="bold">Continuous Integration/Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>) pipeline. The consistent repetition <a id="_idIndexMarker309"/>of certain tasks becomes monotonous and takes away from development time. Why not have a computer process the work?</p>
<p>As developers, the need to include a task runner section in this chapter is meant to show developers how to automate tasks to make client-side endeavors more efficient. In recent years, I’ve experienced developers who’ve never used a task runner for client-side tasks or even know what it is. A task runner is a tremendous benefit to all developers.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor141"/>What is a task runner?</h2>
<p>As JavaScript became <a id="_idIndexMarker310"/>popular, developers wanted a way to build their JavaScript as well as build their solutions. In addition to using JavaScript, TypeScript was created to give JavaScript more of a strong-typed feel and required a compilation step as well.</p>
<p>Along with “compiling” TypeScript, most websites require additional tasks such as minifying and bundling JavaScript and optimizing. There was a need for a tool to make the developer’s experience seamless when working with C# and JavaScript.</p>
<p>This is why the Task Runner tool was created and integrated into Visual Studio. Its primary responsibility is to automate tasks using either Grunt or Gulp with build scripts.</p>
<p>Gulp and Grunt are also task runners, but each one has a different file format in JavaScript when defining tasks. While we can use either Grunt or Gulp scripts in the Visual Studio Task Runner, we’ll be using the Gulp format.</p>
<p>The Task Runner in Visual Studio is what I would consider a “mini-pipeline for the client side.” A task runner is a great introduction for developers learning to create a CI/CD pipeline for an application.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor142"/>Setting up the Task Runner</h2>
<p>The Task Runner <a id="_idIndexMarker311"/>relies heavily on Node.js for running scripts. By default, Node.js should already be installed through Visual Studio.</p>
<p>To find out whether Node.js is installed on your machine, do the following:</p>
<ol>
<li>Select <strong class="bold">Package Manager Console</strong> from <strong class="bold">View | </strong><strong class="bold">Other Windows</strong>.</li>
<li>When a prompt appears, type <code>npm --version</code>. If it displays a version number, we can proceed with the next step. If not, a repair of Visual Studio through the Visual Studio Installer may be required.</li>
<li>Type <code>npm install -g gulp --save-dev</code>. The <code>-g</code> option is to install Gulp globally, and <code>--save-dev</code> is there to save the dependency in the <code>package.json</code> file. With that said, there should be a <code>package.json</code> file added to the solution.</li>
<li>Add a new JavaScript file to the root of the project, called <code>gulpfile.js</code>.</li>
</ol>
<p>Depending on whether we’re using Grunt or Gulp, the Task Runner requires a specific file. In the <a id="_idIndexMarker312"/>examples (as I mentioned before), we’ll be using the Gulp format.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor143"/>Structure of a gulpfile</h2>
<p>When <a id="_idIndexMarker313"/>creating a gulpfile, it should be named <code>gulpfile.js</code>. The file<a id="_idIndexMarker314"/> should be placed into the root of the solution.</p>
<p>The structure of a gulpfile contains the following:</p>
<ul>
<li><strong class="bold">Defined packages</strong>—These are the modules used throughout the gulpfile.</li>
<li><strong class="bold">Processing and cleanup tasks</strong>—Each task will contain a process task along with a cleanup task.</li>
<li><strong class="bold">Export groupings</strong>—This provides a list of tasks to execute in a specific order. Usually, cleanup procedures are used first, followed by regular processing tasks.</li>
</ul>
<p>Gulp requires a <code>gulpfile.js</code> file to be located in the root of the solution. The standard layout of a gulpfile is usually segmented using the following stru<a id="_idTextAnchor144"/>cture:</p>
<ul>
<li><code>npm</code> installs.</li>
<li><code>gulpfile.js</code> file, there should be two tasks: a processing task and a cleanup task. The processing task is meant to achieve what we want to automate, whereas the cleanup task is meant to delete created or processed files.</li>
<li><strong class="bold">Global default and cleanup tasks</strong>—Segment the processing and cleanup tasks into logical groupings when building the scripts.</li>
</ul>
<p>Since we already have our file, we’ll create a simple task for our solution. Copy the following JavaScript code into the new <code>gulpfile.js</code> file:</p>
<pre class="source-code">
const { series } = require('gulp');
// Packages defined at the top
const gulp = require('gulp');
// Tasks (no cleanup for Hello World) ;-)
function testTask(done) {
    console.log('Hello World! We finished a task!');
    done();
}
// Global default and cleanup tasks
exports.build = series(
    testTask
);</pre> <p>Since this is <a id="_idIndexMarker315"/>a build script, we’ll be using the <code>series()</code> function<a id="_idIndexMarker316"/> from the Gulp package, which defines sequential processes. This is represented through the first line. The second line creates a <code>const</code> instance representing the Gulp package, making the Gulp functions available to us.</p>
<p>Our simple task for the Task Runner is the world-famous “Hello World!” task defined through the <code>testTask</code> function while passing in the <code>done</code> function, which Gulp handles for us.</p>
<p>Finally, we attach a <code>build</code> property to our exports that defines a series of tasks from the preceding code. The <code>series</code> function is defined in the Gulp package. The name following the <code>exports</code> namespace can be named anything which appears in the Task Runner. If the build task isn’t displaying in the Task Runner, click the <code>gulpfile.js</code> file.</p>
<p>When right-clicking on the <strong class="bold">build</strong> option (or double-click), the build will execute showing the results, as displayed in the following screenshot:</p>
<div><div><img alt="Figure 6.1 – Results from our first Task Runner process" src="img/Figure_6.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Results from our first Task Runner process</p>
<p>In the next <a id="_idIndexMarker317"/>section, we’ll learn how to run our gulpfile<a id="_idIndexMarker318"/> automatically when we build our solution.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor145"/>Running automatically</h2>
<p>To assist in <a id="_idIndexMarker319"/>automatically running our <code>gulpfile.js</code> file, we have the ability to bind certain tasks to events when building the solution. Right-click on the task in the Task Runner to select the appropriate action for the<a id="_idIndexMarker320"/> builds, as follows:</p>
<ul>
<li><strong class="bold">Before Build</strong>—Execute a task before compiling the solution</li>
<li><strong class="bold">After Build</strong>—Execute a task after the solution compiled</li>
<li><strong class="bold">Clean Build</strong>—Execute a task on a “Clean Solution” or “Clean &lt;Project&gt;” action</li>
<li><strong class="bold">Project Open</strong>—Execute a task after the project opens</li>
</ul>
<p>When we select <code>gulpfile.js</code> file:</p>
<pre class="source-code">
/// &lt;binding BeforeBuild='build' /&gt;</pre> <p>When we build the application, the Task Runner executes the build task and, if successful, it proceeds to compile the application, as shown in the following screenshot. If not, the Task Runner will display an error message in the results pane:</p>
<div><div><img alt="Figure 6.2 – A successful build of client-side tasks and solution" src="img/Figure_6.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A successful build of client-side tasks and solution</p>
<p>While this provides a basic foundation for our application, we need to define our client-side directory structure so that when adding resources such as images, scripts, and styles, our tasks <a id="_idIndexMarker321"/>know where to find the resources.</p>
<p>In the next section, we’ll look at how to set up the structure for our client-side workflow.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor146"/>Creating a workflow structure</h2>
<p>Before we<a id="_idIndexMarker322"/> write scripts for our <code>gulpfile.js</code> file, we need to define a simple workflow for our Task Runner. Generally, our gulpfile contains, at the very least, a JavaScript and CSS bundler and minifier. It doesn’t matter which one is executed first, but they could even be candidates for a collection of parallel tasks. While Visual Studio created our server-side application, the client-side structure requires a little more attention in regard to where to place files throughout our application.</p>
<p>In every ASP.NET 8 application, we have a <code>wwwroot</code> folder that contains our client-side scripts, styles, and static content (such as images). This is considered the root path to our application for our static content, so if we have a website called <a href="https://www.mywebsite.com/">https://www.mywebsite.com/</a>, the wwwroot folder will be our root. For example, if we want to access our CSS folder, we’d access it via <code>https://www.mywebsite.com/css/</code>. While every resource (such as scripts and styles) has its own way of processing and creating production-ready output files, there needs to be a workflow on how each task in our Task Runner will perform.</p>
<p>The current<a id="_idIndexMarker323"/> directory structure looks like this:</p>
<div><div><img alt="Figure 6.3 – A common ASP.NET 8 structure" src="img/Figure_6.03_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A common ASP.NET 8 structure</p>
<p>The preceding structure is meant for a production-level application. The <code>css</code> directory doesn’t contain any SASS or LESS files for processing, and the <code>js</code> directory has only simple JavaScript files. We need additional directories for our workflow to function properly.</p>
<p>For our application, we’ll be using TypeScript and SASS. SASS is a preprocessor for CSS files and requires a directory for our source files (with an extension of <code>.scss</code>). TypeScript also requires transpilation into JavaScript files, so we’ll create a <code>scss</code> directory for our SASS files and a <code>src</code> directory for our TypeScript files.</p>
<p>Create a <code>src</code> folder and a <code>scss</code> folder under the <code>wwwroot</code> folder. These folders will contain the source code for our application. The <code>src</code> folder will contain all TypeScript files for the application, whereas the <code>scss</code> folder will contain all of the styles ready for compilation into production-ready CSS files.</p>
<p>The following<a id="_idIndexMarker324"/> steps show a common workflow for a task runner:</p>
<ol>
<li>TypeScript files:<ul><li>Transpile the TypeScript files in the <code>src</code> folder into JavaScript files. The output files will reside in the <code>src</code> folder. The output files are JavaScript files.</li></ul></li>
<li>JavaScript files:<ul><li>Use a bundler to process the <code>.js</code> files. The bundler should automatically know how to include all files based on the JavaScript module pattern.</li><li>Use a minifier to process the bundled JavaScript files. The output files are copied from the <code>src</code> folder over to the <code>js</code> folders. These files are also renamed to have a <code>.min.js</code> suffix added to them to identify them as minified files.</li></ul></li>
<li>Styles:<ul><li>Use a “styler compiler” such as LESS or SASS. We’ll be using SASS to precompile our styles. These files will reside in the <code>scss</code> folder. Once compiled, the folder will contain <code>.css</code> files and be inevitably moved to the <code>css</code> folder.</li></ul></li>
</ol>
<p>The workflow structure of our application implies the <code>js</code> and <code>css</code> folders are production-level <a id="_idIndexMarker325"/>folders while making our <code>src</code> and <code>scss</code> folders specific to developer modifications.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor147"/>Defining our workflow paths</h2>
<p>Since we <a id="_idIndexMarker326"/>created our workflow structure, we need to tell Gulp where our source and destination folders reside in our application. The <code>path</code> module contains a <code>resolve</code> function to concatenate folder names as we go, as shown here:</p>
<pre class="source-code">
// Packages defined at the top
const gulp = require('gulp'),
      path = require('path');
// define our paths for our app
const basePath = path.resolve(__dirname, "wwwroot");</pre> <p><code>__dirname</code> is a reserved word and is based on the current directory (in our case, this is the root of our application). <code>basePath</code> is used to operate solely in the <code>wwwroot</code> folder and below and won’t interfere with our ASP.NET 8 application.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor148"/>Transpiling TypeScript</h2>
<p>Our first order<a id="_idIndexMarker327"/> of business is to transpile our TypeScript files <a id="_idIndexMarker328"/>into JavaScript files. Transpiling is the process of converting TypeScript into JavaScript. With most of our TypeScript projects, we almost always have a <code>tsconfig.json</code> configuration file, and this will reside in the root of the <code>wwwroot</code> folder. However, we need a special package for reading the configuration file specifically for Gulp.</p>
<p>To include the package, pr<a id="_idTextAnchor149"/>oceed as follows:</p>
<ol>
<li>In the <code>npm install -g gulp-cli</code>. It should then be added to your <code>package.json</code> file.</li>
<li>In the <code>npm install gulp@4</code> to install Gulp as a project dependency.</li>
<li>One last time in the <code>npm install gulp-typescript typescript gulp-clean --save-dev</code> to install TypeScript, the <code>gulp-typescript</code>, and the ability to remove files (<code>gulp-clean</code>).</li>
<li>Define the module at the top of the <code>gulpfile.js</code> file, like so:<pre class="source-code">
const gulp = require('gulp'),
      path = require('path'),
      tsConfig = require("gulp-typescript");</pre></li> <li>Load the <a id="_idIndexMarker329"/>configuration using the <code>createProject</code> function<a id="_idIndexMarker330"/> referencing the path to the <code>tsconfig.json</code> file, as follows:<pre class="source-code">
// define our paths for our app
const basePath = path.resolve(__dirname, "wwwroot");
const tsProject = tsConfig.createProject(path.resolve(basePath, 'tsconfig.json'));</pre></li> <li>Define the TypeScript source folder, like so:<pre class="source-code">
const tsSource = path.resolve(basePath, "src");</pre></li> <li>We’ll keep track of paths through a source object. Our <code>srcPaths</code> object will contain a <code>js</code> path pointing to our source code:<pre class="source-code">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js')
    ]
};</pre></li> <li>We need to create process (<code>ts_transpile</code>) and cleanup (<code>ts_cleanup</code>) functions for our TypeScript. Here’s the code to achieve that:<pre class="source-code">
function ts_transpile(done) {
    tsProject
        .src()
        .pipe(tsProject()).js
        .pipe(gulp.dest(tsSource));
    done();
}
function ts_clean(done) {
    gulp.src(srcPaths.js, {allowEmpty: true})
        .pipe(clean({ force: true }));
    done();
}</pre></li> <li>The <code>ts_transpile</code> function uses the <code>tsProject</code> configuration to locate the source <a id="_idIndexMarker331"/>files (through the <code>include</code> property <a id="_idIndexMarker332"/>near the end of the <code>tsconfig.json</code> file) and convert all of the TypeScript files into JavaScript files in the same directory.</li>
<li>Our <code>ts_clean</code> function will simply remove all JavaScript (<em class="italic">NOT</em> TypeScript) files from every directory.</li>
<li>Once we have our TypeScript tasks defined, we simply add them to our build process at the bottom of our <code>gulpfile.js</code> file, like so:<pre class="source-code">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    ts_transpile
);</pre></li> <li>First, we delete all of the JavaScript files with <code>ts_clean</code>, then perform the transpiling with <code>ts_transpile</code>.</li>
<li>As shown in the example, our workflow structure locates all of the TypeScript files and<a id="_idIndexMarker333"/> transpiles them into JavaScript<a id="_idIndexMarker334"/> files:</li>
</ol>
<div><div><img alt="Figure 6.4 – TypeScript files in src folders converted to JavaScript" src="img/Figure_6.04_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – TypeScript files in src folders converted to JavaScript</p>
<p>Since our TypeScript is now transpiled down to JavaScript, we can focus on bundling and minifying <a id="_idIndexMarker335"/>the <a id="_idIndexMarker336"/>files.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor150"/>Bundling and minifying</h2>
<p>By nature, JavaScript <a id="_idIndexMarker337"/>takes a while to load in the browser. To make<a id="_idIndexMarker338"/> matters worse, if a JavaScript file is formatted for readability, the file takes even longer to load, therefore making it slower to download. A minification process is necessary to shorten the loading process as much as possible to give the user a better experience.</p>
<p>Bundling is the concept of taking an application’s scripts and styles and combining them into one script or style instead of loading multiple files.</p>
<p>Since spaces and tabs take up…well, space, minifying the scripts and styles is the process of shrinking client-side files down to a smaller size for faster delivery to the browser.</p>
<p>To bundle our scripts, we need a module called Browserify for our Gulp script. Let’s start adding the bundling functionality to the <code>gulpfile.js</code> file. Here are the steps:</p>
<ol>
<li>In the <code>npm install -g browserify gulp-rename vinyl-source-stream vinyl-buffer vinyl-transform gulp-uglify-es</code>. We should see these modules added to the <code>package.json</code> file.</li>
<li>Once these are installed in the <code>package.json</code> file, we need to include another <code>srcPath</code> object containing all of the files we want bundled/minified:<pre class="source-code">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ]
};</pre></li> </ol>
<p>We’ll call the property <code>jsBundles</code>. Since every TypeScript file was transpiled into a JavaScript file, we have to identify which files to load. A good practice to follow is to name the file the same as the actual page. The good news is the Browserify module will follow the imports in each file and include it in the bundling. As we add more TypeScript to the project, add the primary script to the list for automatic compilation.</p>
<ol>
<li value="3">Create a new variable where the scripts will reside for the web application:<pre class="source-code">
const destPaths = {
    jsFolder: path.resolve(basePath, 'js') // wwwroot/js
};</pre></li> </ol>
<p>We’ll call the variable <code>destPaths</code>.</p>
<ol>
<li value="4">Next, we <a id="_idIndexMarker339"/>create<a id="_idIndexMarker340"/> our processing and cleanup for bundling and minifying the scripts:<pre class="source-code">
/* JavaScript */
function js_bundle_min(done) {
    srcPaths.jsBundles.forEach(file =&gt; {
        const b = browserify({
            entries: file, // Only need initial file, browserify                               finds the deps
            transform: [['babelify', { 'presets': ["es2015"] }]]
        });
        b.bundle()
            .pipe(source(path.basename(file)))
            .pipe(rename(path =&gt; {
                path.basename += ".min";
                path.extname = ".js";
            }))
            .pipe(buffer())
            .pipe(uglify())
            .pipe(gulp.dest(destPaths.jsFolder));
        done();
    });
}
function js_clean(done) {
    gulp.src(path.resolve(destPaths.jsFolder, '**/*.js'), { read: false })
        .pipe(gp_clean({ force: true }));
    done();
}</pre></li> </ol>
<p>In the <code>js_bundle_min</code> function<a id="_idIndexMarker341"/> shown in the preceding <a id="_idIndexMarker342"/>snippet, we loop through all of the files we want bundled. We create a <code>browserify</code> object with options set and start the bundling process per file.</p>
<p>The first process is getting the base name of the file we’re currently processing. Once we have the filename, we can rename the base from <code>site</code> to <code>site.min</code> and then add a <code>.js</code> extension to the end of the file. We then buffer the file and perform an <code>uglify</code> operation on it, meaning we minify it. After it’s bundled and minified, we write the file out to the destination folder, which is <code>wwwroot/js</code>.</p>
<p>The <code>js_clean</code> function removes all of the <code>.js</code> files from the <code>wwwroot/js</code> folder.</p>
<ol>
<li value="5">Finally, we can add the <code>js_bundle_min</code> and <code>js_clean</code> functions to our build exports at the bottom of the file:<pre class="source-code">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    js_clean,
    ts_transpile,
    js_bundle_min
);</pre></li> </ol>
<p>Once the gulpfile is <a id="_idIndexMarker343"/>saved, double-click <a id="_idIndexMarker344"/>on the build, and the files should appear in the <code>wwwroot/js</code> folder. If we double-click the JavaScript file, we’ll see it’s been bundled and minified.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor151"/>Implementing additional tasks</h2>
<p>While bundling <a id="_idIndexMarker345"/>and minifying scripts is a big deal, there are other tasks we can add to a task runner. Such tasks can include the following:</p>
<ul>
<li>SCSS/LESS precompiling</li>
<li>Image optimization</li>
<li>Release notes</li>
<li>Copying <code>dist</code> folders from <code>node_modules</code> to a <code>lib</code> folder on build</li>
</ul>
<p>These are just a few of the simple tasks available when preparing the web application. For additional tasks, refer to the source code for <a href="B19493_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a> on GitHub in the <code>TaskRunner</code> project at <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<p>In this section, we reviewed what a task runner is and what it can do for developers and showed how to automatically execute it when building the solution. We also demonstrated the power of the Task Runner by creating a workflow structure and defining our workflow paths, how to transpile TypeScript, and how to minify and bundle scripts. As we can see, this simplifies the developer experience by automating client-side tasks and building<a id="_idIndexMarker346"/> the solution using one build.</p>
<p>In the next section, we’ll examine more UI standards and what is considered common knowledge when it comes to ASP.NET 8 web applications.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor152"/>Applying standards to UIs</h1>
<p>ASP.NET’s web page<a id="_idIndexMarker347"/> model has evolved over the years. With Web Forms, it was <code>ViewState</code> and components. With MVC, it had partials and HTML Helpers. Now, ASP.NET 8 provides more advanced techniques using <code>ViewComponent</code> classes and <code>TagHelper</code> classes.</p>
<p>For this section, we’ll examine how ASP.NET 8 uses its language-specific features to build quicker and more flexible UIs. We’ll see how to consolidate links across a site, why it’s important to keep controllers/pages small, how <code>ViewComponent</code> classes are better than partials and <code>HTMLHelper</code> classes, and look at how to create SEO-friendly routes.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor153"/>Centralizing your site links</h2>
<p>If we have a <a id="_idIndexMarker348"/>large site with hundreds of links, developers<a id="_idIndexMarker349"/> understand what it means when a page is renamed, moved, or (gasp) deleted. It’s definitely a time-consuming effort to change every link on a large site. While <code>TagHelper</code> classes are…well, helpful, one common practice is to use <code>UrlHelper</code> classes to consolidate the links.</p>
<p>Let’s examine a website with the following ASP.NET 8 <code>TagHelper</code> class shown here:</p>
<pre class="source-code">
&lt;a asp-page="Index"&gt;Go to Main Page&lt;/a&gt;</pre> <p>Imagine all of these on secondary pages pointing to the main page, <code>Index.cshtml</code>, and we receive a request to change the name of the page to <code>Index2</code>.</p>
<p>With extension methods, we can create custom site-specific <code>UrlHelper</code> class URLs for each page, as shown in the following example:</p>
<pre class="source-code">
    Public static class SiteLinkExtensions
    {
        public static string HomeUrl(this UrlHelper helper) =&gt;
            helper.RouteUrl(new UrlRouteContext
            {
                RouteName = "Default",
                Values = new
                {
                    Controller="Home",
                    Action ="Index"
                }
            });
    }</pre> <p>Extension <a id="_idIndexMarker350"/>methods require three things: a static class, a static <a id="_idIndexMarker351"/>method, and the method’s first parameter in the signature must have <code>this</code> declared.</p>
<p class="callout-heading">What is an extension method?</p>
<p class="callout">For more details on using extension methods, navigate to <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods</a>.</p>
<p>We can apply this technique to Razor Pages as well using the <code>PageLink</code> method, as shown here:</p>
<pre class="source-code">
Public static string DetailsUrl(this IurlHelper helper, string blogId) =&gt;
    helper.PageLink("Detail", values: new { Id = blogId, area = "admin" });</pre> <p>The only difference between the two methods is the extension method attaches to an <code>IurlHelper</code> class instead of a <code>UrlHelper</code> class and, for Razor Pages, we use the <code>.PageLink</code> method instead.</p>
<p>If using the <code>TagHelper</code> anchor with the <code>asp-page</code> attribute, this approach limits our flexibility because we are defining a page in multiple places. By adding an extension method to the <code>UrlHelper</code> class, we can simplify it by using the HTML <code>href</code> attribute, as shown here:</p>
<pre class="source-code">
&lt;a href="@Url.HomeUrl()"&gt;Go to Main Page&lt;/a&gt;</pre> <p>With <code>UrlHelper</code> extension <a id="_idIndexMarker352"/>methods, all of the links across the site <a id="_idIndexMarker353"/>are easier to integrate and more efficient to update.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor154"/>Keeping controllers/pages small</h2>
<p>When ASP.NET MVC was<a id="_idIndexMarker354"/> introduced, controllers were often the dumping ground for most code, making calls to the database, creating models, and validating the model.</p>
<p>MVC controllers (and now Razor Pages) should be “traffic cops,” directing the logic to certain parts of the application based on the page’s function.</p>
<p>While the following list is far from complete, certain aspects can be offloaded to other parts of ASP.NET 8 to put controllers and pages on a diet:</p>
<ul>
<li><code>[Required]</code> and <code>[Email]</code>.</li>
<li><code>DbContext</code> instance and use Entity Framework. If Entity Framework isn’t a viable solution, offload the database processing to <code>Service</code> classes (see <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a> on Entity Framework Core).</li>
<li><strong class="bold">Secondary processes</strong>—If the application contains code to send emails, process records, or build an object, refactor the process out to its own class and inject it into the controller/Razor page, making it cleaner and easier to test.</li>
</ul>
<p>Large methods in <a id="_idIndexMarker355"/>controllers or Razor Pages can complicate matters further when trying to test or debug code. Smaller code, in this instance, is the better approach.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor155"/>Using ViewComponents</h2>
<p>When HTML Helpers <a id="_idIndexMarker356"/>and Partial views were introduced <a id="_idIndexMarker357"/>with MVC, the ability to pass an object into a small section and have it create a snippet of HTML for the View was a great feature for developers. However, there were a few downsides to using these two features.</p>
<p>The downside of using HTML Helpers was the ability to create new HTML snippets through code and render that back to the View. If the HTML changed, it would require updating and recompiling of the code <a id="_idIndexMarker358"/>violating <strong class="bold">separation of concerns</strong> (<strong class="bold">SoC</strong>) (“You’ve got your C# in my HTML”). There wasn’t any HTML associated with the Helper; it had to be created using code.</p>
<p>Swinging the pendulum the other way, Partials introduced the ability to have HTML with no code with the ability to pass objects into the partial. The issue with this approach was the ability to place <code>if</code>…<code>then</code> statements inside the HTML. When an <code>if</code>…<code>then</code> statement was introduced in HTML, this was considered a code smell (which is code looking like it doesn’t belong or looks suspicious) and was meant to be a business rule. HTML should be declarative—almost template-like with no branching involved.</p>
<p>With ASP.NET Core, <code>ViewComponent</code> classes were introduced and, while not meant to replace <code>HTMLHelper</code> classes or Partials, fulfilled a larger need for building modular web applications. Considered to be “mini-controllers,” <code>ViewComponent</code> classes provide ASP.NET developers with a better approach for the following reasons:</p>
<ul>
<li><strong class="bold">SoC</strong>—With an HTML and C# combination, this allows a better way of writing modular components.</li>
<li><code>ViewComponent</code> classes only render a chunk of the view instead of the entire response. This makes the component independently render faster.</li>
<li><code>ViewComponent</code> classes are isolated by nature, making them extremely easy to test. Create a new <code>ViewComponent</code> class, pass in arguments, and test to see if it returned what was expected.</li>
</ul>
<p><code>ViewComponent</code> classes give us the best of both worlds, rendering HTML while using C# for<a id="_idIndexMarker359"/> applying <a id="_idIndexMarker360"/>business rules in a single component.</p>
<p class="callout-heading">Additional ViewComponent material</p>
<p class="callout">For more details on the <code>ViewComponent</code> class, navigate to <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components">https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components</a>.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor156"/>Using Tag Helpers instead of HTML Helpers</h2>
<p>While HTML<a id="_idIndexMarker361"/> Helpers provide the ability <a id="_idIndexMarker362"/>to create small snippets of HTML (just don’t go overboard), the <code>TagHelper</code> class take it a step further.</p>
<p>The difference between Tag Helpers and HTML Helpers is <code>TagHelper</code> classes allow us to build our own tag elements through code and <code>HTMLHelper</code> classes are directly called as methods in the HTML.</p>
<p>For example, if we were building a hotel application, some <code>TagHelper</code> classes would include  <code>&lt;calendar&gt;</code>, <code>&lt;availability&gt;</code>, and <code>&lt;room-gallery&gt;</code> tags. These would look like brand new tags in HTML, but ASP.NET would render them on the server and create HTML based on the data model fed to them.</p>
<p>Tag Helpers are an extremely powerful feature for developers wanting to create their own custom library of domain-specific HTML tags.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/>Creating SEO-friendly URLs</h2>
<p>Site architecture <a id="_idIndexMarker363"/>is important when building <a id="_idIndexMarker364"/>websites. If it’s a public-facing website, the site should be easy to crawl with simple URLs.</p>
<p>To look at this another way, examine the following two URLs:</p>
<ul>
<li><code>https://www.mysite.com/Blog/my-first-blog-post</code></li>
<li><code>https://www.mysite.com/?blogpost=E1FCFB35-87C7-442F-9516-7C8585E8CD49</code></li>
</ul>
<p>If we found these links and we were talking with someone on the phone, which one would we tell them to follow?</p>
<p>Creating friendly URLs provides the following benefits:</p>
<ul>
<li><strong class="bold">Easier to identify the page</strong>—We know the first URL is someone’s first blog post. The second URL is…well, we don’t know what kind of page it is.</li>
<li><strong class="bold">Easy to repeat</strong>—It’s easier to say the first URL over the phone as opposed to the GUID.</li>
<li><strong class="bold">Better SEO</strong>—If we have the opportunity, it’s always good to help search engines identify what kind of page created.</li>
</ul>
<p class="callout-heading"> Best practices of Google’s URL structure</p>
<p class="callout">For better naming of URLs and what Google recommends, navigate to <a href="https://developers.google.com/search/docs/crawling-indexing/url-structure">https://developers.google.com/search/docs/crawling-indexing/url-structure</a>.</p>
<p>Creating these SEO-friendly URLs requires a site-wide link strategy using mapping methods such as <code>.MapRoute()</code> and, if using Razor Pages, naming pages related to the content.</p>
<p>In this section, we learned how to catalog our links using extension methods, how controllers and pages should be made as small as possible, how <code>ViewComponent</code> classes can improve the efforts of writing modular code, why <code>TagHelper</code> classes can propel HTML to <a id="_idIndexMarker365"/>new heights, and why creating SEO-friendly <a id="_idIndexMarker366"/>URLs is so important.</p>
<p>In the last section, we’ll apply our knowledge of implementing these concepts into an application.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor158"/>Introducing Buck’s coffee shop project</h1>
<p>We covered a lot in the last<a id="_idIndexMarker367"/> section, with various concepts explained. It’s one thing to explain <code>ViewComponent</code> and <code>TagHelper</code> classes, but where do we apply these concepts on a website?</p>
<p>In this section, we’ll apply those concepts to a brand-new project. Our friend wanted a new website for his coffee shop, so we used the ASP.NET 8 Web Application template as a starting point for the site.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor159"/>Setting up Buck’s website</h2>
<p>Since we have a <a id="_idIndexMarker368"/>new website, we want to create the client-side pipeline so that we can focus on the site’s functionality.</p>
<p>This sounds like a job for…the Task Runner.</p>
<p>While we’ve included the transpiling of TypeScript and bundling/minifying JavaScript in the project, we can add additional tasks to make our lives even easier.</p>
<p>One easy task is to bundle and minify our styles using SASS, as follows:</p>
<ol>
<li>In the <code>npm install --save-dev sass gulp-sass</code>. These modules should be added to the <code>package.json</code> file.</li>
<li>Once these are installed in the <code>package.json</code> file, we include the module as required at the top of our <code>gulpfile.js</code> file, like so:<pre class="source-code">
gp_sass = require('gulp-sass')(require("sass"));</pre></li> <li>Create a variable containing the path to the SCSS files:<pre class="source-code">
const sassSource = path.resolve(basePath, "scss");</pre></li> <li>Add the style file to the <code>srcPaths</code> object (in the <code>sassSrc</code> property):<pre class="source-code">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ],
    sassSrc: [
        path.resolve(sassSource, 'site.scss')
    ]
}</pre></li> <li>Add the style path to the <code>destPaths</code> object (with the <code>cssFolder</code> property):<pre class="source-code">
const destPaths = {
    jsFolder: path.resolve(basePath, 'js'), // wwwroot/js
    cssFolder: path.resolve(basePath, 'css') // wwwroot/css
};</pre></li> <li>Add the<a id="_idIndexMarker369"/> processing and cleaning functions:<pre class="source-code">
/* SASS/CSS */
function sass_clean(done) {
    gulp.src(destPaths.cssFolder + "*.*", { read: false })
        .pipe(gp_clean({ force: true }));
    done();
}
function sass(done) {
    gulp.src(srcPaths.sassSrc)
        .pipe(gp_sass({ outputStyle: 'compressed' }))
        .pipe(rename({
            suffix: '.min'
        }))
        .pipe(gulp.dest(destPaths.cssFolder));
    done();
}</pre></li> <li>Finally, add<a id="_idIndexMarker370"/> the functions to the build process:<pre class="source-code">
// Global default and cleanup tasks
exports.build = series(
    ts_clean,
    js_clean,
    sass_clean,
    ts_transpile,
    js_bundle_min,
    sass
);</pre></li> </ol>
<p>What about those JavaScript libraries? They’re in the dreaded <code>node_modules</code> folder. Most JavaScript libraries have a <code>dist</code> folder for distribution. This was the case when we installed the Bootstrap and Font Awesome libraries. Why not copy that into our <code>/lib</code> folder for our local purposes?</p>
<ol>
<li value="8">Create a variable in the <code>gulpfile.js</code> file containing the path to the <code>node_modules</code> folder. This should be in the root of the solution:<pre class="source-code">
const moduleSource = path.resolve(__dirname, "node_modules");</pre></li> <li>Create a new variable containing the destination of where to place our <code>dist</code> packages (our <code>/</code><code>lib</code> folder):<pre class="source-code">
const libSource = path.resolve(basePath, "lib");</pre></li> <li>Define the <a id="_idIndexMarker371"/>copy details in a property called <code>lib</code>:<pre class="source-code">
const srcPaths = {
    js: [
        path.resolve(tsSource, '**/*.js') // all *.js in every                                              folder
    ],
    jsBundles: [
        path.resolve(tsSource, 'site.js') // specific files to                                              bundle/minify
    ],
    sassSrc: [
        path.resolve(sassSource, 'site.scss')
    ],
    // local dev (copy dist into lib)
    lib: [
        {
            src: path.resolve(moduleSource, 'bootstrap/                dist/**/*'),
            dest: path.resolve(libSource, 'bootstrap/')
        },
        {
            src: path.resolve(moduleSource, '@fortawesome/                fontawesome-free/**/*'),
            dest: path.resolve(libSource, 'fontawesome/')
        }
    ]
};</pre></li> <li>Add the <a id="_idIndexMarker372"/>processing and cleaning functions:<pre class="source-code">
/* Copy Libraries to their location */
function copyLibraries(done) {
    srcPaths.lib.forEach(item =&gt; {
        return gulp.src(item.src)
            .pipe(gulp.dest(item.dest));
    });
    done();
}
function cleanLibraries(done) {
    srcPaths.lib.forEach(item =&gt; {
        return gulp.src(item.dest + "/*.*")
            .pipe(gp_clean({ force: true }));
    });
    done();
}</pre></li> <li>Finally, add our library copy to the build process:<pre class="source-code">
// Global default and cleanup tasks
exports.build = series(
    cleanLibraries,
    copyLibraries,
    ts_clean,
    js_clean,
    sass_clean,
    ts_transpile,
    js_bundle_min,
    sass
);</pre></li> </ol>
<p>This gives us the ability to automatically receive the latest versions of packages for our application. When<a id="_idIndexMarker373"/> updating our <code>package.json</code> file, we’ll benefit from the latest versions in <code>node_modules</code> delivered right to our <code>/</code><code>lib</code> folder.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor160"/>Updating the links</h2>
<p>Since we<a id="_idIndexMarker374"/> have a new application, we’ll create <code>Url</code> Helpers to help catalog the site. Based on the template, we have two links: <code>Home</code> and <code>Privacy</code>. Let’s create those <code>Url</code> Helpers, as follows:</p>
<pre class="source-code">
public static class BucksUrlExtensions
{
    public static string HomeUrl(this IUrlHelper helper) =&gt;
        helper.PageLink("/Index")!;
    public static string PrivacyUrl(this IUrlHelper helper) =&gt;
        helper.PageLink("/Privacy")!;
}</pre> <p>This makes our HTML easier to read. Instead of the Anchor Tag Helpers, we can substitute them with a Url Helper. Here is the result of replacing the Privacy Anchor Tag Helper:</p>
<pre class="source-code">
    &lt;footer class="border-top footer text-muted"&gt;
        &lt;div class="container"&gt;
            &amp;copy; 2023 - Buck's Coffee Shop - &lt;a href="@Url.PrivacyUrl()"&gt;Privacy&lt;/a&gt;
        &lt;/div&gt;
    &lt;/footer&gt;</pre> <p>While this is one instance on this page, we can already see the dividends of our efforts. Notice the navigation bar?</p>
<p>In the navigation <a id="_idIndexMarker375"/>bar, there’s another location where we can remove the hardcoded URL and use a strongly typed <code>UrlHelper</code> class, as illustrated here:</p>
<pre class="source-code">
&lt;ul class="navbar-nav flex-grow-1"&gt;
    &lt;li class="nav-item"&gt;
        &lt;a class="nav-link text-dark" href="@Url.HomeUrl()"&gt;Home&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class="nav-item"&gt;
        &lt;a class="nav-link text-dark" href="@Url.PrivacyUrl()"&gt;Privacy&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre> <p>There are <code>Privacy</code> and <code>Home</code> links we replaced.</p>
<p>The technique also works with controllers or Razor Pages. If we need to redirect to another page, there is a <code>UrlHelper</code> class available to us by default, as shown here:</p>
<pre class="source-code">
public IActionResult OnGet()
{
    return Redirect(Url.HomeUrl());
}</pre> <p>It removes the<a id="_idIndexMarker376"/> need for hardcoded URLs, providing a more efficient way of referencing links across a large website.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor161"/>Creating an OffCanvas Tag Helper</h2>
<p>Since responsive <a id="_idIndexMarker377"/>websites are<a id="_idIndexMarker378"/> important, we need to have an <code>OffCanvas</code> menu for when users see the site with a mobile device.</p>
<p><code>OffCanvas</code> menus are activated on mobile devices when clicking on a hamburger menu (shown as three lines on top of each other). <code>OffCanvas</code> menus are hidden from the main content on a web page, hence the name. They’re only necessary to hide navigational items until they’re actually needed.</p>
<p>We’re creating an <code>OffCanvas</code> menu for Buck’s website. However, we want to use this on multiple sites, so there is a requirement to create a reusable component.</p>
<p>Bootstrap has an <code>OffCanvas</code> component and, while it’s simple HTML, we can turn this into a reusable component with Tag Helpers.</p>
<p>First, we need the structure of a Tag Helper. Here’s the code we need to execute:</p>
<pre class="source-code">
[HtmlTargetElement("offcanvas")]
public class OffCanvasTagHelper: TagHelper
{
    [HtmlAttributeName("id")]
    public string Id { get; set; }
    [HtmlAttributeName("tabindex")]
    public string TabIndex { get; set; }
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).GetContent();
        output.Attributes.Clear();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas offcanvas-start");
        if (!string.IsNullOrEmpty(Id))
        {
            output.Attributes.Add("id ", Id);
        }
        if (!string.IsNullOrEmpty(TabIndex))
        {
            output.Attributes.Add("tabindex", TabIndex);
        }
        output.Content.SetHtmlContent(childData);
    }
}</pre> <p>At the <a id="_idIndexMarker379"/>beginning of the code, we<a id="_idIndexMarker380"/> need to identify which HTML Tag we want to use for our Tag Helper. In this case, it’s a simple <code>offcanvas</code> tag. Since HTML tags, attributes, and CSS classes are all lowercase by default, every reference to the <code>OffCanvas</code> class should contain a lowercase string of the tag.</p>
<p>We want to include an ID and a tab index based on the examples, so we need two properties called <code>Id</code> and <code>TabIndex</code>, with <code>[HtmlAttributeName]</code> data annotations applied to each property.</p>
<p>The primary method is the <code>ProcessAsync</code> (or <code>Process</code>) method. We immediately grab any children inside the <code>offcanvas</code> tag and process the child tags, which we’ll get to later in this section.</p>
<p>We set <code>tagname</code> to <code>DIV</code>, set <code>classname</code> to <code>offcanvas</code>, set the attributes, and finally, set <code>innerHTML</code> to the child data retrieved from the beginning of the <code>ProcessAsync</code> method.</p>
<p>According to the <a id="_idIndexMarker381"/>Bootstrap <code>OffCanvas</code> documentation, we<a id="_idIndexMarker382"/> need a header and a body. We can easily duplicate this code to create a <code>header</code> and <code>body</code> tag for <code>offcanvasTagHelper</code>:</p>
<pre class="source-code">
[HtmlTargetElement("header", ParentTag = "offcanvas")]
public class OffCanvasHeaderTagHelper: TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).GetContent();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas-header");
        var header = new TagBuilder("h5")
        {
            TagRenderMode = TagRenderMode.Normal
        };
        header.Attributes.Add("id", "offcanvasLabel");
        header.AddCssClass("offcanvas-title");
        header.InnerHtml.Append(childData);
        var button = new TagBuilder("button")
        {
            TagRenderMode = TagRenderMode.Normal
        };
        button.AddCssClass("btn-close");
        button.Attributes.Add("type","button");
        button.Attributes.Add("data-bs-dismiss","offcanvas");
        button.Attributes.Add("aria-label","Close");
        output.Content.AppendHtml(header);
        output.Content.AppendHtml(button);
    }
}</pre> <p>The <code>HTMLTargetElement</code> data <a id="_idIndexMarker383"/>annotation <a id="_idIndexMarker384"/>is a little bit different. We called this tag <code>header</code>. Won’t this interfere with the regular HTML header tag? Not so long as we include <code>ParentTag</code> as a second parameter, saying this element is only valid within an <code>offcanvas</code> element.</p>
<p>In this <code>Process</code> method, we create a header and button and append the HTML to the output’s content at the bottom. This content is sent back to the parent <code>offcanvasTagHelper</code> instance as the child data.</p>
<p>We only need to create the body with <code>OffCanvasBodyTagHelper</code>, as shown in the following code:</p>
<pre class="source-code">
[HtmlTargetElement("body", ParentTag = "offcanvas")]
public class OffCanvasBodyTagHelper: TagHelper
{
    public override async Task ProcessAsync(TagHelperContext context,
        TagHelperOutput output)
    {
        var childData = (await output.GetChildContentAsync()).            GetContent();
        output.TagName = "div";
        output.Attributes.Add("class", "offcanvas-body");
        output.Content.SetHtmlContent(childData);
    }
}</pre> <p>This will<a id="_idIndexMarker385"/> contain the same <code>HTMLTargetElement</code> data<a id="_idIndexMarker386"/> annotation as our header, but we’ll call this the <code>body</code> tag. Again, it won’t interfere with the standard body HTML tag since we’re inside an <code>&lt;offcanvas&gt;</code> element. We get the child data (which should be a lot of HTML), we set the class and the <code>TagName</code> property, and finally set the content to what was inside the body tag.</p>
<p>One last thing required for our tag helper to work is to include all <code>TagHelper</code> instances in the project through the <code>_ViewImports.cshtml</code> file, like so:</p>
<pre class="source-code">
@addTagHelper *, BucksCoffeeShop</pre> <p>We can add a button to our HTML to trigger <code>offcanvas</code>, like so:</p>
<pre class="source-code">
&lt;button class="btn btn-primary btn-sm" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasExample" aria-controls="offcanvasExample"&gt;
    Open
&lt;/button&gt;</pre> <p>We can now create a simple <code>offcanvas</code> component in our HTML, as shown here:</p>
<pre class="source-code">
&lt;offcanvas id="offcanvasExample" tabindex="-1"&gt;
    &lt;header&gt;Buck's Coffee Shop&lt;/header&gt;
    &lt;body&gt;
        &lt;p&gt;
            Content for the offcanvas goes here.
            You can place just about any Bootstrap
            component or custom elements here.
        &lt;/p&gt;
    &lt;/body&gt;
&lt;/offcanvas&gt;</pre> <p>Once this is rendered, it will produce the Bootstrap result of an <code>OffCanvas</code> component with valid HTML.</p>
<p>This powerful technique can be applied to create a simplified HTML language for any domain where even non-developers can understand web pages.</p>
<p>In this section, we<a id="_idIndexMarker387"/> took a sample<a id="_idIndexMarker388"/> website and optimized our client-side scripts and styles, centralized our links by creating URL Helper extension methods, and finally, built an <code>OffCanvas</code> Tag Helper to showcase how we can create our own HTML library of powerful elements.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor162"/>Summary</h1>
<p>In this chapter, we began with how important a task runner is for client-side tasks and how to set up a task runner, then understood the structure of a gulpfile and how to create a workflow structure. Once we had our task runner working, we put it to work by focusing on transpiling TypeScript into JavaScript and bundling and minifying it into something for a production website.</p>
<p>We proceeded with looking at what’s considered a standard in the industry when it comes to UIs in ASP.NET 8. We learned about how to save time by centralizing all links in one place, why it’s important to keep controllers and Razor Pages small, and the key reasons why <code>ViewComponent</code> classes should be used. We learned why <code>TagHelper</code> classes are better than <code>HTMLHelper</code> classes and why a site should use SEO-friendly URLs.</p>
<p>To finalize this chapter, we looked at an example website and had a task runner bundle and minify our styles along with updating libraries automatically on build. We also applied URL Helper extension methods to the site, making it easier to change site-wide links. Finally, we took a Bootstrap <code>offcanvas</code> HTML component and converted it into a reusable <code>TagHelper</code> class to showcase the power of Tag Helpers.</p>
<p>In the next chapter, we’ll look at the different types of testing and what are the best ways to unit test our code.</p>
</div>
</body></html>