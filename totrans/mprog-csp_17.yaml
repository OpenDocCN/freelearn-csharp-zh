- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Static Code Analysis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: In today’s software development world, I believe it’s more important than ever
    to write clean and maintainable code. The increasing complexity of software, lower
    retention in the workforce, and increased competition should lead us to standardize
    our way of writing software more and put the next developer in the pit of success
    coming into the codebase. Catching errors early is super important when the developers
    have it in their mind, preferably. One of the ways to achieve this is through
    the use of static code analysis, which allows developers to identify potential
    issues and bugs in their code before it is even executed. With the Roslyn compiler
    extensions in C#, developers have the ability to create custom analyzers and code
    fixes that can help automate this process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的软件开发世界中，我认为编写干净且易于维护的代码比以往任何时候都更重要。软件的日益复杂化、劳动力留存率的降低以及竞争的加剧应促使我们标准化编写软件的方式，让下一个开发者进入代码库时能够站在成功的起点。当开发者心中有所意识时，尽早捕捉错误非常重要。实现这一目标的一种方式是通过使用静态代码分析，它允许开发者在代码执行之前就识别出潜在的问题和错误。在C#中，通过Roslyn编译器扩展，开发者能够创建自定义分析器和代码修复，这有助于自动化这一过程。
- en: In this chapter, we’ll explore the basics of static code analysis and how to
    use Roslyn compiler extensions to write your own analyzers and code fixes. We’ll
    cover everything from the fundamentals of writing an analyzer to create automated
    tests to ensure that your code is working as intended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨静态代码分析的基础以及如何使用Roslyn编译器扩展编写自己的分析器和代码修复。我们将从编写分析器的基础到创建自动化测试，确保代码按预期工作的一切内容。
- en: Whether you’re a seasoned developer looking to improve your code quality or
    a newcomer to the world of static code analysis, this chapter will provide you
    with the tools and knowledge you need to get started with Roslyn compiler extensions
    and take your code analysis to the next level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是寻求提高代码质量的资深开发者，还是静态代码分析领域的初学者，本章都将为你提供开始使用Roslyn编译器扩展并提升代码分析水平的工具和知识。
- en: What is static code analysis?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是静态代码分析？
- en: How to write an analyzer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写分析器
- en: How to write a code fix for an analyzer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为分析器编写代码修复
- en: How to write automated tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写自动化测试
- en: By the end of this chapter, you should have a solid understanding of how to
    use Roslyn compiler extensions to implement static code analysis in C#. You should
    be able to write your own custom analyzers and code fixes and know how to create
    automated tests to ensure the correctness of their implementation. Additionally,
    you should have a good understanding of the benefits of static code analysis and
    how it can improve the overall quality and maintainability of their code. With
    this knowledge, you will be well equipped to apply static code analysis techniques
    in your own development projects, leading to more efficient and effective software
    development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对如何使用Roslyn编译器扩展在C#中实现静态代码分析有一个扎实的理解。你应该能够编写自己的自定义分析器和代码修复，并了解如何创建自动化测试以确保其实现的正确性。此外，你应该对静态代码分析的好处以及它如何提高代码的整体质量和可维护性有一个良好的理解。有了这些知识，你将能够将静态代码分析技术应用到自己的开发项目中，从而实现更高效和有效的软件开发。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17)),
    and it builds on top of the **Fundamentals** code that is found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)).
    It also leverages the **Roslyn.Extensions** code that is found in the GitHub repository
    ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter17)），并且它建立在GitHub上找到的**基础**代码之上（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)）。它还利用了GitHub仓库中找到的**Roslyn.Extensions**代码（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Roslyn.Extensions)）。
- en: What is static code analysis?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是静态代码分析？
- en: '**Static code analysis** is a powerful technique for detecting issues and bugs
    in your code before it’s even executed. While it may seem like a relatively new
    development, the truth is that static code analysis has been around for decades
    and has been used in languages such as C/C++ through tools such as linters.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态代码分析**是一种在代码执行之前检测问题的强大技术。虽然它可能看起来是一种相对较新的发展，但事实是静态代码分析已经存在了几十年，并且已经在C/C++等语言中通过linters等工具得到应用。'
- en: Linters are essentially static code analysis tools that analyze source code
    to flag suspicious constructs or style inconsistencies. They have been around
    for several decades and are widely used in languages such as C/C++ to improve
    code quality and maintainability.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Linters本质上是一种静态代码分析工具，它分析源代码以标记可疑的结构或样式不一致。它们已经存在了几十年，并且在C/C++等语言中得到了广泛的应用，以提高代码质量和可维护性。
- en: In recent years, static code analysis has gained more popularity with the rise
    of languages such as JavaScript and TypeScript. Tools such as ESLint have been
    developed to provide similar benefits to JavaScript and TypeScript developers
    by analyzing code for potential issues and providing feedback on best practices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，随着JavaScript和TypeScript等语言的出现，静态代码分析变得更加流行。例如，ESLint这样的工具已经开发出来，为JavaScript和TypeScript开发者提供类似的好处，通过分析代码以查找潜在问题并提供最佳实践的反馈。
- en: The .NET Compiler **Software Development Kit** (**SDK**) from Microsoft takes
    a comprehensive approach to extending the compiler. Rather than just focusing
    on expanding its functionality, the SDK also enables the code to identify potential
    issues within your code editor or **Integrated Development Environment** (**IDE**).
    This feature is supported by popular editors, including **Visual Studio Code**
    (**VSCode**), Rider, and Visual Studio. As you work with files, the editors run
    analyzers in the background, highlighting potential issues with squiggly underlines.
    These analyzers can flag code that is incorrect or could be improved, providing
    real-time feedback to help you catch and correct mistakes more efficiently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的.NET编译器**软件开发工具包**（**SDK**）采取了一种全面的方法来扩展编译器。它不仅关注扩展其功能，而且SDK还使代码能够识别代码编辑器或**集成开发环境**（**IDE**）中的潜在问题。此功能由流行的编辑器支持，包括**Visual
    Studio Code**（**VSCode**）、Rider和Visual Studio。当你处理文件时，编辑器会在后台运行分析器，用波浪线突出显示潜在问题。这些分析器可以标记不正确或可以改进的代码，提供实时反馈，帮助你更有效地捕捉和纠正错误。
- en: Alongside analyzers, Microsoft has introduced code fixers, a feature that enables
    analyzer vendors to provide code that can automatically fix flagged code issues.
    These code fixes are represented by light bulbs within the editor, and you can
    click on them to execute the code fix. With this feature, you can quickly and
    easily apply fixes to your code and improve its overall quality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分析器之外，微软还引入了代码修复功能，这是一个允许分析器供应商提供可以自动修复标记的代码问题的功能。这些代码修复在编辑器中以灯泡的形式表示，你可以点击它们来执行代码修复。有了这个功能，你可以快速轻松地应用修复并提高代码的整体质量。
- en: In the following sections, we will provide an overview of static code analysis
    and code fixes in the context of the C# compiler and how they work. Although we
    won’t delve into the subject in great depth, we’ll provide you with the necessary
    information to get started. It’s important to note that the C# compiler APIs are
    extensive and offer great possibilities, and this introduction will serve as a
    starting point for exploring these features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将概述在C#编译器上下文中静态代码分析和代码修复，以及它们是如何工作的。虽然我们不会深入探讨这个主题，但我们会提供你开始所需的信息。重要的是要注意，C#编译器API非常广泛，提供了巨大的可能性，这个介绍将作为探索这些功能的起点。
- en: Let’s dive into writing an analyzer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨如何编写分析器。
- en: How to write an analyzer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编写分析器
- en: Writing an analyzer that gets automatically run as part of the compile process
    has been made very simple by Microsoft. It follows the same principles as source
    generators, as we saw in [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating
    Code*. Once you have the project set up, as we did back in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250),
    *Roslyn Compiler Extensions*, it’s all about dropping in a class that represents
    the analyzer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微软已经使编写在编译过程中自动运行的作为一部分的分析器变得非常简单。它遵循与我们在[*第16章*](B19418_16.xhtml#_idTextAnchor272)，“生成代码”中看到的源生成器相同的原理。一旦你设置了项目，就像我们在[*第15章*](B19418_15.xhtml#_idTextAnchor250)，“Roslyn编译器扩展”中所做的那样，那就只是插入一个代表分析器的类。
- en: In this chapter, all code assumes you have the **Roslyn.Extensions** project
    that we established in [*Chapter 15*](B19418_15.xhtml#_idTextAnchor250), *Roslyn*
    *Compiler Extensions*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，所有代码都假设你已经有了我们在[*第15章*](B19418_15.xhtml#_idTextAnchor250)中建立的**Roslyn.Extensions**项目，*Roslyn*
    *编译器扩展*。
- en: The analyzer we’re going to make is a highly opinionated one that affects the
    naming of exception types. One of the things we tend to do is to suffix our types
    with what they technically represent; for instance, exceptions are often suffixed
    with **Exception**. Looking at exceptions found in the .NET base class libraries,
    you’ll see things such as **NotImplementedException**, **ArgumentException**,
    or **ArgumentNullException**. This is something I personally don’t like, and I
    believe that it is not important information to communicate, and we should instead
    put effort into properly naming the types for what they do.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要制作的分析器是一个高度有争议的，它会影响异常类型的命名。我们倾向于做的一件事是在我们的类型后缀上加上它们在技术上代表的内容；例如，异常通常后缀为**Exception**。查看.NET基类库中找到的异常，你会看到像**NotImplementedException**、**ArgumentException**或**ArgumentNullException**这样的东西。这是我个人不喜欢的东西，我认为这不是需要传达的重要信息，我们应该将精力投入到为它们所做的事情正确命名类型。
- en: Take **ArgumentException** as an example. Its name does not convey its purpose.
    By simply changing it to be called **InvalidArgument**, it communicates that there
    is a violation – *the argument* *is invalid*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以**ArgumentException**为例。其名称并不能传达其用途。只需将其更名为**InvalidArgument**，就能传达出存在违规——*参数*
    *无效*。
- en: You might not agree with this type of rule in your code base. But let’s set
    aside that for a minute and just use this as an example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会同意你代码库中这种类型的规则。但让我们先暂时放下这一点，只把它作为一个例子。
- en: Fleshing out an analyzer
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完善分析器
- en: Let’s start by creating a home for the analyzer. In the **Roslyn.Extensions**
    project, add a folder called **CodeAnalysis**. I like to have folders for every
    analyzer type since we might be providing code fixes for the analyzer, and we
    might want to have more than just the analyzer class to create the analyzer. With
    that as a principle, add a folder within the **CodeAnalysis** folder called **ExceptionShouldNotBeSuffixed**;
    this will be the name of the analyzer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为分析器创建一个家开始。在**Roslyn.Extensions**项目中，添加一个名为**CodeAnalysis**的文件夹。我喜欢为每种分析器类型创建文件夹，因为我们可能需要为分析器提供代码修复，并且我们可能希望创建的不仅仅是分析器类。按照这个原则，在**CodeAnalysis**文件夹内添加一个名为**ExceptionShouldNotBeSuffixed**的文件夹；这将作为分析器的名称。
- en: 'In **ExceptionShouldNotBeSuffixed**, you can now add a file called **Analyzer.cs**.
    Put the following into the file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在**ExceptionShouldNotBeSuffixed**中，你现在可以添加一个名为**Analyzer.cs**的文件。将以下内容放入该文件中：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code sets up the basics for an analyzer by inheriting the **DiagnosticAnalyzer**
    type from the **.NET Compiler SDK**. In addition to this, it adorns the class
    with an **[DiagnosticAnalyzer]** attribute, instructing it that the supported
    language is C#. All the **using** statements are for the code to come.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过从**.NET Compiler SDK**中的**DiagnosticAnalyzer**类型继承来设置分析器的基础。除此之外，它还通过**[DiagnosticAnalyzer]**属性装饰了类，指示支持的语言是C#。所有的**using**语句都是为了后续代码。
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Analyzers can support multiple languages by specifying the additional languages
    it supports. It can, however, affect the complexity of your analyzer as there
    are differences in how the **abstract syntax tree** (**AST**) is represented.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器可以通过指定它支持的其他语言来支持多种语言。然而，这可能会影响分析器的复杂性，因为**抽象语法树**（**AST**）的表示方式存在差异。
- en: For the analyzer to work and be hooked up, it needs to be configured properly
    and register any actions that should be called.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分析器正常工作并连接起来，它需要正确配置并注册任何应该被调用的操作。
- en: 'Add the following method to the **Analyzer** class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到**Analyzer**类中：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code calls **EnableConcurrentExecution()** on the **AnalysisContext** passed,
    which informs the compiler that your analyzer can be executed concurrently with
    other analyzers in an asynchronous manner. If your analyzer does not support concurrent
    execution, you can simply omit this call. If your analyzer does support concurrent
    execution, it can help to speed up your builds, making your development process
    more efficient. Next, it configures whether or not your analyzer should be run
    on generated code. The analyzer you’re building now should not care about generated
    code; it is therefore configured to ignore it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在传递的 **AnalysisContext** 上调用 **EnableConcurrentExecution()**，这通知编译器您的分析器可以以异步方式与其他分析器并发执行。如果您的分析器不支持并发执行，您可以简单地省略此调用。如果您的分析器支持并发执行，它可以帮助加快您的构建速度，使您的开发过程更加高效。接下来，它配置是否应在生成的代码上运行您的分析器。您现在构建的分析器不应关心生成的代码；因此，它被配置为忽略它。
- en: Lastly, the code registers an action to be run on syntax nodes. A **syntax node**
    is a fundamental unit of the AST, as we looked at in [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272),
    *Generating Code*, and corresponds to a specific syntactic construct, such as
    a method call, a loop statement, or a class declaration. Syntax nodes are represented
    as objects in memory and are linked together in a tree-like structure that mirrors
    the structure of the source code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码注册了一个要在语法节点上运行的操作。**语法节点** 是 AST 的基本单元，正如我们在 [*第 16 章*](B19418_16.xhtml#_idTextAnchor272)，*生成代码*
    中所看到的，对应于特定的语法结构，例如方法调用、循环语句或类声明。语法节点作为内存中的对象表示，并以树状结构链接在一起，反映了源代码的结构。
- en: In our case, we’re only interested in class declarations; it therefore registers
    a **HandleClassDeclaration** callback with **SyntaxKind.ClassDeclaration**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只对类声明感兴趣；因此，它使用 **SyntaxKind.ClassDeclaration** 注册了一个 **HandleClassDeclaration**
    回调。
- en: When an analyzer encounters a problem, it needs to produce a response to the
    compiler that tells there is an issue, and it should be reported back to the developer.
    The representation of the issue is formalized into something called **DiagnosticDescriptor**.
    You need to create specific ones of these for every specific broken rule you get.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析器遇到问题时，它需要向编译器产生一个响应，告诉存在一个问题，并且应该报告给开发者。问题表示被形式化为称为 **DiagnosticDescriptor**
    的东西。您需要为每个特定的破坏性规则创建特定的这些。
- en: 'Add the following to the top of the **Analyzer** class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **Analyzer** 类的顶部：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code establishes a custom **DiagnosticDescriptor** that holds a reference
    to a unique diagnostic identifier (**PP0001**), a title, and a message to display
    to the developer. It also puts the broken rule into a category (**Naming**). Since
    the category is a string, this could be anything, but there are a few well-known
    ones used by other analyzers, such as **Naming**, **Design**, **Correctness**,
    **Performance**, and **Documentation**. The categories are used by tools to let
    developers group warnings or errors in a codebase. In the descriptor, you also
    put the severity level for the broken rule. The levels are shown in this table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码建立了一个自定义的 **DiagnosticDescriptor**，它包含对唯一诊断标识符（**PP0001**）、标题和显示给开发者的消息的引用。它还将破坏性规则放入一个类别（**命名**）。由于类别是一个字符串，这可以是任何东西，但有一些其他分析器使用的知名类别，例如
    **命名**、**设计**、**正确性**、**性能**和**文档**。这些类别被工具用于让开发者将代码库中的警告或错误分组。在描述符中，您还放入破坏性规则的严重程度级别。级别如下表所示：
- en: '| **Level** | **Description** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **Level** | **Description** |'
- en: '| --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Hidden | Not surfaced through normal means |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Hidden | 不会通过常规方式呈现 |'
- en: '| Info | Information that does not indicate a problem |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Info | 不表示问题的信息 |'
- en: '| Warning | Suspicious but allowed; the developer should just know about it
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| Warning | 可疑但允许；开发者只需知道即可 |'
- en: '| Error | Not allowed; the build will be broken |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| Error | 不允许；构建将被破坏 |'
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the developer using your analyzer decides to use the **TreatWarningsAsErrors**
    option in the **.csproj** file, the warnings will be treated as errors and break
    the build. The **Roslyn.Extension.props** file that is included in projects using
    this extension has that option turned on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用您分析器的开发者决定在 **.csproj** 文件中使用 **TreatWarningsAsErrors** 选项，警告将被视为错误并中断构建。包含在此扩展项目中的
    **Roslyn.Extension.props** 文件已将该选项启用。
- en: The last few properties of **DiagnosticDescriptor** are further details to help
    the developers understand the compiler error or warning you want to communicate.
    You could, for instance, include a link to a web page describing in detail the
    analyzer or the specific rule you have implemented.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**DiagnosticDescriptor**的最后几个属性是进一步细节，以帮助开发者理解你想要传达的编译器错误或警告。例如，你可以包含一个链接到网页，详细描述分析器或你已实现的特定规则。'
- en: Handling the syntax nodes
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理语法节点
- en: 'For the analyzer to work, you’re going to need an implementation of the **HandleClassDeclaration**
    callback that was given during the **Initialize** method. Add the following private
    method to the **Analyzer** class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使分析器工作，你需要实现**Initialize**方法期间提供的**HandleClassDeclaration**回调。将以下私有方法添加到**Analyzer**类中：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code starts by looking at the syntax node being analyzed. The syntax node
    would typically be things such as a method declaration, a class definition, or
    a variable declaration. Syntax nodes are used to represent the structure of the
    code but do not convey information about the meaning or semantics of the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先查看正在分析的语法节点。语法节点通常是方法声明、类定义或变量声明等。语法节点用于表示代码的结构，但不传达关于代码意义或语义的信息。
- en: The code assumes the syntax node is a **ClassDeclarationSyntax** node, as that
    was what was configured as a filter in the **Initialize()** method. It then looks
    at the **BaseList** property to see whether the class declaration inherits from
    another type. If it doesn’t, the analyzer is not interested in the node, as it
    only wants to analyze types that inherit from **Exception**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设语法节点是**ClassDeclarationSyntax**节点，因为这是在**Initialize()**方法中配置为过滤器的。然后它查看**BaseList**属性，看类声明是否继承自其他类型。如果没有，分析器对节点不感兴趣，因为它只想分析继承自**Exception**的类型。
- en: For the analyzer to understand the semantic meaning of the node being passed,
    it has to use **SemanticModel** to do so. From the declared symbol, it makes sure
    it has a base type; if not, it just returns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让分析器理解传递的节点语义意义，它必须使用**SemanticModel**来实现。从声明的符号，它确保有一个基类型；如果没有，它就返回。
- en: Next, the code asks for a representation of the **System.Exception** type, which
    is then used to check if **BaseType** is, in fact, an exception. If it is an exception,
    it then checks the class identifier to see whether it is suffixed with the **Exception**
    text. If it is suffixed, it then reports back with an instance of the broken rule
    that holds the location of the class declaration identifier that was wrong.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码请求**System.Exception**类型的表示，然后用于检查**BaseType**是否实际上是一个异常。如果是异常，它将检查类标识符，看它是否以**Exception**文本结尾。如果是，它将报告一个包含错误位置类声明标识符的断言规则的实例。
- en: That is pretty much it for creating a simple analyzer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是创建一个简单分析器的全部内容。
- en: Release tracking
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布跟踪
- en: 'Suppose you go and build the **Roslyn.Extensions** project, you will get a
    warning that looks something like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你构建了**Roslyn.Extensions**项目，你会得到一个类似于以下警告：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The **RS2008** warning tells you that we could add information to our project
    that would make it easier to track releases of your packaged analyzers and the
    rules it provides. If this is not important to you, you can ignore this warning
    and move on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**RS2008**警告告诉你，我们可以向项目中添加信息，使跟踪打包分析器和它提供的规则更容易。如果你认为这不重要，你可以忽略这个警告并继续。'
- en: To satisfy the warning, we need to provide two files. One that contains the
    shipped rules and one that contains the unshipped rules. For an initial release,
    the unshipped rules file would typically be empty, while you might be putting
    in unshipped rules as part of releases for rules that are upcoming. When the rules
    are shipped, you typically move these from unshipped to shipped.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足警告，我们需要提供两个文件。一个是包含已发货规则的文件，另一个是包含未发货规则的文件。对于初始发布，未发货规则文件通常为空，而你可能会在即将发布的规则的发布中添加未发货规则。当规则发货时，你通常将这些规则从未发货移动到已发货。
- en: You can read more detail about the purpose of these files on GitHub ([https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md](https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上阅读更多关于这些文件目的的详细信息（[https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md](https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md)）。
- en: 'Let’s add a file in the root of the **Roslyn.Extensions** project called **AnalyzerReleases.Shipped.md**
    and add the following content to it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 **Roslyn.Extensions** 项目的根目录下添加一个名为 **AnalyzerReleases.Shipped.md** 的文件，并将其以下内容添加到其中：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The content indicates a release version of **1.0** and provides a table of rules.
    In your case, you only have one rule. The **Notes** column could hold the name
    of the analyzer and, if you’d like, a link to a description of the broken rule.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 内容表明这是一个 **1.0** 版本的发布版本，并提供了一个规则表。在你的情况下，你只有一个规则。**注释**列可以包含分析器的名称，如果你愿意，还可以包含一个指向违反规则描述的链接。
- en: With the shipped file in place, you’ll need a file for unshipped. Add a file
    called **AnalyzerReleases.Unshipped.md**. This file can be empty at this point,
    so just leave it as is.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了发布文件后，你需要一个未发布的文件。添加一个名为 **AnalyzerReleases.Unshipped.md** 的文件。在此阶段，此文件可以是空的，所以只需保持原样。
- en: 'When packaging your Roslyn extension as a NuGet package, you want the files
    to be included. Open the **Roslyn.Extensions.csproj** file and add the following
    at the bottom of the file, within the **Project** tag:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当将你的 Roslyn 扩展打包成 NuGet 包时，你希望包含这些文件。打开 **Roslyn.Extensions.csproj** 文件，并在文件的底部，在
    **Project** 标签内添加以下内容：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s it! Your analyzer is now ready to be put into the real world and used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的分析器现在已经准备好投入实际应用并使用了。
- en: Trying out the analyzer
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试使用分析器
- en: 'To test the analyzer and see that it works and performs the way we expect it
    to, you’ll need a project that has code that violates the rule put into the analyzer:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试分析器并确认其按预期工作，你需要一个包含违反规则代码的项目放入分析器中：
- en: 'Create a new folder, next to the **Roslyn.Extensions** folder called **Chapter17**.
    Within the **Chapter17** folder in a terminal, create a new project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹，位于 **Roslyn.Extensions** 文件夹旁边，名为 **Chapter17**。在终端中，在 **Chapter17**
    文件夹内创建一个新的项目：
- en: '[PRE7]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then you need a reference to the **Roslyn.Extensions** project. The project
    reference can not be a standard project reference; it needs to be slightly different.
    Add the following within the **Project** tag of the **Chapter17.csproj** file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你需要一个对 **Roslyn.Extensions** 项目的引用。项目引用不能是标准的项目引用；它需要稍微有所不同。在 **Chapter17.csproj**
    文件的 **Project** 标签内添加以下内容：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By telling it that **OutputItemType** is **Analyzer**, it will automatically
    hook up the assembly output from the **Roslyn.Extensions** project to the compiler.
    **ReferenceOutputAssembly** set to **false** tells it that the compiled output
    of the project will not reference the output assembly of the **Roslyn.Extensions**
    project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过告诉它 **OutputItemType** 是 **Analyzer**，它将自动将 **Roslyn.Extensions** 项目的程序集输出连接到编译器。将
    **ReferenceOutputAssembly** 设置为 **false** 告诉它，项目的编译输出将不会引用 **Roslyn.Extensions**
    项目的输出程序集。
- en: 'Since your **Roslyn.Extensions** project should, at this point in time, be
    holding the **General Data Protection Regulation** (**GDPR**) solution built in
    [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272), *Generating Code*, and it has
    a requirement of a configuration property to be present, you’ll need to add the
    following within a **PropertyGroup** tag in the **Chapter17.csproj** file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你的 **Roslyn.Extensions** 项目在此阶段应该包含在 [*第16章*](B19418_16.xhtml#_idTextAnchor272)
    中构建的 **通用数据保护条例** （**GDPR**）解决方案，并且它需要一个配置属性存在，你需要在 **Chapter17.csproj** 文件的 **PropertyGroup**
    标签内添加以下内容：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in the **Chapter17.csproj** file in the **Chapter17** folder, you will
    need to add a reference to the props file from the **Roslyn.Extensions** project.
    Add the following at the top of the file within the **Project** tag:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **Chapter17** 文件夹中的 **Chapter17.csproj** 文件中，你需要添加对 **Roslyn.Extensions**
    项目中 props 文件的引用。在文件的顶部，在 **Project** 标签内添加以下内容：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the **Chapter17** folder, add a file called **MyException.cs** and add the
    following to it:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Chapter17** 文件夹中，添加一个名为 **MyException.cs** 的文件，并将其内容添加到其中：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open your terminal and do a build, you should see something like the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的终端并执行构建，你应该看到如下所示的内容：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output clearly says that you have a **PP0001** error, and the text describes
    the actual problem.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地表明你有一个 **PP0001** 错误，文本描述了实际的问题。
- en: 'This is pretty cool, but what’s even cooler is that in your editor, you should
    get a clear indication that you have an error by getting a squiggly line underlining
    the **MyException** class name. In **Visual Studio Code** (**VS Code**), this
    would look like the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但更酷的是，在你的编辑器中，你应该通过在 **MyException** 类名下得到一个波浪线来清楚地指示你有一个错误。在 **Visual Studio
    Code** （**VS Code**）中，这看起来如下所示：
- en: '![](img/B19418_17_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_17_01.jpg)'
- en: Figure 17.1 – VS Code analysis error
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 – VS Code 分析错误
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you’re having trouble getting your editor to show the analyzer error, you
    might need to restart it, or if it has a language server, just restart that. For
    VS Code, you can simply bring up the command palette (*F1*) and type **OmniSharp**
    and then select **OmniSharp:** **Restart OmniSharp**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的编辑器没有显示分析器错误，你可能需要重新启动它，或者如果它有一个语言服务器，只需重新启动那个。对于 VS Code，你可以简单地打开命令面板（*F1*）并输入**OmniSharp**，然后选择**OmniSharp:**
    **重启 OmniSharp**。
- en: With an analyzer in place, it’s time to look into making your developers more
    productive so that they can fix errors quite easily.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好分析器之后，现在是时候考虑如何让开发者更高效，以便他们可以轻松修复错误了。
- en: How to write a code fix for an analyzer
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为分析器编写代码修复
- en: As discussed earlier, the .NET Compiler SDK supports more than just writing
    analyzers that analyze your code. You can also provide code that quickly fixes
    any errors that occur. These are understood by most editors and IDEs and will
    automatically be loaded and presented when applicable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，.NET 编译器 SDK 不仅支持编写分析器来分析你的代码，你还可以提供快速修复任何发生的错误的代码。这些通常被大多数编辑器和 IDE 所理解，并且当适用时将自动加载并显示。
- en: 'You’ll be reusing the **Roslyn.Extensions** project for the code fix as well.
    The code fix needs to tap into specific APIs and needs another package reference.
    Add a reference to **Microsoft.CodeAnalysis.CSharp.Workspaces** by running the
    following in your terminal within the **Roslyn.Extensions** folder:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将重用**Roslyn.Extensions**项目来修复代码。代码修复需要调用特定的 API，并且需要另一个包引用。在**Roslyn.Extensions**文件夹内运行以下命令来添加对**Microsoft.CodeAnalysis.CSharp.Workspaces**的引用：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the package reference in place, it’s time for the implementation of the
    code fix:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好包引用之后，现在是时候实现代码修复了：
- en: 'Start by adding a file called **CodeFix.cs** within the **CodeAnalysis/ExceptionShouldNotBeSuffixed**
    folder in the **Roslyn.Extensions** project folder. Add the following to it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**Roslyn.Extensions**项目文件夹中的**CodeAnalysis/ExceptionShouldNotBeSuffixed**文件夹内添加一个名为**CodeFix.cs**的文件。将其内容添加如下：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code sets up a code fix by inheriting from the **CodeFixProvider** and adding
    the **[ExportCodeFixProvider]** attribute. It specifies the language it supports
    and the name of the code fix. As with the analyzer, you can support multiple languages
    by specifying that on the attribute. If you want, you can narrow down the document
    types you want to support and also file extensions by setting the **DocumentKinds**
    or **DocumentExtensions** properties of **ExportCodeFixProvider**. We leave these
    as default, as we trust the editor to call us correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过从**CodeFixProvider**继承并添加**[ExportCodeFixProvider]**属性来设置代码修复。它指定了它支持的语言和代码修复的名称。与分析器一样，你可以通过在属性中指定来支持多种语言。如果你想，你可以通过设置**ExportCodeFixProvider**的**DocumentKinds**或**DocumentExtensions**属性来缩小你想要支持的文档类型和文件扩展名。我们将其保留为默认值，因为我们相信编辑器会正确地调用我们。
- en: 'For the code fix to be invoked, it needs to specify what broken rule it can
    fix. This is done by providing an array of the rule diagnostic identifier. Add
    the following within the **CodeFix** class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调用代码修复，它需要指定它可以修复的损坏规则。这是通过提供一个规则诊断标识符数组来实现的。在**CodeFix**类中添加以下内容：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the broken rule association in place, the next thing you’ll need is a
    method that registers the code fix and the code to be called when the code fix
    is invoked. Add the following method to the **CodeFix** class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好损坏规则关联之后，接下来你需要的是一个注册代码修复以及当代码修复被调用时将被调用的方法的函数。将以下方法添加到**CodeFix**类中：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code assumes there is only one **Diagnostic** that can be errored. This
    is because there is only one in the analyzer. If you have more, you’d need to
    find the correct diagnostic and match the appropriate code fix to it. However,
    for maintainability, I would recommend having one file per code fix linked to
    one broken rule.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码假设只有一个可能出错的**Diagnostic**。这是因为分析器中只有一个。如果你有多个，你需要找到正确的诊断并匹配适当的代码修复。然而，为了可维护性，我建议每个代码修复对应一个文件，链接到一个损坏的规则。
- en: Next, the code registers a code fix for the diagnostic; it does so by creating
    a **CodeAction** that holds a title to display the code fix and the callback to
    be called when the code fix is invoked by the developer.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，代码为诊断注册了一个代码修复；它是通过创建一个包含显示代码修复标题的**CodeAction**以及当开发者调用代码修复时将被调用的回调函数来实现的。
- en: 'All code fix providers can fix single problems, but they can also fix multiple
    by providing **FixAllProvider**. This is something you can choose to implement
    yourself if it needs special handling or use the default **BatchFixer**. Add the
    following method to provide **FixAllProvider**. This is completely optional; by
    default, it does not provide any:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码修复提供者都可以修复单个问题，但它们也可以通过提供**FixAllProvider**来修复多个问题。如果你需要特殊处理，可以选择自己实现它，或者使用默认的**BatchFixer**。添加以下方法以提供**FixAllProvider**。这是完全可选的；默认情况下，它不提供任何：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last thing you’ll need is the code that performs the code fix. The only
    fix you can really do is to provide code that removes the suffix. Add the following
    code to the **CodeFix** class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最后需要的是执行代码修复的代码。你真正能做的唯一修复是提供移除后缀的代码。将以下代码添加到**CodeFix**类中：
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code navigates the document and finds the **ClassDeclarationSyntax** node.
    If it can’t find it, the code fix does not do anything. It then replaces the **Exception**
    text in the **Identifier** of the node with **string.Empty** and then replaces
    the node. It then returns a modified version of the document with the modified
    node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历文档并找到**ClassDeclarationSyntax**节点。如果找不到它，代码修复不会做任何事情。然后它将节点中的**Exception**文本替换为**string.Empty**，然后替换节点。然后它返回一个包含修改后节点的修改后的文档版本。
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Since this code fix is a very simple one, it does not leverage much of the APIs
    available for code fixes. An important aspect of code fixes is to be aware of
    formatting and make sure the result is formatted correctly. This is done by adding
    **.WithAdditionalAnnotations(Formatter.Annotation)** on the node when altering
    it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个代码修复非常简单，它并没有充分利用代码修复可用的 API。代码修复的一个重要方面是要注意格式，并确保结果格式正确。这是通过在修改节点时添加**.WithAdditionalAnnotations(Formatter.Annotation)**来完成的。
- en: This is all you need to do for a simple code fix to work. All you now need to
    do is compile it and open a file that violates the rule. In your case, that would
    be the **MyException.cs** file within the **Chapter17** folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实现简单代码修复所需的所有内容。你现在需要做的就是编译它，并打开一个违反规则的文件。在你的情况下，就是**Chapter17**文件夹中的**MyException.cs**文件。
- en: 'Editors do this slightly differently, but within VS Code, the code fix capability
    would show up as a lightbulb, and clicking the lightbulb would then show the **Remove
    Exception suffix** code fix:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器在这方面略有不同，但在 VS Code 中，代码修复功能会显示为一个灯泡图标，点击灯泡图标会显示**移除异常后缀**代码修复：
- en: '![](img/B19418_17_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_17_02.jpg)'
- en: Figure 17.2 – VS Code code fix
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 – VS Code代码修复
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you’re having trouble getting your editor to show the code fix, you might
    need to restart it, or if it has a language server, just restart that. For VS
    Code, you can simply bring up the command palette (*F1*) and type **OmniSharp**
    and then select **OmniSharp:** **Restart OmniSharp**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的编辑器无法显示代码修复，你可能需要重新启动它，或者如果它有一个语言服务器，只需重新启动那个。对于 VS Code，你可以简单地调出命令面板（*F1*）并输入**OmniSharp**，然后选择**OmniSharp:**
    **重启 OmniSharp**。
- en: Testing your analyzer and code fix with the compiler and an editor does not
    give you the best feedback loop, and as with any code you write, it would be hard
    to catch regression bugs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译器和编辑器测试你的分析器和代码修复并不能提供最佳的反馈循环，并且就像你写的任何代码一样，捕捉回归错误可能会很困难。
- en: How to write automated tests
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编写自动化测试
- en: Writing automated tests for all your code gives you the confidence to change
    your code and know whether you broke anything. This applies to all code, including
    analyzers and code fixes. For anything that extends the compiler or provides editors
    or IDEs with new capabilities, it’s also harder to test whether or not your implementation
    works. It can be frustrating at times to get things working and can hamper your
    productivity by building these.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为你所有的代码编写自动化测试可以让你在更改代码时更有信心，并知道你是否破坏了任何东西。这适用于所有代码，包括分析器和代码修复。对于任何扩展编译器或为编辑器或
    IDE 提供新功能的代码，测试其实现是否工作也更困难。有时候，让事情工作起来可能会很令人沮丧，并且通过构建这些可能会阻碍你的生产力。
- en: 'Luckily, Microsoft has provided an easy way to test your analyzers and code
    fixes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Microsoft 提供了一种简单的方法来测试你的分析器和代码修复：
- en: 'Next to the **Roslyn.Extensions** folder, create a folder called **Roslyn.Extensions.Tests**.
    In a terminal, navigate to the **Roslyn.Extensions.Tests** folder and run the
    following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions**文件夹旁边，创建一个名为**Roslyn.Extensions.Tests**的文件夹。在终端中，导航到**Roslyn.Extensions.Tests**文件夹，并运行以下命令：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The command will set up a [test project usin](https://xunit.net)g the xUnit
    ([https://xunit.net](https://xunit.net)) testing library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将设置一个使用xUnit ([https://xunit.net](https://xunit.net)) 测试库的测试项目。
- en: Important note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use other testing frameworks as well, such as MSTest or NUnit.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用其他测试框架，例如MSTest或NUnit。
- en: We will not cover unit testing or the specifics of xUnit. You can read more
    about xUnit on its site.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会涵盖单元测试或xUnit的特定内容。你可以在其网站上了解更多关于xUnit的信息。
- en: 'The next thing you’ll need is a project reference to the **Roslyn.Extensions**
    project. Run the following command within the **Roslyn.Extensions.Tests** folder:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步你需要的是对**Roslyn.Extensions**项目的项目引用。在**Roslyn.Extensions.Tests**文件夹内运行以下命令：
- en: '[PRE21]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This adds a project reference to the **Roslyn.Extensions** project, and you
    may notice that you did this differently than with the **Chapter17** project.
    The reason is that in the context of testing, you need the **Roslyn.Extensions**
    assembly to be referenced by the test assembly and be present at the runtime of
    the tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为**Roslyn.Extensions**项目添加一个项目引用，你可能注意到你这样做的方式与**Chapter17**项目不同。原因是，在测试的上下文中，你需要**Roslyn.Extensions**程序集被测试程序集引用，并且在测试的运行时存在。
- en: Analyzer tests
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器测试
- en: With the test project in place and the reference to the extension project itself,
    we can start filling it with the tests we want. The first thing you want to write
    a test for is the analyzer. The purpose of the tests for the analyzer is to verify
    that the analyzer will give an error when the code contains an exception that
    is suffixed and not give an error when exception types do not have a suffix.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试项目和扩展项目本身引用就绪后，我们可以开始填充我们想要的测试。你首先想要编写测试的是分析器。分析器测试的目的是验证当代码包含一个后缀的异常时，分析器会给出错误，而当异常类型没有后缀时不会给出错误。
- en: 'Add a folder called **ExceptionShouldNotBeSuffixed** within the **Roslyn.Extensions.Tests**
    folder. Then add a file called **AnalyzerTests**. Put the following content into
    it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions.Tests**文件夹内添加一个名为**ExceptionShouldNotBeSuffixed**的文件夹。然后添加一个名为**AnalyzerTests**的文件。将以下内容放入其中：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This sets up the basics needed for writing the tests. You’re probably asking
    yourself why the namespace declaration comes before the **using** statements.
    We’re doing that to avoid having to use the fully qualified name in **Verify**
    using an alias. The **Verify** alias creates an alias for the **AnalyzerVerifier<>**
    generic type and gives it the analyzer under test as a generic parameter. The
    aliasing is just for convenience, making your tests easier to read and write.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了编写测试所需的基本内容。你可能想知道为什么命名空间声明在**using**语句之前。我们这样做是为了避免在**Verify**中使用别名时必须使用完全限定名。**Verify**别名创建了一个别名用于**AnalyzerVerifier<>**泛型类型，并将其分析器作为泛型参数。别名化只是为了方便，使你的测试更容易阅读和编写。
- en: Also, another slightly different thing is the word **Tests**, which the **Roslyn.Extensions.Tests**
    project name is suffixed with, which is normally something you would also reflect
    in the namespace. Personally, I prefer not to, as test projects are not something
    you’re deploying, and it generally makes things simpler if you omit this from
    your namespace. But that is entirely a personal preference.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一个稍微不同的事情是单词**Tests**，这是**Roslyn.Extensions.Tests**项目名称后缀，这通常是你在命名空间中也会反映出来的东西。我个人更喜欢不这样做，因为测试项目不是你部署的东西，如果你从命名空间中省略它，通常会使事情更简单。但这完全是个人的偏好。
- en: 'The first thing you want to test is whether the analyzer is analyzing the correct
    code. Add the following method to the **AnalyzerTests** class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先想要测试的是分析器是否正在分析正确的代码。将以下方法添加到**AnalyzerTests**类中：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The test sets up a valid C# program and calls the **VerifyAnalyzerAsync()**
    method for that program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置了一个有效的C#程序，并调用该程序的**VerifyAnalyzerAsync()**方法。
- en: 'Then you need a test for testing the violation of the rule. Add the following
    method to the **AnalyzerTests** class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要一个测试来测试规则的违规情况。将以下方法添加到**AnalyzerTests**类中：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The test sets up an invalid C# program and sets up an expectation of a failure
    at line **5** and column **30**. Since you’re putting in the content of the file
    this way, the first line will be empty, and the column is also then the column
    you see in the editor, which should be **30** with the method indented. You could
    improve this by embedding files as embedded resources that you could then maintain
    separately and have a more predictable setup for. The **VerifyAnalyzerAsync()**
    method is then called with the content and the expectations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置了一个无效的C#程序，并设置了一个期望在第**5**行和第**30**列失败。由于你以这种方式输入文件内容，第一行将是空的，列数也是你在编辑器中看到的列数，应该是**30**，方法缩进后。你可以通过将文件作为嵌入资源嵌入来改进这一点，这样你就可以单独维护它们，并有一个更可预测的设置。然后，使用内容和期望调用**VerifyAnalyzerAsync()**方法。
- en: That’s the tests we want to perform for the analyzer at this point. But we do
    also have a code fix for the analyzer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是我们想要对这个分析器执行的测试。但我们也有一个针对分析器的代码修复。
- en: Code fix tests
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码修复测试
- en: 'As with the analyzer, you can create tests specific to code fixes. It uses
    a different verifier than the analyzer: **CodeFixVerifier**. Let’s get started:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析器类似，你可以为代码修复创建特定的测试。它使用与分析器不同的验证器：**CodeFixVerifier**。让我们开始吧：
- en: 'Add a file called **CodeFixTests** within the **ExceptionShouldNotBeSuffixed**
    folder in the **Roslyn.Extensions.Test** project folder. Then add a file called
    **CodeFixTests.cs** and add the following content to it:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions.Test**项目文件夹中的**ExceptionShouldNotBeSuffixed**文件夹内添加一个名为**CodeFixTests**的文件。然后添加一个名为**CodeFixTests.cs**的文件，并将以下内容添加到其中：
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you did with the analyzer tests, you used a verifier. For code fixes, it
    is a different type of verifier: **CodeFixVerifier**.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在分析器测试中所做的那样，你使用了验证器。对于代码修复，它是一种不同类型的验证器：**CodeFixVerifier**。
- en: The **CodeFixVerifier** verifier needs two generic arguments, the first one
    representing the analyzer and the second representing the code fix being tested.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodeFixVerifier**验证器需要两个泛型参数，第一个代表分析器，第二个代表正在测试的代码修复。'
- en: 'Add the following test method to the **CodeFixTests** class:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到**CodeFixTests**类中：
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The code verifies that the code fix does not perform any actions when the C#
    program is a valid program that doesn’t break the rule.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 代码验证了当C#程序是一个有效的程序且不违反规则时，代码修复不会执行任何操作。
- en: 'Next, you need a test that verifies the code fix actually performs what is
    expected. Add the following method to the **CodeFixTests** class:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要一个测试来验证代码修复实际上执行了预期的操作。将以下方法添加到**CodeFixTests**类中：
- en: '[PRE27]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with the analyzer test for the broken rule scenario, it sets up an expectation
    that there should be a compiler error at a specific location. Additionally, it
    then verifies that the code fix actually replaces the **MyException** text by
    removing the suffix.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与违反规则场景的分析器测试类似，它设置了一个期望，即在特定位置应该有一个编译器错误。然后，它还验证代码修复实际上通过删除后缀来替换了**MyException**文本。
- en: 'With tests for both the analyzer and the code fix in place, you can run these
    by running the following in your terminal within the **Roslyn.Extensions.Tests**
    folder:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Roslyn.Extensions.Tests**文件夹中运行以下命令，即可运行针对分析器和代码修复的测试：
- en: '[PRE28]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should then see something like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到以下类似的内容：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you are using an editor that supports xUnit tests, chances are they are already
    visible in the test explorer of your editor, and you can run them from there as
    well.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是支持xUnit测试的编辑器，那么它们可能已经在你的编辑器的测试资源管理器中可见，并且你可以从那里运行它们。
- en: For a full overview of the **Microsoft.CodeAnalysis.Testing** project, I recommend
    heading over to GitHub ([https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md](https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**Microsoft.CodeAnalysis.Testing**项目的全面概述，我建议您前往GitHub（[https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md](https://github.com/dotnet/roslyn-sdk/blob/main/src/Microsoft.CodeAnalysis.Testing/README.md)）。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve covered the use of Roslyn compiler extensions for performing
    static code analysis in C#. We began by explaining what static code analysis is
    and how it differs from dynamic analysis, as well as its benefits and limitations.
    We then covered how to write custom analyzers using Roslyn, using diagnostics
    to report issues, and implementing code fixes to automatically correct issues.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在C#中使用Roslyn编译器扩展进行静态代码分析的方法。我们首先解释了什么是静态代码分析，以及它与动态分析的区别，以及它的优点和局限性。然后，我们介绍了如何使用Roslyn编写自定义分析器，使用诊断来报告问题，并实现代码修复来自动纠正问题。
- en: We also discussed best practices for testing and maintaining code analysis tools,
    as well as how to build rules that are specific to your team and domain. Catching
    errors fast is crucial for minimizing development time and cost, and static code
    analysis is a powerful tool for achieving this. By detecting issues and bugs in
    your code before it’s even executed, you can avoid costly mistakes and improve
    overall code quality and maintainability.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了测试和维护代码分析工具的最佳实践，以及如何构建针对您团队和领域的特定规则。快速捕捉错误对于最小化开发时间和成本至关重要，静态代码分析是实现这一目标的强大工具。通过在代码执行之前检测到问题，您可以避免代价高昂的错误，并提高整体代码质量和可维护性。
- en: You should now have a solid understanding of how to use Roslyn for static code
    analysis in C#, as well as the benefits and challenges of this approach. You should
    also understand how to write effective analyzers and code fixes and how to build
    custom rules for their specific team and domain.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该对如何使用Roslyn在C#中进行静态代码分析有了牢固的理解，以及这种方法的好处和挑战。您还应该了解如何编写有效的分析器和代码修复，以及如何为特定团队和领域构建自定义规则。
- en: Static code analysis is a powerful technique for catching errors quickly and
    improving overall code quality and maintainability. By building custom rules that
    are specific to your team and domain, you can ensure that your code is not only
    error-free but also conforms to your team’s standards and practices. This can
    save time and resources that would otherwise be spent on debugging and testing,
    allowing you to deliver higher-quality software faster.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是一种强大的技术，可以快速捕捉错误并提高整体代码质量和可维护性。通过构建针对您团队和领域的特定规则，您可以确保您的代码不仅无错误，而且符合您团队的标准和惯例。这可以节省在调试和测试上花费的时间和资源，让您能够更快地交付高质量的软件。
- en: This chapter concludes the practical sides of the book, and the next and final
    chapter will cover general caveats and some final words about everything discussed
    in the book.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的实践方面，下一章和最后一章将涵盖一些一般性的注意事项，以及对本书中讨论的所有内容的最后几句话。
