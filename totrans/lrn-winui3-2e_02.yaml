- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring the Development Environment and Creating the Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with WinUI and Windows App SDK development, it is important to
    install and configure Visual Studio for Windows desktop development. A WinUI developer
    must also understand the basics of applicationdevelopment with **Extensible Application
    Markup Language** (**XAML**) and C#, which we started learning in [*Chapter 1*](B20908_01.xhtml#_idTextAnchor015),
    *Introduction to WinUI*. However, the best way to understand the development concept
    is to get your hands on a real project. We will do that in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up your Visual Studio development environment, you will create
    the beginnings of a project that we will be building throughout the rest of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to set up a new Visual Studio installation for Windows desktop application
    development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a new WinUI project, add a few controls, and run the project for
    the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anatomy of a new WinUI project and why each part is important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How XAML can be used to build flexible, performant **user** **interfaces** (**UIs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How WinUI fits with .NET and the role of each layer in the overall application
    architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with WinUI controls and customize them through changes in the XAML
    markup or C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle some basic UI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are new to WinUI and other XAML-based development platforms, by the end
    of this chapter, you should be starting to feel comfortable working with WinUI
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 10, version 1809 (build 17763) or newer or Windows 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.1 or later with the **.NET desktop development**
    workload and **Windows App SDK C# Templates** selected during installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available on GitHub at this URL: [https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Visual Studio and Windows desktop development workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to follow when starting with WinUI development is to install
    Microsoft’s Visual Studio **integrated development environment** (**IDE**). You
    can download the current version of Visual Studio 2022 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
    Visual Studio 2022 Community Edition is free for personal use and has all the
    features you will need to build WinUI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to try new Visual Studio features before they are released, you
    can install the latest Visual Studio Preview version from [https://visualstudio.microsoft.com/vs/preview/](https://visualstudio.microsoft.com/vs/preview/).
    The Preview version is not recommended for the development of production applications
    as some features are unstable.
  prefs: []
  type: TYPE_NORMAL
- en: 'During installation, you can select workloads for any type of application that
    you want to create. For WinUI development, you must start by selecting the **.NET
    desktop development** workload. An overview of the **Workloads** section is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Visual Studio Installer workload selection](img/B20908_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Visual Studio Installer workload selection
  prefs: []
  type: TYPE_NORMAL
- en: After the **.NET desktop development** workload has been selected, select the
    **Windows App SDK C# Templates** component from the **Installation details** pane.
    These templates, required for building WinUI apps, are not installed by default
    with the workload.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation](img/B20908_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Selecting the Windows App SDK C# Templates component for installation
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are a C++ developer and would like to build WinUI apps with C++, you
    must select the **Desktop development with C++** workload and the optional **Windows
    App SDK C++ Templates** component within the **Desktop development with C++**
    workload. However, building WinUI applications with C++ is beyond the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: When continuing to the next step, the Visual Studio Installer will download
    and install all selected workloads and components. When setup is complete, launch
    Visual Studio. The first time you run Visual Studio, you will be prompted to sign
    in with a Microsoft account. Linking Visual Studio to your account will enable
    Visual Studio to sync your settings, link any available licenses, and link your
    Microsoft Store account after it has been created. We will discuss more about
    the Microsoft Store and application distribution in [*Chapter 14*](B20908_14.xhtml#_idTextAnchor582),
    *Packaging and Deploying* *WinUI Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to start building our WinUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the application idea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application we’re going to build is a tool called **My Media Collection**.
    It’s a simple utility that can catalog your entire media library. Because digital
    media is becoming more popular as time goes on, we can design the application
    to support the inclusion of both physical and digital media. The application will
    be able to catalog different types of media, including music, video, and books.
    We’ll add some features that will only light up for certain media types. Physical
    media (books, DVDs, and CDs) are often loaned to friends. This application will
    help you remember who borrowed your favorite book at a recent family party.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the application features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive in and create the new project, let’s get organized. It helps
    to understand what you’re going to build so that you can track your progress while
    progressing through each chapter. If you’re tracking your development on GitHub,
    you could create an **Issue** for each feature. Let’s start with a high-level
    look at the application’s features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: View all media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filter the media library by the following: **Media Type** (**Music**, **Video**,
    or **Book**), **Medium** (the available choices will vary by media type but will
    include **CD**, **Record**, **DVD**, **Blu-Ray**, **Hardcover**, **Paperback**,
    **Digital**), or **Location** (**In Collection** or **Loaned**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new media item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit a media item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark an item as loaned or returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application sign-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back up (or restore) the collection data with OneDrive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The application will use features of the **Windows Community Toolkit**, which
    can simplify things such as Microsoft account authentication and file access on
    OneDrive. You can read more about the toolkit on Microsoft Learn: [https://learn.microsoft.com/dotnet/communitytoolkit/windows/](https://learn.microsoft.com/dotnet/communitytoolkit/windows/).
    The application’s data will be stored in a local **SQLite** database, allowing
    for online or offline access to the media collection. You’ll even be able to send
    email reminders if one of your friends is taking a little too long in returning
    one of the items in your collection.'
  prefs: []
  type: TYPE_NORMAL
- en: WinUI in Desktop projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will be building a Windows App SDK application with the
    **WinUI in Desktop** project template. A **WinUI in Desktop** project targets
    the .NET runtime while using the same XAML schema as a UWP project.
  prefs: []
  type: TYPE_NORMAL
- en: A **WinUI in Desktop** project also includes a **Windows Application Packaging**
    project in the newly created solution. We will learn more about packaging WinUI
    applications in [*Chapter 14*](B20908_14.xhtml#_idTextAnchor582), *Packaging and
    Deploying WinUI Applications*. Now, let’s get started with our first project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first WinUI project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to start building the project. To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Visual Studio, and from the opening screen, select **Create a new project**,
    as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The initial Visual Studio dialog](img/B20908_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The initial Visual Studio dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `winui` in the **Search for templates** field, select the **Blank App,
    Packaged (WinUI 3 in Desktop)** C# template, and click **Next**, as illustrated
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Selecting the project template](img/B20908_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Selecting the project template
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to select the **C#** project template and not **C++**. You can filter
    the project types to show only C# projects by changing the **Language** filter
    from **All languages** to **C#**.
  prefs: []
  type: TYPE_NORMAL
- en: Name the project `MyMediaCollection`, leave the rest of the fields set to their
    default values, and click **Create**. You may be prompted to select the Windows
    versions to target with your app. You can leave these set to their default values
    for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you whether you want to change these versions for your app, but
    you will be limiting the versions of Windows that can install your app. If you
    are using a control or feature that you know is only available in specific versions
    of Windows, you must select that version as the **Minimum version**. The **Target
    version** must be equal to or greater than the **Minimum version**. If you are
    unsure of what to choose, you should stick with the default values.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the project has been created and Visual Studio has loaded, it’s always
    a best practice to build and run the project. Run the application and see what
    the template has provided for `MainWindow`. You should see an empty window hosting
    a few controls. Next, we will see what Visual Studio has created to get us started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and debug WinUI apps on Windows, you must update your Windows settings
    to enable **Developer Mode**. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Open **Settings** from the **Start** menu.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Type `Developer` in the search bar and select the **For Developers** settings
    from the search results.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. On the **For developers** page that appears, switch the **Developer Mode**
    toggle switch on, if it is not already turned on. Enabling this allows developers
    to sideload, run, and debug unsigned apps, and enables some other developer-focused
    Windows settings. You can get more information here: [https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development](https://learn.microsoft.com/windows/apps/get-started/enable-your-device-for-development).'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a WinUI in Desktop project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a new empty WinUI project loaded in Visual Studio, let’s examine
    the different components. In `App.xaml` and `MainWindow.xaml`. We will start by
    discussing the purpose of each of these. Both files can be seen in the following
    screenshot of **Solution Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The new WinUI solution in Solution Explorer](img/B20908_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The new WinUI solution in Solution Explorer
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing App.xaml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `App.xaml` file, as its name implies, stores resources available across
    the entire application. If you have any templates or styles that will need to
    be used across multiple windows, they should be added at the `Application` level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new project’s `App.xaml` file will contain some initial markup, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will cover some XAML basics in the next section. For now, you should know
    that the `Application.Resources` section will contain all the resources to be
    shared across an application. Within this section, the `ResourceDictionary.MergedDictionaries`
    section contains references to other XAML files whose resources will be shared
    with the entire application. This allows developers to organize shared content
    into multiple resource files, leading to better-organized and more maintainable
    XAML. This also enables the sharing of third-party resources across the application.
    For example, this file merges `XamlControlsResources` from the `Microsoft.UI.Xaml.Controls`
    namespace. These are the resources for the WinUI controls that we will be using
    to build our app.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing App.xaml.cs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `App.xaml` file’s node, and you will see there is another file named `App.xaml.cs`
    nested underneath. This is referred to as a `Application` class. If you open the
    C# file, you will see that it already contains some code. This is where you will
    handle any application-wide events. This is the event handler added by default:
    `OnLaunched`. If you need to execute any specific logic when your app is first
    launched, it should be added here. This is also where any application arguments
    passed to the app can be handled.'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing MainWindow.xaml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MainWindow.xaml` file contains the `MainWindow` WinUI window that will
    be displayed when the application launches. You can see this in the `OnLaunched`
    event handler in `App.xaml.cs`, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new blank WinUI app, `Window` will contain an empty `StackPanel` layout
    control. Try replacing `StackPanel`’s child controls with `TextBlock` with a `Text`
    property of `Media` and replace `StackPanel` with `Grid`. The result should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent exceptions at runtime, remove the event handler for the `Button.Click`
    event in `MainWindow.xaml.cs`. Now run the app with the **Debug** | **Start Debugging**
    menu item or the **Start Debugging** button on the Visual Studio toolbar, and
    you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – MainWindow with TextBlock added](img/B20908_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – MainWindow with TextBlock added
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make this window a bit more functional later in the chapter. For now,
    let’s finish our review of the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing MainWindow.xaml.cs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code-behind file for the `MainWindow.xaml.cs` window now contains only a
    call to `InitializeComponent()` in the constructor because we removed the event
    handler for the original `Button` control. Later, we will add some code here to
    populate some sample data and handle events on the page. In a well-designed MVVM
    app, the code-behind files for your pages will have very little code. Most of
    the code will reside in the `ViewModel` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the project references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All your project’s references to `Packages` folder under **Dependencies** in
    **Solution Explorer**. Your WinUI project will reference the following NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.WindowsAppSDK`: The Windows App SDK components, which include WinUI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Windows.SDK.BuildTools`: The Windows SDK components required to
    build a WinUI solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not modify or remove any of these references.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the project properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you right-click the project in **Solution Explorer** and select **Properties**
    from the context menu, you can view and modify the project properties. You won’t
    often need to make any changes here. These are a couple of properties you might
    need to modify from time to time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assembly Name**: You can change the name of the output assembly that is compiled
    by the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Version** and **Target Version**: The Windows versions that were selected
    when creating the project can be modified here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary difference between a new UWP project and a new WinUI 3 project is
    the controls and other objects that are referenced in the `Windows.UI.Xaml.*`
    namespaces are now referenced in the Windows App SDK’s `Microsoft.UI.Xaml.*` namespaces.
    One other difference is that in the `App.xaml` file of the UWP project, it’s not
    necessary to import the controls’ resources. The remaining differences are mostly
    hidden from app developers in the project file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve become familiar with the WinUI project, let’s start building
    the UI for `MainWindow`. We will start with some of the more common XAML controls
    and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: XAML basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to start building the main screen of the **My Media Collection**
    application. The focal point of the application will be the media items in the
    collection. To display that list, we are going to need a few things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Model` class that defines an item in the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some code to bind the collection of items to the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A XAML control to display the items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by building the model for the **My Media Collection** application.
    A **model** defines an entity and its attributes. Earlier in the chapter, we discussed
    some of the items’ attributes we want to display in the UI. To display and (eventually)
    persist this information, we must create the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial version of our model will consist of two enumerations (`ItemType`
    and `LocationType`) in an `Enums` folder, and two classes (`Medium` and `MediaItem`)
    in a `Model` folder, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Solution Explorer displays the new Model and Enum files](img/B20908_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Solution Explorer displays the new Model and Enum files
  prefs: []
  type: TYPE_NORMAL
- en: To add a new folder to the project, right-click on the `Enums` as the folder
    name and hit *Enter*. Repeat this process to add a `Model` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, right-click the project file and select `ItemType`, and click the **Add**
    button, as illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The Add New Item dialog](img/B20908_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The Add New Item dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `ItemType` is created and displayed. Change the `class` definition
    to `enum` and change the `internal` keyword to `public`. The `ItemType` enum contains
    three possible values named `Music`, `Video`, and `Book`. When you’re finished,
    the definition of the `ItemType` enum will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repeat the steps to create a `LocationType` enum, defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using what you have learned, create two classes named `Medium` and `MediaItem`
    in the `Model` folder. The `Medium` class represents a specific medium such as
    *hardcover* or *paperback*, while the `MediaType` property assigns an `ItemType`
    to which the `Medium` class belongs. For these, the valid `ItemType` would be
    `Book`. When you are finished, the two new classes will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To reference the enum types in the `Enums` folder from the two classes, a `using`
    declaration will need to be added at the top of each new class, like this: `using
    MyMediaCollection.Enums;`.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the properties discussed earlier in the chapter, an `Id` property
    has been added to the `MediaItem` class to uniquely identify each item in the
    collection. This will be useful later when we start persisting data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sample data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the model classes in place, we’re ready to add some code that will create
    three media items to display in the UI. This will help us visualize things as
    we start creating our list of items on the main screen. When this step is complete
    and we’re ready to move on to enabling the ability to add items through the app,
    this code will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we are going to add this code in the `MainWindow.xaml.cs` code-behind
    file. Later, in [*Chapter 3*](B20908_03.xhtml#_idTextAnchor073), *MVVM for Maintainability
    and Testability*, this type of code will be added in a `ViewModel` file. The `MainWindow`
    will contain only presentation logic and will not be responsible for creating
    or fetching the data that populates the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `MainWindow.xaml.cs` and create a method named `PopulateData`.
    This method will contain the code that creates three `MediaItem` objects (a CD,
    a book, and a Blu-ray) and adds them to a private `List` named `_items`, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will need to add the `using` statements to `MainWindow` for the `MyMediaCollection.Model`
    and `MyMediaCollection.Enums` namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define `_items` `IList` and `isLoaded` `bool` as private class members. We
    will later change the collection of items to an `ObservableCollection`. `ObservableCollection`
    is a special collection that notifies data-bound items on the UI when items have
    been added or removed from the collection. For now, an `IList` will suit our needs.
    The code can be seen in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a line of code to the `MainWindow` constructor, after the call to
    `Initialize``     Component`, to call the new `PopulateData` method. Any code added to a `Window`
    or `UserControl` constructor must be added after this initialization code. This
    is where all the XAML code in `MainWindow.xaml` is initialized. If you attempt
    to reference any of those elements before the call to `InitializeComponent`, it
    will result in an error. The constructor should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will return to this file to add some data-binding logic after creating some
    UI components in the XAML file. Let’s go and do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Building the initial UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in the chapter, we added a single `TextBlock` to the `MainWindow.xaml`
    file with the `Text` property set to `Media`. We are going to add a `ListView`
    control beneath the existing `TextBlock`. A `ListView` control is a powerful and
    flexible control to display a list of items in a vertical list. It is like the
    `ListBox` control in basic list functionality (item selection, multi-selection,
    and automatic scroll bars), but each list item can be templated to display in
    just about any way imaginable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the `ListView` class, documentation with sample
    code and markup is available on Microsoft Learn: [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.listview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add some markup to create two rows inside the top-level `Grid` control.
    `RowDefinitions` should be added before the existing `TextBlock` element. `TextBlock`
    will remain in the first row, and we’ll add the `ListView` control to the second
    row. Create `RowDefinitions` as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we’re automatically sizing the first `RowDefinition` to the
    size of the `TextBlock` and allocating the remaining space inside the `Grid` to
    the `ListView` control’s `RowDefinition` by using `"*"`. If you assign more than
    one row with `"*"`, those rows will split the remaining available space equally.
    This is the default value for the `Height` attribute. It would be sized the same
    if `"*"` were omitted, but most XAML developers explicitly include it for completeness
    and improved readability.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about row sizing, see the following Microsoft Learn documentation:
    [https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height](https://learn.microsoft.com/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.rowdefinition.height).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a `ListView` control to the `Grid`, setting `Grid.Row` equal to `1`
    (row numbering is 0-based, meaning the first row is row `0`), and name it `ItemList`.
    It is not necessary to name your XAML elements. This is only required if you either
    want to reference them by `ElementName` in XAML data binding or as a variable
    in the code-behind file. Naming a control causes a variable to be created in the
    `InitializeComponent` call, and to optimize performance, you should only name
    your controls if you need to reference them elsewhere. The markup can be seen
    in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By setting the background color to `LightGoldenrodYellow`, we can see the `ListView`
    in the application’s main window before we populate any data. Depending on whether
    you are using a *Light* or *Dark* Windows theme, you can choose a color that works
    best for you. Run the app, and it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – A ListView added to the UI](img/B20908_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – A ListView added to the UI
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to the code-behind file to start wiring up the data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to data binding concepts in XAML programming, Microsoft Learn
    has a great overview of data binding for Windows App SDK developers at the following
    web page: [https://learn.microsoft.com/windows/apps/develop/data-binding/](https://learn.microsoft.com/windows/apps/develop/data-binding/).'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the data-binding initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Return to the `MainWindow.xaml.cs` file and add a line of code before the `PopulateData()`
    method call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After typing `+=`, Visual Studio `ItemList_Loaded` event handler, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Inserting the ItemList_Loaded event handler](img/B20908_02_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Inserting the ItemList_Loaded event handler
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you type the entire line and press *Ctrl* +, you’ll be prompted
    to create the new method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the `MainWindow` constructor simple and keep our data-loading code
    together, move the `PopulateData` call to the `ItemList_Loaded` method. Then,
    add the two other lines of code to the new event handler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is called after the `ItemsList` control has completed loading in
    the UI. We’re getting the instance of the control from the `sender` parameter
    and setting the `ItemsSource` of the list to the `_items` collection that was
    loaded in `PopulateData()`. Now, we have data in the list, but things don’t look
    quite right, as can be seen from the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – A ListView with three rows of data](img/B20908_02_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – A ListView with three rows of data
  prefs: []
  type: TYPE_NORMAL
- en: The `ListView` is displaying three rows for our three sample data items, but
    it’s displaying the data type for each item instead of the data. That’s because
    we haven’t told the `ListView` which properties it should display for the items
    in the collection. By default, the list will display whatever is returned by an
    object’s `ToString()` method. If `ToString()` is not overridden, the data type
    name of the class is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DataTemplate and binding the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s return to `MainWindow.xaml` and tell the `ListView` which data we want
    to display for each item in the list. Try making this change with the application
    still running. Thanks to Visual Studio’s **XAML Hot Reload** feature, you should
    see the UI reload without having to restart the debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Customizing the appearance of each `ListView` item is accomplished by defining
    a `DataTemplate` inside `ListView.ItemTemplate`. A `DataTemplate` can contain
    any WinUI controls we need to define the layout of each list item. Let’s keep
    it simple and add a `Grid` containing two columns. Each column will contain a
    `TextBlock`. The `ListView` should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are beginning to create some more complex XAML and need to keep formatting
    in mind to optimize its readability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly reformat your XAML, you can use the *Ctrl* + *K | D* keyboard shortcut.
    There is also an extension on the **Visual Studio Marketplace** called **XAML
    Styler**. You can search for it in Visual Studio’s **Manage Extensions** dialog
    or get more information on the Marketplace here: [https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022](https://marketplace.visualstudio.com/items?itemName=TeamXavalon.XAMLStyler2022).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable each `TextBlock` to bind to the properties of `MediaItem`, we must
    set an `x:DataType` property on the `DataTemplate`. To resolve `MediaItem`, a
    namespace declaration needs to be added to the `Window` definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A shortcut to add this `using` statement is to place your cursor in `x:DataType`
    and press *Ctrl* +. Visual Studio will suggest adding the missing namespace to
    the file. We now have access to objects in the `MyMediaCollection.Model` namespace
    by using the `model` prefix, and `x:DataType="model:MediaItem"` will resolve `MediaItem`
    when we build and run the app.
  prefs: []
  type: TYPE_NORMAL
- en: Each `TextBlock` has its `Text` property bound to a property of `MediaItem`,
    using the `x:Bind` **markup extension**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `x:Bind` instead of the `Binding` markup extension to bind data to the
    UI has the benefit of compile-time validation and increased performance. The previously
    noted data-binding overview on Microsoft Learn covers the differences in depth.
    I prefer to use `x:Bind` where possible. One important difference between `Binding`
    and `x:Bind` you should note is that while `Binding` defaults to `OneWay` mode,
    `x:Bind` defaults to `OneTime`. This change to the default binding behavior was
    made for performance considerations. `OneWay` binding requires more code behind
    the scenes to wire up the change detection needed for monitoring changes to the
    source value. You can still explicitly update your `x:Bind` usages to be `OneWay`
    or `TwoWay`. For more information about `x:Bind`, see this Microsoft Learn article:
    [https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension](https://learn.microsoft.com/windows/uwp/xaml-platform/x-bind-markup-extension).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on markup extensions in XAML, you can read this .NET article:
    [https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview](https://learn.microsoft.com/dotnet/desktop/xaml-services/markup-extensions-overview).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the application, you can see the `MediumType` name and the
    item name for each item in the `ListView`, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – The ListView with two columns of sample data](img/B20908_02_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – The ListView with two columns of sample data
  prefs: []
  type: TYPE_NORMAL
- en: That’s some pretty good progress! Before we expand on the functionality, let’s
    talk a little about how WinUI, the Windows App SDK, and .NET fit together in terms
    of the app development process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WinUI and Windows App SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review the WinUI controls available to use in our project and see how
    they can help us build the `Microsoft.WindowsAppSDK` package we saw in **Solution
    Explorer** earlier in the chapter contains these controls and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the contents of this package, open the **Object Browser** window from
    Visual Studio’s **View** menu. The controls will be listed here under several
    namespaces inside the **Microsoft.WinUI** tree node, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – WinUI controls in Object Browser](img/B20908_02_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – WinUI controls in Object Browser
  prefs: []
  type: TYPE_NORMAL
- en: The majority of WinUI controls we will be using can be found inside the **Microsoft.UI.Xaml.Controls**
    namespace under **Microsoft.WinUI**, along with other related classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used in our application the `Grid`, `TextBlock`, and `ListView`
    controls. Open the `ListView` class, expand `ListViewBase` class. This base class
    contains the methods, properties, and events available to the `ListView`. The
    members of `ListViewBase` will display in the right pane. Take some time to review
    these members and see whether you recognize any of them from your use of the control
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clear `ListView` from your search, scroll down in the left pane of `TextBlock`
    control. Select it and, in the right pane, find and select the **Text** property.
    The bottom-right pane displays details of the property, as illustrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Details of the TextBlock.Text property in Object Browser](img/B20908_02_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Details of the TextBlock.Text property in Object Browser
  prefs: []
  type: TYPE_NORMAL
- en: The **Object Browser** window can be a valuable resource when familiarizing
    yourself with a new library or project. All referenced projects, NuGet packages,
    and other references will appear here.
  prefs: []
  type: TYPE_NORMAL
- en: The controls and other components you have reviewed here make up the UI layer
    of Windows App SDK applications. The underlying application framework for the
    Windows App SDK is .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the .NET app model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have heard that the underlying app model for WinUI apps can be Win32
    for C++ apps or .NET for desktop apps. So, what exactly is the **.NET** **app
    model**?
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET app model in WinUI apps describes how applications are packaged and
    deployed. It also defines the following behaviors and capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle events (**Startup** and **Shutdown**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multitasking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-app communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WinUI 3 is one component of the Windows App SDK, the UI layer. Although the
    WinUI controls are decoupled from the Windows SDK, the underlying .NET app platform
    is still dependent on it when using the Windows App SDK. Selecting a target and
    minimum Windows version is one of the side effects of this dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of WinUI controls and how they relate
    to the Windows App SDK and the .NET app platform, let’s use a few more of them
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with WinUI controls, properties, and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s time to enhance the UI of the application. Currently, the main page only
    consists of a `Media` label over a `ListView`, with columns for the media type
    and the name of the media item. The following are the enhancements we will add
    in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: A header row for the `ListView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ComboBox` to filter the rows based on the media type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Button` to add a new item to the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by enhancing the `ListView` for our media collection.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a ListView header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we create the header, let’s change the background color of the `ListView`.
    The `Aqua` color worked well to highlight the control, but it would be distracting
    when the application is used by our customers. We will discuss WinUI theme brushes
    and look at `Background="Aqua"` from the `ListView` definition in the `MainWindow.xaml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the header row for the media collection is relatively simple. To define
    the rows for each item, we created a `ListView.ItemTemplate` block containing
    a `DataTemplate`. To create the header, we do the same inside a `ListView.HeaderTemplate`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the item rows, the header row will consist of a `Grid` with two
    columns, with the same `Width` definitions. We again want to use two `TextBlock`
    controls inside the `Grid`, but to add some separation between the header and
    the items, we will add `Border` controls. Let’s look at the markup for the header
    and then discuss the differences in more detail. Take some time to review the
    following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each `TextBlock` is nested inside a `Border` element. This
    will wrap the text in a border with a `BlueViolet` color. However, by setting
    `BorderThickness="0,0,0,1"`, the border color will only appear on the bottom of
    the header row items. Here is how that appears in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The ListView with a header row added](img/B20908_02_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – The ListView with a header row added
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same bottom border could be achieved by nesting the entire `Grid` inside
    a `Border` instead of putting one around each header item. However, by doing it
    this way, we have more control over the appearance of each column’s border style.
    When we implement sorting later, the border’s color can be modified to highlight
    the column on which sorting has been applied.
  prefs: []
  type: TYPE_NORMAL
- en: You probably also noticed that the header row text stands out from the rows
    in the grid. The `FontWeight="Bold"` property set inside each `TextBlock` in the
    `HeaderTemplate` helps to highlight the header row.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ComboBox filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the requirements for the application is to allow users to filter several
    of the collection items’ properties. Let’s start simple, by adding a filter only
    on the medium (**Book**, **Music**, or **Movie**). The list also needs an **All**
    option, which will be the default selection when users open the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add some XAML to `MainWindow` to add a filter to the right of the `Media`
    label. Replace `Media` `TextBlock` with the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The single `TextBlock` label has been replaced with a two-column `Grid`. The
    first column contains the `TextBlock`, with a few modifications. First, the `Text`
    property has been updated to `"Media Collection"`. `FontWeight` has been changed
    to `"Bold"` and some margin has been added. Finally, the element is vertically
    centered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second column contains a new `StackPanel` (a container control that stacks
    its contents horizontally or vertically). The default orientation is `Vertical`.
    In our case, we want a horizontal stack, which is why the `Orientation` property
    has been set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`StackPanel` contains a `TextBlock` label and a `ComboBox` for the filter selection.
    The `ComboBox` filter has been given an `x:Name` so we can reference it from the
    C# code-behind file when initializing its contents. We have also configured a
    `MinWidth` value of `120`. If the contents of the `ComboBox` filter require more
    than 120 **pixels** (**px**), it can grow larger, but its width cannot be less
    than the value set here.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The pixels being referenced in XAML are effective pixels. To read more about
    responsive layouts and sizing with XAML, see this Microsoft Learn article: [https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml](https://learn.microsoft.com/windows/apps/design/layout/layouts-with-xaml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainWindow.xaml.cs` file, add a new variable to hold the list of mediums,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This collection can be an `IList` rather than `ObservableCollection` because
    we don’t expect its contents to change while the application is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inside the `PopulateData()` method, add some code at the end of the method
    to populate the `_mediums` list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re adding an item to the collection for each of the possible values in our
    `ItemType` enum, plus the default `"``All"` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `ComboBox` filter will be bound to the collection after it has loaded,
    so add a `Loaded` event handler in the `MainWindow` constructor, as we did for
    the `ItemList` earlier, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ItemFilter_Loaded` event handler will look much like the `ItemList_Loaded`
    handler. Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code casts the sender to the `ComboBox` data type and sets its `ItemSource`
    to the list we populated in the previous step. Finally, an additional step is
    needed to default the `ComboBox` filter to default to the `"All"` item. This is
    accomplished by setting `SelectedIndex` equal to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the application and see how it looks now. You can see the result
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Media Collection with the Media Type filter added](img/B20908_02_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Media Collection with the Media Type filter added
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty sharp! If you click the **Media Type** filter, you can see the four
    values available for selection, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Media Type values](img/B20908_02_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Media Type values
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how the dropdown of `ComboBox` has picked up the Windows style with
    some transparency without having to add any additional code or markup. Select
    one of the other values in the list and see what happens. Nothing! That’s because
    we haven’t added any code to do the filtering when the selection changes on the
    filter. We can add a little bit of extra code to fix that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new `_allItems` collection to store a list of all available
    media items, regardless of the current filter, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `PopulateData()` method, after populating the `_items` collection,
    add the same items to `_allItems`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to do some filtering when the filter selection changes. We want
    to handle the `SelectionChanged` event on the `ComboBox` control, but we don’t
    want to hook it up until after the entire page has loaded. This will prevent the
    event from being handled while the `ComboBox` filter is initially being populated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the implementation of `ItemFilter_Loaded`, add an event handler
    for the `SelectionChanged` event on the `ComboBox` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the new `ItemFilter_SelectionChanged` event handler, we will iterate through
    the `_allItems` list and determine which of the items to include in the filtered
    list, based on their `MediaType` property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the filter value is empty or `MediaType`. Otherwise, we check whether the
    `MediaType` matches the selection in `ItemFilter` `ComboBox`. When there is a
    match, we add it to the `updatedItems` list. Then, we set `updatedItems` as `ItemsSource`
    on the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A filter should never be empty unless there is an error while initializing the
    data. This condition is only a safeguard for unforeseen scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the app again and select **Book** in the filter, as illustrated in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Media Collection filtered to display only books](img/B20908_02_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Media Collection filtered to display only books
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of the filter implementation for the time being. Let’s finish
    up this part of the UI design with a `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new item button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are not quite ready to start working with multiple windows or navigation
    yet. You should have some understanding of the `Button` to the current page and
    add some code to ensure everything is hooked up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` file and add a third `RowDefinition` to the top-level
    `Grid` on the `Window`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The new row will have a height of `Auto` so that it sizes itself to fit the
    `Button`. We still want the `ListView` to take up most of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after the closing tag of the `ListView` control, add the new `Button`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in the previous chapter, the `Button` control does not have a `Text`
    property. Instead, if you only want a `Button` control to contain text, you assign
    it to the `Content` property. We are also assigning the `Button` control to the
    third row of the `Grid`, setting the margin, and aligning it to the right side
    of the `Grid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the app looks now, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – My Media Collection with an Add Item button](img/B20908_02_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – My Media Collection with an Add Item button
  prefs: []
  type: TYPE_NORMAL
- en: The button doesn’t do anything yet. Because we’re not yet ready to add an additional
    window to the application to add items, let’s open a message popup to inform the
    user that this function is not available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainWindow.xaml`, wire up a new event handler inside `AddButton`. You can
    also remove the `x:Name` attribute. We’re able to remove the name because we do
    not need to reference it in the code-behind file. The code is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can create the event handler by placing the cursor on the name of the handler,
    `AddButton_Click`, and pressing *F12*. This will create the handler and navigate
    to it in the `MainWindow.xaml.cs` file. Inside the `AddButton_Click` event handler,
    we will create a new `ContentDialog` with the message we want to display to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The call to `dialog.ShowAsync()` must be awaited, so remember to add the `async`
    directive to the event handler, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `async` directive is highlighted in the following code snippet for the
    new event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application again and click the **Add Item** button, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Displaying a ContentDialog popup](img/B20908_02_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Displaying a ContentDialog popup
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to adding a functional `Button` to a WinUI page. As we have
    discussed, some of this code will change and be moved to a `ViewModel` in the
    next chapter, but you should now have a good idea of how to work with some basic
    `Button` properties and events.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made some great initial progress on the **My Media Collection** application
    in this chapter. Along the way, you have learned how to use several common WinUI
    controls. You have also learned how to change the appearance, layout, and behavior
    of WinUI controls by using different layout controls and updating control properties
    in XAML. Finally, you saw how to leverage data binding and events to add and update
    data displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to decouple some of the logic we have been writing in
    the code-behind files to build testable and maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you add or remove features to or from Visual Studio?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the lowest minimum version of Windows that must be targeted when creating
    a new WinUI 3 project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you add XAML resources that can be shared by components in a whole
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the default name of the first window loaded in a new WinUI app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which XAML container control allows you to define rows and columns to lay out
    its contents?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which XAML container control stacks its contents horizontally or vertically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the message box that WinUI apps can use to display simple
    messages to users?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Challenge: What type of layout panel in WinUI allows its contents to be positioned
    absolutely?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
