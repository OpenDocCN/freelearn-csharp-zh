- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic Proxy Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at how powerful it is to have the type of
    metadata that the .NET runtime provides us with, combining that with the power
    of creating your own metadata, the capability to analyze it, and turn it into
    useful information or take actions based on it. We’re now going to explore even
    further and let code make new code based on metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into how we can take advantage of the fact that
    your code runs in a managed runtime environment and how that can be used to create
    new code at runtime after your code has been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to IL and Reflection.Emit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic assembly and module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual members and overrides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon completion of this chapter, you should understand the power of the .NET
    runtime and how you can turn metadata into new code to make you more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6)).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to IL and Reflection.Emit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B19418_02.xhtml#_idTextAnchor026), *Metaprogramming Concepts*,
    we touched on what the C# compiler turns your code into. **IL**, short for **Intermediate
    Language**, is a representation of instructions the .NET runtime understands and
    translates to CPU instructions for the target CPU your code is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Since the .NET runtime operates dynamically on your code in this manner, it
    means that it is not a too far a jump to conclude that you should be able to generate
    code as your program executes. And luckily, that is the case. The .NET APIs include
    a whole namespace dedicated to generating code – **System.Reflection.Emit**.
  prefs: []
  type: TYPE_NORMAL
- en: With the **Emit** APIs, you can go and create any constructs you want from scratch,
    introduce new types that do not exist in any source code, or create new types
    that inherit from other types and add new capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For all the different types of artifacts, you can create class, method, properties,
    and more. There are specific builder types – **TypeBuilder** for classes and **MethodBuilder**
    for methods. Properties are also considered methods and are based on a convention
    of a prefix having the name of **get_** or **set_**, which then represents a **get**
    or **set** method respectively.
  prefs: []
  type: TYPE_NORMAL
- en: With a builder, you can call a method called **.GetILGenerator()**. This method
    will then return a type called **ILGenerator**. The **ILGenerator** method is
    where all the magic happens. This is the type you can use to generate the actual
    code. The primary method you use is the **.Emit()** method. The **.Emit()** method
    has several overloads to it and is the method used to add instructions that constitute
    your program. Instructions are referred to as an **op-code**, and there is a class
    with all the allowed instructions, or op-codes, called **OpCodes**.
  prefs: []
  type: TYPE_NORMAL
- en: All the different op-codes are well defined and well documented, and you can
    find the documentation for all of them on Microsoft’s documentation pages ([https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields)).
  prefs: []
  type: TYPE_NORMAL
- en: Even though they’re well defined and well documented, the preparation involved
    to get the right instructions in the right order can be hard and daunting. Therefore,
    it’s a good idea to derive the instructions from real code instead. A great resource
    for doing so is to use something such as **Sharplab** ([https://sharplab.io](https://sharplab.io)).
    With Sharplab, you can take regular C# code and see the instructions needed to
    be able to reproduce it.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get to the point of actually generating IL code, you need to jump
    through a couple more hoops.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic assembly and module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your code has gone through the compiler and been outputted to a binary
    that runs. That code is considered static and cannot be modified. The binary represented
    as an assembly is completely static; not only can you not modify code in it but
    you also cannot add to it either. It would be a security risk if arbitrary code
    could go and modify running code.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, you have to explicitly create a new assembly on the fly that
    only exists in memory. This is known as a **dynamic assembly**.
  prefs: []
  type: TYPE_NORMAL
- en: All assemblies have also the concept of modules. An assembly must have at least
    one module. A module is a container that holds the concrete IL code and only metadata
    related to it, while an assembly is a higher-order abstract container that contains
    more metadata and could, in fact, refer to multiple **.dll** files. Generally,
    you’ll only see a one-to-one relationship between an **assembly** and a **module**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very easy to get started with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code defines the two containers you need – first, the **.DefineDynamicAssembly()**
    method creates the dynamic assembly, and you tell it to give you an assembly that
    you will use to run code from. Once you have the dynamic assembly, you call **.DefineDynamicModule()**
    to get the container where you’ll generate the actual code that will run.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you should take into consideration is the name of both the dynamic
    assembly and dynamic module. Assembly names need to be unique within a running
    process, and within an assembly, every module needs a unique name as well. So,
    if you’re going to create multiple dynamic assemblies and multiple modules within
    them, you need to guarantee unique names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to do that is to leverage **Guid** and mix it into your name.
    The following code will give a unique name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code generates a new **Guid** and combines it with a prefix. The purpose
    of the prefix is to be able to recognize the different assemblies with a friendly
    name. There are some limitations to what characters can be used in an assembly
    name; that’s why you see that **-** is replaced with **_**.
  prefs: []
  type: TYPE_NORMAL
- en: If your code only needs one dynamic assembly and a dynamic module within it,
    the need to create a unique name might not be needed, as you can quite easily
    just give it a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: You might not even need to have multiple dynamic assemblies and, most likely,
    not even multiple modules within the dynamic assembly. It is perfectly fine to
    have one global dynamic assembly. It all depends on your code and whether or not
    you’ll be generating types with the same name for different purposes that should
    then be grouped into specific assembly/module pair containers.
  prefs: []
  type: TYPE_NORMAL
- en: With a dynamic assembly and a dynamic module in place, we can start generating
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dynamically create a simple type without its source code that can print
    out a message. The target type we’re aiming for would look something like the
    following if we wrote it in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put this into Sharplab ([https://sharplab.io](https://sharplab.io)),
    we can see the IL code that is behind it and use it as the template for what we’re
    trying to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19418_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – IL code
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder called **Chapter6**. Open this folder in your command-line
    interface and create a new console project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a file called **MyTypeGenerator.cs**. Start by making the file look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have pulled in two namespaces – **System.Reflection** and
    **System.Reflection.Emit**. These hold the APIs we will be needing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing we want to do is create the assembly and module, and add the
    following to the **Generate** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From the module, we can create a new type, and within the type, a method. Then,
    we append the following to the **Generate** method after the module has been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code creates a public class called **MyType** and then defines a public
    method called **SaySomething**. In the method, we then set that it has parameters.
    The method accepts **param** that allows us to define one or more parameter types.
    The last thing we do is define the parameter. This is done by giving it the parameter
    index it has and a name.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **ParameterAttributes** value you give the parameter indicates that there
    is nothing special with it; it is a regular parameter. If you wanted it to be
    an **out** or **ref** parameter, you would tell it that.
  prefs: []
  type: TYPE_NORMAL
- en: You now have the definition in place of the method with the expected signature.
    It is now time for you to fill in the actual code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code for this method is very simple, as we’re just taking the parameter
    coming in and passing it to another method.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the method definition in place, you can start building out the code. Append
    the following code to the **Generate** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code starts off by getting the **System.Console** type and the method called
    **WriteLine**, which accepts a simple **string**. The method is what you are going
    to use to call and forward the incoming parameter that will eventually produce
    the message in the console. Once you have the **WriteLine** method, you need **ILGenerator**
    for the **SaySomething** method you’re building. Then, the first thing you do
    is to emit an instruction to load the actual argument given to the parameter into
    what is known as the **evaluation stack**. **OpCodes.Ldarg_1** refers to 1, which
    might seem counterintuitive. In the context of an instance type, **OpCodes.Ldarg_0**
    would represent the value of **this**. With the argument loaded onto the stack,
    you emit code that calls the **WriteLine** method on **Console**, giving it the
    type of parameter to use. Finishing off your method, you emit a return instruction
    from the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the **Generate** method is building out the actual **Type**
    and returning it. Append the following to the **Generate** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full listing of the **MyTypeGenerator** class should now look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With your first code generator in place, you want to take it out for a spin.
    Since this is a type that is completely unknown to the compiler, there is really
    no way to write standard C# code that can call it. You will have to revert to
    reflection to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Program.cs** file of the **Chapter6** project, replace the existing
    code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code calls into your new generator to get the generated **Type**. Next,
    it asks the generated type to get the method called **SaySomething**. You then
    go and create an instance of the type by using the **Activator** type in .NET.
    From the method, you can then invoke it and give the instance as the first parameter,
    and then add in the parameter it is expecting in the array that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this using **dotnet run** or, if you prefer, your IDE, you should get
    a simple message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The intermediate language and how the runtime actually works with instructions
    is logical, but it might not be intuitive compared to writing C#. However, it
    gives you great powers and enables new scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual members and overrides
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From my own experience, generating new types from scratch that didn’t exist
    at compile time is not the most common use case. I’ve found myself, more often
    than not, just wanting to automate something that I find tedious and forced upon
    me from libraries that I have to use.
  prefs: []
  type: TYPE_NORMAL
- en: When that is the case, it is common to take a type and create a new one that
    inherits from this and then starts overriding behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Since C# doesn’t have all its members as virtual, as the case is with Java,
    members have to be explicitly virtual. An example of a method that is virtual
    is one that all objects inherit – the **ToString** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue the work on the **MyTypeGenerator** code by adding an override
    of the **ToString** method, just to see the mechanics of how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Generate** method of the **MyTypeGenerator** class, before you return
    the type, you need to define a new method that will be the **MyType** implementation
    of the **ToString** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, the code gets a reference to the method it wants to override from the
    base class. Since this type doesn’t have a specific base type, it will implicitly
    just be **object**. Then, you start defining the new **ToString** method and specify
    that it will return a **string** type. Since the **ToString** method doesn’t take
    any parameters, you just pass it an empty array of **Type**. From the method definition,
    you go and do as before – get **ILGenerator**. You then simply load the string
    into the evaluation stack, which will be the only thing there, and return from
    the method. To make it an override method, you then call **.DefineMethodOverride()**
    on the type builder to tell it which method you’re overriding and give it the
    original **ToString** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **Program.cs** file and add a line of code that will invoke the **ToString**
    method to see that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the program should then print out the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With what you’ve learned thus far in this chapter, you should now have the basic
    building blocks to create types with members on them and also override virtual
    members from inherited base types. All of these things will get you pretty far.
    Now that we’ve looked at the mechanics of how to generate code, let’s make a more
    concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to overriding virtual members from a base type, there is often the
    need to implement interfaces that satisfy a need for a third-party library you
    are using. The implementation of the interface might not be important to your
    own code, but it is something that is forced on you to enable certain behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who has been doing any XAML-flavored development will have come across
    an interface called **INotifyPropertyChanged**. The **INotifyPropertyChanged**
    interface is something that the data binding engine recognizes and will automatically
    use if a type implements it. Its purpose is to notify anyone using your object
    when a property changes. This is very useful when you have a UI element automatically
    reflecting changes being done in the data behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **INotifyPropertyChanged** interface itself is very simple and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For an object implementing **INotifyPropertyChanged**, it means it needs to
    implement the logic for every property when its value is set. This can be very
    tedious and will bloat your code base with code that is not part of your domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have an object representing a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the **INotifyPropertyChanged** requirement for binding purposes, the object
    would, for just one of the properties, need to explode into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code goes from simple one-liners per property to something
    that explicitly has a getter, setter, and private field to hold the actual value.
    In the setter, you have to then raise the **PropertyChanged** event, and a typical
    pattern is to have a convenience method that is reused for all properties to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to code generation, you can make it all go away and get your code back
    to being readable and more maintainable, making you more productive in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Chapter6** folder, go and create a new file called **Person.cs** and
    make it look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The **Person** class now represents the target version without any of the **INotifyPropertyChanged**
    things. At compile-time, it does not implement the **INotifyPropertyChanged**
    interface, but we will make it do so at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve made the properties **virtual**, we can create a new type that inherits
    from the **Person** type and overrides the properties to do what we want.
  prefs: []
  type: TYPE_NORMAL
- en: NotifyObjectWeaver class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to do what we want, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit from the existing type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the **INotifyPropertyChanged** interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a method that handles the logic for when a property is changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override any virtual methods and implement the code needed for notification
    when properties change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to this, it is also common to have properties that are dependent
    on other properties – for instance, to compose multiple properties together. These
    should also notify you of their change, so you want something to handle that as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a file called **NotifyObjectWeaver.cs** in the **Chapter6**
    project. Then, add the following to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code adds the common constants and statics you’ll be using in the code generation,
    ensuring that you do not have to repeat them throughout and that they gather at
    the top for better structure.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you now have the start of the **NotifyObjectWeaver** class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing you’re going to start with is the code to define the type.
    It is pretty much what you’ve done before, only that we are now going to make
    your dynamically created type inherit from a base type and also implement an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The call to **.SetParent()** is the key to the inheritance. It instructs the
    builder to take the **Type** input given to the method as the parent. The next
    thing you do is to instruct the builder that you will be implementing the **INotifyPropertyChanged**
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the INotifyPropertyChanged interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **INotifyPropertyChanged** interface only has one field on it, the **PropertyChanged**
    event field that we need to implement. We need to add code that defines the event
    and also implements the logic to add and remove event handlers from the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **NotifyObjectWeaver** class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The **DefineEvent** method defines the actual event on the type and then calls
    two methods to define the **add** and **remove** methods for the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the **NotifyObjectWeaver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code adds a method that by convention will be used when event handlers are
    added, **add_PropertyChanged**. It uses the **Delegate** type that you added at
    the beginning of the class to get the **Combine** method that will be called.
  prefs: []
  type: TYPE_NORMAL
- en: It then generates the needed IL code that adds the incoming callback to be called
    when a change happens, by calling the retrieved **Combine** method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also, for good measure, add the opposite – the method that will
    remove a callback that has been added. Add the following method to the **NotifyObjectWeaver**
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of **remove** is pretty much the same as for **add**, with
    the difference of getting the **Remove** method from the **Delegate** type and
    calling **.SetRemoveOnMethod()**.
  prefs: []
  type: TYPE_NORMAL
- en: The OnPropertyChanged method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the event logic in place, you now need a private method that all properties
    will call – an **OnPropertyChanged** method that will be doing all the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the following method in the **NotifyObjectWeaver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code defines the **OnPropertyChanged** method with a signature that takes
    **string**, with the name of the property that changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following at the end of **DefineOnPropertyChangedMethod** to
    declare a local variable that holds the type of event args the code will create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, you need code that checks whether the **PropertyChanged** event field is
    null or not and has the **propertyChangedNullLabel** label that the code can jump
    to if the value is null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the end of the **DefineOnPropertyChangedMethod**
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to add code that creates the **PropertyChangedEventArgs** instance
    with the argument that was passed into the **OnPropertyChanged** method. Then,
    call the **invoke** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of the puzzle is to mark the label that the null check will
    jump to if it is null, and then return from the method. Add the following to the
    end of the **DefineOnPropertyChangedMethod** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The code to define the **OnPropertyChanged** method is now done. Now, you need
    to define the properties.
  prefs: []
  type: TYPE_NORMAL
- en: The overriding properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the requirements we had at the beginning was that we wanted to be able
    to notify other properties to make composites or, if it’s relevant, for another
    property to re-evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **NotifyChangedForAttribute.cs** and make it look like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This custom attribute takes a **param** array of property names that will be
    called for a change, in addition to the property that changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, you should add a method to get the properties to notify, based
    on **PropertyInfo** for the property. In the **NotifyingObjectWeaver** class,
    add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code combines the name of the property, looks for the **NotifyChangesForAttribute**
    attribute, and adds the declared names.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re now ready to add the method that defines all the properties on the new
    type. Add the following method to the **NotifyingObjectWeaver** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code looks at the base type and gets all the properties and filters down
    to only virtual methods. Then, for all the properties it found, it goes and defines
    the **get** and **set** methods for the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the **NotifyingObjectWeaver** class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **set_*** method is the method that will perform the notification. The code
    defines the method and first adds a call to the base type’s **set** method so
    that the base type can handle the value being set for itself. Then, it loops through
    all the properties to notify for and adds code to call the **OnPropertyChanged**
    method with the name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the value is slightly different, as you only want it to read through
    to the base type and get the value from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method to the **NotifyingObjectWeaver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You now have all the code for doing the code generation needed for the properties
    and also the method to raise the **PropertyChanged** event.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization and public API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last piece of the puzzle will be to do the main initialization that defines
    the dynamic assembly and module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following in the **NotifyingObjectWeaver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You now need a public API that can be called from the outside to get a proxy
    type of another type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the **NotifyingObjectWeaver** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The **GetProxyType** method checks first whether there is a proxy type for the
    given type and returns the existing one if that’s the case, creating the proxy
    type if it doesn’t have it in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Using NotifyingObjectWeaver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You now have a fully functional object weaver. Let’s take it out for a spin.
    In the **Program.cs** file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code asks for a wrapped-up type and then creates an instance of it. Since
    it now implements **INotifyPropertyChanged**, we can simply cast it to that type
    and interact with the **PropertyChanged** event.
  prefs: []
  type: TYPE_NORMAL
- en: And since the new type inherits from the **Person** class, we can also cast
    it to that type and set the property on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this program, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now would be a good time to try out the **NotifyChangesFor** functionality
    you added. Open the **Person.cs** file and change it to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Since **FullName** is a composite of both **FirstName** and **LastName**, it
    makes sense to be notified if either of those properties changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the program should now give you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The code in the GitHub repository has more capabilities that sit there as a
    reference. For instance, if the base type has a constructor that takes parameters,
    you should implement the same constructor in the type and pass along the constructor
    parameters to the base constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Another common occurrence you may run into is the need to be able to ignore
    properties. Since the implementation in this chapter is an **opt-out** model,
    all virtual properties are considered properties that notify about changes. This
    might not be true, but it is most likely what you need from most properties. Therefore,
    you want to have a way to ignore these.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the complete listing in the GitHub repository, where you can see how
    these things are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the power of having a managed runtime
    environment, seeing how we can take full advantage of it by dynamically creating
    code that will be executed in the same premises as pre-compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: The possibilities are pretty much endless with such a power. It is super helpful
    as a way to automate tedious tasks and optimize the developer experience, but
    it can be used for so much more. For instance, if you have a system that dynamically
    connects to other systems and the types are dynamically created through configuration
    or similar, instead of going through untyped mechanisms such as the **Dictionary<,>**
    type to hold property values, an optimization would be to create types on the
    fly. The benefit is that you’d have something that was type-safe within the runtime.
    It could also prove to be a performance boost to your system, as you wouldn’t
    be looking up values from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into a constructor called **Expression**,
    how it can be used to represent code and logic, and how you can extract information
    from an **Expression**.
  prefs: []
  type: TYPE_NORMAL
