- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Data Structures in Unity – Arrays, Lists, Dictionaries, HashSets, and Game Logic
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的数据结构 – 数组、列表、字典、HashSet和游戏逻辑
- en: Building on the foundational knowledge acquired in [*Chapter 5*](B22128_05.xhtml#_idTextAnchor120),
    where we explored the vast capabilities of Unity’s API in enhancing game functionality
    through physics simulations, scene management, and environmental interactions,
    [*Chapter 6*](B22128_06.xhtml#_idTextAnchor142) delves deeper into the core of
    game development—**data management**. This chapter transitions from the dynamic
    world of game physics and API interactions to the structured realm of data handling,
    introducing essential data structures such as arrays, Lists, Dictionaries, and
    HashSets. Here, we’ll uncover how to effectively organize and manipulate game
    data, from managing collections of game objects to implementing complex inventory
    systems. By integrating these data structures into your game logic, you’ll lay
    the foundation for sophisticated and efficient game design, taking your development
    skills to new heights.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B22128_05.xhtml#_idTextAnchor120)中，我们探讨了Unity API的广泛功能，通过物理模拟、场景管理和环境交互增强游戏功能，[第六章](B22128_06.xhtml#_idTextAnchor142)深入探讨了游戏开发的核心——**数据管理**。本章从动态的游戏物理和API交互的世界过渡到结构化的数据处理领域，介绍了如数组、列表、字典和HashSet等基本数据结构。在这里，我们将揭示如何有效地组织和操作游戏数据，从管理游戏对象集合到实现复杂的库存系统。通过将这些数据结构集成到您的游戏逻辑中，您将为复杂和高效的游戏设计奠定基础，将您的开发技能提升到新的高度。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing and manipulating arrays and Lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和操作数组和列表
- en: Exploring Dictionaries and HashSets for complex data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索字典和HashSet以处理复杂数据
- en: Creating and utilizing custom data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用自定义数据结构
- en: Applying data structures to develop game mechanics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据结构应用于开发游戏机制
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you start, ensure your development environment is set up as described
    in [*Chapter 1*](B22128_01.xhtml#_idTextAnchor015). This includes having the latest
    recommended version of Unity and a suitable code editor installed on your system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您的开发环境已按照[*第一章*](B22128_01.xhtml#_idTextAnchor015)中描述的设置。这包括安装最新推荐的Unity版本和适合您系统的代码编辑器。
- en: Hardware requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件要求
- en: Ensure your computer meets Unity’s minimum hardware specifications, especially
    a graphics card that supports at least DX10 (shader model 4.0) and a minimum of
    8 GB RAM for optimal performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的计算机满足Unity的最低硬件规格，特别是至少支持DX10（着色器模型4.0）的显卡和至少8 GB RAM以实现最佳性能。
- en: Software requirements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件要求
- en: 'The following are the software requirements for this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的软件要求如下：
- en: '**Unity Editor**: Utilize the version of the Unity Editor installed from [*Chapter
    1*](B22128_01.xhtml#_idTextAnchor015), ideally the latest **Long-Term Support**
    (**LTS**) version ([https://unity.com/download](https://unity.com/download)).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity编辑器**：使用从[*第一章*](B22128_01.xhtml#_idTextAnchor015)安装的Unity编辑器版本，理想情况下是最新**长期支持**（**LTS**）版本（[https://unity.com/download](https://unity.com/download)）。'
- en: '**Code editor**: Visual Studio or Visual Studio Code, with Unity development
    tools, should already be integrated as per the initial setup ([https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/)).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编辑器**：Visual Studio或Visual Studio Code，应已根据初始设置集成Unity开发工具（[https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/))）。'
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter06](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter06)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter06](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter06)
- en: Understanding arrays and Lists
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数组和列表
- en: In this section, we dive into the essentials of data structuring in Unity, focusing
    on foundational data types essential for game development. An **array** is a collection
    of elements of the same type, with a fixed size and direct access to each element.
    A **List**, on the other hand, is a collection that can dynamically resize and
    offers easier manipulation. Arrays provide a straightforward approach to data
    storage, while Lists cater to more complex and evolving scenarios. We’ll guide
    you through the basics of each, from syntax and initialization to practical use
    cases such as inventory systems and game object management. As we delve into working
    with these structures—accessing elements, iterating, and modifying content—we’ll
    also weigh their performance implications and best practices. This ensures you
    can make informed decisions on when and how to use arrays and Lists to optimize
    your Unity projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨Unity中数据结构的基础知识，重点关注对游戏开发至关重要的基础数据类型。**数组**是一系列相同类型的元素集合，具有固定的大小和直接访问每个元素的能力。另一方面，**列表**是一种可以动态调整大小的集合，提供了更简单的操作。数组提供了直接的数据存储方法，而列表则适用于更复杂和不断变化的场景。我们将引导您了解每个数据结构的基础知识，从语法和初始化到实际用例，如库存系统和游戏对象管理。当我们深入研究使用这些结构（访问元素、迭代和修改内容）时，我们还会权衡它们的性能影响和最佳实践。这确保您可以在何时以及如何使用数组和列表来优化您的Unity项目做出明智的决定。
- en: Introducing arrays
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍数组
- en: Arrays are vital in programming, offering a way to organize and manage data,
    such as character stats or inventory items in Unity and C# games. They are collections
    of similar elements stored together, accessible by index, making them ideal for
    handling multiple game entities efficiently. Declaring an array in C#, such as
    `int[] scores;`, and initializing it, either with specific elements, such as `int[]
    scores = {90, 85, 100};`, or by size, such as `int[] scores = new int[3];`, is
    straightforward, supporting a range of game development needs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在编程中至关重要，提供了一种组织和管理工作数据的方法，例如Unity和C#游戏中的角色统计数据或库存项目。它们是存储在一起、通过索引访问的相似元素集合，非常适合高效处理多个游戏实体。在C#中声明数组，例如`int[]
    scores;`，并初始化它，无论是使用特定元素，如`int[] scores = {90, 85, 100};`，还是通过大小，如`int[] scores
    = new int[3];`，都非常简单，支持各种游戏开发需求。
- en: In game development, arrays are used extensively for storing enemy positions,
    inventory item IDs, or player scores, facilitating quick access and updates essential
    for game mechanics. For example, iterating over an array to update game object
    positions is a typical use case. Essentially, arrays streamline data handling
    in game development, with their easy syntax and fast element access improving
    game system complexity management. Learning to effectively use arrays is fundamental
    for advancing in Unity and C# game programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，数组被广泛用于存储敌人位置、库存项目ID或玩家得分，便于快速访问和更新，这对于游戏机制至关重要。例如，遍历数组以更新游戏对象位置是一个典型的用例。本质上，数组简化了游戏开发中的数据处理，其简单的语法和快速的元素访问提高了游戏系统复杂性的管理。学会有效地使用数组对于在Unity和C#游戏编程中取得进步至关重要。
- en: Working with arrays
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组
- en: In Unity and C#, arrays play a key role in organizing game elements such as
    objects, scores, and inventory, providing indexed access to efficiently manage
    and update data. This allows developers to easily access specific elements for
    operations such as modifying a player’s score or an enemy’s health, enhancing
    the game’s dynamics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity和C#中，数组在组织游戏元素（如对象、得分和库存）方面发挥着关键作用，提供了索引访问，以便高效地管理和更新数据。这使得开发者可以轻松访问特定元素以执行操作，如修改玩家的得分或敌人的健康值，增强游戏动态。
- en: However, the fixed size of arrays poses limitations on their adaptability, particularly
    for adding or removing elements, which necessitates creating new arrays to accommodate
    changes. This contrasts with more dynamic data structures such as Lists, which
    offer greater flexibility for such operations, albeit with some trade-offs in
    performance.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数组的固定大小限制了它们的适应性，尤其是在添加或删除元素时，这需要创建新的数组以适应变化。这与更动态的数据结构（如列表）形成对比，后者在执行此类操作时提供了更大的灵活性，尽管在性能方面有所妥协。
- en: 'Consider the following C# script that demonstrates iterating over an array
    of game object positions and updating them:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下C#脚本，它演示了遍历游戏对象位置数组并更新它们：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code initializes an array of `Vector3` positions with specific starting
    values and updates each position to move upwards every frame.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码初始化了一个具有特定起始值的`Vector3`位置数组，并在每一帧更新每个位置向上移动。
- en: So, while arrays in C# offer a reliable way to store and access collections
    of data, their fixed size poses challenges for dynamic operations such as adding
    or removing elements. Understanding how to navigate these limitations, alongside
    proficiently accessing and iterating over array elements, is key to leveraging
    arrays effectively in Unity game development. This balance between structure and
    flexibility is what makes arrays both a powerful and a nuanced tool in a game
    developer’s arsenal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然C#中的数组提供了可靠地存储和访问数据集合的方法，但它们的固定大小为动态操作（如添加或删除元素）带来了挑战。理解如何应对这些限制，以及熟练地访问和迭代数组元素，对于在Unity游戏开发中有效地利用数组至关重要。这种结构和灵活性的平衡使得数组成为游戏开发者工具箱中既强大又细腻的工具。
- en: Introducing Lists
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入列表
- en: Transitioning from arrays, Lists in C# offer dynamic resizing, ideal for game
    development scenarios with changing element counts, such as inventory items or
    on-screen enemies. Part of Unity’s `System.Collections.Generic` namespace, Lists
    provide an adaptable alternative to arrays, allowing for straightforward element
    addition and removal through methods such as `Add()` and `Remove()`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组过渡到列表，C#中的列表提供了动态调整大小，非常适合游戏开发场景中元素计数变化的场景，如库存物品或屏幕上的敌人。作为Unity的`System.Collections.Generic`命名空间的一部分，列表提供了对数组的灵活替代方案，允许通过`Add()`和`Remove()`等方法轻松添加和删除元素。
- en: Though Lists bring adaptability, they may have slightly lower performance compared
    to arrays in high-frequency operations. Nonetheless, their flexibility and ease
    of use often outweigh these limitations, particularly for managing dynamic game
    elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表带来了适应性，但在高频操作中，它们与数组相比可能性能略低。然而，它们的灵活性和易用性通常超过了这些限制，尤其是在管理动态游戏元素时。
- en: 'Here’s a simple C# script that demonstrates using a List to manage enemies
    in Unity:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的C#脚本，演示了在Unity中使用列表管理敌人：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script populates a List with active enemies at startup and removes an object
    from the List when the *R* key is pressed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本在启动时填充一个包含活动敌人的列表，并在按下*R*键时从列表中删除一个对象。
- en: Understanding when and how to use Lists effectively, in conjunction with arrays,
    can significantly enhance the structure and dynamism of your game’s logic and
    data management.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时以及如何有效地使用列表，与数组结合使用，可以显著增强游戏逻辑和数据管理的结构和动态性。
- en: Working with Lists
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'After introducing Lists in C#, we explore their utility in Unity, where their
    dynamic nature excels at managing game elements such as character states. This
    section covers essential operations: adding, accessing, removing, and iterating
    over List elements, which are paramount for game data manipulation.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中引入列表后，我们探讨了它们在Unity中的应用，其中它们的动态特性在管理游戏元素（如角色状态）方面表现出色。本节涵盖了基本操作：添加、访问、删除和迭代列表元素，这些对于游戏数据操作至关重要。
- en: Using the `Add()` method, developers can easily expand Lists, while accessing
    and removing elements is made simple with indexing and methods such as `Remove()`.
    Iteration is typically done with loops, allowing for bulk operations on elements.
    Despite their versatility, developers should be mindful of Lists’ performance
    impact, especially with frequent modifications, to prevent them from hindering
    game performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Add()`方法，开发者可以轻松扩展列表，而通过索引和如`Remove()`等方法访问和删除元素变得简单。迭代通常通过循环完成，允许对元素进行批量操作。尽管列表具有多功能性，开发者应留意列表的性能影响，尤其是在频繁修改时，以防止其影响游戏性能。
- en: 'Here’s a sample C# script demonstrating basic List operations within Unity:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例C#脚本，展示了Unity中基本列表操作的示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script demonstrates adding, accessing, iterating over, and removing items
    from a List of collected items in a game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本演示了在游戏中添加、访问、迭代和从收集物品列表中删除项目。
- en: While Lists bring unparalleled flexibility to game development, mindful usage
    is significant to maintain optimal performance. Mastering these aspects of Lists
    will significantly enhance a developer’s ability to manage game data effectively,
    contributing to richer and more dynamic gameplay experiences.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表为游戏开发带来了无与伦比的灵活性，但谨慎使用对于保持最佳性能至关重要。掌握列表的这些方面将显著提高开发者有效管理游戏数据的能力，从而为玩家提供更丰富和更具动态性的游戏体验。
- en: Practical applications of Lists and arrays in Unity
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中列表和数组的实际应用
- en: After exploring arrays and Lists, we turn to their practical uses in Unity,
    such as managing inventories or enemy tracking. Arrays are ideal for stable elements,
    offering quick access, while Lists adapt well to dynamic scenarios such as expanding
    inventories and balancing between structure and flexibility based on game requirements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了数组和列表之后，我们转向它们在Unity中的实际应用，例如管理库存或敌人追踪。数组对于稳定元素来说非常理想，提供快速访问，而列表则很好地适应了动态场景，如扩展库存和根据游戏需求在结构性和灵活性之间进行平衡。
- en: Choosing between arrays and Lists involves weighing their speed and adaptability
    against the game’s design and performance needs, ensuring efficient game object
    management.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组与列表之间进行选择，需要权衡它们的速度和适应性，以适应游戏的设计和性能需求，确保高效的游戏对象管理。
- en: 'To illustrate, consider a simple C# script in Unity that manages a character’s
    inventory using a List:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，考虑一个简单的Unity中的C#脚本，该脚本使用列表来管理角色的库存：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This script demonstrates how Lists can dynamically manage a conversation system,
    where items can be added or removed by other game components through the `AddItem`
    and `RemoveItem` methods. Pressing the *I* key logs all items currently in the
    inventory, showcasing the ease of iteration over the List.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本演示了列表如何动态管理对话系统，其中可以通过`AddItem`和`RemoveItem`方法由其他游戏组件添加或删除项目。按下*I*键记录当前库存中的所有项目，展示了遍历列表的简便性。
- en: So, arrays are essential for organizing game elements in Unity within stable
    environments, while Lists are better suited for dynamic environments where elements
    can change frequently. Their strategic use enhances game structure and player
    engagement. Moving forward, we’ll explore Dictionaries and HashSets, which offer
    advanced data management options for more complex scenarios, further expanding
    our toolkit for efficient game development.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数组对于在Unity中稳定环境中组织游戏元素至关重要，而列表则更适合动态环境，其中元素可以频繁更改。它们的战略使用增强了游戏结构和玩家参与度。接下来，我们将探索字典和哈希集，它们为更复杂场景提供了高级数据管理选项，进一步扩展了我们的游戏开发工具集。
- en: Exploring Dictionaries and HashSets
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索字典和哈希集
- en: Diving into Dictionaries and HashSets, we’ll explore C#’s key-value pair structures
    and set collections, respectively. A **Dictionary** is a collection of key-value
    pairs that allows efficient data access based on unique keys, making it ideal
    for inventory systems and game state management. A **HashSet** is a collection
    that ensures unique items and provides fast lookups. We contrast these with arrays
    and Lists for complex data management in Unity. We’ll navigate their syntax, usage,
    and performance in game development, understanding when and how to leverage these
    structures for optimized, engaging game mechanics. This segment also covers best
    practices and advanced techniques for managing complex key types in Dictionaries
    and utilizing HashSets for effective data handling. First, let’s dive into Dictionaries.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解字典和哈希集，我们将分别探索C#中的键值对结构和集合。**字典**是一个键值对集合，允许基于唯一键高效地访问数据，使其非常适合库存系统和游戏状态管理。**哈希集**是一个确保唯一项目并提供快速查找的集合。我们将它们与数组列表进行对比，以在Unity中进行复杂的数据管理。我们将探讨它们的语法、用法和性能在游戏开发中的应用，了解何时以及如何利用这些结构来实现优化和吸引人的游戏机制。本节还涵盖了管理字典中复杂键类型的高级技术和最佳实践，以及利用哈希集进行有效数据处理。首先，让我们深入了解字典。
- en: Introducing Dictionaries
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍字典
- en: Dictionaries in C# are versatile data structures designed for efficient data
    storage and retrieval using key-value pairs, distinct from the sequential element
    access seen in arrays and Lists. This unique structure allows for rapid lookups,
    updates, and management of associated data, making Dictionaries ideal for scenarios
    where relationships between data points matter, such as audio settings or game
    difficulty settings values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的字典是灵活的数据结构，旨在使用键值对进行高效的数据存储和检索，与数组列表中看到的顺序元素访问不同。这种独特的结构允许快速查找、更新和管理相关数据，使字典非常适合数据点之间关系重要的场景，例如音频设置或游戏难度设置值。
- en: To declare and initialize a Dictionary, one specifies the types for both keys
    and values (e.g., int, string, float), using syntax such as `Dictionary<KeyType,
    ValueType> dictionaryName = new Dictionary<KeyType, ValueType>();`. This structure’s
    initialization can be straightforward or involve pre-populating it with elements.
    When compared to arrays and Lists, Dictionaries stand out for their direct access
    to elements through keys rather than indices, providing a more intuitive way of
    handling data when element order is not a priority but fast, efficient access
    to specific elements is indispensable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明和初始化一个 Dictionary，需要指定键和值的类型（例如，int、string、float），使用如 `Dictionary<KeyType,
    ValueType> dictionaryName = new Dictionary<KeyType, ValueType>();` 这样的语法。这种结构的初始化可以是直接的，也可以是预先填充元素。与数组相比，Dictionary
    的突出特点是它通过键而不是索引直接访问元素，当元素顺序不是重点但快速高效地访问特定元素是必不可少的时，这提供了一种更直观的数据处理方式。
- en: Using Dictionaries in Unity
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Unity 中使用 Dictionary
- en: In Unity game development, Dictionaries are invaluable for structuring complex
    data such as **Non-Player Character** (**NPC**) dialogue trees or player progression
    tracking, enabling efficient and intuitive data operations. By associating keys
    with values, developers can swiftly add, access, and modify game data, enhancing
    gameplay mechanics and user experience.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 游戏开发中，Dictionary 对于结构化复杂数据，如 **非玩家角色**（NPC）对话树或玩家进度跟踪，非常有价值，它能够实现高效直观的数据操作。通过将键与值关联，开发者可以快速添加、访问和修改游戏数据，增强游戏机制和用户体验。
- en: For instance, managing game achievements becomes streamlined with Dictionaries,
    allowing for quick achievement lookups and updates using achievement names or
    IDs as keys. Similarly, game state variables can be effectively organized, making
    it easier to save and load game states. Operations such as adding `(dictionary.Add(key,
    value))`, accessing `(var value = dictionary[key])`, and removing `(dictionary.Remove(key))`
    key-value pairs are straightforward. Iterating through a Dictionary, either by
    keys, values, or both, facilitates bulk operations such as displaying quest statuses
    or updating character attributes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 Dictionary 管理游戏成就变得简单高效，允许通过成就名称或 ID 作为键快速查找和更新成就。同样，游戏状态变量可以有效地组织，使得保存和加载游戏状态变得更容易。添加（`dictionary.Add(key,
    value)`）、访问（`var value = dictionary[key]`）和删除（`dictionary.Remove(key)`）键值对的操作都很简单。通过键、值或两者遍历
    Dictionary，便于执行批量操作，如显示任务状态或更新角色属性。
- en: 'Consider this simple C# example demonstrating a Dictionary for an inventory
    system:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简单的 C# 示例，演示了用于库存系统的 Dictionary：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This script initializes a Dictionary to manage an inventory, adds two items
    in the `Start` method, and listens for the *U* key to increase the quantity of
    `Potion` by `1`, displaying the updated value in the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本初始化一个 Dictionary 来管理库存，在 `Start` 方法中添加两个项目，并监听 *U* 键以增加 `Potion` 的数量 `1`，在控制台显示更新后的值。
- en: Dictionaries in Unity facilitate robust and flexible data management, essential
    for features such as player statistics or ammunition stores. Their ability to
    handle key-value pairs makes adding, accessing, and iterating through game data
    efficient, significantly improving game logic and design workflows.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的 Dictionary 促进了强大灵活的数据管理，这对于玩家统计或弹药库等特性至关重要。它们处理键值对的能力使得添加、访问和遍历游戏数据变得高效，显著提高了游戏逻辑和设计工作流程。
- en: Performance considerations of using Dictionaries in Unity
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Unity 中使用 Dictionary 的性能考虑
- en: When integrating Dictionaries in Unity, it’s essential to consider their impact
    on game performance. While Dictionaries offer fast data access through key-value
    pairs, their misuse can lead to inefficiencies, particularly in resource-intensive
    games where optimal performance is important.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Unity 中集成 Dictionary 时，考虑其对游戏性能的影响是至关重要的。虽然 Dictionary 通过键值对提供快速数据访问，但使用不当可能导致效率低下，尤其是在资源密集型游戏中，最佳性能至关重要。
- en: Dictionaries are generally efficient, but their performance can degrade with
    improper usage, such as excessive additions, deletions, or large datasets. Best
    practices include minimizing the frequency of operations within performance-critical
    loops and considering initial capacity settings to reduce rehashing. Additionally,
    using appropriate key types and ensuring a good distribution of hash values can
    prevent bottlenecks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Dictionary 通常效率很高，但使用不当会导致性能下降，例如过度添加、删除或大数据集。最佳实践包括最小化性能关键循环中的操作频率，并考虑初始容量设置以减少重新散列。此外，使用适当的键类型并确保良好的哈希值分布可以防止瓶颈。
- en: Introducing HashSets
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍HashSet
- en: Following our exploration of Dictionaries, we introduce HashSets in C#, another
    powerful collection type that offers unique capabilities distinct from Lists and
    Dictionaries. HashSets store unique elements, making them ideal for operations
    requiring distinct values without duplicates. Unlike Dictionaries, which manage
    key-value pairs, HashSets focus solely on individual elements, offering efficient
    insertion, removal, and lookup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索了字典之后，我们介绍C#中的HashSet，这是一种功能强大的集合类型，它提供了与列表和字典不同的独特功能。HashSet存储唯一元素，使其成为需要无重复值操作的理想选择。与负责管理键值对的字典不同，HashSet专注于单个元素，提供高效的插入、删除和查找。
- en: HashSets are declared with a type specifier, similar to Lists, using the `HashSet<T>
    myHashSet = new HashSet<T>();` syntax, where `T` represents the type of elements
    stored. Initializing a HashSet can involve adding elements individually or passing
    an entire collection. The uniqueness of elements in HashSets inherently prevents
    duplication, streamlining certain operations such as checking for existing values
    or eliminating repeated entries from a collection.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: HashSet使用类型说明符声明，类似于列表，使用`HashSet<T> myHashSet = new HashSet<T>();`语法，其中`T`表示存储的元素类型。初始化HashSet可以涉及逐个添加元素或传递整个集合。HashSet中元素的唯一性固有地防止了重复，简化了某些操作，例如检查现有值或从集合中消除重复条目。
- en: Their simple syntax and initialization coupled with the guarantee of unique
    elements make HashSets a valuable tool for specific scenarios in Unity development,
    enhancing data handling and performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的简单语法和初始化以及唯一元素的保证使HashSet成为Unity开发中特定场景的有价值工具，增强了数据处理和性能。
- en: Using HashSets in Unity
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Unity中使用HashSet
- en: HashSets in Unity excel in managing unique elements and streamlining operations
    such as adding, checking, and removing items, which is vital for game development
    tasks such as tracking collectibles or managing enemies. Their efficiency in preventing
    duplicates and facilitating fast lookups makes them a valuable tool for maintaining
    game data integrity and performance in dynamic environments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，HashSet在管理唯一元素和简化添加、检查和删除项目等操作方面表现出色，这对于游戏开发任务，如跟踪收集品或管理敌人至关重要。它们在防止重复和促进快速查找方面的效率使它们成为维护游戏数据完整性和动态环境性能的有价值工具。
- en: 'For example, managing a set of unique power-ups collected by a player can be
    efficiently handled with a HashSet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，管理玩家收集的独特道具集合可以使用HashSet高效处理：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This script uses a HashSet to manage collected power-ups, ensuring each power-up
    is added only once and logging a message when a new power-up is collected, with
    the `CollectPowerUp` method being called by other scripts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用HashSet来管理收集的道具，确保每个道具只添加一次，并在收集新道具时记录一条消息，通过其他脚本调用`CollectPowerUp`方法。
- en: Now that we have defined HashSets and explored their unique advantages, let’s
    compare them with Dictionaries to understand how each can be effectively utilized
    in different game development scenarios.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了HashSet并探讨了它们的独特优势，让我们将它们与字典进行比较，以了解每个如何在不同的游戏开发场景中有效利用。
- en: Comparing Dictionaries and HashSets
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字典和哈希集合
- en: In Unity game development, choosing the right data structure between Dictionaries
    and HashSets is fundamental for efficient performance and code clarity. Dictionaries,
    with their key-value pairs, excel in scenarios requiring associated data management,
    while HashSets are optimal for maintaining unique sets of items without duplicates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发中，在字典和HashSet之间选择合适的数据结构对于高效性能和代码清晰度至关重要。具有键值对的字典在需要关联数据管理的情况下表现卓越，而HashSet在维护无重复项的唯一集合方面是最优的。
- en: Dictionaries are ideal when there’s a need to retrieve or modify data based
    on specific keys, such as tracking player scores by their IDs or managing game
    state settings. Their main advantage lies in fast lookups and data organization,
    but they can become cumbersome when only uniqueness is required without key-value
    associations. On the other hand, HashSets shine in situations where the emphasis
    is on item uniqueness and fast membership checks, such as ensuring no duplicate
    enemies are spawned or managing distinct collectible items. While offering high
    performance for add, remove, and search operations, HashSets lack the direct association
    between keys and values found in Dictionaries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要根据特定键检索或修改数据时，例如根据ID跟踪玩家得分或管理游戏状态设置，字典是理想的。它们的主要优势在于快速的查找和数据组织，但如果没有键值关联，仅需要唯一性时，它们可能会变得繁琐。另一方面，哈希集合在强调项目唯一性和快速成员检查的情况下表现出色，例如确保不会生成重复的敌人或管理独特的可收集物品。虽然哈希集合在添加、删除和搜索操作中提供了高性能，但它们缺乏字典中键和值之间的直接关联。
- en: Having compared the features and applications of Dictionaries and HashSets,
    let’s delve into some advanced tips and techniques to further optimize their use
    in Unity, enhancing both performance and scalability in your game projects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 比较了字典和哈希集合的功能和应用后，让我们深入了解一些高级技巧和技术，以进一步优化它们在Unity中的使用，从而提高游戏项目中的性能和可扩展性。
- en: Advanced tips and techniques
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级技巧和技术
- en: Exploring Dictionaries and HashSets reveals advanced data management techniques
    in Unity. Using complex keys in Dictionaries requires attention to equality and
    hash code methods, while HashSets excel in fast presence checks, which is useful
    for unique game elements. These advanced uses demand a solid grasp of C#’s data
    structures, enhancing game performance and scalability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 探索字典和哈希集合揭示了Unity中的高级数据管理技术。在字典中使用复杂键时，需要注意相等性和哈希码方法，而哈希集合在快速存在检查方面表现出色，这对于独特的游戏元素非常有用。这些高级用法要求对C#的数据结构有扎实的掌握，从而提高游戏性能和可扩展性。
- en: In essence, Dictionaries are ideal for complex key-value associations, while
    HashSets excel with unique item sets, focusing on performance. Choosing the right
    structure depends on the game’s data needs, impacting overall efficiency and architecture.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，字典非常适合复杂的键值关联，而哈希集合在处理唯一项集合时表现出色，侧重于性能。选择正确的结构取决于游戏的数据需求，影响整体效率和架构。
- en: With a solid understanding of advanced techniques for using Dictionaries and
    HashSets, we can now explore creating custom data structures in Unity to further
    tailor data management to the specific needs of your game.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了使用字典和哈希集合的高级技巧之后，我们现在可以探索在Unity中创建自定义数据结构，以进一步定制数据管理以满足您游戏的具体需求。
- en: Custom data structures in Unity
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity中的自定义数据结构
- en: Moving from Dictionaries and HashSets, we now explore custom data structures
    in Unity, essential for developers seeking advanced game design solutions. These
    structures provide tailored approaches for specific game needs, enhancing performance
    and usability. This section spans designing unique structures for complex scenarios,
    such as level layouts or AI logic, to their implementation and integration in
    Unity using C#, ScriptableObject, and more. We’ll address serialization, memory
    management, and advanced concepts such as generics and design patterns for efficient
    custom structures. Through practical examples and emphasizing best practices,
    we aim to guide you in crafting and refining custom data structures, culminating
    with a tutorial on creating a custom inventory system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典和哈希集合转移到，我们现在探索Unity中的自定义数据结构，这对于寻求高级游戏设计解决方案的开发者来说是必不可少的。这些结构为特定的游戏需求提供了定制的方法，提高了性能和可用性。本节涵盖了为复杂场景设计独特结构，例如关卡布局或AI逻辑，以及使用C#、ScriptableObject等在Unity中的实现和集成。我们将讨论序列化、内存管理以及泛型和设计模式等高级概念，以实现高效的定制结构。通过实际示例和强调最佳实践，我们的目标是指导您制作和优化定制数据结构，最终以创建自定义库存系统的教程作为总结。
- en: Custom data structures are essential in game development, enabling tailored
    solutions that standard types can’t provide. They’re particularly valuable when
    unique gameplay features or data management needs arise, demanding more than what
    predefined structures such as arrays or Lists offer. Considering custom structures
    is pivotal when facing specific challenges, such as optimizing performance, enhancing
    data organization, or implementing complex game mechanics. Situations requiring
    a novel approach to data handling, such as intricate inventory systems or character
    attributes, signal the need for custom solutions. These structures align data
    management closely with the game’s conceptual design, improving code maintainability
    and game functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义数据结构在游戏开发中至关重要，它能够提供标准类型无法提供的定制解决方案。当出现独特的游戏特性或数据管理需求时，这些结构尤其有价值，它们能够提供比数组或列表等预定义结构更多的功能。面对诸如优化性能、增强数据组织或实现复杂游戏机制等特定挑战时，考虑自定义结构至关重要。需要采用新颖的数据处理方法的情况，例如复杂的库存系统或角色属性，表明需要定制解决方案。这些结构将数据管理紧密地与游戏的概念设计相结合，提高了代码的可维护性和游戏功能。
- en: Designing custom data structures
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计自定义数据结构
- en: In game development, designing custom data structures requires balancing performance,
    memory efficiency, and usability to manage game data effectively. Optimal performance
    ensures these structures don’t slow down the game, particularly in resource-heavy
    scenes, while careful memory usage helps maintain a lean footprint, essential
    in complex environments. Additionally, ease of use is central, allowing developers
    to integrate these structures smoothly into their workflow, thereby enhancing
    development efficiency.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，设计自定义数据结构需要平衡性能、内存效率和可用性，以有效地管理游戏数据。最佳性能确保这些结构不会减慢游戏速度，尤其是在资源密集型场景中，而谨慎的内存使用有助于保持轻量级的足迹，这对于复杂环境至关重要。此外，易用性是核心，它允许开发者将这些结构顺利地集成到他们的工作流程中，从而提高开发效率。
- en: Custom data structures become necessary in scenarios such as creating intricate
    inventory systems, optimizing collision detection through spatial partitioning,
    or managing data for procedurally generated worlds. These unique challenges surpass
    the capabilities of standard structures, making custom solutions vital for sophisticated
    game mechanics and performance optimization.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建复杂的库存系统、通过空间分区优化碰撞检测或管理程序生成世界的数据等场景中，自定义数据结构变得必要。这些独特的挑战超出了标准结构的范围，使得自定义解决方案对于复杂的游戏机制和性能优化至关重要。
- en: Implementing custom data structures in C#
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在C#中实现自定义数据结构
- en: Implementing custom data structures in C# involves a deep dive into the fundamentals
    of class and struct, enabling the creation of tailored, efficient data containers.
    Classes offer reference-type structures ideal for more complex data scenarios
    requiring inheritance and extensive functionality, while structs provide value-type
    semantics suited for lightweight, immutable data storage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中实现自定义数据结构需要深入理解类和结构体的基础知识，从而能够创建定制且高效的容器。类提供了适用于需要继承和广泛功能的复杂数据场景的引用类型结构，而结构体提供了适用于轻量级、不可变数据存储的值类型语义。
- en: Custom structures are crafted using constructors for initialization, properties
    for data encapsulation, and methods to define behaviors. Constructors set up the
    initial state, properties manage access to the structure’s data, and methods implement
    the structure’s functionality. This approach allows for the creation of highly
    specialized data structures that align closely with a game’s unique requirements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义结构是通过构造函数进行初始化、通过属性进行数据封装以及通过方法定义行为来构建的。构造函数设置初始状态，属性管理对结构体数据的访问，而方法实现了结构体的功能。这种方法允许创建与游戏独特需求紧密对齐的高度专业化的数据结构。
- en: 'Consider this simple C# example of a custom data structure for a 2D point:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的C#示例，用于表示二维点的自定义数据结构：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This `Point2D` struct demonstrates a basic custom data structure with properties
    for `X` and `Y` coordinates and a method to translate the point:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Point2D`结构体演示了一个基本的自定义数据结构，具有`X`和`Y`坐标属性以及一个用于平移点的`translate`方法：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Point2DExample` script demonstrates creating a `Point2D` instance, logging
    its initial coordinates, translating the point by adding values to its X and Y
    coordinates, and then logging the updated coordinates. This shows how the `Point2D`
    struct can be used to manage and manipulate 2D point data in Unity. Such straightforward,
    custom structures enhance readability and maintainability, allowing developers
    to model game data more intuitively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point2DExample`脚本演示了创建`Point2D`实例，记录其初始坐标，通过向其X和Y坐标添加值来平移点，然后记录更新后的坐标。这展示了如何使用`Point2D`结构在Unity中管理和操作2D点数据。这种简单、自定义的结构增强了可读性和可维护性，使开发者能够更直观地建模游戏数据。'
- en: Integrating custom structures within Unity
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Unity中集成自定义结构
- en: Integrating custom data structures into Unity involves leveraging Unity-specific
    features such as `ScriptableObject` for sophisticated data storage, alongside
    understanding serialization nuances for game data persistence. This approach enhances
    game architecture by enabling more complex data management and state-saving mechanisms
    tailored to Unity’s environment.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义数据结构集成到Unity中涉及利用Unity特定的功能，如`ScriptableObject`进行复杂的数据存储，以及理解序列化细节以实现游戏数据持久化。这种方法通过允许更复杂的数据管理和针对Unity环境的定制状态保存机制来增强游戏架构。
- en: '`ScriptableObject` allows for creating data containers that are not bound to
    scene objects, ideal for storing game settings, character stats, or inventory
    items, and can be easily edited within the Unity Editor. When designing custom
    structures, it’s important to ensure they are serializable to maintain game state
    across sessions, requiring attention to Unity’s serialization rules and attributes.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScriptableObject`允许创建不绑定到场景对象的数据容器，非常适合存储游戏设置、角色统计数据或库存物品，并且可以在Unity编辑器中轻松编辑。在设计自定义结构时，确保它们可序列化以保持游戏状态跨会话，需要关注Unity的序列化规则和属性。'
- en: 'For instance, creating a `ScriptableObject` for an inventory system might look
    like this in C#:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在C#中创建一个用于库存系统的`ScriptableObject`可能看起来像这样：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sample defines a basic quest-tracking system where items can be dynamically
    added, leveraging `ScriptableObject` to create a flexible and reusable quest asset.
    Integrating such custom structures effectively with Unity not only broadens the
    game’s design possibilities but also streamlines development workflows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例定义了一个基本的任务追踪系统，其中可以通过利用`ScriptableObject`来创建一个灵活且可重用的任务资产，从而动态地添加项目。将此类自定义结构有效地集成到Unity中不仅拓宽了游戏的设计可能性，而且简化了开发工作流程。
- en: Common custom structures in game development
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏开发中的常见自定义结构
- en: In game development, common custom data structures such as grids, trees, and
    graphs play pivotal roles in creating immersive worlds and intelligent behaviors.
    These structures underpin various aspects of game design, from level layout to
    AI decision-making and navigation, offering tailored solutions for complex problems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，常见的自定义数据结构，如网格、树和图，在创建沉浸式世界和智能行为中发挥着关键作用。这些结构支撑着游戏设计的各个方面，从关卡布局到AI决策和导航，为复杂问题提供定制解决方案。
- en: Grids and matrices are fundamental for designing game levels, providing a structured
    approach to map creation and spatial organization. Trees, particularly Behavior
    Trees, are indispensable for structuring AI decision processes, enabling a clear,
    modular approach to AI behavior scripting. Graphs facilitate the representation
    of interconnected spaces, which is essential for pathfinding algorithms and map
    navigation. Implementing these custom structures enhances game functionality,
    contributing to more dynamic environments and sophisticated gameplay mechanics.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 网格和矩阵是设计游戏关卡的基础，为地图创建和空间组织提供了一种结构化的方法。树，尤其是行为树，对于结构化AI决策过程至关重要，它使得AI行为脚本的编写具有清晰、模块化的方法。图有助于表示相互连接的空间，这对于路径查找算法和地图导航至关重要。实现这些自定义结构增强了游戏功能，有助于创造更动态的环境和更复杂的游戏机制。
- en: Advanced techniques for data structures in game development
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏开发中数据结构的高级技术
- en: Exploring advanced techniques in game development, such as the use of generics
    and design patterns, can significantly enhance the flexibility and efficiency
    of data structures. These methodologies allow for more adaptable and maintainable
    code, critical for complex game systems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 探索游戏开发中的高级技术，如泛型和设计模式的使用，可以显著提高数据结构的灵活性和效率。这些方法允许编写更适应性和可维护的代码，这对于复杂游戏系统至关重要。
- en: Generics in C# enable developers to create versatile data structures that can
    operate with various data types, leading to reusable and type-safe code, which
    ensures that errors related to incorrect data types are caught at compile time
    rather than at runtime. Design patterns, which are reusable solutions to common
    software design problems, such as Factory and Builder, further refine data structuring
    by providing clear paradigms for object creation and configuration. The Factory
    pattern simplifies object creation without specifying the exact class, while the
    Builder pattern allows for the step-by-step construction of complex objects. These
    patterns streamline the development process for complex game components and systems.
    Employing these advanced techniques fosters robust and scalable game architecture,
    accommodating the evolving needs of game development projects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的泛型允许开发者创建可通用的数据结构，这些数据结构可以与各种数据类型一起操作，从而生成可重用且类型安全的代码，这确保了与数据类型错误相关的错误在编译时而不是在运行时被捕获。设计模式，作为解决常见软件设计问题的可重用解决方案，例如工厂和构建者模式，通过提供对象创建和配置的清晰范例进一步精炼数据结构。工厂模式简化了对象创建，而不需要指定确切的类，而构建者模式允许逐步构建复杂对象。这些模式简化了复杂游戏组件和系统的开发过程。采用这些高级技术促进了健壮和可扩展的游戏架构，适应游戏开发项目的不断变化需求。
- en: Practical example – building a custom inventory system
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际示例 - 构建自定义库存系统
- en: Creating a custom inventory system exemplifies the practical application of
    custom data structures in game development, showcasing how to manage in-game items
    dynamically and efficiently. This approach allows for tailored inventory management,
    fitting the specific needs and mechanics of a game.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自定义库存系统展示了在游戏开发中自定义数据结构的实际应用，展示了如何动态和高效地管理游戏中的物品。这种方法允许进行定制的库存管理，适应游戏的具体需求和机制。
- en: To build an inventory system, start by defining a data structure that can store
    items, along with methods to add, remove, and query these items. This system should
    be flexible to accommodate various item types and quantities. Handling item additions
    involves adding to the inventory structure, while removals require checking and
    updating the inventory accordingly. Item queries might involve checking for the
    presence of an item or retrieving a list of items based on certain criteria.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个库存系统，首先定义一个可以存储物品的数据结构，以及添加、删除和查询这些物品的方法。这个系统应该足够灵活，以适应各种物品类型和数量。处理物品添加涉及向库存结构中添加，而删除则需要相应地检查和更新库存。物品查询可能涉及检查物品的存在或根据某些标准检索物品列表。
- en: 'Here’s a basic C# example of an inventory system:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的 C# 库存系统示例：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sample outlines a simple inventory system using a `List` to manage items.
    The `AddItem` method allows for adding new items to the recipes list. The `RemoveItem`
    method removes a recipe from the recipe list and returns a Boolean indicating
    whether the removal was successful. The `CheckItem` method checks whether a specific
    recipe is present in the recipe list, returning a Boolean result. This provides
    a foundational structure for more complex recipe tracking requirements in game
    development, allowing for basic recipe management functionality within a game.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例概述了一个使用 `List` 管理物品的简单库存系统。`AddItem` 方法允许向食谱列表中添加新物品。`RemoveItem` 方法从食谱列表中删除食谱，并返回一个布尔值，指示删除是否成功。`CheckItem`
    方法检查特定食谱是否存在于食谱列表中，并返回一个布尔结果。这为游戏开发中更复杂的食谱跟踪需求提供了一个基础结构，允许在游戏中实现基本的食谱管理功能。
- en: Custom data structures in Unity are pivotal for tailoring game development to
    specific needs, from the foundational concepts and design considerations such
    as performance and usability to their practical implementation and integration
    within Unity using C# and `ScriptableObject`. This exploration covered various
    structures such as grids for level design and trees for AI, alongside advanced
    techniques involving generics and design patterns. With a focus on optimization
    and best practices, such as efficient memory management and avoiding common pitfalls,
    we’ve laid the groundwork for creating robust and performant custom structures.
    A practical walkthrough of building a custom inventory system exemplified these
    concepts in action. As we transition to discussing game logic, the insights gained
    from custom data structures will prove invaluable in crafting sophisticated game
    mechanics.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，自定义数据结构对于满足特定游戏开发需求至关重要，从基础概念和设计考虑，如性能和可用性，到其实际应用和通过C#和`ScriptableObject`在Unity中的集成。这次探索涵盖了各种结构，如用于关卡设计的网格和用于AI的树，以及涉及泛型和设计模式的先进技术。我们专注于优化和最佳实践，如高效的内存管理和避免常见陷阱，为创建健壮且高效的自定义结构奠定了基础。构建自定义库存系统的实际演练展示了这些概念的实际应用。当我们过渡到讨论游戏逻辑时，从自定义数据结构中获得的知识将在构建复杂游戏机制时变得极为宝贵。
- en: Data structures for game logic
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏逻辑的数据结构
- en: Let’s delve into the critical intersection of game logic and data structuring
    within Unity game development. Starting with the fundamentals, we will explore
    how essential data structures such as arrays and Lists form the backbone of game
    logic, facilitating core functionalities such as inventory systems and character
    management. The narrative then advances to sophisticated data management practices,
    where we examine the use of complex structures such as Dictionaries and HashSets
    in orchestrating game states, asset management, and unique item tracking. This
    section also sheds light on crafting custom data structures tailored to specific
    game development needs, such as skill trees or networked interactions. The culmination
    of this journey is a comprehensive discussion on the seamless integration of these
    data structures with Unity’s components, emphasizing performance optimization
    and practical implementation. Through this structured approach, the section aims
    to equip game developers with the knowledge to harness data structures effectively,
    enhancing game logic and overall project performance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨Unity游戏开发中游戏逻辑与数据结构的关键交汇点。从基础开始，我们将探讨数组和列表等基本数据结构如何构成游戏逻辑的骨架，促进核心功能，如库存系统和角色管理。接着，我们将探讨复杂的数据管理实践，例如在协调游戏状态、资产管理以及独特物品跟踪中使用字典和哈希集。本节还将阐明针对特定游戏开发需求定制数据结构的方法，例如技能树或网络交互。这一旅程的最终目标是全面讨论这些数据结构与Unity组件的无缝集成，强调性能优化和实际应用。通过这种结构化的方法，本节旨在为游戏开发者提供有效利用数据结构的知识，从而增强游戏逻辑和整体项目性能。
- en: Fundamentals of game logic and data structures
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏逻辑和数据结构的基本原理
- en: Game logic forms the essence of interactive experiences in game development,
    orchestrating everything from character movement to complex decision-making processes.
    At the heart of implementing these game logic elements are foundational data structures
    such as arrays and Lists, which provide the necessary framework for organizing
    and manipulating game data efficiently. These structures facilitate a wide array
    of game logic implementations, enabling developers to create dynamic inventory
    systems, manage character attributes, and track in-game entities with ease and
    precision.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏逻辑构成了游戏开发中交互体验的核心，从角色移动到复杂的决策过程，无所不包。实现这些游戏逻辑元素的核心是基础数据结构，如数组和列表，它们为高效组织和操作游戏数据提供了必要的框架。这些结构促进了各种游戏逻辑的实现，使开发者能够轻松精确地创建动态库存系统、管理角色属性以及跟踪游戏中的实体。
- en: Arrays and Lists, in particular, serve as the building blocks for structuring
    game elements in a coherent and accessible manner. Whether it’s handling a collection
    of items a player can carry or maintaining a list of non-player characters within
    a game world, these data structures offer the flexibility and performance required
    to implement game logic effectively. By understanding and leveraging arrays and
    Lists, developers can ensure that the core components of their games—such as inventory
    management and character state tracking—are both robust and adaptable to the complexities
    of game development.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是数组和列表，作为构建游戏元素结构化且易于访问的基础。无论是处理玩家可以携带的物品集合，还是在游戏世界中维护非玩家角色列表，这些数据结构提供了实施游戏逻辑所需的灵活性和性能。通过理解和利用数组和列表，开发者可以确保他们游戏的核心组件——如库存管理和角色状态跟踪——既强大又能够适应游戏开发的复杂性。
- en: Advanced data management in game development
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏开发中的高级数据管理
- en: As game development projects grow in complexity, the need for more advanced
    data management strategies becomes paramount. Dictionaries and HashSets emerge
    as sophisticated data structures that excel in managing game states and assets
    and ensuring the uniqueness of collections, such as inventory items or enemy entities.
    Dictionaries, with their key-value pairing, provide an efficient means to associate
    specific game states or assets with unique identifiers, facilitating swift access
    and modifications. HashSets are invaluable for managing collections where uniqueness
    is crucial, eliminating the overhead of checking for duplicates, and enhancing
    performance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏开发项目复杂性的增加，对更高级数据管理策略的需求变得至关重要。字典和哈希集作为高级数据结构，在管理游戏状态和资产以及确保集合的唯一性方面表现出色，例如库存物品或敌人实体。字典通过其键值对提供了一种有效的方法，将特定的游戏状态或资产与唯一的标识符关联起来，从而促进快速访问和修改。哈希集在管理唯一性至关重要的集合时非常有价值，消除了检查重复项的开销，并提高了性能。
- en: Beyond these, the custom design of data structures tailors solutions to the
    unique challenges of complex game systems, such as skill trees, which demand hierarchical
    organization, or networking systems that require efficient, low-latency data exchange.
    Crafting these custom structures demands a deep understanding of both the game’s
    requirements and the underlying algorithms, ensuring that the data management
    backbone is both robust and capable of scaling with the game’s evolving needs.
    Together, these advanced data management tools form a versatile toolkit for developers,
    enabling them to construct richer, more dynamic game worlds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，数据结构的定制设计针对复杂游戏系统独特的挑战提供解决方案，例如技能树，它需要层次化组织，或者需要高效、低延迟数据交换的网络系统。构建这些定制结构需要深入理解游戏的需求和底层算法，确保数据管理骨干既强大又能够随着游戏不断发展的需求进行扩展。这些高级数据管理工具共同构成了开发者可用的多功能工具包，使他们能够构建更丰富、更动态的游戏世界。
- en: Optimization and integration of data structures in Unity
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中数据结构的优化和集成
- en: Integrating and optimizing data structures in Unity involves ensuring they work
    seamlessly with Unity’s components for optimal performance. Utilizing Unity’s
    native types, such as GameObjects and ScriptableObjects, ensures compatibility
    with built-in functionalities, allowing for smoother development and easier maintenance.
    Following Unity’s conventions streamlines processes such as serialization, asset
    management, and scene organization. Creating custom systems can lead to compatibility
    issues and increased complexity. Proper integration and performance optimization
    prevent bottlenecks in resource-intensive scenes or complex game mechanics, enhancing
    the maintainability of the game code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中集成和优化数据结构涉及确保它们与Unity的组件无缝工作以实现最佳性能。利用Unity的本地类型，如GameObject和ScriptableObjects，确保与内置功能的兼容性，从而实现更流畅的开发和更简单的维护。遵循Unity的约定简化了序列化、资产管理以及场景组织等流程。创建自定义系统可能导致兼容性问题并增加复杂性。适当的集成和性能优化可以防止在资源密集型场景或复杂游戏机制中出现瓶颈，从而提高游戏代码的可维护性。
- en: Applying these concepts in real-world game development scenarios involves a
    meticulous approach to designing, implementing, and refining game features. For
    instance, when developing a character inventory system, developers must consider
    how the data structure will interact with Unity’s UI components, handle serialization
    for game saves, and ensure that inventory updates do not hinder game performance.
    By using the concepts discussed in this chapter and regularly assessing performance,
    developers can effectively integrate and optimize data structures. This involves
    using a variety of data containers to enhance gameplay and user experience. Ensuring
    a balanced use of different data structures allows for efficient resource management
    and smooth game mechanics, highlighting the importance of proficient data structure
    optimization and integration in Unity game projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的游戏开发场景中应用这些概念需要精心设计、实施和改进游戏功能的方法。例如，在开发角色库存系统时，开发者必须考虑数据结构如何与Unity的UI组件交互，处理游戏保存的序列化，并确保库存更新不会妨碍游戏性能。通过使用本章讨论的概念并定期评估性能，开发者可以有效地集成和优化数据结构。这涉及到使用各种数据容器来增强游戏和用户体验。确保不同数据结构的平衡使用可以有效地进行资源管理，并使游戏机制流畅，突出了在Unity游戏项目中熟练的数据结构优化和集成的重要性。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this exploration of data structures in Unity, we’ve delved into the
    foundational elements of arrays and Lists, their pivotal role in game logic, and
    the dynamic capabilities they offer for managing game objects and systems such
    as inventory and character attributes. We examined how these structures underpin
    core game mechanics and logic, providing essential frameworks for game functionality.
    Further, we expanded into the realms of Dictionaries and HashSets, highlighting
    their specialized use in state management, asset tracking, and ensuring unique
    collections, crucial for advanced game development scenarios. The journey also
    encompassed custom data structures, tailored to fit complex systems and enhance
    game functionality, emphasizing the integration and optimization within Unity’s
    ecosystem to ensure peak performance and seamless gameplay experiences.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次对Unity中数据结构的探索中，我们深入研究了数组与列表的基础元素，它们在游戏逻辑中的关键作用，以及它们为管理游戏对象和系统（如库存和角色属性）提供的动态能力。我们考察了这些结构如何支撑核心游戏机制和逻辑，为游戏功能提供基本框架。此外，我们还扩展到了字典和哈希集的领域，强调了它们在状态管理、资产跟踪和确保唯一集合方面的专用用途，这对于高级游戏开发场景至关重要。这次旅程还包括了定制数据结构，这些结构旨在适应复杂系统并增强游戏功能，强调了在Unity生态系统中的集成和优化，以确保最佳性能和无缝的游戏体验。
- en: As we transition from the structural backbone of game development into the realm
    of Unity’s **user interface** (**UI**) elements, the principles and insights gained
    from data management will prove invaluable. Understanding how to effectively organize
    and manipulate data underpins not only game logic and system design but also the
    creation of intuitive and responsive UIs, bridging the gap between backend mechanics
    and frontend user interaction. The upcoming chapter will build upon this foundation,
    exploring how data structures inform UI design and functionality, enhancing player
    engagement and overall game quality.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从游戏开发的结构基础过渡到Unity的用户界面（UI）元素领域时，从数据管理中获得的原则和见解将证明非常有价值。理解如何有效地组织和操作数据不仅支撑了游戏逻辑和系统设计，还支撑了直观和响应式的UI创建，弥合了后端机制和前端用户交互之间的差距。接下来的章节将在此基础上构建，探讨数据结构如何影响UI设计和功能，增强玩家参与度和整体游戏质量。
- en: Join our community on Discord
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)
- en: '![](img/Disclaimer_QR2.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![免责声明二维码](img/Disclaimer_QR2.jpg)'
