<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-154"><a id="_idTextAnchor163"/>7</h1>
<h1 id="_idParaDest-155"><a id="_idTextAnchor164"/>Testing Your Code</h1>
<p><strong class="bold">Testing code</strong> is an overloaded term when it comes to development. It can refer to several concepts, such as load testing, unit tests, or integration testing, just to name a few. All testing concepts are important for developers to understand regarding the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>). Each has its purpose and is equally important to provide stability and confidence, and even provide documentation.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Understanding testing concepts</li>
<li>Best approaches for testing</li>
<li>Testing Entity Framework Core</li>
</ul>
<p>In the first section, we’ll cover the basic concepts of testing, including unit, integration, regression, load, system, and UI tests.</p>
<p>Next, we’ll review some best approaches when writing solid tests for software, including why tests are necessary, how many unit tests are required, using the <strong class="bold">Arrange, Act, Assert</strong> (<strong class="bold">AAA</strong>) technique when writing unit tests, why unit test scaffolding should be avoided, why to avoid large unit tests, how and why to avoid static methods, and, finally, how to use tests for documentation.</p>
<p>Finally, we’ll apply our knowledge of this chapter by creating a full integration test using Entity Framework Core.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor165"/>Technical requirements</h1>
<p>We recommend using a favorite editor to view this book’s GitHub repository. Our recommendations include the following:</p>
<ul>
<li>Visual Studio (preferably 2022, though any version is fine)</li>
<li>Visual Studio Code</li>
<li>JetBrains Rider</li>
</ul>
<p>The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with the code.</p>
<p>The code for this chapter is located in Packt Publishing’s GitHub repository, which is located in the <code>Chapter07</code> folder, at <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor166"/>Understand testing concepts</h1>
<p>Unit tests are<a id="_idIndexMarker389"/> important to developers because they provide stability to software, confidence in their code, and the added benefit of documenting complex code. Unit tests provide numerous benefits, as we’ll see in this chapter.</p>
<p>In this section, we’ll review the concepts of testing and why each one is important to the stability and confidence in building a website.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor167"/>Unit tests</h2>
<p>The smallest test we can write to <a id="_idIndexMarker390"/>confirm the code functions as <a id="_idIndexMarker391"/>expected is a unit test. Unit tests are usually created to test small(-ish) methods, as well as to test multiple parameters sent into those methods and expect a certain result.</p>
<p>Identifying the types of unit tests to write is a simple process of finding conditions in a method and writing the relevant test for the behavior.</p>
<p>The following scenarios could justify unit tests throughout a method:</p>
<ul>
<li>Successful flow of a method (that is, the happy path)</li>
<li>Failure of a method’s behavior (that is, the unhappy path)</li>
<li>Any branching or condition (if..then, switch, inline if, and so on)</li>
<li>Different parameters passed into the method</li>
<li>Exception handling</li>
</ul>
<p>If we have a large system, the number of unit tests is expected to be in the hundreds since these small, granular methods comprise most of the system.</p>
<p>The following example shows an extension method formatting a date/time object for display purposes. Since it’s self-contained, we can simply create a date/time object and test it:</p>
<pre class="source-code">
[TestMethod]
public void FormattedDateTimeWithTimeTest()
{
    // Arrange
    var startDate = new DateTime(2023, 5, 2, 14, 0, 0);
    const string expected = @"May 2&lt;sup&gt;nd&lt;/sup&gt;, 2023 at 2:00pm";
    // Act
    var actual = startDate.ToFormattedDateTime();
    // Assert
    Assert.AreEqual(expected, actual);
}</pre> <p>This code creates a<a id="_idIndexMarker392"/> new date with a time. The unit test is formatted <a id="_idIndexMarker393"/>using the AAA technique (which we’ll cover in a bit) and returns a string to be displayed in our HTML.</p>
<p>Once unit tests are in place, the next step is to provide integration tests.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor168"/>Integration tests</h2>
<p>The next level<a id="_idIndexMarker394"/> of <a id="_idIndexMarker395"/>testing is integration tests, which require additional functionality as to how the system is tested. Integration tests involve grouping modules and the ability to test those components as a group, which contrasts with unit tests.</p>
<p>In my experience, the primary difference between integration and unit tests is external resources. If a unit test accesses an external resource (such as a disk drive, database, network call, or API), it can be considered an integration test.</p>
<p>The following example shows a simple integration test where we’re connecting to a local test database to <a id="_idIndexMarker396"/>confirm the connection of the database and<a id="_idIndexMarker397"/> returning a valid <code>IndexModel</code> object:</p>
<pre class="source-code">
[TestClass]
public class PageTests
{
    private DbContextOptions&lt;ThemeParkDbContext&gt; _options;
    private ThemeParkDbContext _context;
    [TestInitialize]
    public void Setup()
    {
        _options = new DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
            .UseSqlServer("Data Source=localhost;Initial                  Catalog=ASPNetCore8BestPractices;" +
                 "Integrated                  Security=True;MultipleActiveResultSets=True;")
                 .Options;
        var config = new Mock&lt;IConfiguration&gt;();
        _context = new ThemeParkDbContext(_options, config.Object);
    }
    [TestMethod]
    [TestCategory("Integration")]
    public void ReturnAnIndexModelTest()
    {
        // Arrange
        var logger = new Mock&lt;ILogger&lt;IndexModel&gt;&gt;();
        var service = new AttractionService(_context);
        // Act
        var actual = new IndexModel(logger.Object, service);
        // Assert
        Assert.IsNotNull(actual);
        Assert.IsInstanceOfType(actual, typeof(IndexModel));
    }
}</pre> <p>In <code>DbContextOptionsBuilder</code>, we created a connection to our local database, created a valid <code>AttractionService</code> while passing in our valid <code>ThemeParkDbContext</code>, and confirmed we have the right type of model.</p>
<p>In the end, there are<a id="_idIndexMarker398"/> different ways to conduct integration<a id="_idIndexMarker399"/> tests, such as creating a mocked-up database or API, duplicating an environment, or even creating a new server for our tests.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor169"/>Regression tests</h2>
<p>Regression tests<a id="_idIndexMarker400"/> are the functional and nonfunctional <a id="_idIndexMarker401"/>tests we’ve performed in the past. By nature, these are the past successful tests we ran against the system. Regression tests are types of tests that are conducted to confirm new features don’t break existing features. These include the unit tests and integration tests.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor170"/>Load testing</h2>
<p>Once you have the <a id="_idIndexMarker402"/>tests (unit and integration) running in <a id="_idIndexMarker403"/>the CI/CD pipeline (see <a href="B19493_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>) and are expecting a large number of users to hit the site, it is advantageous to create load test(s) for the site.</p>
<p>When load testing a website, subject it to stress levels beyond what a single developer experiences when running the site standalone. Load testing simulates a large number of users hitting the website concurrently and reports on whether the site can handle a large influx of users.</p>
<p>The results of a load test may require several team members to help with the performance of the website. Not only would developers be involved, but <strong class="bold">database administrators</strong> (<strong class="bold">DBAs</strong>), system <a id="_idIndexMarker404"/>administrators, and even architects would be involved with fixing the performance of the site.</p>
<p>A continuous increase in performance should be the goal of the website and creating load tests to measure performance is key to that.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor171"/>System testing (end-to-end or E2E)</h2>
<p>System testing is <a id="_idIndexMarker405"/>based on certain scenarios <a id="_idIndexMarker406"/>and is a team effort. Users of the system test new features introduced into the system while other team members conduct regression system testing to confirm new features don’t break existing features.</p>
<p>Members of the team create scenarios for users. These users are then asked to walk through each scenario and provide feedback on whether it works or not.</p>
<p>One example scenario could be broken down into several categories, as shown here:</p>
<ul>
<li>Shopping cart:<ul><li>Log in to the website</li><li>Place an item into the shopping cart</li><li>Click on checkout</li><li>Receive a confirmation page with an order number</li></ul></li>
</ul>
<p>If the scenario succeeds, the top scenario (“shopping cart”) will contain a green checkmark, meaning all steps passed with no issues. If one of the steps failed, a red “X” with a reason underneath it would appear and be placed into the backlog for developers to examine later.</p>
<p>These types of tests require multiple users to go through the site and find issues with certain scenarios. There are times when manually testing a site is necessary, but if there’s time <a id="_idIndexMarker407"/>available, it <a id="_idIndexMarker408"/>may make sense to automate these scenarios using a <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) testing approach.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor172"/>UI testing</h2>
<p>UI testing is visually<a id="_idIndexMarker409"/> conducted through a software tool such as Selenium<a id="_idIndexMarker410"/> or Cypress and automates an end user clicking around or a customer navigating the website based on a given scenario. This requires a tester to understand how the UI testing software works; they should know how to access elements on a page, know how to place values into those elements, and know how to activate events such as click and blur to simulate an end user clicking a button.</p>
<p>These types of tests are usually done after work hours through a CI/CD pipeline but can be run during work hours on a dedicated server (that is, a QA server) to identify issues early.</p>
<p>In this section, we reviewed various types of testing, including unit tests, integration tests, regression tests, load tests, system tests, and UI testing, and how each one is important and leverages the other.</p>
<p>In the next section, we’ll look at what developers are accustomed to when it comes to unit tests, including why we write unit tests, debunking the 100% test coverage myth, how using AAA is a great approach for unit tests, why we should write a unit test library, creating large unit tests, why unnecessary mocks should be avoided, and why unit tests have the added benefit of documentation. We’ll also learn how to identify slow integration <a id="_idIndexMarker411"/>tests, when<a id="_idIndexMarker412"/> to write a unit test, and how to avoid testing .NET code.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor173"/>Best approaches for testing</h1>
<p>Every company has its way <a id="_idIndexMarker413"/>of testing software. Whether it’s manually or automated, it’s a requirement for developers. Developers are becoming more than just people who type code. We’re required to design, write, test, debug, document, build, and deploy software.</p>
<p>Automating tests using a CI/CD approach is where companies can save time and provide consistent stability and quality when releasing software to the public.</p>
<p>In this section, we’ll cover the standards of why testing is important, how to avoid the 100% test coverage myth, what AAA is and why it’s a great approach for unit tests, how to avoid writing a unit test library, large unit tests, and unnecessary mocks. We’ll also learn about why tests have the added benefit of documentation, how to identify slow integration tests, when to write a unit test, and how to avoid testing .NET code.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor174"/>Why do we write tests?</h2>
<p>While some believe<a id="_idIndexMarker414"/> testing starts with developers, I believe it should start with management.</p>
<p>Developers consider tests as an absolute requirement when writing software, but if management believes tests are a waste of time, it may be time to update the resume.</p>
<p>Management, and possibly some developers, have various opinions about the stability of their software and the impact tests have on timetables.</p>
<p>The reason for tests is simple: it allows developers to confirm the code they write to perform as expected. Further, if tests are providing a simple way to consume a certain module of code, those tests provide clarity to others as well as the original author, for that matter.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor175"/>The “100% test coverage” myth</h2>
<p>As we swing<a id="_idIndexMarker415"/> the pendulum to the other side, some managers require 100% test coverage. While some people believe it’s possible, 100% is not achievable or desirable.</p>
<p>Tests should be created where they are needed, not just for the sake of coverage. This creates a false metric and presents an illusion of “100% test coverage” if some unit tests are included to fulfill a metric. Developers may build tests just to “make their quota” to achieve this mythical metric. Each test should provide integrity with solid results and value.</p>
<p>This metric goes hand in<a id="_idIndexMarker416"/> hand with the <strong class="bold">Line-Of-Code</strong> (<strong class="bold">LoC</strong>) false metric as well because a developer <a id="_idIndexMarker417"/>who can write code with the least amount of lines is more efficient than a developer who writes less efficient code. More doesn’t always mean better.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor176"/>Using AAA</h2>
<p>When we write <a id="_idIndexMarker418"/>our unit tests, the best way is to use the <a id="_idIndexMarker419"/>AAA technique:</p>
<ul>
<li><strong class="bold">Arrange</strong>: Initialize the code for a test</li>
<li><strong class="bold">Act</strong>: Perform the actual test</li>
<li><strong class="bold">Assert</strong>: Determine whether the result is the expected behavior</li>
</ul>
<p>The Arrange step should initialize the code and be as minimal as possible.</p>
<p>The Act step should execute the code in question and should look similar to (if not exactly) like code in production.</p>
<p>Finally, the Assert step compares the result with what we’re expecting back from the code.</p>
<p>The AAA technique provides the easiest way to identify how tests in a system are tested.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor177"/>Avoid writing unit test code for your code</h2>
<p>While the AAA concept<a id="_idIndexMarker420"/> is a simple way of writing unit tests, there is another approach that I consider a code smell.</p>
<p>Imagine this scenario: the developer has to write a unit test where they have to make a database call using Entity Framework Core. The Arrange step has 30 lines of code to prepare the Act step to work properly. The developer takes these 30 lines of code and moves them into a library, making them available for other unit tests.</p>
<p>These 30 lines of code are the code smell I mentioned. It makes more sense to refactor the code and abstract it even further to simplify the code. The Arrange step should not include an additional library of custom code to run a unit test. It should focus on testing the production code already written, not writing additional testing code to make the code pass.</p>
<p>However, if there is a need for a helper library, it shouldn’t contain any branching statements, which <a id="_idIndexMarker421"/>would require the need to unit test the unit testing helper library.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor178"/>Avoid large unit tests</h2>
<p>Developers have <a id="_idIndexMarker422"/>various definitions of what “large” is considered. Unit tests with more than one page (a screen) of code or more than 30 lines of code should be avoided.</p>
<p>These types of unit test methods present a problem: they are one step away from creating a library for the Arrange step from our previous tip.</p>
<p>Again, it’s considered a code smell, where someone may need to take a step back and look at better ways to produce smaller setups instead of large code blocks of initialization.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor179"/>Avoid unnecessary mocks, fakes, or stubs</h2>
<p>There are times <a id="_idIndexMarker423"/>when a method on a<a id="_idIndexMarker424"/> class doesn’t have any dependencies and is completely isolated. When we encounter this, we may not need to create a mocked object to fully unit test the method.</p>
<p>Mocking is when we want to test a predefined behavior where stubs return a predefined value. Fakes are fully populated objects with working implementations.</p>
<p>At the very beginning of this chapter, we mentioned what a unit test was. We also created a simple extension method called <code>.ToFormattedDateTime()</code>. Since it’s an isolated method, we don’t require a mocked date/time object. We simply call the method.</p>
<p>For example, if we have a large library of extension methods that contain strings, we can create a unit test, create a string, pass it in, and check the return value is what is expected. If it requires further testing, rinse and repeat with different parameters.</p>
<p>When there’s a simple method, sometimes, it’s easier to test its functionality. No mock, fake, or stub <a id="_idIndexMarker425"/>is<a id="_idIndexMarker426"/> necessary.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor180"/>Using tests as documentation</h2>
<p>Every unit <a id="_idIndexMarker427"/>test should contain some explanation of what is tested either in the method signature or in a comment explaining the situation.</p>
<p>Unit tests should be informative to peers (and our future self) and indicate knowledge of what’s involved in the effort (or abstraction) of completing each unit test and how it relates to the production code under test.</p>
<p>Along with informative unit tests, directory structure can also act as documentation and can go a long way. We should mirror the directory structure of the application in the unit tests.</p>
<p>If we see a folder in the application (or have a project) named <code>Data</code>, create a similar folder or project for the unit tests called <code>Data.Tests</code>. While this may be a simple concept, it helps our peers know immediately where and what the tests relate to in the project.</p>
<p>For example, if we look at a sample project with unit tests, you may have seen this type of structure:</p>
<div><div><img alt="Figure 7.1 – Example of well-structured tests for a project" src="img/B19493_07_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Example of well-structured tests for a project</p>
<p>While some folders are missing in the <code>ThemePark.Tests</code> project, we can immediately see that the <code>Extensions</code>, <code>Pages</code>, and <code>Services</code> folders contain at least one type of test. The presence of test folders mirroring the project folders itself makes it<a id="_idIndexMarker428"/> known that they contain unit or integration tests and shows a need for additional tests to be included in the testing project.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor181"/>Identifying slow integration tests</h2>
<p>Integration tests <a id="_idIndexMarker429"/>are performed using external resources such as a database, filesystem, or API. Therefore, integration tests will always run slower than unit tests.</p>
<p>If we are working with a test environment to mimic another environment (such as arranging a QA environment to mimic production), the ability to detect slow connections provides a safeguard that an environment is working as expected. Ever heard the statement “It works in QA, but not in production” before?</p>
<p>However, if we’re working with an in-memory representation of an environment, it doesn’t make sense to identify whether a test is slow or not, does it? Compared to an actual environment, an in-memory representation of an environment will always run faster.</p>
<p>One example of this is using the <code>Stopwatch</code> class to gauge processes (a page or API) to determine whether they’re fast or <em class="italic">very</em> fast.</p>
<p>If we look at our Entity Framework example from <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, and we add an integration test to the project, we can create a simple way to identify whether our page call is slow or not, as shown<a id="_idIndexMarker430"/> in the following example:</p>
<pre class="source-code">
using System.Diagnostics;
using EFApplication.Pages;
using EFApplication.Services;
using Microsoft.Extensions.Logging;
using Moq;
namespace ThemePark.Tests.Pages;
[TestClass]
public class PagesTest
{
    [TestMethod]
    [TestCategory("Integration")]
    public void ConfirmTheMainPageReturnsWithinThreeSecondTest()
    {
        // Arrange
        var logger = new Mock&lt;ILogger&lt;IndexModel&gt;&gt;();
        var service = new Mock&lt;IAttractionService&gt;();
        var stopwatch = Stopwatch.StartNew();
        // Act
        _ = new IndexModel(logger.Object, service.Object);
        // Assert
        // Make sure our call is less than 3 seconds
        stopwatch.Stop();
        var duration = stopwatch.Elapsed.Seconds;
        Assert.IsTrue(duration &lt;= 3);
    }
}</pre> <p>In this integration <a id="_idIndexMarker431"/>test, we are testing the main page of our <code>ThemePark</code> application and finding out if it performs well or not. First, we arrange our classes, since <code>IndexModel</code> accepts <code>ILogger&lt;PageModel&gt;</code> and <code>IAttractionService</code>. Once we create our stopwatch, we call <code>IndexModel</code> (Act) and stop the stopwatch immediately. We convert it into seconds and conduct our Assert step.</p>
<p>Of course, we are performing an in-memory integration test for illustration purposes, but this concept is best suited to integration tests with external resources to identify latency issues.</p>
<p>In the example above, we can’t tell if it’s in memory or not just by reading the test. It’s encapsulated in <code>IndexModel</code> and its goal is meant to identify whether it performs quick or not.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor182"/>Find a bug, write a test</h2>
<p>Unit tests are <a id="_idIndexMarker432"/>vital to a stable product, regardless of <a id="_idIndexMarker433"/>whether it’s a web application or a smartphone app. Every developer will most definitely experience bugs in the application, so it makes sense to always keep the unit tests up to date.</p>
<p>When we (or the users) encounter a bug, repeat this mantra: <em class="italic">Find a bug, write a test</em>. This may be a simple concept, but it’s recommended.</p>
<p>When anyone finds a bug in the application, immediately write a unit test about that bug. This gives us peace of mind when deploying an application. If we had a bug and confirmed a unit test fixed the problem, we’ll have enough confidence to say it was tested before being deployed. It’s one thing to fix the problem, but adding a test makes the code more bulletproof and provides confidence that the bug won’t happen again.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor183"/>Avoid testing .NET</h2>
<p>.NET is a large <a id="_idIndexMarker434"/>framework. Unit tests are meant to test specific code. <em class="italic">YOUR code</em>. There is no need to create unit tests for .NET code (or other libraries/frameworks for that matter) when it’s already been tested by Microsoft.</p>
<p>For example, if there is a test for determining whether a substring method returns the right value, this is testing the .NET framework. <em class="italic">Don’t write this </em><em class="italic">unit test</em>.</p>
<p>Our efforts are better suited to a higher scope of the method. Focus on unit testing the calling method where our code lives as opposed to a .NET method.</p>
<p>In this section, we examined why creating unit tests is important and why 100% test coverage is a myth. We also learned about various common unit testing strategies, such as how to use an AAA scaffolding for our unit tests, why it’s considered a code smell to write additional unit test libraries when creating large unit tests, and why sometimes mocking libraries aren’t necessary for everything.</p>
<p>We also learned about using tests as documentation using comments and folders, identifying slow integration tests by adding stopwatches, finding a bug and immediately writing a test to bulletproof our code even further, and how to avoid testing .NET methods.</p>
<p>In the next section, we’ll review our strategies and apply them to our <code>ThemePark</code> application<a id="_idIndexMarker435"/> from <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/>Testing data access</h1>
<p>Over the years, Entity <a id="_idIndexMarker436"/>Framework has strived to become unit testable and gives developers a better level of confidence when working with data access.</p>
<p>Building on when we created a sample database with Entity Framework Core in <a href="B19493_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, in this section, we’ll cover a simple way to use a SQLite in-memory database to confirm the functionality of our application… even though we don’t have a database connection. Using the in-memory provider option, Microsoft has recommended avoiding this approach and using either SQLite to conduct database calls or using a production (or better, a QA) database for our queries.</p>
<p class="callout-heading">Avoid in-memory providers</p>
<p class="callout">Since in-memory is an extremely simplistic implementation of a database, Microsoft has recommended using alternative methods for testing and avoiding the in-memory provider for databases. Refer to the following URL for additional details: <a href="https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database">https://learn.microsoft.com/en-us/ef/core/testing/testing-without-the-database</a>.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor185"/>Adding the SQLite provider</h2>
<p>Since we don’t<a id="_idIndexMarker437"/> have a way to access data yet in our <a id="_idIndexMarker438"/>tests, we have to add SQLite to get as close to an implementation as possible. Using NuGet, we have to add the following NuGet packages:</p>
<ul>
<li><code>Microsoft.EntityFrameworkCore.Sqlite</code></li>
<li><code>Microsoft.EntityFrameworkCore.InMemory</code></li>
</ul>
<p>Once we have those in our tests, we can proceed with creating our <code>AttractionService</code> and <code>LocationService</code> tests to confirm they work as expected.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Creating the AttractionService test</h2>
<p>Since we<a id="_idIndexMarker439"/> are using <code>AttractionService</code> as a “repository,” we only <a id="_idIndexMarker440"/>need to pass in <code>DbContext</code> for it to work as expected. Currently, <code>ThemeParkDbContext</code> creates seeded data for an empty database.</p>
<p>This is perfect for our needs because when passing in <code>ThemeParkDbContext</code>, <code>DbContext</code> could be an in-memory representation or an actual connection to a production database. In this case, we are creating an in-memory SQLite database for our purposes.</p>
<p>The SQLite provider opens connections when a call is made and deletes the connection when it’s closed. We create the connection during setup and provide a <code>[Cleanup]</code> attribute to deallocate the connection. This is specifically for SQLite.</p>
<p>Our <code>AttractionService</code> integration test is shown in the following example:</p>
<pre class="source-code">
using Microsoft.EntityFrameworkCore;
using System.Data.Common;
using Microsoft.Data.Sqlite;
using Microsoft.Extensions.Configuration;
using Moq;
using ThemePark.DataContext;
using ThemePark.Services;
namespace ThemePark.Tests.Services;
[TestClass]
public class AttractionServiceTest
{
    private DbConnection _connection = null!;
    private DbContextOptions&lt;ThemeParkDbContext&gt; _options = null!;
    private IThemeParkDbContext _context = null!;
    [TestInitialize]
    public void Setup()
    {
        _connection = new SqliteConnection("Filename=:memory:");
        _connection.Open();
        // These options will be used by the context instances in this            test suite,
        // including the connection opened above.
        _options = new DbContextOptionsBuilder&lt;ThemeParkDbContext&gt;()
            .UseSqlite(_connection)
            .Options;
        var config = new Mock&lt;IConfiguration&gt;();
        // Create the schema and seed some data
        _context = new ThemeParkDbContext(_options, config.Object);
        _context?.Database.EnsureCreated();
    }
    [TestCleanup]
    public void Cleanup()
    {
        _connection.Dispose();
    }
    [TestMethod]
    public async Task ReturnAllAttractionsTest()
    {
        // Arrange
        var service = new AttractionService(_context);
        // Act
        var records = await service.GetAttractionsAsync();
        // Assert
        Assert.IsTrue(records.Any());
    }
}</pre> <p>In the preceding <a id="_idIndexMarker441"/>example, we tell our tests to run <a id="_idIndexMarker442"/>the setup method using the <code>[TestInitialize]</code> attribute and clean up our mess using the <code>[TestCleanup]</code> attribute. The <code>[TestInitialize]</code> attribute attaches to a method for initialization purposes. The <code>[TestCleanup]</code> attribute identifies a method to clean up what was initialized with the <code>[</code><code>TestInitialize]</code> attribute.</p>
<p>Since we’re using SQLite for our database, we must create a connection in the <code>Setup()</code> method and open the connection. Once we open it, we need to create <code>DbContextOptions</code> for our fake database. The final step is to ensure the databases were created for our tests.</p>
<p>There are two things to notice here. The first is that we didn’t need a mocked object for <code>DbContext</code>. In the <code>OnConfiguring()</code> configuration method of <code>DbContext</code>, if we have a configuration (such as an <code>appsettings.json</code> file), we should use it. If not, we should create a SQLite in-memory database for our testing.</p>
<p>The second thing to notice is our Act step in our integration test. This line should be the same one that we have in our production code. The closer we can get test calls to match what you have in<a id="_idIndexMarker443"/> production, the more confident we’ll <a id="_idIndexMarker444"/>feel about the code, along with the accuracy and value of those tests.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/>Creating the LocationService test</h2>
<p>Since we have a<a id="_idIndexMarker445"/> structure of what our tests consist of<a id="_idIndexMarker446"/> now, we can use those tests for <code>LocationService</code>. Our <code>LocationService</code> test consists of two methods – <code>GetAllLocationsAsync()</code> and <code>GetLocationAsync(int)</code>:</p>
<pre class="source-code">
[TestMethod]
public async Task ReturnAllLocationsTest()
{
    // Arrange
    var service = new LocationService(_context);
    // Act
    var records = await service.GetLocationsAsync();
    // Assert
    Assert.IsTrue(records.Any());
}
[TestMethod]
[TestCategory("Integration")]
public async Task ReturnOneLocationByIdTest()
{
    // Arrange
    var service = new LocationService(_context);
    // Act
    var record = await service.GetLocationAsync(1);
    // Assert
    Assert.IsNotNull(record);
    Assert.IsTrue(record.Id==1);
}</pre> <p>Again, notice that we didn’t need to mock <code>DbContext</code>. We created <code>LocationService</code> by passing in <code>ThemeParkDbContext</code> and used it as we would in a production environment. The ability to set up and tear down a full database is one of the greatest ways to test the database’s functionality. While using an existing database would be as equally beneficial, this provides a quicker way of “setting up” and “tearing down” database functionality without the clutter or modifications when others update the database. If others are using an existing database, this could cause integration tests to fail in a CI/CD pipeline.</p>
<p>In this section, we<a id="_idIndexMarker447"/> learned how to set up tests with SQLite<a id="_idIndexMarker448"/> and how to perform queries using an in-memory database to mimic a production database. We also gave three examples of testing Entity Framework Core.</p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Summary</h1>
<p>Testing and documentation are often areas that get deprioritized or overlooked by development teams. However, testing is a requirement for code bases. As a final point, developers should make their tests as small and fast as possible using as close to production code in the Act step as possible.</p>
<p>In this chapter, we covered the different types of testing, which include unit, integration, regression, load testing, system (or E2E tests), and UI testing.</p>
<p>Once we understood the difference between these types of testing, we examined why creating unit tests is important and why test coverage goals shouldn’t be 100%. We then covered common unit testing strategies, such as how to use AAA scaffolding for our unit tests, why writing too much code for our unit tests is considered a code smell, and why mocking libraries aren’t required.</p>
<p>Finally, we learned how to supplement documentation by using comments and folders, how to identify slow integration tests by adding stopwatches, how to find a bug and immediately write a test to bulletproof our code even further, and how to avoid testing .NET methods.</p>
<p>In the next chapter, we’ll cover exception handling and some of the better ways to handle errors in the application.</p>
</div>
</body></html>