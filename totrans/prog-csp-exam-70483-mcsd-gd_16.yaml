- en: Serialization, Deserialization, and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a .NET application interacts with an external network, the data being exchanged
    must be transformed into a flat or binary format. Similarly, when the data is
    retrieved from external applications, binary data needs to be formatted to objects
    on which they can then be worked upon. This is done via the serialization and
    deserialization of data using different approaches. The process of changing objects
    into binary format is referred to as serialization. Deserialization is the reverse
    of serialization. In involves transforming binary data into its object representation
    so that it can be used in the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will work on different serialization and deserialization
    approaches available in the .NET Framework. We will look into XML serialization,
    JSON serialization, and binary serialization. We will also look at how we define
    data contracts in web services to inform the consuming application of the format
    of the data that is to be exchanged between different applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at how we can use different collections objects such as arrays,
    lists, dictionary, queues, and stacks and we'll learn how they can be used for
    storing and consuming data. Finally, we will look at different things that help
    us choose collection objects while working with .NET applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The programs explained in this book will be developed in Visual Studio 2017\.
    The sample code for this chapter can be found at GitHub at [https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  prefs: []
  type: TYPE_NORMAL
- en: Serialization and deserialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with objects, we often find a need to either save them in different
    mediums such as a database or file or, in some cases, transfer them to other applications
    over a network. To do this, we must first convert the object into a stream of
    bytes—this process is known as **serialization**.
  prefs: []
  type: TYPE_NORMAL
- en: Deserialization is the process of converting bytes received from the external
    application into objects that can be then used inside the application. With serialization,
    we can transform an object into bytes and save information related to its state,
    attributes, assembly version, and so on in external mediums such as databases,
    or we can exchange them on a network to external applications. An important thing
    to note here is that we can only apply serialization to objects and their attributes
    but not to their methods.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Framework provides us with the `System.Runtime.Serialization` namespace,
    which has got helper classes that help us serialize and deserialize the data.
    .NET provides us with three mechanisms for achieving this: XML serialization,
    JSON serialization, and data contract serialization.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we do serialization using `XMLSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: XmlSerializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `XMLSerialization`, we convert the data into the format of an XML document,
    which can then be transferred easily across the network.
  prefs: []
  type: TYPE_NORMAL
- en: During deserialization, we can render an object from the same XML document format.
    `XMLSerializer` is based upon **Simple Object Access Protocol** (**SOAP**), a
    protocol for exchanging information with web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'While working with `XmLSerlializer`, we must mark our classes with the `Serializable`
    tag to inform the compiler that this class is serializable. Please refer to the
    following code implementation wherein we are using this tag against our class
    to inform the compiler that the class is `Serializable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we declared a `Student` class and specified
    it with the `FirstName`, `LastName`, and `ID` attributes. To inform the compiler
    that the class is serializable, we have used the `Serializable` tag on the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need to pick and choose the attributes that we would like to
    be serialized. In these cases, we can use the `NonSerialized` tag on the attribute
    and convey to the compiler that the attribute will not be serializable. Following
    is the code implementation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We used the `Serializable` tag on the class name but used the `NonSerialized`
    tag to indicate that the `ID` attribute cannot be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a code implementation scenario where we will look at a code
    base in which we will serialize a class object using `XmlSerializer` and will
    save the file on the filesystem. This file can then be transferred across the
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we are using the same `Student` class we used
    in the previous example. We have created a dummy `Student` object and are then
    serializing the object into bytes. The bytes are then converted into a file using
    the `TextWriter` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the preceding code gets executed, a file with the name `StudentData` gets
    created in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7d7dcd6-9cb9-4af2-a1fb-ffbfff6b162a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we open the file in Internet Explorer, we will see the student data in XML
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5655cae-f6b7-461f-a02f-162c8a69c07c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code example, there was no hierarchy in the data. All of the
    data is represented as an element in the XML file. However, in most situations,
    we will need to represent data that is following some sort of hierarchy. Using
    the preceding example, let''s try to represent the course scores for each of the
    students as well. Let''s say there are five courses: English, Maths, Physics,
    Chemistry, and Computers. Now, let''s try to represent the scores for each of
    the courses for the student using the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding complete code can be found in the GitHub repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code implementation, we declared three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Course`: To represent the subject along with the description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CourseScore`: To represent the score that a student is getting in that particular
    course'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Student`: Has a list of `CourseScore` to represent the score the student gets
    in each subject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please note the following tags we used in the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`XmlIgnore`: We use this tag against attributes that we don''t want to be saved
    in the generated XML class. In the preceding class example, we have used `XmlIgnore`
    against the `Feedback` class. This will ensure that the `Feedback` attribute will
    not be present in the generated XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XmlElement`: We can use this tag if we want to represent an element in the
    generated XML. The element can then have attributes. In the preceding example,
    we used the `XmlElement` tag for the `Course` attribute. This will then enable
    us to add attributes of `Course Name` and `Course Description` in the generated
    XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLArray`: We use this tag when there can be multiple child records in this
    element. In the preceding example, we used the `XMLArray` tag for the `CourseScores`
    attribute to indicate that this is an element in the XML that can have multiple
    child records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLArrayItem`: We use this tag to represent the individual child records in
    the `XMLArray` record. In the preceding example, we used the `XMLArrayItem` tag
    to represent individual records in the list collection variable, `CourseScores`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we need to serialize the data using `XMLSerialization`, we can use the following
    code. Once the code is executed, it will generate an XML file based on the data
    structure and tags used in the preceding declaration of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the program is generated, note that an XML file, `StudentDataWithScores`,
    is generated. Now, open the XML file and review the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/218ce068-28a3-439d-ae2b-11053466435c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note the following points in the structure of the XML file that is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: In the XML file, there is no node for `Feedback` as it has been marked with
    the `XmlIgnore` tag in the `Student` class file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Student` node, there is a `CourseScores` element node in line with the
    `XmlArray` tag that we used in the `CourseScore` list collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the element node, `CourseScores`, we have an individual node item element,
    `Course`, in line with `XmlArrayItem`, which we declared for each element in the
    `CourseScores` collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of the child item nodes has a `Score` attribute. It is in line with the
    tag—`XmlElement`—that we used for `CoursePerformance`; note that the XML also
    shows the name and description of the course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we''re using `XMLSerialization`, we can produce data that we can
    easily read, but there are certain issues with regard to `XmlSerialization`:'
  prefs: []
  type: TYPE_NORMAL
- en: It consumes more space. If we are sharing XML files, they will ultimately end
    up saving space on the filesystem, which might not be ideal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to that, if we declare an attribute with the access modifier of
    `private`, it will not be picked during the XML serialization. For example, if
    we set the access modifier of the `LastName` attribute in the preceding example,
    we will see that the generated XML file will not have the attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code is the updated set of access modifiers for the attributes
    in the `Student` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The access modifier for the `LastName` attribute has been changed from `public`
    to `private`. If we execute the project and open the XML file, we will observe
    that the `LastName` attribute no longer exists in the generated XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88411386-5677-46c2-9331-dfcfd39c88d9.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will go through the binary serialization approach in
    C#.
  prefs: []
  type: TYPE_NORMAL
- en: Binary serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `XmlSerialization`, the output of the serialization is an XML file that can
    be easily opened by Notepad. However, as explained previously, creating a file
    adds to the overall storage space required by the application, which may not be
    desirable in all circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: We also observed that if we marked any attribute with the access modifier of
    `private`, it was not copied across to the generated XML file. This may also be
    an issue in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at an alternative approach in which we will serialize
    the data to a stream of bytes. This data will not be viewable like the XML file
    but will save us space and will deal with `private` attributes in a much better
    way.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework provides us with the `System.Runtime.Serialization` and `System.Runtime.Serialization.Formatters.Binary`
    namespaces, which provide us with helper classes for dealing with binary serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how binary serialization works, let''s look at the following
    example. We will work with `Student`, a similar class to what we created while
    we were working on XML serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in the class declaration, just like in `XmlSerialization`,
    we used a `Serializable` tag in the declaration of the `StudentBinary` class.
    This indicates to the compiler that the `StudentBinary` class can be serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following code to serialize and deserialize an object of this
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the code example, we created an object of the `StudentBinary` class and then
    used a helper class, `BinaryFormatter`, to serialize the data into binary data.
    Once the data is serialized, using the `FileStream` helper class, we saved this
    binary data in a binary file, `StudentBinaryData.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we open the file we created in the previous step and deserialize
    it back to the `StudentBinary` class. If we try to debug the application and do
    a quick watch on the `studeseria` variable, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/119bd568-b34a-4a55-b2d1-ee5a6f88f4c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s make one change to the preceding class: let''s mark the `LastName`
    attribute as `private`. When we used `XmlSerialization`, we saw that any attribute
    marked with the `private` access modifier was excluded from the attribute. Let''s
    do the same with binary serialization and observe the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now try to debug an application and do a QuickWatch on the `studeseria`
    variable, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d6deb19-d1f0-40b8-9049-4de1caf81a3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that even though we made `LastName` as `private`, it has no impact on the
    output. This illustrates the advantage binary serialization has on `XmlSerialization`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just with `XmlSerialization`, we can also set tags on an attribute that would
    ensure that that attribute is ignored during the serialization. We can do it with
    the `NonSerialized` tag. In the following code implementation, we are using this
    tag for the `Feedback` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Even though binary serialization allows us to overcome the restriction around
    any attribute that is marked with the `private` access modifier, there are still
    some scenarios when we would deliberately want to restrict the exchange of certain
    data, especially those attributes that are sensitive and that we would like to
    restrict anyhow. We can do this by using the `ISerializable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following implemented code, we used a similar class, `StudentBinaryInterface`,
    and have implemented an `ISerializable` interface in it. As part of this interface,
    we must implement a `GetObjectData` method in this class. This method is classed
    when the class gets serialized. In this method, we will do encapsulation and not
    add any sensitive attributes to the serialized stream. Let''s have a look at how
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we declared the `LastName` attribute as `private`.
    Through this code, we will try to exclude this attribute from being serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important functions in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetObjectData`: As illustrated previously, this function is called when the
    class gets serialized. In this method, we will serialize the data present in `Firstname`,
    `Feedback`, and `ID`. Note that `LastName` is not present in this. This has been
    to make sure that the data in the `LastName` attribute will not be added to the
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constructor: As the class implements the `ISerializable` interface, it must
    implement the following constructor with the parameters of `SerializationInfo`
    and `StreamingContext`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor will be called when the data will be deserialized into this
    class object. Note that in the constructor, we are accessing the values in the
    `Value1`, `Value2`, and `Value3` attributes and converting them into their respective
    mapped attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we debug this code and do a QuickWatch on the `studeseria` variable, we
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53957262-df4b-48c2-935f-bc7769ec72f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that no value is present in the `LastName` attribute. In the next section,
    we will learn how to work with collections.
  prefs: []
  type: TYPE_NORMAL
- en: Working with collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection in .NET defines a group of related data or elements. Elements
    can be variables of simple data types such as `int`, `float`, or `String` or can
    be complex data variables such as a class or structure. While working with .NET
    applications, we often need to work with such collections. We can execute operations
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an element to a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading elements present in the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing elements present in the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will understand what the different types of collections
    available in .NET are and how programmers can execute operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are the most basic collection variable available in .NET Framework. Arrays
    are used to store a group of data variables that are of the same type as `int`,
    `String`, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a code implementation in which we will create an array collection
    of `int` variables and then loop through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the following in the code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: An array is declared by the `[]` syntax after the data type. In the implemented
    code, we are declaring an array of the `int` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While declaring the array collection, we must define the length of the array
    collection. In the code, we are declaring that the length of the array is `10`.
    This basically implies that the array can contain `10` elements of the `int` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of the array starts at `0`. This implies that, in the preceding case,
    the first element will start at index `0` and will end at index `9`. If we need
    to refer to the elements present in the *i*^(th) index in the array, we can use
    the `array[i]` declaration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each array has a `length` property. This attribute indicates the maximum number
    of elements that can be present in the array. In the code, we are doing a `for`
    loop from `0` to `9` that is of the length -1 and are setting the value in each
    element present in that index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array implements the `IEnumerable` interface. Due to this, we can loop through
    the array using the `foreach` loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On executing the preceding code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0148d3f5-1152-48e0-bb87-10343f743202.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code, we are setting values in each index of the array—the same value
    as the index in itself. Before we move ahead and start looking at the code examples,
    we need to understand two important concepts regarding arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multidimensional arrays: These are arrays in which we store elements in a matrix
    structure that has both rows and columns. For example, we can use the following
    code for declaring a multidimensional array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The use of a single `,` mark during the array declaration indicates that this
    is a two-dimensional array. In the case of a two-dimensional array, the first
    dimension indicates the number of rows, while the second indicates the number
    of columns present in the array. Also, note that by using `3,2`, we are basically
    indicating that the number of rows in the array should be `3` while the number
    of columns should be `2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like in a normal array, in a multidimensional array, the index for both
    dimensions starts at `0`. Therefore, the first element will be present at index
    `{0,0}`, while the last element will be present at index `{2,1}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code implementation, in which we will look at
    the code to loop through this multidimensional array and read each number present
    in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we are doing two nested loops. In the
    first loop, we are looping through the number of rows present in the multidimensional
    array. In the second loop, we are looping through the number of columns present
    in the multidimensional array. Using the `arrayInt[i, j]` syntax, we are printing
    the element present in that combination of rows and columns in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the code, we get the following result. As we have to loop through
    the two-dimensional array using a nested loop, at each step, we will access elements
    present at position `{i, j}`. For each iteration of the `i` variable, the `j`
    variable will iterate from `0` to `1`. Hence, it will start at `{0,0}`, which
    will be `1` and will end at `{2,1}`, which will be `6`, hence generating the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b8b2a58-f2f9-4556-abdc-89d5f3f8a608.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next section, we will look at another collection type: lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working on arrays, we learned that the length of an array must be specified
    when the array is declared. Also, we cannot increase the length of an array collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome these issues, we can use the list collection. Lists provide us
    with several helper methods that help us to add and remove items in a list, sort
    a list, search in a list, and more. A list collection is declared by the following
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go to the definition of a list, we will realize that, internally, it
    implements many interfaces, such as `IEnumerable`, `ICollection`, and `IList`.
    Due to these different interfaces, list collections are extremely powerful and
    provide different operations. The following screenshot shows what the definition
    of a list collection looks like in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4cd2503-b725-4f02-be3d-a7ec811c95ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The `IEnumerable` interface allows us to loop through the list collection using
    the `foreach` loop just as we did for arrays. The `ICollection` interface allows
    us to do operations such as count length, add a new element, and remove an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code implementation, in which we will execute
    all of these operations on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what we did in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a list of `int` and added the elements 1-6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are looping across the list using a `for` loop and we are printing the values
    present in it. To find the length or the number of elements present in a list,
    we are using the `Count` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove an element from a particular index, we can use the `Remove` method.
    In the preceding code implementation, we are removing the element present at index
    `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a new element in the list, we use the `Add` method. In the preceding
    code implementation, we are adding an element, `7`, to the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether an element is present in the list, we use the `Contains` method.
    In the preceding code implementation, we are checking whether a `4` element is
    present in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we execute this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfdb2794-f71c-4f0d-8dc1-a817ecedc97b.png)'
  prefs: []
  type: TYPE_IMG
- en: One potential issue with a list collection is that we can have duplicate values
    in the list. For example, in the preceding example, it's possible to have two
    elements with the same value as `1` in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this issue, we cannot use list collection in scenarios where we must
    ensure the uniqueness of values. In the next section, we will look at another
    collection dictionary that overcomes this issue with a list object.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dictionary collection can be used in scenarios when we need to maintain
    uniqueness in values that are being saved. A dictionary collection is comprised
    of two parts: a key and a value. Together, they are referred to as a key-value
    pair in .NET. When a dictionary collection is created, it ensures that the key-value
    is unique and no duplicate keys are present in the collection. Retrieval is also
    based upon the key, making the operation extremely fast. A dictionary collection
    is declared by the following index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we are declaring a dictionary collection
    where both key and value are of the `int` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s right-click on the `Dictionary` class and click on Go to Definition.
    On doing this, we will be taken to the definition of the dictionary. Upon doing
    so, we will realize that it implements several interfaces such as `IEnumerable`,
    `ICollection<KeyValuePair<Tkey`, and `TValue>>`. Please refer to the following
    definition of the `Dictionary` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59822b04-ebe1-4cdd-9a77-74228a97ce41.png)'
  prefs: []
  type: TYPE_IMG
- en: Due to the implementation of the `ICollection` interface based on `KeyValuePair`,
    it ensures that the uniqueness is maintained based on the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code implementation, we will look at a code example wherein we will
    implement operations on the `Dictionary` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the following in the preceding code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We have declared a dictionary collection variable. We have implemented a `for`
    loop that runs five times. In the loop, we are creating `KeyValuePair` and adding
    it to the dictionary object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we have added elements to the dictionary object, we are looping through
    the dictionary. We are doing it via a `foreach` loop on `KeyValuePair` present
    in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To remove a particular element from the dictionary, we can use the `Remove`
    method. The method takes the input of a key and, based on a key, deletes the respective
    `KeyValuePair` present in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a particular element in the dictionary, we can use the `Add` method.
    The method has two parameters, one of the key and another of the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether a particular key is present in the dictionary, we can use the
    `ContainsKey` method. The method returns whether the given key exists in the dictionary.
    If the key exists, it returns `true` and, in other cases, it returns `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check whether a particular value is present in the dictionary, we can use
    the `ContainsValue` method. The method returns whether the given value exists
    in the dictionary. If the value exists, it returns `true` and, in other cases,
    it returns `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the preceding code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74220baa-fafd-4dc0-90ee-70ceb40fb5dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please note the following points in the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The values (`0`, `0`), (`1`, `100`), (`2`, `200`), (`3`, `300`), and (`4`, `400`)
    indicate the key-value pairs that are added in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5` indicates the length or number of elements present in the dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True` indicates that the dictionary contains `KeyValuePair` with the key `4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`False` indicates that the dictionary does not contain `KeyValuePair` with
    the value `900`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move to the next section, let''s try what would happen if we try
    to add `KeyValuePair` in the same dictionary in which the key already exists in
    the dictionary. For the sake of an example, we will add `KeyValue` of `(1, 1000)`.
    Please note that the key `1` is already present in the dictionary. When the code
    is executed, we get the following exception. The exception indicates that if we
    try to add a value with the same key in the dictionary, it will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/653ba67e-fd25-4f30-8974-769ee8363c12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next section, we will go over another set of collection objects: queues
    and stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Queues and stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues and stacks are collection items that allow us to save data temporarily
    during the execution of the program. These collections are very similar to the
    other collections, such as lists, with the major difference being how elements
    are added and removed from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A queue is a first-in, first-out type of collection. It basically implies that
    elements are accessed from the queue in the same order they are added to the collection.
    When the items are accessed, they can also be removed in the same operation. A
    queue has three main operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new element to the queue: It''s executed by the `Enqueue` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Removing an existing element from the queue: It''s executed by the `Dequeue`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Peeking or retrieving the value of an element in the queue: It''s executed
    by the `Peek` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram shows how the queue works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/074aa130-4fac-489b-b76f-576f5d20cc42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, the block indicates a queue collection. In the collection,
    we have added five elements: element A, element B, element C, element D, and element
    E. Element E was the first element added to the queue and it''s at the front of
    the queue. Element A was the last element added to the queue and it''s at the
    back of the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: The green arrows indicate the indexes in the queue at which the different operations
    will take place. The addition of a new element will always take place at the back
    of the queue. Removal of an element will take place at the front of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a code implementation to show how it''s done programmatically.
    In the following code, we have created a queue collection object. We will then
    add elements to the object and execute different operations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9ee75b7-c05b-4cfb-8c57-eab160abbd18.png)'
  prefs: []
  type: TYPE_IMG
- en: As illustrated by the queue diagram, when we add elements to the queue, they
    are always added to the end. Therefore, when we add the `E`, `D`, `C`, `B`, and
    `A` elements in the same order, `A` will always be at the back of the queue and
    `E` will be at the front of the queue. The indexes in the preceding output indicate
    the position in the queue where each respective element is present.
  prefs: []
  type: TYPE_NORMAL
- en: A peek operation in a queue is always done on the front index, that is, the
    `0` index of the queue. A removal operation in a queue is always done on the front
    index, that is, the `0` index of the queue. Therefore in the preceding output,
    both of these operations are executed on the element `E`.
  prefs: []
  type: TYPE_NORMAL
- en: Once these operations are done and we reiterate through the queue, we find that,
    owing to the remove operation, element `E` is no longer present in the queue.
    Now that we have an understanding of the queue, let's look at how a stack works
    in .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like a queue, the stack also provides temporary storage with the only
    difference being in terms of how the operations are executed on a stack. Stack
    follows the LIFO model, which implies that the last element added to the stack
    will be the first one to be removed. The following are the three main operations
    that we can do on a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new element to the stack. It's executed by the `Push` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an existing element from the stack. It's executed by the `Pop` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peek or retrieve the value of an element in the stack. It's executed by the
    `Peek` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the stack works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ea5d145-ccfe-4b60-bef5-9d088e1f996e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the diagram, the block indicates a stack collection. In the collection,
    we have added five elements: element A, element B, element C, element D, and element
    E. Element E was the first element added to the stack and it''s at the front of
    the stack. Element A was the last element added to the stack and it''s at the
    back of the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: The green arrows indicate the indexes in the stack at which the different operations
    will take place. The addition of a new element will always take place at the bottom
    of the stack. The removal of an element will take place at the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a code implementation to show how it''s done programmatically.
    In the following code, we have created a stack collection object. We will then
    add elements in the object and execute different operations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bc29428-0a7b-4de3-bc97-c6e27d4a908b.png)'
  prefs: []
  type: TYPE_IMG
- en: A `Peek` operation on a stack is always done on the last element added on the
    stack. Element `A` was the last element to be added to the stack. Therefore, when
    a `Peek` operation is done on the stack, it gives an output of `A`. Similarly,
    when a `Pop` operation is executed on the stack, it removes the element `A`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have gone through the different collections that are available
    in .NET. Each of these collection items has some properties that make them usable
    in some scenarios and not in others. These criteria need to be evaluated when
    we are trying to select a collection item to use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some of the criteria that help us to select
    the right collection item for each scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While choosing a collection type, we have to analyze the scenarios in the application
    in which we want to use them. The primary difference between these collection
    types is the way we access elements in them:'
  prefs: []
  type: TYPE_NORMAL
- en: The array collection needs to have a definite size or length while declaring
    itself. On the other hand, all other collection types can have their sizes increased
    dynamically. Also, arrays support random access to the data. This basically implies
    that as long as the element exists at the specified index in the array, we can
    access that element without needing to loop through the entire array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues and stacks allow us access the elements in a definite manner. While the
    queue works in a FIFO manner, the stack works in a LIFO manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, the list and dictionary collection types allow us to configure
    random access to the elements. Please note that, conceptually, the list does not
    support random access; however, in C#, the list is maintained as an array. Due
    to this, it supports random access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important difference between a list and dictionary is the way they save
    data as well as the performance. In the dictionary collection, we save data in
    `KeyValuePair`. This allows us to maintain the uniqueness of the keys that are
    present in the dictionary. On the other hand, a list does not provide us with
    that feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how we serialize and deserialize data while
    exchanging it over a network. We looked at the different techniques available
    for serialization and deserialization. We started with `XmlSerialization` and
    saw how we serialize the data to XML files. We also looked at different attribute
    tags, such as `XmlArray`, `XmlArrayItem`, and `XmlIgnore`, which we can place
    in the class object when it's being converted into an XML file. We then looked
    at binary serialization and learned the advantages it has compared to `XmlSerialization`.
    We also looked at the `ISerializable` interface and learned how it provides security
    while exchanging data over the network.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at different collection types available in C# and the scenarios
    in which we should use each of them. We looked at arrays and their restrictions
    in terms of the length or size of the array, which we must declare during the
    declaration of the array. We then looked at some other complex collection types,
    such as list and dictionary. Both of these collection items allow us to increase
    the collection size during execution but differ in the way they access data. A
    dictionary saves the data in `KeyValuePair` and enforces the uniqueness of the
    keys that are present in the collection type.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at queues and stack collection types. As opposed to lists and
    dictionaries, which allow random access to the data, stacks and queues allow us
    to access to data in a particular order. Queues follow the FIFO model, while stacks
    follow the FILO model.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During serialization, `XmlSerialization` automatically includes private attributes
    in the generated XML class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In `XmlSerialization`, the `XmlIgnore` tag can be used to exclude any attribute
    that we don't want to include in the generated XML class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In binary serialization, private marked attributes are not serialized.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `ISerializable` interface, we can select the attributes and their
    tags that we want to be present in serialization.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can increase the size of an array collection type during program execution.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Queues follow the LIFO model for accessing elements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A dictionary saves data in `KeyValuePair`, ensuring the uniqueness of key-value
    pairs present in the collection item.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both a list and dictionary allow random access to the data elements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are working with a large group of `student` objects. You need to remove
    all duplicates and then group them by `studentid`. Which collections should we
    use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Queue
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**b and d**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**c and d**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**c**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
