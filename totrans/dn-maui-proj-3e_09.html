<html><head></head><body>
<div id="_idContainer165">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor854"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor855"/><span class="koboSpan" id="kobo.2.1">Setting Up a Backend for a Game Using Azure Services</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will set up a backend for a game app with real-time communication. </span><span class="koboSpan" id="kobo.3.2">We will not only create a backend that can scale up to handle a large number of users but also scale down when the number of users is reduced. </span><span class="koboSpan" id="kobo.3.3">To build that backend, we will use a serverless </span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.4.1">architecture based on services in </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.5.1">Microsoft Azure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understanding the different Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">serverless services</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Creating a </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">SignalR</span></strong><span class="koboSpan" id="kobo.13.1"> service in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Microsoft Azure</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using Azure Functions as an </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">application programming </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.17.1">interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.19.1">API</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">)</span></span></li>
</ul>
<h1 id="_idParaDest-151"><a id="_idTextAnchor856"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">To be able to complete this project, you need to have Visual Studio for Mac or PC installed, as well as the necessary .NET MAUI components. </span><span class="koboSpan" id="kobo.22.2">See </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 1</span></em></span><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Introduction to .NET MAUI</span></em><span class="koboSpan" id="kobo.26.1">, for more details on how to set up </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">your environment.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">You also need an Azure account. </span><span class="koboSpan" id="kobo.28.2">If you have a Visual Studio subscription, there are a specific amount of Azure credits included each month. </span><span class="koboSpan" id="kobo.28.3">To activate your Azure benefits, go </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to </span></span><a href="https://my.visualstudio.com"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://my.visualstudio.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You can also create a free account, where you can use selected services for free over 12 months. </span><span class="koboSpan" id="kobo.32.2">You will get $200 worth of credit to explore any Azure service for 30 days, and you can also use the free services at any time. </span><span class="koboSpan" id="kobo.32.3">Read more </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">at </span></span><a href="https://azure.microsoft.com/en-us/free/"><span class="No-Break"><span class="koboSpan" id="kobo.34.1">https://azure.microsoft.com/en-us/free/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">If you do not have and do not want to sign up for a free Azure account, you can use local development tools to run the services </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">without Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">You can find the full source for the code in this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">at </span></span><a href="https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor857"/><span class="koboSpan" id="kobo.42.1">Project overview</span></h1>
<p><span class="koboSpan" id="kobo.43.1">The main aim of this project will be to set up the backend for a game. </span><span class="koboSpan" id="kobo.43.2">A large part of the project will be the configuration that we will carry out in the Azure portal. </span><span class="koboSpan" id="kobo.43.3">We will also write some code for the Azure functions that will handle the SignalR connections and a bit of the game logic and state. </span><span class="koboSpan" id="kobo.43.4">SignalR is a library that makes real-time communication in applications easier. </span><span class="koboSpan" id="kobo.43.5">Azure SignalR is a service that makes it easier to connect multiple clients to send messages via the SignalR library. </span><span class="koboSpan" id="kobo.43.6">SignalR is described in more detail later. </span><span class="koboSpan" id="kobo.43.7">There will be functions to return information about the SignalR connection, manage matching players to play against each other, and post the result of each player’s turn to the SignalR service. </span></p>
<p><span class="koboSpan" id="kobo.44.1">The following diagram shows an overview of the architecture of </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">this application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.46.1"><img alt="" role="presentation" src="image/B19214_09_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.47.1">Figure 9.1 – Application architecture</span></p>
<p><span class="koboSpan" id="kobo.48.1">The estimated time to complete this part of the project is about </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">2 hours.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor858"/><span class="koboSpan" id="kobo.50.1">An overview of the game</span></h2>
<p><em class="italic"><span class="koboSpan" id="kobo.51.1">Sticks &amp; Stones</span></em><span class="koboSpan" id="kobo.52.1"> is a turn-based social game based on the concepts of two childhood games mashed into one, Dots and Boxes and Tic-Tac-Toe. </span><span class="koboSpan" id="kobo.52.2">The game board is laid out in a 9x9 grid. </span><span class="koboSpan" id="kobo.52.3">Each player will take a turn placing a stick along the side of a box, earning one point. </span><span class="koboSpan" id="kobo.52.4">If a stick </span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.53.1">completes a box, then the player takes ownership of the box, earning five points. </span><span class="koboSpan" id="kobo.53.2">The game is won when a player owns three boxes in a row, horizontally, vertically, or diagonally. </span><span class="koboSpan" id="kobo.53.3">If no player can own three boxes in a row, the winner of the game is determined by the player with the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">highest score.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">To keep the app and the service side relatively simple, we will eliminate a lot of state management. </span><span class="koboSpan" id="kobo.55.2">When the player opens the app, they will have to connect to the game service. </span><span class="koboSpan" id="kobo.55.3">They will have to provide a gamer tag or username and an email address. </span><span class="koboSpan" id="kobo.55.4">Optionally, they can upload a picture of themselves to use as a </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">profile picture.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Once connected, the player will see a list of all the other players connected to the same game service; this is called the lobby. </span><span class="koboSpan" id="kobo.57.2">The player’s status, either “Ready to play” or “In a match,” will be displayed along with the player’s gamer tag and profile picture. </span><span class="koboSpan" id="kobo.57.3">If the player is not in a match, then there will also be a button to challenge the player to </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">a match.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Challenging a player to a match will cause the app to prompt the opponent to respond to the challenge, either accept or decline. </span><span class="koboSpan" id="kobo.59.2">If the opponent accepts the challenge, then both players are navigated to a new game board where the player who received the challenge will have the first turn. </span><span class="koboSpan" id="kobo.59.3">Both players’ statuses will update to “In a match” in all the other players’ lobbies. </span><span class="koboSpan" id="kobo.59.4">Play will alternate between players as they choose a location to place a single stick. </span><span class="koboSpan" id="kobo.59.5">Each time a stick is placed by a player, the game board and score will update on both players’ devices. </span><span class="koboSpan" id="kobo.59.6">When a stick is placed that completes one or more squares, the player then “owns” that square, and a pile of stones is placed in the center of the square. </span><span class="koboSpan" id="kobo.59.7">When all </span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.60.1">sticks have been placed, or a player owns three stones in a row, the game is over, the players navigate back to the lobby, and their status is updated to “Ready </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">to play.”</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">If a player leaves the app during a game, then they will have forfeited the game and the remaining opponent will be credited with the win and navigated back to </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">the lobby.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">The following screenshot should give you an idea of what the app will look like when it’s completed in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.65.1">Chapter 10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.67.1"><img alt="Figure 9.2 – The main game screens" src="image/B19214_09_2_Merged.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.68.1">Figure 9.2 – The main game screens</span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor859"/><span class="koboSpan" id="kobo.69.1">Understanding the different Azure serverless services</span></h1>
<p><span class="koboSpan" id="kobo.70.1">Before we start to build a backend with a serverless architecture, we need to define what </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">serverless</span></strong><span class="koboSpan" id="kobo.72.1"> means. </span><span class="koboSpan" id="kobo.72.2">In a serverless architecture, the code will run on a server, but we don’t need </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.73.1">to worry about that; the only thing we need to focus on is building our software. </span><span class="koboSpan" id="kobo.73.2">We let someone else handle everything to do with servers. </span><span class="koboSpan" id="kobo.73.3">We don’t need to think about how much memory or </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">central processing units</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">CPUs</span></strong><span class="koboSpan" id="kobo.77.1">) the server needs, or even how many servers we need. </span><span class="koboSpan" id="kobo.77.2">When we use services in Azure, Microsoft takes care of this </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">for us.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor860"/><span class="koboSpan" id="kobo.79.1">Azure SignalR Service</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.80.1">Azure SignalR Service</span></strong><span class="koboSpan" id="kobo.81.1"> is a service in </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">Microsoft Azure</span></strong><span class="koboSpan" id="kobo.83.1"> for real-time communication between a </span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.84.1">server and clients. </span><span class="koboSpan" id="kobo.84.2">The service will push content to the clients without them having to poll the server to get content updates. </span><span class="koboSpan" id="kobo.84.3">SignalR can </span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.85.1">be used for multiple types of applications, including mobile applications, web applications, and </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">desktop applications.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">SignalR will use </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">WebSockets</span></strong><span class="koboSpan" id="kobo.89.1"> if that </span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.90.1">option is available. </span><span class="koboSpan" id="kobo.90.2">If it is not, SignalR </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.91.1">will use other techniques for communication, such as </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Server-Sent Events</span></strong><span class="koboSpan" id="kobo.93.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.94.1">SSEs</span></strong><span class="koboSpan" id="kobo.95.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">long polling</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">SignalR will detect which transport technology </span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.98.1">is available and use it without the developer having to think about it </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">SignalR can </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.101.1">be used in the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following examples:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Chat applications</span></strong><span class="koboSpan" id="kobo.104.1">: Where the application requires updates from the server as soon as new messages </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">are available</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Collaborative applications</span></strong><span class="koboSpan" id="kobo.107.1">: For example, meeting applications or when users on multiple devices are working with the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">same document</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.109.1">Multiplayer games</span></strong><span class="koboSpan" id="kobo.110.1">: Where all users need live updates about </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">other users</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Dashboard applications</span></strong><span class="koboSpan" id="kobo.113.1">: Where users need </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">live updates</span></span></li>
</ul>
<h2 id="_idParaDest-156"><a id="_idTextAnchor861"/><span class="koboSpan" id="kobo.115.1">Azure Functions</span></h2>
<p><span class="koboSpan" id="kobo.116.1">Azure Functions is a Microsoft Azure service that allows us to run code in a serverless way. </span><span class="koboSpan" id="kobo.116.2">We will deploy </span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.117.1">small pieces of </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.118.1">code called </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">functions</span></strong><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">Functions are deployed </span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.121.1">in groups, called </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">function apps</span></strong><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">When we are creating a function app, we need to select whether we want it to run on a Consumption plan or an App Service plan. </span><span class="koboSpan" id="kobo.123.3">We select a Consumption plan if we want the application to be completely serverless, while with an App Service plan, we have to specify </span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.124.1">the requirements of the server. </span><span class="koboSpan" id="kobo.124.2">With a Consumption plan, we pay for the execution time and for how much memory the function uses. </span><span class="koboSpan" id="kobo.124.3">One benefit of an App Service plan is that you can configure it to be </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Always-On</span></strong><span class="koboSpan" id="kobo.126.1">, and you won’t have any cold starts, so long as you don’t have to scale up to more instances. </span><span class="koboSpan" id="kobo.126.2">The big benefit of a Consumption plan is that it will always scale according to which resources are needed at </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">that time.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">There are several ways in which a function can be triggered to run. </span><span class="koboSpan" id="kobo.128.2">Two examples are </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">TimeTrigger</span></strong><span class="koboSpan" id="kobo.132.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.134.1"> will trigger the function to run when an HTTP request is calling the function. </span><span class="koboSpan" id="kobo.134.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">TimeTrigger</span></strong><span class="koboSpan" id="kobo.136.1">, functions will run at an interval that we specify. </span><span class="koboSpan" id="kobo.136.2">There are also triggers for other Azure services. </span><span class="koboSpan" id="kobo.136.3">For example, we can configure a function to run when a file is uploaded to Azure Blob storage, when a new message is posted to an event hub or service bus, or when data is changed in an Azure Cosmos </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">DB service.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">Now that we understand what features Azure SignalR Service and Functions offer, let’s use them to build our </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">game backend.</span></span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor862"/><span class="koboSpan" id="kobo.140.1">Building the serverless backend</span></h1>
<p><span class="koboSpan" id="kobo.141.1">In this section, we will </span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.142.1">set up the backend based on the services described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">preceding section.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor863"/><span class="koboSpan" id="kobo.144.1">Creating a SignalR service</span></h2>
<p><span class="koboSpan" id="kobo.145.1">The first </span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.146.1">service that we will set up is the one for SignalR. </span><span class="koboSpan" id="kobo.146.2">To create such a service, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.148.1">Go to the Azure portal </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">at </span></span><a href="https://portal.azure.com"><span class="No-Break"><span class="koboSpan" id="kobo.150.1">https://portal.azure.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.151.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.152.1">Create a </span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.153.1">new resource. </span><span class="koboSpan" id="kobo.153.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.154.1">SignalR Service</span></strong><span class="koboSpan" id="kobo.155.1"> resource is in the </span><strong class="bold"><span class="koboSpan" id="kobo.156.1">Web &amp; </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.157.1">Mobile</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.158.1"> category.</span></span></li>
<li><span class="koboSpan" id="kobo.159.1">Provide a name for the resource in </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">the form.</span></span></li>
<li><span class="koboSpan" id="kobo.161.1">Select the subscription you want to use for </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">this project.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.163.1">We recommend that you create a new </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Resource group</span></strong><span class="koboSpan" id="kobo.165.1"> and use it for all the resources that we will create for this project. </span><span class="koboSpan" id="kobo.165.2">The reason that we want one resource group is that it is easier to track which resources are related to this project, and it is also easier to delete all the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">resources together.</span></span></p></li>
<li><span class="koboSpan" id="kobo.167.1">Select a location that is close to </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">your users.</span></span></li>
<li><span class="koboSpan" id="kobo.169.1">Select a pricing tier. </span><span class="koboSpan" id="kobo.169.2">For this project, we will use the </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Free</span></strong><span class="koboSpan" id="kobo.171.1"> tier. </span><span class="koboSpan" id="kobo.171.2">We can always use the </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Free</span></strong><span class="koboSpan" id="kobo.173.1"> tier for development and later scale up to a tier that can handle </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">more connections.</span></span></li>
<li><span class="koboSpan" id="kobo.175.1">Set </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Service mode</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.177.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.178.1">Serverless</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.180.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.181.1">Review + create</span></strong><span class="koboSpan" id="kobo.182.1"> to review the settings before creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">SignalR service.</span></span></li>
<li><span class="koboSpan" id="kobo.184.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">Create</span></strong><span class="koboSpan" id="kobo.186.1"> to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">storage account.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.188.1">Refer to the following screenshot to view the </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">preceding information:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.190.1"><img alt="Figure 9.3 – Creating the SignalR service" src="image/B19214_09_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">Figure 9.3 – Creating the SignalR service</span></p>
<p><span class="koboSpan" id="kobo.192.1">This is all </span><a id="_idIndexMarker896"/><span class="koboSpan" id="kobo.193.1">we need to do to set up a SignalR service. </span><span class="koboSpan" id="kobo.193.2">We will return to it in the Azure portal later to grab a connection string </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">to it.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">The next step </span><a id="_idIndexMarker897"/><span class="koboSpan" id="kobo.196.1">is to set up a storage account in which we can store the images that are uploaded by </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">the users.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">With the Computer Vision service created, we can now create the Azure Functions service, which will run our game logic and use SignalR, Blob storage, and Cognitive Services, which we </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">just created.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor864"/><span class="koboSpan" id="kobo.200.1">Using Azure Functions as an API</span></h2>
<p><span class="koboSpan" id="kobo.201.1">All the </span><a id="_idIndexMarker898"/><span class="koboSpan" id="kobo.202.1">code we will write for the backend will </span><a id="_idIndexMarker899"/><span class="koboSpan" id="kobo.203.1">be in Azure Functions. </span><span class="koboSpan" id="kobo.203.2">We will use a Visual Studio project to write, debug, and deploy our functions. </span><span class="koboSpan" id="kobo.203.3">Before we create the project, we will have to set up and configure the Azure Functions service. </span><span class="koboSpan" id="kobo.203.4">Then, we will implement the function to connect the player to the game and provide the client with a list of current players. </span><span class="koboSpan" id="kobo.203.5">Next, we will write the functions that allow one player to challenge </span><a id="_idIndexMarker900"/><span class="koboSpan" id="kobo.204.1">another to a game. </span><span class="koboSpan" id="kobo.204.2">Finally, we will </span><a id="_idIndexMarker901"/><span class="koboSpan" id="kobo.205.1">wrap up by writing the function that allows players to take turns placing sticks on </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">the board.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">Let’s begin by creating the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">Functions service.</span></span></p>
<h3><span class="koboSpan" id="kobo.209.1">Creating the Azure Functions service</span></h3>
<p><span class="koboSpan" id="kobo.210.1">Before we </span><a id="_idIndexMarker902"/><span class="koboSpan" id="kobo.211.1">write any code, we will create the function app. </span><span class="koboSpan" id="kobo.211.2">This will contain the functions in the Azure portal. </span><span class="koboSpan" id="kobo.211.3">Proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.213.1">Create a new </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">Function App</span></strong><span class="koboSpan" id="kobo.215.1"> resource. </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">Function App</span></strong><span class="koboSpan" id="kobo.217.1"> can be found under the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.218.1">Compute</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.219.1"> category.</span></span></li>
<li><span class="koboSpan" id="kobo.220.1">Select a subscription for the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">function app.</span></span></li>
<li><span class="koboSpan" id="kobo.222.1">Select a resource group for the function app. </span><span class="koboSpan" id="kobo.222.2">This should be the same as the other resources we have created in </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">this chapter.</span></span></li>
<li><span class="koboSpan" id="kobo.224.1">Give the function app a name. </span><span class="koboSpan" id="kobo.224.2">The name will also be the start of the URL of </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the function.</span></span></li>
<li><span class="koboSpan" id="kobo.226.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.227.1">Code</span></strong><span class="koboSpan" id="kobo.228.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">deployment mechanism.</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.231.1">.NET</span></strong><span class="koboSpan" id="kobo.232.1"> as the runtime stack for </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the functions.</span></span></li>
<li><span class="koboSpan" id="kobo.234.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">.NET 6.0 (Long Term Support)</span></strong><span class="koboSpan" id="kobo.236.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the version.</span></span></li>
<li><span class="koboSpan" id="kobo.238.1">Select a location that is closest to </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">your users.</span></span></li>
<li><span class="koboSpan" id="kobo.240.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.241.1">Windows</span></strong><span class="koboSpan" id="kobo.242.1"> for </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.243.1">Operating System</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">We will use the </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">Consumption</span></strong><span class="koboSpan" id="kobo.247.1"> plan as our </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">Hosting</span></strong><span class="koboSpan" id="kobo.249.1"> plan, so we’ll only pay for what we use. </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Function app</span></strong><span class="koboSpan" id="kobo.251.1"> will scale both up and down according to our requirements – without us having to think about it at all – if we select a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.252.1">Consumption</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.253.1"> plan.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.254.1">Refer to the following screenshot to view the </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">preceding information:</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.256.1"><img alt="Figur﻿e 9.4 – Create Function App – Basics" src="image/B19214_09_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.257.1">Figure 9.4 – Create Function App – Basics</span></p>
<ol>
<li value="11"><span class="koboSpan" id="kobo.258.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">Review + create</span></strong><span class="koboSpan" id="kobo.260.1"> to review the settings before creating the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">function app.</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">Create</span></strong><span class="koboSpan" id="kobo.264.1"> to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">function app.</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.266.1">Creating the projects</span></h3>
<p><span class="koboSpan" id="kobo.267.1">If you want, you can create functions in the Azure portal. </span><span class="koboSpan" id="kobo.267.2">I prefer to use Visual Studio, however, because </span><a id="_idIndexMarker903"/><span class="koboSpan" id="kobo.268.1">the code editing experience is better, and you can use source control. </span><span class="koboSpan" id="kobo.268.2">For this project, we will need to separate projects as part of our solution – an Azure Functions project and a class library for shared code between the functions and the .NET MAUI app that will be built in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.269.1">Chapter 10</span></em></span><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">To create and configure the projects, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.272.1">Create a new project in </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">Visual Studio.</span></span></li>
<li><span class="koboSpan" id="kobo.274.1">Enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">function</span></strong><span class="koboSpan" id="kobo.276.1"> in the search field to find the template for </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Azure Functions.</span></span></li>
<li><span class="koboSpan" id="kobo.278.1">Click the </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Azure Functions</span></strong><span class="koboSpan" id="kobo.280.1"> template to continue, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.282.1"><img alt="Figure 9.5 – Create a new project" src="image/B19214_09_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.283.1">Figure 9.5 – Create a new project</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.284.1">Name the </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">project </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.288.1">Name the </span><a id="_idIndexMarker904"/><span class="koboSpan" id="kobo.289.1">solution </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.291.1">, as illustrated in the following screenshot, and </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.293.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer154">
<span class="koboSpan" id="kobo.295.1"><img alt="Figu﻿re 9.6 – Configure your new project" src="image/B19214_09_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.296.1">Figure 9.6 – Configure your new project</span></p>
<p><span class="koboSpan" id="kobo.297.1">The next step is to create our first function, </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.299.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">.Net 6.0 (Long Term Support)</span></strong><span class="koboSpan" id="kobo.301.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Functions worker</span></strong><span class="koboSpan" id="kobo.303.1"> at the top of the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">dialog box.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">Http trigger</span></strong><span class="koboSpan" id="kobo.307.1"> as the trigger for our </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">first function.</span></span></li>
<li><span class="koboSpan" id="kobo.309.1">Click </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">Create</span></strong><span class="koboSpan" id="kobo.311.1"> to continue; our functions project will </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">be created.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.313.1">Refer to </span><a id="_idIndexMarker905"/><span class="koboSpan" id="kobo.314.1">the following screenshot to view the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">preceding information:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer155">
<span class="koboSpan" id="kobo.316.1"><img alt="Figure 9.7 – Creating a new Azure Functions application – Additional information" src="image/B19214_09_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.317.1">Figure 9.7 – Creating a new Azure Functions application – Additional information</span></p>
<p><span class="koboSpan" id="kobo.318.1">Our first function will return the connection information for the SignalR service. </span><span class="koboSpan" id="kobo.318.2">To do that, we need to connect the function by adding a connection string to the SignalR service, </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.320.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">SignalR Service</span></strong><span class="koboSpan" id="kobo.322.1"> resource in the </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">Azure portal.</span></span></li>
<li><span class="koboSpan" id="kobo.324.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.325.1">Keys</span></strong><span class="koboSpan" id="kobo.326.1"> tab on the left and copy the </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">connection string.</span></span></li>
<li><span class="koboSpan" id="kobo.328.1">Go to the </span><strong class="bold"><span class="koboSpan" id="kobo.329.1">Function App</span></strong><span class="koboSpan" id="kobo.330.1"> resource and add the connection string under </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">Application Settings</span></strong><span class="koboSpan" id="kobo.332.1">. </span><span class="koboSpan" id="kobo.332.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">AzureSignalRConnectionString</span></strong><span class="koboSpan" id="kobo.334.1"> as the name for </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">the setting.</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">Add the </span><a id="_idIndexMarker906"/><span class="koboSpan" id="kobo.337.1">connection string to the </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">Values</span></strong><span class="koboSpan" id="kobo.339.1"> array in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">local.settings.json</span></strong><span class="koboSpan" id="kobo.341.1"> file in the Visual Studio project to be able to run the function locally on the development machine, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">code block:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
{  "IsEncrypted": false,  "Values": {    "AzureWebJobsStorage": "UseDevelopmentStorage=true",    "FUNCTIONS_WORKER_RUNTIME": "dotnet",    "AzureSignalRConnectionString": "</span><strong class="bold"><span class="koboSpan" id="kobo.344.1">{EnterTheConnectingStringHere}</span></strong><span class="koboSpan" id="kobo.345.1">"  }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.346.1">If the file doesn’t exist in your project, create a new file in the root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.348.1"> project, and add the code listed previously with your </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">connection string.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.350.1">Next, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.352.1"> project, we need to reference the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Microsoft.Azure.WebJobs.Extensions.SignalRService</span></strong><span class="koboSpan" id="kobo.354.1"> NuGet package. </span><span class="koboSpan" id="kobo.354.2">This package contains the classes we need to communicate with the SignalR service. </span><span class="koboSpan" id="kobo.354.3">If an error occurs during this and you are not able to install the package, make sure that you have the latest version of all other packages in the project and </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">try again.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">The last change we need to make is to adjust the automatic namespace generation. </span><span class="koboSpan" id="kobo.356.2">By default, the default namespace is the name of the project, which means all types in this project would have a root namespace of </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.358.1">. </span><span class="koboSpan" id="kobo.358.2">We don’t need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">Functions</span></strong><span class="koboSpan" id="kobo.360.1"> part of that, so let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">remove it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.362.1">Right-click the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.364.1"> project in </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.366.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.368.1">Properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.370.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Properties</span></strong><span class="koboSpan" id="kobo.372.1"> window, use the search box at the top to search for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Default namespace</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.375.1">Change the </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">Default namespace</span></strong><span class="koboSpan" id="kobo.377.1"> property value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">$(MSBuildProjectName.Split(".")[0].Replace(" ", "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">_"))</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.381.1">This will split the project name on </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">.</span></strong><span class="koboSpan" id="kobo.383.1">, using only the first part and replacing any spaces </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">with underscores.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.385.1">Now, when we </span><a id="_idIndexMarker907"/><span class="koboSpan" id="kobo.386.1">create a new class, the namespace will start with just </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">SticksAndStones</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">It’s time to create a shared project so that we can reuse code in both the .NET MAUI client and the Azure </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">Functions service.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">The shared code will go into a class library project. </span><span class="koboSpan" id="kobo.390.2">To create the project and reference it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.392.1"> project, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.394.1">Right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">SticksAndStones</span></strong><span class="koboSpan" id="kobo.396.1"> solution node in </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.398.1"> and select </span><strong class="bold"><span class="koboSpan" id="kobo.399.1">Add</span></strong><span class="koboSpan" id="kobo.400.1">, then </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.401.1">New Project</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">Search for </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Class Library</span></strong><span class="koboSpan" id="kobo.405.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">Add a new project</span></strong><span class="koboSpan" id="kobo.407.1"> dialog box, as </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">shown here:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer156">
<span class="koboSpan" id="kobo.409.1"><img alt="Figure 9.8 – Add a new project" src="image/B19214_09_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.410.1">Figure 9.8 – Add a new project</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.411.1">Select </span><a id="_idIndexMarker908"/><span class="koboSpan" id="kobo.412.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">Class Library</span></strong><span class="koboSpan" id="kobo.414.1"> template, then </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.416.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.418.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.419.1">Configure your new project</span></strong><span class="koboSpan" id="kobo.420.1"> dialog box, enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">StickAndStones.Shared</span></strong><span class="koboSpan" id="kobo.422.1"> for the name, as shown in the following screenshot, and </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.424.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer157">
<span class="koboSpan" id="kobo.426.1"><img alt="Figure 9.9 – Configure your new project" src="image/B19214_09_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.427.1">Figure 9.9 – Configure your new project</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.428.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">.NET 6.0 (Long Term Support)</span></strong><span class="koboSpan" id="kobo.430.1"> framework project in the </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Additional information</span></strong><span class="koboSpan" id="kobo.432.1"> dialog, then </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.434.1">Create</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.436.1">Delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">Class1.cs</span></strong><span class="koboSpan" id="kobo.438.1"> file that is created as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">project template.</span></span></li>
<li><span class="koboSpan" id="kobo.440.1">Add a reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.442.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.444.1"> project.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.445.1">As we did </span><a id="_idIndexMarker909"/><span class="koboSpan" id="kobo.446.1">for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.448.1"> project, we will change the default namespace by following </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.450.1">Right-click the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.452.1"> project in </span><strong class="bold"><span class="koboSpan" id="kobo.453.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.454.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.456.1">Properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.458.1">In the </span><strong class="bold"><span class="koboSpan" id="kobo.459.1">Properties</span></strong><span class="koboSpan" id="kobo.460.1"> window, use the search box at the top to search for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">Default namespace</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.463.1">Change the </span><strong class="bold"><span class="koboSpan" id="kobo.464.1">Default namespace</span></strong><span class="koboSpan" id="kobo.465.1"> property value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">$(MSBuildProjectName.Split(".")[0].Replace(" ", "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">_"))</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.469.1">This will </span><a id="_idIndexMarker910"/><span class="koboSpan" id="kobo.470.1">split the project name on </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">.</span></strong><span class="koboSpan" id="kobo.472.1">, using only the first part and replacing any spaces </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">with underscores.</span></span></p></li>
</ol>
<p><span class="koboSpan" id="kobo.474.1">Now, we can write the code for the function that will return the </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">connection information.</span></span></p>
<h3><span class="koboSpan" id="kobo.476.1">Connecting a player to the game</span></h3>
<p><span class="koboSpan" id="kobo.477.1">The first step in the game is to get connected. </span><span class="koboSpan" id="kobo.477.2">Being connected adds you to the list of available </span><a id="_idIndexMarker911"/><span class="koboSpan" id="kobo.478.1">players so that you or other players can then join a game. </span><span class="koboSpan" id="kobo.478.2">As we have done in other projects in this book, first, we will create the models that we need to store or transfer data between the service and the clients. </span><span class="koboSpan" id="kobo.478.3">Then, we will implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">Connect</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.480.1">function itself.</span></span></p>
<h3><span class="koboSpan" id="kobo.481.1">Creating the models</span></h3>
<p><span class="koboSpan" id="kobo.482.1">We will need a few functions for the app in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.483.1">Chapter 10</span></em></span><span class="koboSpan" id="kobo.484.1"> to call during the life cycle of the app. </span><span class="koboSpan" id="kobo.484.2">The first </span><a id="_idIndexMarker912"/><span class="koboSpan" id="kobo.485.1">is to establish a connection with the game services, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Connect</span></strong><span class="koboSpan" id="kobo.487.1">. </span><span class="koboSpan" id="kobo.487.2">Essentially, this tells the service that a new or existing player is active and ready for play. </span><span class="koboSpan" id="kobo.487.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Connect</span></strong><span class="koboSpan" id="kobo.489.1"> function will register the player details and return the connection string to the SignalR hub so that the app can receive messages. </span><span class="koboSpan" id="kobo.489.2">We will need a few models before we can complete the function. </span><span class="koboSpan" id="kobo.489.3">There needs to be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">Player</span></strong><span class="koboSpan" id="kobo.491.1"> model, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">Game</span></strong><span class="koboSpan" id="kobo.493.1"> model, and models to assist with passing data between Azure Functions and the SignalR service to </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">Before we dive into creating the library, we should discuss the naming convention used in this chapter. </span><span class="koboSpan" id="kobo.495.2">Having a convention for how you name things will make it easier to determine how the class is used. </span><span class="koboSpan" id="kobo.495.3">When the app calls any Azure function, if it needs to send any data, it will do so using a class that has a suffix of </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">-Request</span></strong><span class="koboSpan" id="kobo.497.1">, and any Azure function that returns data will do so using a class that ends with </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">-Response</span></strong><span class="koboSpan" id="kobo.499.1">. </span><span class="koboSpan" id="kobo.499.2">For any data that is sent via the SignalR hub, we will use a class that has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">EventArgs</span></strong><span class="koboSpan" id="kobo.501.1"> suffix. </span><span class="koboSpan" id="kobo.501.2">These classes will contain references to our actual models, and just act as a container for the data. </span><span class="koboSpan" id="kobo.501.3">Having these classes in place means that you can modify the data being sent or received without affecting the </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">models themselves.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">Since this is a two-player game, we need to track a little bit of the state so that we know who is online and what matches are in play. </span><span class="koboSpan" id="kobo.503.2">For this project, we will keep the state simple and not involve an actual database, but we will still use Entity Framework to do most of the work </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Now that we have </span><a id="_idIndexMarker913"/><span class="koboSpan" id="kobo.506.1">created and referenced the new project, and we have a naming convention in place, we can start creating the classes we will need. </span><span class="koboSpan" id="kobo.506.2">We will start with the two models, </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Player</span></strong><span class="koboSpan" id="kobo.508.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">Match</span></strong><span class="koboSpan" id="kobo.510.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">Player</span></strong><span class="koboSpan" id="kobo.512.1"> represents each person, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">Game</span></strong><span class="koboSpan" id="kobo.514.1"> is a match between two </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Player instances</span></strong><span class="koboSpan" id="kobo.516.1"> and the state of play. </span><span class="koboSpan" id="kobo.516.2">To create the two models, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.518.1">Create a new folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.520.1"> project </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">Models</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.524.1">Create a new class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Models</span></strong><span class="koboSpan" id="kobo.526.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">Player</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.530.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">public</span></strong><span class="koboSpan" id="kobo.532.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Player</span></strong><span class="koboSpan" id="kobo.534.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Id</span></strong><span class="koboSpan" id="kobo.536.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Guid</span></strong><span class="koboSpan" id="kobo.538.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">Guid.Empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.542.1">Create another </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">public</span></strong><span class="koboSpan" id="kobo.544.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">GamerTag</span></strong><span class="koboSpan" id="kobo.546.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">string</span></strong><span class="koboSpan" id="kobo.548.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">string.Empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.552.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">public</span></strong><span class="koboSpan" id="kobo.554.1"> property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">GameId</span></strong><span class="koboSpan" id="kobo.556.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">Guid</span></strong><span class="koboSpan" id="kobo.558.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">Guid.Empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.562.1">Your </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Player</span></strong><span class="koboSpan" id="kobo.564.1"> class should now resemble the following </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">code block:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
namespace SticksAndStones.Models;public class Player {    public Guid Id { get; set; } = Guid.Empty;    public string GamerTag { get; set; } = string.Empty;    public string EmailAddress { get; set; } = string.Empty;    public Guid MatchId { get; set; } = Guid.Empty;}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.567.1">Our model classes </span><a id="_idIndexMarker914"/><span class="koboSpan" id="kobo.568.1">will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Id</span></strong><span class="koboSpan" id="kobo.570.1"> field as a unique identifier so that we can locate each one individually. </span><span class="koboSpan" id="kobo.570.2">It will be used to locate specific players for messaging and relating </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">Match</span></strong><span class="koboSpan" id="kobo.572.1"> instances to </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">Player</span></strong><span class="koboSpan" id="kobo.574.1"> instances. </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">GamerTag</span></strong><span class="koboSpan" id="kobo.576.1"> will be the display name for the player, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">EmailAddress</span></strong><span class="koboSpan" id="kobo.578.1"> is how we can correlate players if they leave the app and then log back in again. </span><span class="koboSpan" id="kobo.578.2">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">MatchId</span></strong><span class="koboSpan" id="kobo.580.1"> property will track whether the player is actively in </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">a game.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">Now that we have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Player</span></strong><span class="koboSpan" id="kobo.584.1"> class, it’s time to define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1"> class:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.587.1">Create a new class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">Models</span></strong><span class="koboSpan" id="kobo.589.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">public</span></strong><span class="koboSpan" id="kobo.595.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">Game</span></strong><span class="koboSpan" id="kobo.597.1"> class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">Id</span></strong><span class="koboSpan" id="kobo.599.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">Guid</span></strong><span class="koboSpan" id="kobo.601.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Guid.Empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.605.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">public</span></strong><span class="koboSpan" id="kobo.607.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">PlayerOneId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.609.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Guid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">public</span></strong><span class="koboSpan" id="kobo.614.1"> property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">PlayerOneScore</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.616.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.619.1">Create another </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">public</span></strong><span class="koboSpan" id="kobo.621.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">PlayerTwoId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.623.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">Guid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.626.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">public</span></strong><span class="koboSpan" id="kobo.628.1"> property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">PlayerTwoScore</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.630.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">int</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.633.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">public</span></strong><span class="koboSpan" id="kobo.635.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">NextPlayerId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.637.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">Guid</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.640.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">public</span></strong><span class="koboSpan" id="kobo.642.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">Sticks</span></strong><span class="koboSpan" id="kobo.644.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.646.1"> and initialize it to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">new List&lt;int&gt;(24)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.649.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">public</span></strong><span class="koboSpan" id="kobo.651.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">Stones</span></strong><span class="koboSpan" id="kobo.653.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.655.1"> and initialize it to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">new List&lt;int&gt;(9)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.658.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">public</span></strong><span class="koboSpan" id="kobo.660.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">Scores</span></strong><span class="koboSpan" id="kobo.662.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.664.1"> and initialize it to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">new List&lt;int&gt;(2)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.667.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">public</span></strong><span class="koboSpan" id="kobo.669.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">Completed</span></strong><span class="koboSpan" id="kobo.671.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">bool</span></strong><span class="koboSpan" id="kobo.673.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.677.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">public</span></strong><span class="koboSpan" id="kobo.679.1"> property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">WinnerId</span></strong><span class="koboSpan" id="kobo.681.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">Guid</span></strong><span class="koboSpan" id="kobo.683.1"> and initialize it </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">Guid.Empty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.687.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">public</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.689.1">static</span></strong><span class="koboSpan" id="kobo.690.1"> method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">New</span></strong><span class="koboSpan" id="kobo.692.1"> that takes two parameters, both of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Guid</span></strong><span class="koboSpan" id="kobo.694.1"> type, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">challengerId</span></strong><span class="koboSpan" id="kobo.696.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">opponentId</span></strong><span class="koboSpan" id="kobo.698.1">. </span><span class="koboSpan" id="kobo.698.2">The method returns an </span><a id="_idIndexMarker915"/><span class="koboSpan" id="kobo.699.1">object of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">Game</span></strong><span class="koboSpan" id="kobo.701.1"> type. </span><span class="koboSpan" id="kobo.701.2">The method should return a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">Game</span></strong><span class="koboSpan" id="kobo.703.1"> and assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">Id</span></strong><span class="koboSpan" id="kobo.705.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">Guid.NewGuid()</span></strong><span class="koboSpan" id="kobo.707.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">PlayerOneId</span></strong><span class="koboSpan" id="kobo.709.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">NextPlayerId</span></strong><span class="koboSpan" id="kobo.711.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">opponentId</span></strong><span class="koboSpan" id="kobo.713.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">PlayerTwoId</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.715.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">challengerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.718.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">Player</span></strong><span class="koboSpan" id="kobo.720.1"> class should now resemble the following </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">code block:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.722.1">
using System;using System.Collections.Generic;namespace SticksAndStones.Models;public class Match {    public Guid Id { get; set; } = Guid.Empty;    public Guid PlayerOneId { get; set; }    public int PlayerOneScore { get; set; }    public Guid PlayerTwoId { get; set; }    public int PlayerTwoScore { get; set; }    public Guid NextPlayerId { get; set; }    public List&lt;int&gt; Sticks {get; set; } = new(new int[24]);    public List&lt;int&gt; Stones {get; set;} = new(new int[9]);    public List&lt;int&gt; Score = new(new int[2]);    public bool Completed { get; set; } = false;    public Guid WinnerId { get; set; } = Guid.Empty;    public static Game New(Guid challengerId, Guid opponentId)    {        return new()        {            Id = Guid.NewGuid(),            PlayerOne = opponent,            PlayerTwo = challenger,            NextPlayer = opponent         };    }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.723.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">Player</span></strong><span class="koboSpan" id="kobo.725.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">Match</span></strong><span class="koboSpan" id="kobo.727.1"> classes will be used for data storage and data transfer between the client and server. </span><span class="koboSpan" id="kobo.727.2">Before we go any further with creating our models, let’s add the database using </span><a id="_idIndexMarker916"/><span class="koboSpan" id="kobo.728.1">Entity Framework. </span><span class="koboSpan" id="kobo.728.2">Perform the following steps to add a reference to Entity Framework and create the database context so that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">Player</span></strong><span class="koboSpan" id="kobo.730.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">Match</span></strong><span class="koboSpan" id="kobo.732.1"> classes can be stored in an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">InMemory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> database:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.735.1">Add a package reference to </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">Microsoft.EntityFrameworkCore.InMemory</span></strong><span class="koboSpan" id="kobo.737.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.740.1">Create a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">Repository</span></strong><span class="koboSpan" id="kobo.742.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.744.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.745.1">Create a class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">GameDbContext</span></strong><span class="koboSpan" id="kobo.747.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">Repository</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.749.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.750.1">Modify the constructor for the class to set </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">database options:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
public GameDbContext(DbContextOptions&lt;GameDbContext&gt; options) : base(options) { }</span></pre></li> <li><span class="koboSpan" id="kobo.753.1">Add a public </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">Players</span></strong><span class="koboSpan" id="kobo.755.1"> property to store the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">Player</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.757.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.758.1">
public DbSet&lt;Player&gt; Players { get; set; }</span></pre></li> <li><span class="koboSpan" id="kobo.759.1">Add a public </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">Matches</span></strong><span class="koboSpan" id="kobo.761.1"> property to store the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1"> objects:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.764.1">
public DbSet&lt;Match Matches { get; set; }</span></pre></li> <li><span class="koboSpan" id="kobo.765.1">Add an </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.766.1">override to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">OnModelCreating</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.769.1">
protected override void OnModelCreating(ModelBuilder modelBuilder){}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.770.1">This method is where we specify to Entity Framework how to relate our classes together in a </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">relational database.</span></span></p></li> <li><span class="koboSpan" id="kobo.772.1">Start by declaring the identifiers for each class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">OnModelCreating</span></strong><span class="koboSpan" id="kobo.774.1"> method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.776.1">
modelBuilder.Entity&lt;Player&gt;()    .HasKey&lt;Player&gt;(p =&gt; p.Id);modelBuilder.Entity&lt;Match&gt;()    .HasKey&lt;Match&gt;(g =&gt; g.Id);base.OnModelCreating(modelBuilder);</span></pre></li> <li><span class="koboSpan" id="kobo.777.1">Entity Framework does not handle our </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.779.1"> properties properly. </span><span class="koboSpan" id="kobo.779.2">It assumes that since it is a list, they are related instances. </span><span class="koboSpan" id="kobo.779.3">To change the default behavior in Entity Framework, we can use the following </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">highlighted code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.781.1">
modelBuilder.Entity&lt;Game&gt;()    .HasKey(g =&gt; g.Id);</span><strong class="bold"><span class="koboSpan" id="kobo.782.1">modelBuilder.Entity&lt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.783.1">Match</span></strong><strong class="bold"><span class="koboSpan" id="kobo.784.1">&gt;()</span></strong><span class="koboSpan" id="kobo.785.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.786.1">.Property(p =&gt; p.Sticks)</span></strong><span class="koboSpan" id="kobo.787.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.788.1">.HasConversion(    </span></strong><span class="koboSpan" id="kobo.789.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">toDb =&gt; string.Join(",", toDb),    </span></strong><span class="koboSpan" id="kobo.791.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">fromDb =&gt; fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? </span><span class="koboSpan" id="kobo.792.2">new(new int[24]));</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.793.1">modelBuilder.Entity&lt;Match&gt;()</span></strong><span class="koboSpan" id="kobo.794.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.795.1">.Property(p =&gt; p.Stones)</span></strong><span class="koboSpan" id="kobo.796.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">.HasConversion(    </span></strong><span class="koboSpan" id="kobo.798.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.799.1">toDb =&gt; string.Join(",", toDb),    </span></strong><span class="koboSpan" id="kobo.800.1">    </span><strong class="bold"><span class="koboSpan" id="kobo.801.1">fromDb =&gt; fromDb.Split(',', StringSplitOptions.None).Select(int.Parse).ToList() ?? </span><span class="koboSpan" id="kobo.801.2">new(new int[9]));</span></strong><span class="koboSpan" id="kobo.802.1">
base.OnModelCreating(modelBuilder);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.803.1">What each block does is define a conversion for the property. </span><span class="koboSpan" id="kobo.803.2">A conversion has two Lambda expressions – one from the C# object to the database and the other from </span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.804.1">the database to the C# object. </span><span class="koboSpan" id="kobo.804.2">For our </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.806.1"> properties, we want to convert a C# </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.808.1"> into a comma-separated string of integers, and then a comma-separated string of integers </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">List&lt;int&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">toDB</span></strong><span class="koboSpan" id="kobo.813.1"> is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.815.1">, so to convert that into a comma-separated list of numbers, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">String.Join</span></strong><span class="koboSpan" id="kobo.817.1"> function to join each element of the list with </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">,</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.819.1">between them.</span></span></p><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">fromDb</span></strong><span class="koboSpan" id="kobo.821.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">string</span></strong><span class="koboSpan" id="kobo.823.1"> value containing numbers separated by commas. </span><span class="koboSpan" id="kobo.823.2">To convert that into </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.825.1">, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">String.Split</span></strong><span class="koboSpan" id="kobo.827.1"> method to isolate each number, then pass each number into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">Int.Parse</span></strong><span class="koboSpan" id="kobo.829.1"> method to convert the number into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">int</span></strong><span class="koboSpan" id="kobo.831.1"> value. </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">Select</span></strong><span class="koboSpan" id="kobo.833.1"> will produce </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">IEnumberable&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.835.1">; we can </span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.836.1">use the </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">LINQ</span></strong><span class="koboSpan" id="kobo.838.1"> extension, </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">ToList</span></strong><span class="koboSpan" id="kobo.840.1">, to convert that into </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">List&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.842.1">. </span><span class="koboSpan" id="kobo.842.2">If it doesn’t create a list, we can supply a default list of values, just like we did in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">Match</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.844.1">class itself.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.845.1">To initialize Entity Framework to use an in-memory database, we need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">Startup</span></strong><span class="koboSpan" id="kobo.847.1"> method. </span><span class="koboSpan" id="kobo.847.2">To create the method and initialize the database, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.849.1">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Startup</span></strong><span class="koboSpan" id="kobo.851.1"> in the root of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.853.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.854.1">Modify </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.855.1">the class file with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">highlighted code:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.857.1">using Microsoft.Azure.Functions.Extensions.DependencyInjection;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.DependencyInjection;using SticksAndStones.Repository;[assembly: FunctionsStartup(typeof(SticksAndStones.Startup))]</span></strong><span class="koboSpan" id="kobo.858.1">
namespace SticksAndStones;public class Startup </span><strong class="bold"><span class="koboSpan" id="kobo.859.1">: FunctionsStartup </span></strong><span class="koboSpan" id="kobo.860.1">{    </span><strong class="bold"><span class="koboSpan" id="kobo.861.1">public override void Configure(IFunctionsHostBuilder builder)    {        string SqlConnection = Environment.GetEnvironmentVariable("SqlConnectionString");        builder.Services.AddDbContextFactory&lt;GameDbContext&gt;(            options =&gt;            {                options.UseInMemoryDatabase("SticksAndStones");            });    }</span></strong><span class="koboSpan" id="kobo.862.1">}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.863.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">Startup</span></strong><span class="koboSpan" id="kobo.865.1"> method will now be called when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.867.1"> project is loaded at runtime. </span><span class="koboSpan" id="kobo.867.2">It will then create a factory for creating instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">GameDbContext</span></strong><span class="koboSpan" id="kobo.869.1"> class we created previously and initialize it with an </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">in-memory database.</span></span></p>
<p><span class="koboSpan" id="kobo.871.1">That concludes </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.872.1">our setup for Entity Framework and our basic models, </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">Player</span></strong><span class="koboSpan" id="kobo.874.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">Game</span></strong><span class="koboSpan" id="kobo.876.1">. </span><span class="koboSpan" id="kobo.876.2">There is one final model that we need to send the SignalR connection information to the client. </span><span class="koboSpan" id="kobo.876.3">To create this model, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.878.1">Create a new class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">Models</span></strong><span class="koboSpan" id="kobo.880.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">ConnectionInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.884.1">Add a public property </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">Url</span></strong><span class="koboSpan" id="kobo.886.1"> that is a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.888.1"> value.</span></span></li>
<li><span class="koboSpan" id="kobo.889.1">Add another public property named </span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">AccessToken</span></strong><span class="koboSpan" id="kobo.891.1"> that is also a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.893.1"> value.</span></span></li>
<li><span class="koboSpan" id="kobo.894.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">ConnectionInfo</span></strong><span class="koboSpan" id="kobo.896.1"> class should look </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.898.1">
namespace SticksAndStones.Models;public class ConnectionInfo {    public string Url { get; set; }    public string AccessToken { get; set; }}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.899.1">With the models now created, we can start creating the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">Connect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.901.1"> function.</span></span></p>
<h4><span class="koboSpan" id="kobo.902.1">Creating the Connect function</span></h4>
<p><span class="koboSpan" id="kobo.903.1">We will start with a function to connect our player to the game, aptly named </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">Connect</span></strong><span class="koboSpan" id="kobo.905.1">. </span><span class="koboSpan" id="kobo.905.2">This function </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.906.1">will expect a partially filled </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Player</span></strong><span class="koboSpan" id="kobo.908.1"> object to be sent in the request body. </span><span class="koboSpan" id="kobo.908.2">The function will return a fully populated </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Player</span></strong><span class="koboSpan" id="kobo.910.1"> object, a list of the currently connected players, and the connection information needed by the client to connect to the SignalR hub. </span><span class="koboSpan" id="kobo.910.2">To make the inputs and outputs cleaner, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">wrap them.</span></span></p>
<p><span class="koboSpan" id="kobo.912.1">To create the input and output classes, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.914.1">Create a new class in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">Messages</span></strong><span class="koboSpan" id="kobo.916.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">ConnectMessages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.920.1">Modify </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">ConnectMessages.cs</span></strong><span class="koboSpan" id="kobo.922.1"> so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.924.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct ConnectRequest(Player Player);public record struct ConnectResponse(Player Player, List&lt;Player&gt; Players, ConnectionInfo ConnectionInfo);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.925.1">For all the classes that will be used to transfer data between the client and Azure Functions or </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.926.1">the SignalR service, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">record</span></strong><span class="koboSpan" id="kobo.928.1"> syntax. </span><span class="koboSpan" id="kobo.928.2">Since these classes will not have any real functionality, their sole purpose is to contain our models. </span><span class="koboSpan" id="kobo.928.3">By using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">record</span></strong><span class="koboSpan" id="kobo.930.1"> struct, we also improve the memory usage of our functions since a new instance would be created in local memory and not global memory, which requires additional handling. </span><span class="koboSpan" id="kobo.930.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">record</span></strong><span class="koboSpan" id="kobo.932.1"> syntax combines the constructor and property declarations into a single line of code, eliminating a lot of boilerplate code that adds no </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">real benefit.</span></span></p>
<p><span class="koboSpan" id="kobo.934.1">You will notice that we are using the conventions we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.935.1">Creating the models</span></em><span class="koboSpan" id="kobo.936.1"> section. </span><span class="koboSpan" id="kobo.936.2">Classes that have a suffix of </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Request</span></strong><span class="koboSpan" id="kobo.938.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">Response</span></strong><span class="koboSpan" id="kobo.940.1"> are used as input and output for any Azure function. </span><span class="koboSpan" id="kobo.940.2">For any data that is sent via the SignalR service, the class will use a suffix </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">EventArgs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.944.1">When a new client is connecting, a message will be sent to other users via the SignalR service to indicate that they have connected. </span><span class="koboSpan" id="kobo.944.2">This message will also be used to notify when players start or end a game. </span><span class="koboSpan" id="kobo.944.3">To create such a message, proceed </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.946.1">Create a new class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">PlayerUpdatedEventArgs</span></strong><span class="koboSpan" id="kobo.948.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">Messages</span></strong><span class="koboSpan" id="kobo.950.1"> folder of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">SticksAndStones.Shared</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.953.1">Modify the class so that it’s a </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">record</span></strong><span class="koboSpan" id="kobo.955.1"> struct with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">Player</span></strong><span class="koboSpan" id="kobo.957.1"> parameter, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.959.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct PlayerUpdatedEventArgs(Player Player);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.960.1">Now that </span><a id="_idIndexMarker924"/><span class="koboSpan" id="kobo.961.1">we have created the structures needed for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">Connect</span></strong><span class="koboSpan" id="kobo.963.1"> function, we can start writing the </span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">function itself:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.965.1">Create a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">Hubs</span></strong><span class="koboSpan" id="kobo.967.1">. </span><span class="koboSpan" id="kobo.967.2">We will put our service class into </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">this folder.</span></span></li>
<li><span class="koboSpan" id="kobo.969.1">Move the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">Function1.cs</span></strong><span class="koboSpan" id="kobo.971.1"> file into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">Hubs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.974.1">Respond </span><strong class="bold"><span class="koboSpan" id="kobo.975.1">Yes</span></strong><span class="koboSpan" id="kobo.976.1"> to the next two prompts for moving the file and adjusting </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">the namespace.</span></span></li>
<li><span class="koboSpan" id="kobo.978.1">Rename the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">Function1.cs</span></strong><span class="koboSpan" id="kobo.980.1"> file </span><strong class="source-inline"><span class="koboSpan" id="kobo.981.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.982.1"> and click </span><strong class="bold"><span class="koboSpan" id="kobo.983.1">Yes</span></strong><span class="koboSpan" id="kobo.984.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">rename prompt.</span></span></li>
<li><span class="koboSpan" id="kobo.986.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.988.1"> file and rename the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">GameHub</span></strong><span class="koboSpan" id="kobo.990.1">, replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">internal static</span></strong><span class="koboSpan" id="kobo.992.1"> access modifiers and replace them with </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">public</span></strong><span class="koboSpan" id="kobo.994.1">, and derive it from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">ServerlessHub</span></strong><span class="koboSpan" id="kobo.996.1"> base class, as </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">highlighted here:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.998.1">public </span></strong><span class="koboSpan" id="kobo.999.1">class GameHub </span><strong class="bold"><span class="koboSpan" id="kobo.1000.1">: ServerlessHub</span></strong><span class="koboSpan" id="kobo.1001.1">
{    [FunctionName("Function1")]    public static async Task&lt;IActionResult&gt; Run(    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,    ILogger log)    {        log.LogInformation("C# HTTP trigger function processed a request.");        string name = req.Query["name"];        string requestBody = await new StreamReader(req.Body).ReadToEndAsync();        dynamic data = JsonConvert.DeserializeObject(requestBody);        name = name ?? </span><span class="koboSpan" id="kobo.1001.2">data?.name;        string responseMessage = string.IsNullOrEmpty(name)        ? </span><span class="koboSpan" id="kobo.1001.3">"This HTTP triggered function executed successfully. </span><span class="koboSpan" id="kobo.1001.4">Pass a name in the query string or in the request body for a personalized response."                : $"Hello, {name}. </span><span class="koboSpan" id="kobo.1001.5">This HTTP triggered function executed successfully.";        return new OkObjectResult(responseMessage);    }}</span></pre></li> <li><span class="koboSpan" id="kobo.1002.1">Rename the </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.1003.1">default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1004.1">Function1</span></strong><span class="koboSpan" id="kobo.1005.1"> function </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">Connect</span></strong><span class="koboSpan" id="kobo.1007.1">, removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">static</span></strong><span class="koboSpan" id="kobo.1009.1"> modifier as well. </span><span class="koboSpan" id="kobo.1009.2">The method signature should look like the following highlighted </span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">code snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1011.1">
[FunctionName("</span><strong class="bold"><span class="koboSpan" id="kobo.1012.1">Connect</span></strong><span class="koboSpan" id="kobo.1013.1">")]</span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">public async</span></strong><span class="koboSpan" id="kobo.1015.1"> Task&lt;IActionResult&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1016.1">Connect</span></strong><span class="koboSpan" id="kobo.1017.1">( [HttpTrigger(AuthorizationLevel.Function, </span><strong class="bold"><span class="koboSpan" id="kobo.1018.1">"post", Route = null)]</span></strong><span class="koboSpan" id="kobo.1019.1"> HttpRequest req,    ILogger log)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1020.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.1022.1"> attribute indicates that this function is called by using the HTTP protocol and not by some other means, such as a SignalR message or a timer. </span><span class="koboSpan" id="kobo.1022.2">The function is only called using the HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">POST</span></strong><span class="koboSpan" id="kobo.1024.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">not </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.1028.1">To send a message </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.1029.1">to all clients connected to the SignalR hub, we will need another SignalR binding. </span><span class="koboSpan" id="kobo.1029.2">This time, it is an </span><strong class="bold"><span class="koboSpan" id="kobo.1030.1">output binding</span></strong><span class="koboSpan" id="kobo.1031.1">. </span><span class="koboSpan" id="kobo.1031.2">The output binding is decorated with a SignalR attribute with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">HubName</span></strong><span class="koboSpan" id="kobo.1033.1"> and is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">IAsyncCollector&lt;SignalRMessage&gt;</span></strong><span class="koboSpan" id="kobo.1035.1"> type, </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1037.1">
[HttpTrigger(AuthorizationLevel.Anonymous, "post", Route = null)] HttpRequest req,[SignalRConnectionInfo(HubName = "GameHub")] SignalRConnectionInfo connectionInfo,</span><strong class="bold"><span class="koboSpan" id="kobo.1038.1">[SignalR(HubName = "GameHub")] IAsyncCollector&lt;SignalRMessage&gt; signalRMessages,</span></strong><span class="koboSpan" id="kobo.1039.1">ILogger log)</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1040.1">Remove the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">Connect</span></strong><span class="koboSpan" id="kobo.1042.1"> method and proceed as follows to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">the function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1044.1">Logging is important in Azure Functions as it helps when debugging in production environments. </span><span class="koboSpan" id="kobo.1044.2">So, let’s add a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">log</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1"> message:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1047.1">
log.LogInformation("A new client is requesting connection");</span></pre></li> <li><span class="koboSpan" id="kobo.1048.1">The client, a .NET MAUI app, will send </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">ConnectRequest</span></strong><span class="koboSpan" id="kobo.1050.1"> in the body of the HTTP request </span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.1051.1">as JSON. </span><span class="koboSpan" id="kobo.1051.2">To get an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">ConnectRequest</span></strong><span class="koboSpan" id="kobo.1053.1"> from the request body, use the following lines </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">of code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1055.1">
var result = await JsonSerializer.DeserializeAsync&lt;ConnectRequest&gt;(req.Body, jsonOptions);var newPlayer = result.Player;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1056.1">You will have to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">using System.Text.Json</span></strong><span class="koboSpan" id="kobo.1058.1"> to the namespace declarations as well. </span><span class="koboSpan" id="kobo.1058.2">This uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">System.Text.Json.JsonSerializer</span></strong><span class="koboSpan" id="kobo.1060.1"> class to read the contents of the request body and create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">ConnectRequest</span></strong><span class="koboSpan" id="kobo.1062.1"> object from it. </span><span class="koboSpan" id="kobo.1062.2">It uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">jsonOptions</span></strong><span class="koboSpan" id="kobo.1064.1"> to properly deserialize </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">the object.</span></span></p></li> <li><span class="koboSpan" id="kobo.1066.1">Now, we need to define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">jsonOptions</span></strong><span class="koboSpan" id="kobo.1068.1"> field. </span><span class="koboSpan" id="kobo.1068.2">Add the following line of code above the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">Connect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1071.1">
internal class GameHub : ServerlessHub {</span><strong class="bold"><span class="koboSpan" id="kobo.1072.1">    private readonly JsonSerializerOptions jsonOptions = new(JsonSerializerDefaults.Web);</span></strong><span class="koboSpan" id="kobo.1073.1">
    [FunctionName("Connect")]    public async Task&lt;IActionResult&gt; Connect(</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">JsonSerializerDefaults.Web</span></strong><span class="koboSpan" id="kobo.1075.1"> ensures that the JSON is formatted properly so that Azure Functions and the SignalR service will properly serialize and deserialize the objects. </span><span class="koboSpan" id="kobo.1075.2">Mainly, it will enforce </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">the following:</span></span></p><ul><li><span class="koboSpan" id="kobo.1077.1">Property names </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">are case-insensitive</span></span></li><li><span class="koboSpan" id="kobo.1079.1">All property and object names will be formatted </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">as camelCase</span></span></li><li><span class="koboSpan" id="kobo.1081.1">Numbers can </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">be quoted</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.1083.1">If we receive </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.1084.1">bad player data, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.1086.1"> to the client, </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1088.1">
if (newPlayer is null){    var error = new ArgumentException("No player data.", "Player");    log.LogError(error, "Failure to deserialize arguments");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.GamerTag)){    var error = new ArgumentException("A GamerTag is required for all players.", "GamerTag");    log.LogError(error, "Invalid value for GamerTag");    return new BadRequestObjectResult(error);}if (string.IsNullOrEmpty(newPlayer.EmailAddress)){    var error = new ArgumentException("An Email Address is required for all players.", "EmailAddress");    log.LogError(error, "Invalid value for EmailAddress");    return new BadRequestObjectResult(error);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1089.1">Since the return type of the function is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">IActionResult</span></strong><span class="koboSpan" id="kobo.1091.1">, we can’t simply return our custom objects. </span><span class="koboSpan" id="kobo.1091.2">Instead, we need to create an object that derives or implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">IActionResult</span></strong><span class="koboSpan" id="kobo.1093.1"> and pass in our result. </span><span class="koboSpan" id="kobo.1093.2">In the case of errors, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">BadRequestObjectResult</span></strong><span class="koboSpan" id="kobo.1095.1">, which will accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">Exception</span></strong><span class="koboSpan" id="kobo.1097.1"> as a parameter in the constructor. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">BadRequestObjectResult</span></strong><span class="koboSpan" id="kobo.1099.1"> will set the HTTP status code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">400</span></strong><span class="koboSpan" id="kobo.1101.1">, indicating an error. </span><span class="koboSpan" id="kobo.1101.2">This status code can then be checked by the client to know whether the request succeeded or not before parsing the body of </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">the response.</span></span></p></li> <li><span class="koboSpan" id="kobo.1103.1">The next </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.1104.1">couple of steps will require us to query the database, so we need to add the database context factory to the class. </span><span class="koboSpan" id="kobo.1104.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Microsoft.EntityFrameworkCore</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1106.1">namespace declaration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1107.1">
using Microsoft.Azure.WebJobs.Extensions.SignalRService;</span><strong class="bold"><span class="koboSpan" id="kobo.1108.1">using Microsoft.EntityFrameworkCore;</span></strong><span class="koboSpan" id="kobo.1109.1">using Microsoft.Extensions.Logging;</span></pre></li> <li><span class="koboSpan" id="kobo.1110.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">private</span></strong><span class="koboSpan" id="kobo.1112.1"> field to store the context factory and a constructor with an argument that will be fulfilled by dependency injection, </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1114.1">
private readonly JsonSerializerOptions jsonOptions = new JsonSerializerOptions(JsonSerializerDefaults.Web);</span><strong class="bold"><span class="koboSpan" id="kobo.1115.1">
private readonly IDbContextFactory &lt;GameDbContext&gt; dbContextFactory;public GameHub(IDbContextFactory&lt;GameDbContext&gt; dbcontext){    contextFactory = dbContextFactory;}</span></strong><span class="koboSpan" id="kobo.1116.1">
[FunctionName("Connect")]public async Task&lt;IActionResult&gt; Connect(</span></pre></li> <li><span class="koboSpan" id="kobo.1117.1">Add a namespace declaration for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">System.Linq</span></strong><span class="koboSpan" id="kobo.1119.1"> to allow the use of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1120.1">Linq</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1"> queries:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1122.1">
using System;</span><strong class="bold"><span class="koboSpan" id="kobo.1123.1">using System.Linq;</span></strong><span class="koboSpan" id="kobo.1124.1">using System.Text.Json;</span></pre></li> <li><span class="koboSpan" id="kobo.1125.1">Now that we </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.1126.1">can access the database context and have determined that the input is valid, we need to make sure that the data is unique, so we will look for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">GamerTag</span></strong><span class="koboSpan" id="kobo.1128.1"> in the database to ensure it isn’t in use already by another player, </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1130.1">
using var context = contextFactory.CreateDbContext();log.LogInformation("Checking for GameTag usage");var gamerTagInUse = (from p in context.Players                      where string.Equals(p.GamerTag, newPlayer.GamerTag, StringComparison.InvariantCultureIgnoreCase)                     &amp;&amp; !string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase)                     select p).Any();if (gamerTagInUse){    var error = new ArgumentException($"The GamerTag {newPlayer.GamerTag} is in use, please choose another.", "GamerTag");    log.LogError(error, "GamerTag in use.");    return new BadRequestObjectResult(error);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1131.1">The first step is to get a new database context from the factory. </span><span class="koboSpan" id="kobo.1131.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.1132.1">Linq</span></strong><span class="koboSpan" id="kobo.1133.1"> query is simple in this case – it uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">Players</span></strong><span class="koboSpan" id="kobo.1135.1"> list from the database context to compare </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">GamerTag</span></strong><span class="koboSpan" id="kobo.1137.1"> value to other GamerTagsvalues. </span><span class="koboSpan" id="kobo.1137.2">However, we want to exclude a result if it matches </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">EmailAddress</span></strong><span class="koboSpan" id="kobo.1139.1"> since that would indicate the records are identical, and this user is just signing back </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">in again.</span></span></p></li> <li><span class="koboSpan" id="kobo.1141.1">Now, query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">Players</span></strong><span class="koboSpan" id="kobo.1143.1"> dataset for a player with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">matching email:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1145.1">
    log.LogInformation("Locating Player record.");    var thisPlayer = (from p in context.Players where string.Equals(p.EmailAddress, newPlayer.EmailAddress, StringComparison.OrdinalIgnoreCase) select p).FirstOrDefault();</span></pre></li> <li><span class="koboSpan" id="kobo.1146.1">If there </span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.1147.1">is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">Player</span></strong><span class="koboSpan" id="kobo.1149.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">Players</span></strong><span class="koboSpan" id="kobo.1151.1"> that matches, then add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">Player</span></strong><span class="koboSpan" id="kobo.1153.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">the dataset:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
if (thisPlayer is null){    log.LogInformation("Player not found, creating.");    thisPlayer = newPlayer;    thisPlayer.Id = Guid.NewGuid();    context.Add(thisPlayer);    await context.SaveChangesAsync();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1156.1">We assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">Player</span></strong><span class="koboSpan" id="kobo.1158.1"> object a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">Guid</span></strong><span class="koboSpan" id="kobo.1160.1"> so that each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">Player</span></strong><span class="koboSpan" id="kobo.1162.1"> has a unique identifier. </span><span class="koboSpan" id="kobo.1162.2">This could also be done by Entity Framework; however, we will take care of it here. </span><span class="koboSpan" id="kobo.1162.3">The context is then used to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">Player</span></strong><span class="koboSpan" id="kobo.1164.1"> instance so that it is tracked for any changes. </span><span class="koboSpan" id="kobo.1164.2">After this, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">SaveChangesAsync</span></strong><span class="koboSpan" id="kobo.1166.1"> will commit all changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">the database.</span></span></p></li> <li><span class="koboSpan" id="kobo.1168.1">The next step in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">Connect</span></strong><span class="koboSpan" id="kobo.1170.1"> function is to send a message to all the connected players that a new player has joined. </span><span class="koboSpan" id="kobo.1170.2">We can do that using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">SendAsync</span></strong><span class="koboSpan" id="kobo.1172.1"> method. </span><span class="koboSpan" id="kobo.1172.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">SendAsync</span></strong><span class="koboSpan" id="kobo.1174.1"> method takes two parameters – the method name as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">string</span></strong><span class="koboSpan" id="kobo.1176.1"> value that the message is intended for, and the message as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">object</span></strong><span class="koboSpan" id="kobo.1178.1"> value. </span><span class="koboSpan" id="kobo.1178.2">To ensure we are sending and receiving the right method, we will create a constant value. </span><span class="koboSpan" id="kobo.1178.3">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">Constants</span></strong><span class="koboSpan" id="kobo.1180.1"> in the root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1182.1"> project, then update it so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1184.1">
namespace SticksAndStones;public static class Constants {    public static class Events     {        public static readonly string PlayerUpdated = nameof(PlayerUpdated);    }}</span></pre></li> <li><span class="koboSpan" id="kobo.1185.1">Now, we can </span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.1186.1">notify other connected players that a new player has connected. </span><span class="koboSpan" id="kobo.1186.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">GameHub</span></strong><span class="koboSpan" id="kobo.1188.1"> class and, at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">Connect</span></strong><span class="koboSpan" id="kobo.1190.1"> method, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1192.1">
    log.LogInformation("Notifying connected players of new player.");    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(thisPlayer));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1193.1">This code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">SendAsync</span></strong><span class="koboSpan" id="kobo.1195.1"> method from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">Clients.All</span></strong><span class="koboSpan" id="kobo.1197.1"> collection in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">ServerlessHub</span></strong><span class="koboSpan" id="kobo.1199.1"> base class to send a message to all connected clients. </span><span class="koboSpan" id="kobo.1199.2">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">Constants.Events.PlayerUpdated</span></strong><span class="koboSpan" id="kobo.1201.1">, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">"PlayerUpdated"</span></strong><span class="koboSpan" id="kobo.1203.1"> string, as the method name. </span><span class="koboSpan" id="kobo.1203.2">As arguments, we are sending the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">Player</span></strong><span class="koboSpan" id="kobo.1205.1"> instance wrapped in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">PlayerUpdatedEventArgs</span></strong><span class="koboSpan" id="kobo.1207.1">. </span><span class="koboSpan" id="kobo.1207.2">We will handle this message in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1208.1">Chapter 10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.1210.1">Now, get the set of available players from the database to send back to </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">the client:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1212.1">
// Get the set of available players log.LogInformation("Getting the set of available players.");    var players = (from player in context.Players         where player.Id != thisPlayer.Id         select player).ToList();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1213.1">Using Linq, we can easily query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">Players</span></strong><span class="koboSpan" id="kobo.1215.1"> collection and exclude the </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">current player.</span></span></p></li> <li><span class="koboSpan" id="kobo.1217.1">At this point, we need to get the SignalR connection information from the SignalR service. </span><span class="koboSpan" id="kobo.1217.2">This can be accomplished by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">NegotiateAsync</span></strong><span class="koboSpan" id="kobo.1219.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">ServerlessHub</span></strong><span class="koboSpan" id="kobo.1221.1"> base class. </span><span class="koboSpan" id="kobo.1221.2">Additionally, so that we can send directed messages to individual users, we will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">UserId</span></strong><span class="koboSpan" id="kobo.1223.1"> value for the connection </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.1224.1">to the player ID value. </span><span class="koboSpan" id="kobo.1224.2">Add the following line of code to configure and retrieve the SignalR </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">connection information:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1226.1">
var connectionInfo = await NegotiateAsync(new NegotiationOptions() { UserId = thisPlayer.Id.ToString() });</span></pre></li> <li><span class="koboSpan" id="kobo.1227.1">Now that we have all the information that we need to return to the client, we can construct the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">ConnectResponse</span></strong><span class="koboSpan" id="kobo.1229.1"> object. </span><span class="koboSpan" id="kobo.1229.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">ConnectionInfo</span></strong><span class="koboSpan" id="kobo.1231.1"> class and map the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">SignalRConnection</span></strong><span class="koboSpan" id="kobo.1233.1"> properties to it so that we avoid having to reference the SignalR service in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1234.1">shared library:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1235.1">
log.LogInformation("Creating response.");var connectResponse = new ConnectResponse(){    Player = thisPlayer,    Players = players,    ConnectionInfo = new Models.ConnectionInfo { Url = connectionInfo.Url, AccessToken = connectionInfo.AccessToken }};</span></pre></li> <li><span class="koboSpan" id="kobo.1236.1">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.1237.1">ConnectResponse</span></strong><span class="koboSpan" id="kobo.1238.1"> has been initialized, we can return it by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">OkObjectResult</span></strong><span class="koboSpan" id="kobo.1240.1">, which will use an HTTP response code of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1241.1">200 OK</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1243.1">
log.LogInformation("Sending response.");return new OkObjectResult(connectResponse);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1244.1">To test the function we just wrote, you can use a PowerShell command prompt and the following command, after pressing </span><em class="italic"><span class="koboSpan" id="kobo.1245.1">F5</span></em><span class="koboSpan" id="kobo.1246.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">Visual Studio:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1248.1">
Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect -Method Post -Body ''</span></pre> <p><span class="koboSpan" id="kobo.1249.1">The port </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.1250.1">number used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">Uri</span></strong><span class="koboSpan" id="kobo.1252.1"> parameter may be different for your project. </span><span class="koboSpan" id="kobo.1252.2">You can get the correct port number by opening the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">launchSettings.json</span></strong><span class="koboSpan" id="kobo.1254.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">Properties</span></strong><span class="koboSpan" id="kobo.1256.1"> folder of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.1258.1"> project. </span><span class="koboSpan" id="kobo.1258.2">The port number is set in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">commandLineArgs</span></strong><span class="koboSpan" id="kobo.1260.1"> property, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">highlighted here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1262.1">
{  "profiles": {    "SticksAndStones.Functions": {      "commandName": "Project",      "commandLineArgs": "--port </span><strong class="bold"><span class="koboSpan" id="kobo.1263.1">7024</span></strong><span class="koboSpan" id="kobo.1264.1">",      "launchBrowser": false     }  }}</span></pre> <p><span class="koboSpan" id="kobo.1265.1">Replace your port number in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">Uri</span></strong><span class="koboSpan" id="kobo.1267.1"> parameter </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">after </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">localhost:</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1271.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">Body</span></strong><span class="koboSpan" id="kobo.1273.1"> parameter, you can add the JSON that the command is expecting. </span><span class="koboSpan" id="kobo.1273.2">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">Connect</span></strong><span class="koboSpan" id="kobo.1275.1"> function, this would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1276.1">ConnectRequest</span></strong><span class="koboSpan" id="kobo.1277.1"> and would look </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1279.1">
'{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress": "newplayer2@gmail.com",    }}'</span></pre> <p><span class="koboSpan" id="kobo.1280.1">The full command will look </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1282.1">
Invoke-WebRequest -Headers @{ ContentType = "application/json" } -Uri http://localhost:7024/api/Connect -Method Post -Body '{     "player": {        "gamerTag": "NewPlayer2",        "emailAddress": "newplayer2@gmail.com",    }}'</span></pre> <p><span class="koboSpan" id="kobo.1283.1">Go ahead </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.1284.1">and try out various versions of the command to see how the </span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">function reacts.</span></span></p>
<p><span class="koboSpan" id="kobo.1286.1">Now that we can connect players to the game server, let’s look at what is needed for </span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">the lobby.</span></span></p>
<h3><span class="koboSpan" id="kobo.1288.1">Refreshing the lobby</span></h3>
<p><span class="koboSpan" id="kobo.1289.1">In the Sticks and Stones App, which you will create in </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">Chapter 10</span></span><span class="koboSpan" id="kobo.1291.1">, once a player has connected, they will move to the lobby page. </span><span class="koboSpan" id="kobo.1291.2">Initially, the lobby </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.1292.1">will be populated from the list of players </span><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.1293.1">sent in the response from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">Connect</span></strong><span class="koboSpan" id="kobo.1295.1"> function. </span><span class="koboSpan" id="kobo.1295.2">Additionally, as each player connects, the lobby will be updated through a </span><span class="No-Break"><span class="koboSpan" id="kobo.1296.1">SignalR event.</span></span></p>
<p><span class="koboSpan" id="kobo.1297.1">But we all get impatient and want a way to refresh the list immediately. </span><span class="koboSpan" id="kobo.1297.2">So, the lobby page has a way to refresh the list; to do so, it will call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">GetAllPlayers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1299.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1300.1">Let’s start by creating the messages needed </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">GetAllPlayers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1303.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1304.1">Creating the messages</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">GetAllPlayers</span></strong><span class="koboSpan" id="kobo.1306.1"> takes no </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.1307.1">parameters, so we only need to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">GetAllPlayersResponse</span></strong><span class="koboSpan" id="kobo.1309.1"> type. </span><span class="koboSpan" id="kobo.1309.2">Follow these steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">add </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">GetAllPlayersResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1313.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1315.1"> project, create a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">GetAllPlayers</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">
Messages.cs</span></strong><span class="koboSpan" id="kobo.1319.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">Messages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.1322.1">Modify the contents of the file so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1323.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1324.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct GetAllPlayersResponse(List&lt;Player&gt; Players);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1325.1">With the </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.1326.1">messages created, we can move on to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">GetAllPlayers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1328.1"> function.</span></span></p>
<h4><span class="koboSpan" id="kobo.1329.1">Getting all the players</span></h4>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">GetAllPlayers</span></strong><span class="koboSpan" id="kobo.1331.1"> is called using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">Http</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">GET</span></strong><span class="koboSpan" id="kobo.1334.1"> method and has an optional parameter that is passed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">QueryString</span></strong><span class="koboSpan" id="kobo.1336.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">id</span></strong><span class="koboSpan" id="kobo.1338.1"> key. </span><span class="koboSpan" id="kobo.1338.2">The optional parameter is used to </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.1339.1">exclude a specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">id</span></strong><span class="koboSpan" id="kobo.1341.1"> from the returned list. </span><span class="koboSpan" id="kobo.1341.2">This makes it </span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.1342.1">so that the app can send the current player’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">id</span></strong><span class="koboSpan" id="kobo.1344.1"> and not have it returned in the list. </span><span class="koboSpan" id="kobo.1344.2">To create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">GetAllPlayers</span></strong><span class="koboSpan" id="kobo.1346.1"> function, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1348.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1349.1">GameHub</span></strong><span class="koboSpan" id="kobo.1350.1"> class, after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">Connect</span></strong><span class="koboSpan" id="kobo.1352.1"> method, add the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">method declaration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1354.1">
[FunctionName("GetAllPlayers")]public IActionResult GetAllPlayers([HttpTrigger(AuthorizationLevel.Function, "get", Route = "Players/GetAll")] HttpRequest req,ILogger log){}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1355.1">Not much is new here other than using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">"get"</span></strong><span class="koboSpan" id="kobo.1357.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1358.1">"post"</span></strong><span class="koboSpan" id="kobo.1359.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">Http</span></strong><span class="koboSpan" id="kobo.1361.1"> method, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">Route</span></strong><span class="koboSpan" id="kobo.1363.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">"Players/GetAll"</span></strong><span class="koboSpan" id="kobo.1365.1">, which would make the URL for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">http://localhost:7024/api/Players/GetAll</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.1369.1">In the method, we will process the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1370.1">id</span></strong><span class="koboSpan" id="kobo.1371.1"> option parameter. </span><span class="koboSpan" id="kobo.1371.2">To do so, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1373.1">
// Exclude the playerId if provided Guid playerId = Guid.Empty;if (req.Query.ContainsKey("id")){    string id = req.Query["id"];    if (!string.IsNullOrEmpty(id))    {        playerId = new Guid(id);    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1374.1">In this code, we check for the existence of a key named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1375.1">id</span></strong><span class="koboSpan" id="kobo.1376.1">. </span><span class="koboSpan" id="kobo.1376.2">If it exists, then its value is retrieved and converted into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">Guid</span></strong><span class="koboSpan" id="kobo.1378.1"> value and assigned to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1379.1">playerId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1380.1"> variable.</span></span></p></li> <li><span class="koboSpan" id="kobo.1381.1">Next, we can </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.1382.1">query the database for all players, and exclude </span><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">player.Id</span></strong><span class="koboSpan" id="kobo.1384.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1386.1">
using var context = contextFactory.CreateDbContext();// Get the set of available players log.LogInformation("Getting the set of available players.");var players = (from player in context.Players                where player.Id != playerId                select player).ToList();</span></pre></li> <li><span class="koboSpan" id="kobo.1387.1">Finally, return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">OkObjectResult</span></strong><span class="koboSpan" id="kobo.1389.1"> with a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">GetAllPlayersResponse</span></strong><span class="koboSpan" id="kobo.1391.1"> object initialized with the list </span><span class="No-Break"><span class="koboSpan" id="kobo.1392.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">players</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1395.1">
return new OkObjectResult(new GetAllPlayersResponse(players));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1396.1">Now that we can refresh the lobby with a list of all the players, it’s time to match them up for </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">a game.</span></span></p>
<h3><span class="koboSpan" id="kobo.1398.1">Challenging another player to a game</span></h3>
<p><span class="koboSpan" id="kobo.1399.1">To test your </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.1400.1">skills at this game, you’ll need an opponent – someone who would also like to test their skills against yours. </span><span class="koboSpan" id="kobo.1400.2">This section will build the functionality needed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">SticksAndStones.Function</span></strong><span class="koboSpan" id="kobo.1402.1"> project to have one player – the challenger – challenge another player – the opponent – to a game. </span><span class="koboSpan" id="kobo.1402.2">The opponent has the option to accept the challenge or deny it. </span><span class="koboSpan" id="kobo.1402.3">We will also handle the case where the opponent does not respond since they might have put their phone down; this is an </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">edge case.</span></span></p>
<p><span class="koboSpan" id="kobo.1404.1">The interactions </span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.1405.1">in this use case can get tricky, so let’s review the following diagram to get a better understanding of what we </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">are building:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<span class="koboSpan" id="kobo.1407.1"><img alt="Figure 9.10 – Challenge diagram" src="image/B19214_09_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1408.1">Figure 9.10 – Challenge diagram</span></p>
<p><span class="koboSpan" id="kobo.1409.1">The process starts with a user interaction that results in the client making an HTTP request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">GameHub</span></strong><span class="koboSpan" id="kobo.1411.1"> instance via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1413.1"> function. </span><span class="koboSpan" id="kobo.1413.2">The client will pass the challenger and opponent details when making the HTTP call. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1415.1"> will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">Id</span></strong><span class="koboSpan" id="kobo.1417.1"> value to track this process. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1418.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1419.1"> will then send a direct message to the opponent via the SignalR hub using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1420.1">SendAsync</span></strong><span class="koboSpan" id="kobo.1421.1"> method. </span><span class="koboSpan" id="kobo.1421.2">The message will include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">Id</span></strong><span class="koboSpan" id="kobo.1423.1"> value that was created earlier, the challenger, and the opponent details as an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">ChallengeEventArgs</span></strong><span class="koboSpan" id="kobo.1425.1">. </span><span class="koboSpan" id="kobo.1425.2">The opponent’s client will receive the message via an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1426.1">On&lt;ChallengeEventArgs&gt;</span></strong><span class="koboSpan" id="kobo.1427.1"> event handler. </span><span class="koboSpan" id="kobo.1427.2">The opponent will then have the choice of accepting or declining the challenge. </span><span class="koboSpan" id="kobo.1427.3">The response is sent back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1428.1">GameHub</span></strong><span class="koboSpan" id="kobo.1429.1"> instance using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.1431.1"> function. </span><span class="koboSpan" id="kobo.1431.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1432.1">Id</span></strong><span class="koboSpan" id="kobo.1433.1"> value of the challenge is sent along with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">ChallengeResponse</span></strong><span class="koboSpan" id="kobo.1435.1">, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">Accept</span></strong><span class="koboSpan" id="kobo.1437.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">Decline</span></strong><span class="koboSpan" id="kobo.1439.1">. </span><span class="koboSpan" id="kobo.1439.2">A third possibility is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1440.1">Timeout</span></strong><span class="koboSpan" id="kobo.1441.1">. </span><span class="koboSpan" id="kobo.1441.2">If the opponent never responds, then after a certain amount of time has passed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1442.1">Challenge</span></strong><span class="koboSpan" id="kobo.1443.1"> will </span><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">Timeout</span></strong><span class="koboSpan" id="kobo.1445.1">. </span><span class="koboSpan" id="kobo.1445.2">In either event, the result is then returned to the challenger using the response of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1446.1">IssueChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1447.1"> call.</span></span></p>
<p><span class="koboSpan" id="kobo.1448.1">Let’s get started by defining </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">the messages.</span></span></p>
<h4><span class="koboSpan" id="kobo.1450.1">Creating the messages and models</span></h4>
<p><span class="koboSpan" id="kobo.1451.1">We will </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.1452.1">start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">IssueChallengeRequest</span></strong><span class="koboSpan" id="kobo.1454.1"> since that is the first message that is being sent. </span><span class="koboSpan" id="kobo.1454.2">Follow these steps to create </span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1">the class:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1456.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1458.1"> project, create a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">ChallengeMessages.cs</span></strong><span class="koboSpan" id="kobo.1460.1"> under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">Message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1462.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.1463.1">Modify the file so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1464.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1465.1">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct IssueChallengeRequest(Player Challenger, Player Opponent);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1466.1">As we have in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">Connect</span></strong><span class="koboSpan" id="kobo.1468.1"> function, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">record</span></strong><span class="koboSpan" id="kobo.1470.1"> struct to eliminate a lot of the boilerplate code needed to define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1471.1">struct</span></strong><span class="koboSpan" id="kobo.1472.1"> value. </span><span class="koboSpan" id="kobo.1472.2">Our message only needs two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1473.1">Player</span></strong><span class="koboSpan" id="kobo.1474.1"> objects – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1475.1">Challenger</span></strong><span class="koboSpan" id="kobo.1476.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1477.1">Opponent</span></strong><span class="koboSpan" id="kobo.1478.1">. </span><span class="koboSpan" id="kobo.1478.2">The client will have both available when it makes the call to this function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1479.1">Challenger</span></strong><span class="koboSpan" id="kobo.1480.1"> will be the client making the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1481.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1482.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1483.1">Opponent</span></strong><span class="koboSpan" id="kobo.1484.1"> will be the </span><span class="No-Break"><span class="koboSpan" id="kobo.1485.1">opposing side.</span></span></p>
<p><span class="koboSpan" id="kobo.1486.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1487.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1488.1"> function will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">IssueChallengeResponse</span></strong><span class="koboSpan" id="kobo.1490.1">. </span><span class="No-Break"><span class="koboSpan" id="kobo.1491.1">This </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">Issue</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">
ChallengeResponse</span></strong><span class="koboSpan" id="kobo.1494.1"> will have just one field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">Response</span></strong><span class="koboSpan" id="kobo.1496.1">, which will be an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">enum</span></strong><span class="koboSpan" id="kobo.1498.1"> value called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">ChallengeResponse</span></strong><span class="koboSpan" id="kobo.1500.1">. </span><span class="koboSpan" id="kobo.1500.2">Follow these steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1">create </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1502.1">ChallengeResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1504.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1506.1"> project, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">Models</span></strong><span class="koboSpan" id="kobo.1508.1"> folder, create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">enum</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1510.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">ChallengeResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1512.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1513.1">Add the following values to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">enum</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1515.1"> value:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1516.1">None</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1517.1">Accepted</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">Declined</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">Timeout</span></strong></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.1520.1">Your code should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1521.1">like this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1522.1">
namespace SticksAndStones.Models;public enum ChallengeResponse {    None,    Accepted,    Declined,    TimeOut }</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1523.1">To create </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.1524.1">the remaining messages for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1526.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.1528.1"> functions, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1530.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">ChallengeMessages.cs</span></strong><span class="koboSpan" id="kobo.1532.1"> file and add the following declaration at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.1533.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1534.1">
public record struct IssueChallengeResponse(ChallengeResponse Response);</span></pre></li> <li><span class="koboSpan" id="kobo.1535.1">When the opponent responds to a challenge, they will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1536.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.1537.1"> function and pass an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">AcknowledgeChallengeRequest</span></strong><span class="koboSpan" id="kobo.1539.1"> object as an argument. </span><span class="koboSpan" id="kobo.1539.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">ChallengeMessages.cs</span></strong><span class="koboSpan" id="kobo.1541.1"> file, add the following declaration to create </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">AcknowledgeChallengeRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1544.1">
public record struct AcknowledgeChallengeRequest(Guid Id, ChallengeResponse Response);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1545.1">That completes the messages that are sent or received from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">GameHub</span></strong><span class="koboSpan" id="kobo.1547.1"> functions for a challenge. </span><span class="koboSpan" id="kobo.1547.2">That just leaves </span><strong class="source-inline"><span class="koboSpan" id="kobo.1548.1">ChallengeEventArgs</span></strong><span class="koboSpan" id="kobo.1549.1">, which is sent from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1550.1">GameHub</span></strong><span class="koboSpan" id="kobo.1551.1"> to the opponent. </span><span class="koboSpan" id="kobo.1551.2">To create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1552.1">ChallengeEventArgs</span></strong><span class="koboSpan" id="kobo.1553.1"> class, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1554.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1555.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">Messages</span></strong><span class="koboSpan" id="kobo.1557.1"> folder of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1558.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1559.1"> project, create a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1561.1">ChallengeEventArgs.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1563.1">Replace the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">ChallengeEventArgs.cs</span></strong><span class="koboSpan" id="kobo.1565.1"> file with </span><span class="No-Break"><span class="koboSpan" id="kobo.1566.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1567.1">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct ChallengeEventArgs(Guid Id, Player Challenger, Player Opponent);</span></pre></li> <li><span class="koboSpan" id="kobo.1568.1">To add </span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.1569.1">the method name constant for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1570.1">SendAsync</span></strong><span class="koboSpan" id="kobo.1571.1"> method, open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1572.1">Constants.cs</span></strong><span class="koboSpan" id="kobo.1573.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1574.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1575.1"> project and add the following highlighted field to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1576.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1578.1">
public static class Events {    public static readonly string PlayerUpdated = nameof(PlayerUpdated);    </span><strong class="bold"><span class="koboSpan" id="kobo.1579.1">public static readonly string Challenge = nameof(Challenge);</span></strong><span class="koboSpan" id="kobo.1580.1">}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1581.1">As with the previous message definitions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1582.1">ChallengeEventArgs</span></strong><span class="koboSpan" id="kobo.1583.1"> is also defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1584.1">public record struct</span></strong><span class="koboSpan" id="kobo.1585.1">. </span><span class="koboSpan" id="kobo.1585.2">The parameters are an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1586.1">Id</span></strong><span class="koboSpan" id="kobo.1587.1"> value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1588.1">Guid</span></strong><span class="koboSpan" id="kobo.1589.1"> type and two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1590.1">Player</span></strong><span class="koboSpan" id="kobo.1591.1"> objects – one for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1592.1">Challenger</span></strong><span class="koboSpan" id="kobo.1593.1"> or the initiator, and one for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1594.1">Opponent</span></strong><span class="koboSpan" id="kobo.1595.1"> or the receiver. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1596.1">Id</span></strong><span class="koboSpan" id="kobo.1597.1"> will be created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1598.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1599.1"> function and is used to correlate the challenge with the response. </span><span class="koboSpan" id="kobo.1599.2">This is needed because we are tracking the challenge and if a certain amount of time has passed, we expire the challenge. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">Id</span></strong><span class="koboSpan" id="kobo.1601.1"> is used to track that state and check whether the challenge is still valid if the </span><span class="No-Break"><span class="koboSpan" id="kobo.1602.1">client responds.</span></span></p>
<p><span class="koboSpan" id="kobo.1603.1">What was not included in the diagram in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1604.1">Figure 9</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1605.1">.10</span></em><span class="koboSpan" id="kobo.1606.1"> is a structure that is used to track the challenge in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">GameHub</span></strong><span class="koboSpan" id="kobo.1608.1"> class. </span><span class="koboSpan" id="kobo.1608.2">It is only needed while a challenge is active and hasn’t timed out. </span><span class="koboSpan" id="kobo.1608.3">To create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">Challenge</span></strong><span class="koboSpan" id="kobo.1610.1"> class, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1611.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1612.1">Create a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1613.1">Challenge.cs</span></strong><span class="koboSpan" id="kobo.1614.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1615.1">Models</span></strong><span class="koboSpan" id="kobo.1616.1"> folder of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1617.1">SticksAndStones.Shared</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.1619.1">Replace the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">Challenge.cs</span></strong><span class="koboSpan" id="kobo.1621.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1622.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1623.1">
using System;namespace SticksAndStones.Models;public record struct Challenge(Guid Id, Player Challenger, Player Opponent, ChallengeResponse Response);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1624.1">As with </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.1625.1">previous models, we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">record</span></strong><span class="koboSpan" id="kobo.1627.1"> struct. </span><span class="koboSpan" id="kobo.1627.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1628.1">Challenge</span></strong><span class="koboSpan" id="kobo.1629.1"> class has various properties – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">Id</span></strong><span class="koboSpan" id="kobo.1631.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">Challenger</span></strong><span class="koboSpan" id="kobo.1633.1"> as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">Player</span></strong><span class="koboSpan" id="kobo.1635.1"> type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1636.1">Opponent</span></strong><span class="koboSpan" id="kobo.1637.1"> as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">Player</span></strong><span class="koboSpan" id="kobo.1639.1"> type, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">ChallengeResponse</span></strong><span class="koboSpan" id="kobo.1641.1">, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.1642.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1643.1">Response</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1644.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1645.1">If a player accepts the challenge, then the two players will start a match with each other. </span><span class="koboSpan" id="kobo.1645.2">Each player will be notified that the match has begun by receiving a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1646.1">MatchStarted</span></strong><span class="koboSpan" id="kobo.1647.1"> SignalR event. </span><span class="koboSpan" id="kobo.1647.2">To create the event and its arguments, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1648.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1649.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">Constants.cs</span></strong><span class="koboSpan" id="kobo.1651.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1652.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1653.1"> project and add the following highlighted field to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1654.1">Events</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1655.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1656.1">
public static class Events {    public static readonly string PlayerUpdated = nameof(PlayerUpdated);    public static readonly string Challenge = nameof(Challenge);</span><strong class="bold"><span class="koboSpan" id="kobo.1657.1">
    public static readonly string GameStarted = nameof(MatchStarted);</span></strong><span class="koboSpan" id="kobo.1658.1">}</span></pre></li> <li><span class="koboSpan" id="kobo.1659.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1660.1">Messages</span></strong><span class="koboSpan" id="kobo.1661.1"> folder of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.1663.1"> project, create a new file </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1665.1">MatchStartedEventArgs.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1666.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1667.1">Replace the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">MatchStartedEventArgs.cs</span></strong><span class="koboSpan" id="kobo.1669.1"> file with </span><span class="No-Break"><span class="koboSpan" id="kobo.1670.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1671.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct MatchStartedEventArgs(Match Match);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1672.1">That </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.1673.1">concludes the new messages and models that are needed to allow one player to challenge another to a game of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1674.1">SticksAndStones</span></strong><span class="koboSpan" id="kobo.1675.1">. </span><span class="koboSpan" id="kobo.1675.2">Next, we will create the first of two functions that will handle the process in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1676.1">GameHub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1677.1"> class.</span></span></p>
<h3><span class="koboSpan" id="kobo.1678.1">Creating the IssueChallenge function</span></h3>
<p><span class="koboSpan" id="kobo.1679.1">We’ll </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.1680.1">start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1681.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1682.1"> function. </span><span class="koboSpan" id="kobo.1682.2">This function is called from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">Challenger</span></strong><span class="koboSpan" id="kobo.1684.1"> client to start the challenge process. </span><span class="koboSpan" id="kobo.1684.2">The client will pass their </span><strong class="source-inline"><span class="koboSpan" id="kobo.1685.1">Player</span></strong><span class="koboSpan" id="kobo.1686.1"> object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">Challenger</span></strong><span class="koboSpan" id="kobo.1688.1">, and the player they are challenging – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1689.1">Opponent</span></strong><span class="koboSpan" id="kobo.1690.1">. </span><span class="koboSpan" id="kobo.1690.2">These two models are contained in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">IssueChallengeRequest</span></strong><span class="koboSpan" id="kobo.1692.1"> object. </span><span class="koboSpan" id="kobo.1692.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1693.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1694.1"> function will need to perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.1695.1">following actions:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1696.1">Validate input</span></span></li>
<li><span class="koboSpan" id="kobo.1697.1">Create a </span><span class="No-Break"><span class="koboSpan" id="kobo.1698.1">challenge object</span></span></li>
<li><span class="koboSpan" id="kobo.1699.1">Send a challenge to </span><span class="No-Break"><span class="koboSpan" id="kobo.1700.1">the opponent</span></span></li>
<li><span class="koboSpan" id="kobo.1701.1">Wait for a response from </span><span class="No-Break"><span class="koboSpan" id="kobo.1702.1">the opponent</span></span></li>
<li><span class="koboSpan" id="kobo.1703.1">Send the response to </span><span class="No-Break"><span class="koboSpan" id="kobo.1704.1">the challenger</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1705.1">To create the function and implement these actions, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1706.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1707.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1708.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.1709.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1710.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1711.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.1712.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1713.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1714.1"> function declaration, </span><span class="No-Break"><span class="koboSpan" id="kobo.1715.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1716.1">
[FunctionName("IssueChallenge")]public async Task&lt;IssueChallengeResponse&gt; IssueChallenge(    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Challenge/Issue")] HttpRequest req,    ILogger log){}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1717.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">FunctionName</span></strong><span class="koboSpan" id="kobo.1719.1"> attribute tells Azure Functions that this is an available function. </span><span class="koboSpan" id="kobo.1719.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1720.1">req</span></strong><span class="koboSpan" id="kobo.1721.1"> parameter is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1722.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.1723.1"> object, and the Azure Functions runtime will provide its instance when the function is called. </span><span class="koboSpan" id="kobo.1723.2">It is attributed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1724.1">HttpTrigger</span></strong><span class="koboSpan" id="kobo.1725.1"> attribute, which makes the function available via an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1726.1">Http</span></strong><span class="koboSpan" id="kobo.1727.1"> API call. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">HttpRequest</span></strong><span class="koboSpan" id="kobo.1729.1"> must use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">POST</span></strong><span class="koboSpan" id="kobo.1731.1"> method and not </span><strong class="source-inline"><span class="koboSpan" id="kobo.1732.1">GET</span></strong><span class="koboSpan" id="kobo.1733.1"> when making the call and the function’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1734.1">Route</span></strong><span class="koboSpan" id="kobo.1735.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1736.1">Url</span></strong><span class="koboSpan" id="kobo.1737.1"> will end with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">Challenge/Issue</span></strong><span class="koboSpan" id="kobo.1739.1">. </span><span class="koboSpan" id="kobo.1739.2">The function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1740.1">IssueChallengeResponse</span></strong><span class="koboSpan" id="kobo.1741.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1">the caller.</span></span></p></li> <li><span class="koboSpan" id="kobo.1743.1">The first </span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.1744.1">action the function performs is to validate the inputs. </span><span class="koboSpan" id="kobo.1744.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1745.1">IssueChallengeRequest</span></strong><span class="koboSpan" id="kobo.1746.1"> object is sent as part of the body of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1747.1">Http</span></strong><span class="koboSpan" id="kobo.1748.1"> POST request. </span><span class="koboSpan" id="kobo.1748.2">To retrieve the instance, use the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1749.1">IssueChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1750.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1751.1">
{    var result = await JsonSerializer.DeserializeAsync&lt;IssueChallengeRequest&gt;(req.Body, jsonOptions);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1752.1">This is the same way we retrieved the arguments that were passed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1753.1">Connect</span></strong><span class="koboSpan" id="kobo.1754.1"> function. </span><span class="koboSpan" id="kobo.1754.2">The main difference is that the type of object being returned by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1755.1">DeserializeAsync</span></strong><span class="koboSpan" id="kobo.1756.1"> method is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">IssueChallengeRequest</span></strong><span class="koboSpan" id="kobo.1758.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.1759.1">ConnectRequest</span></strong><span class="koboSpan" id="kobo.1760.1">. </span><span class="koboSpan" id="kobo.1760.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1761.1">jsonOptions</span></strong><span class="koboSpan" id="kobo.1762.1"> field is already defined in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1763.1">GameHub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1764.1"> class.</span></span></p></li> <li><span class="koboSpan" id="kobo.1765.1">Now, we need to check whether the challenger and opponent are valid. </span><span class="koboSpan" id="kobo.1765.2">Valid means that they exist in our database, and neither are currently in a match. </span><span class="koboSpan" id="kobo.1765.3">We will use </span><strong class="bold"><span class="koboSpan" id="kobo.1766.1">Linq</span></strong><span class="koboSpan" id="kobo.1767.1"> queries to check our database for each object. </span><span class="koboSpan" id="kobo.1767.2">Add the following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1769.1"> function to verify that the </span><span class="No-Break"><span class="koboSpan" id="kobo.1770.1">players exist:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1771.1">
using var context = contextFactory.CreateDbContext();Guid challengerId = result.Challenger.Id;var challenger = (from p in context.Players                   where p.Id == challengerId                   select p).FirstOrDefault();

Guid opponentId = result.Opponent.Id;var opponent = (from p in context.Players                 where p.Id == opponentId                 select p).FirstOrDefault();if (challenger is null)    throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag} is not a valid player.");if (opponent is null)    throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag} is not a valid player.");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1772.1">First, we capture the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1773.1">Id</span></strong><span class="koboSpan" id="kobo.1774.1"> value of the player. </span><span class="koboSpan" id="kobo.1774.2">We use this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1775.1">Id</span></strong><span class="koboSpan" id="kobo.1776.1"> to query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">Players</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1778.1">DbSet</span></strong><span class="koboSpan" id="kobo.1779.1"> in the database context for a matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.1780.1">Id</span></strong><span class="koboSpan" id="kobo.1781.1"> and return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1782.1">Player</span></strong><span class="koboSpan" id="kobo.1783.1"> object if it exists; otherwise, we return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1784.1">null</span></strong><span class="koboSpan" id="kobo.1785.1">. </span><span class="koboSpan" id="kobo.1785.2">If the object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1786.1">null</span></strong><span class="koboSpan" id="kobo.1787.1">, then </span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.1788.1">we exit the function by throwing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1789.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.1790.1"> and passing the name of the object as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1791.1">paramName</span></strong><span class="koboSpan" id="kobo.1792.1"> argument and a message detailing the issue. </span><span class="koboSpan" id="kobo.1792.2">This can be used on the client to display an </span><span class="No-Break"><span class="koboSpan" id="kobo.1793.1">error message.</span></span></p></li> <li><span class="koboSpan" id="kobo.1794.1">The following code will check whether the players are currently engaged in a match with another player. </span><span class="koboSpan" id="kobo.1794.2">Add the following code to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">IssueChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1796.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1797.1">
var challengerInMatch = (from g in context.Matches
                         where g.PlayerOneId == challengerId || g.PlayerTwoId == challengerId
                         select g).Any();
var opponentInMatch = (from g in context.Matches
                       where g.PlayerOneId == opponentId || g.PlayerTwoId == opponentId
                       select g).Any();
if (challengerInMatch)
    throw new ArgumentException(paramName: nameof(challenger), message: $"{challenger.GamerTag} is already in a match!");
if (opponentInMatch)
    throw new ArgumentException(paramName: nameof(opponent), message: $"{opponent.GamerTag} is already in a match!");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1798.1">Again, we use </span><strong class="bold"><span class="koboSpan" id="kobo.1799.1">Linq</span></strong><span class="koboSpan" id="kobo.1800.1"> to query the database, but this time, we are querying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">Matches</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1802.1">DbSet</span></strong><span class="koboSpan" id="kobo.1803.1">. </span><span class="koboSpan" id="kobo.1803.2">We are not looking for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1804.1">Match</span></strong><span class="koboSpan" id="kobo.1805.1"> instance, just the fact that one does exist, where either </span><strong class="source-inline"><span class="koboSpan" id="kobo.1806.1">PlayerOneId</span></strong><span class="koboSpan" id="kobo.1807.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1808.1">PlayerTwoId</span></strong><span class="koboSpan" id="kobo.1809.1"> is the player’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1810.1">Id</span></strong><span class="koboSpan" id="kobo.1811.1"> value. </span><span class="koboSpan" id="kobo.1811.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1812.1">Any</span></strong><span class="koboSpan" id="kobo.1813.1"> function to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.1814.1">true</span></strong><span class="koboSpan" id="kobo.1815.1"> if there are any results and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1816.1">false</span></strong><span class="koboSpan" id="kobo.1817.1"> if there are no results. </span><span class="koboSpan" id="kobo.1817.2">Again, we throw </span><strong class="source-inline"><span class="koboSpan" id="kobo.1818.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.1819.1"> if either player is in a match with an </span><span class="No-Break"><span class="koboSpan" id="kobo.1820.1">appropriate message.</span></span></p></li> <li><span class="koboSpan" id="kobo.1821.1">At this point, we have validated that both players exist and can join a new game. </span><span class="koboSpan" id="kobo.1821.2">We will </span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.1822.1">need to capture the game </span><strong class="source-inline"><span class="koboSpan" id="kobo.1823.1">Id</span></strong><span class="koboSpan" id="kobo.1824.1"> value if the challenge is accepted, so let’s create the variable and log some details before </span><span class="No-Break"><span class="koboSpan" id="kobo.1825.1">moving on:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1826.1">
Guid matchId = Guid.Empty;log.LogInformation($"{challenger.GamerTag} has challenged {opponent.GamerTag} to a match!");</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1827.1">The next step in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1828.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1829.1"> function is to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1830.1">Challenge</span></strong><span class="koboSpan" id="kobo.1831.1"> object. </span><span class="koboSpan" id="kobo.1831.2">But because we want to track how long </span><strong class="source-inline"><span class="koboSpan" id="kobo.1832.1">Challenge</span></strong><span class="koboSpan" id="kobo.1833.1"> is waiting so that we can time it out, we need a helper class to abstract that detail away from </span><span class="No-Break"><span class="koboSpan" id="kobo.1834.1">the function.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1835.1">Don’t reinvent the wheel</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1836.1">The </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.1837.1">implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.1839.1"> is heavily based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1840.1">AckHandler</span></strong><span class="koboSpan" id="kobo.1841.1"> from the </span><strong class="bold"><span class="koboSpan" id="kobo.1842.1">Azure SignalR AckableChatRoom</span></strong><span class="koboSpan" id="kobo.1843.1"> sample. </span><span class="koboSpan" id="kobo.1843.2">The source for the sample is available </span><span class="No-Break"><span class="koboSpan" id="kobo.1844.1">at </span></span><a href="https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom"><span class="No-Break"><span class="koboSpan" id="kobo.1845.1">https://github.com/aspnet/AzureSignalR-samples/tree/main/samples/AckableChatRoom</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1846.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1847.1">Let’s </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.1848.1">create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.1850.1"> class by following </span><span class="No-Break"><span class="koboSpan" id="kobo.1851.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1852.1">Create a new folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1853.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.1854.1"> folder </span><span class="No-Break"><span class="koboSpan" id="kobo.1855.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1856.1">Handlers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1857.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1858.1">Create a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1859.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.1860.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1861.1">Handlers</span></strong><span class="koboSpan" id="kobo.1862.1"> folder, and change the access modifier from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1863.1">internal</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1864.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1865.1">public</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1866.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1867.1">Add a constructor for the class that has three parameters – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1868.1">completeAcksOnTimeout</span></strong><span class="koboSpan" id="kobo.1869.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1870.1">bool</span></strong><span class="koboSpan" id="kobo.1871.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1872.1">ackThreshold</span></strong><span class="koboSpan" id="kobo.1873.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1874.1">TimeSpan</span></strong><span class="koboSpan" id="kobo.1875.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">ackInterval</span></strong><span class="koboSpan" id="kobo.1877.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1878.1">TimeSpan</span></strong><span class="koboSpan" id="kobo.1879.1">. </span><span class="koboSpan" id="kobo.1879.2">The constructor will create a timer to periodically clear out old challenges and store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1880.1">ackThreshold</span></strong><span class="koboSpan" id="kobo.1881.1"> value in a class field. </span><span class="koboSpan" id="kobo.1881.2">The class’s contents should look </span><span class="No-Break"><span class="koboSpan" id="kobo.1882.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1883.1">
private readonly TimeSpan ackThreshold;private readonly Timer timer;
public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan ackInterval){    if (completeAcksOnTimeout)    {        timer = new Timer(_ =&gt; CheckAcks(), state: null, dueTime: ackInterval, period: ackInterval);    }    this.ackThreshold = ackThreshold;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1884.1">You will need to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1885.1">using</span></strong><span class="koboSpan" id="kobo.1886.1"> declaration for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1887.1">System.Threading</span></strong><span class="koboSpan" id="kobo.1888.1"> namespace to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1889.1">Timer</span></strong><span class="koboSpan" id="kobo.1890.1"> type. </span><span class="koboSpan" id="kobo.1890.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1891.1">CheckAcks</span></strong><span class="koboSpan" id="kobo.1892.1"> method will be created later in </span><span class="No-Break"><span class="koboSpan" id="kobo.1893.1">this section.</span></span></p></li> <li><span class="koboSpan" id="kobo.1894.1">To provide </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.1895.1">some reasonable defaults for the constructor, we will create a parameterless constructor and provide the defaults, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1896.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1897.1">
private readonly Timer timer;</span><strong class="bold"><span class="koboSpan" id="kobo.1898.1">
public ChallengeHandler() : this(    completeAcksOnTimeout: true,    ackThreshold: TimeSpan.FromSeconds(30),    ackInterval: TimeSpan.FromSeconds(1))    {    }</span></strong><span class="koboSpan" id="kobo.1899.1">
public ChallengeHandler(bool completeAcksOnTimeout, TimeSpan ackThreshold, TimeSpan ackInterval)</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1900.1">This will provide the default values to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1901.1">main constructor.</span></span></p></li> <li><span class="koboSpan" id="kobo.1902.1">Now, to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1903.1">Challenge</span></strong><span class="koboSpan" id="kobo.1904.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1905.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1906.1"> function will call a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1907.1">CreateChallenge</span></strong><span class="koboSpan" id="kobo.1908.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1909.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1910.1">
public (Guid id, Task&lt;Challenge&gt; responseTask) CreateChallenge(Player challenger, Player opponent){    var id = Guid.NewGuid();    var tcs = new TaskCompletionSource&lt;Challenge&gt;(TaskCreationOptions.RunContinuationsAsynchronously);    handlers.TryAdd(id, new(id, tcs, DateTime.UtcNow, new(id, challenger, opponent, ChallengeResponse.None)));    return (id, tcs.Task);}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1911.1">Add this method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.1913.1"> class, below the main constructor. </span><span class="koboSpan" id="kobo.1913.2">The method will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1914.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.1915.1"> to track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1916.1">Challenge</span></strong><span class="koboSpan" id="kobo.1917.1"> object. </span><span class="koboSpan" id="kobo.1917.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1918.1">Challenge</span></strong><span class="koboSpan" id="kobo.1919.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1920.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.1921.1"> instances are held by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1922.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1923.1">, which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.1924.1">like this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1925.1">private record struct ChallengeRecord(Guid Id, TaskCompletionSource&lt;Challenge&gt; ResponseTask, DateTime Created, Challenge Challenge);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1926.1">Add </span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.1927.1">this declaration to the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1928.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.1929.1"> class. </span><span class="koboSpan" id="kobo.1929.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.1930.1">record</span></strong><span class="koboSpan" id="kobo.1931.1"> has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1932.1">Id</span></strong><span class="koboSpan" id="kobo.1933.1"> value – for uniqueness, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1934.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.1935.1"> – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1936.1">DateTime</span></strong><span class="koboSpan" id="kobo.1937.1"> value to track the creation time, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1938.1">Challenge</span></strong><span class="koboSpan" id="kobo.1939.1"> object itself. </span><span class="koboSpan" id="kobo.1939.2">We keep a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1940.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1941.1"> instances in another field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1942.1">handlers</span></strong><span class="koboSpan" id="kobo.1943.1">. </span><span class="koboSpan" id="kobo.1943.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1944.1">handlers</span></strong><span class="koboSpan" id="kobo.1945.1"> field, which is declared right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1946.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1947.1"> class, is </span><span class="No-Break"><span class="koboSpan" id="kobo.1948.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1949.1">private readonly ConcurrentDictionary&lt;Guid, ChallengeRecord&gt; handlers = new();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1950.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">ConcurrentDictionary</span></strong><span class="koboSpan" id="kobo.1952.1"> since we may be accessing the field from several different threads at the same time. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1953.1">ConncurrentDictionary</span></strong><span class="koboSpan" id="kobo.1954.1"> is designed to prevent data corruption in multithreaded situations, like </span><span class="No-Break"><span class="koboSpan" id="kobo.1955.1">this one.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1956.1">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.1957.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.1958.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1959.1">Challenge</span></strong><span class="koboSpan" id="kobo.1960.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1961.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1962.1"> have been created, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1963.1">Challenge</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1964.1">Id</span></strong><span class="koboSpan" id="kobo.1965.1"> value and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1966.1">Task</span></strong><span class="koboSpan" id="kobo.1967.1"> value associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1968.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.1969.1"> are returned as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1970.1">Tuple</span></strong><span class="koboSpan" id="kobo.1971.1"> value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1972.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.1973.1"> function. </span><span class="koboSpan" id="kobo.1973.2">We will see what happens to that data later in this section when we complete the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1974.1">IssueChallege</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1975.1"> function.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.1976.1">Finally, to resolve the missing namespaces, add the following highlighted namespace declarations to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1977.1">ChallengeHandler</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1978.1">class file:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.1979.1">using SticksAndStones.Models;</span></strong><span class="koboSpan" id="kobo.1980.1">
using System;
</span><strong class="bold"><span class="koboSpan" id="kobo.1981.1">using System.Collections.Concurrent;</span></strong><span class="koboSpan" id="kobo.1982.1">
using System.Threading;
</span><strong class="bold"><span class="koboSpan" id="kobo.1983.1">using System.Threading.Tasks;</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1984.1">To acknowledge the challenge, either accepting it or declining it, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1985.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.1986.1"> function will call a method named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1987.1">Respond</span></strong><span class="koboSpan" id="kobo.1988.1">. </span><span class="koboSpan" id="kobo.1988.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1989.1">Respond</span></strong><span class="koboSpan" id="kobo.1990.1"> method will remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.1991.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1992.1"> from the dictionary, if it exists, and </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.1993.1">return the associate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1994.1">Challenge</span></strong><span class="koboSpan" id="kobo.1995.1">. </span><span class="koboSpan" id="kobo.1995.2">If there is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1996.1">ChallengeRecord</span></strong><span class="koboSpan" id="kobo.1997.1">, then a new empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">Challenge</span></strong><span class="koboSpan" id="kobo.1999.1"> record is returned, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2000.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2001.1">
public Challenge Respond(Guid id, ChallengeResponse response){    if (handlers.TryRemove(id, out var res))    {        var challenge = res.Challenge;        challenge.Response = response;        res.ResponseTask.TrySetResult(challenge);        return challenge;    }    return new Challenge();}</span></pre></li> <li><span class="koboSpan" id="kobo.2002.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2003.1">CheckAcks</span></strong><span class="koboSpan" id="kobo.2004.1"> method, which is called periodically to check for </span><strong class="source-inline"><span class="koboSpan" id="kobo.2005.1">Challenge</span></strong><span class="koboSpan" id="kobo.2006.1"> objects that have expired and have not been responded to, looks </span><span class="No-Break"><span class="koboSpan" id="kobo.2007.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2008.1">
private void CheckAcks(){    foreach (var pair in handlers)    {        var elapsed = DateTime.UtcNow - pair.Value.Created;        if (elapsed &gt; ackThreshold)        {            pair.Value.ResponseTask.TrySetException(new TimeoutException("Response time out"));        }    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2009.1">This method will iterate over all the pairs in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2010.1">handlers</span></strong><span class="koboSpan" id="kobo.2011.1"> dictionary. </span><span class="koboSpan" id="kobo.2011.2">For each one, it will determine whether the elapsed time is greater than the threshold provided in the constructor. </span><span class="koboSpan" id="kobo.2011.3">If it is, then the task fails with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2012.1">TimeOutException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2013.1"> error.</span></span></p></li> <li><span class="koboSpan" id="kobo.2014.1">To wrap </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.2015.1">up this class, we need to make sure that we clean up any remaining tasks when the service shuts down. </span><span class="koboSpan" id="kobo.2015.2">We will handle canceling tasks in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2016.1">Dispose</span></strong><span class="koboSpan" id="kobo.2017.1"> method, which is implemented via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2018.1">IDisposable</span></strong><span class="koboSpan" id="kobo.2019.1"> interface. </span><span class="koboSpan" id="kobo.2019.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2020.1">IDisposable</span></strong><span class="koboSpan" id="kobo.2021.1"> interface to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2022.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2023.1"> class and add the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.2024.1">Dispose</span></strong><span class="koboSpan" id="kobo.2025.1"> method to the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.2026.1">the class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2027.1">
public void Dispose(){    timer?.Dispose();    foreach (var pair in handlers)    {        pair.Value.ResponseTask.TrySetCanceled();    }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2028.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2029.1">Dispose</span></strong><span class="koboSpan" id="kobo.2030.1"> method will dispose of the timer since we don’t want that firing any longer. </span><span class="koboSpan" id="kobo.2030.2">Then, it iterates over the handlers and cancels each of </span><span class="No-Break"><span class="koboSpan" id="kobo.2031.1">the tasks.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2032.1">That should complete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2033.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2034.1"> class. </span><span class="koboSpan" id="kobo.2034.2">We can now resume the implementation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2035.1">IssueChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2036.1"> function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2037.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2038.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.2039.1"> file and locate the constructor, modifying it as highlighted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2040.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2041.1">
private readonly GameDbContext context;</span><strong class="bold"><span class="koboSpan" id="kobo.2042.1">private readonly ChallengeHandler challengeHandler;</span></strong><span class="koboSpan" id="kobo.2043.1">
public GameHub(GameDbContext dbcontext</span><strong class="bold"><span class="koboSpan" id="kobo.2044.1">, ChallengeHandler handler</span></strong><span class="koboSpan" id="kobo.2045.1">){    context = dbcontext;    </span><strong class="bold"><span class="koboSpan" id="kobo.2046.1">challengeHandler = handler;</span></strong><span class="koboSpan" id="kobo.2047.1">
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2048.1">Since we will need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2049.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2050.1"> class, and it needs to maintain state, we will use dependency injection and have the Azure Functions runtime supply us with </span><span class="No-Break"><span class="koboSpan" id="kobo.2051.1">the instance.</span></span></p></li> <li><span class="koboSpan" id="kobo.2052.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2053.1">Startup.cs</span></strong><span class="koboSpan" id="kobo.2054.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2055.1">SticksAndStones.Function</span></strong><span class="koboSpan" id="kobo.2056.1"> project and add the following line of code at the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2057.1">Configure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2058.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2059.1">
builder.Services.AddSingleton&lt;ChallengeHandler&gt;();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2060.1">This will </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.2061.1">register </span><strong class="source-inline"><span class="koboSpan" id="kobo.2062.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2063.1"> with dependency injection to allow the Azure Functions runtime to manage the instance creation </span><span class="No-Break"><span class="koboSpan" id="kobo.2064.1">and lifetime.</span></span></p></li> <li><span class="koboSpan" id="kobo.2065.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2066.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.2067.1"> file and navigate to the bottom of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2068.1">IssueChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2069.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.2070.1">Add the following lines </span><span class="No-Break"><span class="koboSpan" id="kobo.2071.1">of code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2072.1">
var challengeInfo = challengeHandler.CreateChallenge(challenger, opponent);log.LogInformation($"Challenge [{challengeInfo.id}] has been created.");
log.LogInformation($"Waiting on response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");await Clients.User(opponent.Id.ToString()).SendAsync(Constants.Events.Challenge, new ChallengeEventArgs(challengeInfo.id, challenger, opponent));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2073.1">This code will first call </span><strong class="source-inline"><span class="koboSpan" id="kobo.2074.1">CreateChallenge</span></strong><span class="koboSpan" id="kobo.2075.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2076.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2077.1"> instance that we are getting in the constructor. </span><strong class="source-inline"><span class="koboSpan" id="kobo.2078.1">challengeInfo</span></strong><span class="koboSpan" id="kobo.2079.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2080.1">Tuple</span></strong><span class="koboSpan" id="kobo.2081.1"> value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2082.1">Challenge</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.2083.1">Id</span></strong><span class="koboSpan" id="kobo.2084.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.2085.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2086.1">task</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2087.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2088.1">Next, the opponent is sent a SignalR </span><strong class="source-inline"><span class="koboSpan" id="kobo.2089.1">Challenge</span></strong><span class="koboSpan" id="kobo.2090.1"> message with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2091.1">ChallengeEventArgs</span></strong><span class="koboSpan" id="kobo.2092.1">. </span><span class="koboSpan" id="kobo.2092.2">This message is sent slightly differently since this message will only be sent to the client that matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.2093.1">opponent’s </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2094.1">Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2095.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.2096.1">Now, we </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.2097.1">need to wait for the opponent’s response, or a timeout from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2098.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2099.1">, by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.2100.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2101.1">
ChallengeResponse response;try {    var challenge = await challengeInfo.responseTask.ConfigureAwait(false);    log.LogInformation($"Got response from {opponent.GamerTag} for challenge[{challengeInfo.id}].");    response = challenge.Response;}catch {    log.LogInformation($"Never received a response from {opponent.GamerTag} for challenge[{challengeInfo.id}], it timed out.");    response = ChallengeResponse.TimeOut;}return new(response);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2102.1">The real trick in this code is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2103.1">challengeInfo.responseTask</span></strong><span class="koboSpan" id="kobo.2104.1"> await. </span><strong class="source-inline"><span class="koboSpan" id="kobo.2105.1">responseTask</span></strong><span class="koboSpan" id="kobo.2106.1"> is the task that is created as part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2107.1">TaskCompletionSource</span></strong><span class="koboSpan" id="kobo.2108.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.2109.1">ChallengeHandler</span></strong><span class="koboSpan" id="kobo.2110.1">. </span><span class="koboSpan" id="kobo.2110.2">By awaiting it, we do not continue until either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2111.1">Respond</span></strong><span class="koboSpan" id="kobo.2112.1"> method is called and the task is completed, or the task is failed by setting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2113.1">TimeoutException</span></strong><span class="koboSpan" id="kobo.2114.1"> error in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2115.1">CheckAcks</span></strong><span class="koboSpan" id="kobo.2116.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.2117.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2118.1">ChallengeHandler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2119.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2120.1">Once one of those conditions is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2121.1">true</span></strong><span class="koboSpan" id="kobo.2122.1">, the method completes and we can get the response from the returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.2123.1">Challenge</span></strong><span class="koboSpan" id="kobo.2124.1">, or in the case of a timeout, handle the exception and return the response to the client in a new instance </span><span class="No-Break"><span class="koboSpan" id="kobo.2125.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2126.1">IssueChallengeResponse</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2127.1">.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2128.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2129.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.2130.1"> function is now complete. </span><span class="koboSpan" id="kobo.2130.2">The client can call the function and it will send a message to the opponent’s client and wait for the response. </span><span class="koboSpan" id="kobo.2130.3">If the opponent </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.2131.1">client does not respond in a defined amount of time, which is 30 seconds by default, then the challenge will time out. </span><span class="koboSpan" id="kobo.2131.2">Now, let’s work on accepting or declining a challenge. </span><span class="koboSpan" id="kobo.2131.3">As with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2132.1">Connect</span></strong><span class="koboSpan" id="kobo.2133.1"> function, you can try it out using the command line. </span><span class="koboSpan" id="kobo.2133.2">You just need to connect two players, and then have one challenge </span><span class="No-Break"><span class="koboSpan" id="kobo.2134.1">the other!</span></span></p>
<h3><span class="koboSpan" id="kobo.2135.1">Creating the AcknowledgeChallenge function</span></h3>
<p><span class="koboSpan" id="kobo.2136.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2137.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.2138.1"> function is used by the client to respond to an open challenge </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.2139.1">from another player. </span><span class="koboSpan" id="kobo.2139.2">Let’s create the function by following </span><span class="No-Break"><span class="koboSpan" id="kobo.2140.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2141.1">Add a new function to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2142.1">GameHub</span></strong><span class="koboSpan" id="kobo.2143.1"> class, </span><span class="No-Break"><span class="koboSpan" id="kobo.2144.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2145.1">
[FunctionName("AcknowledgeChallenge")]public async Task AcknowledgeChallenge(    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Challenge/Ack")] HttpRequest req,    ILogger log)
{}</span></pre></li> <li><span class="koboSpan" id="kobo.2146.1">In the body of the function, deserialize the arguments using the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.2147.1">of code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2148.1">
var result = await JsonSerializer.DeserializeAsync&lt;AcknowledgeChallengeRequest&gt;(req.Body, jsonOptions);</span></pre></li> <li><span class="koboSpan" id="kobo.2149.1">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.2150.1">challengeHandler</span></strong><span class="koboSpan" id="kobo.2151.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2152.1">Respond</span></strong><span class="koboSpan" id="kobo.2153.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.2154.1">the challenge:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2155.1">
var challenge = challengeHandler.Respond(result.Id, result.Response);if (challenge.Id == Guid.Empty){    return;}</span></pre></li> <li><span class="koboSpan" id="kobo.2156.1">If the </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.2157.1">response is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2158.1">Declined</span></strong><span class="koboSpan" id="kobo.2159.1">, then just log </span><span class="No-Break"><span class="koboSpan" id="kobo.2160.1">a message:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2161.1">
var challenger = challenge.Challenger;var opponent = challenge.Opponent;if (result.Response == ChallengeResponse.Declined){    log.LogInformation($"{opponent.GamerTag} has declined the challenge from {challenger.GamerTag}!");}</span></pre></li> <li><span class="koboSpan" id="kobo.2162.1">If the response is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2163.1">Accepted</span></strong><span class="koboSpan" id="kobo.2164.1">, then create a match and notify </span><span class="No-Break"><span class="koboSpan" id="kobo.2165.1">the players:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2166.1">
if (result.Response == ChallengeResponse.Accepted)
{
    log.LogInformation($"{opponent.GamerTag} has accepted the challenge from {challenger.GamerTag}!");
    using var context = contextFactory.CreateDbContext();
    var game = Match.New(challenger.Id, opponent.Id);
    context.Matches.Add(game);
    opponent.MatchId = challenger.MatchId = match.Id;
    context.Players.Update(opponent);
    context.Players.Update(challenger);
    context.SaveChanges();
    log.LogInformation($"Created match {match.Id} between {opponent.GamerTag} and {challenger.GamerTag}!");
    // Create Group for Game
    await UserGroups.AddToGroupAsync(opponent.Id.ToString(), $"Match[{match.Id}]");
    await UserGroups.AddToGroupAsync(challenger.Id.ToString(), $"Match[{match.Id}]");
    await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchStarted, new MatchStartedEventArgs(match));
    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(opponent));
    await Clients.All.SendAsync(Constants.Events.PlayerUpdated, new PlayerUpdatedEventArgs(challenger));
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2167.1">So, ignoring all the logging, since that is non-functional, the preceding code starts by </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.2168.1">creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.2169.1">Match</span></strong><span class="koboSpan" id="kobo.2170.1"> instance and assigning </span><strong class="source-inline"><span class="koboSpan" id="kobo.2171.1">PlayerOneId</span></strong><span class="koboSpan" id="kobo.2172.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2173.1">PlayerTwoId</span></strong><span class="koboSpan" id="kobo.2174.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2175.1">NextPlayerId</span></strong><span class="koboSpan" id="kobo.2176.1">. </span><span class="koboSpan" id="kobo.2176.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2177.1">Match</span></strong><span class="koboSpan" id="kobo.2178.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.2179.1">Id</span></strong><span class="koboSpan" id="kobo.2180.1"> property is then assigned to both of the players, and all the changes are saved to </span><span class="No-Break"><span class="koboSpan" id="kobo.2181.1">the database.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2182.1">Next, is the SignalR messages. </span><span class="koboSpan" id="kobo.2182.2">First, we create a SignalR group with just the two players in it and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2183.1">Match</span></strong><span class="koboSpan" id="kobo.2184.1"> object’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.2185.1">Id</span></strong><span class="koboSpan" id="kobo.2186.1"> property in the name. </span><span class="koboSpan" id="kobo.2186.2">This way we can send messages to the group and both players will </span><span class="No-Break"><span class="koboSpan" id="kobo.2187.1">receive them.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2188.1">The first message we will send will indicate the start of a new game and it will send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2189.1">match</span></strong><span class="koboSpan" id="kobo.2190.1"> instance wrapped </span><span class="No-Break"><span class="koboSpan" id="kobo.2191.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2192.1">MatchStartedEventArgs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2193.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.2194.1">Finally, we send a message for each player to all players, indicating a change in </span><span class="No-Break"><span class="koboSpan" id="kobo.2195.1">their status.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2196.1">That completes the functionality for one player to challenge another player to a match of Sticks and Stones! </span><span class="koboSpan" id="kobo.2196.2">It’s time to move on to playing a match. </span><span class="koboSpan" id="kobo.2196.3">But first, we will need a function to return the game to </span><span class="No-Break"><span class="koboSpan" id="kobo.2197.1">the player.</span></span></p>
<h3><span class="koboSpan" id="kobo.2198.1">Getting the match</span></h3>
<p><span class="koboSpan" id="kobo.2199.1">You may be wondering why we need this functionality since, in the previous function, we sent the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2200.1">Match</span></strong><span class="koboSpan" id="kobo.2201.1"> object to both players through a SignalR message. </span><span class="koboSpan" id="kobo.2201.2">The answer is rather simple – if the user accidentally closes the Sticks and Stones app while in the middle of a game, then when they </span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.2202.1">return to the Sticks and Stones app and log back in, the app will detect that they are still in a match and navigate to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2203.1">Match</span></strong><span class="koboSpan" id="kobo.2204.1"> page. </span><span class="koboSpan" id="kobo.2204.2">It will use this function to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2205.1">Match</span></strong><span class="koboSpan" id="kobo.2206.1"> object in this case since it wasn’t sent during </span><strong class="source-inline"><span class="koboSpan" id="kobo.2207.1">Connect</span></strong><span class="koboSpan" id="kobo.2208.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2209.1">just </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2210.1">Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2211.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2212.1">So, let’s create a function to return a game by its </span><strong class="source-inline"><span class="koboSpan" id="kobo.2213.1">Id</span></strong><span class="koboSpan" id="kobo.2214.1">, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.2215.1">the messages.</span></span></p>
<h3><span class="koboSpan" id="kobo.2216.1">Creating the messages</span></h3>
<p><span class="koboSpan" id="kobo.2217.1">This function </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.2218.1">will only need a response message object. </span><span class="koboSpan" id="kobo.2218.2">Unlike the previous functions, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2219.1">GetMatch</span></strong><span class="koboSpan" id="kobo.2220.1"> function will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2221.1">Http</span></strong><span class="koboSpan" id="kobo.2222.1"> GET method, and we will pass the match </span><strong class="source-inline"><span class="koboSpan" id="kobo.2223.1">Id</span></strong><span class="koboSpan" id="kobo.2224.1"> value as part of the URL. </span><span class="koboSpan" id="kobo.2224.2">The response from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2225.1">GetGame</span></strong><span class="koboSpan" id="kobo.2226.1"> function will be the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2227.1">Match</span></strong><span class="koboSpan" id="kobo.2228.1"> instance. </span><span class="koboSpan" id="kobo.2228.2">To create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2229.1">GetGameResponse</span></strong><span class="koboSpan" id="kobo.2230.1"> message, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.2231.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2232.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2233.1">SticksAndStones.Shared</span></strong><span class="koboSpan" id="kobo.2234.1"> project, create a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2235.1">GetGameMessages.cs</span></strong><span class="koboSpan" id="kobo.2236.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2237.1">Messages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2238.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.2239.1">Modify the contents of the file so that it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.2240.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2241.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct GetMatchResponse(Match Match);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2242.1">With the response message class in place, we can create the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2243.1">GetMatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2244.1"> function.</span></span></p>
<h3><span class="koboSpan" id="kobo.2245.1">Getting a match by its ID</span></h3>
<p><span class="koboSpan" id="kobo.2246.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2247.1">GetMatch</span></strong><span class="koboSpan" id="kobo.2248.1"> function will accept a single integer named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2249.1">id</span></strong><span class="koboSpan" id="kobo.2250.1"> as a parameter. </span><span class="koboSpan" id="kobo.2250.2">The parameter </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.2251.1">is bound to a part of the URL that’s used to call the function. </span><span class="koboSpan" id="kobo.2251.2">Let’s look at an example. </span><span class="koboSpan" id="kobo.2251.3">If we wanted to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.2252.1">Match</span></strong><span class="koboSpan" id="kobo.2253.1"> identified by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2254.1">Guid</span></strong><span class="koboSpan" id="kobo.2255.1"> type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2256.1">c39c7490-f4bc-425a-84ab-0a4ad916ea48</span></strong><span class="koboSpan" id="kobo.2257.1">, then the URL would </span><span class="No-Break"><span class="koboSpan" id="kobo.2258.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2259.1">http://localhost:7024/api/Game/c39c7490-f4bc-425a-84ab-0a4ad916ea48</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2260.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.2261.1">Follow these steps to implement the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2262.1">GetMatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2263.1"> function:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2264.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2265.1">GameHub.cs</span></strong><span class="koboSpan" id="kobo.2266.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2267.1">Hubs</span></strong><span class="koboSpan" id="kobo.2268.1"> folder of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2269.1">SticksAndStones.Functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2270.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.2271.1">Add the following method declaration after the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2272.1">AcknowledgeChallenge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2273.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2274.1">
[FunctionName("GetMatch")]
public IActionResult GetMatch(
[HttpTrigger(AuthorizationLevel.Function, "get", Route = 
"Match/{id}")] HttpRequest req,
    Guid id,    ILogger log){}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2275.1">There are a few differences from the other functions. </span><span class="koboSpan" id="kobo.2275.2">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2276.1">Http</span></strong><span class="koboSpan" id="kobo.2277.1"> method that’s used is </span><strong class="source-inline"><span class="koboSpan" id="kobo.2278.1">"get"</span></strong><span class="koboSpan" id="kobo.2279.1">, not </span><strong class="source-inline"><span class="koboSpan" id="kobo.2280.1">"post"</span></strong><span class="koboSpan" id="kobo.2281.1">. </span><span class="koboSpan" id="kobo.2281.2">Second, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2282.1">Route</span></strong><span class="koboSpan" id="kobo.2283.1"> is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2284.1">"Game/{id}"</span></strong><span class="koboSpan" id="kobo.2285.1">; </span><strong class="source-inline"><span class="koboSpan" id="kobo.2286.1">{id}</span></strong><span class="koboSpan" id="kobo.2287.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.2288.1">Route</span></strong><span class="koboSpan" id="kobo.2289.1"> tells the Azure Functions runtime that this function has a parameter named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2290.1">id</span></strong><span class="koboSpan" id="kobo.2291.1"> and that the value in that position of the URL should be passed in as an argument. </span><span class="koboSpan" id="kobo.2291.2">You can see that the third change is that there is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.2292.1">id</span></strong><span class="koboSpan" id="kobo.2293.1"> parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2294.1">Guid</span></strong><span class="koboSpan" id="kobo.2295.1"> type. </span><span class="koboSpan" id="kobo.2295.2">This means that whatever is on the URL in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2296.1">{id}</span></strong><span class="koboSpan" id="kobo.2297.1"> position must be able to be converted into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2298.1">Guid</span></strong><span class="koboSpan" id="kobo.2299.1"> type; otherwise, the Azure Functions runtime will return an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.2300.1">500 Internal </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2301.1">Server</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2302.1"> error.</span></span></p></li> <li><span class="koboSpan" id="kobo.2303.1">To query our database for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2304.1">Match</span></strong><span class="koboSpan" id="kobo.2305.1"> object that matches the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2306.1">id</span></strong><span class="koboSpan" id="kobo.2307.1"> value, use the following lines </span><span class="No-Break"><span class="koboSpan" id="kobo.2308.1">of code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2309.1">
using var context = contextFactory.CreateDbContext();Match match = (from m in context.Matches where m.Id == id select m).FirstOrDefault();</span></pre></li> <li><span class="koboSpan" id="kobo.2310.1">If the method gets this far, then it has been completed successfully, so we can return </span><strong class="source-inline"><span class="koboSpan" id="kobo.2311.1">OkObjectResult</span></strong><span class="koboSpan" id="kobo.2312.1">. </span><span class="koboSpan" id="kobo.2312.2">The object that’s returned will be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2313.1">GetMatchResponse</span></strong><span class="koboSpan" id="kobo.2314.1"> instance with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2315.1">Match</span></strong><span class="koboSpan" id="kobo.2316.1"> instance that was found, </span><span class="No-Break"><span class="koboSpan" id="kobo.2317.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2318.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2319.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2320.1">
return new OkObjectResult(new GetMatchResponse(match));</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2321.1">Since this </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.2322.1">function uses the HTTP GET method, you can test it out in your </span><span class="No-Break"><span class="koboSpan" id="kobo.2323.1">favorite browser:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2324.1">Press </span><em class="italic"><span class="koboSpan" id="kobo.2325.1">F5</span></em><span class="koboSpan" id="kobo.2326.1"> to start the project in </span><span class="No-Break"><span class="koboSpan" id="kobo.2327.1">debug mode.</span></span></li>
<li><span class="koboSpan" id="kobo.2328.1">Wait for txhe service to start, then copy the URL for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2329.1">GetMatch</span></strong><span class="koboSpan" id="kobo.2330.1"> function from the output window – for example, http://localhost:####/api/Game/{id}, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.2331.1">###</span></strong><span class="koboSpan" id="kobo.2332.1"> is your </span><span class="No-Break"><span class="koboSpan" id="kobo.2333.1">port number.</span></span></li>
<li><span class="koboSpan" id="kobo.2334.1">Open your browser and paste the URL in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2335.1">address bar.</span></span></li>
<li><span class="koboSpan" id="kobo.2336.1">Change </span><strong class="source-inline"><span class="koboSpan" id="kobo.2337.1">{id}</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2338.1">to anything.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2339.1">Press </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2340.1">Enter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2341.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.2342.1">You should get an error page in your browser. </span><span class="koboSpan" id="kobo.2342.2">Try a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.2343.1">Guid</span></strong><span class="koboSpan" id="kobo.2344.1"> value such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.2345.1">c39c7490-f4bc-425a-84ab-0a4ad916ea48</span></strong><span class="koboSpan" id="kobo.2346.1">. </span><span class="koboSpan" id="kobo.2346.2">You should get a response similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.2347.1">the following:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2348.1">
{    "match": null }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2349.1">Since there are no active games, you won’t be able to retrieve an actual </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2350.1">Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2351.1"> instance.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2352.1">Now that we can retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2353.1">Match</span></strong><span class="koboSpan" id="kobo.2354.1"> object, we will tackle how players make and receive moves and how to determine the score and winner of </span><span class="No-Break"><span class="koboSpan" id="kobo.2355.1">the game.</span></span></p>
<h3><span class="koboSpan" id="kobo.2356.1">Playing the game</span></h3>
<p><span class="koboSpan" id="kobo.2357.1">Sticks and Stones is an interactive, fast-paced, turn-based game. </span></p>
<p><span class="koboSpan" id="kobo.2358.1">Let's review the following diagram to get a better understanding of what we </span><span class="No-Break"><span class="koboSpan" id="kobo.2359.1">are building:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer159">
<span class="koboSpan" id="kobo.2360.1"><img alt="Figure 9.11 – Processing turns" src="image/B19214_09_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2361.1">Figure 9.11 – Processing turns</span></p>
<p><span class="koboSpan" id="kobo.2362.1">Once a match has started, players will take turns choosing a location to place one of their sticks. </span><span class="koboSpan" id="kobo.2362.2">The client </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.2363.1">application will then send a message to the GameHub’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.2364.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2365.1"> function. </span><span class="koboSpan" id="kobo.2365.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2366.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2367.1"> function will then validate the move, recalculate the score, check for a winner, and finally, send an update to </span><span class="No-Break"><span class="koboSpan" id="kobo.2368.1">the players.</span></span></p>
<h4><span class="koboSpan" id="kobo.2369.1">Creating the ProcessTurn messages and models</span></h4>
<p><span class="koboSpan" id="kobo.2370.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2371.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2372.1"> function has three parameters – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2373.1">Match Id</span></strong><span class="koboSpan" id="kobo.2374.1">, the player making the move, and </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.2375.1">the position of the move. </span><span class="koboSpan" id="kobo.2375.2">The function will return an updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.2376.1">Match</span></strong><span class="koboSpan" id="kobo.2377.1"> instance. </span><span class="koboSpan" id="kobo.2377.2">Follow these steps to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2378.1">ProcessTurn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2379.1"> messages:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2380.1">Add a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2381.1">ProcessTurnMessages.cs</span></strong><span class="koboSpan" id="kobo.2382.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2383.1">Messages</span></strong><span class="koboSpan" id="kobo.2384.1"> folder in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2385.1">SticksAndStones.Shared</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2386.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.2387.1">Modify the contents of the file so that it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.2388.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2389.1">
using SticksAndStones.Models;using System;namespace SticksAndStones.Messages;public record struct ProcessTurnRequest(Guid MatchId, Player Player, int Position);
public record struct ProcessTurnResponse(Match Match);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2390.1">As part of the turn, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2391.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2392.1"> will send the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.2393.1">Match</span></strong><span class="koboSpan" id="kobo.2394.1"> instance to the players. </span><span class="koboSpan" id="kobo.2394.2">This will require a new SignalR event. </span><span class="koboSpan" id="kobo.2394.3">Perform the following steps to </span><span class="No-Break"><span class="koboSpan" id="kobo.2395.1">add it:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2396.1">SaveMatchAndSendUpdates</span></strong><span class="koboSpan" id="kobo.2397.1"> sends a new event via SignalR to the clients, so we need to add that to our constants. </span><span class="koboSpan" id="kobo.2397.2">Add the highlighted code in the following snippet to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2398.1">Constants.cs</span></strong><span class="koboSpan" id="kobo.2399.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2400.1">SticksAndStones.Shared</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2401.1"> project:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2402.1">
    public static class Events     {        public static readonly string PlayerUpdated = nameof(PlayerUpdated);        public static readonly string Challenge = nameof(Challenge);        public static readonly string MatchStarted = nameof(MatchStarted);
        public static readonly string MatchUpdated = nameof(MatchUpdated);
    }</span></pre></li> <li><span class="koboSpan" id="kobo.2403.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2404.1">MatchUpdatedEventArgs</span></strong><span class="koboSpan" id="kobo.2405.1"> class that we used to send the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.2406.1">Match</span></strong><span class="koboSpan" id="kobo.2407.1"> to the players when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2408.1">MatchUpdated</span></strong><span class="koboSpan" id="kobo.2409.1"> event is set by adding a new file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2410.1">MatchUpdatedEventArgs.cs</span></strong><span class="koboSpan" id="kobo.2411.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2412.1">Messages</span></strong><span class="koboSpan" id="kobo.2413.1"> folder in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2414.1">SticksAndStones.Shared</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2415.1"> project.</span></span></li>
<li><span class="koboSpan" id="kobo.2416.1">Modify the contents of the file so that it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.2417.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2418.1">
using SticksAndStones.Models;namespace SticksAndStones.Messages;public record struct MatchUpdatedEventArgs(Match Match);</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2419.1">That </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.2420.1">concludes the additional models, events, and messages that are used by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2421.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2422.1"> function. </span><span class="koboSpan" id="kobo.2422.2">Next, we can start working on the ProcessTurn (</span><span class="No-Break"><span class="koboSpan" id="kobo.2423.1">P-Code) function.</span></span></p>
<h4><span class="koboSpan" id="kobo.2424.1">Processing turns</span></h4>
<p><span class="koboSpan" id="kobo.2425.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2426.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2427.1"> function </span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.2428.1">has a few responsibilities. </span><span class="koboSpan" id="kobo.2428.2">It will need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.2429.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2430.1">Validate </span><span class="No-Break"><span class="koboSpan" id="kobo.2431.1">the turn</span></span></li>
<li><span class="koboSpan" id="kobo.2432.1">Make the necessary changes to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2433.1">Match</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2434.1"> object</span></span></li>
<li><span class="koboSpan" id="kobo.2435.1">Recalculate </span><span class="No-Break"><span class="koboSpan" id="kobo.2436.1">the score</span></span></li>
<li><span class="koboSpan" id="kobo.2437.1">Determine whether there is </span><span class="No-Break"><span class="koboSpan" id="kobo.2438.1">a winner</span></span></li>
<li><span class="koboSpan" id="kobo.2439.1">Notify </span><span class="No-Break"><span class="koboSpan" id="kobo.2440.1">the players</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2441.1">To start the </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.2442.1">implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2443.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2444.1"> function, we will create stubs for each of the methods that we will call when processing a turn. </span><span class="koboSpan" id="kobo.2444.2">Follow these steps to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.2445.1">method stubs:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2446.1">Add a new method declaration to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2447.1">GameHub</span></strong><span class="koboSpan" id="kobo.2448.1"> class for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2449.1">ProcessTurn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2450.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2451.1">
[FunctionName("ProcessTurn")]public async Task&lt;IActionResult&gt; ProcessTurn(
    [HttpTrigger(AuthorizationLevel.Function, "post", Route = $"Game/Move")] HttpRequest req,
    ILogger log)
{}</span></pre></li> <li><span class="koboSpan" id="kobo.2452.1">Add a new method declaration </span><span class="No-Break"><span class="koboSpan" id="kobo.2453.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2454.1">ValidateProcessTurnRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2455.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2456.1">
private Exception ValidateProcessTurnRequest(ProcessTurnRequest args)
{    return null;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2457.1">The method accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.2458.1">ProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2459.1"> as the only argument. </span><span class="koboSpan" id="kobo.2459.2">If there are no errors in the arguments, then it will default to returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.2460.1">null</span></strong><span class="koboSpan" id="kobo.2461.1">. </span><span class="koboSpan" id="kobo.2461.2">If there is an error, then it will return an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2462.1">Exception</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2463.1"> error.</span></span></p></li> <li><span class="koboSpan" id="kobo.2464.1">We will use another method to verify the match state before processing the move. </span><span class="koboSpan" id="kobo.2464.2">Create a new method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2465.1">GameHub</span></strong><span class="koboSpan" id="kobo.2466.1"> class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.2467.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2468.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2469.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2470.1">
private Exception VerifyMatchState(Match match, ProcessTurnRequest args)
{    return null;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2471.1">Just like with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2472.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2473.1">, we will return </span><strong class="source-inline"><span class="koboSpan" id="kobo.2474.1">null</span></strong><span class="koboSpan" id="kobo.2475.1"> for the error if everything is okay; otherwise, we will return </span><span class="No-Break"><span class="koboSpan" id="kobo.2476.1">an error.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.2477.1">Now that we </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.2478.1">have the helper method signatures in place, let’s implement them, starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2479.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2480.1">. </span><span class="koboSpan" id="kobo.2480.2">Follow these steps to add the implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.2481.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2482.1">ValidateProcessTurnRequest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2483.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2484.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2485.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2486.1">, add the following at the top of the method to check for a </span><span class="No-Break"><span class="koboSpan" id="kobo.2487.1">valid position:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2488.1">
if (args.Position &lt;= 0 || args.Position &gt; 23)
{
    return new IndexOutOfRangeException("Position is out of range, must be between 1 and 24");}</span></pre></li> <li><span class="koboSpan" id="kobo.2489.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2490.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2491.1">, add the following at the top of the method to check for a </span><span class="No-Break"><span class="koboSpan" id="kobo.2492.1">valid player:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2493.1">
if (args.Player is null){    return new ArgumentException("Invalid Player");}</span></pre></li> <li><span class="koboSpan" id="kobo.2494.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2495.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2496.1">, add the following at the top of the method to check for a valid game </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2497.1">Id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2498.1"> value:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2499.1">
if (args.MatchId == Guid.Empty){
    return new ArgumentException("Invalid MatchId");}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2500.1">That </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.2501.1">completes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2502.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2503.1"> method. </span><span class="koboSpan" id="kobo.2503.2">Now, we can add the code to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2504.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2505.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2506.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2507.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2508.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2509.1">, add the following at the top of the method to check that the position hasn’t already </span><span class="No-Break"><span class="koboSpan" id="kobo.2510.1">been played:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2511.1">
if (match.Sticks[args.Position] != 0){    return new ArgumentException($"Position [{args.Position}] has already been played");}</span></pre></li> <li><span class="koboSpan" id="kobo.2512.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2513.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2514.1">, add the following at the top of the method to check that the correct player is taking </span><span class="No-Break"><span class="koboSpan" id="kobo.2515.1">their turn:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2516.1">
if (args.Player.Id != game.NextPlayerId){    return new ArgumentException($"It is not {args.Player.GamerTag}'s turn");}</span></pre></li> <li><span class="koboSpan" id="kobo.2517.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2518.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2519.1">, add the following at the top of the method to check that the game isn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.2520.1">over already:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2521.1">
if (match.WinnerId != Guid.Empty){    return new ArgumentException("Match is complete");}</span></pre></li> <li><span class="koboSpan" id="kobo.2522.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.2523.1">VerifyMatchState</span></strong><span class="koboSpan" id="kobo.2524.1">, add the following at the top of the method to check that the game </span><span class="No-Break"><span class="koboSpan" id="kobo.2525.1">object exists:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2526.1">
if (match is null)
{
    return new ArgumentException("Invalid MatchId");
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2527.1">Now that </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.2528.1">we have created these helper methods, we can implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2529.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2530.1"> method by following </span><span class="No-Break"><span class="koboSpan" id="kobo.2531.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2532.1">Deserialize the arguments that are passed to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2533.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2534.1"> function using </span><strong class="source-inline"><span class="koboSpan" id="kobo.2535.1">JsonSerializer</span></strong><span class="koboSpan" id="kobo.2536.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2537.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2538.1">
var args = await JsonSerializer.DeserializeAsync&lt;ProcessTurnRequest&gt;(req.Body, jsonOptions);</span></pre></li> <li><span class="koboSpan" id="kobo.2539.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2540.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2541.1"> method, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.2542.1">ValidateProcessTurnRequest</span></strong><span class="koboSpan" id="kobo.2543.1">. </span><span class="koboSpan" id="kobo.2543.2">If there is an error, we can handle it, </span><span class="No-Break"><span class="koboSpan" id="kobo.2544.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2545.1">
var error = ValidateProcessTurnRequest(args);
if (error is not null)
{
    log.LogError(error, "Error validating turn request");
    return new BadRequestObjectResult(error);
}</span></pre></li> <li><span class="koboSpan" id="kobo.2546.1">With the arguments verified, we can query the database for the game, and fail if it </span><span class="No-Break"><span class="koboSpan" id="kobo.2547.1">doesn’t exist:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2548.1">
using var context = contextFactory.CreateDbContext();
var game = (from g in context.Matches where m.Id == args.MatchId select m).FirstOrDefault() ?? </span><span class="koboSpan" id="kobo.2548.2">throw new ArgumentException("Invalid MatchId.");</span></pre></li> <li><span class="koboSpan" id="kobo.2549.1">Now, we can call </span><strong class="source-inline"><span class="koboSpan" id="kobo.2550.1">VerifyGameState</span></strong><span class="koboSpan" id="kobo.2551.1">. </span><span class="koboSpan" id="kobo.2551.2">If there is an error, we can handle it, </span><span class="No-Break"><span class="koboSpan" id="kobo.2552.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2553.1">
error = VerifyGameState(game, args);
if (error is not null)
{
    log.LogError(error, "Error validating game state");
    return new BadRequestObjectResult(error);
}</span></pre></li> <li><span class="koboSpan" id="kobo.2554.1">We must </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.2555.1">do one final check before making the move and updating the scores – we need to check to see whether the player made their selection before their turn expired using the </span><span class="No-Break"><span class="koboSpan" id="kobo.2556.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2557.1">
if (turnHandler.EndTurn(args.GameId) == TurnHandler.TurnStatus.Forfeit)
{
    error = new ArgumentException($"The turn has expired.");
    log.LogError(error, $"Player did not respond in the time alloted.");
    return new BadRequestObjectResult(error);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2558.1">With the validation of the input and game out of the way, we can now focus on applying the player’s move to the current state of the game, updating the score, and determining a winner. </span><span class="koboSpan" id="kobo.2558.2">To make the code for updating the score simpler, we will need a complex data structure. </span><span class="koboSpan" id="kobo.2558.3">Let’s explore </span><span class="No-Break"><span class="koboSpan" id="kobo.2559.1">this further.</span></span></p>
<p><span class="koboSpan" id="kobo.2560.1">When a player chooses a location to place one of their sticks, it may complete a square. </span><span class="koboSpan" id="kobo.2560.2">If it does, then the player who placed the stick gets the square and an additional five points. </span><span class="koboSpan" id="kobo.2560.3">The trick is how to determine that a stick has completed a square. </span><span class="koboSpan" id="kobo.2560.4">We are storing the state of all sticks and stones as an array of integers. </span><span class="koboSpan" id="kobo.2560.5">What we need is a map from a stone index (0–8) to the sticks that make up its sides. </span><span class="koboSpan" id="kobo.2560.6">But we can simplify the logic a bit more once we know what sticks make up a square since we are only interested in a single stick, and a single stick can complete, at most, two squares. </span><span class="koboSpan" id="kobo.2560.7">So, we can now have a structure </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.2561.1">that maps each stick position (0–23) to an array of tuples. </span><span class="koboSpan" id="kobo.2561.2">Each tuple has an integer that is the index for the stone and another integer array that is the other three stick indexes that make up </span><span class="No-Break"><span class="koboSpan" id="kobo.2562.1">the square.</span></span></p>
<p><span class="koboSpan" id="kobo.2563.1">Let’s use an example to illustrate this. </span><span class="koboSpan" id="kobo.2563.2">Pretend that we have a game that’s in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2564.1">following state:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.2565.1"><img alt="Figure 9.12 – Sample view of the board game" src="image/B19214_09_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2566.1">Figure 9.12 – Sample view of the board game</span></p>
<p><span class="koboSpan" id="kobo.2567.1">Now, pretend </span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.2568.1">that a player has chosen to place their stick at location 9, highlighted </span><span class="No-Break"><span class="koboSpan" id="kobo.2569.1">in aqua:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.2570.1"><img alt="Figure 9.13 – Board game with stick placement highlighted" src="image/B19214_09_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2571.1">Figure 9.13 – Board game with stick placement highlighted</span></p>
<p><span class="koboSpan" id="kobo.2572.1">We will </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.2573.1">only need to check the two squares highlighted in brown. </span><span class="koboSpan" id="kobo.2573.2">This means that we need to check whether there are sticks in positions 2, 5, and 6 for the stone in the upper brown box, and 12, 13, and 16 for the stone in the lower </span><span class="No-Break"><span class="koboSpan" id="kobo.2574.1">brown box.</span></span></p>
<p><span class="koboSpan" id="kobo.2575.1">This means we need two tuples – one for stone 2 and a second for stone 5 – each with an array of integers of the sides – f example, { (2, {2, 5, 6} ), (5, {12, 13, 16) }. </span><span class="koboSpan" id="kobo.2575.2">Using that data, we can check the two possible squares that could be completed by placing a stick at </span><span class="No-Break"><span class="koboSpan" id="kobo.2576.1">position 9.</span></span></p>
<p><span class="koboSpan" id="kobo.2577.1">Using old-fashioned sticky notes with a pencil and eraser, we can determine that the complete mapping will look </span><span class="No-Break"><span class="koboSpan" id="kobo.2578.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.2579.1">
(int stone, int[] sticks)[][] stickToStoneMap = new (int, int[])[][] {/* 1 */ new (int, int[])[] { (1, new int[] { 4, 5, 8}), (0, new int[] { 0, 0, 0})},/* 2 */ new (int, int[])[] { (2, new int[] { 5, 6, 9}), (0, new int[] { 0, 0, 0})},/* 3 */ new (int, int[])[] { (3, new int[] { 6, 7,10}), (0, new int[] { 0, 0, 0})},/* 4 */ new (int, int[])[] { (1, new int[] { 1, 5, 8}), (0, new int[] { 0, 0, 0})},/* 5 */ new (int, int[])[] { (1, new int[] { 1, 4, 8}), (2, new int[] { 2, 6, 9})},/* 6 */ new (int, int[])[] { (2, new int[] { 2, 5, 9}), (3, new int[] { 3, 7,10})},/* 7 */ new (int, int[])[] { (3, new int[] { 3, 6,10}), (0, new int[] { 0, 0, 0})},/* 8 */ new (int, int[])[] { (1, new int[] { 1, 4, 5}), (4, new int[] {11,12,15})},/* 9 */ new (int, int[])[] { (2, new int[] { 2, 5, 6}), (5, new int[] {12,13,16})},/*10 */ new (int, int[])[] { (3, new int[] { 3, 6, 7}), (6, new int[] {13,14,17})},/*11 */ new (int, int[])[] { (4, new int[] { 8,12,15}), (0, new int[] { 0, 0, 0})},/*12 */ new (int, int[])[] { (4, new int[] { 8,11,15}), (5, new int[] { 9,13,16})},/*13 */ new (int, int[])[] { (5, new int[] { 9,12,16}), (6, new int[] {10,14,17})},/*14 */ new (int, int[])[] { (6, new int[] {10,13,17}), (0, new int[] { 0, 0, 0})},/*15 */ new (int, int[])[] { (4, new int[] { 8,11,12}), (7, new int[] {18,19,22})},/*16 */ new (int, int[])[] { (5, new int[] { 9,12,13}), (8, new int[] {19,20,23})},/*17 */ new (int, int[])[] { (6, new int[] {13,14,17}), (9, new int[] {20,21,24})},/*18 */ new (int, int[])[] { (7, new int[] {15,19,22}), (0, new int[] { 0, 0, 0})},/*19 */ new (int, int[])[] { (7, new int[] {15,18,22}), (8, new int[] {16,20,23})},/*20 */ new (int, int[])[] { (8, new int[] {16,19,23}), (9, new int[] {17,21,24})},/*21 */ new (int, int[])[] { (9, new int[] {17,20,24}), (0, new int[] { 0, 0, 0})},/*22 */ new (int, int[])[] { (7, new int[] {15,18,19}), (0, new int[] { 0, 0, 0})}, /*23 */ new (int, int[])[] { (8, new int[] {16,19,20}), (0, new int[] { 0, 0, 0})},/*24 */ new (int, int[])[] { (9, new int[] {17,20,21}), (0, new int[] { 0, 0, 0})},};</span></pre> <p><span class="koboSpan" id="kobo.2580.1">Add the </span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.2581.1">preceding code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2582.1">GameHub</span></strong><span class="koboSpan" id="kobo.2583.1"> class after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2584.1">turnHandler</span></strong><span class="koboSpan" id="kobo.2585.1"> field declaration. </span><span class="koboSpan" id="kobo.2585.2">Now that we have declared the data structure for finding completed boxes, let’s continue processing </span><span class="No-Break"><span class="koboSpan" id="kobo.2586.1">the turn:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2587.1">Return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2588.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2589.1"> method, and add the following code at </span><span class="No-Break"><span class="koboSpan" id="kobo.2590.1">the end:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2591.1">
match.Sticks[args.Position] = args.Player.Id == match.PlayerOneId ? </span><span class="koboSpan" id="kobo.2591.2">1 : -1;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2592.1">This will assign the position </span><strong class="source-inline"><span class="koboSpan" id="kobo.2593.1">-1</span></strong><span class="koboSpan" id="kobo.2594.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2595.1">1</span></strong><span class="koboSpan" id="kobo.2596.1">, depending on who the active player is. </span><span class="koboSpan" id="kobo.2596.2">We will use a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2597.1">-1</span></strong><span class="koboSpan" id="kobo.2598.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.2599.1">1</span></strong><span class="koboSpan" id="kobo.2600.1"> later in determining a winner, in the case of three stones in </span><span class="No-Break"><span class="koboSpan" id="kobo.2601.1">a row.</span></span></p></li> <li><span class="koboSpan" id="kobo.2602.1">Now that we have placed the stick, we need to adjust the player’s score, </span><span class="No-Break"><span class="koboSpan" id="kobo.2603.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2604.1">
if (args.Player.Id == game.PlayerOneId){    match.PlayerOneScore += 1;}else {    match.PlayerTwoScore += 1;}</span></pre></li> <li><span class="koboSpan" id="kobo.2605.1">The following code will use the data structure from earlier to determine whether placing the stick completed </span><span class="No-Break"><span class="koboSpan" id="kobo.2606.1">any squares:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2607.1">
// Determine if this play creates a square
foreach (var tuple in stickToStoneMap[args.Position])
{
    if (tuple.stone == 0) continue;
    var stickCompletesABox = 
    (
        Math.Abs(match.Sticks[tuple.sticks[0] - 1]) + 
        Math.Abs(match.Sticks[tuple.sticks[1] - 1]) + 
        Math.Abs(match.Sticks[tuple.sticks[2] - 1])
    ) == 3;
    if (stickCompletesABox)
    {
        // If so, place stone, and adjust score
        var player = args.Player.Id == match.PlayerOneId ? </span><span class="koboSpan" id="kobo.2607.2">1 : -1;
        match.Stones[tuple.stone - 1] = player;
        if (player &gt; 0)
        {
            match.PlayerOneScore += 5;
        }
        else
        {
            match.PlayerTwoScore += 5;
        }
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2608.1">This code will iterate over the tuples declared at the array position of the newly placed stick, adjusting for C# arrays being 0-based. </span><span class="koboSpan" id="kobo.2608.2">It will then use the array of stick positions from the tuple to index into the array of sticks in the match The value at </span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.2609.1">that location will be either </span><strong class="source-inline"><span class="koboSpan" id="kobo.2610.1">1</span></strong><span class="koboSpan" id="kobo.2611.1"> for player one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2612.1">-1</span></strong><span class="koboSpan" id="kobo.2613.1"> for player two, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.2614.1">0</span></strong><span class="koboSpan" id="kobo.2615.1"> for unclaimed. </span><span class="koboSpan" id="kobo.2615.2">We can add the absolute value of all three locations and if it is 3, then the newly placed stick completes a box. </span><span class="koboSpan" id="kobo.2615.3">If so, then assign the stone location from the tuple, adjusting for 0-based arrays again, to the player, and give them </span><span class="No-Break"><span class="koboSpan" id="kobo.2616.1">five points.</span></span></p></li> <li><span class="koboSpan" id="kobo.2617.1">To help determine whether the match is over, we are going to use a couple of helper functions to make the code cleaner and easier to read. </span><span class="koboSpan" id="kobo.2617.2">The first of those returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.2618.1">boolean</span></strong><span class="koboSpan" id="kobo.2619.1"> value if all the sticks have been played in the match. </span><span class="koboSpan" id="kobo.2619.2">Add the following code to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2620.1">GameHub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2621.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2622.1">
private static bool AllSticksHaveBeenPlayed(Match match)
{
    return !(from s in match.Sticks where s == 0 select s).Any();
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2623.1">This function uses a straightforward LINQ query to search the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2624.1">Sticks</span></strong><span class="koboSpan" id="kobo.2625.1"> array for any element that has a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.2626.1">0</span></strong><span class="koboSpan" id="kobo.2627.1">, meaning unclaimed. </span><span class="koboSpan" id="kobo.2627.2">If there are, the </span><span class="No-Break"><span class="koboSpan" id="kobo.2628.1">function returns.</span></span></p></li> <li><span class="koboSpan" id="kobo.2629.1">The next function is a little more complex as it is used to determine whether a player has three </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.2630.1">stones in a row, either horizontally, vertically, or diagonally, and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2631.1">Id</span></strong><span class="koboSpan" id="kobo.2632.1"> value of the player that does. </span><span class="koboSpan" id="kobo.2632.2">Add the following code to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2633.1">GameHub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2634.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2635.1">
private static int HasThreeInARow(List&lt;int&gt; stones){    for (var rc = 0; rc &lt; 3; rc++)    {        var rowStart = rc * 3;        var rowValue = stones[rowStart] + stones[rowStart + 1] + stones[rowStart + 2];        if (Math.Abs(rowValue) == 3) // we Have a winner!        {            return rowValue;        }        var colStart = rc;        var colValue = stones[colStart] + stones[colStart + 3] + stones[colStart + 6];        if (Math.Abs(colValue) == 3) // We have a winner!        {            return colValue ;        }    }    var tlbrValue = stones[0] + stones[4] + stones[8];    var trblValue = stones[2] + stones[4] + stones[6];    if (Math.Abs(tlbrValue) == 3) { return tlbrValue; }    if (Math.Abs(trblValue) == 3) { return trblValue; }    return 0;}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2636.1">This method starts by checking all the rows and columns for 3 stones in a row, for the same player. </span><span class="koboSpan" id="kobo.2636.2">Since there are nine stones arranged in a 3x3 grid, we only need to check three columns and three rows. </span><span class="koboSpan" id="kobo.2636.3">Using a single iterator, each row or column is checked by adding the values stored at each position in </span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.2637.1">the row or column and if the absolute value of the sum is 3, then a single player has a winning row. </span><span class="koboSpan" id="kobo.2637.2">If the sum is positive, player one has won; otherwise, player two has won. </span><span class="koboSpan" id="kobo.2637.3">Since there are only two possible diagonals, those checks use the same logic but are done individually, rather </span><span class="No-Break"><span class="koboSpan" id="kobo.2638.1">than looping.</span></span></p></li> <li><span class="koboSpan" id="kobo.2639.1">Now, we can use those two functions to determine whether there is a winner. </span><span class="koboSpan" id="kobo.2639.2">To do so, we can use the following code at the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2640.1">ProcessTurn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2641.1"> function:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2642.1">
// Does one player have 3 stones in a row?
</span><span class="koboSpan" id="kobo.2642.2">var winner = Guid.Empty;
var threeInARow = HasThreeInARow(match.Stones);
if (threeInARow != 0)
    winner = threeInARow &gt; 0 ? </span><span class="koboSpan" id="kobo.2642.3">match.PlayerOneId : match.PlayerTwoId;
if (winner == Guid.Empty) // No Winner yet
{
    // Have all sticks been played, if yes, use top score.
    </span><span class="koboSpan" id="kobo.2642.4">if (HaveAllSticksBeenPlayed(match))
    {
        winner = match.PlayerOneScore &gt; match.PlayerTwoScore ? </span><span class="koboSpan" id="kobo.2642.5">match.PlayerOneId : match.PlayerTwoId;
    }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2643.1">Here, we use </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.2644.1">the two methods we just created to do the main checks and assign the winner. </span><span class="koboSpan" id="kobo.2644.2">We capture the winner as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2645.1">Guid</span></strong><span class="koboSpan" id="kobo.2646.1"> type from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2647.1">Id</span></strong><span class="koboSpan" id="kobo.2648.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2649.1">Player</span></strong><span class="koboSpan" id="kobo.2650.1"> class, so some translation </span><span class="No-Break"><span class="koboSpan" id="kobo.2651.1">is needed.</span></span></p></li> <li><span class="koboSpan" id="kobo.2652.1">Next, we can set the next player’s turn, or if there is a winner, complete the match, </span><span class="No-Break"><span class="koboSpan" id="kobo.2653.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2654.1">
if (winner == Guid.Empty)
{
    match.NextPlayerId = args.Player.Id == match.PlayerOneId ? </span><span class="koboSpan" id="kobo.2654.2">match.PlayerTwoId : match.PlayerOneId;
}
else
{
    match.NextPlayerId = Guid.Empty;
    match.WinnerId = winner;
    match.Completed = true;
}</span></pre></li> <li><span class="koboSpan" id="kobo.2655.1">The final steps are to save any changes we have made and send updates to the players. </span><span class="koboSpan" id="kobo.2655.2">We will use a helper method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.2656.1">SaveGameAndSendUpdates</span></strong><span class="koboSpan" id="kobo.2657.1"> to handle that as we will need the same code when a turn expires. </span><span class="koboSpan" id="kobo.2657.2">Add the following code to the end of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2658.1">GameHub</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2659.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2660.1">
private async Task SaveMatchAndSendUpdates(GameDbContext context, Match match)
{
    context.Matches.Update(match);
    await context.SaveChangesAsync();
    await Clients.Group($"Match[{match.Id}]").SendAsync(Constants.Events.MatchUpdated, new MatchUpdatedEventArgs(match));
    if (match.Completed)
    {
        await UserGroups.RemoveFromGroupAsync(match.PlayerOneId.ToString(), $"Match[{match.Id}]");
        await UserGroups.RemoveFromGroupAsync(game.PlayerTwoId.ToString(), $"Match[{match.Id}]");
    }
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2661.1">This function will save the current match state to the database, then sends a message to the SignalR group for the match indicating that there have been updates to the match. </span><span class="koboSpan" id="kobo.2661.2">If the match is over, then we remove the players from </span><span class="No-Break"><span class="koboSpan" id="kobo.2662.1">the group.</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2663.1">The following final three lines of code complete the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2664.1">ProcessTurn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2665.1"> method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2666.1">
await SaveMatchAndSendUpdates(context, match);
return new OkObjectResult(new ProcessTurnResponse(match));</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2667.1">After saving the match changes and notifying the players of the match updates, if the match is not over yet, we notify the next player that it is their turn to play. </span><span class="koboSpan" id="kobo.2667.2">To wrap things up we return the updated match object back to the player that just made </span><span class="No-Break"><span class="koboSpan" id="kobo.2668.1">their move.</span></span></p></li> <li><span class="koboSpan" id="kobo.2669.1">We also need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.2670.1">SaveGameAndSendUpdates</span></strong><span class="koboSpan" id="kobo.2671.1"> when there is an error after calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.2672.1">VerifyGameState</span></strong><span class="koboSpan" id="kobo.2673.1">. </span><span class="koboSpan" id="kobo.2673.2">Modify that section of code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.2674.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2675.1"> using the </span><span class="No-Break"><span class="koboSpan" id="kobo.2676.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2677.1">
error = VerifyMatchState(game, args);
if (error is not null)
{
    await SaveMatchAndSendUpdates(game);
    log.LogError(error, "Error validating match state.");
    return new BadRequestObjectResult(error);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2678.1">We have now completed all the required functions to connect a player to the service, challenge another player to a match, and then process each player’s turn and determine </span><span class="No-Break"><span class="koboSpan" id="kobo.2679.1">the winner.</span></span></p>
<p><span class="koboSpan" id="kobo.2680.1">Let’s take a short look back at what we have accomplished so far in this chapter. </span><span class="koboSpan" id="kobo.2680.2">We started by creating the Azure services that our game server backend would need, a SignalR </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.2681.1">service for real-time communication, and finally, the Functions service to host our backend functions. </span><span class="koboSpan" id="kobo.2681.2">We then implemented the Azure functions that would provide the functionality for </span><span class="No-Break"><span class="koboSpan" id="kobo.2682.1">our game:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2683.1">Connect</span></strong><span class="koboSpan" id="kobo.2684.1">: To register players to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2685.1">game service</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2686.1">IssueChallenge</span></strong><span class="koboSpan" id="kobo.2687.1">: To allow one player to request a game with </span><span class="No-Break"><span class="koboSpan" id="kobo.2688.1">another player</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2689.1">AcknowledgeChallenge</span></strong><span class="koboSpan" id="kobo.2690.1">: To accept or decline </span><span class="No-Break"><span class="koboSpan" id="kobo.2691.1">a request</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2692.1">ProcessTurn</span></strong><span class="koboSpan" id="kobo.2693.1">: To manage the gameplay between two players and determine </span><span class="No-Break"><span class="koboSpan" id="kobo.2694.1">the winner</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2695.1">Our backend is now complete, and we are ready to publish it to Azure so that we can consume the services from the game app in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2696.1">Chapter 10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2697.1">.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor865"/><span class="koboSpan" id="kobo.2698.1">Deploying the functions to Azure</span></h1>
<p><span class="koboSpan" id="kobo.2699.1">The final </span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.2700.1">step in this chapter is to deploy the functions to Azure. </span><span class="koboSpan" id="kobo.2700.2">You can do that as a part of a </span><strong class="bold"><span class="koboSpan" id="kobo.2701.1">continuous integration/continuous deployment</span></strong><span class="koboSpan" id="kobo.2702.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2703.1">CI/CD</span></strong><span class="koboSpan" id="kobo.2704.1">) pipeline – for example, with Azure DevOps. </span><span class="koboSpan" id="kobo.2704.2">But the easiest way to deploy the functions, in this case, is to do it directly from Visual Studio. </span><span class="koboSpan" id="kobo.2704.3">Perform the following steps to deploy </span><span class="No-Break"><span class="koboSpan" id="kobo.2705.1">the functions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2706.1">Right-click on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2707.1">SticksAndStones.Functions</span></strong><span class="koboSpan" id="kobo.2708.1"> project and </span><span class="No-Break"><span class="koboSpan" id="kobo.2709.1">select </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2710.1">Publish</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2711.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.2712.1">Select </span><strong class="bold"><span class="koboSpan" id="kobo.2713.1">Azure</span></strong><span class="koboSpan" id="kobo.2714.1"> as the </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.2715.1">destination for publishing and </span><span class="No-Break"><span class="koboSpan" id="kobo.2716.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2717.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2718.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.2719.1"><img alt="Figure 9.14 – Target selection when publishing" src="image/B19214_09_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2720.1">Figure 9.14 – Target selection when publishing</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.2721.1">Choose </span><strong class="bold"><span class="koboSpan" id="kobo.2722.1">Azure Function App (Windows)</span></strong><span class="koboSpan" id="kobo.2723.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.2724.1">Specific target</span></strong><span class="koboSpan" id="kobo.2725.1"> tab, then </span><span class="No-Break"><span class="koboSpan" id="kobo.2726.1">click </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2727.1">Next</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2728.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.2729.1"><img alt="Figure 9.15 – Container selection when publishing" src="image/B19214_09_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2730.1">Figure 9.15 – Container selection when publishing</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.2731.1">Sign in to </span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.2732.1">the same Microsoft account that we used in the Azure portal when we were creating the </span><strong class="bold"><span class="koboSpan" id="kobo.2733.1">Function </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2734.1">App</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2735.1"> resource.</span></span></li>
<li><span class="koboSpan" id="kobo.2736.1">Select the subscription that contains the function app. </span><span class="koboSpan" id="kobo.2736.2">All function apps we have in the subscription will now </span><span class="No-Break"><span class="koboSpan" id="kobo.2737.1">be loaded.</span></span></li>
<li><span class="koboSpan" id="kobo.2738.1">Select the function app and click </span><strong class="bold"><span class="koboSpan" id="kobo.2739.1">Finish</span></strong><span class="koboSpan" id="kobo.2740.1">. </span><span class="koboSpan" id="kobo.2740.2">If your app isn’t showing up, click </span><strong class="bold"><span class="koboSpan" id="kobo.2741.1">Back</span></strong><span class="koboSpan" id="kobo.2742.1"> and choose the </span><strong class="bold"><span class="koboSpan" id="kobo.2743.1">Azure Function App (Linux)</span></strong><span class="koboSpan" id="kobo.2744.1"> option as you may not have changed the default when creating the service in the </span><em class="italic"><span class="koboSpan" id="kobo.2745.1">Creating the Azure service for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2746.1">functions</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2747.1"> section.</span></span></li>
<li><span class="koboSpan" id="kobo.2748.1">When the profile is created, click the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.2749.1">Publish</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2750.1"> button.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.2751.1">The following screenshot shows the last step. </span><span class="koboSpan" id="kobo.2751.2">After that, the publishing profile will </span><span class="No-Break"><span class="koboSpan" id="kobo.2752.1">be created:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.2753.1"><img alt="Figure 9.16 – Publishing Azure functions" src="image/B19214_09_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2754.1">Figure 9.16 – Publishing Azure functions</span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor866"/><span class="koboSpan" id="kobo.2755.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2756.1">In this chapter, we started by learning about a few Azure services, including SignalR, and Functions. </span><span class="koboSpan" id="kobo.2756.2">Then, we created the services in Azure that our game server backend would need – a SignalR service for real-time communication, and finally, the Functions service to host our backend functions. </span><span class="koboSpan" id="kobo.2756.3">After this, we implemented the Azure functions that would provide the functionality for </span><span class="No-Break"><span class="koboSpan" id="kobo.2757.1">our game.</span></span></p>
<p><span class="koboSpan" id="kobo.2758.1">We wrapped up this chapter by publishing our function code to the Azure Functions instance </span><span class="No-Break"><span class="koboSpan" id="kobo.2759.1">in Azure.</span></span></p>
<p><span class="koboSpan" id="kobo.2760.1">In the next chapter, we will build a game app that will use the backend we have built in </span><span class="No-Break"><span class="koboSpan" id="kobo.2761.1">this project.</span></span></p>
</div>
</body></html>