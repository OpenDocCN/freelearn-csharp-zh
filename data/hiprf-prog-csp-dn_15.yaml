- en: '*Chapter 13*: Distributed Systems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 13 章*：分布式系统'
- en: In this chapter, you will learn about distributed applications and how you can
    improve their performance. You will understand how to build performant applications
    using the **Command Query Responsibility Separation** (**CQRS**) software design
    pattern, event sourcing, and microservices. You will learn how to use cloud providers
    such as Microsoft Azure to build scalable distributed solutions using Cosmos DB,
    Azure Functions, and the open source Pulumi infrastructure tool.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于分布式应用程序以及如何提高它们性能的知识。你将了解如何使用**命令查询责任分离**（**CQRS**）软件设计模式、事件溯源和微服务来构建高性能的应用程序。你将学习如何使用云服务提供商，如
    Microsoft Azure，利用 Cosmos DB、Azure Functions 和开源的 Pulumi 基础设施工具构建可扩展的分布式解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '**Implementing the CQRS design pattern**: In this section, we will implement
    the CQRS design pattern with a sample project that demonstrates the separation
    of commands and queries.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现 CQRS 设计模式**：在本节中，我们将通过一个示例项目来演示如何实现 CQRS 设计模式，该示例项目展示了命令和查询的分离。'
- en: '**Implementing event sourcing**: Many resources always show event sourcing
    with CQRS. But in this section, we will write a sample project that demonstrates
    pure event sourcing without CQRS. By doing this, you will know how to implement
    CQRS and event sourcing individually and be able to combine them to work together.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现事件溯源**：许多资源总是将事件溯源与 CQRS 结合展示。但在这个部分，我们将编写一个示例项目，展示没有 CQRS 的纯事件溯源。通过这样做，你将了解如何单独实现
    CQRS 和事件溯源，并能够将它们结合起来协同工作。'
- en: '**Using Microsoft Azure for distributed systems**: In this section, we will
    provide a high-level overview of Azure Functions – specifically Durable Azure
    Functions – for providing robust, secure, and scalable serverless code that performs
    well in a distributed environment. We will also look at the difference between
    containers and serverless, and when to use one over the other.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Microsoft Azure 构建分布式系统**：在本节中，我们将提供 Azure Functions（特别是持久 Azure Functions）的高级概述，以提供在分布式环境中表现良好的强大、安全且可扩展的无服务器代码。我们还将探讨容器和无服务器之间的区别，以及何时使用其中一种而不是另一种。'
- en: '**Managing your cloud infrastructure with Pulumi**: Managing Azure resources
    can become unwieldy, especially when the number of microservices you deploy increases.
    So, in this section, we will look at how Pulumi allows you to manage your cloud
    infrastructure and resources using pure C# that you can include in your build,
    test, and deploy pipelines.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Pulumi 管理你的云基础设施**：管理 Azure 资源可能会变得难以控制，尤其是在你部署的微服务数量增加时。因此，在本节中，我们将探讨
    Pulumi 如何允许你使用纯 C# 来管理你的云基础设施和资源，这些代码可以包含在你的构建、测试和部署管道中。'
- en: 'By completing this chapter, you will gain the following skills:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，你将获得以下技能：
- en: You will be able to separate commands and queries into different services.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够将命令和查询分离到不同的服务中。
- en: You will be able to persist state changes as sequences of state-changing events.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够将状态更改持久化为一系列状态更改事件。
- en: You will be able to understand the difference between containers and serverless,
    and you will be able to know when to use one over the other.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够理解容器和无服务器之间的区别，并知道何时使用其中一种而不是另一种。
- en: You will understand the different types of Durable Azure Function types and
    design patterns so that you can use them to build serverless functions.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将理解不同的 Durable Azure Function 类型以及设计模式，以便你可以使用它们来构建无服务器函数。
- en: You will be able to manage your cloud using Pulumi.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将能够使用 Pulumi 管理你的云。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You’ll need the following components to follow along with this chapter and
    perform the necessary programming tasks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章并执行必要的编程任务，你需要以下组件：
- en: Visual Studio 2022 or later
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 或更高版本
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书源代码：[https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13)
- en: 'Optional: A Microsoft Azure account'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：一个 Microsoft Azure 账户
- en: 'Optional: A Pulumi subscription'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：一个 Pulumi 订阅
- en: Implementing the CQRS design pattern
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 CQRS 设计模式
- en: 'In this section, we will look at the **Command Query Responsibility Separation**
    (**CQRS**) design pattern. In simple terms, a command is a method that performs
    an action, while a query is a method that returns data. Commands do not perform
    queries, and queries do not perform commands. Commands can have separate models
    for queries. Now, let’s write a simple console application that demonstrates how
    easy it is to implement this pattern, which is used extensively in microservice
    development:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 **命令查询责任分离**（**CQRS**）设计模式。简单来说，命令是一个执行动作的方法，而查询是一个返回数据的方法。命令不执行查询，查询也不执行命令。命令可以为查询有单独的模型。现在，让我们编写一个简单的控制台应用程序，演示实现此模式是多么简单，该模式在微服务开发中被广泛使用：
- en: Start a new console application called `CH13_CQRSPattern`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个名为 `CH13_CQRSPattern` 的新控制台应用程序。
- en: Add a new class called `CQRSBasedClass`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `CQRSBasedClass` 的新类。
- en: 'Add the `SleepCommand` method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `SleepCommand` 方法：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our `SleepCommand` method is an example of a command. It takes in a parameter
    that is several milliseconds in length. A command is then executed that causes
    the current thread to sleep for the number of milliseconds specified by the caller.
    This particular command does not return a value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `SleepCommand` 方法是一个命令的例子。它接受一个长度为几毫秒的参数。然后执行一个命令，使当前线程休眠由调用者指定的毫秒数。这个特定的命令不返回任何值。
- en: 'Add the `DateTimeQuery` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `DateTimeQuery` 方法：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `DateTimeQuery` method is an example of a query. It is a parameterless query,
    although queries can have parameters. The query does not perform any commands.
    It simply returns the current date and time to the caller.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `DateTimeQuery` 方法是一个查询的例子。它是一个无参数查询，尽管查询可以有参数。查询不执行任何命令。它只是将当前日期和时间返回给调用者。
- en: 'In the `Program` class, add the `ExecuteCommand` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类中添加 `ExecuteCommand` 方法：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ExecuteCommand` method executes `SleepCommand` in our `CQRSBasedClass`,
    which causes the current thread to sleep for 1 second.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteCommand` 方法在我们的 `CQRSBasedClass` 中执行 `SleepCommand`，这将导致当前线程休眠 1 秒。'
- en: 'Add the `ExecuteQuery` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `ExecuteQuery` 方法：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ExecuteQuery` method executes `DateTimeQuery` in our `CQRSBasedClass`,
    which queries the current date and time and returns the value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteQuery` 方法在我们的 `CQRSBasedClass` 中执行 `DateTimeQuery`，查询当前日期和时间并返回值。'
- en: 'Update the `Program.cs` file, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Program.cs` 文件，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start our program by writing a message to the console. Then, we call `ExecuteCommand`.
    Finally, we write a message to the console that includes the current date and
    time that is returned by the call to `ExecuteQuery`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向控制台写入一条消息来开始我们的程序。然后，我们调用 `ExecuteCommand`。最后，我们向控制台写入一条消息，其中包含由 `ExecuteQuery`
    调用返回的当前日期和时间。
- en: As you can see, in its most basic form, the CQRS pattern is really simple. A
    command performs an action and nothing else, while a query performs a query and
    nothing else. We can shift commands into their own command class so that the only
    purpose of the class is to execute commands. We can do the same with queries by
    placing them in their own query class so that all the query class does is returns
    queries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在它的最基本形式中，CQRS 模式实际上非常简单。命令执行一个动作，而什么都不做，而查询执行一个查询，而什么都不做。我们可以将命令移入它们自己的命令类，这样类的唯一目的就是执行命令。我们也可以通过将它们放入它们自己的查询类中来做同样的事情，这样查询类所做的只是返回查询。
- en: If you study this book’s source code, you will see that we have done this. We
    have a `CommandClass` with a command called `Sleep`. We also have a `QueryClass`
    with a query called `Now`. CQRS is the enabling pattern that’s used in microservice
    development. It is often used in conjunction with message brokers, message buses,
    message sending and receiving, domain modeling, domain events, event sourcing,
    eventual consistency, separate read and write models, and **domain-driven design**
    (**DDD**). This is where people tend to become lost. But even though the CQRS
    pattern is used alongside all these, the pattern itself is very simple, and it
    enables these other patterns and technologies to gel nicely together.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究这本书的源代码，你会看到我们已经这样做了。我们有一个名为 `CommandClass` 的类，其中有一个名为 `Sleep` 的命令。我们还有一个名为
    `QueryClass` 的类，其中有一个名为 `Now` 的查询。CQRS 是微服务开发中使用的启用模式。它通常与消息代理、消息总线、消息发送和接收、领域建模、领域事件、事件溯源、最终一致性、单独的读写模型以及
    **领域驱动设计**（**DDD**）一起使用。这就是人们容易迷失的地方。但尽管 CQRS 模式与所有这些一起使用，该模式本身非常简单，它使这些其他模式和技术的结合变得非常融洽。
- en: In terms of database operations, you can think of the `add`, `edit`, `delete`,
    and `update` operations as commands, and you can think of `select` operations
    as queries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库操作方面，你可以将`add`、`edit`、`delete`和`update`操作视为命令，而将`select`操作视为查询。
- en: Now that we have a simple understanding of the CQRS pattern, in the next section,
    we will turn our attention to understanding and implementing event sourcing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对CQRS模式有了简单的理解，在下一节中，我们将转向理解和实现事件溯源。
- en: Implementing event sourcing
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现事件溯源
- en: When you consider documents in a document store and records in a database, these
    are normally a business’s point of truth. Their state is the source of truth.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑文档存储中的文档和数据库中的记录时，这些通常是企业的真相来源。它们的状态是真相来源。
- en: Event sourcing record events become your source of truth rather than the state
    of data in tables, or the state of documents in document stores.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源记录的事件成为你的真相来源，而不是表格中的数据状态，或文档存储中的文档状态。
- en: So, instead of using the state as a point of truth, we can use recorded events
    as a source of truth.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是使用状态作为真相来源，而是可以使用记录的事件作为真相来源。
- en: In the old days of programming, this was known as an audit trail. I remember
    working on a database several years ago. It had an audit table. In that table,
    there was a record of all the actions that were carried out on the database and
    by whom. We could tell when data operations took place, what those data operations
    were, and who or what process was carried out those data operations. Then, if
    anything went wrong with the database, we could analyze that table and know which
    operation caused the resulting problems. To store this information, we would use
    database triggers that fired on every `add`, `update`, `delete`, and `read` operation.
    These triggers were events that fired upon a data operation that recorded what
    data modifications had taken place, who made those modifications, why they made
    the changes, and at what date and time those modifications took place.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程的旧时代，这被称为审计跟踪。我记得几年前我在一个数据库上工作。它有一个审计表。在那个表中，记录了在数据库上执行的所有操作以及由谁执行。我们可以知道数据操作发生的时间、那些数据操作是什么，以及谁或哪个过程执行了那些数据操作。然后，如果数据库出现任何问题，我们可以分析那个表并知道哪个操作导致了结果问题。为了存储这些信息，我们会使用在每次`add`、`update`、`delete`和`read`操作上触发的数据库触发器。这些触发器是在数据操作上触发的，记录了发生了哪些数据修改、谁进行了这些修改、为什么进行修改，以及修改发生的时间和日期。
- en: In this section, we will look at event sourcing, which records events that become
    your source of truth. Events allow you to understand how you arrived at a particular
    state at a particular point in time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨事件溯源，它记录的事件成为你的真相来源。事件允许你理解你如何在特定时间点达到特定的状态。
- en: An easy way to understand the benefits of event sourcing is to have a look at
    your bank statement. When you receive your bank statement, you start with the
    balance that was carried over from the previous month. Then, you see a list of
    transactions that took place during the period covered by the statement, which
    consists of money entering your account and money leaving your account. Each of
    these transactions is an event. These events can be money transfer in, money transfer
    out, direct debit payment, interest payment, standing order payment, bank charge
    payment, payment of goods, salary/wages being paid in, and so forth.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解事件溯源的好处的一个简单方法就是看看你的银行对账单。当你收到银行对账单时，你从上个月结转的余额开始。然后，你看到一份在账单涵盖期间发生的交易列表，包括进入你账户的金钱和离开你账户的金钱。每一笔交易都是一个事件。这些事件可以是资金转入、资金转出、直接借记支付、利息支付、定期订单支付、银行费用支付、商品支付、工资/薪水的支付等等。
- en: When you consider this scenario, your bank statement shows how you came to have
    the money come in and leave your account. But from a database point of view, just
    by looking at the data, this is not so easy. When you look at the data, you usually
    have to write a query that joins multiple tables in a relational database together
    to reveal the facts of how the state of your account changed. But you don’t necessarily
    know the context that led to those changes being made.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑这个场景时，你的银行对账单显示了你的钱是如何进入和离开账户的。但从数据库的角度来看，仅仅通过查看数据，这并不那么容易。当你查看数据时，你通常必须编写一个查询，将关系数据库中的多个表连接起来，以揭示你的账户状态是如何变化的实际情况。但你并不一定知道导致这些变化发生的原因。
- en: However, in the same scenario, when you store events, you are storing facts.
    These facts are based on true events that happened in the past, and that is why
    they can be trusted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在相同的场景中，当你存储事件时，你是在存储事实。这些事实基于过去发生过的真实事件，这就是为什么它们可以信赖。
- en: As for transactional logs, they inform you of what state changes took place.
    However, they don’t necessarily tell you why those state changes were made. On
    the other hand, when you store events, they inform you of what state changes were
    made, and the reason why those state changes were made.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交易日志，它们会告知你发生了哪些状态变化。然而，它们并不一定告诉你为什么这些状态变化被做出。另一方面，当你存储事件时，它们会告知你发生了哪些状态变化，以及这些状态变化的原因。
- en: Events are stored as aggregates in an append-only form. An aggregate is a consistency
    guard. You can see the state changes and the context that led to those changes.
    This means that you can revert the state to the last known consistent state at
    a particular point in time by replaying events forward or backward. You can use
    the event log to provide an audit trail. Information such as why and when can
    be very useful to various business functions, such as senior management, marketing,
    finance, and resource planning, since event logs are full of very valuable business
    information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事件以追加形式存储为聚合。聚合是一种一致性保护。你可以看到状态变化及其导致这些变化的环境。这意味着你可以通过向前或向后重放事件来将状态回滚到特定时间点的最后已知一致状态。你可以使用事件日志提供审计跟踪。诸如为什么和何时等信息对于各种业务功能，如高级管理层、市场营销、财务和资源规划等非常有用，因为事件日志充满了非常有价值的企业信息。
- en: Going back to our example scenario, an event represents a fact that took place
    in our banking domain. Each event in our banking system is a source of truth from
    which our bank account’s current state is derived. Such facts are immutable business
    facts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例场景，一个事件代表在我们银行领域发生的事实。我们银行系统中的每个事件都是真理的来源，我们的银行账户的当前状态就是从这些事实中得出的。这些事实是不可变业务事实。
- en: Our banking events will follow the normal methodology of providing state information,
    metadata that provides contextual information, the date and time when it happened,
    and other information that is necessary and appropriate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的银行事件将遵循提供状态信息、提供上下文信息的元数据、发生的时间和日期以及其他必要和适当的信息的正常方法。
- en: 'Let’s look at an example of how we can aggregate events so that they arrive
    at a specific state for our bank account:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，说明我们如何聚合事件，以便它们达到我们银行账户的特定状态：
- en: 'Events:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件：
- en: A dividend of £39 was issued by the investment firm to the customer at 12:43
    A.M. on June 12, 2021.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投资公司于2021年6月12日凌晨12:43向客户发放了39英镑的股息。
- en: A dividend of £39 was paid into the customer’s bank account by the investment
    firm at 12:45 A.M. on June 12, 2021.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投资公司于2021年6月12日凌晨12:45将39英镑的股息支付到客户的银行账户。
- en: Events
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: A salary of £2,300 paid was into the customer’s bank account by the employer
    at 12:00 A.M. on July 25, 2021, using BACS.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 薪资2300英镑于2021年7月25日凌晨12:00通过BACS支付到客户的银行账户。
- en: A standing order of £230 was transferred from the customer’s bank account into
    their savings account to build up an emergency stash at 09:11 A.M. on July 26,
    2021.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户于2021年7月26日上午9:11将230英镑的定期订单从客户的银行账户转入储蓄账户，以建立紧急储备金。
- en: A direct debit of £432 was paid to the local authority for rent from the customer’s
    bank account at 07:00 P.M. on July 25, 2021, using the relevant Android banking
    app.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户的银行账户于2021年7月25日晚上7:00通过相关的安卓银行应用程序支付了432英镑的直接借记费用给当地政府缴纳租金。
- en: A direct debit of £103 was paid to the local authority for council tax at 08:29
    P.M. on July 26, 2021, using online banking.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户于2021年7月26日晚上8:29通过网上银行支付了103英镑的直接借记费用给当地政府缴纳地方税。
- en: £23.79 was paid for groceries to the merchant by the customer using contactless
    payment at 09:35 P.M. on July 27, 2021.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户于2021年7月27日晚上9:35使用非接触式支付向商家支付了23.79英镑的杂货费用。
- en: As you can see from our banking scenario, when we use events as our fact-based
    points of truth, we see the full context of where the money is coming from, where
    the money is going, and by which method, what the amount is, and the precise date
    and time when it takes place.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的银行场景中看到的，当我们使用事件作为基于事实的真理点时，我们可以看到资金的来源、去向、方式、金额以及发生的精确日期和时间。
- en: These events ensure the data is in a consistent state, that there is an audit
    trail, and that valuable information is provided that allows business decisions
    to be made based on trustworthy facts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件确保数据处于一致状态，有审计跟踪，并提供有价值的信息，允许基于可信事实做出业务决策。
- en: Continuing with our banking scenario, each bank account would have a stream
    and unique identifier. All events that occur against that bank account will be
    recorded via its stream. So, we end up with one stream per aggregate. In our banking
    scenario, our aggregate is the group of events that take place against a specific
    bank account.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的银行场景，每个银行账户都会有一个流和唯一标识符。针对该银行账户发生的所有事件将通过其流进行记录。因此，我们为每个聚合体得到一个流。在我们的银行场景中，我们的聚合体是针对特定银行账户发生的事件组。
- en: Event sourcing example project
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源示例项目
- en: 'In this section, we will write a simple event sourcing application that also
    provides examples of usage. To implement the project, follow these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个简单的事件溯源应用程序，并提供使用示例。要实现项目，请按照以下步骤操作：
- en: Start a new .NET 6.0 console application and call it `CH13_EventSourcing`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 .NET 6.0 控制台应用程序，并将其命名为 `CH13_EventSourcing`。
- en: Add a public interface called `IEvent` with an empty method body. This is a
    convenient interface for marking any object an event.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `IEvent` 的新公共接口，方法体为空。这是一个方便的接口，用于标记任何对象为事件。
- en: 'Add a new public interface called `IRegisterable` and add the following method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `IRegisterable` 的新公共接口，并添加以下方法：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method allows registerable objects to register themselves with an event
    aggregator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许可注册的对象将自己注册到事件聚合器中。
- en: 'Add a new public interface called `IEventAggregator` and add the following
    methods:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `IEventAggregator` 的新公共接口，并添加以下方法：
- en: '[PRE6]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Register` method is used for registering objects of the `IRegisterable`
    type with the event aggregator. The `Register<T>` method registers an event handler
    of the `T` type for the specified object type. Finally, the `RaiseEvent` executes
    the event that was passed in as a parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register` 方法用于将 `IRegisterable` 类型的对象注册到事件聚合器。`Register<T>` 方法注册一个指定对象类型的
    `T` 类型的事件处理器。最后，`RaiseEvent` 执行传入的参数事件。'
- en: 'Add a new class called `EventHandler` and replace its contents with the following
    code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `EventHandler` 的新类，并用以下代码替换其内容：
- en: '[PRE7]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This delegate defines our event handler, which is of the `T` type, for events
    of the `IEvent` type.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此委托定义了我们的事件处理器，该处理器为 `T` 类型，用于 `IEvent` 类型的事件。
- en: Add a new class called `SingleThreadedEventAggregator` that implements the `IEventAggregator`
    interface.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `SingleThreadedEventAggregator` 的新类，该类实现了 `IEventAggregator` 接口。
- en: 'Add the following dictionary field to hold our event handlers:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字典字段添加以保存我们的事件处理器：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This dictionary defines a list of event handlers of the `IEvent` type for objects
    of a specified type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此字典定义了指定类型对象的 `IEvent` 类型事件处理器列表。
- en: 'Add the following constructor:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we instantiate our dictionary of event handlers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化我们的事件处理器字典。
- en: 'Update the `Register` method, as shown here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Register` 方法，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method registers our event aggregator with the registerable type that was
    passed in.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将传入的可注册类型的事件聚合器注册。
- en: 'Update the `Register<T>` method, as shown here:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Register<T>` 方法，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method checks our dictionary to see if it contains a key of the specified
    type; if it doesn’t, it adds one. Then, it creates a new event handler list of
    the specified type and adds the event handler.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查我们的字典是否包含指定类型的键；如果没有，则添加一个。然后，它创建一个新的指定类型的事件处理器列表，并将事件处理器添加进去。
- en: 'Update the `RaiseEvent` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `RaiseEvent` 方法：
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method gets a list of event handlers for the event that was passed in and
    loops through them, invoking them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法获取传入事件的事件处理器列表，并遍历它们，调用它们。
- en: Add a new class called `MultiThreadedEventAggregator` that implements the `IEventAggregator`
    interface.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `MultiThreadedEventAggregator` 的新类，该类实现了 `IEventAggregator` 接口。
- en: 'Add the following dictionary to the class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字典添加到类中：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This dictionary will hold a list of event handlers and their events.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此字典将保存事件处理器及其事件的列表。
- en: 'Add the following constructor:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下构造函数：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our constructor initializes our list of event handlers. Notice that we are using
    a concurrent dictionary to handle multi-threaded scenarios.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数初始化我们的事件处理器列表。注意，我们正在使用并发字典来处理多线程场景。
- en: 'Add the following method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method registers the event handlers of the registerable object with the
    multi-threaded event aggregator.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将可注册对象的的事件处理程序注册到多线程事件聚合器中。
- en: 'Add the following `Register` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `Register` 方法：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method checks our dictionary to see if it contains a key of the specified
    type; if it doesn’t, it adds one. Then, it creates a new event handler list of
    the specified type and adds the event handler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法检查我们的字典是否包含指定类型的键；如果没有，则添加一个。然后，它创建一个新的指定类型的事件处理程序列表并将事件处理程序添加进去。
- en: 'Add the `RaiseEvent` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `RaiseEvent` 方法：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method loops through all our event handlers stored in the event handler
    list and invokes them for the specified event that was passed in as an argument.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历存储在事件处理程序列表中的所有事件处理程序，并为传入作为参数的指定事件调用它们。
- en: This is the completed base project. Now, let’s look at an example of using our
    event sourcing code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成的基础项目。现在，让我们看看如何使用我们的事件源代码的示例。
- en: Add a folder called `BankApp`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `BankApp` 的文件夹。
- en: 'Add the following `DividendPayment` class to the `BankApp` folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `DividendPayment` 类添加到 `BankApp` 文件夹中：
- en: '[PRE18]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This class defines our dividend payment event. This event provides information
    on a dividend payment regarding who sent the payment, to whom the payment was
    made, the date of the payment, and the amount of the payment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义了我们的股息付款事件。此事件提供了有关股息付款的信息，包括谁发送了付款、付款对象是谁、付款日期以及付款金额。
- en: 'Add the `InvalidDateException` class to the `BankApp` folder:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `InvalidDateException` 类添加到 `BankApp` 文件夹中：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This class implements the `System.Exception` class and will be used to inform
    others that an exception occurred due to an incorrect date.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此类实现了 `System.Exception` 类，并将用于通知他人由于日期不正确而发生了异常。
- en: 'Add the `StandingOrderPayment` class to the `BankApp` folder:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `StandingOrderPayment` 类添加到 `BankApp` 文件夹中：
- en: '[PRE20]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This class defines our standing order payment event, which informs us of who
    pays the standing order and to whom, the start date of the standing order, and
    the amount to be paid.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此类定义了我们的定期订单付款事件，它通知我们谁支付了定期订单以及支付对象是谁，定期订单的开始日期以及应支付的金额。
- en: 'Add the `EventHandlers` class to the `BankApp` folder, and update it as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `EventHandlers` 类添加到 `BankApp` 文件夹中，并按以下方式更新：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our class implements the `IRegisterable` interface and will be used to register
    our events with the event aggregator that was used for those events.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类实现了 `IRegisterable` 接口，并将用于将我们的事件注册到用于这些事件的聚合器中。
- en: 'Add the following property and constructor:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下属性和构造函数：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This property is set in the constructor to label the `EventHandlers` class for
    easy human reference.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性在构造函数中设置，以便于人类参考 `EventHandlers` 类。
- en: 'Add the following registration code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下注册代码：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method registers the events and the event handlers for the dividend payments
    and standing orders with the event aggregator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将股息付款和定期订单的事件及其事件处理程序注册到事件聚合器中。
- en: 'Add the following handler method for dividend payments:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为股息付款添加以下处理方法：
- en: '[PRE24]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every time a dividend payment is made, this event handler is called, and the
    properties of the dividend payment event are logged to the console window.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每次支付股息时，都会调用此事件处理程序，并将股息付款事件的属性记录到控制台窗口中。
- en: 'Add the following handler method for standing order payments:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为定期付款添加以下处理方法：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Every time a standing order payment is paid, this event handler is called. The
    properties of the standing order payment event are written out on the console.
    During this process, the payment date is checked to see if it is valid; if it’s
    not, then an `InvalidDateException` is raised.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每次支付定期订单付款时，都会调用此事件处理程序。定期订单付款事件的属性将在控制台上输出。在此过程中，会检查付款日期是否有效；如果不是，则引发 `InvalidDateException`。
- en: 'Add the `GetStandingOrderDate` method:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetStandingOrderDate` 方法：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method takes the start date of the standing order and checks the date against
    the current date. An exception is thrown if the date is before the standing order
    start date or is not on or after the payment date for the month. Otherwise, the
    current date and time are returned.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受定期订单的开始日期，并将该日期与当前日期进行比较。如果日期早于定期订单的开始日期或不在该月的付款日期或之后，则抛出异常。否则，返回当前日期和时间。
- en: 'Replace the text in the `Program.cs` class with the following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 类中的文本替换为以下内容：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is our application entry point. We create an event aggregator that is single-threaded.
    Then, we create an instance of the `EventHandlers` class and pass it in the text
    that shows these event handlers are used to handle payment events. Next, we create
    two events – one for dividend payments and the other being for standing order
    payments. The instance of the `EventHandlers` class is then passed into the event
    aggregator so that the event handlers can be registered. Finally, the events for
    the dividend payment and standing order are raised.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的应用程序入口点。我们创建了一个单线程的事件聚合器。然后，我们创建了一个 `EventHandlers` 类的实例，并将显示这些事件处理器用于处理支付事件的文本传递给它。接下来，我们创建了两个事件——一个是用于股息支付，另一个是用于定期订单支付。然后，将
    `EventHandlers` 类的实例传递给事件聚合器，以便注册事件处理器。最后，引发了股息支付和定期订单的事件。
- en: 'Run the program. You should see something similar to the following output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。你应该会看到以下类似的输出：
- en: '![Figure 13.1 – The output of our event source application'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 我们事件源应用程序的输出](img/B16617_Figure_13.1.jpg)'
- en: '](img/B16617_Figure_13.1.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B16617_Figure_13.1.jpg](img/B16617_Figure_13.1.jpg)'
- en: Figure 13.1 – The output of our event source application
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 我们事件源应用程序的输出
- en: With that, you have coded and run an event sourcing application. Before that,
    you did the same with a CQRS application. By writing these two applications, you
    have seen pure CQRS and pure event sourcing at work. With this knowledge, you
    can now write applications that use these patterns individually or that combine
    them so that they work together. In the next section, we will provide a high-level
    overview of Microsoft Azure in terms of writing distributed systems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经编码并运行了一个事件源应用程序。在此之前，你用 CQRS 应用程序做了同样的事情。通过编写这两个应用程序，你看到了纯 CQRS 和纯事件源的实际应用。有了这些知识，你现在可以编写使用这些模式单独或结合它们以协同工作的应用程序。在下一节中，我们将从编写分布式系统的角度提供一个关于微软
    Azure 的高级概述。
- en: Using Microsoft Azure for distributed systems
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微软 Azure 进行分布式系统
- en: In this section, we will learn how to use Azure to implement durable microservices
    using serverless features, namely Azure Functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Azure 通过无服务器功能实现持久化微服务，即 Azure Functions。
- en: What is Azure? As I am sure you are aware by now, Microsoft Azure is Microsoft’s
    cloud offering for hosting your databases, APIs, and data resources. It also has
    many other forms of cloud offerings. Microsoft Azure consists of paid services,
    free for 1-year services, and always free services. You are advised to review
    their different cloud services and compare them with other providers to suit your
    needs. Pay particular attention to which services are free, along with their usage
    limits, and which services you will have to pay for.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Azure？正如你现在已经意识到的，微软 Azure 是微软为托管你的数据库、API 和数据资源提供的云服务。它还有许多其他形式的云服务。微软
    Azure 包括付费服务、免费一年的服务和始终免费的服务。建议你审查他们不同的云服务，并将它们与其他提供商进行比较，以满足你的需求。特别注意哪些服务是免费的，以及它们的用量限制，以及哪些服务你需要付费。
- en: Let's name some good reasons to host your applications and databases in the
    cloud instead of on-premises. Well, you don’t have to pay for hardware or electricity
    costs for a start. Then, there is the aspect of scaling up and scaling out when
    your existing infrastructure meets the maximum capacity. Hardware can become obsolete
    very quickly as the complexity of the needs of software and its users grows. So,
    there are many reasons to use the cloud that you will need to carefully consider,
    and with those reasons, there will be both pros and cons. Therefore, when deciding
    to use the cloud, make sure you research, document, and price everything so that
    you start on the right footing. This will make system management, maintenance,
    and business growth much easier in the long run. If you get things right from
    the start of your endeavors, then you will save yourself potential headaches further
    down the line!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举一些将应用程序和数据库托管在云端而不是本地的一些好理由。首先，你不需要为硬件或电力成本付费。然后，当现有的基础设施达到最大容量时，就需要进行扩展和扩展。随着软件及其用户需求复杂性的增长，硬件可能会很快过时。因此，有许多理由使用云，你需要仔细考虑这些理由，并且随着这些理由的出现，会有利弊。因此，在决定使用云时，确保你研究、记录并评估一切，以便你有一个正确的起点。这将使系统管理、维护和长期业务增长变得更加容易。如果你从一开始就做对了，那么你将在未来的某个时候避免潜在的头痛！
- en: A microservice is normally a simple web service that receives a request and
    sends a response. Many kinds of microservices exist, such as film and music streaming
    services and document upload and retrieval services. In the DDD of microservices,
    the microservice will normally have a data source. On Azure, this could be a file
    held in blob storage, data stored in an Azure SQL Server relational database,
    or even data stored in an Azure Cosmos DB NoSQL database.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通常是一个简单的 Web 服务，它接收请求并发送响应。存在许多种类的微服务，例如电影和音乐流媒体服务以及文档上传和检索服务。在微服务的 DDD 中，微服务通常会有一个数据源。在
    Azure 上，这可能是存储在 blob 存储中的文件，存储在 Azure SQL Server 关系型数据库中的数据，甚至是存储在 Azure Cosmos
    DB NoSQL 数据库中的数据。
- en: Modern microservice implementations are relying less on containerization that
    uses tools such as Docker and Kubernetes and more on pure serverless options such
    as Azure Functions. The beauty of an Azure Function is that it is only active
    for the period of the call. Once the function has done what it is required to
    do, it simply goes to sleep. An Azure Function also uses fewer computing resources
    and power compared to containerized solutions. The only downside is that you must
    manage many Azure Functions. And so, just like with containerization, you will
    need some way to orchestrate all your Azure Functions in an easy-to-maintain,
    extended, and useful way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现代微服务实现越来越不依赖于使用 Docker 和 Kubernetes 等工具的容器化，而是更多地依赖于如 Azure 函数这样的纯无服务器选项。Azure
    函数的美丽之处在于它仅在调用期间处于活跃状态。一旦函数完成了它需要完成的工作，它就简单地进入休眠状态。与容器化解决方案相比，Azure 函数使用的计算资源和电力更少。唯一的缺点是你必须管理许多
    Azure 函数。因此，就像容器化一样，你需要一种方法来以易于维护、扩展和实用的方式编排所有 Azure 函数。
- en: Azure Functions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 函数
- en: An Azure Function is a unit of work. When you implement Azure Functions, you
    do not have to concern yourself with provisioning and managing infrastructure,
    since Azure Functions is one of Microsoft’s serverless computing offerings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数是一个工作单元。当你实现 Azure 函数时，你不需要担心基础设施的配置和管理，因为 Azure 函数是微软的无服务器计算服务之一。
- en: Serverless computing is managed by the serverless provider. This means that
    the serverless computing provider is responsible for investing heavily into provisioning
    and managing the infrastructure that hosts your serverless computing services,
    such as Azure Functions. This means you get to save money on hardware and electricity
    costs, and can fully concentrate your efforts on developing, testing, deploying,
    and maintaining your serverless projects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器计算由无服务器提供商管理。这意味着无服务器计算提供商负责大量投资于配置和管理托管你的无服务器计算服务（如 Azure 函数）的基础设施。这意味着你可以节省硬件和电力成本，并可以将全部精力集中在开发、测试、部署和维护你的无服务器项目上。
- en: Microsoft’s investment into serverless computing provides your Azure Functions
    with networking, service discovery, routing, and events to facilitate high-performance
    communication between your functions and other aspects of your software system
    architecture.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对无服务器计算的投资为你的 Azure 函数提供了网络、服务发现、路由和事件，以促进你的函数与其他软件系统架构方面的性能通信。
- en: 'An Azure Function normally consists of one or more inputs that you can bind
    and trigger, and outputs that you can bind to, with your custom code sitting between
    the inputs and outputs, as shown in the following diagram:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数通常由一个或多个你可以绑定和触发的输入组成，以及你可以绑定输出的部分，你的自定义代码位于输入和输出之间，如下面的图所示：
- en: '![Figure 13.2 – High-level Microsoft Azure Functions concept diagram'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – 高级 Microsoft Azure 函数概念图'
- en: '](img/B16617_Figure_13.2.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16617_Figure_13.2.jpg)'
- en: Figure 13.2 – High-level Microsoft Azure Functions concept diagram
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 高级 Microsoft Azure 函数概念图
- en: Azure Functions are excellent tools to use when developing distributed systems.
    But the complexity of using Azure Functions begins to materialize when the number
    of Azure Functions in your projects starts to grow. Managing large numbers of
    Azure Functions requires a form of orchestration. Orchestration makes managing
    many Azure Functions more straightforward for the infrastructure team. The orchestration
    to employ for Azure Functions is Durable Azure Function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 函数是开发分布式系统时使用的优秀工具。但是，当你的项目中 Azure 函数的数量开始增加时，使用 Azure 函数的复杂性开始显现。管理大量
    Azure 函数需要一种编排形式。编排使得基础设施团队管理大量 Azure 函数变得更加简单。用于 Azure 函数的编排是可持久 Azure 函数。
- en: Durable Azure Functions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可持久 Azure 函数
- en: You can execute Azure Functions with stateful orchestration using durable functions.
    Azure Functions provide an extension known as Durable Functions. Durable function
    applications consist of multiple Azure Functions. Each function in a durable function
    orchestration can perform a different role and/or function. The different types
    of durable functions are activity, orchestrator, entity, and client. Let’s take
    a brief look at each type of durable function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用持久化函数执行具有状态编排的Azure Functions。Azure Functions提供了一个名为Durable Functions的扩展。持久化函数应用程序由多个Azure
    Functions组成。持久化函数编排中的每个函数都可以执行不同的角色和/或功能。持久化函数的不同类型包括活动、编排器、实体和客户端。让我们简要地看一下每种持久化函数类型。
- en: Durable function type – activity
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化函数类型 – 活动
- en: A basic unit of work is defined as an activity function within the orchestration
    of a durable function. This means that when an orchestrated function performs
    multiple tasks, such as data validation, reading data, and updating data, each
    of these tasks will be executed by a durable activity function. Once a durable
    activity function has been completed, it may return data to the function that
    orchestrated the activity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的工作单元是在持久化函数编排中定义的活动函数。这意味着当编排函数执行多个任务，如数据验证、读取数据和更新数据时，每个这些任务将由持久化活动函数执行。一旦持久化活动函数完成，它可能将数据返回到编排该活动的函数。
- en: Activity functions are defined by activity triggers. `DurableActivityContext`
    is passed in as a parameter. Event triggers can be bound to JSON-serializable
    objects that can be used to pass input data into functions. Since an activity
    function can only have single values passed to them, you can overcome this limitation
    by using arrays, complex types, and tuples.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 活动函数由活动触发器定义。`DurableActivityContext`作为参数传递。事件触发器可以绑定到可序列化为JSON的对象，这些对象可以用于将输入数据传递到函数中。由于活动函数只能传递单个值，你可以通过使用数组、复杂类型和元组来克服这种限制。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Activity functions can only be triggered from an orchestrator function and are
    only guaranteed to run at least once by the Durable Task Framework. Because we
    don’t know how many times an activity might be called, Microsoft recommends that
    you make durable activity functions idempotent whenever possible.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 活动函数只能从编排器函数触发，并且由Durable Task Framework保证至少运行一次。因为我们不知道活动可能被调用多少次，所以Microsoft建议尽可能使持久化活动函数具有幂等性。
- en: Durable function type – orchestrator
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化函数类型 – 编排器
- en: Use the orchestrator function type when you need to control what actions are
    executed, and the order that you need to execute them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要控制要执行的操作以及它们的执行顺序时，请使用编排器函数类型。
- en: Durable function type – entity
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化函数类型 – 实体
- en: A durable entity can be invoked by client and orchestrator functions and is
    triggered by an entity trigger. A durable entity function is used to read and
    update an object’s state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化实体可以通过客户端和编排器函数调用，并由实体触发器触发。持久化实体函数用于读取和更新对象的状态。
- en: Durable function type – client
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化函数类型 – 客户端
- en: A durable client function is defined using a durable client output binding.
    Client functions are used to start orchestrator and entity functions since, on
    the Azure portal, these functions cannot be triggered by button clicks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化客户端函数是通过持久化客户端输出绑定定义的。客户端函数用于启动编排器和实体函数，因为在Azure门户中，这些函数不能通过按钮点击来触发。
- en: Durable function patterns
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久化函数模式
- en: 'There are several patterns that you can use to manage your durable functions.
    These include the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用几种模式来管理你的持久化函数。这些包括以下内容：
- en: Aggregator (stateful entities)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合器（有状态实体）
- en: Async HTTP APIs
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步HTTP API
- en: Fan-out/fan-in
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扇出/扇入
- en: Function chaining
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数链
- en: Human interaction
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工交互
- en: Monitoring
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: The aggregator (stateful entities) pattern
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 聚合器（有状态实体）模式
- en: In this pattern, a single addressable entity is used to aggregate event data
    that takes place over a certain period. The data that’s passed into an aggregator
    can come from multiple sources. Data may be spread over time and can be delivered
    in batches. You can process data upon arrival and make the aggregated data available
    for querying by external clients.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，使用单个可寻址实体来聚合在一定时期内发生的事件数据。传递给聚合器的数据可以来自多个来源。数据可能随着时间的推移而分散，并且可以分批交付。你可以在数据到达时处理数据，并使聚合数据可供外部客户端查询。
- en: In the aggregator pattern, the aggregator function should be run in a single
    process or VM. The main reason is due to the complexity of concurrency control
    when it’s used with normal functions that are stateless.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合器模式中，聚合器函数应在单个进程或虚拟机中运行。主要原因是因为当与无状态的普通函数一起使用时，并发控制的复杂性较高。
- en: Async HTTP APIs
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步HTTP API
- en: Factors that affect the time it takes for an API call to complete include volume
    and latency, as well as other factors beyond your control. Durable functions have
    a built-in mechanism for working with the execution of long-running functions,
    and the durable function’s runtime is also responsible for managing the state.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 影响API调用完成时间因素包括数量和延迟，以及超出你控制的其他因素。可持续函数具有内置机制来处理长时间运行函数的执行，并且可持续函数的运行时还负责管理状态。
- en: Fan-out/fan-in
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扇出/扇入
- en: Durable functions allow you to execute functions in parallel and on the results
    of tasks.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可持续函数允许你并行执行函数并在任务的结果上执行。
- en: Function chaining
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数链
- en: When using ordinary functions with service bus queues, you have more complexity
    when it comes to error handling, and it can be hard to visualize the relationship
    between a function and a queue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用服务总线队列与普通函数一起使用时，错误处理会更加复杂，并且很难可视化函数与队列之间的关系。
- en: However, when you use a durable function, you have one location where you can
    set the order of your functions, storage queues are automatically managed by the
    durable function, and if errors occur in any of the activities, they get propagated
    back to the orchestration function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你使用可持续函数时，你有一个位置可以设置函数的顺序，存储队列由可持续函数自动管理，如果任何活动发生错误，它们会被传播回编排函数。
- en: Human interaction
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 人工交互
- en: Durable functions can be used to escalate processes that have not received human
    interaction within an agreed timeline.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可持续函数可用于提升在约定时间内未收到人工交互的流程。
- en: Monitoring (actors)
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监控（演员）
- en: When you need to perform a recurring task, such as releasing system resources,
    durable functions provide a flexible way for you to manage recurrence intervals,
    use a single orchestration to manage multiple monitor processes, and manage the
    lifetime of a task.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要执行重复性任务时，例如释放系统资源，可持续函数为你提供了一种灵活的方式来管理重复间隔，使用单个编排来管理多个监控过程，并管理任务的生命周期。
- en: Containers and serverless
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和无服务器
- en: Container and serverless technologies all have a valid place in the microservice
    ecosystem. The primary thought process is to know their strengths and weaknesses
    to help you choose the best option for your needs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和无服务器技术都在微服务生态系统中有一个合理的位置。主要思路是了解它们的优缺点，以帮助你选择最适合你需求的最佳选项。
- en: Containers
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: Containers are a good option for you if you have legacy code that you want to
    migrate to a more modern platform and code base. You do not have to rewrite your
    legacy code base, such as web services and batch processes, immediately. You can
    place them within a container and deploy them to the cloud. Then, when time, money,
    and resources become available, you can plan for and implement the rewriting of
    your legacy projects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将遗留代码迁移到更现代的平台和代码库，容器是一个不错的选择。你不必立即重写你的遗留代码库，例如Web服务和批处理过程。你可以将它们放入容器中，并将它们部署到云端。然后，当时间、金钱和资源可用时，你可以计划并实施重写你的遗留项目。
- en: When you rely on third-party dependencies, cost and PaaS availability can be
    an issue. Sites such as Docker Hub provide access to many readily available containers
    for various third-party dependencies that you can pull and deploy.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你依赖第三方依赖项时，成本和PaaS可用性可能成为问题。例如，Docker Hub等网站提供了许多可用的容器，用于各种第三方依赖项，你可以拉取并部署它们。
- en: Local development of multiple microservices can be simplified with Docker Compose
    files. You can add as many services as you need to a Docker Compose file and start
    them all up when they are required.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose文件可以简化多个微服务的本地开发。你可以在Docker Compose文件中添加所需的服务数量，并在需要时启动它们。
- en: Using Kubernetes clusters, an ingress controller is used to expose only those
    services you want to be exposed to. This allows you to provide secure code with
    a limited footprint that makes life hard for hackers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes集群，一个入口控制器用于仅暴露你想要暴露的服务。这允许你提供具有有限足迹的安全代码，让黑客难以生存。
- en: Some downsides to containers are that they can encourage the use of older development
    techniques that are more heavyweight and require more computing power. This can
    lead to an increase in computing costs. Containers also need a core number of
    cluster nodes that are always running, adding to your costs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的缺点之一是它们可能会鼓励使用更重量级且需要更多计算能力的旧开发技术。这可能导致计算成本增加。容器还需要一个核心数量的始终运行的数据节点，这会增加你的成本。
- en: Serverless
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无服务器
- en: External services can be integrated with serverless technology such as Azure
    Functions. Rapid application development is promoted by the simplified programming
    model of serverless computing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 外部服务可以通过 Azure Functions 等无服务器技术进行集成。无服务器计算的简化编程模型促进了快速应用开发。
- en: When programming serverless code, you are encouraged to use an event-driven
    approach to your functions. Such code is easily scalable and can be easily rewritten
    or discarded as your business evolves.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写无服务器代码时，鼓励您采用事件驱动的函数方法。此类代码易于扩展，并且可以根据业务的发展轻松重写或丢弃。
- en: Serverless code supports *scale to zero* as functions only ever run when they
    are needed and do not run when they are not needed. This helps reduce running
    costs as resource consumption is very minimal compared to services such as cluster
    nodes, which are always running.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器代码支持*缩放至零*，因为函数仅在需要时运行，不需要时则不运行。这有助于降低运行成本，因为与始终运行的数据节点等服务相比，资源消耗非常小。
- en: Rapid scale-out of serverless code is another advantage of such technologies,
    as you only ever pay for the running time of the function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器代码的快速扩展是此类技术的另一个优点，因为你只为函数的运行时间付费。
- en: Serverless functions can pose a security risk, so you must take steps to ensure
    your functions are safe and secure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数可能存在安全风险，因此您必须采取措施确保您的函数安全且受保护。
- en: Now that you know about the strengths and weaknesses of containers and serverless
    functions, and you have reviewed the various types of durable functions available
    in Microsoft Azure, as well as some durable function patterns, let’s look at managing
    our cloud infrastructures in C# with Pulumi.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了容器和无服务器函数的优缺点，并已审查了 Microsoft Azure 中可用的各种持久性函数以及一些持久性函数模式，让我们看看如何使用
    C# 和 Pulumi 在 C# 中管理我们的云基础设施。
- en: Managing your cloud infrastructure with Pulumi
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pulumi 管理您的云基础设施
- en: In this section, you will learn how to manage your cloud infrastructure using
    Pulumi. With cloud infrastructure, it is important to be consistent. One way to
    achieve this is to remove the human element, which is prone to error, and automate
    as much as you can. An important aspect of the cloud that can be readily automated
    is infrastructure provisioning tasks. And that’s where Pulumi comes in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 Pulumi 管理您的云基础设施。在云基础设施中，保持一致性很重要。实现这一目标的一种方法是通过消除容易出错的人类因素，尽可能实现自动化。云中可以轻松自动化的一个重要方面是基础设施提供任务。这正是
    Pulumi 发挥作用的地方。
- en: With Pulumi, you can code **Infrastructure as Code** (**IaC**) solutions. Code
    and configuration files are used to manage and provision the infrastructure that
    your software will run on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pulumi，您可以编写**基础设施即代码**（**IaC**）解决方案。代码和配置文件用于管理和提供软件将运行的底层基础设施。
- en: 'Pulumi projects can be written in various programming languages such as Python,
    VB.NET, F#, and C#. We are interested in using C# for our Pulumi projects. You
    can use Pulumi to do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi 项目可以用各种编程语言编写，如 Python、VB.NET、F# 和 C#。我们感兴趣的是使用 C# 进行我们的 Pulumi 项目。您可以使用
    Pulumi 执行以下操作：
- en: Specify your infrastructure.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定您的基础设施。
- en: Automate how cloud resources are created, updated, and deleted.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化云资源的创建、更新和删除过程。
- en: Use IDEs and code editors such as Visual Studio and Visual Studio Code.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 和 Visual Studio Code 等集成开发环境（IDE）和代码编辑器。
- en: Catch mistakes during compilation.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译过程中捕捉错误。
- en: Enforce security, compliance, and best practices.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行安全性、合规性和最佳实践。
- en: Use existing NuGet libraries as well as code your own libraries.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有的 NuGet 库以及编写自己的库。
- en: Use Kubernetes, Docker containers, Azure Functions, and Cosmos DB to build applications
    that are easy to scale.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes、Docker 容器、Azure Functions 和 Cosmos DB 来构建易于扩展的应用程序。
- en: Note
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: To follow along, you will need to have Chocolatey installed since it will be
    used as the package manager for installing Pulumi. You will also need to have
    a Microsoft Azure account to deploy your IaC. On Windows, when using the command
    line, make sure you are using PowerShell and that you are running it as an Administrator.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要跟随，您需要安装 Chocolatey，因为它将被用作安装 Pulumi 的包管理器。您还需要一个 Microsoft Azure 账户来部署您的 IaC。在
    Windows 上，当使用命令行时，请确保您正在使用 PowerShell，并且以管理员身份运行它。
- en: 'Now, let’s look at a very simple example of provisioning blob storage, adding
    files to blob storage, and destroying our provisioned resources. The following
    steps will provision, use, and delete Azure blob storage:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个配置 Blob 存储、向 Blob 存储添加文件以及销毁我们配置的资源的一个非常简单的示例。以下步骤将配置、使用和删除 Azure
    Blob 存储：
- en: 'Install Pulumi with the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 Pulumi：
- en: '[PRE28]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ensure that you have .NET 6 SDK or higher installed.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已安装 .NET 6 SDK 或更高版本。
- en: 'Configure Pulumi’s access to your Microsoft Azure account by typing the following
    command:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令配置 Pulumi 对您的 Microsoft Azure 账户的访问权限：
- en: '[PRE29]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Your credentials will never be sent to pulumi.com, and they will only be used
    by Pulumi for authentication purposes when managing and provisioning resources.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的凭据永远不会发送到 pulumi.com，并且它们仅用于 Pulumi 在管理和配置资源时的身份验证目的。
- en: 'At this point, you are ready to start using Pulumi. If the `az` term is not
    recognized, try the following command:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您已经准备好开始使用 Pulumi。如果 `az` 术语不被识别，请尝试以下命令：
- en: '[PRE30]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new project using the following commands:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的项目：
- en: '[PRE31]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You will be asked to enter your token, or you can simply press *Enter* to log
    into Pulumi and have Pulumi obtain your token for you. If you don’t have one,
    you can create one quite easily at this stage. Once you are logged in, you will
    be asked a series of questions in PowerShell. You can simply accept all the defaults.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求输入您的令牌，或者您可以简单地按 *Enter* 键以登录到 Pulumi，让 Pulumi 为您获取令牌。如果您还没有，您可以在这一阶段轻松创建一个。一旦登录，您将在
    PowerShell 中被问及一系列问题。您可以简单地接受所有默认值。
- en: 'Open the project in Visual Studio. Let’s review the project files:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开项目。让我们回顾一下项目文件：
- en: '`Pulumi.yaml` is used to define the project.'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pulumi.yaml` 用于定义项目。'
- en: '`Pulumi.dev.yaml` is used to store configuration values for your stack.'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pulumi.dev.yaml` 用于存储您的堆栈配置值。'
- en: '`Program.cs` is the entry point for your project.'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Program.cs` 是您项目的入口点。'
- en: '`MyStack.cs` is used to define your stack resources.'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MyStack.cs` 用于定义您的堆栈资源。'
- en: This class creates an Azure resource group and a storage account. The primary
    key for the storage account is then exported. You will find the location for the
    resource group in the `Pulumi.dev.yaml` file with the `azure-native:location`
    property name.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此类创建一个 Azure 资源组和一个存储账户。然后导出存储账户的主密钥。您可以在 `Pulumi.dev.yaml` 文件中找到资源组的定位，其属性名为
    `azure-native:location`。
- en: 'Now, deploy your stack with the following command:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令部署您的堆栈：
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When prompted, select **Yes** to deploy your stack to Azure.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，选择 **是** 以将您的堆栈部署到 Azure。
- en: At this stage, you should be able to log into your Azure account and see the
    newly created resource, and that it is a storage account.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段，您应该能够登录到您的 Azure 账户并查看新创建的资源，并且它是一个存储账户。
- en: 'Add an HTML file to your project called `index.html` and edit the file by adding
    some HTML content and saving it. Here is some sample content:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `index.html` 的 HTML 文件添加到您的项目中，并编辑该文件，添加一些 HTML 内容并保存。以下是一些示例内容：
- en: '[PRE33]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code to the `MyStack.cs` class immediately after the code
    block that creates the Azure storage account resource:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Azure 存储账户资源的代码块之后立即将以下代码添加到 `MyStack.cs` 类中：
- en: '[PRE34]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With that, we have created a new static website resource that utilizes the storage
    account we’ve just created.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就创建了一个新的静态网站资源，该资源利用了我们刚刚创建的存储账户。
- en: 'Next, add the following code after the code shown in *Step 10*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 *步骤 10* 中显示的代码之后添加以下代码：
- en: '[PRE35]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we used our cloud resources and a local `FileAsset` to upload our `index.html`
    file to blob storage.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了我们的云资源和本地 `FileAsset` 将我们的 `index.html` 文件上传到 Blob 存储。
- en: 'At the end of the constructor, add the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的末尾添加以下代码：
- en: '[PRE36]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code configures the web endpoint to our static website.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码配置了 Web 端点到我们的静态网站。
- en: 'Add the following property just above the constructor:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数上方添加以下属性：
- en: '[PRE37]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This property provides our static website endpoint.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性提供了我们的静态网站端点。
- en: 'Now, it’s time to deploy our changes by typing the following command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候通过输入以下命令来部署我们的更改了。
- en: '[PRE38]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will upload the `index.html` file to blob storage and make our static website
    available to the public. You should see a URL that you can use to view the web
    page that you created and uploaded. The file should be visible in your blob storage,
    which you can view via the Azure portal or Azure Storage Explorer.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这将上传`index.html`文件到blob存储，并使我们的静态网站对公众可用。您应该看到一个可以用来查看您创建和上传的网页的URL。该文件应在您的blob存储中可见，您可以通过Azure门户或Azure存储资源管理器查看。
- en: 'Once you are satisfied that the preceding code has worked for you, it is time
    to destroy the resources. Type the following command:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您确认前面的代码对您有效，就是时候销毁资源了。请输入以下命令：
- en: '[PRE39]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you want to destroy the entire stack, type the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想销毁整个堆栈，请输入以下命令：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With that, the stack has been completely removed from Pulumi.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，堆栈已经完全从Pulumi中移除。
- en: In this section, you learned how to manage your Azure stack with Pulumi. By
    using Visual Studio and the PowerShell command line, you created an Azure resource
    account and assigned blob storage to it. Then, you created a static website resource
    and used the cloud resources and local `FileAsset` to upload the static website,
    which consisted of a single file called `index.html`. You were able to view the
    file in blob storage and view the web page in your browser.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用Pulumi管理您的Azure堆栈。通过使用Visual Studio和PowerShell命令行，您创建了一个Azure资源帐户，并将blob存储分配给它。然后，您创建了一个静态网站资源，并使用云资源和本地`FileAsset`上传了静态网站，该网站由一个名为`index.html`的单个文件组成。您能够在blob存储中查看文件，并在浏览器中查看网页。
- en: In the next section, we will look at some performance considerations for distributed
    systems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨分布式系统的一些性能考虑因素。
- en: Performance considerations for distributed computing
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式计算的性能考虑因素
- en: We now know how to develop distributed systems. But what about their performance?
    What kinds of things should we be aware of in terms of the performance of distributed
    systems?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何开发分布式系统。但它们的性能如何？在分布式系统的性能方面，我们应该注意哪些方面？
- en: The first consideration is the network connection between clients and servers.
    TCP collisions can result in lost packets of information. This can corrupt communication
    between multiple devices and cause connections to time out. The most common reason
    for TCP collisions is when two or more computers share the same IP address.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑的是客户端和服务器之间的网络连接。TCP冲突可能导致信息包丢失。这可能会破坏多个设备之间的通信，并导致连接超时。TCP冲突最常见的原因是两台或多台计算机共享相同的IP地址。
- en: No computer on the same network should have the same address as another computer
    on the same network. This results in unpredictable network behavior that is detrimental
    to the performance and stability of a networked application. If you experience
    this situation, simply change the IP address of one of the computers to a different
    IP address.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 同一网络上的任何计算机都不应具有与同一网络上的另一台计算机相同的地址。这会导致不可预测的网络行为，对网络应用程序的性能和稳定性有害。如果您遇到这种情况，只需将其中一台计算机的IP地址更改为不同的IP地址即可。
- en: 'Another problem that can result in slow network communication is **Domain Name
    Resolution** (**DNS**). If DNS is not correctly set, then accessing a network
    resource such as a web page or web service may take longer than expected and cause
    a connection or request to time out. It is worth noting that there is usually
    more than one DNS on a distributed network. You have the DNS server of the external
    network and your router, which has a DNS for your local network. Either of these
    could be responsible for slow DNS resolution. Some steps you can take to resolve
    DNS issues are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能导致网络通信缓慢的问题是**域名解析**（**DNS**）。如果DNS设置不正确，那么访问网络资源，如网页或网络服务，可能比预期花费更长的时间，并可能导致连接或请求超时。值得注意的是，在分布式网络中通常不止一个DNS。您有外部网络的DNS服务器和您的路由器，后者为您的本地网络提供DNS。这些中的任何一个都可能导致DNS解析缓慢。您可以采取以下一些步骤来解决DNS问题：
- en: Check your network connectivity.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您的网络连接。
- en: Check that your DNS addresses are correct and in the right order.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的DNS地址正确，并且顺序正确。
- en: Ping the computer name, IP address, or base URL, such as google.co.uk, that
    you are trying to access to see if it responds or times out.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ping您试图访问的计算机名称、IP地址或基本URL（例如google.co.uk），以查看它是否响应或超时。
- en: Identify the nameservers in use using `nslookup`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nslookup`命令识别正在使用的域名服务器。
- en: Check the DNS suffix.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 DNS 后缀。
- en: Check that the DNS settings have been configured to pull the DNS IP address
    from the DHCP server.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 DNS 设置已配置为从 DHCP 服务器获取 DNS IP 地址。
- en: Use `ipconfig` to release and renew the DHCP address and DNS information.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ipconfig` 释放和更新 DHCP 地址和 DNS 信息。
- en: Check the DNS server to see if any services need to be restarted or if the server
    needs to be rebooted.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 DNS 服务器，看是否有服务需要重启或服务器需要重新启动。
- en: Sometimes, the information on the router becomes stale, so a quick solution
    is to reboot the router.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，路由器上的信息会过时，所以快速解决方案是重新启动路由器。
- en: Every so often, an ISP will run into problems of their own that affect you.
    In these cases, you will need to communicate with them to understand the problem
    and get some indication of when things will be back to normal.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，ISP 会遇到影响你的问题。在这种情况下，你需要与他们沟通，了解问题并了解何时恢复正常。
- en: Distributed firewalls may be employed to protect business networks. Misconfiguration
    of firewalls can result in resource access being denied or invisible. If machines
    are unable to access distributed resources, then the distributed firewall is a
    good place to start. If the distributed firewall is configured correctly, then
    check client and server firewalls to see if they are enabled or disabled and whether
    they are correctly configured or not.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用分布式防火墙来保护企业网络。防火墙配置错误可能导致资源访问被拒绝或不可见。如果机器无法访问分布式资源，那么分布式防火墙是一个好的起点。如果分布式防火墙配置正确，那么检查客户端和服务器防火墙是否启用或禁用，以及它们是否配置正确。
- en: For example, I have dealt with a lot of SQL Server problems. Some have been
    DNS and DHCP issues, but the most common issues are SQL Server configuration and
    firewall configurations. SQL Server uses dynamic ports. But sometimes, these can
    clash, as can fixed ports. Also, I have found that for SQL Server to work on many
    networks, the Named Pipes and TCP protocols must be enabled. Once these protocols
    have been changed within SQL Server Configuration Manager, you need to restart
    the instance of SQL Server they apply to, followed by the SQL Server Browser service.
    If you have firewalls in place, then the SQL Server executable for the instance
    will need to be added to the firewall as an application exception. If you need
    to use specific ports, then you would need to add port exceptions. Standard port
    exceptions for SQL Server are `1433` for TCP and `1434` for UDP.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我处理过很多 SQL Server 问题。有些是 DNS 和 DHCP 问题，但最常见的问题是 SQL Server 配置和防火墙配置。SQL Server
    使用动态端口。但有时，这些端口可能会冲突，固定端口也是如此。我还发现，为了在许多网络上运行 SQL Server，必须启用命名管道和 TCP 协议。一旦在
    SQL Server 配置管理器中更改了这些协议，就需要重新启动受影响的 SQL Server 实例，然后是 SQL Server 浏览器服务。如果你有防火墙，那么需要将实例的
    SQL Server 可执行文件添加到防火墙作为应用程序异常。如果你需要使用特定端口，那么你需要添加端口异常。SQL Server 的标准端口异常是 TCP
    的 `1433` 和 UDP 的 `1434`。
- en: 'Sometimes, even after the aforementioned SQL Server troubleshooting has been
    completed, networked applications can still not see the SQL Server instance. When
    this happens, a workaround is to recreate the database connection string with
    the following format: `IP_ADDRESS,PORT_NUMBER\INSTANCE_NAME`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使完成了上述 SQL Server 故障排除，网络应用程序仍然看不到 SQL Server 实例。当这种情况发生时，一种解决方案是重新创建以下格式的数据库连接字符串：`IP_ADDRESS,PORT_NUMBER\INSTANCE_NAME`。
- en: Another problem that can affect SQL Server connectivity in a distributed setting
    is the SQL Server driver that is installed and used. If you use specific versions
    of a SQL Server native client, then you will need to ensure that that particular
    version of the native client is installed on all computers for them to be able
    to connect to SQL Server. The way around this is to realize that the SQL Server
    driver is installed by default on all Windows computers, both server and client.
    If you use this driver, then you do not have to worry about rolling out SQL Server
    Native Clients to various computers that are part of your distributed system.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响分布式环境中 SQL Server 连接性的问题是安装和使用的 SQL Server 驱动程序。如果你使用特定版本的 SQL Server
    原生客户端，那么你需要确保该特定版本的原生客户端已安装在所有计算机上，以便它们能够连接到 SQL Server。解决这个问题的方法是意识到 SQL Server
    驱动程序默认安装在所有 Windows 计算机上，无论是服务器还是客户端。如果你使用此驱动程序，那么你不必担心将 SQL Server 原生客户端推广到分布式系统中的各种计算机。
- en: Another area of performance is the database querying aspect. The same query
    to obtain a set of results can be written in so many different ways to obtain
    the required results. This is especially true with larger result sets that have
    more joins. Dynamic SQL can also perform slowly. Therefore, speeding up queries
    can improve a database-driven distributed application significantly. You can use
    SQL Server Profile and review SQL Server Execution Plans to identify bottlenecks
    and rewrite SQL so that it’s more performant. You can also add missing indexes,
    correct incorrect indexing, and use pre-compiled stored procedures for performance
    enhancement purposes.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个性能方面是数据库查询。为了获取一组结果，相同的查询可以以多种不同的方式编写，以获得所需的结果。这在结果集较大的情况下尤其如此，因为它们有更多的连接。动态SQL也可能运行缓慢。因此，加快查询速度可以显著提高数据库驱动的分布式应用程序。您可以使用SQL
    Server配置文件和审查SQL Server执行计划来识别瓶颈，并重写SQL以提高其性能。您还可以添加缺失的索引，纠正错误的索引，并使用预编译的存储过程来提高性能。
- en: SQL Server can become corrupt and fail for many reasons, so it must be regularly
    updated with security patches. Here, you can use Always-On and failover clusters
    to keep connections alive and switch between SQL Servers when a server is down
    or needs to be taken offline for maintenance.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server可能因多种原因而损坏和失败，因此必须定期更新安全补丁。在这里，您可以使用Always-On和故障转移集群来保持连接活跃，并在服务器宕机或需要离线进行维护时在SQL服务器之间切换。
- en: The number of connections to a resource can also overload a distributed system
    to the point that clients cannot connect. To overcome this, you can employ load
    balancing so that when a resource server reaches a certain peak, clients are sent
    to an alternative server for those resources.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 资源连接的数量也可能使分布式系统过载到客户端无法连接的程度。为了克服这一点，您可以采用负载均衡，以便当资源服务器达到某个峰值时，客户端会被发送到替代服务器以获取那些资源。
- en: Another common oversight when sharing networked resources is network permissions.
    Sometimes, a folder may not be shared that should be shared. A really nasty problem
    can be that of a permissions hierarchy that is enforced via group policy that
    overrides even a network domain administrator’s ability to do their job.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享网络资源时，另一个常见的疏忽是网络权限。有时，可能没有共享应该共享的文件夹。一个真正棘手的问题可能是通过组策略强制执行的权限层次结构，它甚至可以覆盖网络域管理员执行其工作的能力。
- en: It is important to fully document your group policy and permissions structure
    for current and future staff. With a clear document that diagrammatically shows
    the permission groups and hierarchies, as well as provides a list of resources
    and their permission sets, if someone or an app is having trouble accessing resources,
    such documents can ease the pain of troubleshooting such problems.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 完全记录您的组策略和权限结构对于当前和未来的员工来说非常重要。一个清晰的文档可以直观地显示权限组和层次结构，并提供资源及其权限集的列表，如果有人或应用程序在访问资源时遇到问题，此类文档可以减轻解决此类问题的痛苦。
- en: It is also worth noting that sometimes, System and TrustedInstaller take control
    of certain resources and prevent you from being able to access resources locally
    and across a network. This can result in you having to override the ownership
    of that network or local location and file resource.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时系统管理员和受信任的安装程序会控制某些资源，阻止您在本地和网络中访问资源。这可能导致您必须覆盖该网络或本地位置的文件资源所有权。
- en: Computer security software can also significantly slow down network traffic
    and even stop programs from working. The usual culprits are the firewall, as we
    mentioned previously, and antivirus software. If your software is not code-signed
    with an authority-approved code signing certificate, then DLLs and executables
    can be quarantined and identified as harmful software. This is what is known as
    being identified as a false positive. You can either sign your software, add your
    software as an application or folder exception, or pass your software to security
    firms to assess your software and update their software to prevent this from happening
    in the future.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机安全软件也可能显著减慢网络流量，甚至停止程序运行。通常的罪魁祸首是防火墙，正如我们之前提到的，以及防病毒软件。如果您的软件没有使用权威批准的代码签名证书进行签名，那么DLL和可执行文件可能会被隔离并识别为恶意软件。这就是所谓的误报。您可以选择对软件进行签名，将软件添加为应用程序或文件夹例外项，或将软件传递给安全公司以评估您的软件，并更新他们的软件以防止未来发生此类情况。
- en: Antivirus software can also slow applications down when all network traffic
    and even local files are real-time scanned. An example of this is educational
    software that pulls audio files across the network during assessments. A characteristic
    that identifies this being the case is when the audio files are backed up and
    fired together. To overcome this problem, you can update the antivirus software
    by adding the application, its folders, and its resources as folder and or application/file
    exceptions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有网络流量甚至本地文件都进行实时扫描时，杀毒软件也可能减慢应用程序的速度。一个例子是在评估期间通过网络拉取音频文件的教育软件。当音频文件被备份并一起播放时，这表明了这种情况。为了克服这个问题，你可以通过将应用程序、其文件夹及其资源添加为文件夹和或应用程序/文件异常来更新杀毒软件。
- en: The size of resources also affects network performance. The larger the size,
    the longer the time to request and receive a resource. Here, you can reduce the
    size of resources such as images, video, and audio files using various compression
    techniques. You can also zip resources up and transmit them before they need to
    be accessed, such as at application startup. You can store resources in the local
    cache once they have been requested and received.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的大小也会影响网络性能。资源越大，请求和接收资源所需的时间就越长。在这里，你可以使用各种压缩技术来减小图像、视频和音频文件等资源的大小。你还可以在需要访问之前压缩资源并传输它们，例如在应用程序启动时。一旦请求并接收了资源，你就可以将它们存储在本地缓存中。
- en: 'When the workload increases to the point that your current system cannot handle
    it, you have two options: scale up vertically or scale out horizontally. Scaling
    up involves increasing the physical computing capacity to cope with the increased
    workload. Scaling out is when you add more servers to cope with the increased
    workload. At the time of writing, the way forward for many companies is to use
    server VMs and containers and have containers running in container management
    software such as Docker and Kubernetes on cloud platforms such as Azure, AWS,
    Google Cloud, and others.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作负载增加到当前系统无法处理的地步时，你有两个选择：垂直扩展或水平扩展。垂直扩展涉及增加物理计算能力以应对增加的工作负载。水平扩展是指添加更多服务器以应对增加的工作负载。在撰写本文时，许多公司的前进方向是使用服务器虚拟机（VMs）和容器，并在Azure、AWS、Google
    Cloud等云平台上的Docker和Kubernetes等容器管理软件中运行容器。
- en: Large libraries and executables can be made smaller by moving code into microservices
    such as Azure Functions. Azure Functions is an event-driven, compute-on-demand
    experience that extends the existing Azure application platform with capabilities
    to implement code triggered by events occurring in Azure or third-party services,
    as well as on-premises systems. These online services can then scale up and down
    and run only when they are required to do so. This has the added advantage of
    providing cost savings, such as electricity and equipment costs.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将代码移动到微服务（如Azure Functions）中，可以减小大型库和可执行文件的大小。Azure Functions是一个事件驱动的按需计算体验，它通过在Azure或第三方服务以及本地系统中发生的事件触发代码的能力，扩展了现有的Azure应用程序平台。这些在线服务可以自动扩展和缩减，并且仅在需要时运行。这还带来了额外的优势，例如节省成本，如电力和设备成本。
- en: You can also use tools such as the browser developer tools and Postman to monitor
    application and network performance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用浏览器开发者工具和Postman等工具来监控应用程序和网络性能。
- en: Now, let’s summarize what we have learned.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下我们所学到的内容。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by looking at the implementation of the CQRS design
    pattern. Then, we looked at an implementation of event sourcing. You can use both
    these patterns by themselves, though they can also be combined to provide very
    powerful and functional microservices.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了CQRS设计模式的实现。然后，我们研究了事件源的实施。你可以单独使用这两种模式，尽管它们也可以结合起来提供非常强大和功能性的微服务。
- en: Then, we took a high-level look at using Microsoft Azure for writing distributed
    systems. The benefits and negative aspects of containers and serverless functions
    were covered to help you understand when to use each technology.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们以高级别概述了使用Microsoft Azure编写分布式系统的方法。我们涵盖了容器和无服务器函数的优点和缺点，以帮助您了解何时使用每种技术。
- en: In terms of Microsoft Azure, we focused mainly on Azure Functions. Specifically,
    we looked at Durable Azure Functions. We identified the various types of durable
    functions and various durable function patterns.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Azure方面，我们主要关注Azure Functions。具体来说，我们研究了持久Azure Functions。我们确定了各种持久函数及其持久函数模式。
- en: Now, take some time to answer this chapter’s questions to see how much you have
    retained from this chapter. Please review the *Further reading* section to build
    upon what you have learned in this chapter.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，花些时间回答本章的问题，看看你记住了多少。请查阅*进一步阅读*部分，以巩固你在本章中学到的知识。
- en: In the next chapter, we will be looking at multithreaded programming in C#.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨C#中的多线程编程。
- en: Questions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What does CQRS stand for?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CQRS代表什么？
- en: Why do we use the CQRS pattern when developing microservices?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在开发微服务时使用CQRS模式？
- en: What is event sourcing?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件溯源？
- en: Why do we use event sourcing?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们使用事件溯源？
- en: What are containers?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是什么？
- en: Why would we use containers?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会使用容器？
- en: What are serverless functions?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是无服务器函数？
- en: Why should we use serverless functions?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该使用无服务器函数？
- en: What are durable functions?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是持久化函数？
- en: What are the different types of durable functions?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持久化函数有哪些不同类型？
- en: What types of durable function patterns are there?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些类型的持久化函数模式？
- en: What is Pulumi?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pulumi是什么？
- en: Why would we use Pulumi?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会使用Pulumi？
- en: Further reading
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: '*Getting started with Pulumi on Azure*: [https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Azure上使用Pulumi入门*：[https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)'
- en: '*Building Modern Cloud Applications using Pulumi and .NET Core*: [https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/](https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Pulumi和.NET Core构建现代云应用程序*：[https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/](https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/)'
- en: '*Orchestration Using Durable Azure Functions*: [https://blog.kiprosh.com/orchestration-using-durable-azure-function/](https://blog.kiprosh.com/orchestration-using-durable-azure-function/)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用持久化Azure函数进行编排*：[https://blog.kiprosh.com/orchestration-using-durable-azure-function/](https://blog.kiprosh.com/orchestration-using-durable-azure-function/)'
- en: '*Durable Functions Orchestrations*: [https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久化函数编排*：[https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp)'
- en: '*Best Practices for Durable Functions Patterns*: [https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices](https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持久化函数模式的最佳实践*：[https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices](https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices)'
- en: '*Chapters 9* and *10* of *Clean Code in C#* by Jason Alls: [https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S](https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C#中的Clean Code》第9章和第10章* by Jason Alls：[https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S](https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S)'
- en: '*10 Ways to Troubleshoot DNS Resolution Issues*: [https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/](https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*10种解决DNS解析问题的方法*：[https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/](https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/)'
