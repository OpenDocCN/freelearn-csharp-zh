- en: Networks in a Nutshell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络概述
- en: It's hard to imagine that anyone reading this book doesn't have some intuitive
    idea of what a network actually is*.* As I write this introduction, I'm surrounded
    by no fewer than six distinct, network-connected devices within arm's reach. Even
    before I began a career in software engineering, I could have given a reasonably
    accurate description of what constitutes a network. However, no amount of intuition
    about what networks are or what might run on them, nor the use of software running
    on distributed systems, can account for the impact of a distributed architecture
    on your code. It's that impact on your software design and implementation decisions
    that we'll cover in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象任何阅读这本书的人对网络实际上是什么没有一些直观的想法*.* 当我写这篇引言时，我周围至少有六个不同的、可触及的网络连接设备。即使在开始软件工程职业生涯之前，我也能给出一个关于网络构成的大致准确的描述。然而，无论对网络是什么或可能在其上运行什么有怎样的直觉，无论使用在分布式系统上运行的软件，都无法解释分布式架构对代码的影响。正是这种对软件设计和实现决策的影响，我们将在本章中探讨。
- en: We'll try to nail down a concrete definition of a network, and we'll consider
    the new problems you'll need to solve when writing software for them. This book
    assumes a fair amount of general programming skills within the C# language from
    its readers. I won't take any time to explain the use of native language structures,
    types, or keywords, nor will I discuss or explain the common general algorithms
    used throughout. However, I will stop short of making any assumptions of the reader's
    knowledge of networks, inter-device communication, or how those problems are solved
    in .NET Core. As such, this chapter will start from the most basic first principles
    and seek to provide a stable foundation from which anyone with at least some programming
    skill can proceed competently through the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试给出一个关于网络的明确定义，并考虑在为这些网络编写软件时需要解决的新问题。本书假设读者具备相当程度的C#语言通用编程技能。我不会花费时间去解释原生语言结构、类型或关键字的使用，也不会讨论或解释在整个过程中使用的通用算法。然而，我不会对读者对网络的了解、设备间通信或.NET
    Core中解决这些问题的方法做出任何假设。因此，本章将从最基本的第一原理开始，旨在为至少具备一些编程技能的任何人提供一个稳定的基石，使他们能够胜任本书其余部分的学习。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The unique challenges of distributing computational or data resources over a
    network, and how those challenges manifest in software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上分配计算或数据资源所面临的独特挑战，以及这些挑战如何在软件中体现
- en: The different components of a network, and how those components can be arranged
    to achieve different goals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络的不同组成部分，以及如何安排这些组件以实现不同的目标
- en: The impact of the variability of devices, latency, instability, and standardization
    of networks on the complexity of applications written for network use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备多样性、延迟、不稳定性和网络标准化对为网络使用编写的应用程序复杂性的影响
- en: Common concepts, terms, and data structures used for network programming, and
    how those concepts are exposed by .NET Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程中常用的概念、术语和数据结构，以及.NET Core如何暴露这些概念
- en: Understanding the scope of applications that are made possible by networked
    architectures, and the importance of developing skills in network programming
    to enable those kinds of applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络架构使可能的应用程序的范围，以及发展网络编程技能以实现这些类型应用程序的重要性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This being an introductory chapter, there will be no meaningful code samples,
    as we'll be covering the high-level concepts and vocabulary of networks to establish
    a clear foundation for the rest of the book. However, in this chapter, we'll be
    discussing the `System.Net` class library provided by .NET Core. While this discussion
    will be happening at a very high level, it would be a good opportunity to familiarize
    yourself with the development tools made available to you by Microsoft Visual
    Studio Community edition. This is free to use, and provides a rich feature suite
    out of the box, with broad support for .NET Core project management and administration
    provided out of the box. As we discuss some of the libraries provided within the
    .NET Core tools, I encourage you to investigate using the Visual Studio IDE to
    include those libraries into your project and begin exploring them through the
    IDE's IntelliSense.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个入门章节，我们将不会提供有意义的代码示例，因为我们将涵盖网络的高级概念和词汇，为本书的其余部分建立一个清晰的基础。然而，在本章中，我们将讨论.NET
    Core提供的`System.Net`类库。虽然这次讨论将在非常高的层次上进行，但这将是一个熟悉由Microsoft Visual Studio Community版提供的开发工具的好机会。这是免费的，并且提供了丰富的功能套件，默认支持.NET
    Core项目管理和维护。当我们讨论.NET Core工具中提供的某些库时，我鼓励您使用Visual Studio IDE将这些库包含到您的项目中，并通过IDE的IntelliSense开始探索它们。
- en: Expanding the scope of software – distributed systems and the challenges they
    introduce
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展软件的范畴——分布式系统和它们带来的挑战
- en: The first step to understanding programming for networks is, of course, understanding
    networks. Defining what they are, clarifying the aspects of networks we are concerned
    with, addressing how network architecture impacts the programs we write, and what
    kinds of software solutions networks need to be effective.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解网络编程的第一步当然是理解网络。定义它们是什么，明确我们关心的网络方面，探讨网络架构对我们编写的程序的影响，以及网络需要什么样的软件解决方案才能有效。
- en: What is a network?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是网络？
- en: 'At its most basic, a network is nothing more than a physical implementation
    of an undirected graph; a series of nodes and edges, or connections, between those
    nodes, as demonstrated in the following diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的意义上，网络不过是一个无向图的物理实现；一系列节点和节点之间的边，或者说是连接，如下面的图所示：
- en: '![](img/564485cf-f5a8-4ebd-9334-0fadeb8fa45c.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/564485cf-f5a8-4ebd-9334-0fadeb8fa45c.png)'
- en: '[A basic, undirected graph]'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[一个基本的、无向图]'
- en: However, the preceding diagram doesn't quite capture the full picture. What
    constitutes a node, and what is sufficient for a connection are all very pertinent
    details to clarify. An individual node should probably be able to meaningfully
    interact with other nodes on the network, or else you might have to concern yourself
    with programming for a potato connected by two wires to a network of routers and
    servers. It's safe enough to say that potatoes very obviously aren't nodes, and
    that an active and stable Azure server very obviously *is*, so the line delineating
    nodes from non-nodes on a network falls somewhere between those two poles. Likewise,
    we can easily identify that the cables from the power supply of a computer to
    the outlet in a wall don't constitute a network connection, but that a CAT-5 cable
    from our computer to a router obviously does. The dividing line probably falls
    somewhere between those two, and it is important that we take care to draw that
    line accurately.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的图并没有完全捕捉到全貌。构成节点的要素是什么，以及什么才足够构成一个连接，这些都是非常相关的细节，需要明确。一个节点可能需要能够与网络上的其他节点进行有意义的交互，否则你可能不得不为通过两根线连接到路由器和服务器上的土豆编写程序。可以说，土豆显然不是节点，而一个活跃且稳定的Azure服务器显然是节点，因此网络中节点与非节点的界限可能介于这两者之间。同样，我们可以很容易地识别出，从电脑的电源到墙上的插座之间的电缆并不构成网络连接，而从我们的电脑到路由器的CAT-5电缆显然是。这条界限可能介于这两者之间，而且我们一定要小心准确地划出这条线。
- en: 'We''ll start with a workable definition of networks for the purposes of this
    book, unpack the definition, and examine why we chose to make the specific distinctions
    we have, and finally, consider what each essential property of a network means
    to us as programmers. So, without further ado, the definition of a computer network
    is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，我们将从网络的一个可行定义开始，解析这个定义，并考察我们为什么选择做出特定的区分，最后，考虑每个网络的基本属性对我们程序员意味着什么。所以，不再多言，计算机网络的定义如下：
- en: <q>A computer network is, for our purposes, an arbitrarily large set of computational
    or navigational devices, connected by channels of communication across which computational
    resources can be reliably sent, received, forwarded, or processed.</q>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <q>对于我们的目的而言，计算机网络是由任意大量计算或导航设备组成，这些设备通过通信渠道连接，计算资源可以通过这些渠道可靠地发送、接收、转发或处理。</q>
- en: On the surface, that might seem basic, but there is a lot of nuance in that
    definition that deserves our consideration. So, let's take a deeper dive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这似乎很基本，但那个定义中有很多细微之处值得我们思考。所以，让我们深入探讨一下。
- en: An arbitrarily large set
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任意大量集合
- en: What do we mean when we say arbitrarily large? Well when you're writing software
    for a router (accepting that you would realistically be bound by the maximum size
    of physically-addressable space), you would not (and should not) care about how
    many devices are actually connected to your hardware, or how many routes you need
    to reliably pass resources or requests along. Suppose you are writing the system
    software for a wireless router. While doing so, you tell your product owner that
    their marketing copy should specify that this router can only connect a maximum
    of four computers to the internet. Can you imagine any product owner would take
    that news kindly? You would be looking for a new job in no time! Networks must
    be able to scale with the needs of their users.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“任意大量”时，我们指的是什么？当你为路由器编写软件时（接受你实际上会受到物理可寻址空间最大大小的限制），你不会（也不应该）关心有多少设备实际上连接到你的硬件，或者你需要多少路由来可靠地传递资源或请求。假设你正在为无线路由器编写系统软件。在这样做的时候，你告诉你的产品经理，他们的营销文案应该明确指出这款路由器最多只能连接四台电脑到互联网。你能想象任何产品经理会友好地接受这个消息吗？你很快就会在寻找新的工作了！网络必须能够根据用户的需求进行扩展。
- en: A basic property of almost all computer networks is device-agnosticism, which
    is to say that any device on a network should assume no knowledge of the number
    or kind of other devices on that network at any given moment. Indeed, a program
    or device might need to discern whether or not a specific device or piece of software
    exists on the network, but nothing about the network connection it obtains will
    convey that information. Instead, it should be equipped to send and receive messages
    in a format that is typically standardized for the communication protocol over
    which the messages are sent. Then, using these standardized messages, a device
    can request information about the availability, configuration, or capabilities
    of other devices on the network, without actually knowing whether or not the devices
    it expects to be available on the network are, in fact, available on the network.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有计算机网络的一个基本属性是设备无关性，也就是说，网络上的任何设备都应该在任何给定时刻假设不知道该网络上的其他设备数量或种类。事实上，一个程序或设备可能需要判断特定设备或软件是否存在于网络上，但网络连接本身不会传达任何信息。相反，它应该能够以通常为发送消息的通信协议标准化的格式发送和接收消息。然后，使用这些标准化消息，设备可以请求有关网络上其他设备的可用性、配置或功能的信息，而无需知道它期望在网络上可用的设备实际上是否真的可用。
- en: Ensuring that the receiving end of any given outgoing connection from a device
    is properly connected, or that the receiving devices are configured accordingly,
    is the concern of the network engineers who support your software. Supporting
    and responding to requests sent by your software is the responsibility of the
    authors of the receiving software. Obviously, if you're working in a sufficiently
    small software shop, both of those roles may well also be filled by you; but in
    a sufficiently mature working environment, you can likely rely on others to handle
    these tasks for you. However, when the time comes to deploy your software to a
    networked device, no information about whether or not those responsibilities were
    handled properly is available to you simply by virtue of being connected to a
    network.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 确保任何给定设备发出的任何出站连接的接收端正确连接，或者接收设备已相应配置，这是支持你的软件的网络工程师的关心的问题。响应由你的软件发送的请求是接收软件作者的职责。显然，如果你在一个足够小的软件公司工作，这两个角色可能也会由你担任；但在一个足够成熟的职场环境中，你很可能会依赖其他人来为你处理这些任务。然而，当你的软件部署到网络设备上的时间到来时，仅仅因为连接到网络，你无法简单地获得这些责任是否得到妥善处理的信息。
- en: Device-agnosticism means that a network has no idea what has connected to it,
    and, accordingly, cannot tell you as much. A corollary attribute of networks is
    that other devices on the network cannot and will not be notified that your device
    or software has connected and been made a resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 设备无关性意味着网络不知道连接到它的是什么，因此，它也无法告诉你太多。网络的一个相关属性是，网络上的其他设备无法也不会通知你的设备或软件已经连接并成为资源。
- en: Ultimately, this is what is meant by an arbitrarily large set of devices. Technically,
    a single computer constitutes a network of one node, and zero connections (though,
    for the purposes of this book, we'll only be considering networks with at least
    two nodes, and at least one connection between any given node and any other node
    on the network), but there is no fixed maximum value of nodes beyond which a network
    ceases to be a network. Any arbitrary number of nodes, from one to infinity (or
    whatever the maximum number of physically possible nodes may be), constitutes
    a valid network, so long as those nodes have some valid connection between themselves
    and the rest of the network.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这就是任意大量设备的意思。技术上讲，一台单独的电脑构成一个由一个节点和零连接组成的网络（尽管，为了这本书的目的，我们只会考虑至少有两个节点，并且任何给定节点与网络中任何其他节点之间至少有一个连接的网络），但没有一个固定的节点数量上限，超过这个上限网络就不再是网络。任何任意数量的节点，从一到无穷大（或者可能的最大物理节点数量），只要这些节点之间以及与网络其他部分之间有有效的连接，就构成了一个有效的网络。
- en: Computational devices
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算设备
- en: Now that we know we can have an arbitrarily large numberof computational devices
    as nodes in our network, it bears further scrutiny to discern what exactly a computational
    device is. While this may seem obvious, at least initially, we can quickly identify
    where it becomes unclear by way of an example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以在网络中拥有任意数量的计算设备作为节点，那么进一步审视一下究竟什么是计算设备是很有必要的。虽然这看起来可能很明显，至少最初是这样，但我们可以通过一个例子很快地识别出它变得不清楚的地方。
- en: As per our definition of a network, the device I'm using to draft this book
    right now might well qualify as a self-contained network. I have a keyboard, mouse,
    monitors, and computer, all connected by standardized channels of communication.
    This looks awfully network-like at a conceptual level, but intuitively, we would
    be inclined to say that it is a network of one, and so, not reallya network at
    all. However, while the what of the non-network status of my computer seems obvious,
    the why might be less clear.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对网络的定义，我现在用来撰写这本书的设备可能完全符合自包含网络的标准。我有一个键盘、鼠标、显示器和电脑，它们都通过标准化的通信通道连接。在概念层面上，这看起来非常像网络，但直观上，我们可能会倾向于说这是一个由一个设备组成的网络，因此，实际上并不是真正的网络。然而，虽然我的电脑的非网络状态在表面上看起来很明显，但原因可能就不那么明确了。
- en: This is where we benefit from clearly explicating what constitutes a computational
    device for the purposes of our definition of a network. Simply being able to perform
    computation is insufficient for a network node. In my example, I can tell you
    that my mouse (a relatively high-end gaming mouse) certainly performs a number
    of complex calculations transforming a laser-sensor signal into directional inputs
    to pass to my computer. My monitors certainly have to do a fair amount of computation
    to transform the raw binary data of pixel color values into the rendered screens
    I see 60 or 120 times per second. Both of these devices are connected by way of
    reliable, standardized communication protocols to my machine, but I wouldn't necessarily
    be inclined to consider them nodes on a network. My computer, when connected to
    the internet, or my local home network, surely constitutes a node, but its individual
    peripherals? I'm inclined to say no.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要明确说明，为了我们定义网络的目的，什么构成了计算设备。仅仅能够执行计算对于网络节点来说是远远不够的。在我的例子中，我可以告诉你，我的鼠标（一款相对高端的游戏鼠标）确实执行了许多复杂的计算，将激光传感器信号转换成方向输入，传递给我的电脑。我的显示器也必须进行相当数量的计算，将像素颜色的原始二进制数据转换成我每秒看到60或120次的渲染屏幕。这两个设备都通过可靠的、标准化的通信协议连接到我的机器上，但我不一定会倾向于认为它们是网络上的节点。当我的电脑连接到互联网或我的本地家庭网络时，它当然构成一个节点，但它的个别外围设备呢？我倾向于说不是。
- en: So, if peripherals aren't network devices, then what essential property is it
    that they're missing? Open communication. While a monitor and a keyboard can communicate
    over a connection with a wide variety of other devices, the manner in which they
    can communicate is restricted to a very specific and limited range of possible
    signals. This highlights an important distinction to be made between distributed
    systems and networks**.** While a network is always a distributed system, a distributed
    system may not necessarily always constitute a network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果外围设备不是网络设备，那么它们缺失的基本属性是什么？开放通信。虽然显示器和键盘可以通过连接与各种其他设备通信，但它们可以通信的方式仅限于一个非常特定和有限的信号范围。这突出了在分布式系统和网络之间需要做出的重要区分**。**虽然网络始终是分布式系统，但分布式系统不一定总是构成网络。
- en: My computer is a distributed system; its components can function independently
    of one another, but they operate in a coordinated fashion to perform the responsibilities
    of a computer. However, my computer is very obviously nota network. It lacks device-agnosticism,
    as each component is explicitly configured to communicate its presence to the
    next node in the graph, so that it can be used to service the needs of the end
    user. It is also not arbitrarily scalable. I can only have, at most, three monitors
    connected to my machine at any given time, and only under very specific conditions
    of connection interfaces and organization. While being connected to a network,
    my computer and each of its peripherals can instead be conceptually considered
    a single, atomic computational device. Thus, on a network, we can specify that
    a computational device is something that can facilitate the requirements of the
    network. It accepts and communicates openly over device-agnostic channels of communication
    to provide or leverage computational resources on that network.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计算机是一个分布式系统；其组件可以独立于彼此运行，但它们以协调的方式运行以执行计算机的责任。然而，我的计算机显然不是一个网络。它缺乏设备无关性，因为每个组件都是明确配置为将其存在通知图中的下一个节点，以便它可以用于满足最终用户的需求。它也不是任意可扩展的。在任何给定时间，我最多只能将三个显示器连接到我的机器上，并且只有在非常具体的连接接口和组织条件下才能做到。当连接到网络时，我的计算机及其每个外围设备在概念上可以被视为一个单一的、原子的计算设备。因此，在网络中，我们可以指定计算设备是能够促进网络需求的东西。它通过设备无关的通信渠道开放接受和通信，以提供或利用该网络上的计算资源。
- en: Navigational devices
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航设备
- en: In our definition of a network, I specify computational or navigational devices.
    For the sake of this book, a navigational device is a valid network device, and
    constitutes a node on our network. The meaningful difference between a computational
    and navigational device (or resource) is that a navigational device provides no
    resources of its own, and instead exists only to facilitate the successful communication
    of other devices on the network. A simple switch or router would fall under this
    category. These devices are still programmed to operate successfully on a network,
    but are typically done at the system level in C or C++, with on-board firmware.
    The concerns of programming these intermediary devices will generally fall outside
    the purview of this book, but I wanted to note the distinction for the sake of
    clarity and completeness.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对网络的定义中，我指定了计算或导航设备。为了这本书的目的，导航设备是一个有效的网络设备，并且构成了我们网络中的一个节点。计算设备和导航设备（或资源）之间的有意义区别在于，导航设备不提供自己的资源，而仅仅存在是为了促进网络中其他设备的成功通信。简单的交换机或路由器就属于这一类别。这些设备仍然被编程以在网络中成功运行，但通常是在系统级别使用C或C++进行，并带有板载固件。对这些中介设备的编程问题通常超出了这本书的范围，但我想要为了清晰和完整性而指出这种区别。
- en: Channels of communication
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信渠道
- en: Within the context of networks, what constitutes a channel of communication
    is merely a shared interface for data transmission between any two devices on
    a network. There are no constraints on the physical implementation of a channel
    of communication, or the format in which data must be transmitted over a channel,
    simply that at least two devices can communicate across that channel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络的环境中，构成通信渠道的仅仅是网络中任何两个设备之间数据传输的共享接口。对通信渠道的物理实现没有约束，也没有对通过渠道传输的数据格式的要求，只需至少两个设备可以通过该渠道进行通信。
- en: The software impact
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件影响
- en: When writing software meant to leverage or be leveraged by other devices on
    a network, there are a number of new considerations and constraints that developers
    are shielded from when only writing code for local systems. How these issues are
    best dealt with will be addressed more thoroughly in subsequent chapters, but
    for now it is worth considering what the impact these aspects of general computer
    networks might have on the software we write.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写旨在利用或被网络上的其他设备利用的软件时，开发者需要考虑和约束的新问题，当只为本地系统编写代码时，这些问题是受到保护的。如何最好地处理这些问题将在后续章节中更详细地讨论，但就目前而言，考虑这些一般计算机网络方面的方面对我们编写的软件可能产生的影响是值得的。
- en: The impact of device-agnosticism
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备无关性的影响
- en: When we talk about device-agnosticism, we assume our software is not given information
    about which resources we expect to be available areactually available. So, going
    back to the example of my computer as a distributed system that is not a network,
    I can reliably write local programs that print or draw information to a screen.
    Because the program is executed locally, I can trust that my operating system
    will take responsibility for acquiring the connection to my monitor and transmitting
    the data from my program's stack frame to the monitor's display port connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论设备无关性时，我们假设我们的软件没有关于我们期望可用的资源实际上是否可用的信息。因此，回到我的计算机作为分布式系统而不是网络的例子，我可以可靠地编写本地程序，将信息打印或绘制到屏幕上。因为程序是在本地执行的，我可以相信我的操作系统将负责获取与我的监视器的连接，并将从我的程序堆栈帧到监视器显示端口连接的数据传输。
- en: The monitors are resources that are not inherent to the distributed system;
    I can technically execute any series of commands on my computer without a monitor.
    It's not essential for the system to function, even if it is essential for the
    system to function in a way that is decipherable to me. However, I can reliably
    assume that if the monitors are present on the system, my software will have access
    to them, because my operating system acts as an intelligent broker of requests
    between those peripherals. It will always have, and be capable of delivering,
    information about the status of any peripherals that my software needs to use.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 监视器不是分布式系统固有的资源；我可以在我自己的计算机上技术上执行任何一系列命令而不需要监视器。对于系统功能来说，这不是必要的，即使对于系统以我能够理解的方式运行来说，这是必要的。然而，我可以可靠地假设，如果监视器存在于系统中，我的软件将能够访问它们，因为我的操作系统充当了那些外围设备之间请求的智能经纪人。它将始终存在，并且能够提供任何我的软件需要使用的设备的状态信息。
- en: As soon as my software needs to access resources distributed on a network*,*
    however, I can no longer make assumptions about the availability of those resources.
    That's the crux of device-agnosticism and how it impacts networked programs. Where
    the operating system of my computer served as an intelligent broker, we cannot
    assume the same of a network. So, verifying the presence of resources, and our
    ability to access them, becomes a key component in the design of our software.
    And I'll note that this task becomes more challenging when we have multiple devices
    on our network that could provide the resources we're looking for.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的软件需要访问网络上分布的资源时*，*然而，我不能再对这些资源的可用性做出假设。这就是设备无关性的核心，以及它如何影响网络程序。当我的计算机的操作系统作为智能经纪人时，我们不能假设网络也是如此。因此，验证资源的存在以及我们访问它们的能力，成为我们软件设计中的关键组成部分。并且我要指出，当我们有多个设备可以提供我们正在寻找的资源时，这项任务变得更加具有挑战性。
- en: In that case, it's the responsibility of some software on the network to determine
    which specific device ultimately services our software's request for that resource.
    Whether that work is done by our own program as part of its communication algorithm,
    or handled by some other intelligent broker deployed to the network to facilitate
    this situation, the work needs to be done for our software to behave reliably
    on such a network.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，网络中某些软件的责任是确定哪个特定设备最终为我们软件请求的资源提供服务。这项工作是由我们自己的程序作为其通信算法的一部分来完成，还是由部署到网络中的某些其他智能经纪人来处理以促进这种情况，这项工作都需要完成，以便我们的软件能够在这样的网络上可靠地运行。
- en: Writing for open communication
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为开放通信编写
- en: When we talk about open communication on networks, we're talking about collaboration
    between different devices or software components. This collaboration puts some
    responsibility on every developer who intends to leverage the resources of another;
    the responsibility to agree upon some standard for communication, and to respond
    according to that agreed upon standard. There may be a functionally infinite number
    of ways to format data to send and receive over a pipe, but unless someone else
    on the network has agreed to receive your data in the format you've decided to
    send it, none of it can be considered valid*.* You are, essentially, screaming
    into the void.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论网络上的开放通信时，我们是在谈论不同设备或软件组件之间的协作。这种协作给每个打算利用其他资源资源的开发者带来了一些责任；即达成一些通信标准的共识，并按照该协议作出响应。在管道中发送和接收数据的方式可能有功能上无限多种，但除非网络上的其他人同意以你决定发送的格式接收你的数据，否则这些都无法被认为是有效的*.*
    你本质上是在对空喊。
- en: The broad range of possibility creates a need for standardization that is met
    by an equally broad number of organizations, including the **World Wide Web Consortium**
    (**W3C**) and the **International Standards Organization** (**ISO**). What this
    means for you is that you will ultimately be responsible for understanding what
    standards your software should adhere to in order to meet the functional requirements
    of your projects, and to provide the most value to other users of your product.
    Common standards you'll learn about in this book include communication protocols,
    such as TCP, UDP, and HTTP, as well as addressing and naming standards such as
    the IP addressing standard and the domain naming system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性的广泛范围产生了一个需要标准化的需求，这个需求由同样广泛数量的组织来满足，包括**万维网联盟**（**W3C**）和**国际标准化组织**（**ISO**）。这意味着对你来说，你最终将负责理解你的软件应该遵守哪些标准，以便满足你项目的功能需求，并为你的产品的其他用户提供最大价值。在这本书中，你将了解到的一些常见标准包括通信协议，如TCP、UDP和HTTP，以及寻址和命名标准，如IP寻址标准和域名系统。
- en: Topologies and physical infrastructure
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**拓扑结构和物理基础设施**'
- en: Having spent a sufficient amount of time discussing what a network is, we should
    now consider how networks are actually implemented. This section will consider
    the various solutions that the engineers have arrived at to build systems that
    meet the definition of a network. We'll discuss the distinction between a logical
    and a physical topology for a network, and then examine the most common examples
    of the former.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在花费足够的时间讨论了什么是网络之后，我们现在应该考虑网络是如何实际实现的。本节将考虑工程师们为构建符合网络定义的系统而找到的各种解决方案。我们将讨论网络逻辑拓扑和物理拓扑之间的区别，然后检查前者的最常见例子。
- en: Physical and logical topologies
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**物理和逻辑拓扑**'
- en: In the same way that the topology of a geographic region describes how the features
    of that region are arranged over the area of the region, the topology of a network
    describes how the components of that network are arranged relative to one another.
    There are two ways to think about the organization of networks. As should be obvious,
    having read the header for this subsection, they are the physical topology and
    the logical topology**.**
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就像地理区域的拓扑结构描述了该区域特征如何安排在该区域的面积上一样，网络的拓扑结构描述了该网络组件相对于彼此的排列方式。思考网络组织的方式有两种。正如本小节标题所暗示的，它们是物理拓扑和逻辑拓扑**。**
- en: The physical topology describes how a network is physically connected and organized
    in real space. It describes the medium by which connections are established, the
    medium of the connections themselves, the location of devices in physical space,
    and the layout of the connections between nodes. It is determined, in part, by
    the specific networking devices of the network and the connections those devices
    allow (I can't use coaxial cabling to connect to a router with only Ethernet ports).
    Separately, the physical topology itself determines the maximum capabilities of
    the network in terms of performance, resilience, and, in some cases, even security.
    Imagine that all incoming network traffic trying to access a **local area network**
    (**LAN**) I own must be funneled through a firewall for security purposes. If
    I only expose one physical device to act as that firewall, my network won't be
    very fault tolerant. However, if I expose multiple firewall devices, with each
    servicing requests from different regions, I can increase my fault tolerance considerably.
    Especially if each is capable of serving as a backup in the event that one of
    the others is taken offline for any reason. The physical topology of one firewall
    provides less fault tolerance than the physical topology of several.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 物理拓扑描述了网络在真实空间中的物理连接和组织方式。它描述了建立连接的介质，连接本身的介质，设备在物理空间中的位置，以及节点之间连接的布局。它部分由网络的具体网络设备和这些设备允许的连接决定（我无法使用同轴电缆连接到只有以太网端口的路由器）。另外，物理拓扑本身决定了网络在性能、弹性和在某些情况下甚至安全性方面的最大能力。想象一下，所有试图访问我拥有的**局域网**（**LAN**）的入站网络流量都必须通过防火墙进行安全过滤。如果我只暴露一个物理设备作为防火墙，我的网络将不会有很高的容错能力。然而，如果我有多个防火墙设备，每个设备服务于不同区域的请求，我可以大大提高我的容错能力。特别是如果每个设备都能在另一个设备因任何原因离线时作为备份，那么一个防火墙的物理拓扑提供的容错能力将低于多个防火墙的物理拓扑。
- en: The physical topology also describes the variety of network devices I use on
    the network at any point in time. This is where our high-level abstractions of
    communication channel and node or computational device is brought down into concretions.
    Instead of a link or connection, a physical topology characterizes a connection
    as wired or wireless. A robust topology may even specify the type of wire used
    as coaxial or fiber optic cables, as is typical of most high-speed home internet
    connections, or as twisted-pair copper wire, like what's used for telecom networks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 物理拓扑还描述了我在任何给定时间点使用的网络设备的多样性。这是我们的高级通信通道和节点或计算设备抽象被具体化的地方。物理拓扑不是用链路或连接来描述的，而是将连接描述为有线或无线。一个健壮的拓扑甚至可能指定使用的线缆类型，如同轴电缆或光纤电缆，这在大多数高速家庭互联网连接中很典型，或者像电信网络中使用的双绞线。
- en: This is also where our network nodes get nailed down to a concrete, specific
    device. Instead of a computational device, we have switches, routers, bridges,
    and **network-interface controllers** (**NIC**). Each of these devices is responsible
    for a different task or service on a network, and some, or all, of them may be
    present on any given implementation. For example, I have no need for a bridge
    on my home wireless network, but it would be impossible to imagine how the entire
    internet could exist without the use of each and every device I listed, and dozens
    more that I haven't.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们的网络节点被固定到具体、特定设备的地方。我们不是使用计算设备，而是使用交换机、路由器、网桥和**网络接口控制器**（**NIC**）。这些设备中的每一个都在网络上负责不同的任务或服务，并且它们中的某些或全部可能存在于任何特定的实现中。例如，在我的家庭无线网络上，我并不需要网桥，但很难想象整个互联网在没有使用我列出的每一个设备以及更多我没有列出的设备的情况下如何存在。
- en: 'Meanwhile, the logical topology of a network explains the conceptual organization
    of relevant actors on the network, and the connective paths over which they can,
    or must, communicate with any other actors on that network. One important consideration
    to make, though, is that physical topologies do not necessarily map directly to
    the logical topology. Looking back at our earlier example of a physical topology
    with one firewall as compared to a physical topology of multiple firewalls, we
    can illustrate the distinction between physical and logical. First, let''s take
    a look at the initial, naive implementation of an internal network with a single
    physical firewall device to restrict access to our server resources:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，网络的逻辑拓扑解释了网络中相关参与者之间的概念组织，以及他们可以或必须通过哪些连接路径与该网络上的任何其他参与者进行通信。然而，有一个重要考虑因素需要指出，物理拓扑并不一定直接映射到逻辑拓扑。回顾我们之前关于具有一个防火墙的物理拓扑与具有多个防火墙的物理拓扑的例子，我们可以说明物理和逻辑之间的区别。首先，让我们看看使用单个物理防火墙设备来限制对服务器资源的访问的初始、天真实现：
- en: '![](img/e1a34020-234c-433e-a8ed-f9f75a42dd03.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1a34020-234c-433e-a8ed-f9f75a42dd03.png)'
- en: Initial, single-firewall physical topology
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的单防火墙物理拓扑
- en: 'While a complete physical topology would define and describe the type of connection
    supported, and perhaps even define the model of the physical devices represented
    in the preceding diagram, this will be sufficient for our purposes. Next, let''s
    look at the more resilient physical topology with multiple firewalls and a failover
    strategy for unresponsive firewalls:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完整的物理拓扑将定义和描述支持的连接类型，甚至可能定义前面图中表示的物理设备的型号，但这将满足我们的目的。接下来，让我们看看具有多个防火墙和未响应防火墙的故障转移策略的更具弹性的物理拓扑：
- en: '![](img/00c0380a-fa01-4cd8-a9a0-1edbe78f27b1.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00c0380a-fa01-4cd8-a9a0-1edbe78f27b1.png)'
- en: It's easy to see why the physical topology diagram would be different, because
    there are different physical components in play. What's more, for as simple a
    difference as it is between them, the physical difference between the two is non-trivial,
    as the second topology has a meaningful impact on the owner of the network in
    terms of cost, reliability, and performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出物理拓扑图为什么会不同，因为其中涉及不同的物理组件。更重要的是，尽管它们之间的差异很简单，但这两个物理之间的差异并非微不足道，因为第二个拓扑对网络所有者在成本、可靠性和性能方面有重要的影响。
- en: 'The point we want to make with this, however, is that in both physical implementations,
    the logical topology remains the same. If we think of the single firewall (in
    the case of the first physical topology) and the multi-firewall along with requesting
    the brokering router (in the case of the second physical topology) as being, conceptually,
    a single secure access point into our internal network, then we can easily see
    how both physical topologies map to the following logical topology:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们想要说明的是，在这两种物理实现中，逻辑拓扑保持不变。如果我们把单个防火墙（在第一种物理拓扑的情况下）和多个防火墙以及请求中继路由器（在第二种物理拓扑的情况下）在概念上视为进入我们内部网络的单一安全接入点，那么我们可以很容易地看到这两种物理拓扑如何映射到以下逻辑拓扑：
- en: '![](img/87c248bf-016f-4675-b5d4-383bbf73fb68.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87c248bf-016f-4675-b5d4-383bbf73fb68.png)'
- en: Looking at this diagram, you might also notice that it bears a striking resemblance
    to the physical layout of the first diagram, but looks wholly different from the
    second. This serves to illustrate the fact that a logical topology might map one-to-one
    to its physical counterpart, but does not necessarilymap one-to-one with its physical
    implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个图，你可能会注意到它与第一个图的物理布局非常相似，但与第二个图完全不同。这有助于说明逻辑拓扑可能与它的物理对应物一对一映射，但并不一定与它的物理实现一对一映射。
- en: For the remainder of this book, we'll exclusively be concerned with the logicaltopology
    of a network, as this abstraction defines the interactions we'll be processing
    in the software we build. Device manufacturers can deal with the hardware components,
    and network engineers can work to meet the physical performance constraints. We'll
    just think about what resources we need, or need to provide, and how we can meet
    those needs. The logical topology will be sufficient for that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将专门关注网络的逻辑拓扑，因为这种抽象定义了我们将在构建的软件中处理的交互。设备制造商可以处理硬件组件，网络工程师可以努力满足物理性能限制。我们只需考虑我们需要什么资源，或者需要提供什么资源，以及我们如何满足这些需求。逻辑拓扑将足够满足这一点。
- en: The specific organization of the logical topology of our network may well have
    an impact on our software implementation, however, and there is a variety of common
    topologies with their own strengths and disadvantages we'll want to consider,
    so we should take some time to do so now.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们网络的逻辑拓扑的具体组织可能对我们的软件实现有影响，并且存在各种常见的拓扑，它们各自有其优势和劣势，我们需要考虑，因此我们应该花些时间来做这件事。
- en: Point-to-point topology
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点对点拓扑
- en: Let's start with the most basic. A point-to-point topology is exactly what it
    sounds like. A single logical connection between two nodes on a network. This
    topology is how we would define a minimum complete network, which is to say, at
    least one connection between at least two nodes. It is the lowest cost in terms
    of implementation, and has the lowest impact on the engineering considerations
    for software meant to be deployed to such a network. Point-to-point networks can
    maintain a dedicated connection between the two relevant nodes, or establish that
    connection dynamically as needed. Any direct peer-to-peer communication is an
    instance of a point-to-point network on your system, even if that peer-to-peer
    connection is established over a more complicated logical network topology, the
    communication session itself is an instance of a logical point-to-point topology.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的概念开始。点对点拓扑学正如其名。网络中两个节点之间的一条单一逻辑连接。这种拓扑学定义了一个最小完整网络，也就是说，至少两个节点之间至少有一个连接。在实现成本方面，这是最低的，并且对部署到此类网络的软件的工程考虑影响最小。点对点网络可以在两个相关节点之间保持专用连接，或者根据需要动态建立该连接。任何直接的点对点通信都是你系统上点对点网络的一个实例，即使该点对点连接是在更复杂的逻辑网络拓扑上建立的，通信会话本身也是逻辑点对点拓扑的一个实例。
- en: While the cost of a point-to-point connection might be exceptionally low, the
    benefits you can possibly reap from those costs are also extremely low. The kinds
    of problems solved by a point-to-point network design are limited in scope, and
    are usually specific to an immediate problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然点对点连接的成本可能非常低，但你可以从这些成本中获得的好处也非常低。点对点网络设计解决的问题范围有限，通常与一个直接的问题相关。
- en: Linear topology (daisy-chaining)
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性拓扑（菊花链）
- en: A linear topology is exactly what it sounds like – a line! It is the most primitive
    extension of the point-to-point topology, one of the simplest logical topologies
    conceptually, and often one of the cheapest in terms of a corresponding physical
    implementation. In a linear network topology, we extend our point-to-point model
    in such a way as to only ever have one node connected to at most two other nodes
    at a given time. The benefit here is obviously in the physical implementation
    cost (even with high resiliency, this configuration can only ever get so complicated).
    The drawback, however, should be similarly obvious. Communication from one node
    to any node other than one of its nearest neighbors will require the intermediary
    nodes to do some work investigating the target of the inbound request and determine
    if they are suitable to process the request, and if not, know to pass the request
    along to the neighbor that didn't originate the request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 线性拓扑学正如其名——一条线！它是点对点拓扑学最原始的扩展，从概念上讲，是最简单的逻辑拓扑之一，并且在物理实现方面通常也是最便宜的。在线性网络拓扑中，我们扩展我们的点对点模型，使得在任何给定时间只有一个节点连接到最多两个其他节点。这里的优势显然在于物理实现成本（即使具有高可靠性，这种配置也只能变得如此复杂）。然而，缺点也同样明显。从一个节点到除其最近邻节点之外的其他节点的通信将需要中间节点做一些工作，调查目标请求，并确定它们是否适合处理该请求，如果不适合，知道将请求传递给未发起请求的邻居。
- en: Note that specification to not return the request to the neighbor that originated
    the request in the first place. If the nodes responded by simply submitting the
    request back out to both of your neighbors blindly, you would end up in an infinite
    loop of submitting and re-submitting the request between the two nodes. At least
    one of the nodes in any pair has to be aware enough to not re-submit a request
    to its originator. This highlights the most important drawback of this topology.
    Specifically, that it requires a tight coupling of nodes to their conceptual position
    in the network structure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不要将请求返回给最初发起请求的邻居。如果节点通过简单地向两个邻居盲目提交请求来响应，你将陷入在两个节点之间提交和重新提交请求的无穷循环。在任何一对节点中，至少有一个节点必须足够意识到不要向其发起者重新提交请求。这突出了这种拓扑最重要的缺点。具体来说，它需要节点与其在网络结构中的概念位置紧密耦合。
- en: While none of this is particularly complicated, you can already see how the
    logical organization of your network can impact the design of your networking
    code. That will only become more apparent as the complexity of the topology increases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一切并不特别复杂，但你已经可以看到你的网络逻辑组织如何影响你的网络代码设计。随着拓扑复杂性的增加，这一点将变得更加明显。
- en: Bus topology
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总线拓扑
- en: 'A bus topology is one in which every single node on the network is connected
    to every other node on the network by way of a single channel of communication,
    as seen in the following diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总线拓扑是一种网络拓扑，其中网络上的每个节点都通过单个通信通道连接到网络上的每个其他节点，如下面的图所示：
- en: '![](img/8274a2f7-9a0e-456d-b23f-98ec4c290bc2.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8274a2f7-9a0e-456d-b23f-98ec4c290bc2.png)'
- en: Each connection coming off of a node is joined to a shared connection between
    all nodes by way of a simple connection interface. Any packets sent by a node
    on a bus topology will be transmitted on the same bus as every other packet transmitted
    over the network, and each node on the bus is responsible for identifying whether
    or not it is the most suitable node to service the request carried by that packet.
    Similar to the linear network previously described, packets on a bus topology
    must contain information about the target node for the request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点发出的每个连接都通过简单的连接接口连接到所有节点之间的共享连接。在总线拓扑上发送的任何数据包都将与网络上传送的每个其他数据包在同一个总线上传输，并且总线上的每个节点都负责确定它是否是服务该数据包所携带请求的最合适的节点。类似于之前描述的线性网络，总线拓扑上的数据包必须包含有关请求目标节点的信息。
- en: As is the case with each of the topologies of lesser complexity, the bus topology
    has the obvious benefit of a low upfront cost of implementation, and relatively
    low overheads for orchestration. Hopefully, however, the previous description
    I provided helps to characterize the particular challenges associated with this
    particular network topology. Because all network communication happens over a
    single channel, all traffic, even under ideal circumstances, is limited by the
    bandwidth of that channel. Especially chatty software doesn't do well on a bus
    topology, as it tends to monopolize the link between nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个较低复杂性的拓扑一样，总线拓扑具有明显的优点，即实施成本低，以及相对较低的开销。然而，希望我之前的描述有助于描述与这种特定网络拓扑相关的特定挑战。因为所有网络通信都通过单个通道进行，所以即使在理想情况下，所有流量也受该通道带宽的限制。特别是，在总线拓扑上，健谈的软件表现不佳，因为它往往会垄断节点之间的连接。
- en: Additionally, because there is only a single channel of communication across
    the whole of the network, that channel serves as a single point of failure for
    the network. If the central bus comes offline, then each node is isolated simultaneously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于整个网络中只有一个通信通道，因此该通道成为网络的单一故障点。如果中心总线断开，那么每个节点将同时被隔离。
- en: Star topology
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 星型拓扑
- en: 'Finally, we begin to consider network topologies more common in enterprise
    networks. The star topology is arranged in such a way as to produce an asterisk-like
    star shape, with each peripheral node connected by a single channel to a central
    hub-node, as demonstrated in the following diagram:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始考虑在企业网络中更常见的网络拓扑。星型拓扑以产生类似星形的形状排列，每个外围节点通过单个通道连接到中心集线器节点，如下面的图所示：
- en: '![](img/44b58274-dd79-4b7c-a914-83fc3edd9596.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44b58274-dd79-4b7c-a914-83fc3edd9596.png)'
- en: The **hub** of a star topology serves as a broker of communication between all
    peripheral nodes. It receives and forwards requests from each of its peripheral
    nodes by way of a direct, point-to-point connection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 星型拓扑的**中心节点**充当所有外围节点之间的通信代理。它通过直接、点对点连接接收并转发其外围节点中的每个节点的请求。
- en: This topology provides the benefit of isolating the failures of peripheral nodes
    or their connections to the hub to those nodes specifically. Each of the other
    nodes can maintain their connections to all the other nodes in the network with
    any one of them going down. It is also, at least conceptually if not physically,
    infinitely scalable. The only task necessary to add a node to the network is to
    add a link between the new node and the hub node.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种拓扑的优点在于将外围节点或它们与中心节点的连接故障隔离到特定的节点。其他每个节点都可以通过任何一个节点故障来维持与网络中所有其他节点的连接。它至少在概念上（如果不是在物理上）是无限可扩展的。向网络添加节点的唯一必要任务是添加新节点与中心节点之间的链接。
- en: Hopefully, by this point in the discussion of network topology, you'll already
    have identified the obvious downside to this approach. If the hub-node goes offline,
    the entire network is eliminated. From the perspective of any one peripheral node, loss
    of the hub means a loss of the entire network, since everything can only ever
    communicate with the hub.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到讨论网络拓扑的这一阶段，你已经已经识别出这种方法的明显缺点。如果中心节点离线，整个网络就会消失。从任何一个外围节点的角度来看，中心节点的丢失意味着整个网络的丢失，因为所有通信只能与中心节点进行。
- en: In reading my description, you may have also realized that some network topologies
    can be decomposed into sub-networks of completely different topologies. A network
    defined by any given peripheral node and the hub node of a star topology is itself
    a single instance of a point-to-point network. Likewise, a network defined by
    any twoperipheral nodes and the hub node of a star topology is technically a linear
    topology (which is itself a specialized implementation of the bus topology). By
    logically extending these simple diagrams into larger compositional topologies,
    we can describe any kind of network you could possibly write software for.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读我的描述时，你可能也已经意识到，某些网络拓扑可以被分解为具有完全不同拓扑的子网络。由任何给定外围节点和星型拓扑的中心节点定义的网络本身就是点对点网络的单个实例。同样，由任何两个外围节点和星型拓扑的中心节点定义的网络在技术上是一种线性拓扑（它本身是总线拓扑的一种特殊实现）。通过逻辑上扩展这些简单的图到更大的组合拓扑，我们可以描述任何可能为软件编写的网络类型。
- en: Ring topology
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环形拓扑
- en: 'A ring topology is very similar to a linear topology (which, as I noted before,
    is technically an implementation of the bus topology) except that, in the case
    of a ring topology, the endpoints are ultimately connected, and communication
    is unidirectional, as shown in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 环形拓扑与线性拓扑非常相似（正如我之前提到的，线性拓扑在技术上是一种总线拓扑的实现），只不过在环形拓扑的情况下，端点最终是连接在一起的，通信是单向的，如下面的图所示：
- en: '![](img/196aa31f-9d9d-45c3-8b6e-2faadbcb99ab.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![环形拓扑](img/196aa31f-9d9d-45c3-8b6e-2faadbcb99ab.png)'
- en: The benefit of this particular network topology might not be immediately apparent,
    but with each node in the network serving as a peer of the previous node in the
    chain, there's no need for any request broker, or communication specific software
    or hardware. This can lower your network management costs substantially.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的网络拓扑的优点可能不会立即显现，但网络中的每个节点都作为链中前一个节点的对等节点，因此不需要任何请求代理或特定的通信软件或硬件。这可以大幅度降低您的网络管理成本。
- en: The drawbacks are similar to each of the previous implementations in that, once
    a link in the chain is broken, the network is essentially rendered useless. Technically,
    because of the unidirectional communication pattern of a ring topology, the node
    residing immediately after the broken link in the chain can still communicate
    with every other node in the network, and maintain some degree of operation. However,
    since any responding device would be incapable of transmitting their response
    back to the originating node, communication would be one-way for all nodes on
    the chain. I'm having an extremely hard time imagining a scenario in which a device
    on a network can meaningfully interact with a distributed system via strict one-way
    communication.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其缺点与之前每种实现方式相似，即一旦链中的某个链接断裂，网络基本上就变得毫无用处。技术上，由于环形拓扑的单向通信模式，链中断裂链接之后的节点仍然可以与网络中的每个其他节点通信，并保持一定程度的运行。然而，由于任何响应设备都无法将它们的响应传回原始节点，因此链上的所有节点之间的通信将是一向的。我很难想象一个场景，其中网络上的设备可以通过严格的一向通信有意义地与分布式系统交互。
- en: Another less obvious downside to this is that the maximum performance of the
    whole network would be limited by the lowest performing link between any two nodes
    in the network. This is the case because any round-trip communication of request-response
    between two nodes would necessarily traverse the whole chain.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不那么明显的缺点是，整个网络的最大性能将受到网络中任意两个节点之间性能最差链接的限制。这是因为任何两个节点之间请求-响应的往返通信必然要穿越整个链。
- en: Mesh topology
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格拓扑
- en: 'The mesh topology is one of the most resilient and common network topologies
    in use today. And the reason for that is that it is almost entirely arbitrary
    in how it is organized. A mesh topology simply describes any non-formal topology
    of connectivity in which some nodes are connected by way of a single point-to-point
    connection to some other nodes, and some may have multiple connections to multiple
    nodes. The original graph diagram from the beginning of this chapter, shown as
    follows, is technically a mesh network topology:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 网格拓扑是目前使用中最具弹性和最常见的一种网络拓扑。其原因是它在组织方式上几乎完全是任意的。网格拓扑简单描述了任何非正式的连接拓扑，其中一些节点通过单点对点连接与其他节点相连，而一些节点可能与其他多个节点有多个连接。本章开头的原始图示，如下所示，在技术上是一个网格网络拓扑：
- en: '![](img/9057649e-d8a6-4b6d-bcda-3870d05f9b1b.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9057649e-d8a6-4b6d-bcda-3870d05f9b1b.png)'
- en: In case you forgot.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了。
- en: You'll note that the nodes in the preceding diagram have anywhere from one to
    three direct connections to other nodes in the network. This can provide some
    of the resilience of other network topologies where necessary, without incurring
    their costs. Since there is no obvious specification for a mesh network other
    than that it does not fully implement any of the other network topologies we discussed,
    it can include networks with an arbitrary degree of connectivity between nodes
    up to, and including, a fully-connected mesh network.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，前一个图中的节点与其他网络中的节点有从一到三个直接连接。这可以在必要时提供其他网络拓扑的一些弹性，而不会产生它们的成本。由于网格网络没有明显的规范，除了它没有完全实现我们讨论过的任何其他网络拓扑之外，它可以包括节点之间具有任意连接度的网络，包括完全连接的网格网络。
- en: Fully connected mesh network
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全连接的网格网络
- en: 'A fully connected mesh network is one in which every node has a direct connection
    to every other node in the network, as demonstrated in the following diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全连接的网格网络是这样的，其中每个节点都与网络中的每个其他节点有直接连接，如下面的图示所示：
- en: '![](img/2429ea22-6539-483c-81e6-e7ddfa851e9d.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2429ea22-6539-483c-81e6-e7ddfa851e9d.png)'
- en: If this diagram looks a bit crowded to you, you've already noticed the single
    biggest drawback of a fully-connected mesh network. It's nearly impossible to
    scale beyond a certain point, because each new node on the network requires a
    connection for each previously connected node on the network. The math works out
    to a quadratic increase in connections for each new node to be added. Moving past
    a few nodes on the network becomes physically impossible very quickly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个图看起来有点拥挤，你已经注意到了完全连接的网格网络最大的缺点。几乎不可能扩展到某个点以上，因为网络上的每个新节点都需要与网络中之前连接的每个节点建立连接。对于每个要添加的新节点，连接的数量呈二次增长。在网络中超过几个节点后，物理上变得几乎不可能。
- en: The incredibly high cost of a fully connected mesh network, however, brings
    with it the most stable and resilient topology possible. No node has to be responsible
    for packet-forwarding or request switching, because there should be no context
    in which two nodes are communicating with each other indirectly. Any one node
    or connection between nodes can go down, and every other node on the network has
    full connectivity with no loss of performance. A single weak connection between
    two nodes has zero impact on the performance of any other two nodes. As topologies
    go, a fully connected mesh is bulletproof. It's also often prohibitively expensive,
    and so not common in anything but the smallest and most trivial contexts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个完全连接的网状网络的成本非常高，但它带来了最稳定和最具有弹性的拓扑。没有节点需要负责数据包转发或请求切换，因为不应该存在两个节点间接通信的上下文。任何一个节点或节点之间的连接都可以中断，而网络上的其他每个节点都可以保持完整的连接性，没有任何性能损失。两个节点之间单一薄弱的连接对任何其他两个节点的性能没有影响。从拓扑的角度来看，完全连接的网状拓扑是坚不可摧的。它也往往过于昂贵，因此在除了最小和最简单的情况下，并不常见。
- en: Hybrid and specialized topologies
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合和专用拓扑
- en: As I mentioned before, most larger networks over which you might need to access
    resources are composed of multiple topologies joined together into what are typically
    called **hybrids**. A star topology, in which one of the peripheral nodes is also
    a link in a linear topology, would be an example of such a hybrid.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，你可能需要访问资源的多数大型网络都是由多个拓扑结构组合而成的，通常被称为**混合型**。例如，一个星型拓扑，其中外围节点之一也是线性拓扑中的一个链路，就是这种混合型拓扑的一个例子。
- en: Other kinds of topologies are actually variants of the topologies we've discussed
    here. For example, a scenario where a node of a linear network topology is also
    the access point to a secondary linear topology constitutes a tree topology, simply
    a hierarchical linear topology. The specifics of these structures are less important
    than knowing that they exist and that, depending on the nature of the software
    you intend to deploy onto a network, you know that there are costs and considerations
    to be made for them. And speaking of those costs...
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的拓扑实际上是我们在本节中讨论的拓扑的变体。例如，一个线性网络拓扑的节点同时也是次要线性拓扑的接入点的情况构成了一个树型拓扑，简单地说，就是一个分层线性拓扑。这些结构的细节不如知道它们的存在重要，以及根据你打算部署到网络上的软件的性质，你知道对于它们有成本和考虑需要做出。说到这些成本...
- en: The software impact of distributing resources on a network
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在网络上分配资源对软件的影响
- en: All this talk of device-agnosticism and open communication might sound extremely
    abstract up to this point. You may well be reading this and wondering yeah, so
    what? I don't have to code a network switch, which is probably true. It is certainly
    true that you won't have to code a network switch in C# using .NET Core, since
    that is quite a bit beyond the scope and capabilities of the framework, and thus,
    this book. The impact of the unpredictability of a network on your software, however,
    will be pretty substantial, and that will be true no matter what part of the network
    stack you're programming for. So, let's look at some of the ways your code should
    be prepared for distributed systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有关于设备无关性和开放通信的讨论可能听起来非常抽象。你可能正在阅读这段内容，心想，嗯，那又怎样呢？我不用编写网络交换机的代码，这可能确实如此。确实，你不必使用.NET
    Core在C#中编写网络交换机的代码，因为这远远超出了框架的范围和能力，因此，这本书的范围。然而，网络不可预测性对你的软件的影响将是相当大的，并且这将对网络堆栈的任何部分编程都是如此。所以，让我们看看你的代码应该如何为分布式系统做好准备。
- en: Security
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: I've gone to the most obvious and complicated issue first,because I personally
    find it to be the most interesting. Writing software in a professional context
    will, across the board, require you to code your applications to be secure. Even
    if your job doesn't explicitly require it, I would argue until I'm blue in the
    face that, as an engineer, you have an ethical obligation to write secure software
    regardless. That can be a daunting task. Especially since having secured software
    is always a moving target. It's important that you keep this in mind, though,
    because making your software useful as a resource to a wide variety of benevolent
    consumers inherently opens you up to malicious intent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先讨论了最明显且复杂的问题，因为我认为这最有意思。在专业环境中编写软件，总体上要求你编写安全的应用程序。即使你的工作没有明确要求，我也会不遗余力地争论，作为一个工程师，你有道德义务编写安全的软件，无论是否明确要求。这可能是一项艰巨的任务。特别是，因为确保软件安全始终是一个移动的目标。然而，重要的是要记住，让你的软件作为一个资源对广泛的善意消费者有用，这本质上会使你面临恶意意图。
- en: This is where device-agnosticism and open communication become hugely important.
    Device-agnosticism means you can't reasonably be sure that a malicious actor hasn't
    gained access to a network that you may have assumed was secured upstream from
    your hosting environment. You will only ever see and process requests on the access
    points to your software. And open communication means you may end up getting a
    number of requests that are malformed that you'll attempt to parse initially,
    before determining that you can't, and disposing of them. This need to first read
    the messages you're given, in order to know, if they're something you care about,
    as that ultimately exposes you to malicious commands or code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设备无关性和开放通信变得极其重要的地方。设备无关性意味着你无法合理地确信一个恶意行为者没有访问到你可能认为已经在上游托管环境中得到保护的网络安全。你将只会在你的软件的访问点上看到和处理请求。开放通信意味着你可能会收到许多格式不正确的请求，你将尝试最初解析它们，然后确定你无法解析，并将它们丢弃。这种首先读取你给出的消息的需要，以便知道它们是否是你关心的，因为这最终会使你面临恶意命令或代码。
- en: Thankfully, as we'll explore later, the .NET Core libraries provide a wide array
    of strong security components right out of the box, and the leg-work of getting
    and leveraging the encryption libraries and request sanitizing algorithms is just
    a matter of knowing what `using` statements to include at the top of your source
    files.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如我们稍后将要探讨的，.NET Core 库提供了大量的强大安全组件，直接开箱即用，而获取和利用加密库以及请求清理算法的工作，只需知道在源文件顶部包含哪些`using`语句即可。
- en: Communication overhead
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信开销
- en: The other, most obvious concern you face with networked programming is dealing
    with the openness of open communication. That property means that you'll have
    to spend a substantial amount of time familiarizing yourself with the specific
    messaging standards of different communication protocols (which I'll cover in
    depth in this book). There's an immense amount of organization necessary to cram
    data into well-formed packets, with appropriate header information to tell your
    software when to start and when to stop reading from your connection to get the
    full, uninterrupted binary stream and convert that back into meaningful data structures
    in your code. It's a headache just describing the process.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络编程中，你面临的另一个最明显的问题是如何处理开放通信的开放性。这一特性意味着你将不得不花费大量时间熟悉不同通信协议的具体消息标准（我将在本书中深入探讨）。将数据压缩成格式良好的数据包，并添加适当的头部信息，以便告诉你的软件何时开始和何时停止从你的连接中读取以获取完整的、不间断的二进制流，并将其转换回代码中的有意义的数据结构，这需要大量的组织工作。描述这个过程本身就是一件头疼的事情。
- en: In locally hosted code, you have the benefit of sharing DLLs of your libraries
    among consumer applications to facilitate a shared contract for data structures.
    You could communicate with other software on your system through the filesystem
    itself. You could just use the systems, file-access APIs to expose all the nuts
    and bolts of how much data exists in your message, what the encoding of that data
    is, and expose it through random access into the file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地托管代码中，你可以通过在消费者应用程序之间共享库的 DLL 来方便地共享数据结构的合同。你可以通过文件系统本身与系统上的其他软件进行通信。你可以仅使用系统文件访问
    API 来公开你的消息中存在多少数据，数据的编码方式是什么，并通过随机访问文件来公开这些信息。
- en: With a network, you have to give enough context for someone else to make sense
    of your message with the message itself. And you have to communicate that context
    in a way that a consumer could understand it before they have that context. Once
    again, the .NET libraries will come to your rescue here, providing easy-to-use
    classes exposing standardized headers and message formats to keep your code clear
    of that overhead.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中，您必须提供足够的上下文，以便其他人能够通过消息本身理解您的信息。您必须以消费者在获得上下文之前能够理解的方式传达这种上下文。再次强调，.NET
    库将在这里为您提供帮助，提供易于使用的类，这些类公开标准化的头和消息格式，以保持您的代码清晰，避免这种开销。
- en: Resilience
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: I mentioned this concept a few times talking about network topologies, but it
    bears special mention here, because you'll be responsible for maintaining resiliency
    of your application on a network from both ends of a connection. If your application
    leverages any resources on a network, you'll have to account for the very likely
    possibility that there will be times at which those resources aren't actually availableon
    that network. You'll need to write your code so that it still responds to its
    users in a reliable and stable manner in the event of such an outage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我在讨论网络拓扑时提到过这个概念几次，但在这里特别提一下，因为您将负责从连接的两端维护您应用程序的弹性。如果您的应用程序在网络中利用任何资源，您必须考虑到这些资源在网络上可能实际上不可用的可能性。在这种情况下，您需要编写代码，以确保即使在出现此类故障的情况下，代码仍然能够以可靠和稳定的方式响应用户。
- en: Likewise, if your software is a dependency for other systems on your network,
    and it goes down, the best thing for you to do is have a strategy in place for
    rebounding from such an outage. There are a number of viable solutions in place
    for notifying your downstream consumers that you've recovered from an outage,
    each with their own strengths and costs in terms of resource usage or development
    time, and we'll discuss several of them later in this book. For now though, it
    is sufficient to consider this as you design your solutions and adjust those designs
    accordingly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您的软件是您网络中其他系统的依赖项，并且它崩溃了，您最好的做法是制定一个策略来从这种故障中恢复。目前有几种可行的解决方案来通知您的下游消费者您已经从故障中恢复过来，每种方案都有其自身的优势和成本，包括资源使用或开发时间，我们将在本书的后面讨论其中几个。然而，现在，在设计解决方案时考虑这一点并相应调整设计就足够了。
- en: Asynchrony
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: Tying in somewhat closely with the notion of resiliency and open communication
    is the concept of asynchronous communication. This is a hugely important concept
    for maintaining any semblance of reliable performance on a networked program.
    Put simply, it's the concept of processing the result of a request that is notprovided
    by the code internal to your system whenthat result becomes available.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与弹性和开放通信的概念紧密相关的是异步通信的概念。这对于在网络程序中保持任何可靠性能至关重要。简单来说，这是处理当结果变得可用时，系统内部代码未提供的结果的概念。
- en: When your program needs to request some resources from another node on its network,
    there is a round-trip time associated with sending your initial request and then
    receiving some meaningful response. During that time, you program technically couldlock
    and wait for the response to come back, but realistically, there is no reason
    why it shouldlock and wait. However, even after our program may have moved on,
    deciding not to wait on the response to our initial request, we typically want
    to take a step back and handle the response whenever it doescome back over the
    network. This process is asynchronous programming, and it's a major key to developing
    reasonably performing network software.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的程序需要从其网络上的另一个节点请求一些资源时，发送初始请求并接收一些有意义响应之间存在往返时间。在这段时间内，您的程序在技术上可以锁定并等待响应返回，但现实中没有理由让它锁定并等待。然而，即使我们的程序可能已经继续前进，决定不对初始请求的响应等待，我们通常希望退一步处理当响应通过网络返回时的响应。这个过程是异步编程，它是开发合理性能网络软件的关键。
- en: One obvious case of asynchronous programming you may have encountered separately
    from the context of network programming is in programming responsive user interfaces
    (UI). Typically, a UI component needs to actively listen and respond to user inputs
    whenever that user chooses to engage with it. Since the programmer can't ever
    know precisely whena user might want to press a button they've been presented
    with, they must respond to the input at the earliest moment that resources that
    can respond to the input withoutkeeping those resources on hold while they wait
    to respond.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能遇到的一个异步编程的明显例子是在网络编程之外，即在编程响应式用户界面（UI）时。通常，UI组件需要积极监听并响应用户输入，无论用户何时选择与之交互。由于程序员永远无法确切知道用户何时会按下他们提供的按钮，他们必须在最早的时刻响应用户输入，而不必在等待响应时保持资源处于等待状态。
- en: Network objects and data structures in .NET Core
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的网络对象和数据结构
- en: It may sound like a daunting task to start writing network code from scratch,
    and in some cases, it absolutely is. There is help, however, in the form of the
    .NET Core class libraries. With these libraries, you'll be well positioned to
    start working with clean abstractions for complicated, and often frustrating,
    network protocols and standards to start producing valuable components on a distributed
    network.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始编写网络代码可能听起来是一项艰巨的任务，在某些情况下，这确实如此。然而，.NET Core类库提供了帮助。有了这些库，您将能够开始使用干净的抽象来处理复杂且经常令人沮丧的网络协议和标准，从而在分布式网络上开始生产有价值的组件。
- en: Using System.Net
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用System.Net
- en: The `using` statement might be one of the most important statements you can
    include in source files containing any sort of networking code. The `System.Net`
    namespace is a suite of general-purpose .NET Core classes and utilities for programming
    most protocols and networked system behaviors. It is the root namespace for the
    most common networking classes you'll use as we move through this book.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`语句可能是您可以在包含任何类型网络代码的源文件中包含的最重要语句之一。System.Net命名空间是一套通用的.NET Core类和实用工具，用于编程大多数协议和网络化系统行为。它是您在阅读本书时将使用的最常见网络类的根命名空间。'
- en: 'The namespace includes classes for the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该命名空间包括以下类：
- en: Domain name resolution and DNS access
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名解析和DNS访问
- en: The abstract base `WebRequest` and `WebResponse` classes, as well as common
    implementations of those classes, including `FtpWebRequest`, and `HttpWebRequest`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类`WebRequest`和`WebResponse`，以及这些类的常见实现，包括`FtpWebRequest`和`HttpWebRequest`
- en: '**Internet Protocol** (**IP**) resolution and definition'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网协议**（**IP**）解析和定义'
- en: Socket utility class definitions
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Socket实用类定义
- en: Many others
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他类
- en: The classes in this namespace will be your bread and butter as you begin to
    develop more complex and powerful software, and you should spend a fair amount
    of time familiarizing yourself with the features and functionality the System.Net
    namespace encapsulates.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始开发更复杂和强大的软件时，这个命名空间中的类将成为您的日常必需品，您应该花相当多的时间熟悉System.Net命名空间封装的功能和功能。
- en: Getting specific with sub-namespaces
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专注于子命名空间
- en: While the System.Net namespace encapsulates a wealth of useful classes for network
    programming, there are a number of useful sub-namespaces under the System.Net
    package hierarchy that you should also be familiar with, as follows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然System.Net命名空间封装了大量的网络编程有用类，但在System.Net包层次结构下还有许多有用的子命名空间，您也应该熟悉，如下所示。
- en: '`System.Net.Http`: A utility class used to provide HTTP standards-compliant
    messages and interactions within your .NET Core app'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.Http`：一个实用类，用于在您的.NET Core应用程序中提供符合HTTP标准的消息和交互'
- en: '`System.Net.NetworkInformation`: Provides traffic data, address information,
    and other details about the host node on the network'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.NetworkInformation`：提供有关网络中主机节点的流量数据、地址信息和其他详细信息'
- en: '`System.Net.Security`: Provides reliably secure networked communication and
    resource sharing and accessing'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.Security`：提供可靠的安全网络通信和资源共享及访问'
- en: '`System.Net.Sockets`:  Exposes netcore managed access to the WinSock interface'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Net.Sockets`：提供对WinSock接口的netcore托管访问'
- en: Each of these namespaces and the classes they expose will be explored in much
    greater detail over the course of this book, but for now, I wanted to expose you
    to some of the most commonly used, and most broadly valuable, network classes
    provided out of the box by .NET Core.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将更深入地探讨这些命名空间以及它们公开的类。但到目前为止，我想让你了解.NET Core开箱即用的最常用、最有价值的网络类。
- en: 'Their software is open source and described by robust and reliable documentation
    here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的软件是开源的，并且在这里有详尽的文档描述：
- en: '[https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1](https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1](https://docs.microsoft.com/en-us/dotnet/api/?view=netcore-2.1)'
- en: It would certainly be worth the time of anyone considering a career in network
    web development to examine the classes in their fullest.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于考虑从事网络Web开发职业的人来说，花时间检查这些类无疑是值得的。
- en: A whole new computing world
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个全新的计算世界
- en: The maximum value a piece of software can deliver is limited by the number of
    downstream consumers of that software who have the ability to leverage it. Deploying
    your software on a widely available network can increase the overall impact it
    has on your organization or community of consumers. This last section takes a
    look at the kinds of applications opened up by this transition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一件软件能提供的最大价值受限于能够利用该软件的下游消费者数量。将你的软件部署在广泛可用的网络上可以增加它对你的组织或消费者社区的整体影响。本节的最后部分将探讨这一转变所开启的应用类型。
- en: Long – distance communication
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长距离通信
- en: Thanks to communication protocols such as **File Transfer Protocol** (**FTP**)
    and **Simple Mail Transfer Protocol **(**SMTP**), it is possible to write to,
    or receive a letter from, someone on the entire other side of the globe within
    a few seconds of them having sent it. This feat of engineering is made possible
    by a robust, resilient physical infrastructure supporting the internet as a whole,
    and by the end of this book, the target is for you to have the skills necessary
    to develop these kinds of applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢**文件传输协议**（**FTP**）和**简单邮件传输协议**（**SMTP**）等通信协议，在发送者发送后几秒钟内，就可以在地球的另一端写入或接收一封信。这一工程技术成就得益于支持整个互联网的强大、弹性的物理基础设施，到本书结束时，目标是让你具备开发这类应用所需的技能。
- en: With peer-to-peer communication protocols, we can build systems of networked
    multiplayers for real-time, high-intensity, high-action games.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对等通信协议，我们可以构建网络化多人游戏系统，用于实时、高强度、高动作的游戏。
- en: Share functionality, not code
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享功能，而不是代码
- en: With well-defined standards such as the RESTful API design and the messaging
    format of HTTP, you can write stable, clean, well-isolated web API projects that
    allow a variety of consumers to request functionality you've written on demand.
    Instead of sharing code directly, you can keep your abstractions abstract and
    allow only conceptual access to the business process you own through well-documented
    channels of communication.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如RESTful API设计以及HTTP消息格式等明确的标准，你可以编写稳定、干净、良好隔离的Web API项目，这些项目允许各种消费者按需请求你编写的功能。你不必直接共享代码，而可以通过良好的文档化通信渠道，仅允许对所拥有的业务流程进行概念性访问，从而保持你的抽象抽象化。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took a verydeep dive on a small handful of subjects. We delivered
    a carefully considered definition of a network, and then considered how the key
    components of that definition impact our development strategies for network programs.
    We considered the distinction between a physical and logical network topology,
    and then explored the most common logical topologies we'll be working with. Lastly,
    we considered what kinds of new design decisions and strategies we'll have to
    make as we start to write our first network programs, as well as the .NET classes
    that will help us implement those strategies easily and cleanly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了少数几个主题。我们给出了一个仔细考虑的网络定义，然后考虑了该定义的关键组成部分如何影响我们的网络程序开发策略。我们考虑了物理网络拓扑和逻辑网络拓扑之间的区别，然后探讨了我们将要工作的最常见逻辑拓扑。最后，我们考虑了在开始编写第一个网络程序时，我们将不得不做出的新设计决策和策略，以及.NET类将如何帮助我们轻松且干净地实现这些策略。
- en: In the next chapter, we'll take the first steps into programming for networks,
    as we look into resource location and addressing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将迈出网络编程的第一步，我们将探讨资源定位和寻址。
- en: Questions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the definition of a network?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络的定义是什么？
- en: What is the difference between a physical and logical topology?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理拓扑和逻辑拓扑之间的区别是什么？
- en: Which was the only network topology discussed in this chapter that is not exposed
    to a potential single point of failure?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中唯一讨论的、没有暴露给潜在的单点故障的网络拓扑是哪一个？
- en: What are some of the physical devices that implement channels of communication
    on a network? What physical devices serve as nodes?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络上实现通信通道的一些物理设备有哪些？哪些物理设备作为节点？
- en: What is the root namespace for the most common networking libraries and classes
    provided by .NET Core?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core 提供的最常见的网络库和类的根命名空间是什么？
- en: Name at least four classes exposed by the System.Net namespace.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列出 System.Net 命名空间暴露的四个类。
- en: What are the four other most commonly used namespaces provided by .NET Core
    for reliable and stable network programming?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core 为可靠和稳定的网络编程提供了哪些其他四个最常用的命名空间？
- en: Further reading
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For additional general information on networks, check out *Building Modern Networks*
    by *Steven Noble*, which is available through Packt Publishing. It's a great resource
    for understanding the challenges facing modern network engineers, and a good,
    deep dive into the applications of the concepts discussed in this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获取有关网络的更多信息，请查看由 Steven Noble 编写的 *Building Modern Networks*，通过 Packt Publishing
    提供。这是一本了解现代网络工程师面临的挑战的绝佳资源，也是对本章讨论的概念应用的深入探讨。
