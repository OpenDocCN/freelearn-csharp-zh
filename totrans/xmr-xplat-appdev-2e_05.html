<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. XamChat for iOS</h1></div></div></div><p class="calibre8">In this chapter, we will develop the iOS portion of our cross-platform XamChat application. Since we are using the MVVM design pattern, most of the work we will be doing will be in the View layer of the application. We will mainly be working with native iOS APIs and understanding how we can apply them leverage the shared code in our portable class library. Since Xamarin.iOS enables us to call Apple APIs directly, our iOS app will be indistinguishable from an application developed in Objective-C or Swift.</p><p class="calibre8">To begin writing the iOS version of XamChat, create a new <strong class="calibre2">Single View Application</strong> under the <strong class="calibre2">iOS</strong> section. Name the project <code class="literal">XamChat.iOS</code> or some other appropriate name of your choice. The project template will automatically create a controller with an unfamiliar name; go ahead and delete it. We will create our own controllers as we go.</p><p class="calibre8">In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem">The basics of an iOS application</li><li class="listitem">The use of <code class="literal">UINavigationController</code></li><li class="listitem">Implementing a login screen</li><li class="listitem">Segues and <code class="literal">UITableView</code></li><li class="listitem">Adding a friends list</li><li class="listitem">Adding a list of messages</li><li class="listitem">Composing messages</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec36" class="calibre1"/>Understanding the basics of an iOS app</h1></div></div></div><p class="calibre8">Before we start<a id="id282" class="calibre1"/> developing our app, let's review the main settings of the application. Apple uses a file named <code class="literal">Info.plist</code> to store important information about any iOS app. These settings are used when an iOS application is installed on a device by the Apple App Store. We will begin development on any new iOS application by filling out the information in this file.</p><p class="calibre8">Xamarin Studio provides a neat menu to modify values in the <code class="literal">Info.plist</code> file, as shown in the following screenshot:</p><div><img src="img/00033.jpeg" alt="Understanding the basics of an iOS app" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">The most important settings are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Application Name</strong>: This is the title below an app's icon in iOS. Note that this is not the same as the official name of your app in the iOS App Store.</li><li class="listitem"><strong class="calibre2">Bundle Identifier</strong>: This is<a id="id283" class="calibre1"/> your app's bundle identifier or bundle ID. It is a unique name to identify your application. The convention is to use a reverse domain naming style beginning with your company name, such as <code class="literal">com.packt.xamchat</code>.</li><li class="listitem"><strong class="calibre2">Version</strong>: This is a version number for your application such as <code class="literal">1.0.0</code>.</li><li class="listitem"><strong class="calibre2">Devices</strong>: In this field you can select <strong class="calibre2">iPhone/iPod</strong>, <strong class="calibre2">iPad</strong>, or <strong class="calibre2">Universal</strong> (all devices) for your application.</li><li class="listitem"><strong class="calibre2">Deployment Target</strong>: This is the minimum iOS version your application runs on.</li><li class="listitem"><strong class="calibre2">Main Interface</strong>: This is the main storyboard file for your app that declares most of the UI of your application. iOS will automatically load this file and open the root controller as the initial screen to be displayed.</li><li class="listitem"><strong class="calibre2">Supported Device Orientations</strong>: These are the different positions your application will be able to rotate to and support.</li></ul></div><p class="calibre8">There are other settings<a id="id284" class="calibre1"/> for app icons, splash screens, and so on. You can also toggle between the <strong class="calibre2">Advanced</strong> or <strong class="calibre2">Source</strong> tabs to configure additional settings that Xamarin does not provide a user-friendly menu for.</p><p class="calibre8">Configure the following settings for our application:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Application Name</strong>: <code class="literal">XamChat</code></li><li class="listitem"><strong class="calibre2">Bundle Identifier</strong>: <code class="literal">com.yourcompanyname.xamchat</code>; make sure that you name future apps beginning with <code class="literal">com.yourcompanyname</code></li><li class="listitem"><strong class="calibre2">Version</strong>: This can be any version number you prefer, but it should just not be left blank</li><li class="listitem"><strong class="calibre2">Devices</strong>: <strong class="calibre2">iPhone/iPod</strong></li><li class="listitem"><strong class="calibre2">Deployment Target</strong>: 7.0 (you can also target 8.0, but we aren't using any iOS 8-specific APIs in this app)</li><li class="listitem"><strong class="calibre2">Supported Device Orientations</strong>: Only select <strong class="calibre2">Portrait</strong></li></ul></div><p class="calibre8">You can find some additional settings for Xamarin iOS applications if you right-click on your project and select <strong class="calibre2">Options</strong>. It is a good idea to know what is available for iOS-specific projects in Xamarin Studio.</p><p class="calibre8">Let's discuss some of the most important options.</p><div><ol class="orderedlist"><li class="listitem" value="1">Navigate to the <strong class="calibre2">iOS Build</strong> | <strong class="calibre2">General</strong> tab as shown in the following screenshot:<div><img src="img/00034.jpeg" alt="Understanding the basics of an iOS app" class="calibre9"/></div><p class="calibre14"> </p><p class="calibre15">You have the<a id="id285" class="calibre1"/> following options under this tab:</p><div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">SDK version</strong>: This is the version of the iOS SDK to compile your application with. It is generally best to use <strong class="calibre2">Default</strong>.</li><li class="listitem"><strong class="calibre2">Linker behavior</strong>: Xamarin has implemented a feature called <strong class="calibre2">linking</strong>. The linker will strip any code that will never be called within your assemblies. This keeps your application small and allows them to ship a stripped-down version of the core Mono framework with your app. Except for debug builds, it is best to use the <strong class="calibre2">Link SDK assemblies only</strong> option. We will cover linking in the next chapter.</li><li class="listitem"><strong class="calibre2">Optimize PNG files for iOS</strong>: Apple uses a custom PNG format to speed up the loading of PNGs within your app. You can turn this off to speed up builds, or if you plan on optimizing the images yourself.</li><li class="listitem"><strong class="calibre2">Enable debugging</strong>: Turning this on allows Xamarin to include extra information with your<a id="id286" class="calibre1"/> app to enable debugging from Xamarin Studio.</li><li class="listitem"><strong class="calibre2">Additional mtouch arguments</strong>: This field is for passing extra command-line arguments to the Xamarin compiler for iOS. You can check out the complete list of these arguments at <a class="calibre1" href="http://iosapi.xamarin.com">http://iosapi.xamarin.com</a>.</li></ul></div></li><li class="listitem" value="2">Navigate to <strong class="calibre2">iOS Build</strong> | <strong class="calibre2">Advanced</strong> tab as shown in the following screenshot:<div><img src="img/00035.jpeg" alt="Understanding the basics of an iOS app" class="calibre9"/></div><p class="calibre14"> </p><p class="calibre15">You have the following options under this tab:</p><div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Supported architectures</strong>: Here, the options are <strong class="calibre2">ARMv7</strong>, <strong class="calibre2">ARMv7s</strong>, and a <strong class="calibre2">FAT</strong> version that includes both. These are instruction sets that different iOS device processors support. If you really care about <a id="id287" class="calibre1"/>performance, you might consider selecting the option to support both; however, this will make your application larger.</li><li class="listitem"><strong class="calibre2">Use LLVM optimizing compiler</strong>: Checking this compiles the code that is smaller and runs faster, but it takes longer to compile. <strong class="calibre2">LLVM</strong> stands for <strong class="calibre2">Low Level Virtual Machine</strong>.</li><li class="listitem"><strong class="calibre2">Enable generic value type sharing</strong>: This is an option specific to Mono that draws better performance from C# generics with value types. It has the downside of making the application slightly larger, but I would recommend that you leave it on.</li><li class="listitem"><strong class="calibre2">Use SGen generational garbage collector</strong>: This uses the new Mono garbage collector in your app. I would recommend that you turn this on if you really need good performance with the <strong class="calibre2">garbage collector</strong> (<strong class="calibre2">GC</strong>) or are working on an app that needs to be responsive in real time, such as a game. It is probably safe to turn this on by default now, as the SGen garbage collector is very stable.</li><li class="listitem"><strong class="calibre2">Use the reference counting extension (preview)</strong>: This is currently an experimental feature, but improves the general memory usage of native objects that are accessible from C#. These native object's reference is managed by the GC instead of a backing field on the object when using this setting. Since it is still in preview, you should be careful when using this option.</li></ul></div></li><li class="listitem" value="3">You have the following options under <strong class="calibre2">iOS Bundle Signing</strong>:<div><ul class="itemizedlist1"><li class="listitem"><strong class="calibre2">Identity</strong>: This is the certificate to identify the app's creator for deploying the application to devices. We'll cover more on this in later chapters.</li><li class="listitem"><strong class="calibre2">Provisioning profile</strong>: This is a specific profile that deploys the app to a device. This works in tandem with Identity, but also declares the distribution method, and the devices that can install the app.</li><li class="listitem"><strong class="calibre2">Custom Entitlements</strong>: This file contains additional settings to be applied to the provisioning profile, and it contains other specific declarations for the app such as iCloud or push notifications. The project template for iOS apps includes a default <code class="literal">Entitlements.plist</code> file for new projects.</li></ul></div></li><li class="listitem" value="4"><strong class="calibre2">iOS Application</strong>: These settings are identical to what you see in the <code class="literal">Info.plist</code> file.</li></ol><div></div><p class="calibre8">For this application, you <a id="id288" class="calibre1"/>can leave all these options at their defaults. When making a real iOS application on your own, you should consider changing many of these as per your application's needs.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Using UINavigationController</h1></div></div></div><p class="calibre8">In iOS applications, the key<a id="id289" class="calibre1"/> class that manages navigation between different controllers is the <code class="literal">UINavigationController</code> class. The navigation controller is the most basic building block of navigation on iOS, so it is the best choice to start with most of the iOS applications. It is a parent controller that contains several child controllers in a stack. Users can move forward by putting new controllers on top of the stack or using a built-in back button to pop a controller off the stack and navigate to the previous screen.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec17" class="calibre1"/>Methods in Navigation Controllers</h2></div></div></div><p class="calibre8">The <a id="id290" class="calibre1"/>following are the methods in Navigation<a id="id291" class="calibre1"/> Controllers:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">SetViewControllers</code>: This sets an array of child controllers. It has a value to optionally<a id="id292" class="calibre1"/> animate the transition.</li><li class="listitem"><code class="literal">ViewControllers</code>: This is a property to get or set the array of child controllers without an<a id="id293" class="calibre1"/> option for animations.</li><li class="listitem"><code class="literal">PushViewController</code>: This places a new child controller at the top of the stack with an option to<a id="id294" class="calibre1"/> display an animation.</li><li class="listitem"><code class="literal">PopViewControllerAnimated</code>: This<a id="id295" class="calibre1"/> pops off the child controller at the top of the stack with an option to animate the transition.</li><li class="listitem"><code class="literal">PopToViewController</code>: This pops to the specified child controller, removing all<a id="id296" class="calibre1"/> controllers above it. It provides an option to animate the transition.</li><li class="listitem"><code class="literal">PopToRootViewController</code>: This<a id="id297" class="calibre1"/> removes all the child controllers except the bottom-most controller. It includes an option to display an animation.</li><li class="listitem"><code class="literal">TopViewController</code>: This is<a id="id298" class="calibre1"/> a property that returns the child controller that is currently on top of the stack.</li></ul></div><div><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">It is important to note that using the option for animations will cause a crash if you try to modify the stack during the animation. To fix this situation, either use the <code class="literal">SetViewControllers</code> method and set the entire list of child controllers, or refrain from using the animations during a combination of transitions.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec18" class="calibre1"/>Setting up a Navigation Controller</h2></div></div></div><p class="calibre8">Perform the following steps to set <a id="id299" class="calibre1"/>up a Navigation Controller:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in Xamarin Studio.</li><li class="listitem" value="2">Remove the controller that was created by the project template.</li><li class="listitem" value="3">Drag a <strong class="calibre2">Navigation Controller</strong> element from the <strong class="calibre2">Toolbox</strong> pane on the right-hand side onto the storyboard.</li><li class="listitem" value="4">Notice that a default <strong class="calibre2">View Controller</strong> element was created as well as a <strong class="calibre2">Navigation Controller</strong> element.</li><li class="listitem" value="5">You will see a <strong class="calibre2">segue</strong> that connects the two controllers. We'll cover this concept in more detail later in the chapter.</li><li class="listitem" value="6">Save the storyboard file.</li></ol><div></div><p class="calibre8">If you run the application at this point, you will have a basic iOS app with a status bar at the top, a navigation controller that contains a navigation bar with a default title, and a child controller that is completely white, as shown in the following screenshot:</p><div><img src="img/00036.jpeg" alt="Setting up a Navigation Controller" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Implementing the login screen</h1></div></div></div><p class="calibre8">Since the first <a id="id300" class="calibre1"/>screen of our application will be a login screen, let's begin by setting up the appropriate views in the storyboard file. We will implement the login screen using Xamarin Studio to write the C# code, and its iOS designer to create iOS layouts in our storyboard file.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec19" class="calibre1"/>Creating a LoginController class</h2></div></div></div><p class="calibre8">Return to the project in<a id="id301" class="calibre1"/> Xamarin Studio and<a id="id302" class="calibre1"/> perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in the iOS designer.</li><li class="listitem" value="2">Select your view controller and click on the <strong class="calibre2">Properties</strong> pane and select the <strong class="calibre2">Widget</strong> tab.</li><li class="listitem" value="3">Enter <code class="literal">LoginController</code> into the <strong class="calibre2">Class</strong> field.</li><li class="listitem" value="4">Notice that the <code class="literal">LoginController</code> class is generated for you. You can create a <code class="literal">Controllers</code> folder and move the file in it if you wish.</li></ol><div></div><p class="calibre8">The following<a id="id303" class="calibre1"/> screenshot shows you what the<a id="id304" class="calibre1"/> controller's settings will look like in Xamarin Studio after the changes have been made:</p><div><img src="img/00037.jpeg" alt="Creating a LoginController class" class="calibre9"/></div><p class="calibre10"> </p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec20" class="calibre1"/>Modifying the controller's layout</h2></div></div></div><p class="calibre8">Now let's modify the layout<a id="id305" class="calibre1"/> of the controller by<a id="id306" class="calibre1"/> performing the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file a second time to return to the iOS designer.</li><li class="listitem" value="2">Tap on the navigation bar and edit the <strong class="calibre2">Title</strong> field to read <code class="literal">Login</code>.</li><li class="listitem" value="3">Drag two text fields onto the controller. Position and size them appropriately for the username and password entries. You might also want to remove the default text to make the fields blank.</li><li class="listitem" value="4">For the second field, check the <strong class="calibre2">Secure Text Entry</strong> checkbox. This will set the control to hide the characters for the password field.</li><li class="listitem" value="5">You might also want to fill out the <strong class="calibre2">Placeholder</strong> field for <code class="literal">Username</code> and <code class="literal">Password</code> respectively.</li><li class="listitem" value="6">Drag a button onto the controller. Set the button's <strong class="calibre2">Title</strong> to <code class="literal">Login</code>.</li><li class="listitem" value="7">Drag an activity indicator onto the controller. Check the <strong class="calibre2">Animating</strong> and <strong class="calibre2">Hidden</strong> checkboxes.</li><li class="listitem" value="8">Next, create an outlet for each of the controls by filling out the <strong class="calibre2">Name</strong> field. Name the <a id="id307" class="calibre1"/>outlets <code class="literal">username</code>, <code class="literal">password</code>, <code class="literal">login</code>, and <code class="literal">indicator</code> respectively.</li><li class="listitem" value="9">Save the <a id="id308" class="calibre1"/>storyboard file and take a look at <code class="literal">LoginController.designer.cs</code>.</li></ol><div></div><p class="calibre8">You will see that Xamarin Studio has generated properties for each of the outlets:</p><div><img src="img/00038.jpeg" alt="Modifying the controller's layout" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Go ahead and compile the application to make sure that everything is okay. At this point, we also need to add a reference to the <code class="literal">XamChat.Core</code> project created in the previous chapter.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec21" class="calibre1"/>Registering and subscribing view models and services</h2></div></div></div><p class="calibre8">Next, let's set up<a id="id309" class="calibre1"/> our iOS application to register all of its view models and other services that will be used<a id="id310" class="calibre1"/> throughout the application. We will <a id="id311" class="calibre1"/>use the <code class="literal">ServiceContainer</code> class that we created in <a class="calibre1" title="Chapter 4. XamChat – a Cross-platform App" href="part0036_split_000.html#page">Chapter 4</a>, <em class="calibre12">XamChat – a Cross-platform App</em>, to set up the dependencies throughout our application. Open<a id="id312" class="calibre1"/> <code class="literal">AppDelegate.cs</code> and add the following method:</p><div><pre class="programlisting">public override bool FinishedLaunching(UIApplication application,NSDictionary launchOptions)
{
  //View Models
  ServiceContainer.Register&lt;LoginViewModel&gt;(() =&gt;new LoginViewModel());
  ServiceContainer.Register&lt;FriendViewModel&gt;(() =&gt;new FriendViewModel());
  ServiceContainer.Register&lt;RegisterViewModel&gt;(() =&gt;new RegisterViewModel());
  ServiceContainer.Register&lt;MessageViewModel&gt;(() =&gt;new MessageViewModel());
  //Models
  ServiceContainer.Register&lt;ISettings&gt;(() =&gt;new FakeSettings());
  ServiceContainer.Register&lt;IWebService&gt;(() =&gt;new FakeWebService());
  
  return true;
}</pre></div><p class="calibre8">Down the road, we will replace the fake services with the real ones. Now, let's add the login functionality to <code class="literal">LoginController.cs</code>. First, add <code class="literal">LoginViewModel</code> to a member variable at the top of the class as follows:</p><div><pre class="programlisting">readonly LoginViewModel loginViewModel = ServiceContainer.Resolve&lt;LoginViewModel&gt;();</pre></div><p class="calibre8">This will pull a shared instance of <code class="literal">LoginViewModel</code> into a local variable in the controller. This is the pattern that we will use throughout the book in order to pass a shared view model from one class to another.</p><p class="calibre8">Next, override <code class="literal">ViewDidLoad</code> to<a id="id313" class="calibre1"/> hook up the view model's functionality with the views set up in outlets as<a id="id314" class="calibre1"/> follows:</p><div><pre class="programlisting">public override void ViewDidLoad()
{
  base.ViewDidLoad();
  login.TouchUpInside += async(sender, e) =&gt;
  {
    loginViewModel.Username = username.Text;
    loginViewModel.Password = password.Text;
    try
    {
      await loginViewModel.Login();
      //TODO: navigate to a new screen
    }
    catch (Exception exc)
    {
      new UIAlertView("Oops!", exc.Message, null, "Ok").Show();
    }
  };
}</pre></div><p class="calibre8">We'll add the code to<a id="id315" class="calibre1"/> navigate to a new screen later<a id="id316" class="calibre1"/> in the chapter.</p><p class="calibre8">Next, let's hook up the <code class="literal">IsBusyChanged</code> event to actually perform an action as follows:</p><div><pre class="programlisting">public override void ViewWillAppear(bool animated)
{
  base.ViewWillAppear(animated);
  loginViewModel.IsBusyChanged += OnIsBusyChanged;
}
public override void ViewWillDisappear(bool animated)
{
  base.ViewWillDisappear(animated);
  loginViewModel.IsBusyChanged -= OnIsBusyChanged;
}
void OnIsBusyChanged(object sender, EventArgs e)
{
  username.Enabled =
    password.Enabled =
    login.Enabled = 
    indicator.Hidden = !loginViewModel.IsBusy;
}</pre></div><p class="calibre8">Now you might be wondering, why we subscribe to the event in this manner. The problem is that the <code class="literal">LoginViewModel</code> class will last through your application's lifetime, while the <code class="literal">LoginController</code><a id="id317" class="calibre1"/> class will not. If we subscribed to the event in <code class="literal">ViewDidLoad</code>, but didn't unsubscribe later, then our application will have a <a id="id318" class="calibre1"/>memory leak. We also avoided using a lambda expression for the event since it would otherwise be impossible to unsubscribe the event. Note that we don't have the same problem with the <code class="literal">TouchUpInside</code> event on the button, since it will live in memory as long as the controller<a id="id319" class="calibre1"/> does. This is a common problem with <a id="id320" class="calibre1"/>events in C#, which is why it is a good idea to use the preceding pattern on iOS.</p><p class="calibre8">If you run the application now, you should be able to enter a username and password, as shown in the following screenshot. When you press <strong class="calibre2">Login</strong>, you should see the indicator appear and all the controls disabled. Your application will correctly be calling the shared code, and should function correctly when we add a real web service.</p><div><img src="img/00039.jpeg" alt="Registering and subscribing view models and services" class="calibre9"/></div><p class="calibre10"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>Using segues and UITableView</h1></div></div></div><p class="calibre8">A segue is a <a id="id321" class="calibre1"/>transition from one controller to another. In the same way, a storyboard file is a collection<a id="id322" class="calibre1"/> of controllers and their views attached together by segues. This, in turn, allows you to see the layouts of each controller and the general flow of your application at the same time.</p><p class="calibre8">There are just a few categories of segue, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Push</strong>: This is used <a id="id323" class="calibre1"/>within a navigation controller. It pushes a new controller to the top of the navigation controller's stack. Push uses the standard animation technique for navigation controllers and is generally the most commonly used segue.</li><li class="listitem"><strong class="calibre2">Relationship</strong>: This is used to set a child controller of another controller. For example, the root <a id="id324" class="calibre1"/>controller of a navigation controller, container views, or split view controllers in an iPad application.</li><li class="listitem"><strong class="calibre2">Modal</strong>: On using this, a controller presented modally will appear on top of the parent controller. It will<a id="id325" class="calibre1"/> cover the entire screen until dismissed. There are several types of different transition animations available.</li><li class="listitem"><strong class="calibre2">Custom</strong>: This is a custom segue that includes an option for a custom class, which subclasses <code class="literal">UIStoryboardSegue</code>. This gives you fine-grained control over the animation<a id="id326" class="calibre1"/> and how the next controller is presented.</li></ul></div><p class="calibre8">Segues also use the following pattern while executing:</p><div><ul class="itemizedlist"><li class="listitem">The destination<a id="id327" class="calibre1"/> controller and its views are created.</li><li class="listitem">The segue object, a subclass of <code class="literal">UIStoryboardSegue</code>, is created. This is normally only important for custom segues.</li><li class="listitem">The <code class="literal">PrepareForSegue</code> method is called on the source controller. This is a good place to run any custom code before a segue begins.</li><li class="listitem">The segue's <code class="literal">Perform</code> method is called and the transition animation is started. This is where the bulk of the code resides for a custom segue.</li></ul></div><p class="calibre8">In the Xamarin.iOS designer, you have the choice of either firing a segue automatically from a button or table view<a id="id328" class="calibre1"/> row, or just giving the segue an identifier. In the second case, you can start the segue yourself by calling the <code class="literal">PerformSegue</code> method on the source controller using its identifier.</p><p class="calibre8">Now, let's set up a new segue by<a id="id329" class="calibre1"/> setting up some aspects of our <code class="literal">MainStoryboard.storyboard</code> file by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in the iOS designer.</li><li class="listitem" value="2">Add a new <strong class="calibre2">Table View Controller</strong> to the storyboard.</li><li class="listitem" value="3">Select your view controller and navigate to the <strong class="calibre2">Properties</strong> pane and the <strong class="calibre2">Widget</strong> tab.</li><li class="listitem" value="4">Enter <code class="literal">ConversationsController</code> into the <strong class="calibre2">Class</strong> field.</li><li class="listitem" value="5">Scroll down under the <strong class="calibre2">View Controller</strong> section and enter <strong class="calibre2">Title</strong> of <code class="literal">Conversations</code>.</li><li class="listitem" value="6">Create a segue from <code class="literal">LoginController</code> to <code class="literal">ConversationsController</code> by clicking while holding <em class="calibre12">Ctrl</em> and dragging the blue line from one controller to the other.</li><li class="listitem" value="7">Select the <strong class="calibre2">push</strong> segue from the popup that appears.</li><li class="listitem" value="8">Select the segue by clicking on it and <a id="id330" class="calibre1"/>give it an <strong class="calibre2">Identifier</strong> of <code class="literal">OnLogin</code>.</li><li class="listitem" value="9">Save the storyboard file.</li></ol><div></div><p class="calibre8">Your storyboard <a id="id331" class="calibre1"/>will look something similar to what is shown in the following screenshot:</p><div><img src="img/00040.jpeg" alt="Using segues and UITableView" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">Open <code class="literal">LoginController.cs</code>, and modify the line of code that we marked as <code class="literal">TODO</code> earlier in this chapter as follows:</p><div><pre class="programlisting">PerformSegue("OnLogin", this);</pre></div><p class="calibre8">Now if you build and run the application, you will navigate to the new controller after a successful log in. The segue will be performed, and you will see the built-in animation provided by the navigation controller.</p><p class="calibre8">Next, let's set up the table view <a id="id332" class="calibre1"/>on the second controller. We are using a powerful class on iOS called <code class="literal">UITableView</code>. It is used in many situations and is very similar to the concept of a list view on other platforms. The <code class="literal">UITableView</code> class is controlled by another class called <code class="literal">UITableViewSource</code>. It has methods that you need to override to set up how many<a id="id333" class="calibre1"/> rows should exist and how these rows should be displayed on the screen.</p><div><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">Note that <code class="literal">UITableViewSource</code> is a combination of <code class="literal">UITableViewDelegate</code> and <code class="literal">UITableViewDataSource</code>. I prefer to use <code class="literal">UITableViewSource</code> for simplicity, since many times using both of the other two classes would be required.</p></div><p class="calibre8">Before we jump in and start coding, let's review the most commonly used methods on <code class="literal">UITableViewSource</code>, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">RowsInSection</code>: This method<a id="id334" class="calibre1"/> allows you to define the number of rows in a section. All the table views have a number of sections and rows. By default, there is only one section; however, it is a requirement to return the number of rows in a section.</li><li class="listitem"><code class="literal">NumberOfSections</code>: This is the number<a id="id335" class="calibre1"/> of sections in the table view.</li><li class="listitem"><code class="literal">GetCell</code>: This method <a id="id336" class="calibre1"/>must return a cell for each row and should be implemented. It is up to the developer to set up how a cell should look like; you can also implement code to recycle the cells as you scroll. Recycling cells will yield better performance while scrolling.</li><li class="listitem"><code class="literal">TitleForHeader</code>: This method, if overridden, is the simplest way to return a string for the title. Each <a id="id337" class="calibre1"/>section in a table view has a standard header view, by default.</li><li class="listitem"><code class="literal">RowSelected</code>: This method <a id="id338" class="calibre1"/>will be called when the user selects a row.</li></ul></div><p class="calibre8">There are additional methods that you can override, but these will get you by in most situations. You can also <a id="id339" class="calibre1"/>set up custom headers and footers if you need to develop a custom styled table view.</p><p class="calibre8">Now, let's open the <code class="literal">ConversationsController.cs</code> file, and create a nested class inside <code class="literal">ConversationsController</code> as follows:</p><div><pre class="programlisting">class TableSource : UITableViewSource
{
  const string CellName = "ConversationCell";
  readonly MessageViewModel messageViewModel = ServiceContainer.Resolve&lt;MessageViewModel&gt;();

  public override int RowsInSection(UITableView tableView, int section)
  {
    return messageViewModel.Conversations == null ?0 : messageViewModel.Conversations.Length;
  }
  public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
  {
    var conversation = messageViewModel.Conversations[indexPath.Row];
    var cell = tableView.DequeueReusableCell(CellName);
    if (cell == null)
    {
      cell = new UITableViewCell(UITableViewCellStyle.Default, CellName);
      cell.Accessory = UITableViewCellAccessory.DisclosureIndicator;
    }
    cell.TextLabel.Text = conversation.Username;
    return cell;
  }
}</pre></div><p class="calibre8">We implemented the two required <a id="id340" class="calibre1"/>methods to set up a table view: <code class="literal">RowsInSection</code> and <code class="literal">GetCell</code>. We returned the number of conversations found on the view model and set up our cell for each row. We also used <code class="literal">UITableViewCellAccessory.DisclosureIndicator</code> to add an indicator for the users to know that they can click on the row.</p><p class="calibre8">Notice our implementation of recycling cells. Calling <code class="literal">DequeueReusableCell</code> with a cell identifier will return a <code class="literal">null</code> cell the first time around. If <code class="literal">null</code>, you should create a new cell using the same cell identifier. Subsequent calls to <code class="literal">DequeueReusableCell</code> will return an existing cell, enabling you to reuse it. You can also define the <code class="literal">TableView</code> cells in the storyboard file, which<a id="id341" class="calibre1"/> is useful for custom cells. Our cell here is very simple, so it is easier to define it from the code. Recycling cells is important on mobile platforms to preserve<a id="id342" class="calibre1"/> memory and provide the user with a very fluid scrolling table.</p><p class="calibre8">Next, we need to set up the <code class="literal">TableView</code> source on <code class="literal">TableView</code>. Add some changes to our <code class="literal">ConversationsController</code> class as follows:</p><div><pre class="programlisting">readonly MessageViewModel messageViewModel = ServiceContainer.Resolve&lt;MessageViewModel&gt;();

public override void ViewDidLoad()
{
  base.ViewDidLoad();
  TableView.Source = new TableSource();
}
public async override void ViewWillAppear(bool animated)
{
  base.ViewWillAppear(animated);
  try
  {
    await messageViewModel.GetConversations();
    TableView.ReloadData();
  }
  catch(Exception exc)
  {
    new UIAlertView("Oops!", exc.Message, null, "Ok").Show();
  }
}</pre></div><p class="calibre8">So when the view appears, we will load our list of conversations. Upon completion of this task, we'll reload the table view so that it displays our list of conversations. If you run the application, you'll see a few conversations appear in the table view after logging in, as shown in the following screenshot. Down the road, everything will operate in the same manner when we load the conversations from a real web service.</p><div><img src="img/00041.jpeg" alt="Using segues and UITableView" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec40" class="calibre1"/>Adding a friends list screen</h1></div></div></div><p class="calibre8">The next fairly important<a id="id343" class="calibre1"/> screen is that of our friends list. When creating a new conversation, the app will load a list of friends to start a conversation with. We'll follow a very similar pattern to load our list of conversations.</p><p class="calibre8">To begin, we'll create <code class="literal">UIBarButtonItem</code> that navigates to a new controller named <code class="literal">FriendsController</code> by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in the iOS designer.</li><li class="listitem" value="2">Add a new <strong class="calibre2">Table View Controller</strong> to the storyboard.</li><li class="listitem" value="3">Select your view controller and click on the <strong class="calibre2">Properties</strong> pane and make sure you have selected the <strong class="calibre2">Widget</strong> tab. </li><li class="listitem" value="4">Enter <code class="literal">FriendsController</code> in the <strong class="calibre2">Class</strong> field.</li><li class="listitem" value="5">Scroll down to the <strong class="calibre2">View Controller</strong> section, enter <code class="literal">Friends</code> in the <strong class="calibre2">Title</strong> field.</li><li class="listitem" value="6">Drag a <strong class="calibre2">Navigation Item</strong> from the <strong class="calibre2">Toolbox</strong> pane onto the <code class="literal">ConversationsController</code>.</li><li class="listitem" value="7">Create a new <strong class="calibre2">Bar Button Item</strong> element and place it in the top-right corner of the new navigation bar.</li><li class="listitem" value="8">In the <strong class="calibre2">Properties</strong> pane of the bar button, set its <strong class="calibre2">Identifier</strong> to <strong class="calibre2">Add</strong>. This will use the built-in plus button, which is commonly used throughout iOS applications.</li><li class="listitem" value="9">Create a segue from <strong class="calibre2">Bar Button Item</strong> to the <code class="literal">FriendsController</code> by holding <em class="calibre12">Ctrl</em> and dragging the blue line from the bar button to the next controller.</li><li class="listitem" value="10">Select the <strong class="calibre2">push</strong> <a id="id344" class="calibre1"/>segue from the popup that appears.</li><li class="listitem" value="11">Save the storyboard file.</li></ol><div></div><p class="calibre8">Your changes to the storyboard should look something similar to what is shown in the following screenshot:</p><div><img src="img/00042.jpeg" alt="Adding a friends list screen" class="calibre9"/></div><p class="calibre10"> </p><p class="calibre8">You will see a new <code class="literal">FriendsController</code> class that Xamarin Studio has generated for you. If you compile and run the application, you'll see the new bar button item we created. Clicking <a id="id345" class="calibre1"/>on it will take you to the new controller.</p><p class="calibre8">Now, let's implement <code class="literal">UITableViewSource</code> to display our friends list. Start with a new nested class inside <code class="literal">FriendsController</code> as follows:</p><div><pre class="programlisting">class TableSource : UITableViewSource
{
  const string CellName = "FriendCell";
  readonly FriendViewModel friendViewModel = ServiceContainer.Resolve&lt;FriendViewModel&gt;();

  public override int RowsInSection(UITableView tableView, int section)
  {
    return friendViewModel.Friends == null ?0 : friendViewModel.Friends.Length;
  }
  public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
  {
    var friend = friendViewModel.Friends[indexPath.Row];
    var cell = tableView.DequeueReusableCell(CellName);
    if (cell == null)
    {
      cell = new UITableViewCell(UITableViewCellStyle.Default, CellName);
      cell.AccessoryView = UIButton.FromType(UIButtonType.ContactAdd);
      cell.AccessoryView.UserInteractionEnabled = false;
    }
    cell.TextLabel.Text = friend.Username;
    return cell;
  }
}</pre></div><p class="calibre8">Just as before, we implemented table cell recycling and merely set the text on the label for each friend. We used <code class="literal">cell.AccessoryView</code> to indicate to the user that each cell is clickable and starts <a id="id346" class="calibre1"/>a new conversation. We disabled the user interaction on the button just to allow the row to be selected when the user clicks on the button. Otherwise, we'd have to implement a click event for the button.</p><p class="calibre8">Next, we'll need to modify <code class="literal">FriendsController</code> in the same way as we did for conversations, as follows:</p><div><pre class="programlisting">readonly FriendViewModel friendViewModel = ServiceContainer.Resolve&lt;FriendViewModel&gt;();

public override void ViewDidLoad()
{
  base.ViewDidLoad();
  TableView.Source = new TableSource();
}
public async override void ViewWillAppear(bool animated)
{
  base.ViewWillAppear(animated);
  try
  {
    await friendViewModel.GetFriends();

    TableView.ReloadData();
  }
  catch(Exception exc)
  {
    new UIAlertView("Oops!", exc.Message, null, "Ok").Show();
  }
}</pre></div><p class="calibre8">This will function exactly <a id="id347" class="calibre1"/>as the conversations list. The controller will load the friends list asynchronously and refresh the table view. If you compile and run the application, you'll be able to navigate to the screen and view the sample friend list we created in <a class="calibre1" title="Chapter 4. XamChat – a Cross-platform App" href="part0036_split_000.html#page">Chapter 4</a>, <em class="calibre12">XamChat – a Cross-platform App</em>, as shown in the following screenshot:</p><div><img src="img/00043.jpeg" alt="Adding a friends list screen" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec41" class="calibre1"/>Adding a list of messages</h1></div></div></div><p class="calibre8">Now let's implement the screen to view a conversation or list of messages. We will try to model the screen after the built-in text message application on iOS. To do so, we will also cover the basics of how to create custom table view cells.</p><p class="calibre8">To start, we'll need a<a id="id348" class="calibre1"/> new <code class="literal">MessagesController</code> class to perform the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in the iOS designer.</li><li class="listitem" value="2">Add a new <strong class="calibre2">Table View Controller</strong> to the storyboard.</li><li class="listitem" value="3">Select your view controller and click on the <strong class="calibre2">Properties</strong> pane and make sure you have selected the <strong class="calibre2">Widget</strong> tab.</li><li class="listitem" value="4">Enter <code class="literal">MessagesController</code> in the <strong class="calibre2">Class</strong> field.</li><li class="listitem" value="5">Scroll down to the <strong class="calibre2">View Controller</strong> section, enter <code class="literal">Messages</code> in the <strong class="calibre2">Title</strong> field.</li><li class="listitem" value="6">Create a segue from <code class="literal">ConversationsController</code> to <code class="literal">MessagesController</code> by holding <em class="calibre12">Ctrl</em> and dragging the blue line from one controller to the other.</li><li class="listitem" value="7">Select the <strong class="calibre2">push</strong> segue from the popup that appears. Enter the <strong class="calibre2">Identifier</strong> <code class="literal">OnConversation</code> in the <strong class="calibre2">Properties</strong> pane.</li><li class="listitem" value="8">Now, create two <strong class="calibre2">Table View Cells</strong> in the table view in <code class="literal">MessagesController</code>. You can reuse the existing one created, by default.</li><li class="listitem" value="9">Enter <code class="literal">MyMessageCell</code> and <code class="literal">TheirMessageCell</code> respectively into the <strong class="calibre2">Class</strong> field for each cell.</li><li class="listitem" value="10">Set the <strong class="calibre2">Identifier</strong> to <code class="literal">MyCell</code> and <code class="literal">TheirCell</code> respectively on each cell.</li><li class="listitem" value="11">Save the storyboard file.</li></ol><div></div><p class="calibre8">Xamarin Studio will generate three files: <code class="literal">MessagesController.cs</code>, <code class="literal">MyMessageCell.cs</code>, and <code class="literal">TheirMessageCell.cs</code>. You might decide to keep things organized by creating a <code class="literal">Views</code> folder and moving the cells into it. Likewise, you can move the controller to a <code class="literal">Controllers</code> folder.</p><p class="calibre8">Now let's implement a base class for both these cells to inherit from:</p><div><pre class="programlisting">public class BaseMessageCell : UITableViewCell
{
  public BaseMessageCell(IntPtr handle) : base(handle)
  {
  }
  public virtual void Update(Message message)
  {
  }
}</pre></div><p class="calibre8">We will override the <code class="literal">Update</code> method later and take the appropriate action for each cell type. We need this class<a id="id349" class="calibre1"/> to make things easier while interacting with both the types of cells from <code class="literal">UITableViewSource</code>.</p><p class="calibre8">Now open <code class="literal">MessagesController.cs</code> and implement <code class="literal">UITableViewSource</code> inside a nested class, as follows:</p><div><pre class="programlisting">class TableSource : UITableViewSource
{
  const string MyCellName = "MyCell";
  const string TheirCellName = "TheirCell";
  readonly MessageViewModel messageViewModel = ServiceContainer.Resolve&lt;MessageViewModel&gt;();
  readonly ISettings settings = ServiceContainer.Resolve&lt;ISettings&gt;();

  public override int RowsInSection(UITableView tableview, int section)
  {
    return messageViewModel.Messages == null ?0 : messageViewModel.Messages.Length;
  }
  public override UITableViewCell GetCell(UITableView tableView, NSIndexPath indexPath)
  {
    var message = messageViewModel.Messages [indexPath.Row];
    bool isMyMessage = message.UserId == settings.User.Id;
    var cell = tableView.DequeueReusableCell(isMyMessage ?MyCellName : TheirCellName) as BaseMessageCell;
    cell.Update(message);
    return cell;
  }
}</pre></div><p class="calibre8">We added some logic to check whether a message is from a current user to decide on the appropriate table cell identifier. Since we have a base class for both cells, we can cast to <code class="literal">BaseMessageCell</code> and use its <code class="literal">Update</code> method.</p><p class="calibre8">Now let's make the changes to our <code class="literal">MessagesController</code> file to load our list of messages and display them:</p><div><pre class="programlisting">readonly MessageViewModel messageViewModel = ServiceContainer.Resolve&lt;MessageViewModel&gt;();

public override void ViewDidLoad()
{
  base.ViewDidLoad();

  TableView.Source = new TableSource();
}
public async override void ViewWillAppear(bool animated)
{
  base.ViewWillAppear(animated);
  Title = messageViewModel.Conversation.Username;
  try
  {
    await messageViewModel.GetMessages();
    TableView.ReloadData();
  }
  catch (Exception exc)
  {
    new UIAlertView("Oops!", exc.Message, null, "Ok").Show();
  }
}</pre></div><p class="calibre8">The only thing new here is where we set the <code class="literal">Title</code> property to the username of the conversation.</p><p class="calibre8">To complete our<a id="id350" class="calibre1"/> custom cells, we will need to make more changes in Xcode by performing the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Double-click on the <code class="literal">MainStoryboard.storyboard</code> file to open it in the iOS designer.</li><li class="listitem" value="2">Drag a new <strong class="calibre2">Label</strong> onto both the custom cells.</li><li class="listitem" value="3">Use some creativity to style both labels. I chose to make the text in <code class="literal">MyMessageCell</code> blue and <code class="literal">TheirMessageCell</code> green. I set <strong class="calibre2">Alignment</strong> on the label to the right aligned in <code class="literal">TheirMessageCell</code>.</li><li class="listitem" value="4">For the <strong class="calibre2">Name</strong> of each cell, enter <code class="literal">message</code>.</li><li class="listitem" value="5">Save the storyboard file and return.</li></ol><div></div><p class="calibre8">Now add the following<a id="id351" class="calibre1"/> <code class="literal">Update</code> method to both <code class="literal">MyMessageCell.cs</code> and <code class="literal">TheirMessageCell.cs</code>:</p><div><pre class="programlisting">public partial class MyMessageCell : BaseMessageCell
{
  public MyMessageCell (IntPtr handle) : base (handle)
  {
  }
  public override void Update(Message message)
  {
    this.message.Text = message.Text;
  }
}</pre></div><p class="calibre8">It is a bit strange to have duplicated the code for each cell, but it is the simplest approach to take advantage of the outlets Xamarin Studio generated based on the storyboard file. You could also have chosen to use the same class for both cells (even with a different layout in Xcode); however, you then lose the ability to have different code in each cell.</p><p class="calibre8">If you run the application now, you will be able to view the messages list, as displayed in the following screenshot:</p><div><img src="img/00044.jpeg" alt="Adding a list of messages" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec42" class="calibre1"/>Composing messages</h1></div></div></div><p class="calibre8">For the final piece of our application, we need to implement some custom functionality that Apple doesn't provide <a id="id352" class="calibre1"/>with their APIs. We need to add a text field with a button that appears to be attached to the bottom of the table view. Most of this will require writing code and wiring up a lot of events.</p><p class="calibre8">Let's begin by adding some new member variables to our <code class="literal">MessagesController</code> class as follows:</p><div><pre class="programlisting">UIToolbar toolbar;
UITextField message;
UIBarButtonItem send;
NSObject willShowObserver, willHideObserver;</pre></div><p class="calibre8">We will place the text field and bar buttons inside the toolbar, as shown in the following code. The <code class="literal">NSObject</code> fields will be<a id="id353" class="calibre1"/> an example of iOS's event system called <a id="id354" class="calibre1"/><strong class="calibre2">notifications</strong>. We'll see how these are used shortly:</p><div><pre class="programlisting">public override void ViewDidLoad()
{
  base.ViewDidLoad();

  //Text Field
  message = new UITextField(new RectangleF(0, 0, 240, 32))
  {
    BorderStyle = UITextBorderStyle.RoundedRect,ReturnKeyType = UIReturnKeyType.Send,ShouldReturn = _ =&gt;
      {
        Send();
        return false;
      },
  };
  //Bar button item
  send = new UIBarButtonItem("Send", UIBarButtonItemStyle.Plain,(sender, e) =&gt; Send());

  //Toolbar
  toolbar = new UIToolbar(new RectangleF(0, TableView.Frame.Height - 44,TableView.Frame.Width, 44));
  toolbar.Items = new UIBarButtonItem[]
  {
    new UIBarButtonItem(message),
    send
  };
  NavigationController.View.AddSubview(toolbar);

  TableView.Source = new TableSource();
  TableView.TableFooterView = new UIView(new RectangleF(0, 0, TableView.Frame.Width, 44))
  {
    BackgroundColor = UIColor.Clear,
  };
}</pre></div><p class="calibre8">Much of this work involves setting up a basic UI. It is not something we can do inside Xcode, because it's a custom UI in this case. We create a text field, bar button item, and toolbar from C# and add them to our navigation controller's view. This will display the toolbar at the top of the table view, no matter where it is scrolled to. Another trick we used was to add a footer view to the table<a id="id355" class="calibre1"/> view, which is of the same height as the toolbar. This will simplify some animations that we'll set up later.</p><p class="calibre8">Now we will need to modify <code class="literal">ViewWillAppear</code> as follows:</p><div><pre class="programlisting">public async override void ViewWillAppear(bool animated)
{
  base.ViewWillAppear(animated);

  Title = messageViewModel.Conversation.Username;

  //Keyboard notifications
  willShowObserver = UIKeyboard.Notifications.ObserveWillShow((sender, e) =&gt; OnKeyboardNotification(e));
  willHideObserver = UIKeyboard.Notifications.ObserveWillHide((sender, e) =&gt; OnKeyboardNotification(e));

  //IsBusy
  messageViewModel.IsBusyChanged += OnIsBusyChanged;
  try
  {
    await messageViewModel.GetMessages();
    TableView.ReloadData();
    message.BecomeFirstResponder();
  }
  catch (Exception exc)
  {
    new UIAlertView("Oops!", exc.Message, null, "Ok").Show();
  }
}</pre></div><p class="calibre8">Most of these changes are straightforward, but notice our use of iOS notifications. Xamarin has provided a C# friendly way to subscribe to notifications. There is a static nested class named <code class="literal">Notifications</code> inside various <code class="literal">UIKit</code> classes that provide notifications. Otherwise, you would have to use the <code class="literal">NSNotificationCenter</code> class, which is not as easy to use. To unsubscribe from these events, we merely need to dispose <code class="literal">NSObject</code> that is returned.</p><p class="calibre8">So let's add an override for <code class="literal">ViewWillDisapper</code> to clean up these events, as follows:</p><div><pre class="programlisting">public override void ViewWillDisappear(bool animated)
{
  base.ViewWillDisappear(animated);
  //Unsubcribe notifications
  if (willShowObserver != null)
  {
    willShowObserver.Dispose();
    willShowObserver = null;
  }
  if (willHideObserver != null)
  {
    willHideObserver.Dispose();
    willHideObserver = null;
  }
  //IsBusy
  messageViewModel.IsBusyChanged -= OnIsBusyChanged;
}</pre></div><p class="calibre8">Next, let's set up our methods<a id="id356" class="calibre1"/> for these events, as follows:</p><div><pre class="programlisting">void OnIsBusyChanged (object sender, EventArgs e)
{
  message.Enabled = send.Enabled = !messageViewModel.IsBusy;
}
void ScrollToEnd()
{
  TableView.ContentOffset = new PointF(0, TableView.ContentSize.Height -TableView.Frame.Height);
}
void OnKeyboardNotification (UIKeyboardEventArgs e)
{
  //Check if the keyboard is becoming visible
  bool willShow = e.Notification.Name == UIKeyboard.WillShowNotification;

  //Start an animation, using values from the keyboard
  UIView.BeginAnimations("AnimateForKeyboard");
  UIView.SetAnimationDuration(e.AnimationDuration);
  UIView.SetAnimationCurve(e.AnimationCurve);

  //Calculate keyboard height, etc.
  if (willShow)
  {
    var keyboardFrame = e.FrameEnd;
    var frame = TableView.Frame;
    frame.Height -= keyboardFrame.Height;
    TableView.Frame = frame;
    frame = toolbar.Frame;
    frame.Y -= keyboardFrame.Height;
    toolbar.Frame = frame;
  }
  else
  {
    var keyboardFrame = e.FrameBegin;
    var frame = TableView.Frame;
    frame.Height += keyboardFrame.Height;
    TableView.Frame = frame;
    frame = toolbar.Frame;
    frame.Y += keyboardFrame.Height;
    toolbar.Frame = frame;
  }
  //Commit the animation
  UIView.CommitAnimations();
  ScrollToEnd();
}</pre></div><p class="calibre8">That is quite a bit of code, but not too difficult. <code class="literal">OnIsBusyChanged</code> is used to disable some of our views while it is loading. <code class="literal">ScrollToEnd</code> is a quick method to scroll the table view to the end. We need <a id="id357" class="calibre1"/>this for the sake of usability. Some math is required because Apple does not provide a built-in method for this.</p><p class="calibre8">On the other hand, <code class="literal">OnKeyboardNotification</code> has quite a lot going on. We used the built-in animation system for iOS to set up an animation when the keyboard appears or hides. We use this to move views around for the onscreen keyboard. Using the animation system is quite easy; call <code class="literal">UIView.BeginAnimations</code>, modify some views, and then finish up with <code class="literal">UIView.CommitAnimations</code>. We also used a few more values from the keyboard to time our animation identically with the keyboard's animations.</p><p class="calibre8">Last but not least, we need to implement a function to send a new message as follows:</p><div><pre class="programlisting">async void Send()
{
  //Just hide the keyboard if they didn't type anything
  if (string.IsNullOrEmpty(message.Text))
  {
    message.ResignFirstResponder();
    return;
  }
  //Set the text, send the message
  messageViewModel.Text = message.Text;
  await messageViewModel.SendMessage();

  //Clear the text field &amp; view model
  message.Text = messageViewModel.Text = string.Empty;

  //Reload the table
  TableView.ReloadData();

  //Hide the keyboard
  message.ResignFirstResponder();

  //Scroll to end, to see the new message
  ScrollToEnd();
}</pre></div><p class="calibre8">This code is also fairly<a id="id358" class="calibre1"/> straightforward. After sending the message, we merely need to reload the table, hide the keyboard, and then make sure we scroll to the bottom to see the new message, as shown in the following screenshot. Using the <code class="literal">async</code> keyword makes this easy.</p><div><img src="img/00045.jpeg" alt="Composing messages" class="calibre9"/></div><p class="calibre10"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec43" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered the basic settings that Apple and Xamarin provide for developing iOS applications. This includes the <code class="literal">Info.plist</code> file and project options in Xamarin Studio. We covered <code class="literal">UINavigationController</code>, the basic building block for navigation in iOS applications, and implemented a login screen complete with username and password fields. Next, we covered iOS segues and the <code class="literal">UITableView</code> class. We implemented the friends list screen using <code class="literal">UITableView</code>, and the messages list screen, also using <code class="literal">UITableView</code>. Lastly, we added a custom UI functionality; a custom toolbar floating at the bottom of the messages list.</p><p class="calibre8">After completing this chapter, you will have a partially functional iOS version of XamChat. You will have a deeper understanding of the iOS platform and tools, and fairly good knowledge to apply to building your own iOS applications. Take it upon yourself to implement the remaining screens that we did not cover in the chapter. If you get lost, feel free to review the full sample application included with this book. In the next chapter, we will develop the Android UI for XamChat using the native Android APIs. A lot of our steps will be very similar to what we did on iOS, and we will be working mainly with the View layer of the MVVM design pattern.</p></div></body></html>