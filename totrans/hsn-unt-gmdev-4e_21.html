<html><head></head><body>
  <div><h1 class="chapterNumber">17</h1>
    <h1 id="_idParaDest-230" class="chapterTitle">Animated Realities: Creating Animations with Animator, Cinemachine, and Timeline</h1>
    <p class="normal">Sometimes, we need to move objects in a predetermined way, such as with cutscenes, or specific character animations, such as jumping, running, and so on. In this chapter, we will go over several Unity animation systems to create all the possible movements of objects we can get without scripting.</p>
    <p class="normal">In this chapter, we will examine the following animation concepts:</p>
    <ul>
      <li class="bulletList">Using skinning animation with Animator</li>
      <li class="bulletList">Scripting animations</li>
      <li class="bulletList">Creating dynamic cameras with Cinemachine</li>
      <li class="bulletList">Creating cutscenes with Timeline</li>
    </ul>
    <p class="normal">By the end of this chapter, you will be able to create cutscenes to tell the history of your game or highlight specific areas of your level, as well as create dynamic cameras that are capable of giving an accurate look to your game, regardless of the situation.</p>
    <h1 id="_idParaDest-231" class="heading-1">Using skinning animation with Animator</h1>
    <p class="normal">So far, we<a id="_idIndexMarker1156"/> have used what are called <a id="_idIndexMarker1157"/>static meshes, which are solid<a id="_idIndexMarker1158"/> three-dimensional models that are not supposed to bend or animate in any way (aside from moving separately, like the doors of a car).</p>
    <p class="normal">We also have another kind of mesh, called skinned meshes, which <a id="_idIndexMarker1159"/>are meshes that have the ability to deform based on a skeleton so they can emulate the muscle movements of the human body. We are going to explore how to integrate animated humanoid characters into our project to create enemy and player movements.</p>
    <p class="normal">In this section, we will examine the following skeletal mesh concepts:</p>
    <ul>
      <li class="bulletList">Understanding skinning</li>
      <li class="bulletList">Importing skinned meshes</li>
      <li class="bulletList">Integration using Animator Controllers</li>
      <li class="bulletList">Using avatar masks</li>
    </ul>
    <p class="normal">Now that we’ve introduced skinned meshes, let’s delve deeper into how skinning functions and its pivotal role in character animation. Then, we are going to bring animated meshes into our project to finally apply animations to them. Let’s start by discussing how to bring skeletal animations into our project.</p>
    <h2 id="_idParaDest-232" class="heading-2">Understanding skinning</h2>
    <p class="normal">In order to get an animated mesh, we<a id="_idIndexMarker1160"/> need to have four pieces, starting with the mesh that will be animated, which is created the same way as any other mesh. Then, we need the skeleton, which is a set of bones that will match the desired mesh topology, such as the arms, fingers, feet, and so on. In <em class="italic">Figure 17.1</em>, you can see an example of a set of bones aligned with our target mesh:</p>
    <figure class="mediaobject"><img src="img/B21361_17_01_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.1: A ninja mesh with a skeleton matching its default pose</p>
    <p class="normal">Once the artist has created the model and its bones, the next step is to do skinning, which is the act of associating every vertex of the model to one or more bones. This way, when you move a bone, the associated vertices will move with it. </p>
    <p class="normal">In <em class="italic">Figure 17.2</em>, you can see the triangles of a mesh being painted according to the color of the bone, which affects it as a way to visualize the influence of the bones. You will notice blending between colors, meaning that those vertexes are affected differently by different bones to allow the vertexes near an articulation to bend nicely. Also, <em class="italic">Figure 17.2 </em>illustrates an example of a two-dimensional mesh used for two-dimensional games, but the concept is the same:</p>
    <figure class="mediaobject"><img src="img/B21361_17_02_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.2: Mesh skinning weights visually represented as colors</p>
    <p class="normal">Finally, the last piece you need is the actual animation, which will simply consist of a blending of different poses of the mesh bones. The artist will create keyframes in an animation, determining which pose the model needs to have at different moments, and then the animation system will simply interpolate between them. Basically, the artist will animate the bones, and the skinning system will apply this animation to the whole mesh.</p>
    <p class="normal">In order to get the four parts, we need to get the proper assets containing them. The usual format in this scenario is <strong class="keyWord">Filmbox</strong> (<strong class="keyWord">FBX</strong>), which <a id="_idIndexMarker1161"/>we used previously to import 3D models. This format can contain every piece we need—the model, the skeleton with the skinning, and the animations—but usually, those pieces will come split into several files to be re-utilized.</p>
    <p class="normal">Imagine a city simulator game where we have several citizen meshes with different aspects, and all of them must be animated. If we have a single FBX per citizen containing the mesh, the skinning, and the animation, it will cause each model to have its own animation, or at least a clone of the same one, repeating them. When <a id="_idIndexMarker1162"/>we need to change that animation, we will need to update all the mesh citizens, which is a time-consuming process. </p>
    <p class="normal">Instead of this, we can have one FBX per citizen, containing the mesh and the bones with the proper skinning based on that mesh, as well as a separate FBX for each animation, containing the same bones that all the citizens have with the proper animation, but without the mesh. This will allow us to mix and match the citizen FBX with the animation’s FBX files. You may be wondering why both the model FBX and the animation FBX must have the mesh. This is because they need to match in order to make both files compatible. In <em class="italic">Figure 17.3</em>, you can see how the files should look:</p>
    <figure class="mediaobject"><img src="img/B21361_17_03_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.3: The animation and model FBX files of the package we will use in our project</p>
    <p class="normal">Also, it is worth mentioning a concept called retargeting. As we said before, in order to mix a model and an animation file, we need them to have the same bone structure, which means the same number of bones, hierarchy, and names.</p>
    <p class="normal">Sometimes, this is not possible, especially when we<a id="_idIndexMarker1163"/> mix custom models created by our artist with external animation files that you can record from an actor using motion-capture techniques or just by buying a <strong class="keyWord">mocap</strong> (<strong class="keyWord">motion-capture</strong>) library, a set of animations captured on real humans using specific mocap hardware. In such cases, it is highly likely that you will encounter different bone structures between the one in the mocap library and your character model, so this is where retargeting kicks in. This technique allows Unity to create a generic mapping between two different humanoid-only bone structures to make them compatible. In the next section, <em class="italic">Importing skeletal animations</em>, we will see how to enable this feature.</p>
    <p class="normal">Now that we understand the basics behind skinned meshes, let’s see how we can get the model’s assets with bones and animations.</p>
    <h2 id="_idParaDest-233" class="heading-2">Importing skeletal animations</h2>
    <p class="normal">We can<a id="_idIndexMarker1164"/> download a character model by searching for it in the Asset Store in the <strong class="keyWord">3D</strong> | <strong class="keyWord">Characters</strong> | <strong class="keyWord">Humanoids</strong> section. You can also use external sites, such as the website called Mixamo, to download them. Note that sometimes you will need to download several packages because some packages come only with the skinned model, and others with animation only. Luckily, the models we downloaded in <em class="italic">Chapter 4, Seamless Integration: Importing and Integrating Assets</em>, already contain the skinned meshes and the animations.</p>
    <p class="normal">In my package content, I can find the animation’s FBX files in the <code class="inlineCode">Animations</code> folder and the FBX file of my model called <code class="inlineCode">Polyart_Mesh</code> in the <code class="inlineCode">Mesh</code> folder. Remember that sometimes you won’t have them separated like this, and the animations may be located in the same FBX as the model if any animations are present at all. Now that we have the required files, let’s discuss how to properly configure them.</p>
    <p class="normal">Let’s start by selecting the <strong class="keyWord">Model</strong> file and checking the <strong class="keyWord">Rig</strong> tab. Within this tab, you will find a setting called <strong class="keyWord">Animation Type</strong>, as shown in <em class="italic">Figure 17.4</em>:</p>
    <figure class="mediaobject"><img src="img/B21361_17_04_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.4: The Rig properties</p>
    <p class="normal">This property <a id="_idIndexMarker1165"/>contains the following options:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">None</strong>: Mode for non-animated models; every static mesh in your game will use this mode.</li>
      <li class="bulletList"><strong class="keyWord">Legacy</strong>: The mode to be used in old Unity projects and models; do not use this in new projects.</li>
      <li class="bulletList"><strong class="keyWord">Generic</strong>: A new animation system that can be used in all kinds of models but is commonly used in non-humanoid models, such as horses, octopuses, and so on. If you use this mode, both the model and animation FBX files must have the exact same bone names and structure, thereby reducing the possibility of combining animation from external sources.</li>
      <li class="bulletList"><strong class="keyWord">Humanoid</strong>: New animation systems designed to be used in humanoid models. It enables features such as retargeting and <strong class="keyWord">Inverse Kinematics</strong> (<strong class="keyWord">IK</strong>). These allow you to use models with different bone structures than the <a id="_idIndexMarker1166"/>animation bones. To do so, Unity converts the bone structure of the models and animations using this mode into a standard humanoid bone structure, making them compatible with each other. This structure is called an <em class="italic">Avatar</em>. Take into account that sometimes the automatic mapping can fail, and you will need to correct it manually; so, if your generic model has everything you need, I recommend you stick to <strong class="keyWord">Generic</strong> if that’s the default configuration of the FBX.</li>
    </ul>
    <p class="normal">In my case, the FBX files in my package have the modes set to <strong class="keyWord">Humanoid</strong>, so that’s good, but remember, only switch to other modes if it is absolutely necessary (for example, if you need to combine different models and animations). Now that we have discussed the <strong class="keyWord">Rig</strong> settings, let’s talk about the <strong class="keyWord">Animation</strong> settings.</p>
    <p class="normal">To do this, select any animation FBX file and look for the <strong class="keyWord">Animation</strong> tab in the <strong class="screenText">Inspector</strong> window. You will find several settings, such as the <strong class="keyWord">Import Animation</strong> checkbox, which must be marked if the file has an animation (not the model files), and the <strong class="keyWord">Clips</strong> list, where you will find all the animations in the file. In the following screenshot, you can see the <strong class="keyWord">Clips</strong> list for one of our animation files:</p>
    <figure class="mediaobject"><img src="img/B21361_17_05_PE.png" alt="A picture containing text, screenshot, number, font  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.5: The Clips list in the Animation settings</p>
    <p class="normal">An FBX file with <a id="_idIndexMarker1167"/>animations usually contains a single large animation track, which can contain one or several animations. Either way, by default, Unity will create a single animation based on that track, but if that track contains several animations, you will need to split them manually. In our case, our FBX contains a single animation, but in order to learn how to split it in other cases, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">From the <strong class="screenText">Clips</strong> list, select any animation that you want to recreate; in my case, I will choose <code class="inlineCode">Run_guard_AR</code>.</li>
      <li class="numberedList">Take a look at the <strong class="screenText">Start</strong> and <strong class="screenText">End</strong> values below the animation timeline and remember them; we will use them to recreate this clip:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_06_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.6: The clip settings</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Use the <strong class="screenText">+</strong> button to create a new clip and select it.</li>
      <li class="numberedList">Rename it to something similar to the original using the input field that currently says something like <code class="inlineCode">Take 001</code>. In my case, I will name it <code class="inlineCode">Run</code>.</li>
      <li class="numberedList">Set the <strong class="screenText">End</strong> and <strong class="screenText">Start</strong> properties with the values we needed to remember in <em class="italic">step 2</em>. In my case, I have <code class="inlineCode">20</code> for <strong class="screenText">End</strong> and <code class="inlineCode">0</code> for <strong class="screenText">Start</strong>. This information usually comes from the artist who made the animation, but you can just try the number that works best or simply drag the blue markers in the timeline on top of these properties.</li>
      <li class="numberedList">If an animation needs to loop, check the <strong class="screenText">Loop Time</strong> checkbox to guarantee that. This will make the animation repeat constantly, which is required in most animations like <strong class="screenText">Walk</strong> or <strong class="screenText">Run</strong>. If not, the animation will play once and never repeat:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_07_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.7: Looping the animation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Preview the<a id="_idIndexMarker1168"/> clip by clicking on the bar titled for your animation (<strong class="screenText">Run</strong>, in my case) at the very bottom of the <strong class="screenText">Inspector</strong> window and click on the <strong class="screenText">Play</strong> button. You can see the default Unity model in some cases, but you can see your own by dragging the model file to the preview window because it is important to check whether our models are properly configured. If the animation does not play, you will need to check whether the <strong class="screenText">Animation Type</strong> setting matches the animation file:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_08_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.8: Animation preview</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Open the animation asset (the FBX) by clicking the arrow on its left, and check the sub-assets. You will see that there is an asset with the same title as your animation:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_09_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.9: Generated animation clips</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Remember<a id="_idIndexMarker1169"/> that there are plenty of other settings aside from the <strong class="screenText">Init</strong> frame, <strong class="screenText">End</strong> frame, and <strong class="screenText">Loop Time</strong>. The character I downloaded required other settings like <strong class="keyWord">Root Transform</strong> <strong class="keyWord">Rotation</strong>, <strong class="keyWord">Root Transform Position</strong>, and <strong class="keyWord">Mask</strong> to make it work, and the mileage may vary between character packages. If you are recreating an existing animation, consider copying all settings as they were or just use the default one. These mentioned settings are beyond the scope of the book, but you can always consult them in the Unity documentation at <a href="https://docs.unity3d.com/Manual/class-AnimationClip.html">https://docs.unity3d.com/Manual/class-AnimationClip.html</a>.</li>
    </ol>
    <p class="normal">Now that we have covered the basic configuration, let’s learn how to integrate animations.</p>
    <h2 id="_idParaDest-234" class="heading-2">Integration using Animation Controllers</h2>
    <p class="normal">When adding animations to our characters, we need to think about the flow of the animations, which means thinking about which animations must be played, when each animation must be active, and how transitions between animations should happen. In previous Unity versions, you needed to code that manually, generating complicated scripts of C# code to handle complex scenarios, but now, we <a id="_idIndexMarker1170"/>have <strong class="keyWord">Animation Controllers</strong>.</p>
    <p class="normal">Animation Controllers are a state machine-based asset where we can diagram the transition logic between animations with a visual editor<a id="_idIndexMarker1171"/> called <strong class="keyWord">Animator</strong>. The idea is that each animation is a separate state, and our model will have several of them. Only one state can be active at a time, so we need to create transitions in order to change them, which will have conditions that must be met in order to trigger the transition process. Conditions are comparisons of data about the character to be animated, such as its velocity, whether it’s shooting or crouched, and so on.</p>
    <p class="normal">So, basically, an<a id="_idIndexMarker1172"/> Animation Controller or state machine is a set of animations with transition rules that will dictate which animation should be active. Let’s start creating a simple Animation Controller by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Click the <strong class="screenText">+</strong> button under the <strong class="screenText">Project</strong> view, click on <strong class="screenText">Animator Controller</strong>, and call it <code class="inlineCode">Player</code>. Remember to locate your asset within a folder for proper organization; I will call mine <code class="inlineCode">Animations</code>.</li>
      <li class="numberedList">Double-click on the asset to open the <strong class="screenText">Animator</strong> window. Don’t confuse this window with the <strong class="screenText">Animation</strong> window; the <strong class="screenText">Animation</strong> window serves to create new animations, but for now, we will stick with the downloaded ones. The <strong class="keyWord">Animator</strong> window is in charge of creating and editing the animation state machines in a visual way, similar to Visual Scripting.</li>
      <li class="numberedList">Search for the <strong class="screenText">Idle</strong> animation clip of your character in the <strong class="screenText">Animations</strong> folder of your characters package and drag it into the <strong class="screenText">Animator</strong> window. In my case, it was called <strong class="screenText">Idle_guard_ar</strong>. Remember to drag the sub-asset, not the entire file. This will create a box in the Animator Controller representing the animation that will be connected to the entry point of the Controller, indicating that the animation will be the default one because it is the first one that we dragged. If you don’t have an <strong class="screenText">Idle</strong> animation, I encourage you to download one from the Asset Store, maybe searching in other characters’ packages. We will need at least one <strong class="screenText">idle</strong> and one <strong class="screenText">walking</strong>/<strong class="screenText">running</strong> animation clip:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_10_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.10: Dragging an animation clip from an FBX asset into an Animator Controller</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Drag the running<a id="_idIndexMarker1173"/> animation in the same way, which is <strong class="screenText">Run_guard_AR</strong> in my case.</li>
      <li class="numberedList">Right-click on the <strong class="screenText">Idle</strong> animation box in the <strong class="screenText">Animator</strong> window, select <strong class="screenText">Make Transition</strong>, and left-click on the <strong class="screenText">Run</strong> animation. This will create a transition between <strong class="screenText">Idle</strong> and <strong class="screenText">Run</strong>.</li>
      <li class="numberedList">Create another transition from <strong class="screenText">Run</strong> to <strong class="screenText">Idle</strong> in the same way:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_11_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.11: Transitions between two animations</p>
    <p class="normal">Transitions must<a id="_idIndexMarker1174"/> have conditions in order to prevent animations from swapping constantly, but in order to create conditions, we need data to make comparisons. We will add properties to our Controller, which will represent data used by the transitions. Later, in the <em class="italic">Scripting animations</em> section of this chapter, we will set that data to match the current state of our object. But for now, let’s create the data and test how the Controller reacts to different values. In order to create conditions based on properties, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Click on the <strong class="screenText">Parameters</strong> tab in the top-left part of the <strong class="screenText">Animator</strong> window. If you don’t see it, click on the button that looks like an eye crossed by a line to display the tabs. The icon will change to an uncrossed eye.</li>
      <li class="numberedList">Click on the <strong class="screenText">+</strong> button and select <strong class="screenText">Float</strong> to create a number that will represent the velocity of our character, naming it <code class="inlineCode">Velocity</code>. If you missed the renaming part, just left-click on the variable and rename it:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_12_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.12: The Parameters tab with a float Velocity property</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Click on the <strong class="screenText">Idle to Run</strong> transition (the white line with an arrow in the middle) and look at the <strong class="screenText">Conditions</strong> property in the <strong class="screenText">Inspector</strong> window.</li>
      <li class="numberedList">Click on the <strong class="screenText">+</strong> button at the bottom of the list, which will create a condition that will rule the transition. The default setting will take the first parameter of our animator (in this case, it is <strong class="screenText">Velocity</strong>) and will set the default comparer, in this case, <strong class="screenText">Greater</strong>, to a value of <code class="inlineCode">0</code>. This tells us that the transition will execute from <strong class="screenText">Idle</strong> to <strong class="screenText">Run</strong> if <strong class="screenText">Idle</strong> is the current animation and the velocity of the Player is greater than <code class="inlineCode">0</code>. I recommend you set a slightly higher value, such as <code class="inlineCode">0.01</code>, to prevent any float rounding errors (a common CPU issue). Also, remember that the actual value of <strong class="screenText">Velocity</strong> needs to be set manually via scripting, which we will do in this chapter’s <em class="italic">Scripting animations</em> section:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_13_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.13: Condition to check whether the velocity is greater than 0.01</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Do the<a id="_idIndexMarker1175"/> same to the <strong class="screenText">Run</strong> <strong class="screenText">to</strong> <strong class="screenText">Idle</strong> transition, but this time, change <strong class="screenText">Greater</strong> to <strong class="screenText">Less</strong> and again set the value to <code class="inlineCode">0.01</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_14_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.14: Condition to check whether a value is less than 0.01</p>
    <h2 id="_idParaDest-235" class="heading-2">Applying the Controller to your character</h2>
    <p class="normal">Now that we <a id="_idIndexMarker1176"/>have set up our first Animator Controller, it’s time to <a id="_idIndexMarker1177"/>apply it to an object. In order to do that, we will need a series of components. First, when we have an animated character, rather than a regular Mesh Renderer, we use the <strong class="keyWord">Skinned Mesh Renderer</strong>. If <a id="_idIndexMarker1178"/>you select your player or enemy characters and view their children GameObjects, you will see the Skinned Mesh Renderer in one or more of them:</p>
    <figure class="mediaobject"><img src="img/B21361_17_15_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.15: A Skinned Mesh Renderer component</p>
    <p class="normal">This component <a id="_idIndexMarker1179"/>will be in charge of applying the bones’ movements<a id="_idIndexMarker1180"/> to the mesh. If you search the children of the model, you will find some bones; you can try rotating, moving, and scaling them to see the effect, as shown in the following screenshot. </p>
    <p class="normal">Bear in mind that your bone hierarchy might be different from mine if you downloaded another package from the Asset Store:</p>
    <figure class="mediaobject"><img src="img/B21361_17_16_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.16: Rotating the neckbone</p>
    <p class="normal">The other component that we need is <strong class="keyWord">Animator</strong>, which <a id="_idIndexMarker1181"/>is automatically added to the skinned meshes at its root GameObject. This component will be in charge of applying the state machine that we created in the Animator Controller if the animation FBX files are properly configured, as we mentioned earlier. In order to apply the Animator Controller, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the player in the <strong class="screenText">Hierarchy</strong> and locate the <strong class="screenText">Animator</strong> component in the root GameObject.</li>
      <li class="numberedList">Click on the circle to the right of the <strong class="screenText">Controller</strong> property and select the <strong class="screenText">Player</strong> controller we created earlier. You can also just drag it from the <strong class="screenText">Project</strong> window.</li>
      <li class="numberedList">Make sure that the <strong class="screenText">Avatar</strong> property is set to the avatar inside the FBX model of the character (<code class="inlineCode">Polyart_Mesh</code> being the FBX model in our example project); this will tell the animator that we will use that skeleton. You can identify the avatar asset by its icon of a person, as shown in the following screenshot. Usually, this property is correctly set automatically when you drag the FBX model to the scene:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_17_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.17: Animator using the Player controller and the robot avatar</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Without<a id="_idIndexMarker1182"/> stopping the game, open the Animator Controller asset again by double-clicking it and selecting the character in the <strong class="screenText">Hierarchy</strong> pane. By<a id="_idIndexMarker1183"/> doing this, you should see the current state of the animation being played by that character, using a bar to represent the current part of the animation:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_18_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.18: The Animator Controller in Play mode while an object is selected, showing the current animation and its progress</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Using the <strong class="screenText">Animator</strong> window, change the value of <strong class="screenText">Velocity</strong> to <code class="inlineCode">1.0</code> and see how the transition will execute. Feel free to disable the <strong class="screenText">WaveSpawners</strong> to test this, given they will probably kill the player before we can safely do so:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_19_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.19: Setting the velocity of the Controller to trigger a transition</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Depending on how the <strong class="screenText">Run</strong> animation was set, your character might start to move instead of executing the animation in place. This is caused by root motion, a feature that will move the character based on the animation movement. Sometimes, this is useful, but due to the fact that we will fully move our character using scripting, we want that feature to be turned off. You can do that by unchecking the <strong class="screenText">Apply Root Motion</strong> checkbox in the <strong class="screenText">Animator</strong> component of the <strong class="screenText">Character</strong> object, as seen in <em class="italic">Figure 17.17</em>.</li>
      <li class="numberedList">You will <a id="_idIndexMarker1184"/>also notice a delay between changing the <strong class="screenText">Velocity</strong> value and the start of the animation transition. That’s because, by default, Unity will<a id="_idIndexMarker1185"/> wait for the original animation to end before executing a transition, but in this scenario, we don’t want that. We need the transition to start immediately. In order to do this, select each transition of the Controller, and in the <strong class="screenText">Inspector</strong> window, uncheck the <strong class="screenText">Has Exit Time</strong> checkbox. When this property is checked, a hidden condition for the transition to execute is waiting for the animation to end. But with this unchecked, the transition can execute at any moment during the animation, which we want, given that we don’t want any delay between the player being idle and running:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_20_PE.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.20: Disabling the Has Exit Time checkbox to execute the transition immediately</p>
    <p class="normal">You can start dragging other animations into the Controller and create complex animation logic, such as adding jump, fall, or crouched animations. I invite you to try other parameter types, such as a Boolean, that use checkboxes instead of numbers. Also, as you develop your game further, your Controller will grow in the number of animations it can handle. To manage that, there are other features worth researching, such<a id="_idIndexMarker1186"/> as <strong class="keyWord">Blend Trees</strong> and sub-state machines, but that’s beyond the scope of this book.</p>
    <p class="normal">In this section, we learned how to integrate animation clips into our characters through Animator Controllers. We added all the required animations and created the necessary transitions between them to react to the game circumstances, like the character velocity changes.</p>
    <p class="normal">Now that we have integrated the idle and run animations, let’s integrate the shoot animation, which requires us to<a id="_idIndexMarker1187"/> use <strong class="keyWord">Avatar Masks</strong>.</p>
    <h2 id="_idParaDest-236" class="heading-2">Using Avatar Masks</h2>
    <p class="normal">Unity <a id="_idIndexMarker1188"/>offers a powerful feature known as Avatar Masks, which allows for selective animation of character parts. This feature is particularly useful in complex scenarios like the one we’re about to explore.</p>
    <p class="normal">At first, this case seems as simple as dragging a shoot animation and making transitions that use the <code class="inlineCode">Shooting</code> Boolean parameter as a condition. Consider, however, that we can shoot while walking and while running, so that leads to two shooting <a id="_idIndexMarker1189"/>animations: <strong class="keyWord">Walking Shooting</strong> and <strong class="keyWord">Idle Shooting</strong>. If you <a id="_idIndexMarker1190"/>follow this logic, you can think of shooting while falling, jumping, etc., which leads to a greater number of animation combinations. Imagine having different shooting animations for different weapons! Luckily, we have a better solution: a way to combine several animations using Avatar Masks. <strong class="keyWord">Avatar Masks</strong> in Unity are tools that allow selective animation of specific parts of a character’s body, enabling precise control over complex animations within the Animator Controller.</p>
    <p class="normal">The animation state machine we created in the Animator Controller is what is called <a id="_idIndexMarker1191"/>a <strong class="keyWord">layer</strong>, and an Animator Controller can have several layers. This means that we can have more than one state machine in an Animator Controller. There are several reasons to use this, but the common one is to combine layers with Avatar Masks, an asset that allows us to make a specific Animator Controller layer or state machine to affect certain bones, so we can set different state machines for different parts of the body.</p>
    <p class="normal">We can use this to solve the shooting scenario we discussed previously, splitting our player animation logic into two parts: the upper part of the body and the lower part. The idea is that the lower part will switch between idle and running animations, while the upper part can switch between idle, running, and shooting. This allows us to have scenarios where the lower part is running while the upper part is shooting or the lower part is idle and the upper part is as well, or any combination we can imagine.</p>
    <p class="normal">Let’s start by creating the second layer by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Download a shooting animation from the internet or the Asset Store if you don’t have one already. In our case, we already have several shooting animations, and we are going to pick the one called <code class="inlineCode">Idle_Shoot_ar</code>.</li>
      <li class="numberedList">In the Animator Controller, do a single click in <strong class="screenText">Base Layer</strong> and rename it <strong class="screenText">LowerBody </strong>for organization purposes. If you don’t see the layers list, click the <strong class="screenText">Layers</strong> button at the top-left part of the <strong class="screenText">Animator</strong> window:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_21_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.21: Renaming the base layer</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Add a second layer to the Controller using the <strong class="screenText">+</strong> button and rename it <code class="inlineCode">UpperBody</code>. This one will handle the upper body animations.</li>
      <li class="numberedList">Select the layer and add the <strong class="screenText">Idle</strong>, <strong class="screenText">Run</strong>, and <strong class="screenText">Shoot</strong> animations to it, connecting the states with transitions. Remember to uncheck <strong class="screenText">Has Exit Time</strong> in each transition. With this, the upper body has the<a id="_idIndexMarker1192"/> same animations as the lower one, but also the shooting one.</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_22_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.22: UpperBody state machine</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Add the same transition logic between <strong class="screenText">Idle</strong> and <strong class="screenText">Run</strong> used before, using <strong class="screenText">Velocity</strong> as the parameter for the conditions, as before.</li>
      <li class="numberedList">For the shooting transitions, create a Boolean parameter called <strong class="screenText">Shooting</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_23_PE.png" alt="A picture containing text, screenshot, font, number  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.23: Shooting Boolean</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Make both transitions to shooting (<strong class="screenText">Idle</strong> to <strong class="screenText">Shoot</strong> and <strong class="screenText">Run</strong> to <strong class="screenText">Shoot</strong>) execute when the <strong class="screenText">Shooting</strong> Boolean is <strong class="screenText">true</strong>.</li>
      <li class="numberedList">Make the return transition from <strong class="screenText">Shoot</strong> to <strong class="screenText">Idle</strong> when the <strong class="screenText">Shooting</strong> Boolean is <strong class="screenText">false</strong>, and <strong class="screenText">Velocity</strong> is less than <code class="inlineCode">0.01</code>, and the return from <strong class="screenText">Shoot</strong> to <strong class="screenText">Run</strong> when <strong class="screenText">Shooting</strong> is <strong class="screenText">true</strong>, and <strong class="screenText">Velocity</strong> is greater than <code class="inlineCode">0.01</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_24_PE.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.24: The Shoot to Idle transition at the top, the Shoot to Run transition in the middle, and both the Idle to Shoot and Run to Shoot transitions at the bottom</p>
    <p class="normal">Now that we have the <a id="_idIndexMarker1193"/>layers created, let’s apply the Avatar Masks to them:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an Avatar Mask using the <strong class="screenText">+</strong> button in the <strong class="screenText">Project View</strong>, and name the first one <code class="inlineCode">UpperBodyMask</code>.</li>
      <li class="numberedList">Select the <code class="inlineCode">UpperBodyMask</code> asset in the <strong class="screenText">Inspector </strong>and click the arrow on the left where it says <strong class="screenText">Humanoid </strong>to expand this section.</li>
      <li class="numberedList">Click the lower parts of the body displayed in the <strong class="screenText">Inspector</strong> until they become red:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_25_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.25: UpperBodyMask asset configs</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the Animator <a id="_idIndexMarker1194"/>Controller, select the <strong class="screenText">UpperBody</strong> layer and click on the gear icon to its right to display some options.</li>
      <li class="numberedList">Click on the circle at the right of the <strong class="screenText">Mask</strong> property and select the <strong class="screenText">UpperBodyMask</strong> asset in the window that appears.</li>
      <li class="numberedList">Click again at the wheel of the <strong class="screenText">UpperBody</strong> layer and set its <strong class="screenText">Weight</strong> to <code class="inlineCode">1</code>. Since the two layers affect different parts of the body, both of them have the same priority. In scenarios where two layers affect the same bones, the weight is used to calculate which one has more influence:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_26_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.26: Setting the Weight and the Mask of a layer</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Click again on the wheel and observe how the <strong class="screenText">Blending</strong> parameter is set to <strong class="screenText">Override</strong>, meaning that the bones that this layer affects (driven by the Avatar Mask) will override whatever animation the base layer has—the base layer, in this case, being <strong class="screenText">LowerBody</strong>. That’s how this layer takes ownership of the upper part of the body.</li>
      <li class="numberedList">Test this again, changing the values of the parameters while in <strong class="screenText">Play</strong> mode. For example, try checking <strong class="screenText">Shooting</strong> and then setting <strong class="screenText">Velocity</strong> to <code class="inlineCode">1</code> and then to <code class="inlineCode">0</code> to finally uncheck <strong class="screenText">Shooting</strong> and see how the transitions execute.</li>
      <li class="numberedList">You might notice that our character might not be pointing in the right direction when shooting. This is because the orientation of the character is modified for this <strong class="screenText">Shoot</strong> animation <a id="_idIndexMarker1195"/>compared to <strong class="screenText">Idle</strong> and <strong class="screenText">Run</strong>, but the <strong class="screenText">Base Layer</strong> still has ownership of that. We can make the <strong class="screenText">UpperBodyMask</strong> control the orientation by clicking the circle at the bottom of the human figure in the <strong class="screenText">Humanoid</strong> section of the Avatar Mask until it becomes green:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_27_PE.png" alt="A picture containing footwear, cartoon, art  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.27: Giving the mask authority over the player orientation</p>
    <p class="normal">The issue here is that you will now see the character moving the feet sideways when running and shooting. There’s no easy solution here other than to modify the original animations. In this case, this character has <strong class="screenText">Idle</strong>, <strong class="screenText">Idle Shooting</strong>, <strong class="screenText">Run</strong>, and <strong class="screenText">Run Shooting</strong> animations, so it clearly has been created without having Avatar Masks in mind instead of just having all possible animation combinations. An alternative is to find another package that works better with Avatar Masks. For learning purposes, we will stick with this, but note that Avatar Masks are not a must; you might be good to go just using all possible animation permutations in a single Animator Controller state machine with all the needed transitions.</p>
    <p class="normal">Another issue you might notice when firing when the <strong class="screenText">Shoot</strong> animation is playing is that the muzzle effect will stay in the original position of the weapon. Since the weapon mesh is affected by the skinning animation but not its <strong class="screenText">Transform</strong> position, the muzzle cannot follow it. In order to solve this, you can reparent the <strong class="screenText">Muzzle Effect</strong> to one of the bones of the weapons—in this case, the GameObject called <strong class="screenText">Trigger_Right</strong>, one of the children of the <strong class="screenText">Hips</strong> GameObject. Not all animations will have bones for the weapons, so this is one of the possible scenarios you could face:</p>
    <figure class="mediaobject"><img src="img/B21361_17_28_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.28: Reparenting the Muzzle Effect to one of the weapon’s bones</p>
    <p class="normal">Remember to apply <a id="_idIndexMarker1196"/>the same changes we made to our player to the enemy, which means adding and setting the Player Animator Controller to its <strong class="keyWord">Animator</strong> component and changing the <code class="inlineCode">Muzzle effect</code> parent.</p>
    <p class="normal">With our Animator Controller now set up with Avatar Masks, the next step is to bring these animations to life in our game environment through scripting.</p>
    <h1 id="_idParaDest-237" class="heading-1">Scripting animations</h1>
    <p class="normal">Scripting is crucial in bringing our<a id="_idIndexMarker1197"/> animations in sync with gameplay. Here, we’ll script our animations to respond dynamically to player actions, making our game more immersive and responsive.</p>
    <p class="normal">With our player’s Animator Controller ready, it is time to do some scripting to make these parameters be affected by the actual behavior of the player and match the player’s. In this section, we will do the following to achieve this:</p>
    <ul>
      <li class="bulletList">Script shooting animations</li>
      <li class="bulletList">Script movement animations</li>
    </ul>
    <p class="normal">Let’s start making our characters execute the <strong class="keyWord">Shoot</strong> animation when necessary.</p>
    <h2 id="_idParaDest-238" class="heading-2">Scripting player shooting animations</h2>
    <p class="normal">So far, we have created <a id="_idIndexMarker1198"/>a behavior to shoot each time we press a key, but the animation is prepared for sustained fire. We can make our <code class="inlineCode">PlayerShooting</code> script shoot a bullet every X number of seconds while we keep the <strong class="keyWord">Fire</strong> key pressed to match the animation instead of having to press the key repeatedly.</p>
    <p class="normal">By adding a <code class="inlineCode">fireRate</code> variable, we control the shooting speed, ensuring it aligns with our animation timing. Let’s see how to do this:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <strong class="screenText">PlayerShooting</strong> script, add a public float field called <code class="inlineCode">fireRate</code>, which will measure the seconds between bullet spawns. Remember to set this value in the <strong class="screenText">Inspector</strong> of the player.</li>
      <li class="numberedList">Change<a id="_idIndexMarker1199"/> the <strong class="screenText">OnFire</strong> method to the code seen in <em class="italic">Figure 17.29</em>. The idea is to start a repeating action when we press the key and stop it when we release the key. We are using <strong class="screenText">InvokeRepeating</strong> to repeatedly execute a function called <strong class="screenText">Shoot,</strong> which we will be creating in the next step. The rate of execution will be controlled by the <strong class="screenText">fireRate</strong> field we created in <em class="italic">step 1</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_29_PE.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.29: OnFire changes needed for sustained fire</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Add the <strong class="screenText">Shoot</strong> method, as seen in <em class="italic">Figure 17.30</em> , to our <strong class="screenText">PlayerShooting</strong> script. This is essentially the same code we had before in the <strong class="screenText">OnFire</strong> method but separated into a function, so we can execute it several times with the <strong class="screenText">InvokeRepeating</strong> function:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_30_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.30: OnFire changes needed for sustained fire</p>
    <p class="normal">If you try <a id="_idIndexMarker1200"/>these changes now, you will notice the bullets will never stop shooting once we click the <strong class="keyWord">Fire</strong> button. Even worse, as we press repeatedly, more and more bullets will be shot. With some debugging or educated guessing, you might figure out that the <strong class="keyWord">CancelInvoke</strong> method is not being executed. The reason behind this is that the <strong class="keyWord">Fire</strong> input mapping is not configured by default to inform us about the release of keys, just when they were pressed. Luckily, the solution is pretty simple:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Double-click the <strong class="screenText">SuperShooter</strong> inputs asset, the one we created in <em class="chapterRef">Chapter 6</em>,<em class="italic"> Dynamic Motion: Implementing Movement and Spawning</em>, that contains all the inputs our game supports.</li>
      <li class="numberedList">Select the <strong class="screenText">Fire</strong> action in the <strong class="screenText">Actions</strong> list (the middle column).</li>
      <li class="numberedList">Click the <strong class="screenText">+</strong> button at the right of the <strong class="screenText">Interactions</strong> section and click <strong class="screenText">Press</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Trigger Behavior </strong>of the <strong class="screenText">Press</strong> section to <strong class="screenText">Press And Release</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_31_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.31: OnFire changes needed for sustained fire</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">With this, we <a id="_idIndexMarker1201"/>have configured the input to tell us not only when the key was pressed but also when it was released, making our <strong class="screenText">CancelInvoke</strong> method execute now.</li>
    </ol>
    <p class="normal">Now that we have our constant fire behavior, we can do the following to make the animation reflect this:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add a reference to <code class="inlineCode">Animator</code> using <strong class="screenText">GetComponent</strong> in <strong class="screenText">Awake</strong> and cache it in a field, as seen in <em class="italic">Figure 17.32</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_32_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.32: Caching the Animator reference</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Add the line <code class="inlineCode">animator.SetBool(“Shooting”, value.isPressed);</code> at the beginning of the <strong class="screenText">OnFire</strong> method:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_33_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.33: Setting the Shooting animation parameter to reflect input</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">The idea behind this change is to make sure the <strong class="screenText">Shooting</strong> animation parameter reflects the state of the fire key, meaning that the <code class="inlineCode">Shoot</code> animation will play as long as the <strong class="screenText">Fire</strong> button is pressed and will stop when we release it.</li>
    </ol>
    <p class="normal">One thing you will notice is that the bullets are still being shot from the player’s chest because our <strong class="keyWord">ShootPoint</strong> GameObject, the one that defines the shooting position, is not positioned in front of the weapon. Just re-parent the <strong class="keyWord">ShootPoint</strong> to the weapon bone (<strong class="keyWord">Trigger_Right</strong> in our case) and position it to be in front of the weapon. Remember to make the forward vector (the blue arrow in the <strong class="keyWord">Scene</strong> view) point along the weapon:</p>
    <figure class="mediaobject"><img src="img/B21361_17_34_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.34: Adapting the ShootPoint to follow the animation</p>
    <p class="normal">For the Visual <a id="_idIndexMarker1202"/>Scripting version, in order to get the bullet to be shot constantly, you should change the <strong class="keyWord">Input</strong> nodes of <strong class="keyWord">PlayerShooting</strong> like in <em class="italic">Figure 17.35</em>:</p>
    <figure class="mediaobject"><img src="img/B21361_17_35_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.35: Creating a shoot loop</p>
    <p class="normal">As you can see, we<a id="_idIndexMarker1203"/> used a new node called <strong class="keyWord">Timer</strong>. The idea of a <strong class="keyWord">Timer</strong> is similar to the <strong class="keyWord">Wait For Seconds</strong> node we used before because it allows us to delay the execution of one action. One of the main differences is that it allows us to cancel the timer before it executes again, meaning we can start the timer when we press the <strong class="keyWord">Fire</strong> key and stop it when we release it. We did that by connecting the <strong class="keyWord">InputSystemEventButton</strong> node that has the <strong class="keyWord">OnPressed</strong> mode to the <strong class="keyWord">Start</strong> pin of the <strong class="keyWord">Timer</strong> and the one with the <strong class="keyWord">OnReleased</strong> mode to the <strong class="keyWord">Pause</strong> pin. Also, we created a new variable called <strong class="keyWord">fireRate</strong> and connected it to the <strong class="keyWord">Duration</strong> pin of the <strong class="keyWord">Timer</strong>, so we need to specify how much time the <strong class="keyWord">Timer</strong> will wait before instantiating our bullets. See how we connected the <strong class="keyWord">Completed</strong> pin of the <strong class="keyWord">Timer</strong> to the <strong class="keyWord">If</strong> node that checks if we have enough bullets to instantiate; we used to connect to the input node here before.</p>
    <p class="normal">One little missing detail here is that when we press a key, time will pass (<strong class="keyWord">fireRate</strong>), and then a bullet will be instantiated, but then nothing else. We need to connect the end of the <strong class="keyWord">Bullet</strong> shoot sequence (the <strong class="keyWord">AudioSource: Play</strong> node in this case) of nodes again to the <strong class="keyWord">Start</strong> pin of the <strong class="keyWord">Timer</strong> to create a spawn loop. That loop will be interrupted when we release the key to prevent it from being executed forever:</p>
    <figure class="mediaobject"><img src="img/B21361_17_36_P.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.36: Completing the shoot loop</p>
    <p class="normal">Finally, we need to add the proper <code class="inlineCode">Animator: SetBool(Name, Value)</code> node to the Input nodes to turn on and off the Boolean and trigger the animation:</p>
    <figure class="mediaobject"><img src="img/B21361_17_37_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.37: Executing the Shoot animation</p>
    <p class="normal">Now that we<a id="_idIndexMarker1204"/> have configured the player’s shooting animations, let’s apply similar principles to script the enemy’s animations for consistency in gameplay mechanics:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Cache a reference to the parent animator in the <strong class="screenText">EnemyFSM</strong> script using <strong class="screenText">GetComponentInParent</strong> as we did with the <strong class="screenText">NavMeshAgent</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_38_PE.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.38: Accessing the parent’s Animator reference</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Turn on the <strong class="screenText">Shooting</strong> animator parameter inside the <strong class="screenText">Shoot</strong> function to make sure that every time we shoot, that parameter is set to <strong class="screenText">true</strong> (checked):</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_39_PE.png" alt="A close-up of a logo  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.39: Turning on the shooting animation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Turn off <a id="_idIndexMarker1205"/>the <code class="inlineCode">Shooting</code> parameter in all non-shooting states, such as <strong class="screenText">GoToBase</strong> and <strong class="screenText">ChasePlayer</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_40_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.40: Turning off the shooting animation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Regarding the<a id="_idIndexMarker1206"/> Visual Scripting version, the <strong class="screenText">GoToBase</strong> state in the <strong class="screenText">EnemyFSM</strong> will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_41_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.41: GoToBase state</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Note that we <a id="_idIndexMarker1207"/>needed the <strong class="screenText">GetParent</strong> node again to access the enemy’s parent <strong class="screenText">Transform</strong> (the <strong class="screenText">root</strong>), which we connected to the <strong class="screenText">Animator: SetBool</strong> node in order to access the Animator in the enemy’s root. Then, the <strong class="screenText">ChasePlayer</strong> state actions will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_42_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.42: ChasePlayer state</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Then, both the <strong class="screenText">AttackBase</strong> and <strong class="screenText">AttackPlayer</strong> initial actions will look like this:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_43_PE.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 17.43: AttackBase state</p>
    <p class="normal">With this, both our <a id="_idIndexMarker1208"/>player and enemies have a constant shooting behavior and a <strong class="keyWord">Shoot</strong> animation to reflect this. Now, let’s handle the movement animations for both.</p>
    <h2 id="_idParaDest-239" class="heading-2">Scripting movement animations</h2>
    <p class="normal">Scripting movement animations is<a id="_idIndexMarker1209"/> essential to translating the physical movement of game characters into visual animations. Let’s see how we can dynamically adjust our character’s velocity in the game.</p>
    <p class="normal">For the Animator Controller’s <code class="inlineCode">Velocity</code> parameter, we can detect the magnitude of the velocity vector of the Rigidbody, the velocity in meters per second, and set that as the current value. Separating this script enhances modularity and allows for easier reuse in different game scenarios. </p>
    <p class="normal">So, we need to create a script such as the one in the following image, which just connects the <code class="inlineCode">Rigidbody</code> component’s velocity with the animator’s <code class="inlineCode">Velocity</code> parameter and adds it to the Player GameObject:</p>
    <figure class="mediaobject"><img src="img/B21361_17_44_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.44: Setting VelocityAnimator variables</p>
    <p class="normal">And <a id="_idIndexMarker1210"/>regarding the Visual Scripting version, this is what it would look like:</p>
    <figure class="mediaobject"><img src="img/B21361_17_45_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.45: Setting Velocity Animator variables in Visual Scripting</p>
    <p class="normal">You may need to increase the <code class="inlineCode">0.01</code> transitions threshold used so far in the conditions of the transitions of the Animator Controller<a id="_idIndexMarker1211"/> because <strong class="keyWord">Rigidbody</strong> keeps moving after releasing the keys. Using <code class="inlineCode">1</code> worked perfectly for me. Another option would be to increase the drag and the velocity of the player to make the character stop faster. Pick whatever method works best for you. Remember the transitions of both layers (<strong class="keyWord">UpperBody</strong> and <strong class="keyWord">LowerBody</strong>).</p>
    <p class="normal">Now, we can<a id="_idIndexMarker1212"/> add the movement animations to the enemy. Create and add a script to the enemy prefab called <strong class="keyWord">NavMeshAnimator</strong>, which <a id="_idIndexMarker1213"/>will take the current <a id="_idIndexMarker1214"/>velocity of its <strong class="keyWord">NavMeshAgent</strong> and set it to the Animator Controller. This will work similarly <a id="_idIndexMarker1215"/>to the <strong class="keyWord">VelocityAnimator</strong> script, but this time, checking the velocity of the <strong class="keyWord">NavMeshAgent</strong>. We didn’t use <strong class="keyWord">VelocityAnimator</strong> here because our AI doesn’t use <strong class="keyWord">Rigidbody</strong> to move, so it won’t work:</p>
    <figure class="mediaobject"><img src="img/B21361_17_46_PE.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 17.46: Connecting the NavMeshAgent to our Animator Controller</p>
    <p class="normal">The Visual Scripting version will look like this:</p>
    <figure class="mediaobject"><img src="img/B21361_17_47_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.47: Setting the animator’s velocity parameter the same as our NavMeshAgent</p>
    <p class="normal">Notice that <a id="_idIndexMarker1216"/>we don’t need the <code class="inlineCode">GetParent</code> node here, given that this graph is located at the enemy’s root object alongside <a id="_idIndexMarker1217"/>the <strong class="keyWord">Animator</strong> and the <strong class="keyWord">NavMeshAgent</strong>. With that, we<a id="_idIndexMarker1218"/> have scripted our Player and enemy animations.</p>
    <div><p class="normal">Sometimes, animation clips are not enough to create a believable animation, given they are pre-defined and they don’t adapt to the player’s surroundings. One example is the case of a player standing on a staircase, where the player’s feet should be placed at different heights, but the idle animation was probably designed for standing on flat ground. While you could play around blending animations with feet at different heights, that would be difficult to manage. Instead, you can mix static animations (the regular Animation package) with procedural animations, animations that modify the character rig via scripting. You can achieve this using the following Unity package: <a href="mailto:https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.animation.rigging@1.0/manual/index.html</a>.</p>
    </div>
    <p class="normal">Now, we are ready to keep learning about animations using Cinemachine to create cutscene cameras and much more.</p>
    <h1 id="_idParaDest-240" class="heading-1">Creating dynamic cameras with Cinemachine</h1>
    <p class="normal">Cameras<a id="_idIndexMarker1219"/> are a very important subject in video games. They allow the player to see their surroundings and make decisions based on what they see. The game designer usually defines how they behave to get the exact gameplay experience they want, and that’s no easy task. A lot of behaviors must be layered to get the exact feeling. Also, for cutscenes, it is important to control the path that the camera will be traversing and where the camera is looking to focus the action during those constantly moving scenes.</p>
    <p class="normal">Cinemachine<a id="_idIndexMarker1220"/> is Unity’s <a id="_idIndexMarker1221"/>advanced suite for camera control, enabling<a id="_idIndexMarker1222"/> developers to craft dynamic and responsive camera behaviors that enhance the gaming experience. In this chapter, we will use the <code class="inlineCode">Cinemachine</code> package to create both the dynamic cameras that will follow the player’s movements, which we will code in <em class="chapterRef">Section 3</em>, <em class="italic">Elevating Visuals, Effects, and Audio </em>and also the cameras to be used during cutscenes.</p>
    <p class="normal">In this section, we will examine the following Cinemachine concepts:</p>
    <ul>
      <li class="bulletList">Creating camera behaviors</li>
      <li class="bulletList">Creating dolly tracks</li>
    </ul>
    <p class="normal">Let’s start by discussing how to create a Cinemachine-controlled camera and configure behaviors in it.</p>
    <h2 id="_idParaDest-241" class="heading-2">Creating camera behaviors</h2>
    <p class="normal">Cinemachine<a id="_idIndexMarker1223"/> revolutionizes camera control by offering a suite of flexible and intuitive behaviors, significantly simplifying the complex camera setups commonly seen in video games.</p>
    <p class="normal">Cinemachine<a id="_idIndexMarker1224"/> is a Unity package containing a collection of different behaviors that can be used in a camera, which, when properly combined, can generate all kinds of common camera types in video games, including following the player from behind, first-person cameras, top-down cameras, and so on. In order to use these behaviors, we need to understand the concept of brains and virtual cameras.</p>
    <p class="normal">In Cinemachine, we will only keep one main camera, as we have done so far, and that camera will be controlled by virtual cameras, separated by GameObjects that have the aforementioned behaviors. We can have several virtual cameras and swap between them at will, but the active virtual camera will be the only one that will control our main camera. This is useful for switching cameras at different points of the game, such as switching between our player’s third-person camera and a cutscene camera. In order to control the main camera with the virtual cameras, it must have a <strong class="keyWord">Brain</strong> component, which will monitor all active virtual cameras and pick the proper position to use them.</p>
    <p class="normal">To start using Cinemachine, first, we need to check if it is installed in the Package Manager, as we did previously with other packages. If you don’t remember how to do this, just do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Go to <strong class="screenText">Window</strong> | <strong class="screenText">Package Manager</strong>.</li>
      <li class="numberedList">Ensure that the <strong class="screenText">Packages</strong> option in the top-left part of the window is set to <strong class="screenText">Unity Registry</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_48.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.48: The Packages filter mode</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Wait a moment for the left panel to populate all packages from the servers (an internet connection is required).</li>
      <li class="numberedList">Look for the <strong class="screenText">Cinemachine</strong> package from the list and select it. At the moment of writing this book, the latest available version is 2.9.7, but you can use newer versions if you prefer, always ensuring that the following steps work as expected; if not, you can always install the closest version to ours.</li>
      <li class="numberedList">If you see the <strong class="screenText">Install</strong> button in the bottom-right corner of the screen, it means it is not installed. Just click that button.</li>
    </ol>
    <p class="normal">Now that we have<a id="_idIndexMarker1225"/> it installed, we can start creating a virtual camera to follow the player. So far, we just simply parented the camera to the player for it to follow them, but now we will unparent the camera and let Cinemachine handle it to learn how to use this tool:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the <strong class="screenText">MainCamera</strong> inside the player and unparent it (drag it outside the player) in such a way that it becomes a root object of our scene, having no parent at all.</li>
      <li class="numberedList">Click <strong class="screenText">GameObject | Cinemachine | Virtual Camera</strong>. This will create a new object called <code class="inlineCode">CM vcam1</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_49.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.49: Virtual camera creation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">If you select the <strong class="screenText">MainCamera</strong> from the <strong class="screenText">Hierarchy</strong> pane, you will also notice that a <code class="inlineCode">CinemachineBrain</code> component has been automatically added to it, making our main camera follow the virtual camera. Try to move the created virtual camera, and you will see how the main camera follows it:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_50.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.50: The CinemachineBrain component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Select the<a id="_idIndexMarker1226"/> virtual camera (<code class="inlineCode">CM vcam1</code>) and drag the character to the <strong class="screenText">Follow</strong> and <strong class="screenText">Look At</strong> properties of the <strong class="screenText">CinemachineVirtualCamera </strong>component. This will make the movement and looking behaviors use that object to do their jobs:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_51_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.51: Setting the target of our camera</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">You can see how the <strong class="screenText">Body</strong> property of the virtual camera is set to <strong class="screenText">Transposer</strong>, which will move the camera relative to the target set at the <strong class="screenText">Follow</strong> property—in our case, the character. You can open the <strong class="screenText">Body</strong> options (the arrow to its left), change the <strong class="screenText">Follow Offset</strong> property, and set it to the desired distance you want the camera to have from the target. In my case, I used the <code class="inlineCode">0</code>, <code class="inlineCode">3</code>, and <code class="inlineCode">-3</code> values:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_52_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.52: The camera following the character from behind</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6"><em class="italic">Figure 17.52</em> shows the <strong class="screenText">Game</strong> view; you can see a small, yellow rectangle indicating the target position to look at the character, and it’s currently pointing at the pivot of the character—its feet. If you don’t see it, open the <strong class="screenText">Aim</strong> section of the virtual camera in the <strong class="screenText">Inspector</strong> by clicking the arrow to its left.</li>
      <li class="numberedList">We can apply an<a id="_idIndexMarker1227"/> offset in the <strong class="screenText">Tracked Object Offset</strong> property of the <strong class="screenText">Aim</strong> section of the virtual camera. In my case, values of <code class="inlineCode">0</code>, <code class="inlineCode">1.8</code>, and <code class="inlineCode">0</code> worked well to make the camera look at the head instead:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_53_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.53: Changing the Aim offset</p>
    <p class="normal">As you can see, using Cinemachine is pretty simple, and, in our case, the default settings were mostly enough for the kind of behavior we needed. However, if you explore the other <strong class="keyWord">Body</strong> and <strong class="keyWord">Aim</strong> modes, you will find that you can create any type of camera for any type of game. </p>
    <p class="normal">We won’t cover the other modes in this book, but I strongly recommend you look at the documentation for Cinemachine to check what the other modes do. To open the documentation, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Open the Package Manager by going to <strong class="screenText">Window</strong> | <strong class="screenText">Package Manager</strong>.</li>
      <li class="numberedList">Find <strong class="screenText">Cinemachine</strong> in the left-hand side list. Wait a moment if it doesn’t show up. Remember that you need an internet connection for it to work.</li>
      <li class="numberedList">Once Cinemachine is selected, scroll down in the right panel until you see the <strong class="screenText">Documentation</strong> link in blue. Click on it:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_54.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.54: The Cinemachine documentation link</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">You can <a id="_idIndexMarker1228"/>explore the documentation using the navigation menu on the left:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_55_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.55: The Cinemachine documentation</p>
    <p class="normal">As you did with Cinemachine, you can find other packages’ documentation in the same way. Now that we have achieved the basic camera behavior that we need, let’s explore how we can use Cinemachine to create a camera for our intro cutscene.</p>
    <h2 id="_idParaDest-242" class="heading-2">Creating dolly tracks</h2>
    <p class="normal">When the player starts <a id="_idIndexMarker1229"/>the level, we want a little cutscene with a pan over our scene and the base before entering the battle. This will require the camera to follow a fixed path, and that’s exactly what Cinemachine’s dolly camera does. It creates a path where we can attach a virtual camera so that it will follow it. We can set Cinemachine to move automatically through the track or follow a target to the closest point to the track; in our case, we will use the first option.</p>
    <p class="normal">In order to create a dolly camera, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Let’s start creating the track with a cart, which is a little object that will move along the track, which will be the target to follow the camera. To do this, click on <strong class="screenText">GameObject | Cinemachine | Dolly Track with Cart</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_56_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.56: A dolly camera with a default straight path</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">If you select <a id="_idIndexMarker1230"/>the <code class="inlineCode">DollyTrack1</code> object, you can see two circles with the numbers <code class="inlineCode">0</code> and <code class="inlineCode">1</code> in the <strong class="screenText">Scene</strong> view. These are the control points of the track. Select one of them and move it as you move other objects, using the arrows of the translation gizmo. If you don’t see them, press the <em class="keystroke">W</em> key to enable the <strong class="screenText">Translation</strong> gizmo.</li>
      <li class="numberedList">You can create more control points by clicking the <strong class="screenText">+</strong> button at the bottom of the <strong class="screenText">Waypoints</strong> list of the <code class="inlineCode">CinemachineSmoothPath</code> component of the <code class="inlineCode">DollyTrack1</code> object:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_57.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.57: Adding a path control point</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Create as many waypoints as you need to create a path that will traverse the areas you want the camera to oversee in the intro cutscene. Remember, you can move the waypoints by clicking on them and using the translation gizmo:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_58_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.58: A dolly track for our scene. It ends right behind the character</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Create a new<a id="_idIndexMarker1231"/> virtual camera. If you go to the <strong class="screenText">Game</strong> view after creating it, you will notice that the character camera will be active. In order to test how the new camera looks, select the previous one (<strong class="screenText">CM vcam1</strong>) and temporarily disable it by clicking the checkbox to the left of the GameObject’s name in the <strong class="screenText">Inspector</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Follow</strong> target this time to the <code class="inlineCode">DollyCart1</code> object that we previously created with the track.</li>
      <li class="numberedList">Set the <strong class="screenText">Follow Offset</strong> of the <strong class="screenText">Body</strong> section to <code class="inlineCode">0</code>, <code class="inlineCode">0</code>, and <code class="inlineCode">0</code> to keep the camera in the same position as the cart.</li>
      <li class="numberedList">Set <strong class="screenText">Aim</strong> to <strong class="screenText">Same As Follow Target</strong> to make the camera look in the same direction as the cart, which will follow the track’s curves:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_59.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.59: Configuration to make the virtual camera follow the dolly track</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">Select <a id="_idIndexMarker1232"/>the <strong class="screenText">DollyCart1</strong> object and change the <strong class="screenText">Position</strong> value to see how the cart moves along the track. Do this while the game window is focused and <strong class="screenText">CM vcam2</strong> is in solo mode to see how the camera will look:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_60.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.60: The dolly cart component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="10">Re-enable <code class="inlineCode">CM vcam1</code>.</li>
    </ol>
    <p class="normal">With the dolly track properly set, we can create our cutscene using <strong class="keyWord">Timeline</strong> to sequence it.</p>
    <h1 id="_idParaDest-243" class="heading-1">Creating cutscenes with Timeline</h1>
    <p class="normal">We have our <a id="_idIndexMarker1233"/>intro camera, but that’s not enough to create a cutscene. A proper <a id="_idIndexMarker1234"/>cutscene is a sequence of actions happening at the exact moment that they should happen, coordinating several objects to act as intended. We can have actions such as enabling and disabling objects, switching cameras, playing sounds, moving objects, and so on. To do this, Unity offers <strong class="keyWord">Timeline</strong>, which is a sequencer of actions to coordinate those kinds of cutscenes. We will use <strong class="keyWord">Timeline</strong> to create an intro cutscene for our scene, showing the level before starting the game.</p>
    <p class="normal">In this section, we will examine the following Timeline concepts:</p>
    <ul>
      <li class="bulletList">Creating animation clips</li>
      <li class="bulletList">Sequencing our intro cutscene</li>
    </ul>
    <p class="normal">We are going to see how to create our own animation clips in Unity to animate our GameObjects and then place them inside a cutscene to coordinate their activation using the Timeline sequencer tool. Let’s start by creating a camera animation to use later in Timeline.</p>
    <h2 id="_idParaDest-244" class="heading-2">Creating animation clips</h2>
    <p class="normal">This is <a id="_idIndexMarker1235"/>actually not a Timeline-specific feature but rather a Unity feature that works great with Timeline. When we downloaded the character, it came with animation clips that were created using external software, but you can create custom animation clips using Unity’s <strong class="keyWord">Animation</strong> window. Don’t <a id="_idIndexMarker1236"/>confuse it with the <strong class="keyWord">Animator</strong> window, which allows us to create animation transitions that react to the game situation. This is useful to create small object-specific animations that you will coordinate later in Timeline with other objects’ animations.</p>
    <p class="normal">These <a id="_idIndexMarker1237"/>animations can control any value of an object’s component properties, such as the positions, colors, and so on. In our case, we want to animate the dolly track’s <strong class="keyWord">Position</strong> property to make it go from start to finish in a given time. In order to do this, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the <code class="inlineCode">DollyCart1</code> object.</li>
      <li class="numberedList">Open the <strong class="screenText">Animation</strong> (not <strong class="screenText">Animator</strong>) window by going to <strong class="screenText">Window | Animation | Animation</strong>.</li>
      <li class="numberedList">Click on the <strong class="screenText">Create</strong> button at the center of the <strong class="screenText">Animation</strong> window. Remember to do this while the dolly cart (not track) is selected:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_61_PE.png" alt="A picture containing text, font, software, screenshot  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 17.61: Creating a custom animation clip</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">After doing this, you will be prompted to save the animation clip somewhere. I recommend you create an <code class="inlineCode">Animations</code> folder in the project (inside the <code class="inlineCode">Assets</code> folder) and call it <code class="inlineCode">IntroDollyTrack</code>.</li>
    </ol>
    <p class="normal">If you pay <a id="_idIndexMarker1238"/>attention, the dolly cart now has an <strong class="keyWord">Animator</strong> component with an Animator Controller created, which contains the animation we just created. As with any animation clip, you need to apply it to your object with an Animator Controller; custom animations are no exception. So, the <strong class="keyWord">Animation</strong> window created them for you.</p>
    <p class="normal">Animating in this window consists of specifying the value of its properties at given moments. In our case, we want <strong class="screenText">Position</strong> to have a value of <code class="inlineCode">0</code> at the beginning of the animation, at 0 seconds on the timeline, and have a value of <code class="inlineCode">254</code> at the end of the animation, at 5 seconds. I chose <code class="inlineCode">254</code> because that’s the last possible position in my cart, but that depends on the length of your dolly track. Just test which is the last possible position in yours. Also, I chose <code class="inlineCode">5</code> seconds because that’s what I feel is the correct length for the animation, but feel free to change it as you wish. Now, whatever happens between the animation’s 0 and 5 seconds is an interpolation of the <code class="inlineCode">0</code> and <code class="inlineCode">254</code> values, meaning that in 2.5 seconds, the value of <code class="inlineCode">Position</code> will be <code class="inlineCode">127</code>. Animating always consists of interpolating different states of our object at different moments.</p>
    <p class="normal">In order to do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <strong class="screenText">Animation</strong> window, click on the record button (the red circle in the top-left section). This will make Unity detect any changes in our object and save them to the animation. Remember to do this while you have selected the dolly cart.</li>
      <li class="numberedList">Set the <strong class="screenText">Position</strong> setting of the dolly cart to <code class="inlineCode">1</code> and then <code class="inlineCode">0</code>. Changing this to any value and then to <code class="inlineCode">0</code> again will create a keyframe, which is a point in the animation that says that at <code class="inlineCode">0</code> seconds, we want the <strong class="screenText">Position</strong> value to be <code class="inlineCode">0</code>. We need to set it first to any other value if the value is already at <code class="inlineCode">0</code>.
    <p class="normal">You will notice that the <strong class="keyWord">Position</strong> property has been added to the animation:</p>
    <figure class="mediaobject"><img src="img/B21361_17_62_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.62: The animation in Record mode after changing the Position value to 0</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Using<a id="_idIndexMarker1239"/> the mouse scroll wheel, zoom out the timeline to the right of the <strong class="screenText">Animation</strong> window until you see <strong class="screenText">5:00</strong> seconds in the top bar:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_63_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.63: The timeline of the Animation window seeing 5 seconds</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Click on the <strong class="screenText">5:00</strong>-second label in the top bar of the timeline to position the playback header at that moment. This will locate the next change we make at that moment.</li>
      <li class="numberedList">Set the <strong class="screenText">Position</strong> value of the dolly track to the highest value you can get; in my case, this is <code class="inlineCode">240</code>. Remember to have the <strong class="screenText">Animation</strong> window in <strong class="screenText">Record</strong> mode:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_64_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.64: Creating a keyframe with the 240 value 5 seconds into the animation</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Hit the play button in the top-left section of the <strong class="screenText">Animation</strong> window to see the animation playing. Remember to view it in the <strong class="screenText">Game</strong> view while <code class="inlineCode">CM vcam1</code> is disabled.</li>
    </ol>
    <div><p class="normal">Sometimes, you will need to synchronize gameplay code with animations. One classic example is an attack animation, where you want the player to damage the attacked object when the sword hits the ground instead of as soon as the animation starts. To do this, you can use animation events: <a href="https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html">https://docs.unity3d.com/Manual/script-AnimationWindowEvent.html</a>. You can also add animation events to imported animations: <a href="https://docs.unity3d.com/Manual/class-AnimationClip.html">https://docs.unity3d.com/Manual/class-AnimationClip.html</a>.</p>
    </div>
    <p class="normal">Now, if we <a id="_idIndexMarker1240"/>hit <strong class="keyWord">Play</strong>, the animation will start playing, but that’s something we don’t want. In this scenario, the idea is to give control of the cutscene to the cutscene system, Timeline, because this animation won’t be the only thing that needs to be sequenced in our cutscene. One way to prevent the <strong class="keyWord">Animator</strong> component from automatically playing the animation we created is to create an empty animation state in the Controller and set it as the default state by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Search the Animator Controller that we created at the same time as the animation and open it. If you can’t find it, just select the dolly cart and double-click on the <strong class="screenText">Controller</strong> property of the <strong class="screenText">Animator</strong> component on our GameObject to open the asset.</li>
      <li class="numberedList">Right-click on an empty state in the Controller and select <strong class="screenText">Create State</strong> |<strong class="screenText"> Empty</strong>. This will create a new state in the state machine as if we created a new animation, but it is empty this time:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_65_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.65: Creating an empty state in the Animator Controller</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Right-click on <strong class="screenText">New State</strong> and click on <strong class="screenText">Set as Layer Default State</strong>. The state should become orange:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_66_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.66: Changing the default animation of the Controller to an empty state</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Now, if you hit <strong class="screenText">Play</strong>, no animation will play as the default state of our dolly cart is empty. No transition<a id="_idIndexMarker1241"/> will be required in this case.</li>
    </ol>
    <p class="normal">Now that we have created our camera animation, let’s start creating a cutscene that switches from the intro cutscene camera to the player camera by using Timeline.</p>
    <h2 id="_idParaDest-245" class="heading-2">Sequencing our intro cutscene</h2>
    <p class="normal">Timeline is<a id="_idIndexMarker1242"/> already installed in your project, but if you go to the Package Manager of Timeline, you may see an <strong class="keyWord">Update</strong> button to get the latest version if you need some of the new features. In our case, we will keep the default version included in our project (1.5.2, at the time of writing this book).</p>
    <p class="normal">The first<a id="_idIndexMarker1243"/> thing we will do is create a cutscene asset and an object in the scene responsible for playing it. To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create an empty GameObject using the <strong class="screenText">GameObject</strong> | <strong class="screenText">Create Empty</strong> option.</li>
      <li class="numberedList">Select the empty object and call it <code class="inlineCode">Director</code>.</li>
      <li class="numberedList">Go to <strong class="screenText">Window</strong> | <strong class="screenText">Sequencing</strong> | <strong class="screenText">Timeline</strong> to open the Timeline editor.</li>
      <li class="numberedList">Click the <strong class="screenText">Create</strong> button in the middle of the <strong class="screenText">Timeline</strong> window while the <strong class="screenText">Director</strong> object is selected to convert that object into the cutscene player (or director).</li>
      <li class="numberedList">After doing this, a window will pop up asking you to save a file. This file will be the cutscene or timeline; each cutscene will be saved in its own file. Save it in a <code class="inlineCode">Cutscenes</code> folder in your project (the <code class="inlineCode">Assets</code> folder).</li>
      <li class="numberedList">Now, you can see that the Director object has a <strong class="screenText">Playable Director</strong> component with the <strong class="screenText">Intro</strong> cutscene asset saved in the previous step set for the <strong class="screenText">Playable</strong> property, meaning this cutscene will be played by the Director:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_67.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.67: Playable Director prepared to play the Intro Timeline asset</p>
    <p class="normal">Now that we have the Timeline asset ready to work with, let’s make it sequence actions. To start, we need to sequence two things—first, the cart position animation we did in the last step and then the camera swap between the dolly track camera (<code class="inlineCode">CM vcam2</code>) and the player cameras (<code class="inlineCode">CM vcam1</code>). As we said before, a cutscene is a sequence of actions executing at given moments, and in order to schedule actions, you will need tracks. In Timeline, we have different kinds of tracks, each one allowing you to execute certain actions on certain objects. We will start with the animation track.</p>
    <p class="normal">The animation track will control which animation a specific object will play; we need one track per object to animate. In our case, we want the dolly track to play the <strong class="keyWord">Intro</strong> animation that we created, so let’s do that by following these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add an Animation track by clicking <strong class="screenText">the plus button (+)</strong> and then <strong class="screenText">Animation Track</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_68_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.68: Creating an animation track</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Select<a id="_idIndexMarker1244"/> the <strong class="screenText">Director</strong> object and check the <strong class="screenText">Bindings</strong> list of the <strong class="screenText">Playable Director</strong> component in the <strong class="screenText">Inspector</strong> window.</li>
      <li class="numberedList">Drag the <strong class="screenText">Cart</strong> object to specify that we want the animation track to control its animation:
    <figure class="mediaobject"><img src="img/B21361_17_69_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.69: Making the animation track control the dolly cart animation in this Director</p>
    <p class="normal">Timeline is a generic asset that can be applied to any scene, but as the tracks control specific objects, you need to manually bind them in every scene. In our case, we have an animation track that expects to control a single animator, so in every scene, if we want to apply this cutscene, we need to drag the specific animator to control it in the <strong class="keyWord">Bindings</strong> list.</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Drag the <strong class="screenText">Intro</strong> animation asset that we created to the animation track in the <strong class="screenText">Timeline </strong>window. This will create a clip in the track showing when and for how long the animation will play. You can drag as many animations as possible that the cart can play into the track to sequence different animations at different moments, but right now, we want just that one:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_70_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.70: Making the animator track play the intro clip</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">You can drag the animation to change the exact moment you want it to play. Drag it to the beginning of the track.</li>
      <li class="numberedList">Hit the <strong class="screenText">Play</strong> button in the top-left part of the <strong class="screenText">Timeline</strong> window to see it in action. You can also manually drag the white arrow in the <strong class="screenText">Timeline</strong> window to view the cutscene at different moments. If that doesn’t work, try playing the game and then stopping:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_71_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.71: Playing a timeline and dragging the playback header</p>
    <p class="normal">Now, we will <a id="_idIndexMarker1245"/>make our <strong class="keyWord">Intro</strong> timeline asset tell the <code class="inlineCode">CinemachineBrain</code> component (the main camera) which camera will be active during each part of the cutscene, switching to the player camera once the camera animation is over. We will create a second track—a Cinemachine track—which specializes in making a specific <code class="inlineCode">CinemachineBrain</code> component to switch between different virtual cameras. To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Click the <strong class="screenText">+</strong> button again and click on <strong class="screenText">Cinemachine Track</strong>. Note that you can install Timeline without <strong class="screenText">Cinemachine</strong>, but this kind of track won’t appear in that case:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_72.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.72: Creating a new Cinemachine track</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">In the <strong class="screenText">Playable Director</strong> component’s <strong class="screenText">Bindings</strong> list, drag the main camera to <strong class="screenText">Cinemachine Track</strong> to make it track control which virtual camera will control the main camera at different moments of the cutscene:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_73_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.73: Binding the main camera to the Cinemachine track</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">The <a id="_idIndexMarker1246"/>next step indicates which virtual camera will be active during specific moments of the timeline. To do so, our Cinemachine track allows us to drag virtual cameras to it, which will create virtual camera clips. Drag both <strong class="screenText">CM vcam2</strong> and <strong class="screenText">CM vcam1</strong>, in that order, to the Cinemachine track:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_74_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.74: Dragging virtual cameras to the Cinemachine track</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">If you hit the <strong class="screenText">Play</strong> button or just drag the <strong class="screenText">Timeline Playback</strong> header, you can see how the active virtual camera changes when the playback header reaches the second virtual camera clip. Remember to view this in the <strong class="screenText">Game</strong> view.</li>
      <li class="numberedList">If you place the mouse near the ends of the clips, a resize cursor will appear. If you drag them, you can resize the clips to specify their duration. In our case, we will need to match the length of the <code class="inlineCode">CM vcam2</code> clip to the <strong class="screenText">Cart</strong> animation clip and then put <code class="inlineCode">CM vcam1</code> at the end of it by dragging it so that the camera will be active when the dolly cart animation ends. In my case, they were already the same length, but just try to change it anyway to practice. Also, you can make the <code class="inlineCode">CM vcam1</code> clip shorter; we just need to play it for a few moments to execute the camera swap.</li>
      <li class="numberedList">You can also overlap the clips a little bit to make a smooth transition between the two cameras, instead of a hard switch, which will look odd:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_17_75_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.75: Resizing and overlapping clips to interpolate them</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Increase the <strong class="screenText">Start Time</strong> property of the <strong class="screenText">WaveSpawners</strong> to prevent the enemies from being spawned before the cutscene begins.</li>
    </ol>
    <p class="normal">If you wait for the<a id="_idIndexMarker1247"/> full cutscene to end, you will notice how, at the very end, <code class="inlineCode">CM vcam2</code> becomes active again. You can configure how Timeline will deal with the end of the cutscene, as, by default, it does nothing. This can cause different behavior according to the type of track—in our case, again giving control to pick the virtual camera to the <code class="inlineCode">CinemachineBrain</code> component, which will pick the virtual camera with the highest <strong class="keyWord">Priority</strong> value. We can change the <strong class="keyWord">Priority</strong> property of the virtual cameras to be sure that <strong class="keyWord">CM vcam1</strong> (the player camera) is always the more important one or set the <strong class="screenText">Wrap Mode</strong> of the <strong class="screenText">Playable Director</strong> component to <strong class="screenText">Hold</strong>, which will keep everything as the last frame of the timeline specifies. In our case, we will use the latter option to test the Timeline-specific features:</p>
    <figure class="mediaobject"><img src="img/B21361_17_76.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 17.76: Wrap Mode set to Hold mode</p>
    <p class="normal">Most of the <a id="_idIndexMarker1248"/>different kinds of tracks work under the same logic; each one will control a specific aspect of a specific object using clips that will execute during a set time. I encourage you to test different tracks to see what they do, such as <strong class="keyWord">Activation</strong>, which enables and disables objects during the cutscene. Remember, you can check out the documentation of the Timeline package in the Package Manager.</p>
    <h1 id="_idParaDest-246" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we introduced the different animation systems that Unity provides for different requirements. We discussed importing character animations and controlling them with Animation Controllers. We also saw how to make cameras that can react to the game’s current situation, such as the player’s position, or that can be used during cutscenes. Finally, we looked at Timeline and the animation system to create an intro cutscene for our game. These tools are useful for making the animators in our team work directly in Unity without the hassle of integrating external assets (except for character animations) and also preventing the programmer from creating repetitive scripts to create animations, wasting time in the process.</p>
    <p class="normal">Now, you are able to import and create animation clips in Unity, as well as apply them to GameObjects to make them move according to the clips. Also, you can place them in the Timeline sequencer to coordinate them and create cutscenes for your game. Finally, you can create dynamic cameras to use in-game or in cutscenes.</p>
    <p class="normal">With this, we end <em class="chapterRef">Section 2</em>, <em class="italic">Mastering Programming and Gameplay Mechanics </em>where we learned about different Unity systems to improve several artistic aspects of our game. In the next chapter, the first chapter of <em class="chapterRef">Section 3</em>, <em class="italic">Elevating Visuals, Effects, and Audio </em>we will wrap up the development of our game and see how to build and optimize it, and we will also provide a quick intro to augmented reality applications.</p>
    <h1 id="_idParaDest-247" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>