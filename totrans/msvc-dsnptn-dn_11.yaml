- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Implementing the API and BFF Gateway Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API和BFF网关模式
- en: When building an application using the microservices architectural approach,
    we have come to realize that we will need to keep track of several API endpoints.
    We have effectively gone from one endpoint, which would have been made available
    through a monolith, to a series of endpoints. Some of these endpoints will be
    called by other APIs and some will integrate directly into the client applications
    that interact with the microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用微服务架构方法构建应用程序时，我们已经意识到我们需要跟踪多个API端点。我们实际上已经从通过单体提供的单个端点转变为一系列端点。其中一些端点将由其他API调用，而另一些则直接集成到与微服务交互的客户端应用程序中。
- en: This becomes a challenge because we end up conflating the client application
    with custom logic to cater to integrating with the various services and possibly
    orchestrating inter-service communications. We want to keep the client application
    code as simple and extensible as possible, but integrating with each service does
    not support that notion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这成为一个挑战，因为我们最终将客户端应用程序与用于集成各种服务的自定义逻辑混为一谈，并可能编排服务间的通信。我们希望将客户端应用程序代码保持尽可能简单和可扩展，但与每个服务的集成不支持这种观点。
- en: This is where we will consider implementing the API gateway pattern, which introduces
    a central point of contact between the client and the services. Our API gateway
    will keep a record of all the endpoints and expose a single API address where
    the endpoints will map to the various endpoints of the other microservices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将考虑实现API网关模式的地方，它引入了客户端和服务之间的一个中心接触点。我们的API网关将记录所有端点，并公开一个单一的API地址，其中端点将映射到其他微服务的各种端点。
- en: In this chapter, we will look at various scenarios that will make an API gateway
    a good selection for our application and methods of implementation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种场景，这些场景将使API网关成为我们应用的理想选择，以及实现方法。
- en: 'After reading this chapter, we will be able to do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们将能够做到以下几件事情：
- en: Understand API gateways and why they are important
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解API网关及其重要性
- en: Implement an API gateway using industry-leading technology and methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行业领先的技术和方法实现API网关
- en: Properly implement the **backend for frontend** (**BFF**) pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确实现**前端后端**（**BFF**）模式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code references used in this chapter can be found in this project’s repository,
    which is hosted on GitHub at [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码引用可以在本项目的GitHub仓库中找到，该仓库托管在[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch11)。
- en: What is the API gateway pattern?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API网关模式？
- en: To understand the API gateway pattern and why we need it, we need to review
    the fundamentals of the service-oriented architecture and how we architect such
    solutions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解API网关模式及其必要性，我们需要回顾面向服务的架构的基本原理以及我们如何构建此类解决方案。
- en: 'The service-oriented architecture includes three main layers to an application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 面向服务的架构包括应用的三层主要层：
- en: '**Client**: Also referred to as the fronted. This client app is what the user
    sees and is designed to consume its data from an API. Its functionality is generally
    limited to functions that the API makes available, and a frontend developer can
    leverage several techniques to expose functionality to the end user.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：也称为前端。这个客户端应用程序是用户看到的，它被设计为从API中获取数据。其功能通常限于API提供的功能，并且前端开发者可以利用多种技术向最终用户暴露功能。'
- en: '**Server**: Also referred to as the backend. This section of the architecture
    houses the API and the business logic. The client app is only as intelligent as
    the backend. The backend can be made up of one or more services, as would be the
    case with microservices.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：也称为后端。这个架构部分包含API和业务逻辑。客户端应用程序的智能程度取决于后端。后端可以由一个或多个服务组成，就像微服务的情况一样。'
- en: '**Database**: The database is the anchor of this entire application since it
    stores all the data being used by the API backend and is displayed on the frontend.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：数据库是整个应用程序的锚点，因为它存储了API后端使用的所有数据，并在前端显示。'
- en: This application layout is popular in monolithic applications, where all the
    functionality that is needed on the frontend can be found in one API. This is
    an effective development method that has been at the helm of many successful and
    powerful applications. We have, however, explored the downsides to a monolithic
    approach, where the API might become bloated and difficult to maintain in the
    long run. The main advantage that we would seem to forsake in the pursuit of a
    microservices approach would be where we have a single point of entry for the
    client application, as opposed to several services each with requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用程序布局在单体应用中很受欢迎，其中所有前端所需的功能都可以在一个API中找到。这是一种有效的开发方法，许多成功和强大的应用程序都以此为主导。然而，我们已经探讨了单体方法的缺点，API可能会变得臃肿，难以长期维护。在追求微服务方法的过程中，我们似乎放弃的主要优势是，我们有一个客户端应用的单一入口点，而不是每个服务都有自己的要求。
- en: While the microservices architecture leads us down the path of having an application
    that is implemented with the service-oriented architecture, we will need to account
    for the fact that our client will need to keep track of several backends or APIs
    and be intelligent enough to orchestrate calls for each user request. This is
    a lot of responsibility for the portion of the application that should be the
    least intelligent, based on the description provided.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务架构引领我们走向实现面向服务的架构的应用程序，但我们需要考虑到我们的客户端将需要跟踪多个后端或API，并且足够智能，能够为每个用户请求编排调用。根据所提供的描述，这是应用中应该最不智能的部分承担的大量责任。
- en: '*Figure 11.1* shows the client and microservices:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.1* 展示了客户端和微服务：'
- en: '![Figure 11.1 – The client app needs to be aware of all the endpoints of all
    the microservices and retain the knowledge of how each one works](img/Figure_11.1_B19100.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 客户端应用需要了解所有微服务的端点，并保留每个微服务如何工作的知识](img/Figure_11.1_B19100.jpg)'
- en: Figure 11.1 – The client app needs to be aware of all the endpoints of all the
    microservices and retain the knowledge of how each one works
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 客户端应用需要了解所有微服务的端点，并保留每个微服务如何工作的知识
- en: This is where we introduce an API gateway. This gateway will sit between our
    services and the client app and simplify the communication between the two. For
    the client, it will expose a singular base URL, which the client will gladly interact
    with and see as one API service; to the microservices, it will act as a conduit,
    where it will forward requests coming in from the client to the appropriate microservice.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，我们引入了API网关。这个网关将位于我们的服务和客户端应用之间，简化两者之间的通信。对于客户端，它将暴露一个单一的基URL，客户端将乐意与之交互，并视为一个API服务；对于微服务，它将充当一个通道，将来自客户端的请求转发到适当的微服务。
- en: Let us review the advantages of introducing an API gateway.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下引入API网关的优势。
- en: Advantages of an API gateway
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关的优势
- en: When a request comes in from a client, it is received by the gateway, which
    interprets the request, transforms the data if necessary, and then forwards it
    to the appropriate microservice. In fact, for situations where multiple microservices
    may need to be called, we can implement orchestration and result aggregation and
    return more accurate representations of the data to the client as needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端的请求到来时，它被网关接收，网关解释请求，如果需要，转换数据，然后将它转发到适当的微服务。实际上，对于可能需要调用多个微服务的情况，我们可以实现编排和结果聚合，并根据需要向客户端返回更准确的数据表示。
- en: 'Our API gateway also allows us to centralize the following tasks for our microservices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API网关还允许我们为我们的微服务集中以下任务：
- en: '**Centralized Logging**: From the API gateway, we can centrally log all the
    traffic to our various endpoints and keep track of the success and error responses
    from the downstream services. This is advantageous because it spares us the need
    to implement logging in each service and potentially have a very chatty log. Using
    an API gateway allows us to centralize our implementation and prioritize what
    gets written to the log and can help us to better catalog the outcomes of synchronous
    operations. We can also use the gateway to track and log statistics and response
    times of calls to the downstream services.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中式日志记录**：从API网关，我们可以集中记录所有流量到我们的各种端点，并跟踪下游服务的成功和错误响应。这很有优势，因为它免除了我们在每个服务中实现日志记录的需要，并可能产生非常冗长的日志。使用API网关允许我们集中实施，并优先考虑写入日志的内容，这有助于我们更好地分类同步操作的结果。我们还可以使用网关来跟踪和记录对下游服务调用的统计信息和响应时间。'
- en: '**Caching**: Caching acts as a temporary data store that comes in handy when
    the main data source might be offline or when we need to reduce the number of
    times the services are called. We can use a caching layer in the gateway to stabilize
    our application and potentially increase the application’s performance. With proper
    coordination and customization, we can use this caching for high-speed read operations
    on endpoints that have high volumes of traffic and even use it to handle partial
    failure, where we use the cached data for a response when a service is unavailable.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：缓存作为一种临时数据存储，在主数据源可能离线或我们需要减少对服务调用次数时非常有用。我们可以在网关中使用缓存层来稳定我们的应用程序，并可能提高应用程序的性能。通过适当的协调和定制，我们可以使用此缓存进行端点的高速读取操作，这些端点流量很大，甚至可以使用它来处理部分失败，即当服务不可用时，我们使用缓存数据作为响应。'
- en: '**Security**: Securing microservices can be a tedious and technical task. Each
    service might have unique security requirements and may lead to development overhead
    when coordinating security measures and implementations. Using an API gateway,
    we can centralize security measures at the gateway level. This can remove the
    burden from the microservice to authenticate and authorize access to resources
    since the gateway will manage most of those requirements. We can also implement
    IP whitelisting at this level and limit access to an approved list of IP addresses.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：保护微服务可能是一项繁琐且技术性强的任务。每个服务可能都有独特的安全需求，这可能导致在协调安全措施和实施时产生开发开销。使用API网关，我们可以在网关级别集中安全措施。这可以减轻微服务在验证和授权对资源访问时的负担，因为网关将管理大多数这些需求。我们还可以在此级别实施IP白名单，并限制对批准的IP地址列表的访问。'
- en: '**Service Monitoring**: We can configure our API gateway to conduct health
    probes on the downstream services. As previously discussed, health checks or probes
    help us to ascertain the status of our services. Since the gateway will need to
    forward requests, it is important to be able to determine the health of a downstream
    service before attempting an operation. Since the gateway can determine the health
    of a service, it can be configured to gracefully handle failures and partial failures.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务监控**：我们可以配置我们的API网关对下游服务进行健康检查。如前所述，健康检查或探测有助于我们确定服务状态。由于网关需要转发请求，在尝试操作之前确定下游服务的健康状况非常重要。由于网关可以确定服务的健康状况，它可以配置为优雅地处理失败和部分失败。'
- en: '**Service Discovery**: Our gateway needs to know the addresses of all services
    and how to transform and forward requests as needed. For this, the gateway needs
    a register of all the downstream services. The gateway will simply act as a wrapper
    around the services endpoints and expose a singular address to the client application.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：我们的网关需要知道所有服务的地址以及如何根据需要转换和转发请求。为此，网关需要一个所有下游服务的注册表。网关将简单地作为服务端点的包装器，并向客户端应用暴露一个单一地址。'
- en: '**Rate Limiting**: Sometimes, we want to limit the number of requests that
    can be sent in quick succession, from the same source, on the suspicion that such
    activity might be a **distributed denial-of-service** (**DDoS**) attack on a service
    endpoint. Using the API gateway, we can implement generic rules that govern how
    often endpoints can be accessed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率限制**：有时，我们希望限制来自同一来源的快速连续请求的数量，怀疑这种活动可能是对服务端点的**分布式拒绝服务**（DDoS）攻击。使用API网关，我们可以实施通用规则，以控制端点可以访问的频率。'
- en: Once again, the most important aspect of the gateway’s implementation is that
    it takes much of the responsibility away from our client, making scaling and diversifying
    client code much easier.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，网关实现最重要的方面是它从我们的客户端承担了大部分责任，这使得扩展和多样化客户端代码变得更加容易。
- en: '*Figure 11.2* shows the client, a gateway, and microservices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.2* 展示了客户端、网关和微服务：'
- en: '![Figure 11.2 – With the gateway introduced, the client app now has one endpoint
    and doesn’t need to know about the underlying services](img/Figure_11.2_B19100.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 引入网关后，客户端应用现在有一个端点，不需要了解底层服务](img/Figure_11.2_B19100.jpg)'
- en: Figure 11.2 – With the gateway introduced, the client app now has one endpoint
    and doesn’t need to know about the underlying services
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 引入网关后，客户端应用现在有一个端点，不需要了解底层服务
- en: Now that we have seen where the API gateway helps us to centralize access to
    several API endpoints and make it easier for the client application to integrate
    API operations, let us review some of the disadvantages of using this pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到API网关如何帮助我们集中访问多个API端点，并使客户端应用更容易集成API操作，让我们回顾一下使用这种模式的一些缺点。
- en: Disadvantages of an API gateway
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关的缺点
- en: While the advantages are clear and irrefutable, we must also be aware of the
    downsides of introducing an API gateway. An API gateway may come in the form of
    another microservice and ironically so. The remedy for dealing with too many services
    is to build one to rule them all. This then introduces a single point of failure
    since when this is offline, our client app will have no way to send requests to
    the various services. Now, additional maintenance is required as our gateway service
    needs to morph alongside each service it interacts with to ensure the requests
    and responses are accurately interpreted. We also run the risk of increasing the
    roundtrip time for requests, since this new layer will need to be performant enough
    to receive the original request, forward it, and then retrieve and forward the
    response from the microservice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然优势明显且无可辩驳，但我们还必须意识到引入API网关的弊端。API网关可能以另一个微服务的形式出现，具有讽刺意味的是。处理过多服务的补救措施是构建一个来统治它们。这样，就引入了一个单点故障，因为当这个网关服务离线时，我们的客户端应用将无法向各种服务发送请求。现在，还需要额外的维护，因为我们的网关服务需要随着它所交互的每个服务的变化而变化，以确保请求和响应被准确解释。我们还面临增加请求往返时间的风险，因为这一新层需要足够高效，以接收原始请求，将其转发，然后从微服务检索并转发响应。
- en: While we have obvious advantages that we can reference, we need to ensure that
    we know, accept, and mitigate the risks involved with implementing a gateway service
    for our microservices application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有明显的优势可以参考，但我们需要确保我们知道、接受并减轻为我们的微服务应用程序实现网关服务所涉及的风险。
- en: As we have seen, there are several cross-cutting and generic concerns that all
    APIs share. Implementing these generic requirements in each service can lead to
    bloat and attempting to build a singular service to implement them can lead to
    a monolithic application being created. It is easier to use a third-party application
    that is fortified with the main features that we require of an API gateway.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，所有API都存在一些跨领域和通用问题。在每个服务中实现这些通用需求可能导致冗余，而试图构建一个单一的服务来实现它们可能会导致单体应用程序的创建。使用一个加强了我们所需API网关主要功能的第三方应用程序更容易。
- en: Now, let us review the ways an API gateway could be implemented.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下API网关可能实现的方式。
- en: Implementing the API gateway pattern
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API网关模式
- en: Certain guidelines should be followed when implementing an API gateway. Given
    its description, we might be inclined to develop a new microservice, label it
    the gateway, and develop and maintain the API integrations ourselves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现API网关时，应遵循某些指南。鉴于其描述，我们可能会倾向于开发一个新的微服务，将其标记为网关，并自行开发和维护API集成。
- en: Surely, this is a viable approach, and it does give you full control over the
    implementation, rules, and features that you deem necessary for your application
    and downstream services. We can also implement specific business logic to govern
    certain operations by orchestrating requests and responses to the downstream services
    and aggregating and transforming data accordingly. However, this can lead to having
    a *thick API gateway*. We will discuss this further in the next section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个可行的方案，并且它确实给了你对实现、规则和特性的完全控制，这些是你认为对应用程序和下游服务必要的。我们还可以通过编排对下游服务的请求和响应以及相应地聚合和转换数据来实现特定的业务逻辑来管理某些操作。然而，这可能导致拥有一个*厚API网关*。我们将在下一节中进一步讨论这一点。
- en: Thick API gateways
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 厚API网关
- en: The expression *thick API gateway* is coined when we realize we are placing
    too much business operation logic into our API gateway. Our gateway should act
    more as an abstraction layer between the client and the microservices, not the
    main hub for business logic. We should avoid placing business logic in the gateway,
    which will increase the complexity of the implementation and increase the maintenance
    effort required for the gateway.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们意识到我们将过多的业务操作逻辑放入我们的API网关时，就创造了*厚API网关*这个表达。我们的网关应该更多地作为客户端和微服务之间的抽象层，而不是业务逻辑的主要中心。我们应该避免在网关中放置业务逻辑，这将增加实现复杂性，并增加网关的维护工作量。
- en: We can also call this an *overambitious gateway* and generally should try to
    avoid making the API gateway a central point for how our application behaves.
    We also risk implementing a monolith and ending up at square one with our microservices
    application. At the same time, we should not avoid such a gateway implementation
    entirely, since there are additional patterns that can be leveraged by having
    a gateway with some business logic.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以称这为*过于雄心勃勃的网关*，通常应尽量避免将API网关作为我们应用程序行为的核心点。我们还有可能实现一个单体架构，并最终在我们的微服务应用程序中回到起点。同时，我们也不应完全避免这种网关实现，因为通过拥有带有一些业务逻辑的网关，我们可以利用一些额外的模式。
- en: Earlier in this book, we reviewed the *Saga pattern* and, more specifically,
    the *orchestration pattern*. Recall that the orchestration pattern hinges on the
    presence of a central service that has oversight of the downstream services, monitors
    the service responses, and decides to continue or terminate the saga accordingly.
    In this situation, a *thick API gateway* would be an asset in implementing this
    kind of behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分，我们回顾了*Saga模式*和更具体的*编排模式*。回想一下，编排模式依赖于一个中央服务，该服务对下游服务有监督权，监控服务响应，并相应地决定继续或终止saga。在这种情况下，一个*厚API网关*将有助于实现这种行为。
- en: Ultimately, we all have different needs in our applications, and these are,
    once again, guidelines that we should abide by in doing our implementations. We
    should always make the best decision for our application based on our needs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们都在我们的应用程序中有不同的需求，这些是，再次强调，我们在实施时应该遵守的指南。我们应该始终根据我们的需求为我们的应用程序做出最佳决策。
- en: In a situation where all these factors might not be applicable and we need to
    minimize the amount of business logic that the gateway implements, we may look
    to existing tools and services that can help us to accomplish these with much
    less maintenance and development effort. At this point, we can begin thinking
    about *Amazon API Gateway*, *Microsoft Azure API Management,* and open source
    solutions such as *Ocelot*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些因素可能不适用的情况下，我们需要最小化网关实现中的业务逻辑量，我们可能需要考虑现有的工具和服务，这些工具和服务可以帮助我们以更少的维护和开发工作量完成这些任务。在这个时候，我们可以开始考虑*Amazon
    API Gateway*、*Microsoft Azure API Management*和像*Ocelot*这样的开源解决方案。
- en: In the next section, we will review implementing API gateway functionality using
    *Microsoft Azure API Management*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾使用*Microsoft Azure API Management*实现API网关功能。
- en: Implementing an API gateway using Azure API Management
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Azure API Management实现API网关
- en: Microsoft Azure API Management is a cloud-based solution that can be found in
    the Microsoft Azure suite of development tools. It is designed to abstract, protect,
    accelerate, and observe backend APIs. While doing this, it securely exposes APIs
    through service discovery, to internal and external clients, inside and outside
    of the Azure ecosystem.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure API Management是一个基于云的解决方案，可在Microsoft Azure开发工具套件中找到。它旨在抽象化、保护、加速和观察后端API。在执行此操作时，它通过服务发现安全地暴露API，供内部和外部客户端使用，无论是在Azure生态系统内还是外部。
- en: 'It serves several purposes, including the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下多个用途：
- en: '**API Gateway**: Allows controlled access to backend services and allows us
    to enforce throttling and access control policies. The gateway acts as a façade
    to the backend services, allowing API providers to reduce the attrition involved
    in making changes to the ever-evolving suite of services in the backend. The gateway
    provides consistent and powerful configuration options for security, throttling,
    monitoring, and even caching.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 网关**：允许对后端服务的受控访问，并允许我们实施节流和访问控制策略。网关作为后端服务的门面，允许 API 提供者减少对后端不断发展的服务套件进行更改所涉及的成本。网关提供了用于安全、节流、监控甚至缓存的持续和强大的配置选项。'
- en: While this is a cloud-based service, the API gateway can also be deployed in
    a local environment for customers who wish to self-host their APIs for performance
    and compliance reasons. This *self-hosted gateway* is packaged as a Docker container
    and is commonly deployed to Kubernetes.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这是一个基于云的服务，但 API 网关也可以部署在本地环境中，以满足希望自行托管其 API 以提高性能和合规性的客户。这个 *自托管网关* 被打包成一个
    Docker 容器，通常部署到 Kubernetes。
- en: '**Developer Portal**: An automatically generated and fully customizable website.
    Third-party developers can use the developer portal to review API documentation
    and learn how to integrate it into their applications.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者门户**：一个自动生成且完全可定制的网站。第三方开发者可以使用开发者门户来审查 API 文档并了解如何将其集成到他们的应用程序中。'
- en: '**Management Plane**: This section of Azure API Management allows us to provision
    and configure the service’s settings. We can define API schemas from several sources
    and configure support for different protocols and standards such as *OpenAPI specifications*,
    *WebSockets*, or *GraphQL*.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理平面**：Azure API Management 的这部分允许我们配置服务的设置。我们可以从多个来源定义 API 架构，并配置对不同的协议和标准（如
    *OpenAPI 规范*、*WebSockets* 或 *GraphQL*）的支持。'
- en: Now, let us explore some of the steps required to set up our first Azure API
    Management service. For these exercises, you will need an *Azure subscription*
    and if you don’t already have one, you may create a free *Microsoft Azure account*
    before you begin.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索设置第一个 Azure API 管理服务所需的一些步骤。为此练习，您需要一个 *Azure 订阅*，如果您还没有，您可以在开始之前创建一个免费的
    *Microsoft Azure 账户*。
- en: Our first action is to sign in to the Azure portal. You can then use the search
    feature and type in *API Management services* and select the matching option in
    the search results. The resulting page will list all the instances of the *API
    Management services* that you currently have. For this exercise, you may proceed
    by clicking **Create**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是登录到 Azure 门户。然后您可以使用搜索功能，输入 *API 管理服务* 并在搜索结果中选择匹配的选项。结果页面将列出您目前拥有的所有
    *API 管理服务* 实例。为此练习，您可以点击 **创建**。
- en: '*Figure 11.3* shows the Azure API Management services search results:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.3* 显示了 Azure API Management 服务的搜索结果：'
- en: '![Figure 11.3 – Proceed to create a new API Management service for this exercise](img/Figure_11.3_B19100.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 为此练习创建一个新的 API 管理服务](img/Figure_11.3_B19100.jpg)'
- en: Figure 11.3 – Proceed to create a new API Management service for this exercise
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 为此练习创建一个新的 API 管理服务
- en: 'On the next screen, we can proceed to fill in the details of our service and
    select the following options:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕上，我们可以继续填写服务的详细信息并选择以下选项：
- en: '**Subscription**: The subscription this new service will be provisioned under.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅**：此新服务将配置的订阅。'
- en: '**Resource group**: The logical group of resources associated with the service
    being provisioned. A new one can be created for this exercise.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源组**：与正在配置的服务关联的资源逻辑组。为此练习可以创建一个新的资源组。'
- en: '**Region**: The best geographical representation of where the bulk of the users
    of the services will be located.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：这是服务大部分用户将位于的最佳地理表示。'
- en: '**Resource name**: A unique name for the instance that you will be provisioning.
    You will need to modify the name displayed in *Figure 11.4* to proceed.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源名称**：您将要配置的实例的唯一名称。您需要修改 *图 11.4* 中显示的名称才能继续。'
- en: '**Organization name**: The name of your organization. This will be the name
    associated with ownership of the API service.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织名称**：您的组织名称。这将与 API 服务的所有权相关联。'
- en: '**Administrator email address**: The email address to be used for all communication
    and notifications from API Management.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员电子邮件地址**：用于所有来自 API 管理的通信和通知的电子邮件地址。'
- en: '**Pricing tier**: This determines the level of service uptime that we prefer.
    For this instance, we will use the *Developer* tier, which isn’t for production
    use.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定价层**：这决定了我们偏好的服务正常运行水平。对于此实例，我们将使用 *开发者* 层，它不适用于生产使用。'
- en: '*Figure 11.4* shows the various Azure API Management options:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.4* 展示了各种 Azure API 管理选项：'
- en: '![Figure 11.4 – Minimum values needed to create the API Management service](img/Figure_11.4_B19100.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 创建 API 管理服务所需的最低值](img/Figure_11.4_B19100.jpg)'
- en: Figure 11.4 – Minimum values needed to create the API Management service
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 创建 API 管理服务所需的最低值
- en: After creating the API Management service, we can begin importing our microservices
    into the management portal. Now, our API Management service will act as a façade
    in front of our services, allowing us to control access and transform data as
    needed. We can import APIs from any source if their API is discoverable across
    the internet or network.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 API 管理服务后，我们可以开始将我们的微服务导入管理门户。现在，我们的 API 管理服务将作为我们服务的前端，允许我们根据需要控制访问和转换数据。如果它们的
    API 可以在整个互联网或网络上被发现，我们可以从任何来源导入 API。
- en: The API Management service will handle all communications between a client and
    the target service that maps to the requested endpoint, regardless of the technology
    used to implement the API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: API 管理服务将处理客户端与映射到请求端点的目标服务之间的所有通信，无论实现 API 所使用的技术。
- en: '*Figure 11.5* shows the APIs added to the Azure API Management service:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.5* 展示了添加到 Azure API 管理服务的 API：'
- en: '![Figure 11.5 – The API Management service allows you to add APIs and map custom
    routes, that when called, will reroute the request to the mapped resource](img/Figure_11.5_B19100.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – API 管理服务允许您添加 API 并映射自定义路由，当调用时，将请求重定向到映射的资源](img/Figure_11.5_B19100.jpg)'
- en: Figure 11.5 – The API Management service allows you to add APIs and map custom
    routes, that when called, will reroute the request to the mapped resource
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – API 管理服务允许您添加 API 并映射自定义路由，当调用时，将请求重定向到映射的资源
- en: In *Figure 11.5*, we can see where we have mapped our appointments and customer
    APIs to the API Management service and have defined a base URL based on the primary
    endpoint now available through the service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.5* 中，我们可以看到我们已经将我们的预约和客户 API 映射到 API 管理服务，并基于现在通过服务提供的首选端点定义了一个基本 URL。
- en: In *Figure 11.6*, we can see where we can manage the request types that are
    allowed, as well as define our policies and transformations for each request type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.6* 中，我们可以看到我们可以管理允许的请求类型，以及为每种请求类型定义我们的策略和转换。
- en: '*Figure 11.6* also shows the various request processing options in the Azure
    API Management service:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.6* 还显示了 Azure API 管理服务中的各种请求处理选项：'
- en: '![Figure 11.6 – The API Management service allows you to easily manage the
    request types that are allowed for each API and define transformation policies
    for requests and responses](img/Figure_11.6_B19100.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – API 管理服务允许您轻松管理每个 API 允许的请求类型，并为请求和响应定义转换策略](img/Figure_11.6_B19100.jpg)'
- en: Figure 11.6 – The API Management service allows you to easily manage the request
    types that are allowed for each API and define transformation policies for requests
    and responses
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – API 管理服务允许您轻松管理每个 API 允许的请求类型，并为请求和响应定义转换策略
- en: Using Azure API Management, we gain many standard API gateway features out of
    the box and the further benefit of availability and service uptime guarantees
    when we have production-grade pricing tiers. If we choose not to self-host this
    application, we can take advantage of its **Software-as-a-Service** (**SaaS**)
    model, where we have a greatly reduced responsibility to do any infrastructure
    work related to getting it up and running.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure API Management，我们能够获得许多标准 API 网关功能，并且当我们有生产级定价层时，我们还获得了可用性和服务正常运行时间的保证。如果我们选择不自行托管此应用程序，我们可以利用其
    **软件即服务** (**SaaS**) 模型，其中我们大大减少了与使其上线和运行相关的任何基础设施工作的责任。
- en: We may end up in a situation where we need to self-host our gateway and API
    Management is not an option. In this situation, we can look to provide our own
    API gateway application. A great candidate for this implementation is *Ocelot*,
    which is a lightweight API gateway package that can be installed directly into
    a standard ASP.NET Core project. We will discuss this further in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到需要自行托管我们的网关，并且 API 管理不是可选方案的情况。在这种情况下，我们可以考虑提供自己的 API 网关应用程序。对于这种实现，一个很好的候选者是
    *Ocelot*，这是一个轻量级的 API 网关包，可以直接安装到标准的 ASP.NET Core 项目中。我们将在下一节中进一步讨论这一点。
- en: Implementing an API gateway using Ocelot
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ocelot 实现 API 网关
- en: Ocelot is an open source API gateway developed on the .NET Core platform. It
    is a simple implementation of a gateway that unifies the communication to microservices
    through abstraction, as we have come to expect from a gateway. The Ocelot API
    gateway transforms incoming HTTP requests and forwards them to the appropriate
    microservice address based on preset configurations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Ocelot 是一个基于 .NET Core 平台的开源 API 网关。它是一个简单的网关实现，通过抽象统一了对微服务的通信，正如我们期望从网关中得到的。Ocelot
    API 网关将转换传入的 HTTP 请求，并根据预设的配置将它们转发到适当的微服务地址。
- en: It is a popular and widely used API gateway technology and can easily be installed
    into a .NET Core application using the NuGet package manager. Its configurations
    can be outlined in JSON format; here, we define *upstream* and *downstream* routes.
    *Upstream* routes refer to the service address that is exposed to the client,
    while *downstream* routes are the real addresses of the mapped microservices.
    We can also define the allowed protocols for each upstream service route, allowing
    robust control over the kind of traffic that we are willing to accept on a route.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一种流行的广泛使用的 API 网关技术，并且可以很容易地使用 NuGet 包管理器安装到 .NET Core 应用程序中。其配置可以用 JSON 格式概述；在这里，我们定义
    *upstream* 和 *downstream* 路由。*upstream* 路由是指暴露给客户端的服务地址，而 *downstream* 路由是映射微服务的真实地址。我们还可以为每个上游服务路由定义允许的协议，从而允许对我们在路由上愿意接受的流量类型进行强大的控制。
- en: 'Let us set up an Ocelot API gateway application together. We will use a simple
    ASP.NET Web API project template and start by adding the `Ocelot` package via
    the NuGet package manager:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起设置一个 Ocelot API 网关应用程序。我们将使用一个简单的 ASP.NET Web API 项目模板，并首先通过 NuGet 包管理器添加
    `Ocelot` 包：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we have our package installed, we need to begin outlining our routing
    configurations. We can create a new configuration file and call it `ocelot.json`.
    In this JSON file, we will outline all *upstream* and *downstream* routes. This
    configuration will look something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了我们的包，我们需要开始概述我们的路由配置。我们可以创建一个新的配置文件，并将其命名为 `ocelot.json`。在这个 JSON 文件中，我们将概述所有
    *upstream* 和 *downstream* 路由。此配置将类似于以下内容：
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This configuration file is straightforward and once we pick up on the pattern,
    we can extend it as needed for the rest of our services. The sections are explained
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件很简单，一旦我们掌握了模式，我们就可以根据需要扩展它以用于我们其余的服务。各部分在此处解释：
- en: '**Routes**: This is the parent section of our JSON configuration, where we
    begin to define the upstream and downstream configurations.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Routes**: 这是我们的 JSON 配置的父级部分，我们在这里开始定义上游和下游配置。'
- en: '**DownstreamPathTemplate**: This section outlines the address at which the
    microservice can be found.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DownstreamPathTemplate**: 此部分概述了微服务可以找到的地址。'
- en: '**DownstreamScheme**: This outlines the protocols that we will use to communicate
    to the microservice being defined.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DownstreamScheme**: 这概述了我们将与定义的微服务进行通信的协议。'
- en: '**DownstreamHostAndPorts**: The host address and port are defined in this section.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DownstreamHostAndPorts**: 主机地址和端口在此部分定义。'
- en: '**UpstreamPathTemplate**: We outline the path that we expose to the client
    apps. By calling this defined route, Ocelot will automatically reroute the request
    to the service defined in the **DownstreamPathTemplate**. Notice that in the preceding
    example, we can rename the route if we need to. The **Customers** API endpoint
    originally found in the downstream API can only be reached via a **Patients**
    endpoint address.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UpstreamPathTemplate**: 我们概述了我们将暴露给客户端应用的路径。通过调用此定义的路由，Ocelot 将自动将请求重定向到在
    **DownstreamPathTemplate** 中定义的服务。注意，在前面的示例中，如果我们需要，我们可以重命名路由。下游 API 中原本的 **Customers**
    API 端点只能通过 **Patients** 端点地址访问。'
- en: '**UpstreamHttpMethod**: Here, we define the methods that we will accept as
    legitimate requests from a client.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UpstreamHttpMethod**: 在这里，我们定义我们将接受作为合法请求的方法。'
- en: '**GlobalConfiguration**: We outline the **BaseUrl** in the configuration, where
    all request traffic should be sent through.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局配置**：我们在配置中概述了 **BaseUrl**，所有请求流量都应该通过它发送。'
- en: 'Now, let us configure our application to use these configurations and use the
    Ocelot package. We will start by adding the following lines to the `Program.cs`
    file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置我们的应用程序以使用这些配置并使用 Ocelot 包。我们将从向 `Program.cs` 文件中添加以下行开始：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These lines add the `ocelot.json` file to our global configuration at application
    startup and then register Ocelot as a service. Then, we need to add the Ocelot
    middleware, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行在应用程序启动时将 `ocelot.json` 文件添加到全局配置中，然后注册 Ocelot 作为服务。然后，我们需要添加 Ocelot 中间件，如下所示：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With these few configurations, we can now use the gateway URL as the API URL
    in our client apps.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的配置，我们现在可以在客户端应用程序中使用网关 URL 作为 API URL。
- en: 'Ocelot is well-documented and extendable. It supports other features, such
    as the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ocelot 文档齐全且可扩展。它支持其他功能，例如以下内容：
- en: Built-in cache management
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置缓存管理
- en: A rate limiter
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制器
- en: Support for native .NET Core logging integrations
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持原生 .NET Core 日志集成
- en: Support for **JSON Web Token** (**JWT**) authentication
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 **JSON Web Token** (**JWT**) 认证
- en: Retry and circuit breaker policies (using *Polly*)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试和断路器策略（使用 *Polly*）
- en: Aggregating
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Pre- and post-downstream request transformations
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预下游和后下游请求转换
- en: Now that we have learned how to set up a simple gateway with Ocelot, let us
    look into extending this functionality. We will begin by adding cache management.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用 Ocelot 设置一个简单的网关，让我们来看看如何扩展这个功能。我们将从添加缓存管理开始。
- en: Adding cache management
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加缓存管理
- en: Caches act as temporary data stores in between requests to a more reliable data
    store. This means that a cache will temporarily store data based on the last set
    of data it was given. Good cache management would suggest that we flush our cache
    based on an interval and refresh it with a newer version of the data.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存作为请求到更可靠的数据存储之间的临时数据存储。这意味着缓存将根据它最后接收的数据集临时存储数据。良好的缓存管理建议我们根据间隔刷新缓存，并用数据的新版本刷新它。
- en: Caching comes in handy when we need to reduce the number of trips that are made
    to the main database, reducing latency and read/write costs that come with database
    calls. Ocelot has some support for caching, which is good for solving small caching
    concerns natively in the gateway application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要减少对主数据库的访问次数时，缓存非常有用，这可以减少数据库调用带来的延迟和读写成本。Ocelot 对缓存有一些支持，这对于在网关应用程序中本地解决小缓存问题很有帮助。
- en: 'This can be added with a fair amount of ease. We will begin by using NuGet
    Package Manager to execute the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过相当容易的方式添加。我们将从使用 NuGet 包管理器执行以下命令开始：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This package gives us the caching extensions that we need to then introduce
    an extension method in the `Program.cs` file. This extension method looks like
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包为我们提供了所需的缓存扩展，然后我们可以在 `Program.cs` 文件中引入一个扩展方法。这个扩展方法看起来像这样：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we add the following line to our `ocelot.json` configuration file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `ocelot.json` 配置文件中添加以下行：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have introduced a configuration to govern how caching should occur
    in our gateway, we must outline that values should be cached for a maximum of
    20 seconds. This will add native caching support for the downstream services that
    have been defined. Once that cache period has expired, requests will be forwarded
    as expected and then the new response values will be cached once again, for the
    defined period.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经引入了一个配置来管理我们的网关中缓存应该如何发生，我们必须概述值应该缓存最多 20 秒。这将为已定义的下游服务添加原生缓存支持。一旦缓存期过期，请求将按预期转发，然后新的响应值将再次缓存，为期定义的时间。
- en: Caching helps to reduce the amount of pressure that we place on a service, but
    it reasonably only imposes that limit for a short period. If we extend that period,
    then we run the risk of returning stale data for too long. Another layer of protection
    that we will want to implement is rate limiting. Let us explore this next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存有助于减轻我们对服务的压力，但它合理地只对短期施加限制。如果我们延长这个期限，那么我们就有可能返回过时的数据太长时间。我们还想实施另一层保护，那就是速率限制。让我们接下来探讨这个问题。
- en: Adding rate limiting
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加速率限制
- en: Rate limiting helps us to defend our application from the effects of DDoS attacks.
    Essentially, we impose rules on how frequently our service endpoints can be accessed
    by the same resource. When the request frequency violates our rules, we reject
    other incoming requests. This helps to prevent probable service performance degradation.
    Our service will not be attempting to fulfill all requests, especially those that
    may look like attacks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制帮助我们防御DDoS攻击的影响。本质上，我们规定了我们的服务端点可以被同一资源访问的频率。当请求频率违反我们的规则时，我们将拒绝其他传入的请求。这有助于防止可能的服务性能下降。我们的服务将不会尝试满足所有请求，尤其是那些可能看起来像攻击的请求。
- en: Rate limiting works by recording the IP address of the originating request.
    For all other requests from the same IP address, we evaluate if it is legal and
    within the set constraints that govern how often a request should come from the
    same sender. When a rule violation is detected, we send a failure response and
    do not forward the request in the service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制通过记录原始请求的IP地址来工作。对于来自同一IP地址的所有其他请求，我们评估它是否合法，并且是否在控制从同一发送者发出请求频率的约束范围内。当检测到违规规则时，我们发送失败响应，并且不在服务中转发请求。
- en: Ocelot allows us to configure rate limiting for the configured downstream services.
    This is good because it allows us to globally manage these rules and we do not
    need to implement these rules in each service.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Ocelot允许我们为配置的下游服务配置速率限制。这很好，因为它允许我们全局管理这些规则，我们不需要在每个服务中实现这些规则。
- en: 'First, let us modify our code to implement rate limiting for a particular downstream
    service. We can add the following code to the service’s configuration file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改我们的代码，以实现特定下游服务的速率限制。我们可以在服务的配置文件中添加以下代码：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have introduced a new section called `RateLimitingOptions` to the `ocelot.json`
    file. More specifically, we have added this new configuration to our patient’s
    downstream service configuration. This will now impose the following restrictions
    on how this downstream service can be accessed:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ocelot.json`文件中引入了一个新的部分，称为`RateLimitingOptions`。更具体地说，我们在患者的下游服务配置中添加了此新配置。现在，将对以下如何访问此下游服务施加以下限制：
- en: '**ClientWhiteList**: List of allowed clients that are not subjected to the
    rate limiting restrictions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClientWhiteList**: 允许不受速率限制限制的客户端列表。'
- en: '**EnableRateLimiting**: A flag that indicates whether the rate-limiting restrictions
    should be enforced or not.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EnableRateLimiting**: 一个标志，表示是否应该执行速率限制限制。'
- en: '**Period**: This value specifies the amount of time that we use to determine
    if a client is making a request that violates the limiting options. We can use
    the following:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Period**: 此值指定我们用来确定客户端是否正在发出违反限制选项的请求的时间量。我们可以使用以下：'
- en: s for seconds
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: s 表示秒
- en: m for minutes
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: m 表示分钟
- en: h for hours
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: h 表示小时
- en: d for days
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: d 表示天
- en: The pattern is fairly easy to follow. In our example, we have a 5-second limit
    on requests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模式相当容易遵循。在我们的例子中，我们对请求有一个5秒的限制。
- en: '**PeriodTimeSpan**: This is like a cooldown period. For this period, subsequent
    requests from the client that violated the limiting restrictions will be rejected
    and the clock will restart. Once this period has elapsed, the client can continue
    making requests.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PeriodTimeSpan**: 这是一个冷却期。在此期间，违反限制限制的客户端后续请求将被拒绝，时钟将重置。一旦这个周期过去，客户端可以继续发出请求。'
- en: '**Limit**: The number of requests that a client is allowed to make during the
    period. Here, we are defining that only one request should come in from the client
    every 5 seconds.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Limit**: 客户端在指定时间段内允许发出的请求数量。在此，我们定义每5秒只能从客户端接收一个请求。'
- en: 'Then, we can define global values that govern how the gateway will handle rate
    limiting. We can add a similar `RateLimitingOptions` section to our `GlobalConfiguration`
    section:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义全局值，以控制网关如何处理速率限制。我们可以在`GlobalConfiguration`部分添加一个类似的`RateLimitingOptions`部分：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we have some new options, which are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一些新的选项，如下所示：
- en: '**DisableRateLimitHeaders**: A flag that determines whether we disable or enable
    rate-limiting headers. These header values are generally as follows:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DisableRateLimitHeaders**: 一个标志，用于确定我们是否禁用或启用速率限制头。这些头值通常如下：'
- en: '**X-Rate-Limit**: Maximum number of requests available within the timespan'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X-Rate-Limit**: 在指定时间段内可用的最大请求数量'
- en: '**Retry-After**: Indicates how long the client should wait before making a
    follow-up request'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Retry-After**: 指示客户端在发出后续请求之前应等待多长时间'
- en: '**QuotaExceededMessage**: Allows us to define a custom message to send to the
    client that has violated the limiting rules.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QuotaExceededMessage**：允许我们定义一个自定义消息发送给违反限制规则的客户端。'
- en: '**HttpStatusCode**: This outlines the response code to be sent when the rules
    are violated. 429TooManyRequests is the standard response for this situation.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HttpStatusCode**：这概述了违反规则时要发送的响应代码。429TooManyRequests 是这种情况的标准响应。'
- en: '**ClientIdHeader**: Specifies the header that should be used to identify the
    client making the request.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClientIdHeader**：指定用于识别发起请求的客户端的头部。'
- en: With these minor changes, we have enforced rate limiting on all requests coming
    into the `/patients` endpoint. We will respond with a **429TooManyRequests** HTTP
    response if two or more requests come in within 5 seconds, from the same client
    address.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小的改动，我们已经对所有进入 `/patients` 端点的请求实施了速率限制。如果两个或更多请求在 5 秒内从同一客户端地址进入，我们将以 **429TooManyRequests**
    HTTP 响应进行响应。
- en: Another consideration we might have when using Ocelot is to aggregate our responses.
    This allows us to string multiple calls along and reduce the client’s need to
    orchestrate these calls. We’ll learn how to add this next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Ocelot 时，我们可能还会考虑聚合我们的响应。这允许我们将多个调用串联起来，并减少客户端编排这些调用的需求。我们将学习如何添加这个功能。
- en: Adding response aggregation
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加响应聚合
- en: Response aggregation is a method used for merging responses from multiple downstream
    services and sending one response accordingly. Essentially, an API gateway can
    achieve this by accepting a single request from a client and then making distributed
    parallel requests to several downstream services. Once all the responses are in
    from the downstream services, it will merge the data into a single object and
    return it to the client.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 响应聚合是一种用于合并多个下游服务的响应并相应发送单个响应的方法。本质上，API 网关可以通过接受来自客户端的单个请求，然后向多个下游服务发出分布式并行请求来实现这一点。一旦从下游服务收到所有响应，它将合并数据成一个单一的对象并返回给客户端。
- en: Several benefits come with this approach. The most prevalent one is that we
    can reduce the number of requests that the client needs to make to get data from
    several services. The API gateway will handle that orchestration automatically.
    The client also only needs to know one schema. So, several potentially complex
    requests can be merged into a single request body, which will reduce the number
    of schemas that the client needs to track. This approach will also speed up the
    response times involved with calling several services. Since the calls will be
    made in parallel, we do not have to wait the entire period that would be required
    when making service calls one after the other.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了几个好处。最显著的好处是我们可以减少客户端需要向多个服务请求数据的请求数量。API 网关将自动处理编排。客户端也只需要知道一个模式。因此，几个可能复杂的请求可以合并成一个请求体，这将减少客户端需要跟踪的模式数量。这种方法还将加快涉及调用多个服务的响应时间。由于调用将并行进行，我们不必等待依次进行服务调用所需的全段时间。
- en: 'Ocelot allows us to configure aggregate calls with a fair amount of ease. We
    will decorate our downstream service configurations with keys that act as a point
    of reference for our aggregate configuration. If we want to aggregate a call that
    should return a patient and all the appointments that they have made, we would
    need to make the following modifications:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ocelot 允许我们以相当容易的方式配置聚合调用。我们将用键装饰我们的下游服务配置，这些键将作为我们聚合配置的参考点。如果我们想要聚合一个应该返回患者及其所有预约的调用，我们需要进行以下修改：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start by adding a new key to the `api/patients/{id}` downstream service
    configuration. This key acts as an alias, which we will use later. We will also
    add a new downstream service configuration for appointments and a new endpoint.
    The configuration looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向 `api/patients/{id}` 下游服务配置中添加一个新的键。这个键充当别名，我们稍后会使用它。我们还将添加一个新的下游服务配置和新的端点。配置看起来像这样：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The matching endpoint that will be implemented in the appointments services
    looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将在预约服务中实现的匹配端点看起来像这样：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have configured the new endpoints and modified the downstream service
    configurations, we need to add a new configuration for our aggregate orchestration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了新的端点并修改了下游服务配置，我们需要为我们的聚合编排添加一个新的配置：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can use the endpoint as defined by the aggregate configuration and execute
    a single call that will return a patient’s record alongside all the appointments
    that they have made. This information comes from multiple services almost simultaneously.
    Our client no longer needs to make multiple calls to get this information.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用聚合配置中定义的端点，执行一个调用，该调用将返回患者的记录以及他们所预约的所有预约。这些信息几乎同时来自多个服务。我们的客户端不再需要多次调用以获取这些信息。
- en: This simple and powerful technique helps us to better orchestrate API calls
    and present exactly the information that a client app needs. It promotes a more
    behavior-driven workflow when retrieving data and reduces the development overhead
    that each client application will need.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单而强大的技术帮助我们更好地协调API调用，并精确地呈现客户端应用所需的信息。它促进了在检索数据时的行为驱动型工作流程，并减少了每个客户端应用将需要的开发开销。
- en: Now that we have seen how we can implement API gateways using either our API
    project or Azure API Management, we have overcome a major hurdle in our microservices
    application. We no longer need to build client apps that need to keep track of
    all the addresses of our microservices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到我们可以如何使用我们的API项目或Azure API管理来实现API网关，我们已经克服了微服务应用中的一个主要障碍。我们不再需要构建需要跟踪我们所有微服务地址的客户端应用。
- en: This now raises another cause for concern. Unfortunately, different devices
    might have different requirements for how they interact with our services. Mobile
    clients might need special security and caching considerations that web applications
    do not. This adds more complication to how we keep track of configurations in
    the central gateway, relative to the devices hosting the client apps.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这又引发了一个新的担忧。不幸的是，不同的设备可能对如何与我们服务交互有不同的要求。移动客户端可能需要特殊的考虑，例如安全性和缓存，而Web应用则不需要。这给我们在中央网关中跟踪配置增加了更多的复杂性，相对于托管客户端应用的设备而言。
- en: These considerations lead us down the path of implementing a gateway per type
    of service client. This method of implementation is called the *Backend for Frontend
    pattern*, which we will discuss next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑让我们走上了为每种服务客户端实现一个网关的道路。这种实现方法被称为*前端后端模式*，我们将在下一节中讨论。
- en: Backend for Frontend pattern
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端后端模式
- en: While API gateways solve several problems, it is not a one size fits all solution.
    We still end up contending with the possibility of catering to multiple device
    types and, by extension, client applications. For example, we may need to use
    additional compression and caching rules with data being consumed by a mobile
    client, whereas a website might not need many special considerations. The more
    devices become capable of interacting with APIs, the more we need to ensure that
    we can support integrations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然API网关解决了几个问题，但它并不是一个万能的解决方案。我们仍然需要应对满足多种设备类型和由此产生的客户端应用的可能性。例如，我们可能需要为移动客户端使用额外的压缩和缓存规则，而网站可能不需要很多特殊考虑。随着能够与API交互的设备越来越多，我们越需要确保我们能够支持集成。
- en: '*Figure 11.7* shows multiple clients with one gateway:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.7* 展示了多个客户端和一个网关：'
- en: '![Figure 11.7 – All client devices access the same gateway, leading to inefficient
    behavior for some devices](img/Figure_11.7_B19100.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 所有客户端设备访问相同的网关，导致某些设备效率低下](img/Figure_11.7_B19100.jpg)'
- en: Figure 11.7 – All client devices access the same gateway, leading to inefficient
    behavior for some devices
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 所有客户端设备访问相同的网关，导致某些设备效率低下
- en: All these considerations make a good case for the **Backend for Frontend** (**BFF**)
    pattern. This pattern allows us to supply a service-per-device API approach. The
    BFF pattern allows us to acutely define our API functionality based on the experience
    that we hope for a user to have on a particular user interface. This makes it
    easier for us to develop and maintain and adjust our API based on the client’s
    requirements and simplifies the process of delivering functionality across multiple
    clients.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些考虑都很好地说明了**前端后端**（**BFF**）模式的好处。这种模式允许我们提供按设备API的方法。BFF模式允许我们根据我们希望用户在特定用户界面上拥有的体验来精确定义我们的API功能。这使得我们更容易根据客户端的要求开发和维护API，并简化了在多个客户端之间交付功能的过程。
- en: '*Figure 11.8* shows a BFF setup:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.8* 展示了一个BFF的设置：'
- en: '![Figure 11.8 – Each client app has an endpoint to a gateway that is specially
    configured to optimize API traffic for the target device type](img/Figure_11.8_B19100.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 每个客户端应用程序都有一个端点指向特别配置以优化目标设备类型 API 流量的网关](img/Figure_11.8_B19100.jpg)'
- en: Figure 11.8 – Each client app has an endpoint to a gateway that is specially
    configured to optimize API traffic for the target device type
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 每个客户端应用程序都有一个端点指向特别配置以优化目标设备类型 API 流量的网关
- en: Now, we can optimize each gateway instance to handle traffic for specific devices
    in the most efficient way possible. For instance, our mobile applications might
    require additional caching or compression settings and we may need to rewrite
    request headers. We might even define additional header information to be provided
    from our mobile devices as we may need to track the device type and location.
    In a nutshell, we need to ensure that we are catering to each possible device
    as much as possible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以优化每个网关实例，以最有效的方式处理特定设备的流量。例如，我们的移动应用程序可能需要额外的缓存或压缩设置，我们可能需要重写请求头。我们甚至可能定义额外的头信息，以便从我们的移动设备提供，因为我们可能需要跟踪设备类型和位置。简而言之，我们需要尽可能地为每个可能的设备提供服务。
- en: Azure API Management has features that allow us to interrogate the incoming
    request and redirect or modify the request before forwarding it or modifying the
    response before it is sent to the requesting client. By defining these policies,
    we can implement a BFF-like mechanism where policies are defined to look for the
    type of device or, generally, the source of the request and modify it as optimally
    as possible for forwarding or returning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Azure API Management 具有允许我们在转发请求之前查询传入请求并修改请求，或者在将响应发送到请求客户端之前修改响应的功能。通过定义这些策略，我们可以实现类似
    BFF 的机制，其中策略被定义为查找设备类型或通常请求的来源，并尽可能优化以转发或返回。
- en: Ocelot might require a bit more potentially confusing logic to support policies
    of this nature. The more recommended way to implement this pattern using Ocelot
    is to use multiple implementations of Ocelot. In this implementation style, we
    would create multiple Ocelot projects, each with its specific purpose, such as
    mobile, web, and public gateways, and add each configuration for the allowed up
    and downstream services. We would also be able to specify the rate-limiting and
    caching options per implementation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ocelot 可能需要一些更复杂的逻辑来支持此类策略。使用 Ocelot 实现此模式更推荐的方式是使用多个 Ocelot 实现。在这种实现风格中，我们会创建多个
    Ocelot 项目，每个项目都有其特定的用途，例如移动端、网页和公共网关，并为允许的上游和下游服务添加每个配置。我们还可以为每个实现指定速率限制和缓存选项。
- en: Let us review how this pattern can be implemented using Ocelot.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何使用 Ocelot 实现此模式。
- en: BFF pattern using Ocelot
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ocelot 的 BFF 模式
- en: We have already seen that we can configure Ocelot to be our API gateway. A simple
    enough extension to what we have done is to create additional projects and configure
    them similarly. We can retain the gateway that we have already and use it exclusively
    for third-party application access. With the up and downstream services we have
    defined, we can restrict third parties to only be able to access those endpoints.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们可以配置 Ocelot 作为我们的 API 网关。这只是一个简单的扩展，我们之前所做的工作，即创建额外的项目并按类似方式配置它们。我们可以保留已经拥有的网关，并专门用于第三方应用程序访问。通过我们定义的上游和下游服务，我们可以限制第三方只能访问那些端点。
- en: We can then create a new Ocelot project and use it specifically for our web
    client. Let us say that we do not want rate limiting on the web client and can
    decrease the cache time to 10 seconds instead of 20\. Given that this is our web
    application, we can lift most of these restrictions and allow for less strict
    interactions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建一个新的 Ocelot 项目，并专门为我们的网页客户端使用它。假设我们不想在网页客户端上应用速率限制，可以将缓存时间减少到 10 秒而不是
    20 秒。鉴于这是我们网页应用程序，我们可以放宽大多数这些限制，允许更宽松的交互。
- en: 'This configuration file will simply look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件将看起来像这样：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This looks similar to what we have already done with the previous gateway, but
    note that now, we have the unique opportunity to define custom paths that match
    with the web entry point that we are implementing while adding/removing configurations
    as we deem necessary for the web client. Also, notice that it will broadcast from
    a separate address, which will prevent any reference overlaps between the clients.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在之前的网关中已经做过的类似，但请注意，现在我们有一个独特的机会来定义自定义路径，这些路径与我们要实现的网络入口点相匹配，同时根据需要添加/删除配置，以适应网络客户端。此外，请注意，它将从不同的地址广播，这将防止客户端之间出现任何引用冲突。
- en: 'We may also want to implement a mobile client that has fewer restrictions similar
    to what we have outlined in the web gateway, but we may also want to customize
    the aggregation operation. So, for our mobile client gateway, we can add the following
    aggregator definition to the Ocelot configuration:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能想要实现一个具有较少限制的移动客户端，类似于我们在网络网关中概述的内容，但我们可能还想要自定义聚合操作。因此，对于我们的移动客户端网关，我们可以在Ocelot配置中添加以下聚合器定义：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `Program.cs` file, we add the following line to register the aggregator:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，我们添加以下行以注册聚合器：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to define a class called `PatientAppointmentAggregator`, which
    will implement our custom aggregation logic. This custom aggregator will intercept
    the responses from the downstream server and allow us to interrogate and modify
    what is returned:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个名为`PatientAppointmentAggregator`的类，该类将实现我们的自定义聚合逻辑。这个自定义聚合器将拦截来自下游服务器的响应，并允许我们查询和修改返回的内容：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This aggregator code receives a list of responses, where each entry represents
    the response from the downstream services in the order they were defined in the
    configuration. We then extract the response as a string and append it in one string
    value. We also add a `ContentType` header to the ultimate response, which is sent
    with a `200OK` HTTP response. This is a simple example, but it shows how easy
    it is for us to customize the default aggregation behavior and, by extension,
    for a specific BFF gateway.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聚合器代码接收一个响应列表，其中每个条目代表在配置中定义的顺序中下游服务的响应。然后我们将响应提取为字符串，并将其追加到一个字符串值中。我们还向最终响应添加了一个`ContentType`头，该响应与`200OK`
    HTTP响应一起发送。这是一个简单的例子，但它展示了我们如何轻松地自定义默认的聚合行为，以及如何通过扩展为特定的bff网关进行自定义。
- en: The BFF pattern allows us to further diversify our development teams and their
    efforts in maintaining the various microservices. Teams can now manage their gateways
    and implement gateway methods and features that are unique to the devices they
    are catering to.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: bff模式允许我们进一步多样化我们的开发团队及其在维护各种微服务方面的努力。现在，团队可以管理他们的网关并实现针对他们所服务的设备独特的网关方法和功能。
- en: Now that we understand API gateways, the BFF pattern, and how we can implement
    either one of these using industry-standard software, let us review what we have
    learned in this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了API网关、bff模式以及如何使用行业标准软件实现其中之一，让我们回顾一下本章所学的内容。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has reviewed the need for an API gateway. When building a monolith,
    we have a single point of entry to our application’s supporting API and this single
    point of entry can be used for any type of client.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了API网关的需求。在构建单体应用时，我们有一个单一入口点来访问应用程序的支持API，并且这个单一入口点可以用于任何类型的客户端。
- en: The downside to this is that we might end up with an API that becomes increasingly
    difficult to improve on and scale as the demands change. We also need to consider
    the fact that different devices have different needs from the API in terms of
    caching, compression, and authentication to name a few.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，我们可能会得到一个API，随着需求的改变，它变得越来越难以改进和扩展。我们还需要考虑这样一个事实，即不同的设备对API有不同的需求，例如缓存、压缩和身份验证等。
- en: We then attempt to diversify our application’s capabilities into multiple services
    or microservices and then implement only what is needed per service. This approach
    simplifies each service’s code base while complicating the code base of the client
    applications. Where there was one service endpoint, we now have several to keep
    track of.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后尝试将我们应用程序的功能多样化，扩展到多个服务或微服务中，并且只为每个服务实现所需的功能。这种方法简化了每个服务的代码库，同时却使客户端应用程序的代码库变得更加复杂。原本只有一个服务端点，现在我们有几个需要跟踪。
- en: API gateways will sit on top of all the microservices and expose a single point
    of entry and allow us to implement several instances, which can cater to the direct
    needs of the client applications that will use them. This adjustment is called
    BFF, and it allows us to curate backend services specifically for the client applications
    that need them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: API网关将位于所有微服务之上，提供一个单一的入口点，并允许我们实现多个实例，以满足将使用它们的客户端应用程序的直接需求。这种调整被称为bff，它允许我们针对需要它们的客户端应用程序特别定制后端服务。
- en: The major downside here is that we have reintroduced a single point of failure
    by providing the gateway layer, which can introduce potential performance issues.
    The goal, however, is to reduce the need for our client apps to have intimate
    knowledge of the complex web of services that they need to interact with, and
    this layer of abstraction also helps us to maintain our services with less effect
    on the client applications.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要缺点是，通过提供网关层，我们重新引入了一个单点故障，这可能会引入潜在的性能问题。然而，我们的目标是减少我们的客户端应用程序对它们需要与之交互的复杂服务网络有深入了解的需求，这一层抽象也有助于我们在对客户端应用程序影响较小的情况下维护我们的服务。
- en: We also learned that when attempting to add the BFF pattern, we introduce the
    need for more services and more code to maintain. Ideally, we would like to have
    a single implementation that can be provisioned multiple times, all with their
    specific configurations. This is where technology such as Docker will help, but
    we will review that later in this book.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，当尝试添加bff模式时，我们引入了对更多服务和更多代码进行维护的需求。理想情况下，我们希望有一个单一的实现，可以被配置多次，所有这些配置都是特定的。这正是Docker等技术能够帮助的地方，但我们将在此书稍后进行回顾。
- en: Now that we have seen the pros and cons of the API gateway pattern, we need
    to explore security for our APIs. In the next chapter, we will explore API security
    using bearer tokens.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了API网关模式的优缺点，我们需要探索我们API的安全性。在下一章中，我们将探讨使用令牌的API安全性。
