["```cs\n    public static class Recipes\n    {\n        public static void ValueGreaterThanZero(int iNonZeroValue)\n        {\n\n        }\n    }\n    ```", "```cs\n    public static void ValueGreaterThanZero(int iNonZeroValue)\n    {\n        Contract.Requires(iNonZeroValue >= 1, \"Parameter iNonZeroValue not greater than zero\");\n    }\n    ```", "```cs\n    using static System.Console;\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        ValueGreaterThanZero(0);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n        ReadLine();\n    }\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static class Recipes\n    {\n        public static int NeverReturnZero(int iNonZeroValue)\n        {\n\n        }\n    }\n    ```", "```cs\n    public static int NeverReturnZero(int iNonZeroValue)\n    {\n        Contract.Ensures(Contract.Result<int>() > 0, \"The value returned was not greater than zero\");\n\n        return iNonZeroValue - 1;\n    }\n    ```", "```cs\n    using static System.Console;\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        NeverReturnZero(1);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n        ReadLine();\n    }\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public class InvariantClassState\n    {\n\n    }\n    ```", "```cs\n    private int _Year { get; set; }\n    private int _Month { get; set; }\n    private int _Day { get; set; }\n    ```", "```cs\n    public InvariantClassState(int year, int month, int day)\n    {\n        _Year = year;\n        _Month = month;\n        _Day = day;\n    }\n    ```", "```cs\n    [ContractInvariantMethod]\n    private void Invariants()\n    {\n        Contract.Invariant(this._Year >= DateTime.Now.Year);\n        Contract.Invariant(this._Month <= 12);\n        Contract.Invariant(this._Month >= 1);\n        Contract.Invariant(this._Day >= 1);\n        Contract.Invariant(this._Day <= DateTime.DaysInMonth(_Year, _Month);\n    }\n    ```", "```cs\n    [ContractInvariantMethod]\n    private void Invariants()\n    {\n        Contract.Invariant(this._Year >= DateTime.Now.Year, \"The supplied year is in the past\");\n        Contract.Invariant(this._Month <= 12, $\"The value {_Month} is not a valid Month value\");\n        Contract.Invariant(this._Month >= 1, $\"The value {_Month} is not a valid Month value\");\n        Contract.Invariant(this._Day >= 1, $\"The value {_Day} is not a valid calendar value\");\n        Contract.Invariant(this._Day <= DateTime.DaysInMonth(_Year, _Month), $\"The month given does not contain {_Day} days\");\n    }\n    ```", "```cs\n    public string ReturnGivenMonthDayYearDate()\n    {            \n        return $\"{_Month}/{_Day}/{_Year}\";\n    }\n    ```", "```cs\n    public class InvariantClassState\n    {\n        private int _Year { get; set; }\n        private int _Month { get; set; }\n        private int _Day { get; set; }\n\n        public InvariantClassState(int year, int month, int day)\n        {\n            _Year = year;\n            _Month = month;\n            _Day = day;\n        }\n\n        [ContractInvariantMethod]\n        private void Invariants()\n        {\n            Contract.Invariant(this._Year >= DateTime.Now.Year, \"The supplied year is in the past\");\n            Contract.Invariant(this._Month <= 12, $\"The value {_Month} is not a valid Month value\");\n            Contract.Invariant(this._Month >= 1, $\"The value {_Month} is not a valid Month value\");\n            Contract.Invariant(this._Day >= 1, $\"The value {_Day} is not a valid calendar value\");\n            Contract.Invariant(this._Day <= DateTime.DaysInMonth(_Year, _Month), $\"The month given does not contain {_Day} days\");\n        }\n\n        public string ReturnGivenMonthDayYearDate()\n        {            \n            return $\"{_Month}/{_Day}/{_Year}\";\n        }\n    }\n    ```", "```cs\n    using Chapter8;\n    ```", "```cs\n    try\n    {\n        InvariantClassState oInv = new InvariantClassState(DateTime.Now.Year - 1, 13, 32);\n        string returnedDate = oInv.ReturnGivenMonthDayYearDate();\n        WriteLine(returnedDate);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);                \n    }\n    ReadLine();\n    ```", "```cs\n    try\n    {\n        InvariantClassState oInv = new InvariantClassState(DateTime.Now.Year, 13, 32);\n        string returnedDate = oInv.ReturnGivenMonthDayYearDate();\n\n        WriteLine(returnedDate);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);                \n    }\n    ReadLine();\n    ```", "```cs\n    try\n    {\n        InvariantClassState oInv = new InvariantClassState(DateTime.Now.Year, 11, 32);\n        string returnedDate = oInv.ReturnGivenMonthDayYearDate();\n\n        WriteLine(returnedDate);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);                \n    }\n    ReadLine();\n    ```", "```cs\n    try\n    {\n        InvariantClassState oInv = new InvariantClassState(DateTime.Now.Year, 11, 25);\n        string returnedDate = oInv.ReturnGivenMonthDayYearDate();\n\n        WriteLine(returnedDate);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);                \n    }\n    ReadLine();\n    ```", "```cs\n    try\n    {\n        InvariantClassState oInv = new InvariantClassState(DateTime.Now.Year + 1, 2, 29);\n        string returnedDate = oInv.ReturnGivenMonthDayYearDate();\n\n        WriteLine(returnedDate);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);                \n    }\n    ReadLine();\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static int ValueIsValid(int valueForCalc, int valueToDivide)\n    {\n\n    }\n    ```", "```cs\n    public static int ValueIsValid(int valueForCalc, int valueToDivide)\n    {\n        int calculatedVal = valueForCalc - 1;\n        Contract.Assert(calculatedVal >= 1, \"Calculated value will result in divide by zero exception.\");\n        return valueToDivide / calculatedVal;\n    }\n    ```", "```cs\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        int calcVal = ValueIsValid(1, 9);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n        ReadLine();\n    }\n    ```", "```cs\n    public static int ValueIsValid(int valueForCalc, int valueToDivide)\n    {\n        Contract.Requires((valueForCalc - 1) >= 1);\n        int calculatedVal = valueForCalc - 1;\n        Contract.Assert(calculatedVal >= 1, \"Calculated value will result in divide by zero exception.\");\n        return valueToDivide / calculatedVal;\n    }\n    ```", "```cs\n    public static int ValueIsValid(int valueForCalc, int valueToDivide)\n    {\n        Contract.Assume((valueForCalc - 1) >= 1);\n        int calculatedVal = valueForCalc - 1; \n        Contract.Assert(calculatedVal >= 1, \"Calculated value will result in divide by zero exception.\");\n        return valueToDivide / calculatedVal; \n    }\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static void ValidateList(List<int> lstValues)\n    {\n\n    }\n    ```", "```cs\n    public static void ValidateList(List<int> lstValues)\n    {\n        Contract.Assert(Contract.ForAll(lstValues, n => n != 0), \"Zero values are not allowed\");\n    }\n    ```", "```cs\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        List<int> intList = new List<int>();\n        int[] arr;\n        intList.AddRange(arr = new int[] { 1, 3, 2, 6, 0, 5});\n        ValidateList(intList);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n        ReadLine();\n    }\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static void ValidOutValue(out int secureValue)\n    {\n\n    }\n    ```", "```cs\n    public static void ValidOutValue(out int secureValue)\n    {\n        Contract.Ensures(Contract.ValueAtReturn<int>(out secureValue) >= 1, \"The secure value is less or equal to zero\");\n        secureValue = secureValue - 10;\n    }\n    ```", "```cs\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        int valueToCheck = 5;\n        ValidOutValue(out valueToCheck);\n        WriteLine(\"The value is not zero\");\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n    }\n    ReadLine();\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static int ValidateResult(int value1, int value2)\n    {\n\n    }\n    ```", "```cs\n    public static int ValidateResult(int value1, int value2)\n    {\n        Contract.Ensures(Contract.Result<int>() >= 0, \"Negative result not allowed\");\n        return value1 - value2;\n    }\n    ```", "```cs\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        WriteLine(ValidateResult(10, 23));\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n    }\n    ReadLine();\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public abstract class Shape\n    {\n        public abstract void Length(int value);\n        public abstract void Width(int value);\n    }\n    ```", "```cs\n    public abstract class ShapeContract : Shape\n    {\n\n    }\n    ```", "```cs\n    public abstract class ShapeContract : Shape\n    {\n        public override void Length(int value)\n        {\n            Contract.Requires(value > 0, \"Length must be greater than zero\");\n        }\n\n        public override void Width(int value)\n        {\n            Contract.Requires(value > 0, \"Width must be greater than zero\");\n        }\n    }\n    ```", "```cs\n    [ContractClass(typeof(ShapeContract))]\n    ```", "```cs\n    [ContractClass(typeof(ShapeContract))]\n    public abstract class Shape\n    {\n        public abstract void Length(int value);\n        public abstract void Width(int value);\n    }\n    ```", "```cs\n    [ContractClassFor(typeof(Shape))]\n    ```", "```cs\n    [ContractClassFor(typeof(Shape))]\n    public abstract class ShapeContract : Shape\n    {\n        public override void Length(int value)\n        {\n            Contract.Requires(value > 0, \"Length must be greater than zero\");\n        }\n\n        public override void Width(int value)\n        {\n            Contract.Requires(value > 0, \"Width must be greater than zero\");\n        }\n    }\n    ```", "```cs\n    public class Rectangle : Shape\n    {\n\n    }\n    ```", "```cs\n    public class Rectangle : Shape\n    {\n        private int _length { get; set; }\n        private int _width { get; set; }\n        public override void Length(int value)\n        {\n            _length = value;\n        }\n\n        public override void Width(int value)\n        {\n            _width = value;\n        }\n    }\n    ```", "```cs\n    using Chapter8;\n    ```", "```cs\n    try\n    {\n        Rectangle oRectangle = new Rectangle();\n        oRectangle.Length(0);\n        oRectangle.Width(1);\n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n    }\n    ReadLine();\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static int MethodOne(int value)\n    {\n        Contract.Requires(value > 0, \"Parameter must be greater than zero\");\n        Contract.Ensures(Contract.Result<int>() > 0, \"Method result must be greater than zero\");\n\n        return value - 1;\n    }\n\n    public static int MethodTwo(int value)\n    {\n        Contract.Requires(value > 0, \"Parameter must be greater than zero\");\n        Contract.Ensures(Contract.Result<int>() > 0, \"Method result must be greater than zero\");\n\n        return (value * 10) - 10;\n    }\n    ```", "```cs\n    private static void StandardMethodContract(int value)\n    {\n        Contract.Requires(value > 0, \"Parameter must be greater than zero\");\n        Contract.Ensures(Contract.Result<int>() >= 1, \"Method result must be greater than zero\");\n    }\n    ```", "```cs\n    [ContractAbbreviator]\n    ```", "```cs\n    [ContractAbbreviator]\n    private static void StandardMethodContract(int value)\n    {\n        Contract.Requires(value > 0, \"Parameter must be greater than zero\");\n        Contract.Ensures(Contract.Result<int>() >= 1, \"Method result must be greater than zero\");\n    }\n    ```", "```cs\n    public static int MethodOne(int value)\n    {\n        StandardMethodContract(value);\n\n        return value - 1;\n    }\n\n    public static int MethodTwo(int value)\n    {\n        StandardMethodContract(value);\n\n        return (value * 10) - 10;\n    }\n    ```", "```cs\n    using static Chapter8.Recipes;\n    ```", "```cs\n    try\n    {\n        MethodOne(0);\n        MethodTwo(1);                \n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n    }\n    ReadLine();\n    ```", "```cs\n    try\n    {\n        MethodOne(200);\n        MethodTwo(1);                \n    }\n    catch (Exception ex)\n    {\n        WriteLine(ex.Message);\n    }\n    ReadLine();\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public class CodeContractTests\n    {    \n\n    }\n    ```", "```cs\n    public class CodeContractTests\n    {\n        public int Calculate(int valueOne, int valueTwo)\n        {\n            Contract.Ensures(Contract.Result<int>() >= 1, \"\");\n\n            return valueOne / valueTwo;\n        }\n    }\n    ```", "```cs\n    /// <summary>This class contains parameterized unit tests for CodeContractTests</summary>\n    [PexClass(typeof(CodeContractTests))]\n    [PexAllowedExceptionFromTypeUnderTest(typeof(InvalidOperati onException))]\n    [PexAllowedExceptionFromTypeUnderTest(typeof(ArgumentExcept ion), AcceptExceptionSubtypes = true)]\n    [TestClass]\n    public partial class CodeContractTestsTest\n    {\n        /// <summary>Test stub for Calculate(Int32, Int32)</summary>\n        [PexMethod]\n        public int CalculateTest(\n            [PexAssumeUnderTest]CodeContractTests target,\n            int valueOne,\n            int valueTwo\n        )\n        {\n            int result = target.Calculate(valueOne, valueTwo);\n            return result;\n            // TODO: add assertions to method CodeContractTestsTest.CalculateTest (CodeContractTests, Int32, Int32)\n        }\n    }\n    ```", "```cs\n    public int Calculate(int valueOne, int valueTwo)\n    {\n        Contract.Requires(valueOne > 0, \"Parameter must be greater than zero\");\n        Contract.Requires(valueTwo > 0, \"Parameter must be greater than zero\");\n        Contract.Requires(valueOne > valueTwo, \"Parameter values will result in value <= 0\");\n        Contract.Ensures(Contract.Result<int>() >= 1, \"\");\n\n        return valueOne / valueTwo;\n    }\n    ```", "```cs\n    using System.Diagnostics.Contracts;\n    ```", "```cs\n    public static class ExtensionMethods\n    {\n\n    }\n    ```", "```cs\n    public static bool ContainsInvalidValue<T>(this List<T> value, T invalidValue)\n    {    \n\n    }\n    ```", "```cs\n    try\n    {\n        Contract.Assert(Contract.ForAll(value, n => !value.Contains(invalidValue)), \"Zero values are not allowed\");\n        return false;\n    }\n    catch \n    {\n        return true;\n    }\n    ```", "```cs\n    public static class ExtensionMethods\n    {\n        public static bool ContainsInvalidValue<T>(this List<T> value, T invalidValue)\n        {\n            try\n            {\n                Contract.Assert(Contract.ForAll(value, n => !value.Contains(invalidValue)), \"Zero values are not allowed\");\n                return false;\n            }\n            catch \n            {\n                return true;\n            }\n        }\n    }\n    ```", "```cs\n    using Chapter8;\n    ```", "```cs\n    List<int> intList = new List<int>();\n    int[] arr;\n    intList.AddRange(arr = new int[] { 1, 3, 2, 6, 0, 5 });\n\n    if (intList.ContainsInvalidValue(4)) \n        WriteLine(\"Invalid integer Value\");\n    else\n        WriteLine(\"Valid integer List\");\n    ```", "```cs\n    List<string> strList = new List<string>();\n    string[] arr2;\n    strList.AddRange(arr2 = new string[] { \"S\", \"A\", \"Z\" });\n\n    if (strList.ContainsInvalidValue(\"G\"))\n        WriteLine(\"Invalid string Value\");\n    else\n        WriteLine(\"Valid string List\");\n    ```"]