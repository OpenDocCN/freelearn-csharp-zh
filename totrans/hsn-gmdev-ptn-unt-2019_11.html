<html><head></head><body>
        

                            
                    <h1 class="header-title">Strategy</h1>
                
            
            
                
<p>Strategy is one of those patterns whose name doesn't indicate its intent explicitly. This uncertainty can make it hard to grasp and remember its purpose. But the Strategy pattern is quite simple: it offers a way to dynamically select algorithms and assign them to an object at runtime. We could imagine the Strategy pattern acting as a master chess player, analyzing the chessboard and choosing what strategy is best depending on the context.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basics of the Strategy pattern</li>
<li>Implementing a series of target-seeking behaviors for missiles using the Strategy pattern</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p class="mce-root">This chapter is a hands-on chapter, so you will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>Composition over inheritance</li>
</ul>
<p>If unfamiliar with this concept, please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2UlVjVG">http://bit.ly/2UlVjVG</a></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">An overview of the Strategy pattern</h1>
                
            
            
                
<p>The primary goal of the Strategy pattern is to defer the decision of which algorithm to use until runtime. This approach allows more flexibility and reusability of segments of code that implement logic and behaviors. This idea may sound very complicated, but it's a simple mechanism that's possible because of the object-oriented programming concept of <em>composition</em>. So, instead of sharing reusable algorithms by implementing them in a parent class that can be inherited by other classes, we instead wrap each algorithm into self-contained individual <em>components</em> that we attach to objects at runtime.</p>
<p>If this sounds familiar and resembles a lot how Unity's component system works, it's because the engine has what we call in object-oriented programming a <em>composition over inheritance</em> approach. So, this makes the Strategy pattern harmonious with Unity's architecture.</p>
<p>Let's review the following simple diagram of this pattern:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/53644f50-1166-4f66-95a1-c4603bca9f51.png"/></p>
<p class="mce-root"/>
<p>As we can see, this example of the Strategy pattern implements an interface that permits us to assign various seeking behaviors to any objects of the <strong>Missile</strong> type. But like most patterns, it can be tough to follow it's design just by looking at a UML diagram. Therefore, we can only truly understand the mechanism behind this pattern by implementing it in code, which we will see in the next sections.</p>
<p>In this chapter, we will often use the terms algorithms, logic, and behaviors as synonyms because, in the context of the Strategy pattern, they are manageable as individual components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits and drawbacks</h1>
                
            
            
                
<p>The Strategy pattern has a good reputation, but like most sophisticated patterns, its complexity can cause some drawbacks.</p>
<p>These are the benefits:</p>
<ul>
<li><strong>An alternative to subclassing</strong>: Because it focuses on composition over inheritance, the Strategy offers a way to avoid hardwiring behaviors in each subclass of a parent type</li>
<li><strong>Fewer condition statements to manage</strong>: By implementing each behavior into individual components that can be managed by the Strategy pattern, the need for long conditional statements when dealing with complex contextual behavior selection is eliminated</li>
</ul>
<p>Here are the drawbacks:</p>
<ul>
<li><strong>Client must be aware of the various strategies</strong>: The Strategy pattern doesn't abstract itself from the client, so it must be aware of the different strategies and how to call them</li>
<li><strong>Increased code complexity</strong>: A common drawback of this type of sophisticated pattern is that it does increase the number of classes and objects to manage</li>
</ul>
<p>One of the main reasons that a lot of programmers hesitate to use sophisticated patterns is because they are afraid that junior members of the team might get lost in the complexity that it adds to a code base. So, it's important to diagram and document complex parts of your code and also list the patterns you are using to implement a system.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Use case example</h1>
                
            
            
                
<p>For this use case, let's imagine we are working on a military simulation game and we are assigned to implement the following behaviors for the missile homing system:</p>
<ul>
<li><strong>Heat</strong>: The missile seeks a target by its heat signature</li>
<li><strong>Sonar</strong>: The missile uses sound propagation to find a target</li>
<li><strong>GPS</strong>: The missile uses GPS coordinates to home onto the target</li>
</ul>
<p>The design document also emphasizes that there will be three types of missiles using a homing system. But at the moment, it's not decided which missile will be using which homing system:</p>
<ul>
<li><strong>Tomahawk</strong>: Usually launched from a carrier</li>
<li><strong>SideWinder</strong>: They are intended for jet fighters</li>
<li><strong>Torpado</strong>: They are designed to destroy underwater targets</li>
</ul>
<p>So, now we have technical choices to make:</p>
<ul>
<li>Do we hard code each seeking behavior in the class of each type of missile?</li>
<li>Do we write a single homing system class that will contain all the missile-seeking behaviors?</li>
<li>Do we instead write each missile-seeking behavior as a separate component that we can attach dynamically to any missile?</li>
</ul>
<p>The third option is the best one because it removes any duplicate code and offers flexibility in the form of composition. In the next section, we will implement this use case, and we will see how the Strategy pattern provides us a lot of extensibility.</p>
<p>Good code is flexible and never rigid. Rigidity might seem more stable, but it makes changes difficult and expensive.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Code example</h1>
                
            
            
                
<p>We are going to keep this example very simple, so we can focus on understanding the Strategy pattern and not get lost in wordiness. Let's follow a step-by-step procedure:</p>
<ol>
<li>Let's start by implementing the following critical element that makes this pattern work, which is the interface that will be used to access the seeking behaviors:</li>
</ol>
<pre style="padding-left: 60px">public interface ISeekBehaviour<br/>{<br/>    void Seek();<br/>}</pre>
<p style="padding-left: 60px">Now that we have a standard interface for all our seeking behaviors, let's implements them in individual concrete classes.</p>
<ol start="2">
<li>Our first one is our <kbd>SeekWithGPS</kbd> behavior, as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class SeekWithGPS : ISeekBehaviour<br/>{<br/>    public void Seek()<br/>    {<br/>        Debug.Log("Seeking target with GPS coordinates.");<br/>    }<br/>}</pre>
<ol start="3">
<li>We have our <kbd>SeekWithHeat</kbd> behavior, as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class SeekWithHeat : ISeekBehaviour<br/>{<br/>    public void Seek()<br/>    {<br/>        Debug.Log("Seeking target with heat signature.");<br/>    }<br/>}</pre>
<ol start="4">
<li>Lastly, we have our <kbd>SeekWithSonar</kbd> behavior, as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class SeekWithSonar : ISeekBehaviour<br/>{<br/>    public void Seek()<br/>    {<br/>        Debug.Log("Seeking with sonar.");<br/>    }<br/>}</pre>
<p style="padding-left: 60px">So, now that we have encapsulated each seeking behavior into individual classes, the next step is to find a way to assign them dynamically to missiles.</p>
<ol start="5">
<li>Let's write an abstract class that will group each type of missile with a common parent and permit us to give them a shared interface, as follows:</li>
</ol>
<pre style="padding-left: 60px">abstract public class Missile<br/>{<br/>    protected ISeekBehaviour seekBehavior;<br/><br/>    public void ApplySeek()<br/>    {<br/>        seekBehavior.Seek();<br/>    }<br/><br/>    public void SetSeekBehavior(ISeekBehaviour seekType)<br/>    {<br/>        this.seekBehavior = seekType;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">There are two key things to notice: the <kbd>ApplySeek()</kbd> and <kbd>SetSeekBehaviour()</kbd> functions will apply a specified behavior to any missile type that derives from the <kbd>Missile</kbd> class. We have given ourselves a single point of access to all our missile types and a way to apply a seek behavior dynamically. Let's see how this looks in our concrete missile classes.</p>
<ol start="6">
<li>We are starting with our <kbd>Torpedo</kbd>. By default, let's give it the <kbd>SeekWithSonar</kbd> behavior, as follows:</li>
</ol>
<pre style="padding-left: 60px">public class Torpedo : Missile<br/>{<br/>    void Awake()<br/>    {<br/>        this.seekBehavior = new SeekWithSonar();<br/>    }<br/>}</pre>
<ol start="7">
<li>Next up is our <kbd>SideWinder</kbd>. We should give it the <kbd>SeekWithHeat</kbd> behavior, as follows:</li>
</ol>
<pre style="padding-left: 60px">public class SideWinder : Missile<br/>{<br/>    void Awake()<br/>    {<br/>        this.seekBehavior = new SeekWithHeat();<br/>    }<br/>}</pre>
<ol start="8">
<li>Our final missile type is going to be <kbd>Tomahawk</kbd>. Let's give it the <kbd>SeekWithGPS</kbd> behavior because it's a long-distance missile, as follows:</li>
</ol>
<pre style="padding-left: 60px">public class Tomahawk : Missile<br/>{<br/> void Awake()<br/> {<br/> this.seekBehavior = new SeekWithGPS();<br/> }<br/>}</pre>
<p style="padding-left: 60px">We can notice that each concrete missile class assigns an instance of the seeking behavior to <kbd>this.seekBehaviour</kbd> at <kbd>Awake()</kbd>, and this is because we want to make sure each missile type has a default seeking behavior associated with it at initialization.</p>
<ol start="9">
<li>We will see in our <kbd>Client</kbd> class example that we can reassign a new behavior to a missile at any time we want, as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.D))<br/>        {<br/>            // Applying default seeking behaviour to missiles.<br/>            Missile sideWinder = ScriptableObject.CreateInstance&lt;SideWinder&gt;();<br/>            sideWinder.ApplySeek();<br/><br/>            Missile tomahawk = ScriptableObject.CreateInstance&lt;Tomahawk&gt;();<br/>            tomahawk.ApplySeek();<br/><br/>            Missile torpedo = ScriptableObject.CreateInstance&lt;Torpedo&gt;();<br/>            torpedo.ApplySeek();<br/><br/>            // Applying custom seeking behaviour to a SideWinder.<br/>            Missile sideWinderWithSonar = ScriptableObject.CreateInstance&lt;SideWinder&gt;();<br/>            ISeekBehaviour sonar = new SeekWithSonar();<br/>            sideWinderWithSonar.SetSeekBehavior(sonar);<br/>            sideWinderWithSonar.ApplySeek();<br/>        }<br/>    }<br/>}</pre>
<p>As we can see, we are now able to attach dynamically a seek behavior to any missile. This mechanism is beneficial because it means we could launch a missile and switch its seeking behavior mid-flight; a very cool feature to have in a game.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have just learned how to implement the Strategy pattern by building a series of targeting seeking behaviors that can be attached to any missile at runtime. An important takeaway from this pattern is the importance of isolating behaviors into separate classes that can be assigned dynamically to objects. This approach has become a pillar of good architecture and very popular among game programmers.<br/>
<br/>
In the next chapter, we will explore the command pattern, a behavioral pattern that is often used to manage the triggering of events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Practice</h1>
                
            
            
                
<p>In the preceding code example, we only implemented a simple prototype of missile targeting seeking behaviors to keep the chapter within a reasonable length and focus on learning the core concepts behind the Strategy pattern. However, it would be a great exercise to complete the implementation of those targeting behaviors and build a demo of a launching system that can dynamically switch a missile's homing system from a heat, sonar, or GPS seeking behavior.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>Composition over inheritance:<br/>
<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">https://en.wikipedia.org/wiki/Composition_over_inheritance</a></li>
</ul>


            

            
        
    </body></html>