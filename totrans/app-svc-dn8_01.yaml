- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Apps and Services with .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET介绍应用和服务
- en: In this first chapter, the goals are setting up your development environment
    to use Visual Studio 2022 and Visual Studio Code and understanding your choices
    for building apps and services; we will review good places to look for help.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，目标是设置使用Visual Studio 2022和Visual Studio Code的开发环境，了解构建应用程序和服务的选项；我们将回顾寻找帮助的好地方。
- en: 'The GitHub repository for this book has solutions using full application projects
    for all code tasks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库中的解决方案使用了完整的应用程序项目来处理所有代码任务：
- en: '[https://github.com/markjprice/apps-services-net8/](https://github.com/markjprice/apps-services-net8/)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/](https://github.com/markjprice/apps-services-net8/)'
- en: After going to the GitHub repository, simply press the *.* (dot) key on your
    keyboard or change `.com` to `.dev` to change the repository into a live code
    editor based on Visual Studio Code using GitHub Codespaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前往GitHub仓库后，只需在键盘上按下.*（点）*键或将`.com`更改为`.dev`，即可将仓库转换为基于Visual Studio Code的实时代码编辑器，使用GitHub
    Codespaces。
- en: Visual Studio Code in a web browser is great to run alongside your chosen code
    editor as you work through the book’s coding tasks. You can compare your code
    to the solution code and easily copy and paste parts if needed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中使用Visual Studio Code与您选择的代码编辑器一起运行，非常适合在完成本书的编码任务时使用。您可以将自己的代码与解决方案代码进行比较，并在需要时轻松复制和粘贴部分代码。
- en: Throughout this book, I use the term **modern .NET** to refer to .NET 8 and
    its predecessors like .NET 6, which come from .NET Core. I use the term **legacy
    .NET** to refer to .NET Framework, Mono, Xamarin, and .NET Standard. Modern .NET
    is a unification of those legacy platforms and standards.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我使用术语**现代.NET**来指代.NET 8及其前身，如.NET 6，它们来自.NET Core。我使用术语**传统.NET**来指代.NET
    Framework、Mono、Xamarin和.NET Standard。现代.NET是这些传统平台和标准的统一体。
- en: 'This chapter covers the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Introducing this book and its contents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍本书及其内容
- en: App and service technologies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用和服务技术
- en: Setting up your development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: Exploring top-level programs, functions, and namespaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索顶级程序、函数和命名空间
- en: Making good use of the GitHub repository for this book
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用本书的GitHub仓库
- en: Where to go for help
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪里可以获得帮助
- en: Introducing this book and its contents
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍本书及其内容
- en: 'This book caters to two audiences:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向两个受众：
- en: Readers who have completed my book for beginners, *C# 12 and .NET 8 – Modern
    Cross-Platform Development Fundamentals*, and now want to take their learning
    further.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成了我的入门书籍《C# 12和.NET 8 – 现代跨平台开发基础知识》，并希望进一步学习的读者。
- en: Readers who already have basic skills and knowledge about C# and .NET and want
    to learn practical skills and knowledge to build real-world applications and services.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经具备C#和.NET基本技能和知识的读者，希望学习实际技能和知识来构建真实世界的应用程序和服务。
- en: Companion books to continue your learning journey
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续学习旅程的配套书籍
- en: 'This book is the second of three books in a trilogy that continues your learning
    journey through .NET 8:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是三部曲中的第二部，继续通过.NET 8进行学习之旅：
- en: The first book covers the fundamentals of the C# language, the .NET libraries,
    and ASP.NET Core for web development. It is designed to be read linearly because
    skills and knowledge from earlier chapters build up and are needed to understand
    later chapters.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一本书涵盖了C#语言的基础知识、.NET库以及用于Web开发的ASP.NET Core。它设计为线性阅读，因为早期章节中的技能和知识会逐步积累，并需要理解后续章节。
- en: This second book covers more specialized topics like internationalization and
    popular third-party packages including Serilog and NodaTime. You will learn how
    to build native AOT-compiled services with ASP.NET Core Minimal APIs and how to
    improve performance, scalability, and reliability using caching, queues, and background
    services. You will implement more services using GraphQL, gRPC, SignalR, and Azure
    Functions. Finally, you will learn how to build graphical user interfaces for
    websites, desktop, and mobile apps with Blazor and .NET MAUI.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二本书涵盖了更多专业化的主题，如国际化以及流行的第三方包，包括Serilog和NodaTime。您将学习如何使用ASP.NET Core Minimal
    APIs构建原生AOT编译的服务，以及如何通过缓存、队列和后台服务来提高性能、可扩展性和可靠性。您将使用GraphQL、gRPC、SignalR和Azure
    Functions实现更多服务。最后，您将学习如何使用Blazor和.NET MAUI为网站、桌面和移动应用程序构建图形用户界面。
- en: The third book covers important tools and skills that a professional .NET developer
    should have. These include design patterns and solution architecture, debugging,
    memory analysis, all the important types of testing whether unit, performance,
    or web and mobile, and then hosting and deployment topics like Docker and Azure
    Pipelines. Finally, we look at how to prepare for an interview to get the .NET
    developer career that you want.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三本书涵盖了专业 .NET 开发人员应该具备的重要工具和技能。这些包括设计模式和解构架构、调试、内存分析、所有重要的测试类型，无论是单元测试、性能测试还是
    Web 和移动测试，以及 Docker 和 Azure Pipelines 等托管和部署主题。最后，我们探讨如何准备面试以获得你想要的 .NET 开发人员职业生涯。
- en: 'A summary of the .NET 8 trilogy and their most important topics is shown in
    *Figure 1.1*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8 三部曲及其最重要的主题的总结如图 1.1 所示：
- en: '![](img/B19587_01_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_01_01.png)'
- en: 'Figure 1.1: Companion books for learning C# 12 and .NET 8'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：学习 C# 12 和 .NET 8 的配套书籍
- en: '*Tools and Skills for .NET 8 Pros* is planned to be published in the first
    half of 2024\. Look out for it in your favorite bookstore and complete your .NET
    8 trilogy.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*《.NET 8 高级开发者工具和技能》计划于 2024 年上半年出版。请在您最喜欢的书店留意它，并完成您的 .NET 8 三部曲。'
- en: We provide you with a PDF file that has color images of the screenshots and
    diagrams used in this book. You can download this file from [https://packt.link/gbp/9781837637133](https://packt.link/gbp/9781837637133).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为你提供了一个包含本书中使用的截图和图表彩色图像的 PDF 文件。你可以从 [https://packt.link/gbp/9781837637133](https://packt.link/gbp/9781837637133)
    下载此文件。
- en: What you will learn in this book
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你将在本书中学到的内容
- en: 'After this first chapter, this book can be divided into four parts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，本书可以分为四个部分：
- en: '**Managing data**: How to store and manage data locally and in the cloud with
    SQL Server and Azure Cosmos DB. Later chapters use the SQL Server database and
    entity models that you will create at the end of *Chapter 3*, *Building Entity
    Models for SQL Server Using EF Core*. The chapter about Cosmos DB uses the SQL
    API, and there is an online-only chapter about Gremlin, which is a graph API.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据管理**：如何使用 SQL Server 和 Azure Cosmos DB 在本地和云端存储和管理数据。后续章节将使用你在 *第 3 章*，*使用
    EF Core 为 SQL Server 构建实体模型* 的结尾处创建的 SQL Server 数据库和实体模型。关于 Cosmos DB 的章节使用 SQL
    API，还有一个关于 Gremlin 的在线章节，Gremlin 是一个图 API。'
- en: '**Specialized libraries**: Dates, times, and internationalization; improving
    performance with threads and tasks; and third-party libraries for image handling,
    data validation rules, and so on. These chapters can be treated like a cookbook
    of recipes. If you are not interested in any topic, you can skip it, and you can
    read them in any order.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**专用库**：日期、时间和国际化；使用线程和任务提高性能；以及用于图像处理、数据验证规则等的第三方库。这些章节可以像食谱集一样处理。如果你对任何主题不感兴趣，你可以跳过它，并且可以按任何顺序阅读它们。'
- en: '**Service technologies**: How to build and secure services with ASP.NET Core
    Web API Minimal APIs, GraphQL, gRPC, SignalR, and Azure Functions. To improve
    service scalability and reliability we cover queues, caching, and event scheduling.
    There is also an online-only chapter about OData services.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务技术**：如何使用 ASP.NET Core Web API Minimal APIs、GraphQL、gRPC、SignalR 和 Azure
    Functions 构建和保障服务。为了提高服务的可扩展性和可靠性，我们涵盖了队列、缓存和事件调度。还有一个关于 OData 服务的在线章节。'
- en: '**User interface technologies**: How to build user interfaces with ASP.NET
    Core, Blazor, and .NET MAUI.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户界面技术**：如何使用 ASP.NET Core、Blazor 和 .NET MAUI 构建用户界面。'
- en: My learning philosophy
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的 学习哲学
- en: Most people learn complex topics best by imitation and repetition rather than
    reading a detailed explanation of the theory; therefore, I will not overload you
    with detailed explanations of every step throughout this book. The idea is to
    get you to write some code and see it run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人通过模仿和重复而不是阅读理论的详细解释来最好地学习复杂主题；因此，我不会在本书的每个步骤中提供详细的解释。目的是让你编写一些代码并看到它运行。
- en: You don’t need to know all the nitty-gritty details immediately. That will be
    something that comes with time as you build your own apps and go beyond what any
    book can teach you.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要立即了解所有细节。这些将在你构建自己的应用程序并超越任何书籍所能教授的内容的过程中随着时间的推移而逐渐了解。
- en: Fixing my mistakes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纠正我的错误
- en: In the words of Samuel Johnson, author of the English dictionary in 1755, I
    have committed “*a few wild blunders, and risible absurdities, from which no work
    of such multiplicity is free.*” I take sole responsibility for these and hope
    you appreciate the challenge of my attempt to lash the wind by writing this book
    about rapidly evolving technologies like C# and .NET, and the apps and services
    that you can build with them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用1755年编写英语词典的Samuel Johnson的话说，我已犯下“*一些荒谬的错误和可笑的荒谬，任何如此多的作品都无法避免*”。我对此承担全部责任，并希望你能欣赏我尝试通过撰写关于快速发展的技术（如C#和.NET）以及你可以用它们构建的应用和服务这本书的挑战。
- en: 'If you have an issue with something in this book, then please contact me before
    resorting to a negative review on Amazon. Authors cannot respond to Amazon reviews
    so I cannot contact you to resolve the problem. I want to help you to get the
    best from my book, and I want to listen to your feedback and do better in the
    next edition. Please email me (my email address can be found in the GitHub repository
    for the book), chat with me in the Discord channel for the book ([https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)),
    or raise an issue at the following link: [https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这本书的某个地方遇到问题，请在在亚马逊上发表负面评论之前联系我。作者无法回应亚马逊的评论，所以我无法联系你解决问题。我希望帮助你从我的书中获得最佳体验，我希望听取你的反馈并在下一版中做得更好。请通过电子邮件联系我（我的电子邮件地址可以在本书的GitHub仓库中找到），在本书的Discord频道中与我聊天（[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)），或在以下链接处提出问题：[https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues).
- en: Finding the solution code on GitHub
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在GitHub上找到解决方案代码
- en: 'The solution code in the GitHub repository for this book for all code editors
    is available at the following link: [https://github.com/markjprice/apps-services-net8/tree/main/code](https://github.com/markjprice/apps-services-net8/tree/main/code).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本书GitHub仓库中的所有代码编辑器的解决方案代码可通过以下链接获取：[https://github.com/markjprice/apps-services-net8/tree/main/code](https://github.com/markjprice/apps-services-net8/tree/main/code).
- en: Project naming and port numbering conventions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目命名和端口编号约定
- en: If you complete all the coding tasks in this book, then you will end up with
    dozens of projects. Many of those will be websites and services that require port
    numbers for hosting on the `localhost` domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你完成了本书中的所有编码任务，那么你最终将拥有数十个项目。其中许多将是需要端口号在`localhost`域上托管网站和服务。 '
- en: With large, complex solutions, it can be difficult to navigate the entire code.
    So, a good reason to structure your projects well is to make it easier to find
    components. It is good to have an overall name for your solution that reflects
    the application or solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型、复杂的项目，导航整个代码可能很困难。因此，良好的项目结构可以让你更容易找到组件。给你的解决方案起一个反映应用程序或解决方案的总体名称是很好的。
- en: In the 1990s, Microsoft registered **Northwind** as a fictional company name
    for use in database and code samples. It was first used as the sample database
    for their Access product and then also used in SQL Server. We will build multiple
    projects for this fictional company, so we will use the name `Northwind` as a
    prefix for all the project names.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪90年代，微软将**Northwind**注册为一个虚构公司名称，用于数据库和代码示例。它最初用作他们Access产品的示例数据库，后来也用于SQL
    Server。我们将为这个虚构公司构建多个项目，因此我们将使用名称`Northwind`作为所有项目名称的前缀。
- en: '**Good Practice**: There are many ways to structure and name projects and solutions,
    for example, using a folder hierarchy as well as a naming convention. If you work
    in a team, make sure you know how your team does it.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：有多种方式来组织和命名项目和解决方案，例如使用文件夹层次结构和命名约定。如果你在一个团队中工作，确保你知道你的团队是如何做的。'
- en: 'It is good to have a naming convention for your projects in a solution so that
    any developer can tell what each one does instantly. A common choice is to use
    the type of project, for example, class library, console app, website, and so
    on, as shown in *Table 1.1*:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案中为你的项目制定命名约定是很好的，这样任何开发者都可以立即知道每个项目的作用。一个常见的做法是使用项目类型，例如，类库、控制台应用程序、网站等，如*表1.1*所示：
- en: '| **Name** | **Description** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `Northwind.Common` | A class library project for common types like interfaces,
    enums, classes, records, and structs, used across multiple projects. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.Common` | 用于跨多个项目中的常见类型，如接口、枚举、类、记录和结构体的类库项目。 |'
- en: '| `Northwind.Common.EntityModels` | A class library project for common EF Core
    entity models. Entity models are often used on both the server and client side,
    so it is best to separate dependencies on specific database providers. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.Common.EntityModels` | 一个用于常见 EF Core 实体模型的类库项目。实体模型通常在服务器和客户端上都会使用，因此最好将特定数据库提供程序的依赖项分离。|'
- en: '| `Northwind.Common.DataContext` | A class library project for the EF Core
    database context with dependencies on specific database providers. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.Common.DataContext` | 一个用于 EF Core 数据库上下文的类库项目，依赖于特定的数据库提供程序。|'
- en: '| `Northwind.Mvc` | An ASP.NET Core project for a complex website that uses
    the MVC pattern and can be more easily unit tested. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.Mvc` | 一个使用 MVC 模式且易于单元测试的复杂网站 ASP.NET Core 项目。|'
- en: '| `Northwind.WebApi.Service` | An ASP.NET Core project for an HTTP API service.
    A good choice for integrating with websites because it can use any JavaScript
    library or Blazor to interact with the service. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.WebApi.Service` | 一个用于 HTTP API 服务的 ASP.NET Core 项目。由于它可以使用任何
    JavaScript 库或 Blazor 与服务交互，因此是一个很好的与网站集成的选择。|'
- en: '| `Northwind.WebApi.Client.Console` | A client to a web service. The last part
    of the name indicates that it is a console app. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.WebApi.Client.Console` | 一个 Web 服务的客户端。名称的最后部分表示它是一个控制台应用程序。|'
- en: '| `Northwind.gRPC.Service` | An ASP.NET Core project for a gRPC service. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.gRPC.Service` | 一个 ASP.NET Core gRPC 服务的项目。|'
- en: '| `Northwind.gRPC.Client.Mvc` | A client to a gRPC service. The last part of
    the name indicates that it is an ASP.NET Core MVC website project. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.gRPC.Client.Mvc` | 一个 gRPC 服务的客户端。名称的最后部分表示它是一个 ASP.NET Core MVC
    网站项目。|'
- en: '| `Northwind.BlazorWasm.Client` | An ASP.NET Core Blazor WebAssembly client-side
    project. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.BlazorWasm.Client` | 一个 ASP.NET Core Blazor WebAssembly 客户端项目。|'
- en: '| `Northwind.BlazorWasm.Server` | An ASP.NET Core Blazor WebAssembly server-side
    project. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.BlazorWasm.Server` | 一个 ASP.NET Core Blazor WebAssembly 服务器端项目。|'
- en: '| `Northwind.BlazorWasm.Shared` | A class library shared between client- and
    server-side Blazor projects. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Northwind.BlazorWasm.Shared` | 在客户端和服务器端 Blazor 项目之间共享的类库。|'
- en: 'Table 1.1: Example naming conventions for common project types'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：常见项目类型的命名约定示例
- en: 'To enable you to run any of these projects simultaneously, we must make sure
    that we do not configure duplicated port numbers. I have used the following convention:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您能够同时运行这些项目中的任何一个，我们必须确保我们不配置重复的端口号。我已经使用了以下约定：
- en: '`https://localhost:5[chapternumber]1/`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:5[chapternumber]1/`'
- en: '`http://localhost:5[chapternumber]2/`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:5[chapternumber]2/`'
- en: 'For example, for the encrypted connection to the website built in *Chapter
    14*, *Building Web User Interfaces Using ASP.NET Core*, I used port `5141`, as
    shown in the following link:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于在 *第 14 章* 中构建的网站加密连接，即 *使用 ASP.NET Core 构建网络用户界面*，我使用了端口 `5141`，如下面的链接所示：
- en: '`https://localhost:5141/`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://localhost:5141/`'
- en: Treating warnings as errors
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将警告视为错误
- en: By default, compiler warnings may appear if there are potential problems with
    your code when you first build a project, but they do not prevent compilation
    and they are hidden if you rebuild. Warnings are given for a reason, so ignoring
    warnings encourages poor development practices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在首次构建项目时，如果代码中存在潜在问题，编译器可能会显示警告，但它们不会阻止编译，并且在重新构建时会被隐藏。警告给出是有原因的，因此忽略警告会鼓励不良的开发实践。
- en: 'Some developers would prefer to be forced to fix warnings, so .NET provides
    a project setting to do this, as shown highlighted in the following markup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者可能更喜欢强制修复警告，因此 .NET 提供了一个项目设置来实现这一点，如下面的标记所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I have enabled the option to treat warnings as errors in (almost) all the solutions
    in the GitHub repository.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经启用了将警告视为错误的选项（几乎）在 GitHub 仓库中的所有解决方案中。
- en: 'The exceptions are the gRPC projects. This is due to a combination of factors.
    In .NET 7 or later, the compiler will warn if you compile source files that contain
    only lowercase letters in the name of a type. For example, if you define a `person`
    class, as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例外情况是 gRPC 项目。这是由于多种因素的综合作用。在 .NET 7 或更高版本中，如果编译的源文件中类型的名称只包含小写字母，编译器将会发出警告。例如，如果你定义一个
    `person` 类，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This compiler warning has been introduced so that a future version of C# can
    safely add a new keyword knowing it will not conflict with the name of a type
    that you have used because only C# keywords should contain only lowercase letters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 引入此编译器警告是为了确保未来的 C# 版本在安全地添加新关键字时不会与您已使用的类型名称冲突，因为只有 C# 关键字应该只包含小写字母。
- en: 'Unfortunately, the Google tools for generating C# source files from `.proto`
    files generate aliases for class names that only contain lowercase letters, as
    shown in the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Google用于从`.proto`文件生成C#源文件的工具为仅包含小写字母的类名生成别名，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you treat warnings as errors, then the compiler complains and refuses to
    compile the source code, as shown in the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将警告视为错误，那么编译器会抱怨并拒绝编译源代码，如下面的输出所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Good Practice**: Always treat warnings as errors in your .NET projects (except
    for gRPC projects until Google updates their code generation tools).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在您的.NET项目中始终将警告视为错误（除非是gRPC项目，直到Google更新其代码生成工具）。'
- en: 'If you find that you get too many errors after enabling this, you can disable
    specific warnings by using the `<WarningsNotAsErrors>` element with a comma-separated
    list of warning codes, as shown in the following markup:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现启用此功能后错误太多，你可以通过使用带有逗号分隔的警告代码列表的`<WarningsNotAsErrors>`元素来禁用特定的警告，如下面的标记所示：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**More Information**: You can learn more about controlling warnings as errors
    at the following link: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接中了解更多关于如何将警告视为错误的信息：[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/errors-warnings#warningsaserrors-and-warningsnotaserrors)。'
- en: App and service technologies
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用和服务技术
- en: Microsoft calls platforms for building applications and services **app models**
    or **workloads**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 微软将用于构建应用程序和服务的平台称为**应用模型**或**工作负载**。
- en: Understanding .NET
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解.NET
- en: '.NET, .NET Core, .NET Framework, and Xamarin are related and overlapping platforms
    for developers used to build applications and services. If you are not familiar
    with the history of .NET, then I will point you to each of these .NET concepts
    at the following link, which is from the *C# 12 and .NET 8 – Modern Cross-Platform
    Development Fundamentals* book:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: .NET、.NET Core、.NET Framework和Xamarin是开发人员用于构建应用程序和服务的相关且重叠的平台。如果您不熟悉.NET的历史，那么我将指向以下链接中的每个.NET概念，该链接来自《C#
    12和.NET 8 – 现代跨平台开发基础》一书：
- en: '[https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch01-dotnet-history.md)'
- en: Building websites and apps using ASP.NET Core
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core构建网站和应用程序
- en: Websites are made up of multiple web pages loaded statically from the filesystem
    or generated dynamically by a server-side technology such as ASP.NET Core. A web
    browser makes `GET` requests using **Unique Resource Locators** (**URLs**), which
    identify each page and can manipulate data stored on the server using `POST`,
    `PUT`, and `DELETE` requests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 网站由多个网页组成，这些网页可以从文件系统静态加载或由服务器端技术（如ASP.NET Core）动态生成。网络浏览器使用**唯一资源定位符**（**URLs**）进行`GET`请求，这些URL标识每个页面，并可以使用`POST`、`PUT`和`DELETE`请求来操作服务器上存储的数据。
- en: With many websites, the web browser is treated as a presentation layer, with
    almost all the processing performed on the server side. Some JavaScript might
    be used on the client side to implement some presentation features, such as carousels,
    or to perform data validation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多网站，网络浏览器被视为一个表示层，几乎所有处理都在服务器端进行。客户端可能会使用一些JavaScript来实现一些表示功能，例如轮播图，或者使用`POST`、`PUT`和`DELETE`请求来执行数据验证。
- en: 'ASP.NET Core provides multiple technologies for building websites:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core提供了多种技术来构建网站：
- en: '**ASP.NET Core Razor Pages** can dynamically generate HTML for simple websites.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core Razor Pages**可以动态生成简单网站的HTML。'
- en: '**ASP.NET Core MVC** is an implementation of the **Model-View-Controller**
    (**MVC**) design pattern, which is popular for developing complex websites. You
    will learn about using it to build user interfaces in *Chapter 14*, *Building
    Web User Interfaces Using ASP.NET Core*.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET Core MVC**是**模型-视图-控制器**（**MVC**）设计模式的实现，它对于开发复杂网站非常流行。您将在第14章“使用ASP.NET
    Core构建Web用户界面”中了解如何使用它来构建用户界面。'
- en: '**Razor class libraries** provide a way to package reusable functionality for
    ASP.NET Core projects including user interface components.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Razor类库**为ASP.NET Core项目提供了一种打包可重用功能的方法，包括用户界面组件。'
- en: '**Blazor** lets you build user interface components using C# and .NET and then
    run them in a web browser or embedded web component instead of a JavaScript-based
    UI framework like Angular, React, and Vue. You will learn about Blazor in detail
    in *Chapter 15*, *Building Web Components Using Blazor*, and an online-only section
    titled*Leveraging Open-Source Blazor Component Libraries*.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor** 允许您使用 C# 和 .NET 构建用户界面组件，然后在 Web 浏览器或嵌入式 Web 组件中运行，而不是像 Angular、React
    和 Vue 这样的基于 JavaScript 的 UI 框架。您将在第 15 章“使用 Blazor 构建 Web 组件”和仅在线部分“利用开源 Blazor
    组件库”中详细了解 Blazor。'
- en: Blazor is not just for building websites; it can also be used to create hybrid
    mobile and desktop apps when combined with .NET MAUI.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 不仅用于构建网站；当与 .NET MAUI 结合使用时，它还可以用于创建混合移动和桌面应用程序。
- en: This book assumes that you are already familiar with the fundamentals of ASP.NET
    Core development, so although the book reviews the basics, it quickly moves on
    to intermediate topics.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你已经熟悉 ASP.NET Core 开发的 fundamentals，因此尽管本书回顾了基础知识，但它很快就会转向中级主题。
- en: Building web and other services
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Web 和其他服务
- en: 'There are no formal definitions, but services are sometimes described based
    on their complexity:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有正式的定义，但服务有时会根据它们的复杂性来描述：
- en: '**Service**: All functionality needed by a client app in one monolithic service.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**: 客户端应用在一个单体服务中需要的所有功能。'
- en: '**Microservice**: Multiple services that each focus on a smaller set of functionalities.
    The guiding principle for what the boundary of functionality should be for a microservice
    is that each microservice should own its own data. Only that microservice should
    read/write to that data. If you have a data store that multiple services access,
    then they are not microservices.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务**: 每个都专注于较小功能集的多个服务。微服务功能边界的指导原则是每个微服务应拥有自己的数据。只有那个微服务应该读取/写入该数据。如果你有一个多个服务访问的数据存储，那么它们就不是微服务。'
- en: '**Nanoservice**: A single function provided as a service. Unlike services and
    microservices that are hosted 24/7/365, nanoservices are often inactive until
    called upon to reduce resources and costs. For this reason, they are also known
    as serverless services.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纳米服务**: 作为服务提供的一个单一功能。与 24/7/365 运行的服务和微服务不同，纳米服务通常在需要时才活跃，以减少资源和成本。因此，它们也被称为无服务器服务。'
- en: Although the theory of microservices and serverless services has made them a
    fashionable choice over the past decade or so, monolithic services have recently
    had a resurgence in popularity as developers have found the reality of microservices
    does not always match the theory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管过去十年左右，微服务和无服务器服务的理论使它们成为一种时尚的选择，但最近，随着开发者发现微服务的现实并不总是与理论相符，单体服务在流行度上有所回升。
- en: 'You will learn how to build ASP.NET Core Web API and Minimal API web services
    that use HTTP as the underlying communication technology and follow the design
    principles of Roy Field’s REST architecture. You will also learn how to build
    services using web and other technologies that extend basic web APIs, including:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何构建使用 HTTP 作为底层通信技术并遵循 Roy Field 的 REST 架构设计原则的 ASP.NET Core Web API 和
    Minimal API Web 服务。您还将学习如何使用 Web 和其他技术构建服务，这些服务扩展了基本 Web API，包括：
- en: '**gRPC**: For building highly efficient and performant microservices with support
    for almost any platform.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC**: 用于构建高度高效和性能的微服务，支持几乎任何平台。'
- en: '**SignalR**: For implementing real-time communications between components.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SignalR**: 用于实现组件之间的实时通信。'
- en: '**GraphQL**: For letting the client control what data is retrieved across multiple
    data sources. Although GraphQL can use HTTP, it does not have to, and it does
    not follow the web design principles defined by Roy Field in his dissertation
    about REST APIs.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL**: 允许客户端控制从多个数据源检索的数据。尽管 GraphQL 可以使用 HTTP，但它不必这样做，并且它不遵循 Roy Field
    在其关于 REST API 的论文中定义的 Web 设计原则。'
- en: '**Azure Functions**: For hosting serverless nanoservices in the cloud.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Functions**: 用于在云中托管无服务器纳米服务。'
- en: '**OData**: For easily wrapping EF Core and other data models as a web service.
    This is an online-only section.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OData**: 用于轻松将 EF Core 和其他数据模型包装成 Web 服务。这是一个仅在线的部分。'
- en: Windows Communication Foundation
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Communication Foundation
- en: In 2006, Microsoft released .NET Framework 3.0 with some major new frameworks,
    one of which was **Windows Communication Foundation** (**WCF**). It abstracted
    the business logic implementation of a service from the communication technology
    infrastructure so that you could easily switch to an alternative in the future
    or even have multiple mechanisms to communicate with the service.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，Microsoft发布了.NET Framework 3.0，其中包含一些主要的新框架，其中之一是**Windows Communication
    Foundation** (**WCF**)。它将服务的业务逻辑实现从通信技术基础设施中抽象出来，这样你就可以轻松地在未来切换到替代方案，甚至拥有多个与服务通信的机制。
- en: WCF heavily uses XML configuration to declaratively define endpoints, including
    their address, binding, and contract. This is known as the ABCs of WCF endpoints.
    Once you understand how to do this, WCF is a powerful yet flexible technology.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: WCF大量使用XML配置来声明性地定义端点，包括它们的地址、绑定和合约。这被称为WCF端点的ABC。一旦你了解了如何做这件事，WCF就是一个强大而灵活的技术。
- en: Microsoft decided not to officially port WCF to modern .NET, but there is a
    community-owned OSS project named **CoreWCF** managed by the .NET Foundation.
    If you need to migrate an existing service from .NET Framework to modern .NET
    or build a client to a WCF service, then you can use CoreWCF. Be aware that it
    can never be a full port since parts of WCF are Windows-specific.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft决定不正式将WCF移植到现代.NET，但有一个由.NET基金会管理的社区拥有的开源项目名为**CoreWCF**。如果您需要将现有的服务从.NET
    Framework迁移到现代.NET或构建WCF服务的客户端，则可以使用CoreWCF。请注意，它永远不能是一个完整的移植，因为WCF的部分是Windows特定的。
- en: Technologies like WCF allow for the building of distributed applications. A
    client application can make **remote procedure calls** (**RPCs**) to a server
    application. Instead of using a port of WCF to do this, we should use an alternative
    RPC technology like gRPC, which is covered in this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于WCF的技术允许构建分布式应用程序。客户端应用程序可以向服务器应用程序进行**远程过程调用** (**RPC**)。而不是使用WCF的端口来做这件事，我们应该使用像gRPC这样的替代RPC技术，这在本书中有介绍。
- en: '**More Information**: You can learn more about CoreWCF in its GitHub repository
    found at the following link: [https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF).
    You can read the announcement about client support for calling WCF or CoreWCF
    with System.ServiceModel 6.0 at the following link: [https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/](https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：您可以在以下链接的GitHub仓库中了解更多关于CoreWCF的信息：[https://github.com/CoreWCF/CoreWCF](https://github.com/CoreWCF/CoreWCF)。您可以在以下链接中阅读有关使用System.ServiceModel
    6.0调用WCF或CoreWCF客户端支持的公告：[https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/](https://devblogs.microsoft.com/dotnet/wcf-client-60-has-been-released/)。'
- en: Common service principles
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见服务原则
- en: One of the most important service architecture principles is to make method
    calls chunky instead of chatty. In other words, try to bundle all the data needed
    for an operation in a single call, rather than requiring multiple calls to transmit
    all that information. This is because the overhead of a remote call is one of
    the biggest negative effects of services. This is also why having smaller and
    smaller services can hugely negatively impact a solution architecture.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的服务架构原则之一是使方法调用变得厚重而不是琐碎。换句话说，尽量将操作所需的所有数据捆绑在一个调用中，而不是需要多个调用来传输所有这些信息。这是因为远程调用的开销是服务最大的负面影响之一。这也是为什么越来越小的服务会极大地负面影响解决方案架构。
- en: Summary of choices for services
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务选择总结
- en: 'Each service technology has its pros and cons based on its feature support,
    as shown in *Table 1.2*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每种服务技术都有其优缺点，这取决于其功能支持，如*表1.2*所示：
- en: '| **Feature** | **Web API** | **OData** | **GraphQL** | **gRPC** | **SignalR**
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **Web API** | **OData** | **GraphQL** | **gRPC** | **SignalR** |'
- en: '| Clients can request just the data they need | No | Yes | Yes | No | No |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 客户端可以请求所需的数据 | 否 | 是 | 是 | 否 | 否 |'
- en: '| Minimum HTTP version | 1.1 | 1.1 | 1.1 | 2.0 | 1.1 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 最小HTTP版本 | 1.1 | 1.1 | 1.1 | 2.0 | 1.1 |'
- en: '| Browser support | Yes | Yes | Yes | No | Yes |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器支持 | 是 | 是 | 是 | 否 | 是 |'
- en: '| Data format | XML, JSON | XML, JSON | GraphQL (JSONish) | Binary | Varies
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 数据格式 | XML, JSON | XML, JSON | GraphQL (JSONish) | 二进制 | 多样 |'
- en: '| Service documentation | Swagger | Swagger | No | No | No |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 服务文档 | Swagger | Swagger | 无 | 无 | 无 |'
- en: '| Code generation | Third-party | Third-party | Third-party | Google | Microsoft
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 代码生成 | 第三方 | 第三方 | 第三方 | Google | Microsoft |'
- en: '| Caching | Easy | Easy | Hard | Hard | Hard |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 缓存 | 简单 | 简单 | 困难 | 困难 | 困难 |'
- en: 'Table 1.2: Pros and cons of common service technologies'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.2：常见服务技术的优缺点
- en: 'Use these recommendations for various scenarios as guidance, as shown in *Table
    1.3*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些针对各种场景的建议作为指导，如下所示 *表1.3*：
- en: '| **Scenario** | **Recommendation** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **场景** | **建议** |'
- en: '| Public service | HTTP/1.1-based services are best for services that need
    to be publicly accessible, especially if they need to be called from a browser
    or mobile device. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 公共服务 | 基于HTTP/1.1的服务最适合需要公开访问的服务，特别是如果它们需要从浏览器或移动设备调用。 |'
- en: '| Public data service | OData and GraphQL are both good choices for exposing
    complex hierarchical datasets that could come from different data stores. OData
    is designed and supported by Microsoft via official .NET packages. GraphQL is
    designed by Facebook and supported by third-party packages. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 公共数据服务 | OData和GraphQL都是暴露来自不同数据存储的复杂层次数据集的好选择。OData由微软通过官方.NET包设计和支持。GraphQL由Facebook设计并由第三方包支持。
    |'
- en: '| Service-to-service | gRPC is designed for low-latency and high-throughput
    communication. gRPC is great for lightweight internal microservices where efficiency
    is critical. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 服务到服务 | gRPC是为低延迟和高吞吐量通信设计的。gRPC非常适合轻量级内部微服务，其中效率至关重要。 |'
- en: '| Point-to-point real-time communication | gRPC has excellent support for bidirectional
    streaming. gRPC services can push messages in real time without polling. SignalR
    is designed for real-time communication of many kinds, so it tends to be easier
    to implement than gRPC although it is less efficient. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 点对点实时通信 | gRPC对双向流提供了出色的支持。gRPC服务可以实时推送消息而不需要轮询。SignalR是为多种实时通信设计的，因此它通常比gRPC更容易实现，尽管效率较低。
    |'
- en: '| Broadcast real-time communication | SignalR has great support for broadcasting
    real-time communication to many clients. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 广播实时通信 | SignalR对向多个客户端广播实时通信提供了很好的支持。 |'
- en: '| Polyglot environment | gRPC tooling supports all popular development languages,
    making gRPC a good choice for multi-language and platform environments. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 多语言环境 | gRPC工具支持所有流行的开发语言，使gRPC成为多语言和平台环境的好选择。 |'
- en: '| Network-bandwidth-constrained environment | gRPC messages are serialized
    with Protobuf, a lightweight message format. A gRPC message is always smaller
    than an equivalent JSON message. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 网络带宽受限环境 | gRPC消息使用轻量级消息格式Protobuf进行序列化。gRPC消息始终小于等效的JSON消息。 |'
- en: '| Serverless nanoservice | Azure Functions do not need to be hosted 24/7 so
    they are a good choice for nanoservices that usually do not need to be running
    constantly. **Amazon Web Services** (**AWS**) Lambdas are an alternative. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 无服务器纳米服务 | Azure Functions不需要24/7托管，因此它们是适合通常不需要持续运行的小型服务的良好选择。**亚马逊网络服务**（**AWS**）Lambdas是一个替代方案。
    |'
- en: 'Table 1.3: Service scenarios and the recommended implementation technology'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3：服务场景和推荐实现技术
- en: Building Windows-only apps
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建仅适用于Windows的应用程序
- en: 'Technologies for building Windows-only apps, primarily for desktop, include:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 构建仅适用于Windows的应用程序的技术，主要用于桌面，包括：
- en: '**Windows Forms**, 2002'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows窗体**，2002'
- en: '**Windows Presentation Foundation** (**WPF**), 2006'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows表现层基础**（**WPF**），2006'
- en: '**Windows Store**, 2012'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows商店**，2012'
- en: '**Universal Windows Platform** (**UWP**), 2015'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用Windows平台**（**UWP**），2015'
- en: '**Windows App SDK** (formerly **WinUI 3** and **Project Reunion**), 2021'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows应用SDK**（以前称为**WinUI 3**和**Project Reunion**），2021'
- en: Understanding legacy Windows application platforms
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解遗留的Windows应用程序平台
- en: With the Microsoft Windows 1.0 release in 1985, the only way to create Windows
    applications was to use the C language and call functions in three core DLLs named
    `KERNEL`, `USER`, and `GDI`. Once Windows became 32-bit with Windows 95, the DLLs
    were suffixed with 32 and became known as **Win32 API**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1985年，随着Microsoft Windows 1.0的发布，创建Windows应用程序的唯一方式是使用C语言并调用名为`KERNEL`、`USER`和`GDI`的三个核心DLL中的函数。一旦Windows在Windows
    95中成为32位，DLLs被添加了32后缀，并被称为**Win32 API**。
- en: In 1991, Microsoft introduced Visual Basic, which provided developers with a
    visual, drag-and-drop-from-a-toolbox-of-controls way to build the user interface
    for Windows applications. It was immensely popular, and the Visual Basic runtime
    is still distributed as part of Windows 11 today.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年，微软推出了Visual Basic，它为开发者提供了一种视觉化的、从控件工具箱中拖放的方式来构建Windows应用程序的用户界面。它非常受欢迎，并且Visual
    Basic运行时至今仍然是Windows 11的一部分。
- en: With the first version of C# and .NET Framework released in 2002, Microsoft
    provided technology for building Windows desktop applications named **Windows
    Forms**. The equivalent at the time for web development was named **Web Forms**,
    hence the complementary names. The code could be written in either Visual Basic
    or C# languages. Windows Forms had a similar drag-and-drop visual designer, although
    it generated C# or Visual Basic code to define the user interface, which can be
    difficult for humans to understand and edit directly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2002 年首次发布 C# 和 .NET Framework 时，微软提供了名为 **Windows 表单** 的技术来构建 Windows 桌面应用程序。当时用于
    Web 开发的技术被称为 **Web 表单**，因此名称互补。代码可以用 Visual Basic 或 C# 语言编写。Windows 表单有一个类似的拖放可视化设计器，尽管它生成
    C# 或 Visual Basic 代码来定义用户界面，这对于人类来说可能难以理解和直接编辑。
- en: In 2006, Microsoft released a more powerful technology for building Windows
    desktop applications, named **Windows Presentation Foundation** (**WPF**), as
    a key component of .NET Framework 3.0 alongside **WCF** and Windows **Workflow**
    (**WF**).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 2006 年，微软发布了一种用于构建 Windows 桌面应用程序的更强大技术，名为 **Windows 表现基金会** (**WPF**)，作为 .NET
    Framework 3.0 的关键组件之一，与 **WCF** 和 Windows **工作流** (**WF**) 并列。
- en: Although a WPF app can be created by writing only C# statements, it can also
    use **eXtensible Application Markup Language** (**XAML**) to specify its user
    interface, which is easy for both humans and code to understand. Visual Studio
    2022 is partially built with WPF.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以通过仅编写 C# 语句来创建 WPF 应用程序，但它也可以使用 **可扩展应用程序标记语言** (**XAML**) 来指定其用户界面，这对于人类和代码来说都很容易理解。Visual
    Studio 2022 部分是基于 WPF 构建的。
- en: In 2012, Microsoft released Windows 8 with its Windows Store apps that run in
    a protected sandbox.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 2012 年，微软发布了 Windows 8，并附带其 Windows Store 应用程序，这些应用程序在受保护的沙盒中运行。
- en: In 2015, Microsoft released Windows 10 with an updated Windows Store app concept
    named **Universal Windows Platform** (**UWP**). UWP apps can be built using C++
    and DirectX UI, JavaScript and HTML, or C# using a custom fork of modern .NET
    that is not cross-platform but provides full access to the underlying WinRT APIs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，微软发布了 Windows 10，并更新了名为 **通用 Windows 平台** (**UWP**) 的 Windows Store 应用程序概念。UWP
    应用程序可以使用 C++ 和 DirectX UI、JavaScript 和 HTML 或 C#（使用非跨平台的现代 .NET 的自定义分支）来构建。UWP
    应用程序可以访问底层 WinRT API。
- en: UWP apps can only execute on the Windows 10 or Windows 11 platforms, not earlier
    versions of Windows, but UWP apps can run on Xbox and Windows Mixed Reality headsets
    with motion controllers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: UWP 应用程序只能在 Windows 10 或 Windows 11 平台上运行，不能在 Windows 的早期版本上运行，但 UWP 应用程序可以在配备运动控制器的
    Xbox 和 Windows 混合现实头戴式设备上运行。
- en: Many Windows developers rejected Windows Store and UWP apps because they have
    limited access to the underlying system. Microsoft recently created **Project
    Reunion** and **WinUI 3**, which work together to allow Windows developers to
    bring some of the benefits of modern Windows development to their existing WPF
    apps and allow them to have the same benefits and system integrations that UWP
    apps have. This initiative is now known as **Windows App SDK**.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Windows 开发者拒绝了 Windows Store 和 UWP 应用程序，因为他们对底层系统的访问有限。微软最近创建了 **Project
    Reunion** 和 **WinUI 3**，这两个项目协同工作，允许 Windows 开发者将现代 Windows 开发的部分好处带到他们的现有 WPF
    应用程序中，并使他们能够享有与 UWP 应用程序相同的利益和系统集成。这一举措现在被称为 **Windows App SDK**。
- en: '**More Information**: This book does not cover Windows App SDK because it is
    not cross-platform. If you would like to learn more, you can start at the following
    link: [https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/](https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**：本书不涵盖 Windows App SDK，因为它不是跨平台的。如果您想了解更多信息，可以从以下链接开始：[https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/](https://learn.microsoft.com/en-us/windows/apps/windows-app-sdk/)。'
- en: Understanding modern .NET support for legacy Windows platforms
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解现代 .NET 对遗留 Windows 平台的支持
- en: The on-disk size of the .NET SDKs for Linux and macOS is about 330 MB. The on-disk
    size of the .NET SDK for Windows is about 440 MB. This is because it includes
    **.NET Desktop Runtime**, which allows the legacy Windows application platforms
    Windows Forms and WPF to be run on modern .NET.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: .NET SDK 对于 Linux 和 macOS 的磁盘大小约为 330 MB。.NET SDK 对于 Windows 的磁盘大小约为 440 MB。这是因为它包括
    **.NET 桌面运行时**，它允许遗留 Windows 应用程序平台 Windows Forms 和 WPF 在现代 .NET 上运行。
- en: 'There are many enterprise applications built using Windows Forms and WPF that
    need to be maintained or enhanced with new features, but until recently they were
    stuck on .NET Framework, which is now a legacy platform. With modern .NET and
    its .NET Desktop Runtime, these apps can now use the full modern capabilities
    of .NET. Windows desktop app developers can also optionally install the Windows
    Compatibility Pack. You can learn more about this at the following link: [https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack](https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows Forms 和 WPF 构建的许多企业应用程序需要维护或增强新功能，但直到最近，它们都卡在 .NET Framework 上，这是一个现在的遗留平台。随着现代
    .NET 和其 .NET Desktop Runtime，这些应用程序现在可以使用 .NET 的全部现代功能。Windows 桌面应用程序开发者还可以选择安装
    Windows 兼容包。您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack](https://learn.microsoft.com/en-us/dotnet/core/porting/windows-compat-pack)。
- en: Building cross-platform mobile and desktop apps
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建跨平台移动和桌面应用程序
- en: 'There are two major mobile platforms, Apple’s iOS and Google’s Android, each
    with its own programming languages and platform APIs. There are also two major
    desktop platforms, Apple’s macOS and Microsoft’s Windows, each with its own programming
    languages and platform APIs, as shown in the following list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要的移动平台，苹果的 iOS 和谷歌的 Android，每个都有自己的编程语言和平台 API。还有两个主要的桌面平台，苹果的 macOS 和微软的
    Windows，每个都有自己的编程语言和平台 API，如下所示：
- en: '**iOS**: Objective-C or Swift and UIkit'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：Objective-C 或 Swift 和 UIkit'
- en: '**Android**: Java or Kotlin and Android API'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：Java 或 Kotlin 和 Android API'
- en: '**macOS**: Objective-C or Swift and AppKit or Catalyst'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**：Objective-C 或 Swift 和 AppKit 或 Catalyst'
- en: '**Windows**: C, C++, or many other languages and Win32 API or Windows App SDK'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**：C、C++ 或许多其他语言和 Win32 API 或 Windows App SDK'
- en: Cross-platform mobile and desktop apps can be built once for the **.NET Multi-platform
    App UI** (**MAUI**) platform and then can run on many mobile and desktop platforms.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以一次性为 **.NET Multi-platform App UI** (**MAUI**) 平台构建跨平台移动和桌面应用程序，然后可以在许多移动和桌面平台上运行。
- en: .NET MAUI makes it easy to develop those apps by sharing user interface components
    as well as business logic; they can target the same .NET APIs as used by console
    apps, websites, and web services.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 通过共享用户界面组件以及业务逻辑，使开发这些应用程序变得容易；它们可以针对与控制台应用程序、网站和 Web 服务相同的 .NET API。
- en: The apps can exist standalone, but they usually call services to provide an
    experience that spans all your computing devices, from servers and laptops to
    phones and gaming systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以独立存在，但它们通常调用服务以提供跨越所有计算设备（从服务器和笔记本电脑到手机和游戏系统）的体验。
- en: '.NET MAUI supports existing MVVM and XAML patterns. The team also plans to
    add support in the future for **Model-View-Update** (**MVU**) with C#, which is
    like Apple’s Swift UI. MVU using Comet is still only a proof of concept. It is
    not as mature or well supported as Swift UI. I will not cover it in this book.
    You can read more about it at the following link: [https://github.com/dotnet/Comet](https://github.com/dotnet/Comet).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 支持现有的 MVVM 和 XAML 模式。团队还计划在未来添加对 C# 的 **Model-View-Update** (**MVU**)
    的支持，类似于苹果的 SwiftUI。使用 Comet 的 MVU 仍然只是一个概念验证。它不如 SwiftUI 成熟或得到良好的支持。我不会在本书中介绍它。您可以在以下链接中了解更多信息：[https://github.com/dotnet/Comet](https://github.com/dotnet/Comet)。
- en: .NET MAUI alternatives
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI 替代方案
- en: Before Microsoft created .NET MAUI, third parties created open-source initiatives
    to enable .NET developers to build cross-platform apps using XAML, named **Uno**
    and **Avalonia**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在微软创建 .NET MAUI 之前，第三方创建了开源项目，以使 .NET 开发者能够使用 XAML 构建跨平台应用程序，名为 **Uno** 和 **Avalonia**。
- en: Understanding the Uno platform
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Uno 平台
- en: 'Uno is “*the first C# & XAML, free and open-source platform for creating true
    single-source, multi-platform applications*,” as stated on its own website at
    the following link: [https://platform.uno/](https://platform.uno/).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Uno 被称为“*第一个真正的单源、跨平台应用程序的 C# & XAML、免费和开源平台*”，正如其官方网站上所述，以下链接：[https://platform.uno/](https://platform.uno/)。
- en: Developers can reuse 99% of the business logic and UI layer across native mobile,
    web, and desktop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以在原生移动、Web 和桌面之间重用 99% 的业务逻辑和 UI 层。
- en: The Uno platform uses the Xamarin native platform but not Xamarin.Forms. For
    WebAssembly, Uno uses the mono-wasm runtime just like Blazor WebAssembly. For
    Linux, Uno uses Skia to draw the user interface on the canvas.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Uno 平台使用的是 Xamarin 本地平台，而不是 Xamarin.Forms。对于 WebAssembly，Uno 使用与 Blazor WebAssembly
    相同的 mono-wasm 运行时。对于 Linux，Uno 使用 Skia 在画布上绘制用户界面。
- en: 'A book to read to learn about the Uno platform can be found at the following
    link: [https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498](https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下链接找到一本关于 Uno 平台的书：[https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498](https://www.packtpub.com/product/creating-cross-platform-c-applications-with-uno-platform/9781801078498)。
- en: Understanding Avalonia
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 Avalonia
- en: 'Avalonia “*is a cross-platform UI framework for .NET. It creates pixel-perfect,
    native apps*” and “*is supported on all major platforms*.” Avalonia “*is the trusted
    UI framework for complex apps*,” as stated on its official website home page at
    the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Avalonia “*是一个跨平台的 UI 框架，适用于 .NET。它创建像素级的、原生应用程序*”并且“*支持所有主要平台*。”Avalonia “*是复杂应用程序的受信任
    UI 框架*”，正如其官方网站首页所述，以下链接：[https://avaloniaui.net/](https://avaloniaui.net/)。
- en: You can think of Avalonia as a spiritual successor to WPF. WPF, Silverlight,
    and UWP developers can continue to benefit from their years of pre-existing knowledge
    and skills.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Avalonia 视为 WPF 的精神继承者。WPF、Silverlight 和 UWP 开发者可以继续从他们多年的现有知识和技能中受益。
- en: It was used by JetBrains to modernize their legacy WPF-based tools and take
    them cross-platform. This means their C# code editor runs on Windows, macOS, and
    Linux.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它被 JetBrains 用于现代化他们的基于 WPF 的旧工具并将它们移植到跨平台。这意味着他们的 C# 代码编辑器可以在 Windows、macOS
    和 Linux 上运行。
- en: The Avalonia extension for Visual Studio 2022 and deep integration with JetBrains
    Rider makes development easier and more productive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Avalonia 扩展程序适用于 Visual Studio 2022，并与 JetBrains Rider 深度集成，这使得开发更加容易和高效。
- en: Now that we’ve reviewed the theory about the apps and services technologies
    that can be used with .NET 8, let’s get practical and see how you can set up your
    development environment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了可用于 .NET 8 的应用程序和服务技术理论，让我们来实际操作，看看如何设置你的开发环境。
- en: Setting up your development environment
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的开发环境
- en: 'Before you start programming, you’ll need a code editor for C#. Microsoft has
    a family of code editors and **Integrated Development Environments** (**IDEs**),
    which include:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编程之前，你需要一个用于 C# 的代码编辑器。微软有一系列代码编辑器和**集成开发环境**（**IDEs**），其中包括：
- en: Visual Studio 2022 for Windows
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 系统的 Visual Studio 2022
- en: Visual Studio Code for Windows, Mac, or Linux
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 适用于 Windows、Mac 或 Linux
- en: Visual Studio Code for the Web or GitHub Codespaces
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页或 GitHub Codespaces 的 Visual Studio Code
- en: Third parties have created their own C# code editors, for example, JetBrains
    Rider, which is available for Windows, Mac, or Linux but does have a license cost.
    JetBrains Rider is popular with more experienced .NET developers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方创建了他们自己的 C# 代码编辑器，例如 JetBrains Rider，它适用于 Windows、Mac 或 Linux，但确实需要付费许可。JetBrains
    Rider 在经验更丰富的 .NET 开发者中很受欢迎。
- en: '**Warning!** Although JetBrains is a fantastic company with great products,
    both Rider and the ReSharper extension for Visual Studio are software, and all
    software has bugs and quirky behavior. For example, they might show errors like
    “Cannot resolve symbol” in your Razor Pages, Razor views, and Blazor components.
    Yet you can build and run those files because there is no actual problem. If you
    have installed the Unity Support plugin, then it will complain about boxing operations,
    which are a genuine problem for Unity game developers. But in this book we will
    not create any Unity projects so the boxing warnings do not apply.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**虽然 JetBrains 是一家出色的公司，拥有优秀的产品，但 Rider 和 Visual Studio 的 ReSharper 扩展都是软件，所有软件都有错误和古怪的行为。例如，它们可能会在你的
    Razor 页面、Razor 视图和 Blazor 组件中显示“无法解析符号”等错误。然而，你可以构建和运行这些文件，因为没有真正的问题。如果你安装了 Unity
    支持插件，那么它将抱怨装箱操作，这对于 Unity 游戏开发者来说是一个真正的问题。但在这本书中，我们不会创建任何 Unity 项目，因此装箱警告不适用。'
- en: In *Chapters 1* to *15*, you can use Visual Studio 2022 or cross-platform Visual
    Studio Code and JetBrains Rider to build all the apps and services. In *Chapter
    16*, *Building Mobile and Desktop Apps Using .NET MAUI*; and its *online sections*,
    *Implementing Model-View-ViewModel for .NET MAUI* and *Integrating .NET MAUI Apps
    with Blazor and Native Platforms*, although you could use Visual Studio Code to
    build the mobile and desktop app, it is not easy. Visual Studio 2022 has better
    support for .NET MAUI than Visual Studio Code does (for now).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 *1* 章到 *15* 章，您可以使用 Visual Studio 2022 或跨平台的 Visual Studio Code 和 JetBrains
    Rider 来构建所有应用程序和服务。在第 *16* 章，*使用 .NET MAUI 构建移动和桌面应用程序*；以及其 *在线部分*，*实现 .NET MAUI
    的模型-视图-视图模型*和*将 .NET MAUI 应用程序与 Blazor 和原生平台集成*，尽管您可以使用 Visual Studio Code 来构建移动和桌面应用程序，但这并不容易。目前，Visual
    Studio 2022 对 .NET MAUI 的支持比 Visual Studio Code 更好。
- en: Choosing the appropriate tool and application type for learning
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的工具和应用程序类型进行学习
- en: What is the best tool and application type for building apps and services with
    C# and .NET?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 和 .NET 构建应用程序和服务时，最好的工具和应用程序类型是什么？
- en: I want you to be free to choose any C# code editor or IDE to complete the coding
    tasks in this book, including Visual Studio Code, Visual Studio 2022, or even
    JetBrains Rider.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您能够自由选择任何 C# 代码编辑器或 IDE 来完成这本书中的编码任务，包括 Visual Studio Code、Visual Studio
    2022，甚至是 JetBrains Rider。
- en: In this book, I give general instructions that work with all tools so you can
    use whichever tool you prefer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我提供了适用于所有工具的通用说明，这样您就可以使用您偏好的任何工具。
- en: Using Visual Studio 2022 for general development
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 进行通用开发
- en: Visual Studio 2022 can create most types of applications, including console
    apps, websites, web services, desktop, and mobile apps.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 可以创建大多数类型的应用程序，包括控制台应用程序、网站、网络服务、桌面和移动应用程序。
- en: Although you can use Visual Studio 2022 with a .NET MAUI project to write a
    cross-platform mobile app, you still need macOS and Xcode to compile it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用 Visual Studio 2022 和 .NET MAUI 项目来编写跨平台移动应用程序，但您仍然需要 macOS 和 Xcode 来编译它。
- en: Visual Studio 2022 only runs on Windows 10 version 1909 or later, or Windows
    Server 2016 or later, and only on 64-bit versions. Version 17.4 is the first version
    to support native Arm64.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2022 仅在 Windows 10 版本 1909 或更高版本、Windows Server 2016 或更高版本以及 64
    位版本上运行。17.4 版本是第一个支持原生 Arm64 的版本。
- en: '**Warning!** Visual Studio 2022 for Mac does not officially support .NET 8
    and it will reach end-of-life in August 2024\. If you have been using Visual Studio
    2022 for Mac then you should switch to Visual Studio Code for Mac, JetBrains Rider
    for Mac, or use Visual Studio 2022 for Windows in a virtual machine on your local
    computer or in the cloud using a technology like Microsoft Dev Box. The retirement
    announcement can be read here: [https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/](https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** Visual Studio 2022 for Mac 并未官方支持 .NET 8，并且它将在 2024 年 8 月达到生命周期的终点。如果您一直在使用
    Visual Studio 2022 for Mac，那么您应该切换到 Visual Studio Code for Mac、JetBrains Rider
    for Mac，或者在使用虚拟机的情况下在本地计算机上使用 Visual Studio 2022 for Windows，或者在云中使用类似 Microsoft
    Dev Box 的技术。退休公告可以在此处阅读：[https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/](https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/)。'
- en: Using Visual Studio Code for cross-platform development
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 进行跨平台开发
- en: The most modern and lightweight code editor to choose from, and the only one
    from Microsoft that is cross-platform, is Visual Studio Code. It can run on all
    common operating systems, including Windows, macOS, and many varieties of Linux,
    including **Red Hat Enterprise Linux** (**RHEL**) and Ubuntu.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可供选择的最现代和轻量级的代码编辑器，并且是微软唯一一个跨平台的编辑器是 Visual Studio Code。它可以在所有常见的操作系统上运行，包括
    Windows、macOS 以及许多 Linux 变体，包括 **红帽企业 Linux**（**RHEL**）和 Ubuntu。
- en: Visual Studio Code is a good choice for modern cross-platform development because
    it has an extensive and growing set of extensions to support many languages beyond
    C#.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是现代跨平台开发的良好选择，因为它拥有广泛且不断增长的扩展集，支持许多超出 C# 的语言。
- en: Being cross-platform and lightweight, it can be installed on all platforms that
    your apps will be deployed to for quick bug fixes and so on. Choosing Visual Studio
    Code means a developer can use a cross-platform code editor to develop cross-platform
    apps.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其跨平台和轻量级特性，它可以在您的应用程序将部署到的所有平台上安装，以便快速修复错误等。选择 Visual Studio Code 意味着开发者可以使用跨平台代码编辑器来开发跨平台应用程序。
- en: Visual Studio Code has strong support for web development, although it currently
    has weak support for mobile and desktop development.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 对 Web 开发有很强的支持，尽管它目前对移动和桌面开发的支持较弱。
- en: Visual Studio Code is supported on ARM processors, so you can develop on Apple
    Silicon computers and Raspberry Pi.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 支持ARM处理器，因此您可以在苹果硅电脑和树莓派上开发。
- en: 'Visual Studio Code is by far the most popular integrated development environment,
    with over 73% of professional developers selecting it in the Stack Overflow 2023
    survey that you can read at the following link: [https://survey.stackoverflow.co/2023/](https://survey.stackoverflow.co/2023/).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 是迄今为止最受欢迎的集成开发环境，根据 Stack Overflow 2023 调查，超过 73% 的专业开发者选择了它，您可以在以下链接中阅读调查结果：[https://survey.stackoverflow.co/2023/](https://survey.stackoverflow.co/2023/).
- en: Using GitHub Codespaces for development in the cloud
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在云端使用 GitHub Codespaces 进行开发
- en: GitHub Codespaces is a fully configured development environment based on Visual
    Studio Code that can be spun up in an environment hosted in the cloud and accessed
    through any web browser. It supports Git repos, extensions, and a built-in command-line
    interface so you can edit, run, and test from any device.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Codespaces 是一个基于 Visual Studio Code 的完全配置的开发环境，可以在云中托管的环境中启动，并通过任何网络浏览器访问。它支持
    Git 仓库、扩展和内置的命令行界面，因此您可以从任何设备进行编辑、运行和测试。
- en: '**More Information**: You can learn more about GitHub Codespaces at the following
    link: [https://github.com/features/codespaces](https://github.com/features/codespaces).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多信息**: 您可以在以下链接中了解更多关于 GitHub Codespaces 的信息：[https://github.com/features/codespaces](https://github.com/features/codespaces).'
- en: What I used
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我所使用的
- en: 'To write and test the code for this book, I used the following hardware and
    software:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写和测试本书的代码，我使用了以下硬件和软件：
- en: 'Visual Studio 2022 for Windows on:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 上的 Visual Studio 2022：
- en: Windows 11 on the HP Spectre (Intel) laptop
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惠普 Spectre (Intel) 笔记本电脑上的 Windows 11
- en: 'Visual Studio Code on:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code 在：
- en: macOS on the Apple Silicon Mac mini (M1) desktop
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果硅 Mac mini (M1) 上的 macOS
- en: Windows 11 on the HP Spectre (Intel) laptop
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惠普 Spectre (Intel) 笔记本电脑上的 Windows 11
- en: 'JetBrains Rider on:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider 在：
- en: Windows 11 on the HP Spectre (Intel) laptop
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惠普 Spectre (Intel) 笔记本电脑上的 Windows 11
- en: macOS on the Apple Silicon Mac mini (M1) desktop
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果硅 Mac mini (M1) 桌面上的 macOS
- en: I hope that you have access to a variety of hardware and software too because
    seeing the differences on various platforms deepens your understanding of development
    challenges, although any one of the above combinations is enough to learn how
    to build practical apps and websites.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您也能访问各种硬件和软件，因为看到不同平台上的差异可以加深您对开发挑战的理解，尽管上述任何一种组合都足以学习如何构建实用的应用程序和网站。
- en: '**Getting Started**: *Chapter 1* of the *C# 12 and .NET 8 – Modern Cross-Platform
    Development Fundamentals* book has online sections showing how to get started
    with multiple projects using various code editors like Visual Studio 2022, Visual
    Studio Code, or JetBrains Rider. You can read the sections at the following link:
    [https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**入门指南**: 《C# 12 和 .NET 8 – 现代跨平台开发基础》一书的*第一章*包含在线部分，展示了如何使用各种代码编辑器（如 Visual
    Studio 2022、Visual Studio Code 或 JetBrains Rider）开始多个项目的操作。您可以在以下链接中阅读这些部分：[https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/code-editors/README.md).'
- en: JetBrains Rider and its warnings about boxing
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JetBrains Rider 及其关于装箱的警告
- en: 'If you use JetBrains Rider and you have installed the Unity Support plugin,
    then it will complain a lot about boxing. A common scenario when boxing happens
    is when value types like `int` and `DateTime` are passed as positional arguments
    to `string` formats. This is a problem for Unity projects because they use a different
    memory garbage collector to the normal .NET runtime. For non-Unity projects, like
    all the projects in this book, you can ignore these boxing warnings because they
    are not relevant. You can read more about this Unity-specific issue at the following
    link: [https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用JetBrains Rider并且已安装Unity支持插件，那么它会对装箱问题抱怨很多。装箱发生的一个常见场景是将像`int`和`DateTime`这样的值类型作为位置参数传递给`string`格式。这对于Unity项目来说是一个问题，因为它们使用与正常.NET运行时不同的内存垃圾回收器。对于非Unity项目，如本书中的所有项目，您可以忽略这些装箱警告，因为它们与您无关。您可以在以下链接中了解更多关于此Unity特定问题的信息：[https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing](https://docs.unity3d.com/Manual/performance-garbage-collection-best-practices.html#boxing)。
- en: Deploying cross-platform
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署跨平台
- en: Your choice of code editor and operating system for development does not limit
    where your code gets deployed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的代码编辑器和操作系统不会限制您的代码部署的位置。
- en: '.NET 8 supports the following platforms for deployment:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 8支持以下平台进行部署：
- en: '**Windows**: Windows 10 version 1607 or later. Windows 11 version 22000 or
    later. Windows Server 2012 R2 SP1 or later. Nano Server version 1809 or later.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: Windows 10版本1607或更高版本。Windows 11版本22000或更高版本。Windows Server 2012
    R2 SP1或更高版本。Nano Server版本1809或更高版本。'
- en: '**Mac**: macOS Catalina version 10.15 or later and in the Rosetta 2 x64 emulator.
    Mac Catalyst 11.0 or later.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mac**: macOS Catalina版本10.15或更高版本，并在Rosetta 2 x64模拟器中。Mac Catalyst 11.0或更高版本。'
- en: '**Linux**: Alpine Linux 3.17 or later. Debian 11 or later. Fedora 37 or later.
    openSUSE 15 or later. Oracle Linux 8 or later. **Red Hat Enterprise Linux** (**RHEL**)
    8 or later. SUSE Enterprise Linux 12 SP2 or later. Ubuntu 20.04 or later.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**: Alpine Linux 3.17或更高版本。Debian 11或更高版本。Fedora 37或更高版本。openSUSE 15或更高版本。Oracle
    Linux 8或更高版本。**红帽企业Linux**（**RHEL**）8或更高版本。SUSE Enterprise Linux 12 SP2或更高版本。Ubuntu
    20.04或更高版本。'
- en: '**Android**: API 21 or later.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**: API 21或更高版本。'
- en: '**iOS** and **tvOS**: 11.0 or later.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**和**tvOS**: 11.0或更高版本。'
- en: '**Warning!** .NET support for Windows 7 and 8.1 ended in January 2023: [https://github.com/dotnet/core/issues/7556](https://github.com/dotnet/core/issues/7556).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** .NET对Windows 7和8.1的支持已于2023年1月结束：[https://github.com/dotnet/core/issues/7556](https://github.com/dotnet/core/issues/7556)。'
- en: Windows ARM64 support in .NET 5 and later means you can develop on, and deploy
    to, Windows Arm devices like Microsoft’s Windows Dev Kit 2023 (formerly known
    as Project Volterra) and Surface Pro X.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5及更高版本对Windows ARM64的支持意味着您可以在Windows Arm设备上开发并部署，例如微软的Windows Dev Kit
    2023（之前称为Project Volterra）和Surface Pro X。
- en: 'You can review the latest supported operating systems and versions at the following
    link: [https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md](https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中查看最新的支持操作系统和版本：[https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md](https://github.com/dotnet/core/blob/main/release-notes/8.0/supported-os.md)。
- en: Downloading and installing Visual Studio 2022
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载并安装Visual Studio 2022
- en: Many professional Microsoft developers use Visual Studio 2022 in their day-to-day
    development work. Even if you choose to use Visual Studio Code to complete the
    coding tasks in this book, you might want to familiarize yourself with Visual
    Studio 2022 too.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专业的微软开发者在日常开发工作中使用Visual Studio 2022。即使您选择使用Visual Studio Code来完成本书中的编码任务，您也可能想熟悉一下Visual
    Studio 2022。
- en: If you do not have a Windows computer, then you can skip this section and continue
    to the next section where you will download and install Visual Studio Code on
    macOS or Linux.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Windows电脑，则可以跳过本节，继续到下一节，在那里您将在macOS或Linux上下载并安装Visual Studio Code。
- en: 'Since October 2014, Microsoft has made a professional quality edition of Visual
    Studio 2022 available to students, open-source contributors, and individuals for
    free. It is called Community Edition. Any of the editions are suitable for this
    book. If you have not already installed it, let’s do so now:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自2014年10月以来，微软已向学生、开源贡献者和个人免费提供Visual Studio 2022的专业质量版。它被称为社区版。任何版本都适合本书。如果您尚未安装它，我们现在就安装它：
- en: 'Download Visual Studio 2022 version 17.8 or later from the following link:
    [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 Visual Studio 2022 版本 17.8 或更高版本：[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
- en: Start the installer.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动安装程序。
- en: 'On the **Workloads** tab, select the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工作负载**选项卡中，选择以下内容：
- en: '**ASP.NET and web development**'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASP.NET 和 Web 开发**'
- en: '**Azure development**'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 开发**'
- en: '**.NET Multi-platform App UI development**'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 多平台应用程序用户界面开发**'
- en: '**.NET desktop development** (because this includes console apps)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET 桌面开发**（因为这将包括控制台应用程序）'
- en: '**Desktop development with C++** with all default components (because this
    enables publishing console apps and web services that start faster and have smaller
    memory footprints)'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 C++ 进行桌面开发**（因为这将启用发布启动更快且内存占用更小的控制台应用程序和 Web 服务）'
- en: 'On the **Individual components** tab, in the **Code tools** section, select
    the following:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**单个组件**选项卡中，在**代码工具**部分，选择以下内容：
- en: '**Git for Windows**'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows 版 Git**'
- en: Click **Install** and wait for the installer to acquire the selected software
    and install it.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**并等待安装程序获取所选软件并安装。
- en: When the installation is complete, click **Launch**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，点击**启动**。
- en: 'The first time that you run Visual Studio, you will be prompted to sign in.
    If you have a Microsoft account, you can use that account. If you don’t, then
    register for a new one at the following link: [https://signup.live.com/](https://signup.live.com/).'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次运行 Visual Studio 时，你将需要登录。如果你有微软账户，你可以使用该账户。如果没有，请从以下链接注册一个新账户：[https://signup.live.com/](https://signup.live.com/).
- en: The first time that you run Visual Studio, you will be prompted to configure
    your environment. For **Development Settings**, choose **Visual C#**. For the
    color theme, I chose **Blue**, but you can choose whatever tickles your fancy.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次运行 Visual Studio 时，你将需要配置你的环境。对于**开发设置**，选择**Visual C#**。对于颜色主题，我选择了**蓝色**，但你也可以选择任何你喜欢的。
- en: If you want to customize your keyboard shortcuts, navigate to **Tools** | **Options…**,
    and then select the **Environment** | **Keyboard** option.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要自定义你的键盘快捷键，请导航到**工具** | **选项…**，然后选择**环境** | **键盘**选项。
- en: Visual Studio 2022 keyboard shortcuts
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio 2022 键盘快捷键
- en: In this book, I will avoid showing keyboard shortcuts since they are often customized.
    Where they are consistent across code editors and commonly used, I will try to
    show them.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将避免展示键盘快捷键，因为它们通常都是自定义的。当它们在代码编辑器和常用工具中保持一致时，我会尽量展示它们。
- en: 'If you want to identify and customize your keyboard shortcuts, then you can,
    as shown at the following link: [https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio](https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要识别和自定义你的键盘快捷键，那么你可以，如下链接所示：[https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio](https://learn.microsoft.com/en-us/visualstudio/ide/identifying-and-customizing-keyboard-shortcuts-in-visual-studio).
- en: Downloading and installing Visual Studio Code
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和安装 Visual Studio Code
- en: Visual Studio Code has rapidly improved over the past couple of years and has
    pleasantly surprised Microsoft with its popularity. If you are brave and like
    to live on the bleeding edge, then there is the **Insiders** edition, which is
    a daily build of the next version.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 在过去几年中迅速改进，并因其受欢迎程度而让微软感到惊喜。如果你敢于尝试并喜欢走在前沿，那么还有**内部版本**，这是下一个版本的每日构建。
- en: Even if you plan to only use Visual Studio 2022 for development, I recommend
    that you download and install Visual Studio Code and try the coding tasks in this
    chapter using it, and then decide if you want to stick with just using Visual
    Studio 2022 for the rest of the book.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你计划只使用 Visual Studio 2022 进行开发，我也建议你下载并安装 Visual Studio Code，并使用它来完成本章的编码任务，然后决定你是否想在本书的剩余部分只使用
    Visual Studio 2022。
- en: 'Let’s now download and install Visual Studio Code, the .NET SDK, and the C#
    Dev Kit extension:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来下载和安装 Visual Studio Code、.NET SDK 和 C# 开发工具包扩展：
- en: 'Download and install either the Stable build or the Insiders edition of Visual
    Studio Code from the following link: [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载并安装 Visual Studio Code 的稳定版或内部版本：[https://code.visualstudio.com/](https://code.visualstudio.com/).
- en: '**More Information**: If you need more help installing Visual Studio Code on
    any operating system, you can read the official setup guide at the following link:
    [https://code.visualstudio.com/docs/setup/setup-overview](https://code.visualstudio.com/docs/setup/setup-overview).'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**更多信息**：如果你需要更多帮助在任意操作系统上安装 Visual Studio Code，你可以阅读以下链接中的官方设置指南：[https://code.visualstudio.com/docs/setup/setup-overview](https://code.visualstudio.com/docs/setup/setup-overview)。'
- en: 'Download and install the .NET SDK for version 8.0 from the following link:
    [https://www.microsoft.com/net/download](https://www.microsoft.com/net/download).'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载并安装 8.0 版本的 .NET SDK：[https://www.microsoft.com/net/download](https://www.microsoft.com/net/download)。
- en: To install the **C# Dev Kit** extension using the user interface, you must first
    launch the Visual Studio Code application.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用用户界面安装 **C# Dev Kit** 扩展，你必须首先启动 Visual Studio Code 应用程序。
- en: In Visual Studio Code, click the **Extensions** icon or navigate to **View**
    | **Extensions**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，点击 **扩展** 图标或导航到 **视图** | **扩展**。
- en: '**C# Dev Kit** is one of the most popular extensions available, so you should
    see it at the top of the list, or you can enter `C# Dev Kit` in the search box.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C# Dev Kit** 是最受欢迎的扩展之一，所以你应该在列表顶部看到它，或者你可以在搜索框中输入 `C# Dev Kit`。'
- en: '**C# Dev Kit** has a dependency on the **C#** extension version 2.0 or later,
    so you do not have to install the **C#** extension separately. Note that **C#**
    extension version 2.0 or later no longer uses OmniSharp since it has a new **Language
    Service Protocol (LSP)** host. **C# Dev Kit** also has dependencies on the **.NET
    Install Tool for Extension Authors** and **IntelliCode for C# Dev Kit** extensions
    so they will be installed too.'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**C# Dev Kit** 依赖于 **C#** 扩展版本 2.0 或更高版本，因此你不需要单独安装 **C#** 扩展。请注意，**C#** 扩展版本
    2.0 或更高版本不再使用 OmniSharp，因为它有一个新的 **语言服务协议 (LSP)** 主机。**C# Dev Kit** 还依赖于 **.NET
    扩展作者安装工具** 和 **IntelliCode for C# Dev Kit** 扩展，因此它们也将被安装。'
- en: Click **Install** and wait for the supporting packages to download and install.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **安装** 并等待支持包下载和安装。
- en: '**Good Practice**: Be sure to read the license agreement for **C# Dev Kit**.
    It has a more restrictive license than the **C#** extension: [https://aka.ms/vs/csdevkit/license](https://aka.ms/vs/csdevkit/license).'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**良好实践**：务必阅读 **C# Dev Kit** 的许可协议。它的许可比 **C#** 扩展更为严格：[https://aka.ms/vs/csdevkit/license](https://aka.ms/vs/csdevkit/license)。'
- en: Installing other extensions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装其他扩展
- en: 'In later chapters of this book, you will use more Visual Studio Code extensions.
    If you want to install them now, all the extensions that we will use are shown
    in *Table 1.4*:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，你将使用更多 Visual Studio Code 扩展。如果你现在想安装它们，我们将使用的所有扩展都显示在 *表 1.4* 中：
- en: '| **Extension name and identifier** | **Description** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名称和标识符** | **描述** |'
- en: '| **C# Dev Kit**`ms-dotnettools.csdevkit` | Official C# extension from Microsoft.
    Manage your code with a solution explorer and test your code with integrated unit
    test discovery and execution.Includes the **C#** and **IntelliCode for C# Dev
    Kit** extensions. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **C# Dev Kit**`ms-dotnettools.csdevkit` | 来自 Microsoft 的官方 C# 扩展。使用解决方案资源管理器管理你的代码，并通过集成的单元测试发现和执行测试你的代码。包括
    **C#** 和 **IntelliCode for C# Dev Kit** 扩展。|'
- en: '| **C#**`ms-dotnettools.csharp` | C# editing support, including syntax highlighting,
    IntelliSense, Go To Definition, Find All References, debugging support for .NET,
    and support for `csproj` projects on Windows, macOS, and Linux. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **C#**`ms-dotnettools.csharp` | 提供包括语法高亮、IntelliSense、转到定义、查找所有引用、.NET 调试支持以及
    Windows、macOS 和 Linux 上的 `csproj` 项目支持的 C# 编辑支持。|'
- en: '| **IntelliCode for C# Dev Kit**`ms-dotnettools.vscodeintellicode-csharp` |
    Provides AI-assisted development features for Python, TypeScript/JavaScript, C#,
    and Java developers. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **IntelliCode for C# Dev Kit**`ms-dotnettools.vscodeintellicode-csharp` |
    为 Python、TypeScript/JavaScript、C# 和 Java 开发者提供人工智能辅助开发功能。|'
- en: '| **MSBuild project tools**`tintoy.msbuild-project-tools` | Provides IntelliSense
    for MSBuild project files, including autocomplete for `<PackageReference>` elements.
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **MSBuild 项目工具**`tintoy.msbuild-project-tools` | 为 MSBuild 项目文件提供 IntelliSense，包括
    `<PackageReference>` 元素的自动完成。|'
- en: '| **SQL Server (mssql) for Visual Studio Code**`ms-mssql.mssql` | For developing
    SQL Server, Azure SQL Database, and SQL data warehouses everywhere with a rich
    set of functionalities. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **SQL Server (mssql) for Visual Studio Code**`ms-mssql.mssql` | 提供丰富的功能，用于在所有地方开发
    SQL Server、Azure SQL 数据库和 SQL 数据仓库。|'
- en: '| **REST Client**`humao.rest-client` | Send an HTTP request and view the response
    directly in Visual Studio Code. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **REST 客户端**`humao.rest-client` | 在 Visual Studio Code 中发送 HTTP 请求并直接查看响应。|'
- en: '| **ilspy-vscode**`icsharpcode.ilspy-vscode` | Decompile MSIL assemblies –
    support for modern .NET, .NET Framework, .NET Core, and .NET Standard. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **ilspy-vscode**`icsharpcode.ilspy-vscode` | 反编译 MSIL 程序集 – 支持 .NET、.NET
    Framework、.NET Core 和 .NET Standard。|'
- en: '| **vscode-proto3**`zxh404.vscode-proto3` | Syntax highlighting, syntax validation,
    code snippets, code completion, code formatting, brace matching, and line and
    block commenting. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **vscode-proto3**`zxh404.vscode-proto3` | 语法高亮、语法验证、代码片段、代码补全、代码格式化、括号匹配和行与块注释。|'
- en: '| **Azure Functions for Visual Studio Code**`ms-azuretools.vscode-azurefunctions`
    | Create, debug, manage, and deploy serverless apps directly from VS Code. It
    has dependencies on the Azure Account (`ms-vscode.azure-account`) and Azure Resources
    (`ms-azuretools.vscode-azureresourcegroups`) extensions. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **Azure Functions for Visual Studio Code**`ms-azuretools.vscode-azurefunctions`
    | 直接从 VS Code 创建、调试、管理和部署无服务器应用程序。它依赖于 Azure 账户（`ms-vscode.azure-account`）和 Azure
    资源（`ms-azuretools.vscode-azureresourcegroups`）扩展。|'
- en: 'Table 1.4: Visual Studio Code extensions used in this book'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.4：本书中使用的 Visual Studio Code 扩展
- en: Managing Visual Studio Code extensions at the command prompt
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命令提示符下管理 Visual Studio Code 扩展
- en: 'You can install a Visual Studio Code extension at the command prompt or terminal,
    as shown in *Table 1.5*:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令提示符或终端中安装 Visual Studio Code 扩展，如 *表 1.5* 所示：
- en: '| **Command** | **Description** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `code --list-extensions` | List installed extensions. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `code --list-extensions` | 列出已安装的扩展。|'
- en: '| `code --install-extension <extension-id>` | Install the specified extension.
    |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `code --install-extension <extension-id>` | 安装指定的扩展。|'
- en: '| `code --uninstall-extension <extension-id>` | Uninstall the specified extension.
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `code --uninstall-extension <extension-id>` | 卸载指定的扩展。|'
- en: 'Table 1.5: Working with extensions at the command prompt'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.5：在命令提示符下使用扩展
- en: 'For example, to install the **C# Dev Kit** extension, enter the following at
    the command prompt:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装 **C# 开发工具包** 扩展，请在命令提示符下输入以下内容：
- en: '[PRE5]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I have created PowerShell scripts to install and uninstall the Visual Studio
    Code extensions in the preceding table. You can find them at the following link:
    [https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts](https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了 PowerShell 脚本来安装和卸载前面表格中的 Visual Studio Code 扩展。你可以在以下链接中找到它们：[https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts](https://github.com/markjprice/apps-services-net8/tree/main/scripts/extension-scripts)。
- en: Understanding Microsoft Visual Studio Code versions
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解 Microsoft Visual Studio Code 版本
- en: 'Microsoft releases a new feature version of Visual Studio Code (almost) every
    month and bug-fix versions more frequently. For example:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 微软几乎每个月都会发布一个新的 Visual Studio Code 功能版本，并且更频繁地发布错误修复版本。例如：
- en: Version 1.78.0, April 2023 feature release
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1.78.0，2023 年 4 月的功能发布
- en: Version 1.78.1, April 2023 bug fix release
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1.78.1，2023 年 4 月的错误修复发布
- en: The version used in this book is 1.83.0, September 2023 feature release, but
    the version of Microsoft Visual Studio Code is less important than the version
    of the C# extension that you installed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的版本是 1.83.0，2023 年 9 月的功能发布版，但 Microsoft Visual Studio Code 的版本不如你安装的 C#
    扩展版本重要。
- en: While the C# extension is not required, it provides IntelliSense as you type,
    code navigation, and debugging features, so it’s something that’s very handy to
    install and keep updated to support the latest C# language features.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 扩展不是必需的，但它提供在键入时自动完成、代码导航和调试功能，因此安装并保持其更新以支持最新的 C# 语言特性是非常方便的。
- en: Visual Studio Code keyboard shortcuts
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code 快捷键
- en: In this book, I will avoid showing keyboard shortcuts used for tasks like creating
    a new file since they are often different on different operating systems. The
    situations where I will show keyboard shortcuts are when you need to repeatedly
    press the key, for example, while debugging. These are also more likely to be
    consistent across operating systems.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将避免展示用于创建新文件等任务的键盘快捷键，因为它们在不同的操作系统上通常不同。我将展示键盘快捷键的情况是当你需要重复按键时，例如在调试时。这些情况在不同操作系统之间也更有可能保持一致。
- en: 'If you want to customize your keyboard shortcuts for Visual Studio Code, then
    you can, as shown at the following link: [https://code.visualstudio.com/docs/getstarted/keybindings](https://code.visualstudio.com/docs/getstarted/keybindings).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义 Visual Studio Code 的键盘快捷键，那么你可以，如下链接所示：[https://code.visualstudio.com/docs/getstarted/keybindings](https://code.visualstudio.com/docs/getstarted/keybindings)。
- en: 'I recommend that you download a PDF of keyboard shortcuts for your operating
    system from the following list:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您从以下列表中下载适用于您操作系统的键盘快捷方式PDF：
- en: 'Windows: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf)'
- en: 'macOS: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-macos.pdf)'
- en: 'Linux: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux: [https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf](https://code.visualstudio.com/shortcuts/keyboard-shortcuts-linux.pdf)'
- en: Consuming Azure resources
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消耗Azure资源
- en: Some of the chapters in this book will require you to sign up for an Azure account
    and create Azure resources. Frequently, there are free tiers or local development
    versions of these services, but sometimes you will have to create a resource that
    generates costs for the time it exists.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一些章节将要求您注册Azure账户并创建Azure资源。通常，这些服务有免费层或本地开发版本，但有时您可能需要创建一个在存在期间会产生费用的资源。
- en: Packt books use technical reviewers who complete all the coding exercises just
    like a reader would. Here is what one of the TRs of the **second edition** (**2E**)
    of this book said about their Azure costs. “I got my Azure bill. To run through
    2E on a “paid” account cost me $3.01.”
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Packt书籍使用技术审稿人，他们完成所有编码练习，就像读者一样。以下是这本书**第二版**（**2E**）的一位技术审稿人关于他们的Azure成本的评论：“我收到了我的Azure账单。在“付费”账户上运行2E的成本是3.01美元。”
- en: 'Microsoft currently says, “*Eligible new users get $200 Azure credit in your
    billing currency for the first 30 days and a limited quantity of free services
    for 12 months with your Azure free account.*” You can learn more at the following
    link:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 微软目前表示，“*符合条件的全新用户在第一个30天内将获得相当于您账单货币的200美元的Azure信用额度，以及12个月的限量免费服务，这些服务与您的Azure免费账户相关。*”您可以在以下链接中了解更多信息：
- en: '[https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/avoid-charges-free-account)'
- en: '**Good Practice**: Delete Azure resources as soon as you do not need them to
    keep your costs low.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：一旦您不再需要Azure资源，请立即删除以保持您的成本较低。'
- en: 'A summary of which chapters need Azure resources and if a local development
    alternative is available is shown in *Table 1.6*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*表1.6*展示了哪些章节需要Azure资源以及是否有本地开发替代方案：'
- en: '| **Chapter** | **Azure resource** | **Free tier** | **Local development alternative**
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **章节** | **Azure资源** | **免费层** | **本地开发替代方案** |'
- en: '| 2 to 16 | SQL Database | As part of the free first year. | SQL Server Developer
    Edition on Windows, or SQL Edge in a Docker container on Windows, Linux, and macOS.
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 2到16 | SQL数据库 | 作为免费第一年的部分。 | Windows上的SQL Server Developer Edition或Windows、Linux和macOS上的Docker容器中的SQL
    Edge。 |'
- en: '| 4 | Cosmos DB database | 1,000 RU/s and 25 GB of storage. | Azure Cosmos
    DB emulator on Windows or the preview version on Linux. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Cosmos DB数据库 | 1,000 RU/s和25 GB的存储空间。 | Windows上的Azure Cosmos DB模拟器或Linux上的预览版本。
    |'
- en: '| 11 | Azure Functions | 1 million requests and 400,000 GBs of resource consumption
    per month. | Azurite open-source emulator for testing Azure Blob, Queue Storage,
    and Table storage applications like Azure Functions. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 11 | Azure函数 | 每月1000万个请求和400,000 GB的资源消耗。 | 用于测试Azure Blob、队列存储和表存储应用程序（如Azure函数）的Azurite开源模拟器。
    |'
- en: '| 12 | Azure SignalR Service | 20 concurrent connections and 20,000 messages
    per day with 99.9% SLA. | Add SignalR to any ASP.NET Core project for local development.
    |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 12 | Azure SignalR服务 | 每月20万个并发连接和每天20,000条消息，99.9%的SLA。 | 将SignalR添加到任何ASP.NET
    Core项目进行本地开发。 |'
- en: 'Table 1.6: Chapters that use Azure resources and local development alternatives'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.6：使用Azure资源和本地开发替代方案的章节
- en: 'You can find out how to check your usage of free Azure resources at the following
    link: [https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到如何检查您对免费Azure资源的使用的相关信息：[https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage](https://learn.microsoft.com/en-us/azure/cost-management-billing/manage/check-free-service-usage).
- en: Using other project templates
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他项目模板
- en: 'When you install the .NET SDK, there are many project templates included. Let’s
    review them:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装.NET SDK时，包含了许多项目模板。让我们回顾一下它们：
- en: 'At a command prompt or terminal, enter the following command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符或终端中，输入以下命令：
- en: '[PRE6]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: .NET 7 and later SDKs support either `dotnet new --list` or `dotnet new list`.
    The .NET 6 and earlier SDKs only support `dotnet new --list`.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .NET 7及以后的SDK支持`dotnet new --list`或`dotnet new list`。.NET 6及以前的SDK仅支持`dotnet
    new --list`。
- en: 'You will see a list of currently installed templates, including templates for
    Windows desktop development if you are running on Windows, the most common of
    which are shown in *Table 1.7*:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在Windows上运行，您将看到当前安装的模板列表，包括Windows桌面开发的模板，其中最常见的是在*表1.7*中展示的：
- en: '| **Template Name** | **Short Name** | **Language** |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **模板名称** | **简称** | **语言** |'
- en: '| .NET MAUI App | `maui` | C# |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| .NET MAUI应用程序 | `maui` | C# |'
- en: '| .NET MAUI Blazor App | `maui-blazor` | C# |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| .NET MAUI Blazor应用程序 | `maui-blazor` | C# |'
- en: '| ASP.NET Core Empty | `web` | C#, F# |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET Core空项目 | `web` | C#，F# |'
- en: '| ASP.NET Core gRPC Service | `grpc` | C# |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET Core gRPC服务 | `grpc` | C# |'
- en: '| ASP.NET Core Web API | `webapi` | C#, F# |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET Core Web API | `webapi` | C#，F# |'
- en: '| ASP.NET Core Web API (native AOT) | `webapiaot` | C# |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET Core Web API（原生AOT） | `webapiaot` | C# |'
- en: '| ASP.NET Core Web App (Model-View-Controller) | `mvc` | C#, F# |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| ASP.NET Core Web应用程序（模型-视图-控制器） | `mvc` | C#，F# |'
- en: '| Blazor Web App | `blazor` | C# |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| Blazor Web应用程序 | `blazor` | C# |'
- en: '| Class Library | `classlib` | C#, F#, VB |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 类库 | `classlib` | C#，F#，VB |'
- en: '| Console App | `console` | C#, F#, VB |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 控制台应用程序 | `console` | C#，F#，VB |'
- en: '| `EditorConfig` File | `editorconfig` |  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `EditorConfig` 文件 | `editorconfig` |  |'
- en: '| `global.json` File | `globaljson` |  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `global.json` 文件 | `globaljson` |  |'
- en: '| Solution File | `sln` |  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 解决方案文件 | `sln` |  |'
- en: '| xUnit Test Project | `xunit` |  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| xUnit测试项目 | `xunit` |  |'
- en: 'Table 1.7: Project template full and short names'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.7：项目模板的全名和简称
- en: '.NET MAUI projects are not supported for Linux. The team has said they have
    left that work to the open-source community. If you need to create a truly cross-platform
    graphical app, then take a look at Avalonia at the following link: [https://avaloniaui.net/](https://avaloniaui.net/).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI项目不支持Linux。团队表示，他们已经将这项工作留给了开源社区。如果您需要创建一个真正跨平台的图形应用程序，那么请查看以下链接中的Avalonia：[https://avaloniaui.net/](https://avaloniaui.net/)。
- en: Installing additional template packs
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装额外的模板包
- en: 'Developers can install lots of additional template packs:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以安装许多额外的模板包：
- en: Start a browser and navigate to [https://www.nuget.org/packages](https://www.nuget.org/packages).
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动浏览器并导航到[https://www.nuget.org/packages](https://www.nuget.org/packages)。
- en: Enter `vue` in the **Search for packages…** textbox and note that about 210
    packages are returned.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**搜索包…**文本框中输入`vue`，并注意大约返回210个包。
- en: Click **Filter**, select a **Package Type** of **Template**, click **Apply**,
    and note the list of about 25 available templates, including one published by
    Microsoft.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**筛选器**，选择**包类型**为**模板**，点击**应用**，并注意大约25个可用的模板列表，包括由Microsoft发布的一个。
- en: 'Click on **Vue.Simple.Template** and then click **Project website**, and note
    the instructions for installing and using this template, as shown in the following
    commands:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Vue.Simple.Template**，然后点击**项目网站**，并注意安装和使用此模板的说明，如下所示：
- en: '[PRE7]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Close the browser.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭浏览器。
- en: Exploring top-level programs, functions, and namespaces
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索顶层程序、函数和命名空间
- en: Since .NET 6, the default project template for console apps uses the top-level
    program feature introduced with .NET 5\. It is important to understand how it
    works with the automatically generated `Program` class and its `<Main>$` method.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 自.NET 6以来，控制台应用程序的默认项目模板使用了.NET 5引入的顶层程序功能。了解它与自动生成的`Program`类及其`<Main>$`方法的工作方式非常重要。
- en: 'Let’s explore how the top-level program feature works when you define functions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索当您定义函数时，顶层程序功能是如何工作的：
- en: 'Use your preferred coding tool to create a new project, as defined in the following
    list:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您首选的编码工具创建一个新项目，如下列所示：
- en: 'Project template: **Console App** / `console`'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板：**控制台应用程序** / `console`
- en: 'Project file and folder: `TopLevelFunctions`'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目文件和文件夹：`TopLevelFunctions`
- en: 'Solution file and folder: `Chapter01`'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案文件和文件夹：`Chapter01`
- en: '**Do not use top-level statements**: Cleared'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用顶层语句**：已清除'
- en: '**Enable native AOT publishing**: Cleared'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用原生AOT发布**：已清除'
- en: 'In `Program.cs`, delete the existing statements, define a local function at
    the bottom of the file, and call it, as shown in the following code:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，删除现有的语句，在文件底部定义一个局部函数，并调用它，如下所示：
- en: '[PRE8]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the console app and note that the namespace for the `Program` class is
    `null`, as shown in the following output:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意 `Program` 类的命名空间为 `null`，如下所示，输出中已高亮显示：
- en: '[PRE9]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What is automatically generated for a local function?
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动为局部函数生成了什么？
- en: 'The compiler automatically generates a `Program` class with a `<Main>$` function,
    then moves your statements and function inside the `<Main>$` method, and renames
    the local function, as shown highlighted in the following code:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会自动生成一个带有 `<Main>$` 函数的 `Program` 类，然后将你的语句和函数移动到 `<Main>$` 方法中，并重命名局部函数，如下所示，代码中已高亮显示：
- en: '[PRE10]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the compiler to know where what statements need to go, you must follow
    some rules:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器知道哪些语句需要放在哪里，你必须遵循一些规则：
- en: Import statements (`using`) must go at the top of the `Program.cs` file.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入语句 (`using`) 必须放在 `Program.cs` 文件的顶部。
- en: Statements that will go in the `<Main>$` function must go in the middle of the
    `Program.cs` file. Any functions will become **local functions** in the `<Main>$`
    method.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要放入 `<Main>$` 函数中的语句必须放在 `Program.cs` 文件的中间。任何函数都将成为 `<Main>$` 方法中的 **局部函数**。
- en: The last point is important because local functions have limitations, for example,
    they cannot have XML comments to document them.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点很重要，因为局部函数有一些限制，例如，它们不能有 XML 注释来文档化。
- en: Writing static functions in a separate Program class file
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单独的 Program 类文件中编写静态函数
- en: 'A better approach is to write any functions in a separate class file and define
    them as `static` members of the `Program` class:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是，将任何函数写入单独的类文件，并将它们定义为 `Program` 类的 `static` 成员：
- en: Add a new class file named `Program.Functions.cs`. The name has no effect, but
    it is a good practice to name it so that it is clear that this file is related
    to the `Program.cs` class file.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Program.Functions.cs` 的新类文件。名称没有影响，但这是一个好习惯，这样可以使文件与 `Program.cs` 类文件相关联。
- en: 'In `Program.Functions.cs`, define a `partial Program` class, then cut and paste
    the `WhatsMyNamespace` function to move it from `Program.cs` into `Program.Functions.cs`,
    and finally add the `static` keyword, as shown highlighted in the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.Functions.cs` 文件中，定义一个 `partial Program` 类，然后将 `WhatsMyNamespace`
    函数剪切并粘贴到 `Program.Functions.cs` 中，从 `Program.cs` 移动到 `Program.Functions.cs`，并最终添加
    `static` 关键字，如下所示，代码中已高亮显示：
- en: '[PRE11]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `Program.cs`, confirm that its entire content is now just three statements,
    as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中，确认其全部内容现在只是三条语句，如下所示，代码中已高亮显示：
- en: '[PRE12]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the console app and note that it has the same behavior as before.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并注意它具有与之前相同的行为。
- en: What is automatically generated for a static function?
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动为静态函数生成了什么？
- en: 'When you use a separate file to define a partial `Program` class with `static`
    functions, the compiler defines a `Program` class with a `<Main>$` function and
    moves your top-level statements inside the `<Main>$` method, and then merges your
    function as a member of the `Program` class, as shown in the following code:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用单独的文件来定义带有 `static` 函数的 `partial Program` 类时，编译器定义一个带有 `<Main>$` 函数的 `Program`
    类，并将你的顶层语句移动到 `<Main>$` 方法中，然后将你的函数作为 `Program` 类的成员合并，如下所示，代码中已高亮显示：
- en: '[PRE13]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is much cleaner, and you can document your functions with XML comments,
    which also provide tooltips in your code editor when calling the function.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更干净，你可以使用 XML 注释来文档化你的函数，这也会在调用函数时在你的代码编辑器中提供工具提示。
- en: '**Good Practice**: Create any functions that you will call in `Program.cs`
    in a separate file and manually define them inside a `partial Program` class.
    This will merge them into the automatically generated `Program` class *at the
    same level* as the `<Main>$` method, instead of as local functions *inside* the
    `<Main>$` method.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：在 `Program.cs` 中调用任何函数时，在单独的文件中创建这些函数，并在 `partial Program` 类中手动定义它们。这将使它们与自动生成的
    `Program` 类在 `<Main>$` 方法的同一级别合并，而不是作为 `<Main>$` 方法内部的局部函数。'
- en: It is important to note the lack of namespace declarations. Both the automatically
    generated `Program` class and the explicitly defined `Program` class are in the
    default `null` namespace. If you define your `partial Program` class in a namespace,
    then it will be in a different namespace and therefore not merge with the auto-generated
    `partial Program` class.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意缺少命名空间声明。自动生成的 `Program` 类和显式定义的 `Program` 类都在默认的 `null` 命名空间中。如果你在命名空间中定义你的
    `partial Program` 类，那么它将位于不同的命名空间中，因此不会与自动生成的 `partial Program` 类合并。
- en: '**Good Practice**: Do not define a namespace for any `partial Program` classes
    that you create so that they will be defined in the default `null` namespace.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：不要为任何您创建的`partial Program`类定义命名空间，这样它们将定义在默认的`null`命名空间中。'
- en: Optionally, all the `static` methods in the `Program` class could be explicitly
    declared as `private` but this is the default anyway. Since all the functions
    will be called within the `Program` class itself the access modifier is not important.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，`Program`类中的所有`static`方法都可以显式声明为`private`，但这已经是默认设置。由于所有函数都将在本`Program`类内部调用，因此访问修饰符并不重要。
- en: Making good use of the GitHub repository for this book
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用这本书的GitHub仓库
- en: '**Git** is a commonly used source code management system. **GitHub** is a company,
    website, and desktop application that makes it easier to manage Git. Microsoft
    purchased GitHub in 2018, so it will continue to be closely integrated with Microsoft
    tools.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git**是一个常用的源代码管理系统。**GitHub**是一家公司、一个网站和桌面应用程序，它使得管理Git变得更加容易。微软在2018年收购了GitHub，因此它将继续与微软工具紧密集成。'
- en: 'I created a GitHub repository for this book, and I use it for the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这本书创建了一个GitHub仓库，并用于以下目的：
- en: To store the solution code for the book, which will be maintained after the
    print publication date.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储这本书的解决方案代码，这些代码将在印刷出版日期后得到维护。
- en: To provide extra materials that extend the book, like errata fixes, small improvements,
    lists of useful links, and longer articles that cannot fit in the printed book.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供额外的材料，以扩展书籍，如勘误表修正、小改进、有用的链接列表以及无法放入印刷书的更长文章。
- en: To provide a place for readers to get in touch with me if they have issues with
    the book.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为读者提供一个地方，如果他们对书籍有问题可以与我联系。
- en: Raising issues with the book
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对书籍提出问题
- en: 'If you get stuck following any of the instructions in this book, or if you
    spot a mistake in the text or the code in the solutions, please raise an issue
    in the GitHub repository:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在遵循这本书中的任何说明时遇到困难，或者如果您在解决方案中的文本或代码中发现了错误，请在GitHub仓库中提出问题：
- en: 'Use your favorite browser to navigate to the following link: [https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues).'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的浏览器导航到以下链接：[https://github.com/markjprice/apps-services-net8/issues](https://github.com/markjprice/apps-services-net8/issues)。
- en: Click **New Issue**.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建问题**。
- en: 'Enter as much detail as possible that will help me to diagnose the issue. For
    example:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请尽可能提供详细信息，以便我能够诊断问题。例如：
- en: The specific section title, page number, and step number.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的章节标题、页码和步骤编号。
- en: Your code editor, for example, Visual Studio 2022, Visual Studio Code, or something
    else, including the version number.
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码编辑器，例如，Visual Studio 2022、Visual Studio Code或其他，包括版本号。
- en: As much of your code and configuration that you feel is relevant and necessary.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您认为相关且必要的代码和配置尽可能多。
- en: A description of the expected behavior and the behavior experienced.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对预期行为和实际行为的描述。
- en: Screenshots (you can drag and drop image files into the issue box).
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截图（您可以将图像文件拖放到问题框中）。
- en: 'The following is less relevant but might be useful:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容不太相关，但可能有用：
- en: Your operating system, for example, Windows 11 64-bit, or macOS Big Sur version
    11.2.3.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的操作系统，例如，Windows 11 64位，或macOS Big Sur版本11.2.3。
- en: Your hardware, for example, Intel, Apple silicon, or ARM CPU.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的硬件，例如，英特尔、苹果硅或ARM CPU。
- en: I want all my readers to be successful with my book, so if I can help you (and
    others) without too much trouble, then I will gladly do so.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望所有读者都能通过我的书取得成功，所以如果我可以不费太多力气帮助您（和其他人），我将非常乐意这样做。
- en: Giving me feedback
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给我反馈
- en: 'If you’d like to give me more general feedback about the book, then you can
    email me at `markjprice@gmail.com`. My publisher, Packt, has set up Discord channels
    for readers to interact with authors and other readers. You are welcome to join
    us at the following link: [https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8).'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想就这本书给我更一般的反馈，您可以给我发电子邮件到`markjprice@gmail.com`。我的出版商Packt为读者设置了Discord频道，以便他们与作者和其他读者互动。您可以通过以下链接加入我们：[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)。
- en: I love to hear from my readers about what they like about my books, as well
    as suggestions for improvements and how they are working with C# and .NET, so
    don’t be shy. Please get in touch!
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴听到读者对我书籍的看法，以及改进建议以及他们如何使用C#和.NET，所以请不要害羞。请与我联系！
- en: Thank you in advance for your thoughtful and constructive feedback.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 提前感谢您深思熟虑且建设性的反馈。
- en: Downloading solution code from the GitHub repository
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 GitHub 存储库下载解决方案代码
- en: 'I use GitHub to store solutions to all the hands-on, step-by-step coding examples
    throughout chapters and the practical exercises that are featured at the end of
    each chapter. You will find the repository at the following link: [https://github.com/markjprice/apps-services-net8](https://github.com/markjprice/apps-services-net8).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 GitHub 存储了章节中所有动手、分步编码示例以及每章末尾的特色实践练习的解决方案。您可以在以下链接中找到存储库：[https://github.com/markjprice/apps-services-net8](https://github.com/markjprice/apps-services-net8)。
- en: If you just want to download all the solution files without using Git, click
    the green **Code** button and then select **Download ZIP**.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想下载所有解决方案文件而不使用 Git，请点击绿色的 **Code** 按钮，然后选择 **Download ZIP**。
- en: I recommend that you add the preceding link to your favorites or bookmarks.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您将前面的链接添加到您的收藏夹或书签中。
- en: '**Good Practice**: It is best to clone or download the code solutions to a
    short folder path, like `C:\cs12dotnet8\` or `C:\book\`, to avoid build-generated
    files exceeding the maximum path length. You should also avoid special characters
    like `#`. For example, do not use a folder name like `C:\C# projects\`. That folder
    name might work for a simple console app project but once you start adding features
    that automatically generate code you are likely to have strange issues. Keep your
    folder names short and simple.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**良好实践**：最好将代码解决方案克隆或下载到短路径文件夹中，例如 `C:\cs12dotnet8\` 或 `C:\book\`，以避免构建生成的文件超过最大路径长度。您还应避免使用特殊字符，例如
    `#`。例如，不要使用文件夹名称 `C:\C# projects\`。这个文件夹名称可能适用于简单的控制台应用程序项目，但一旦您开始添加会自动生成代码的功能，您很可能会遇到奇怪的问题。请保持文件夹名称简短且简单。'
- en: Where to go for help
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 去哪里寻求帮助
- en: This section is all about how to find quality information about programming
    on the web.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要介绍如何在网络上找到关于编程的高质量信息。
- en: Reading documentation on Microsoft Learn
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Microsoft Learn 上阅读文档
- en: 'The definitive resource for getting help with Microsoft developer tools and
    platforms is in the technical documentation on Microsoft Learn, and you can find
    it at the following link: [https://learn.microsoft.com/en-us/docs](https://learn.microsoft.com/en-us/docs).'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Microsoft 开发者工具和平台帮助的终极资源是在 Microsoft Learn 的技术文档中，您可以在以下链接中找到它：[https://learn.microsoft.com/en-us/docs](https://learn.microsoft.com/en-us/docs)。
- en: Getting help for the dotnet tool
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 dotnet 工具的帮助
- en: 'At the command prompt, you can ask the `dotnet` tool for help with its commands.
    The syntax is:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符中，您可以请求 `dotnet` 工具帮助其命令。语法如下：
- en: '[PRE14]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will cause your web browser to open a page in the documentation about the
    specified command. Common `dotnet` commands include `new`, `build`, and `run`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致您的网页浏览器打开有关指定命令的文档页面。常见的 `dotnet` 命令包括 `new`、`build` 和 `run`。
- en: '**Warning!** The `dotnet help new` command worked with .NET Core 3.1 to .NET
    6, but it returns an error with .NET 7 or later: `Specified command ''new'' is
    not a valid SDK command. Specify a valid SDK command. For more information, run
    dotnet help.` Hopefully, the .NET team will fix that bug soon!'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！** `dotnet help new` 命令在 .NET Core 3.1 到 .NET 6 中工作正常，但使用 .NET 7 或更高版本时会返回错误：“指定的命令
    ''new'' 不是一个有效的 SDK 命令。请指定一个有效的 SDK 命令。有关更多信息，请运行 dotnet help.` 希望.NET 团队会尽快修复这个错误！'
- en: 'Another type of help is command-line documentation. It follows this syntax:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种帮助类型是命令行文档。它遵循以下语法：
- en: '[PRE15]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For example, `dotnet new -?` or `dotnet new -h` or `dotnet new --help` outputs
    documentation about the `new` command at the command prompt.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`dotnet new -?` 或 `dotnet new -h` 或 `dotnet new --help` 会在命令提示符中输出有关 `new`
    命令的文档。
- en: As you should now expect, `dotnet help help` opens a web browser for the `help`
    command, and `dotnet help -h` outputs documentation for the `help` command at
    the command prompt!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您现在所期望的，`dotnet help help` 命令会在网页浏览器中打开 `help` 命令，而 `dotnet help -h` 则在命令提示符中输出
    `help` 命令的文档！
- en: 'Let’s try some examples:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些示例：
- en: 'To open the official documentation in a web browser window for the `dotnet
    build` command, enter the following at the command prompt or in the Visual Studio
    Code terminal, and note the page opened in your web browser, as shown in *Figure
    1.2*:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在网页浏览器窗口中打开 `dotnet build` 命令的官方文档，请在命令提示符或 Visual Studio Code 终端中输入以下内容，并注意在您的网页浏览器中打开的页面，如图
    *图 1.2* 所示：
- en: '[PRE16]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19587_01_02.png)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述由中等置信度自动生成](img/B19587_01_02.png)'
- en: 'Figure 1.2: Web page documentation for the dotnet build command'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：dotnet构建命令的网页文档
- en: 'To get help output at the command prompt, use the `-?`, `-h`, or `--help` flag,
    as shown in the following command:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在命令提示符下获取帮助输出，请使用`-?`、`-h`或`--help`标志，如下面的命令所示：
- en: '[PRE17]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will see the following partial output:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下部分输出：
- en: '[PRE18]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Repeat both types of help request for the following commands: `add`, `help`,
    `list`, `new`, and `run`.'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对以下命令重复两种帮助请求：`add`、`help`、`list`、`new`和`run`。
- en: AI tools like ChatGPT and GitHub Copilot
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人工智能工具如ChatGPT和GitHub Copilot
- en: One of the biggest changes in coding and development in the past year is the
    emergence of generative **artificial intelligence** (**AI**) tools that can help
    with coding tasks like completing a code statement, implementing an entire function,
    writing unit tests, and suggesting debugging fixes for existing code.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 过去一年中，编码和开发领域最大的变化之一是生成式**人工智能**（**AI**）工具的出现，这些工具可以帮助完成编码任务，如完成代码语句、实现整个函数、编写单元测试以及为现有代码提出调试修复建议。
- en: ChatGPT
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ChatGPT
- en: 'ChatGPT currently has two models: 3.5 (free) and 4.0 ($20 per month).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT目前有两个模型：3.5（免费）和4.0（每月20美元）。
- en: 'Let’s say you need to understand more about how to design a microservice. You
    might enter the following prompt:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要了解更多关于如何设计微服务的知识。你可能输入以下提示：
- en: '[PRE19]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It responds with a summary of those top three mistakes, as shown in detail
    in *Figure 1.3* and the following list:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 它会响应一个总结，详细说明了这三个主要错误，如*图1.3*和以下列表所示：
- en: '![](img/B19587_01_03.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19587_01_03.png)'
- en: 'Figure 1.3: ChatGPT advising about microservice architecture design'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：ChatGPT关于微服务架构设计的建议
- en: '“Designing a microservice architecture is a complex task, and there are several
    common mistakes that can lead to significant issues, even causing a project to
    be abandoned. Here are the top three most common mistakes:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: “设计微服务架构是一项复杂的任务，存在一些常见的错误可能会导致重大问题，甚至导致项目被放弃。以下是三个最常见的错误：
- en: '**Improper Service Boundaries:** One of the most challenging aspects of designing
    a microservice architecture is defining the boundaries of each service. If the
    services are too large (a mistake often called a “monolith in disguise”), you
    lose many of the benefits of microservices due to tight coupling of different
    concerns. On the other hand, if the services are too small (sometimes referred
    to as “nanoservices”), you might have to deal with excessive inter-service communication,
    resulting in high latency and complexity.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不恰当的服务边界：** 设计微服务架构最具挑战性的方面之一是定义每个服务的边界。如果服务太大（通常被称为“伪装的巨石”），由于不同关注点之间的紧密耦合，你将失去许多微服务的优势。另一方面，如果服务太小（有时被称为“纳米服务”），你可能必须处理过多的服务间通信，从而导致高延迟和复杂性。'
- en: A lack of proper boundaries can also lead to data consistency issues. If multiple
    services are interacting with the same database tables, it can be difficult to
    maintain data consistency.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏适当的边界也可能导致数据一致性问题的出现。如果多个服务正在与相同的数据库表进行交互，那么维护数据一致性可能会变得困难。
- en: To avoid this mistake, it’s important to understand the business domain thoroughly
    and design services around business capabilities. Techniques such as **Domain-Driven
    Design** (**DDD**) can help identify service boundaries more effectively.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免这个错误，重要的是要彻底理解业务领域，并围绕业务能力设计服务。例如，**领域驱动设计**（**DDD**）等技术可以帮助更有效地识别服务边界。
- en: '**Inadequate Consideration for Data Management:** Each microservice should
    own its own data to ensure loose coupling. Sharing databases across services leads
    to tight coupling and makes it difficult to change the schema without affecting
    other services.'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对数据管理考虑不足：** 每个微服务应拥有自己的数据以确保松散耦合。在服务之间共享数据库会导致紧密耦合，并使得在不影响其他服务的情况下更改模式变得困难。'
- en: However, managing data across services introduces challenges with data consistency
    and transaction management. Developers often underestimate these challenges. They
    might try to implement distributed transactions, which are complex and can hurt
    performance, instead of using eventual consistency and compensation transactions
    (the Saga pattern).
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，跨服务管理数据会引入数据一致性和事务管理方面的挑战。开发者往往低估了这些挑战。他们可能会尝试实现分布式事务，这些事务复杂且可能损害性能，而不是使用最终一致性补偿事务（即
    Saga 模式）。
- en: '**Neglecting Operational Complexity:** Microservice architectures add operational
    complexity. You’re moving from managing a single monolithic application to managing
    multiple services, each potentially written in different languages, using different
    data storage technologies, and running in different environments.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略操作复杂性**：微服务架构增加了操作复杂性。你将从管理单个单体应用程序转变为管理多个服务，每个服务可能使用不同的语言编写，使用不同的数据存储技术，并在不同的环境中运行。'
- en: This requires a mature DevOps capability, including automated deployment, monitoring,
    and good logging practices. You need to plan for how services will be monitored,
    how logs will be aggregated and analyzed, and how deployments and rollbacks will
    be handled.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这需要成熟的DevOps能力，包括自动化部署、监控和良好的日志记录实践。你需要计划如何监控服务，如何聚合和分析日志，以及如何处理部署和回滚。
- en: Ignoring the operational challenges of microservices can lead to significant
    issues down the line. For instance, it can become very difficult to debug issues
    that span multiple services without good tracing and logging. Deploying changes
    can become a nightmare without automated deployment and good testing practices.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略微服务的操作挑战可能导致后续出现重大问题。例如，如果没有良好的跟踪和日志记录，调试跨越多个服务的问题可能会变得非常困难。没有自动化部署和良好的测试实践，部署更改可能会变成一场噩梦。
- en: In conclusion, designing a microservice architecture isn’t a trivial task. It
    requires a deep understanding of the business domain, careful planning, and a
    mature DevOps capability. However, when done right, microservices can provide
    significant benefits, including better scalability, flexibility, and maintainability.”
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，设计微服务架构不是一项简单任务。它需要深入理解业务领域，周密的规划和成熟的DevOps能力。然而，如果做得正确，微服务可以提供显著的好处，包括更好的可扩展性、灵活性和可维护性。”
- en: GitHub Copilot
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub Copilot
- en: Microsoft has a service specifically for programmers named GitHub Copilot that
    can help autocomplete code directly in your code editor. It is being enhanced
    with more intelligence using GPT-4\. It has plugins for code editors including
    Visual Studio 2022, Visual Studio Code, and JetBrains IntelliJ-based IDEs.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 微软有一个专门为程序员提供的服务，名为 GitHub Copilot，可以帮助你在代码编辑器中直接自动完成代码。它正在通过使用 GPT-4 来增强其智能。它为包括
    Visual Studio 2022、Visual Studio Code 和基于 JetBrains IntelliJ 的 IDEs 在内的代码编辑器提供了插件。
- en: GitHub Copilot is free for students, teachers, and some open-source project
    maintainers. For everyone else, it has a 30-day free trial and then it costs $10
    per month or $100 per year for individuals. Once you have an account, you can
    then sign up for the more advanced experimental GitHub Copilot X features.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 对学生、教师和一些开源项目维护者是免费的。对于其他人，它提供 30 天的免费试用，然后每月收费 10 美元或每年收费 100
    美元。一旦你有了账户，你就可以注册更高级的实验性 GitHub Copilot X 功能。
- en: 'You should check online for which Copilot features are available for various
    code editors. As you can imagine, this is a fast-changing world and a lot of what
    I might write in the book today will be out of date by the time you read it: [https://github.com/features/copilot](https://github.com/features/copilot).'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在线查看各种代码编辑器中可用的 Copilot 功能。正如你可以想象的那样，这是一个快速变化的世界，我今天在书中可能写的大部分内容在你阅读时可能已经过时了：[https://github.com/features/copilot](https://github.com/features/copilot)。
- en: 'JetBrains has its own equivalent named AI Assistant, which you can read about
    at the following link: [https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/](https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/).'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains 有自己的类似产品，名为 AI Assistant，你可以在以下链接了解更多信息：[https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/](https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/)。
- en: 'You can sign up for GitHub Copilot at the following link:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接注册 GitHub Copilot：
- en: '[https://github.com/github-copilot/signup/](https://github.com/github-copilot/signup/)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/github-copilot/signup/](https://github.com/github-copilot/signup/)'
- en: Subscribing to the official .NET blog and announcements
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅官方 .NET 博客和公告
- en: 'To keep up to date with .NET, an excellent blog to subscribe to is the official
    .NET blog, written by the .NET engineering teams, and you can find it at the following
    link: [https://devblogs.microsoft.com/dotnet/](https://devblogs.microsoft.com/dotnet/).'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要保持对 .NET 的了解，一个值得订阅的博客是官方 .NET 博客，由 .NET 工程团队撰写，你可以在以下链接找到它：[https://devblogs.microsoft.com/dotnet/](https://devblogs.microsoft.com/dotnet/)。
- en: 'I also recommend that you subscribe to the official .NET announcements repository
    at the following link: [https://github.com/dotnet/announcements](https://github.com/dotnet/announcements).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我还建议你订阅以下链接的官方 .NET 公告仓库：[https://github.com/dotnet/announcements](https://github.com/dotnet/announcements)。
- en: Practicing and exploring
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习和探索
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring with deeper research the topics in this chapter.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答一些问题、进行一些动手实践，以及通过更深入的研究探索本章的主题，来测试你的知识和理解。
- en: Exercise 1.1 – Test your knowledge
  id: totrans-471
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.1 – 测试你的知识
- en: 'Use the web to answer the following questions:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络回答以下问题：
- en: Why is it good practice to add the following setting to your project files?
    And when should you not set it?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将以下设置添加到你的项目文件中是一种良好的实践？以及在什么情况下不应该设置它？
- en: '[PRE20]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Which service technology requires a minimum HTTP version of 2?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种服务技术需要最低的 HTTP 版本为 2？
- en: In 2010, your organization created a service using .NET Framework and WCF. What
    is the best technology to migrate it to and why?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 2010 年，你的组织使用 .NET Framework 和 WCF 创建了一个服务。将其迁移到哪种最佳技术，以及为什么？
- en: Which code editor or IDE should you install for .NET development?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该安装哪个代码编辑器或 IDE 用于 .NET 开发？
- en: What should you beware of when creating Azure resources?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Azure 资源时，你应该注意什么？
- en: Exercise 1.2 – Review the online-only sections
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.2 – 复习仅在线部分
- en: 'To preserve space in the print book, there are some optional online-only sections
    available in the GitHub repository. They are not needed for the rest of the book,
    but you will find them useful for general knowledge:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在印刷版书籍中保留空间，GitHub 仓库中有一些可选的仅在线部分。它们对于本书的其余部分不是必需的，但你将发现它们对于一般知识很有用：
- en: '**What’s New in Modern C# and .NET**: In this section, the goal is to review
    what is new since C# 6 and .NET Core 1.0, which were released in 2016\. Instead
    of just listing the new features introduced with each version of .NET, this section
    takes a themed approach to make it easier to understand how small individual improvements
    introduced over multiple versions are designed to work together. This section
    will also be updated throughout the lifetime of .NET 8, from November 2023 to
    November 2026\. This will include new language and library features introduced
    in .NET 9 and .NET 10 ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md)).'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现代 C# 和 .NET 的新特性**：在本节中，目标是回顾自 2016 年发布的 C# 6 和 .NET Core 1.0 以来有哪些新内容。本节不是简单地列出每个
    .NET 版本引入的新特性，而是采用主题方法，以便更容易理解在多个版本中引入的小型个别改进是如何协同工作的。本节还将在整个 .NET 8 生命周期内更新，从
    2023 年 11 月到 2026 年 11 月。这包括在 .NET 9 和 .NET 10 中引入的新语言和库功能（[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-whats-new.md)）。'
- en: '**Benchmarking Performance and Testing**: In this section, you will learn how
    to use types in the `System.Diagnostics` namespace and the Benchmark.NET library
    to monitor your code to measure performance and efficiency ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md)).'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能基准测试和测试**：在本节中，你将学习如何使用 `System.Diagnostics` 命名空间中的类型和 Benchmark.NET 库来监控你的代码以衡量性能和效率（[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md)）。'
- en: '**Observing and Modifying Code Execution Dynamically**: This is about some
    common types that are included with .NET for performing code reflection and applying
    and reading attributes, working with expression trees, and creating source generators
    ([https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md)).'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态观察和修改代码执行**：这是关于一些包含在 .NET 中用于执行代码反射、应用和读取属性、处理表达式树以及创建源生成器的常见类型（[https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-dynamic-code.md)）。'
- en: Exercise 1.3 – Explore topics
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.3 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下页面上的链接了解更多关于本章涵盖的主题：
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-1---introducing-apps-and-services-with-net)'
- en: Summary
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你：
- en: Were introduced to the app and service technologies that you will learn about
    in this book.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了你将在本书中学到的应用程序和服务技术。
- en: Set up your development environment.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的开发环境。
- en: Learned where to look for help.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学到了在哪里寻找帮助。
- en: In the next chapter, you will learn how to use SQL Server to store and manage
    relational data.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何使用 SQL Server 存储和管理关系型数据。
- en: Learn more on Discord
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的 Discord 社区——在那里你可以分享反馈、向作者提问以及了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
- en: '![](img/QR_Code3048220001028652625.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code3048220001028652625.png)'
