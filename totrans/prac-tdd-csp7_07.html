<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test-Driving C# Applications</h1>
                
            
            <article>
                
<p class="calibre2">The two most important features for the Speaker Meet application were determined to be the speaker listing and the ability to see an individual speaker's details. The speaker listing and speaker details will deliver the most value for our Minimum Viable Product.</p>
<p class="calibre2">Conference organizers, user group administrators, and the general public would likely care most about finding information on speakers. With that in mind, the speakers epic is where development for the Speaker Meet application begins.</p>
<p class="calibre2">In this chapter, we cover:</p>
<ul class="calibre7">
<li class="calibre8">Speaker Meet requirements</li>
<li class="calibre8">API, service, and repository tests</li>
<li class="calibre8">The speaker detail and speaker listing APIs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reviewing the requirements</h1>
                
            
            <article>
                
<p class="calibre2">In order to get started, the foundation of the speaker section of the Speaker Meet application is laid by defining the initial set of requirements. These will help eliminate ambiguity and develop a common understanding of the requirements, as well as defining a common vocabulary used throughout the project.</p>
<p class="calibre2">The abstract is where a projects, purpose and value can be presented. Any project, before it can be approved to be worked on, must prove the value that it can provide to the company. This is true whether you are working for a Fortune 500 company or a startup with two people.</p>
<p class="calibre2">A data dictionary is important because it provides a common, ubiquitous language for the project. The term, ubiquitous language, is from Domain Driven Design and denotes <em class="calibre12">a shared or common language</em>. The idea is that the shared jargon of the business and development team is solidified in a codex that can be viewed and used by all.</p>
<p class="calibre2">Last, and certainly not least, the requirements must be presented in an agreed upon format. The specific format is less important than the format agreement. Regardless of the format, good requirements provide a context of interaction, the interaction taking place, and the expected results given the context and specific action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Speaker listing</h1>
                
            
            <article>
                
<p class="calibre2">The speakers section of the Speaker Meet website contains a listing of all speakers in the system. The listing of speakers will present value to multiple groups including conference and user group organizers as well as conference and user group attendees. From a user interaction perspective, the speaker listing allows entry to the speaker details. The speaker details are where the real value is delivered in the form of availability, upcoming engagements, and contact information for a given speaker.</p>
<p class="calibre2">Initially, the speaker listing will aid organizers by providing quick access to speaker discovery. Organizers will be able to find speakers they know of and discover speakers of whom they are unaware. Once found or discovered, the organizer will be able to view details for specific speakers and, eventually, organizers will be able to contact the speakers using the available contact information.</p>
<p class="calibre2">Attendees will benefit from the speaker list in a similar fashion to the organizers. Attendees have one important difference, however: they are looking for the events a speaker is already attached to as a presenter. This information, similar to the contact information, will be available in the speaker details.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">API</h1>
                
            
            <article>
                
<p class="calibre2">The API is the main gateway into the core system of the Speaker Meet application. The speaker listing API should return a listing of speaker summary ViewModels. These ViewModels contain only the information necessary for this portion of the application. The ViewModels represent the speaker, but should not necessarily be direct copies of the speaker objects persisted to a database.</p>
<p class="calibre2">The <kbd class="calibre11">SpeakerSummary</kbd> ViewModel will be defined based on the requirements of the system. This ViewModel will grow to contain only the properties required for its limited use.</p>
<p class="calibre2">To get started, a new method will need to be added to an API. For the first new piece of functionality to be added, a new method <kbd class="calibre11">GetAll</kbd> will need to be created in the <kbd class="calibre11">SpeakerController</kbd>. But first, a test must be created.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">API tests</h1>
                
            
            <article>
                
<p class="calibre2">To revisit, code in the <kbd class="calibre11">SpeakerController</kbd> may not be written without a failing unit test. To begin, a new test file should be created named <kbd class="calibre11">GetAll</kbd>. This is where all the tests associated with the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerController</kbd> will be contained.</p>
<div class="packt_infobox">
<p class="calibre36">There is duplication in how testing the <kbd class="calibre37">SpeakerController</kbd> is set up. Try to come up with ways that this duplication can be minimized.</p>
</div>
<p class="calibre2"><span>The first such test should be the standard </span><kbd class="calibre11">ItExists</kbd><span> test. Building on the example from previous chapters, the <kbd class="calibre11">SpeakerController</kbd> accepts an </span><kbd class="calibre11">ISpeakerService</kbd><span> in the constructor. The same method of providing a</span> <kbd class="calibre11">Moq</kbd> <span>object can be applied here as well.</span></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  var controller = new SpeakerController(speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  controller.GetAll();<br class="title-page-name"/>}</pre>
<p class="calibre2">Comparing this first test with the first test written for the <kbd class="calibre11">Search</kbd> method in the <kbd class="calibre11">SpeakerController</kbd>, you may notice there's a bit of duplication happening already. Remember, duplication should be avoided. Don't forget the acronym, <strong class="calibre1">DRY</strong> (<strong class="calibre1">Don't Repeat Yourself</strong>).</p>
<p class="calibre2">In order to make this first test pass, a void <kbd class="calibre11">GetAll</kbd> method should be added to the <kbd class="calibre11">SpeakerController</kbd>. This will allow the application to compile, thereby passing this test. Remember, a failure to compile is a failing test.</p>
<pre class="calibre19">public void GetAll()<br class="title-page-name"/>{           <br class="title-page-name"/>}</pre>
<p class="calibre2">Next, ensure that the <kbd class="calibre11">GetAll</kbd> method of <kbd class="calibre11">SpeakerController</kbd> returns an <kbd class="calibre11">OkObjectResult</kbd> by creating a new test. Don't worry about the type of the result itself. That will be covered by the next test.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsOkObjectResult()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  var controller = new SpeakerController(speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = controller.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  Assert.IsType&lt;OkObjectResult&gt;(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to get this test to pass, the method should return an <kbd class="calibre11">IActionResult</kbd> instead of <kbd class="calibre11">void</kbd>. The method should also be changed to return <kbd class="calibre11">Ok()</kbd> in order to make the test pass. The method does not need to return anything else in order to make the test pass as written. Do not write more code than is required to make the test pass.</p>
<pre class="calibre19">public IActionResult GetAll()<br class="title-page-name"/>{           <br class="title-page-name"/>  return Ok();<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, determine that the method returns a collection of <kbd class="calibre11">SpeakerSummary</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsCollectionOfSpeakerSummary()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  var controller = new SpeakerController(speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = controller.GetAll() as OkObjectResult;<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  Assert.NotNull(result.Value);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(result.Value);<br class="title-page-name"/>}</pre>
<p class="calibre2">Create a <kbd class="calibre11">SpeakerSummary</kbd> class to fulfill the requirement defined by this test. Give some thought to where the new <kbd class="calibre11">SpeakerSummary</kbd> lives. This is a ViewModel that will need to be accessed by the tests, but should not be available to the other layers of the application. More about proper separation in a future chapter.</p>
<p class="calibre2">Modify the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerController</kbd> to return a set of <kbd class="calibre11">SpeakerSummary</kbd> objects as the return value.</p>
<pre class="calibre19">public IActionResult GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return Ok(new List&lt;SpeakerSummary&gt;());<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Moq</h1>
                
            
            <article>
                
<p class="calibre2">In previous chapters, Moq was used to provide a stand-in set of functionalities for the item under test. The results provided for the mocked instance were required, but the implementation was not vital to what was being tested.</p>
<p class="calibre2">Like the examples in previous chapters, the logic for <kbd class="calibre11">GetAll</kbd> should not be found in the controller itself. Instead, the logic will be contained within the business layer, specifically the <kbd class="calibre11">SpeakerService</kbd> implementation of <kbd class="calibre11">ISpeakerService</kbd>. When the <kbd class="calibre11">GetAll</kbd> method in <kbd class="calibre11">SpeakerController</kbd> is called it is expected that the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> will be called.</p>
<p class="calibre2">The <kbd class="calibre11">GetAll</kbd> method does not exist within the <kbd class="calibre11">SpeakerService</kbd>, so the following test should fail.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsGetAllServiceOnce()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  var controller = new SpeakerController(_speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  controller.GetAll();<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  speakerServiceMock.Verify(mock =&gt; mock.GetAll(), Times.Once());<br class="title-page-name"/>}</pre>
<p class="calibre2">Creating the previous test has forced the creation of a new method signature in the <kbd class="calibre11">ISpeakerService</kbd> interface. The following method signature should be added to the <kbd class="calibre11">ISpeakerService</kbd> interface.</p>
<pre class="calibre19">IEnumerable&lt;SpeakerSummary&gt; GetAll();</pre>
<p class="calibre2">To get the application to compile, <kbd class="calibre11">GetAll</kbd> will also need to be added to the <kbd class="calibre11">SpeakerService</kbd> class. For now, this should throw an exception.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  throw new <strong class="calibre1">NotImplementedException</strong>();<br class="title-page-name"/>}</pre>
<p class="calibre2">To get the <kbd class="calibre11">ItCallsGetAllServiceOnce</kbd> test to pass, make sure that the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> is called. The return value from the call is not yet needed for the test to pass, so simply calling the method is all that is required.</p>
<pre class="calibre19">public IActionResult GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  _speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  return Ok(new List&lt;SpeakerSummary&gt;());<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that this will make the test pass, but it is not exactly the correct solution yet. A new test is required to force the code to do something with the return value of the service. Moving on, it's time to do something with the result of the <kbd class="calibre11">SpeakerService.GetAll</kbd> call.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerServiceThenResultsReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakers = new List&lt;SpeakerSummary&gt; { new SpeakerSummary<br class="title-page-name"/>  {<br class="title-page-name"/>    Name = "Speaker"<br class="title-page-name"/>  } };<br class="title-page-name"/><br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  speakerServiceMock.Setup(x =&gt; x.GetAll()).Returns(() =&gt; _speakers);<br class="title-page-name"/><br class="title-page-name"/>  var controller = new SpeakerController(speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = controller.GetAll() as OkObjectResult;<br class="title-page-name"/>  var speakers = ((IEnumerable&lt;SpeakerSummary&gt;)result.Value).ToList();<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(_speakers, speakers);<br class="title-page-name"/>}</pre>
<p class="calibre2">Don't forget to refactor the tests as well as the code. For readability, the <kbd class="calibre11">Arrange</kbd> methods have been included in the previous examples. Likely, these would be extracted and defined as <em class="calibre12">fields</em> and assigned in the constructor.</p>
<pre class="calibre19">private readonly SpeakerController _controller;<br class="title-page-name"/>private static Mock&lt;ISpeakerService&gt; _speakerServiceMock;<br class="title-page-name"/>private readonly List&lt;SpeakerSummary&gt; _speakers;<br class="title-page-name"/><br class="title-page-name"/>public GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  _speakers = new List&lt;SpeakerSummary&gt; { new SpeakerSummary<br class="title-page-name"/>  {<br class="title-page-name"/>    Name = "test"<br class="title-page-name"/>  } };<br class="title-page-name"/><br class="title-page-name"/>  _speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  _speakerServiceMock.Setup(x =&gt; x.GetAll()).Returns(() =&gt; _speakers);<br class="title-page-name"/> <br class="title-page-name"/>  _controller = new SpeakerController(_speakerServiceMock.Object);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing exception cases</h1>
                
            
            <article>
                
<p class="calibre2">In the event that a speaker is requested that does not exist, it would be best to return a friendly error message to the consumer of the API.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerNotFoundExceptionThenNotFoundObjectResult()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _controller.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;NotFoundObjectResult&gt;(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">Create a new exception class named <kbd class="calibre11">SpeakerNotFoundException</kbd>. This will be the specific exception returned by the <kbd class="calibre11">Moq</kbd> call below. Like the <kbd class="calibre11">SpeakerSummary</kbd> class file before, give some thought to where the <kbd class="calibre11">SpeakerNotFoundException</kbd> class file should be saved.</p>
<pre class="calibre19">public class SpeakerNotFoundException : Exception<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">"Throwing" a new exception when a specific ID is supplied requires a little bit of setup in <kbd class="calibre11">Moq</kbd>. This is similar to what was already defined by the <kbd class="calibre11">x.Get(It.IsAny&lt;int&gt;)</kbd> definition.</p>
<pre class="calibre19">_speakerServiceMock.Setup(x =&gt; x.Get(-1)).Returns(() =&gt; throw new SpeakerNotFoundException());</pre>
<p class="calibre2">Make sure this is added after the previous setup, as <kbd class="calibre11">Moq</kbd> will process the last value first. Avoid a false positive by understanding how <kbd class="calibre11">Moq</kbd> will evaluate what has been set up within its context.</p>
<p class="calibre2">Next, modify the <kbd class="calibre11">Get</kbd> method of the controller to catch the exception and return the proper response code.</p>
<pre class="calibre19">public IActionResult Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  try<br class="title-page-name"/>  {<br class="title-page-name"/>    var speaker = _speakerService.Get(id);<br class="title-page-name"/>    return Ok(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/>  catch (SpeakerNotFoundException)<br class="title-page-name"/>  {<br class="title-page-name"/>    return NotFound();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The initial requirements stated that a friendly error message be returned to the client. Create a test that ensures a friendly message is returned to the consumer in the event a speaker is not found with the supplied ID.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerNotFoundExceptionThenMessageReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _controller.Get(-1) as NotFoundObjectResult;<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  Assert.Equal("Speaker Not Found", result.Value);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to make this test pass, the <kbd class="calibre11">SpeakerNotFoundException</kbd> class must be modified in order to return a friendly error message.</p>
<pre class="calibre19">public class SpeakerNotFoundException : Exception<br class="title-page-name"/>{<br class="title-page-name"/>  public SpeakerNotFoundException() : base("Speaker Not Found")<br class="title-page-name"/>  {<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, modify the <kbd class="calibre11">Get</kbd> method in the controller to return the message.</p>
<pre class="calibre19">public IActionResult Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  try<br class="title-page-name"/>  {<br class="title-page-name"/>    var speaker = _speakerService.Get(id);<br class="title-page-name"/>    return Ok(speaker);<br class="title-page-name"/>  }<br class="title-page-name"/>  catch (SpeakerNotFoundException ex)<br class="title-page-name"/>  {<br class="title-page-name"/>    return NotFound(ex.Message);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service</h1>
                
            
            <article>
                
<p class="calibre2">The business logic for the <kbd class="calibre11">GetAll</kbd> method should be housed in the <kbd class="calibre11">SpeakerService</kbd>. As before, in order to write a line of code a test must first be written.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service tests</h1>
                
            
            <article>
                
<p class="calibre2">To build on the previous example, start with an <kbd class="calibre11">ItExists</kbd> test.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasGetAllMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  var speakerService = new SpeakerService();<br class="title-page-name"/>  speakerService.GetAll();<br class="title-page-name"/>}</pre>
<p class="calibre2">Since this method was previously added to the <kbd class="calibre11">SpeakerService</kbd>, although with a <kbd class="calibre11">NotImplementedException</kbd>, it would be best to see this test fail for the proper reason. Delete the <kbd class="calibre11">GetAll</kbd> method from the <kbd class="calibre11">SpeakerService</kbd> so that the application will fail to compile. Now, add the method back to see that the application once again compiles, and therefore this test passes. This time, have the method return <kbd class="calibre11">null</kbd> instead of throwing a new <kbd class="calibre11">NotImplementedException</kbd>.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return null;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, ensure that the <kbd class="calibre11">GetAll</kbd> method returns a collection of <kbd class="calibre11">SpeakerSummary</kbd> by creating a new test.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsCollectionOfSpeakerSummary()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/>}</pre>
<p class="calibre2">Modify the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> in order to make this test pass. The minimum amount of code required to make this test pass involves returning a <kbd class="calibre11">new List</kbd> of <kbd class="calibre11">SpeakerSummary</kbd> objects. Do not add more code than is required to make this test pass.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return new List&lt;SpeakerSummary&gt;();<br class="title-page-name"/>}</pre>
<p class="calibre2">Building on the examples from a previous chapter, use the hardcoded data from before. Extract <kbd class="calibre11">hardCodedSpeakers</kbd> into a field in order to use the data in both the <kbd class="calibre11">Search</kbd> method as well as the <kbd class="calibre11">GetAll</kbd> method:</p>
<pre class="calibre19">public readonly List&lt;Speaker&gt; HardCodedSpeakers = new List&lt;Speaker&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  new Speaker {Name = "Josh"},<br class="title-page-name"/>  new Speaker {Name = "Joshua"},<br class="title-page-name"/>  new Speaker {Name = "Joseph"},<br class="title-page-name"/>  new Speaker {Name = "Bill"}<br class="title-page-name"/>};</pre>
<p class="calibre2">Note that the field was made public. This will allow tests to use this data for comparison for <em class="calibre12">Asserts</em>. Don’t worry, this field and the hardcoded data contained therein will be short-lived. Once these are no longer needed they can be safely deleted.</p>
<p class="calibre2">Now, create a test to ensure that all of the data contained in <kbd class="calibre11">HardCodedSpeakers</kbd> is returned by the <kbd class="calibre11">GetAll</kbd> method in the <kbd class="calibre11">SpeakerService</kbd>. Start by verifying that the same number of speakers in the hardcoded data is returned by the method.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/>  Assert.Equal(_speakerService.HardCodedSpeakers.Count, speakers.Count());<br class="title-page-name"/>}</pre>
<p class="calibre2">To get this to pass, simply iterate over the hardcoded values and return a new <kbd class="calibre11">SpeakerSummary</kbd> for each entry. As the test is not yet checking the values of the speakers returned, all that is required is that the proper count of <kbd class="calibre11">SpeakerSummary</kbd> objects is returned.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return HardCodedSpeakers.Select(speaker =&gt; new SpeakerSummary());<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, ensure that the speakers are properly converted to <kbd class="calibre11">SpeakerSummary</kbd> objects. First, check that the <kbd class="calibre11">Name</kbd> properties are the same.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakersWithName()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/><br class="title-page-name"/>  for (var i = 0; i &lt; speakers.Count; i++)<br class="title-page-name"/>  {<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Name);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Name, speakers[i].Name);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">And now, make this test pass by assigning the <kbd class="calibre11">Name</kbd> within the <kbd class="calibre11">GetAll</kbd> method.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return HardCodedSpeakers.Select(speaker =&gt; new SpeakerSummary<br class="title-page-name"/>  {<br class="title-page-name"/>    Name = speaker.Name     <br class="title-page-name"/>  });<br class="title-page-name"/>}</pre>
<p class="calibre2">Continue to build up the <kbd class="calibre11">SpeakerSummary</kbd> object with the required properties. The <kbd class="calibre11">Name</kbd> property has been added. Now, add an ID and ensure that it is being assigned and returned properly.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakersWithId()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/><br class="title-page-name"/>  for (var i = 0; i &lt; speakers.Count; i++)<br class="title-page-name"/>  {<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Id);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Id, speakers[i].Id);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to make this pass, an ID will need to be mapped in the <kbd class="calibre11">GetAll</kbd> method of the <kbd class="calibre11">SpeakerService</kbd>, and an ID property added to the<kbd class="calibre11"> Speaker</kbd> and <kbd class="calibre11">SpeakerSummary</kbd> objects.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return HardCodedSpeakers.Select(speaker =&gt; new SpeakerSummary<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name     <br class="title-page-name"/>  });<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, add a <kbd class="calibre11">Location</kbd> to be returned by the <kbd class="calibre11">GetAll</kbd> method. This, too, will require the <kbd class="calibre11">Speaker</kbd> and <kbd class="calibre11">SpeakerSummary</kbd> objects to be modified. Give the new Location property in the <kbd class="calibre11">HardCodedSpeakers</kbd> collection distinct values to ensure that the values are being returned properly.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakersWithLocation()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/><br class="title-page-name"/>  for (var i = 0; i &lt; speakers.Count; i++)<br class="title-page-name"/>  {<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Location);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Location, speakers[i].Location);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Add some locations to the hardcoded data.</p>
<pre class="calibre19">public readonly List&lt;Speaker&gt; HardCodedSpeakers = new List&lt;Speaker&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  new Speaker {Id = 1, Name = "Josh", Location = “Tampa, FL”},<br class="title-page-name"/>  new Speaker {Id = 2, Name = "Joshua", Location = “Louisville, KY”},<br class="title-page-name"/>  new Speaker {Id = 3, Name = "Joseph", Location = “Las Vegas, NV”},<br class="title-page-name"/>  new Speaker {Id = 4, Name = "Bill", Location = “New York, NY”},<br class="title-page-name"/>};</pre>
<p class="calibre2">Finally, map the location to the <kbd class="calibre11">SpeakerSummary</kbd> ViewModel.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return HardCodedSpeakers.Select(speaker =&gt; new SpeakerSummary<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name,  <br class="title-page-name"/>    Location = speaker.Location,<br class="title-page-name"/>  });<br class="title-page-name"/>}</pre>
<p class="calibre2">As has been discussed before, tests should have a single action. That does not preclude them from having multiple asserts. In order to minimize duplication, the property tests should be collapsed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Clean tests  </h1>
                
            
            <article>
                
<p class="calibre2">A test suite should be well maintained. This is the first consumer of the application and provides the most comprehensive documentation of the functionality of the system. To clean up the tests that were just created, it is time to do some refactoring.</p>
<p class="calibre2">Collapse the <kbd class="calibre11">SpeakerSummary</kbd> properties into single act, with multiple asserts. This will help to make the test suite smaller, easier to read and maintain, and quite possibly it will execute execute more quickly. A test suite that executes quickly is far more likely to be run often by the developers.</p>
<p class="calibre2">Rename <kbd class="calibre11">ItReturnsAllSpeakersWithName</kbd> to <kbd class="calibre11">ItReturnsAllSpeakersWithProperties</kbd> and collapse the <kbd class="calibre11">ID</kbd> and <kbd class="calibre11">Location</kbd> tests into this one.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakersWithProperties()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/><br class="title-page-name"/>  for (var i = 0; i &lt; speakers.Count; i++)<br class="title-page-name"/>  {<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Name);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Name, speakers[i].Name);<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Id);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Id, speakers[i].Id);<br class="title-page-name"/>    Assert.NotNull(_speakerService.HardCodedSpeakers[i].Location);<br class="title-page-name"/>    Assert.Equal(_speakerService.HardCodedSpeakers[i].Location, speakers[i].Location);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Repository</h1>
                
            
            <article>
                
<p class="calibre2">In a previous chapter, the data was hard-coded within the <kbd class="calibre11">SpeakerController</kbd> class. The data has since moved to a hardcoded collection in the <kbd class="calibre11">SpeakerService</kbd>. Ultimately the data will be persisted in a database. For now, moving the data out of the <kbd class="calibre11">SpeakerService</kbd> will be enough.</p>
<p class="calibre2">A repository layer will be used to separate the data access layer from the rest of the application. To achieve this, a repository must be introduced. In order for a repository to be created, a need must be established. Start slowly by requiring the <kbd class="calibre11">SpeakerService</kbd> to accept an <kbd class="calibre11">IRepository</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAcceptsIRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  IRepository fakeRepository = new FakeRepository();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var service = new SpeakerService(fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(service);<br class="title-page-name"/>}</pre>
<p class="calibre2">This, of course, will cause the application to fail to compile. Create an <kbd class="calibre11">IRepository</kbd> interface, a <kbd class="calibre11">FakeRepository</kbd> class, and modify the <kbd class="calibre11">SpeakerService</kbd> to accept an <kbd class="calibre11">IRepository</kbd>.</p>
<pre class="calibre19">public SpeakerService(IRepository repository)<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The IRepository interface</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">IRepository</kbd> interface will be where the method signatures for interacting with the data access layer will be defined. This interface will be grown slowly, guided by tests. In <a target="_blank" href="part0277.html#885BQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 8</a>, <em class="calibre12">Abstract Away Problems</em>, more details will be provided and additional concepts will be introduced. For now, the interface will merely be a contract for the <kbd class="calibre11">FakeRepository</kbd> used for the <kbd class="calibre11">SpeakerService</kbd> tests.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">FakeRepository</h1>
                
            
            <article>
                
<p class="calibre2">Now that the <kbd class="calibre11">FakeRepository</kbd> has been created, the <kbd class="calibre11">HardCodedSpeakers</kbd> can be moved into the <kbd class="calibre11">FakeRepository</kbd>. First, several iterative tests need to be created.</p>
<p class="calibre2">Interacting with a <kbd class="calibre11">FakeRepository</kbd> of your own creation allows you to substitute values and create additional functionality for testing purposes.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  FakeRepository fakeRepository = new FakeRepository();<br class="title-page-name"/>  var service = new SpeakerService(fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = service.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(fakeRepository.GetAllCalled);<br class="title-page-name"/>}</pre>
<p class="calibre2">By introducing a public field, the same functionality seen with <kbd class="calibre11">Moq</kbd> can be applied here in the <kbd class="calibre11">FakeRepository</kbd>.</p>
<pre class="calibre19">public bool GetAllCalled { get; private set; }<br class="title-page-name"/><br class="title-page-name"/>public void GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  GetAllCalled = true;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now ensure that the <kbd class="calibre11">FakeRepository</kbd> returns the <kbd class="calibre11">HardCodedSpeakers</kbd> when <kbd class="calibre11">GetAll</kbd> is called by modifying the existing tests for <kbd class="calibre11">ItReturnsAllSpeakers</kbd> and <kbd class="calibre11">ItReturnsAllSpeakersWithProperties</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/>  Assert.Equal(_fakeRepository.HardCodedSpeakers.Count, speakers.Count());<br class="title-page-name"/>}</pre>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsAllSpeakersWithProperties()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = _speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/><br class="title-page-name"/>  for (var i = 0; i &lt; speakers.Count; i++)<br class="title-page-name"/>  {<br class="title-page-name"/>    Assert.NotNull(_fakeRepository.HardCodedSpeakers[i].Name);<br class="title-page-name"/>    Assert.Equal(_fakeRepository.HardCodedSpeakers[i].Name, speakers[i].Name);<br class="title-page-name"/>    Assert.NotNull(_fakeRepository.HardCodedSpeakers[i].Id);<br class="title-page-name"/>    Assert.Equal(_fakeRepository.HardCodedSpeakers[i].Id, speakers[i].Id);<br class="title-page-name"/>    Assert.NotNull(_fakeRepository.HardCodedSpeakers[i].Location);<br class="title-page-name"/>    Assert.Equal(_fakeRepository.HardCodedSpeakers[i].Location, speakers[i].Location);<br class="title-page-name"/>  }<br class="title-page-name"/>}    </pre>
<p class="calibre2">It may seem like a lot of effort has been expended to just kick the can down the road. This has all been necessary effort to successfully work towards a truly functional and maintainable application. However, there's still more work to be done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using factories with the FakeRepository</h1>
                
            
            <article>
                
<p class="calibre2">So far this has been a relatively straight-forward exercise. The <kbd class="calibre11">Speaker</kbd> class represents the shape of the object that will be persisted to the database. The <kbd class="calibre11">HardCodedSpeakers</kbd> collection represents the entire set of <em class="calibre12">speakers</em> from a database.</p>
<p class="calibre2">It's not entirely ideal to have or maintain a set of hardcoded data, whether it's in a test file or not. It would be far more flexible to provide a way for the test writer to define the data with which to test.</p>
<p class="calibre2">Using a factory to create speakers and add them to the <kbd class="calibre11">FakeRepository</kbd> provides a much cleaner and easier-to-maintain way of managing the state of the tests that require specific data scenarios.</p>
<pre class="calibre19">public static class SpeakerFactory<br class="title-page-name"/>{<br class="title-page-name"/>  public static Speaker Create(FakeRepository fakeRepository, int id = 1, string name = "Joshua", string location = "Springfield, IL")<br class="title-page-name"/>  {<br class="title-page-name"/>    var speaker = new Speaker<br class="title-page-name"/>    {<br class="title-page-name"/>      Id = id,<br class="title-page-name"/>      Name = name,<br class="title-page-name"/>      Location = location<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    fakeRepository.Speakers.Add(speaker);<br class="title-page-name"/><br class="title-page-name"/>    return speaker;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Note that default values defined for id, name, and location have been provided. This allows the user to supply specific values if they want, or proceed without the need for supplying them.</p>
<p class="calibre2">The <kbd class="calibre11">FakeRepository</kbd> must also be modified to remove the <kbd class="calibre11">HardCodedSpeakers</kbd> and expose a public collection of speakers.</p>
<pre class="calibre19">public class FakeRepository : IRepository<br class="title-page-name"/>{<br class="title-page-name"/>  public List&lt;Speaker&gt; Speakers = new List&lt;Speaker&gt;();<br class="title-page-name"/>  public bool GetAllCalled { get; private set; }<br class="title-page-name"/>  <br class="title-page-name"/>  public IEnumerable&lt;Speaker&gt; GetAll()<br class="title-page-name"/>  {<br class="title-page-name"/>    GetAllCalled = true;<br class="title-page-name"/> <br class="title-page-name"/>    return Speakers;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, for each test a specific set of data can be provided with which to test. All that is required is that the factory be called to create one or more speakers to add to the <kbd class="calibre11">FakeRepository</kbd>.</p>
<pre class="calibre19">public GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  _fakeRepository = new FakeRepository();<br class="title-page-name"/>  SpeakerFactory.Create(_fakeRepository);<br class="title-page-name"/>  _speakerService = new SpeakerService(_fakeRepository);<br class="title-page-name"/>}</pre>
<p class="calibre2">If you have been following along with the same solution from previous chapters, you may need to modify the Search tests as well.</p>
<pre class="calibre19">public Search()<br class="title-page-name"/>{<br class="title-page-name"/>  var fakeRepository = new FakeRepository();<br class="title-page-name"/>  SpeakerFactory.Create(fakeRepository);<br class="title-page-name"/>  SpeakerFactory.Create(fakeRepository, name:"Josh");<br class="title-page-name"/>  SpeakerFactory.Create(fakeRepository, name:"Joseph");<br class="title-page-name"/>  SpeakerFactory.Create(fakeRepository, name:"Bill");<br class="title-page-name"/>  _speakerService = new SpeakerService(fakeRepository);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Soft delete</h1>
                
            
            <article>
                
<p class="calibre2">It was decided that it would be useful to be able to "soft delete" a speaker from the system. A "soft delete" allows for the record to be marked as deleted without physically deleting the record.  This will help maintain referential integrity while achieving the desired result.</p>
<p class="calibre2">First, add an extension method to the SpeakerFactory called <kbd class="calibre11">IsDeleted</kbd> that will set the speaker to be deleted.</p>
<pre class="calibre19">public static Speaker IsDeleted(this Speaker speaker)<br class="title-page-name"/>{<br class="title-page-name"/>  speaker.IsDeleted = true;<br class="title-page-name"/>  return speaker;<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, create a test to ensure that this speaker is not returned when <kbd class="calibre11">GetAll</kbd> is called.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerIsDeletedSpeakerIsNotReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var fakeRepository = new FakeRepository();<br class="title-page-name"/>  SpeakerFactory.Create(fakeRepository).IsDeleted();<br class="title-page-name"/>  var speakerService = new SpeakerService(fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speakers = speakerService.GetAll().ToList();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speakers);<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;IEnumerable&lt;SpeakerSummary&gt;&gt;(speakers);<br class="title-page-name"/>  Assert.Equal(0, speakers.Count);           <br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, modify the code to guarantee the "deleted" speaker is not returned.</p>
<pre class="calibre19">public IEnumerable&lt;SpeakerSummary&gt; GetAll()<br class="title-page-name"/>{<br class="title-page-name"/>  return _repository.GetAll()<br class="title-page-name"/>    .Where(x =&gt; !x.IsDeleted)<br class="title-page-name"/>    .Select(speaker =&gt; new SpeakerSummary<br class="title-page-name"/>      {<br class="title-page-name"/>        Id = speaker.Id,<br class="title-page-name"/>        Name = speaker.Name,<br class="title-page-name"/>        Location = speaker.Location<br class="title-page-name"/>      });<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Speaker details</h1>
                
            
            <article>
                
<p class="calibre2">Next up we come to the speaker details. We've chosen to continue in the back-end application as we'll tie the entire program together in up coming chapters.  </p>
<p class="calibre2">As stated earlier, this is where the real value is delivered for the first set of requirements. User groups and conference organizers will be able to contact a speaker using the information provided in the details view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">API</h1>
                
            
            <article>
                
<p class="calibre2">To return the details of an individual speaker, a new endpoint is needed. A new method <kbd class="calibre11">Get</kbd> is required which will take an integer ID and return a <kbd class="calibre11">SpeakerDetail</kbd> ViewModel.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">API tests</h1>
                
            
            <article>
                
<p class="calibre2">To get started, add a new test class named <kbd class="calibre11">Get</kbd>. Now, add a test to check that the <kbd class="calibre11">Get</kbd> method exists.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  var controller = new SpeakerController(speakerServiceMock.Object);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = controller.Get();<br class="title-page-name"/>}</pre>
<p class="calibre2">Make this test pass by adding a <kbd class="calibre11">Get</kbd> method to the <kbd class="calibre11">SpeakerController</kbd>. Note that, in the following example, the <kbd class="calibre11">Arrange</kbd> test setup has been moved to the constructor of the test class.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Get();<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, ensure that the <kbd class="calibre11">Get</kbd> method accepts an integer.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAcceptsInteger()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Get(1);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to make this test pass, an integer parameter will need to be added to the <kbd class="calibre11">Get</kbd> method. At this time, it is safe to delete the <kbd class="calibre11">ItExists</kbd> method. This test would need to be modified to accommodate the change, and its existence would be verified with the new test.</p>
<pre class="calibre19">public void Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>} </pre>
<p class="calibre2">Now that the tests confirm that the <kbd class="calibre11">Get</kbd> method accepts an integer, now confirm that it returns an <kbd class="calibre11">Ok</kbd> result.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsOkObjectResult()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _controller.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsType&lt;OkObjectResult&gt;(result);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, ensure that the result is a <kbd class="calibre11">SpeakerDetail</kbd>.</p>
<pre class="calibre19">[Fact]       <br class="title-page-name"/>public void ItReturnsSpeakerDetail()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _controller.Get(1) as OkObjectResult;<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  Assert.NotNull(result.Value);<br class="title-page-name"/>  Assert.IsType&lt;SpeakerDetail&gt;(result.Value);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to get this test to pass, a <kbd class="calibre11">SpeakerDetail</kbd> object is required. Create an empty object with no properties, as none are yet required by the tests.</p>
<pre class="calibre19">public IActionResult Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return Ok(new SpeakerDetail());<br class="title-page-name"/>} </pre>
<p class="calibre2">Just like with the <kbd class="calibre11">GetAll</kbd> method, the logic for this action should reside in the <em class="calibre12">Service.</em> Create a test to check that the <kbd class="calibre11">Get</kbd> method in the <kbd class="calibre11">SpeakerService</kbd> is called using <kbd class="calibre11">Moq</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsGetServiceOnce()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  _speakerServiceMock.Verify(mock =&gt; mock.Get(), Times.Once());<br class="title-page-name"/>}</pre>
<p class="calibre2">To get the application to compile a <kbd class="calibre11">Get</kbd> method, a signature will need to be added to the <kbd class="calibre11">IService</kbd> interface.</p>
<pre class="calibre19">void Get();</pre>
<p class="calibre2">The <kbd class="calibre11">SpeakerService</kbd> will need to be modified in order to get the application to compile.</p>
<pre class="calibre19">public void Get()<br class="title-page-name"/>{<br class="title-page-name"/>  throw new NotImplementedException();<br class="title-page-name"/>}</pre>
<p class="calibre2">To make this test pass, simply call the <kbd class="calibre11">Get</kbd> method of the <kbd class="calibre11">SpeakerService</kbd>.</p>
<pre class="calibre19">public IActionResult Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  _speakerService.Get();<br class="title-page-name"/><br class="title-page-name"/>  return Ok(new SpeakerDetail());<br class="title-page-name"/>}</pre>
<p class="calibre2">The method signature of the <kbd class="calibre11">Get</kbd> method in the <kbd class="calibre11">ISpeakerService</kbd> will need to be modified to return a <kbd class="calibre11">SpeakerDetail</kbd> instead of <kbd class="calibre11">void</kbd>.</p>
<pre class="calibre19">SpeakerDetail Get();</pre>
<p class="calibre2">Now ensure that the ID passed into the <kbd class="calibre11">Get</kbd> method in the <kbd class="calibre11">SpeakerController</kbd> is what is provided to the <kbd class="calibre11">Get</kbd> method in the <kbd class="calibre11">SpeakerService</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsGetServiceWithProvidedId()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  const int id = 1;<br class="title-page-name"/>  <br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  _speakerServiceMock.Verify(mock =&gt; mock.Get(id),Times.Once());<br class="title-page-name"/>}</pre>
<p class="calibre2">This will require modifications to the <kbd class="calibre11">ISpeakerService</kbd> interface as well as the <kbd class="calibre11">SpeakerService</kbd> class.</p>
<pre class="calibre19">SpeakerDetail Get(int id);<br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  throw new NotImplementedException();<br class="title-page-name"/>}</pre>
<p class="calibre2">Now return the result of the <kbd class="calibre11">Get</kbd> method of the <kbd class="calibre11">SpeakerService</kbd>.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerServiceThenResultIsReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _controller.Get(1) as OkObjectResult;<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  var speaker = ((SpeakerDetail)result.Value);<br class="title-page-name"/>  Assert.Equal(_speaker, speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to make this test pass, simply return the result of the <kbd class="calibre11">Get</kbd> method.</p>
<pre class="calibre19">public IActionResult Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _speakerService.Get();<br class="title-page-name"/><br class="title-page-name"/>  return Ok(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">Here is what the final results of the <kbd class="calibre11">SpeakerController</kbd> currently look like:</p>
<pre class="calibre19">using Microsoft.AspNetCore.Mvc;<br class="title-page-name"/>using SpeakerMeet.Api.Services;<br class="title-page-name"/><br class="title-page-name"/>namespace SpeakerMeet.Api.Controllers<br class="title-page-name"/>{<br class="title-page-name"/>  [Route("api/[controller]")]<br class="title-page-name"/>  public class SpeakerController : Controller<br class="title-page-name"/>  {<br class="title-page-name"/>    private readonly ISpeakerService _speakerService;<br class="title-page-name"/><br class="title-page-name"/>    public SpeakerController(ISpeakerService speakerService)<br class="title-page-name"/>    {<br class="title-page-name"/>      _speakerService = speakerService;<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    [Route("search")]<br class="title-page-name"/>    public IActionResult Search(string searchString)<br class="title-page-name"/>    {<br class="title-page-name"/>      var speakers = _speakerService.Search(searchString);<br class="title-page-name"/><br class="title-page-name"/>      return Ok(speakers);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public IActionResult GetAll()<br class="title-page-name"/>    {<br class="title-page-name"/>      var speakers = _speakerService.GetAll();<br class="title-page-name"/><br class="title-page-name"/>      return Ok(speakers);<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    public IActionResult Get(int id)<br class="title-page-name"/>    {<br class="title-page-name"/>      var speaker = _speakerService.Get(id);<br class="title-page-name"/><br class="title-page-name"/>      return Ok(speaker);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service</h1>
                
            
            <article>
                
<p class="calibre2">Now that the controller is calling the <kbd class="calibre11">Get</kbd> method of the <kbd class="calibre11">Moq</kbd> service, it's time to implement this method in the <kbd class="calibre11">SpeakerService</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service tests</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre11">Get</kbd> method was declared as a result of previous tests. Create a new <kbd class="calibre11">ItExists</kbd> test and delete the implementation to see it fail.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasGetMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  _speakerService.Get();<br class="title-page-name"/>}</pre>
<p class="calibre2">Make this test pass by implementing the <kbd class="calibre11">Get</kbd> method.</p>
<pre class="calibre19">public void Get()<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Now ensure the <kbd class="calibre11">Get</kbd> method accepts an integer.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAcceptsAnInteger()<br class="title-page-name"/>{<br class="title-page-name"/>  // Act<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  _speakerService.Get(1);<br class="title-page-name"/>}</pre>
<p class="calibre2">Modify the <kbd class="calibre11">Get</kbd> method to accept an integer.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Test that the <kbd class="calibre11">Get</kbd> method returns a <kbd class="calibre11">SpeakerDetail</kbd> object.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsSpeakerDetail()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = _speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(speaker);<br class="title-page-name"/>  Assert.IsType&lt;SpeakerDetail&gt;(speaker);<br class="title-page-name"/>}</pre>
<p class="calibre2">To make this test pass, simply return a new <kbd class="calibre11">SpeakerDetail</kbd> object.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new SpeakerDetail();<br class="title-page-name"/>}</pre>
<p class="calibre2">Verify that the <kbd class="calibre11">SpeakerDetail</kbd> returned contains an ID.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerReturnsId()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = _speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, speaker.Id);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now make the test pass.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = 1,<br class="title-page-name"/>    Name = "Joshua"<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">Confirm that the <kbd class="calibre11">SpeakerDetail</kbd> contains a name.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerReturnsName()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = _speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Joshua", speaker.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">And make the test pass.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = 1,<br class="title-page-name"/>    Name = "Joshua"<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, ensure that <kbd class="calibre11">Location</kbd> is returned.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerReturnsLocation()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = _speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Tampa, FL", speaker.Location);<br class="title-page-name"/>}</pre>
<p class="calibre2">And make the test pass by returning the location.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = 1,<br class="title-page-name"/>    Name = "Joshua",<br class="title-page-name"/>    Location = "Tampa, FL"<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Clean the tests</h1>
                
            
            <article>
                
<p class="calibre2">Don’t forget to clean and refactor the tests. Collapse the property tests.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerReturnsSpeakerWithProperties()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var speaker = _speakerService.Get(1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal(1, speaker.Id);<br class="title-page-name"/>  Assert.Equal("Joshua", speaker.Name);<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">More from the repository</h1>
                
            
            <article>
                
<p class="calibre2">Now, verify that the repository is called.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var fakeRepository = new FakeRepository();<br class="title-page-name"/>  var service = new SpeakerService(fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  service.Get(-1);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(fakeRepository.GetCalled);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now ensure the test passes by implementing the necessary modification.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  _repository.Get();<br class="title-page-name"/><br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = 1,<br class="title-page-name"/>    Name = "Joshua"<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Additional factory work</h1>
                
            
            <article>
                
<p class="calibre2">As before, it would be ideal if the values weren't hardcoded. Use the factory to create a speaker and have the repository return the designated speaker.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItReturnsSpeakerFromRepository()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var fakeRepository = new FakeRepository();<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(fakeRepository, 2, "Bill");<br class="title-page-name"/>  var service = new SpeakerService(fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var actualSpeaker = service.Get(expectedSpeaker.Id);<br class="title-page-name"/> <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(fakeRepository.GetCalled);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Id, actualSpeaker.Id);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Name, actualSpeaker.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">To get this to pass requires a modification to <kbd class="calibre11">IRepository</kbd>, <kbd class="calibre11">FakeRepository</kbd>, and <kbd class="calibre11">Service</kbd>.</p>
<p class="calibre2"><kbd class="calibre11">IRepository</kbd>:</p>
<pre class="calibre19">        Speaker Get(int id);</pre>
<p class="calibre2"><kbd class="calibre11">FakeRepository</kbd>:</p>
<pre class="calibre19">public Speaker Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  GetCalled = true;<br class="title-page-name"/><br class="title-page-name"/>  return Speakers.Find(x =&gt; x.Id == id);<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre11">Service</kbd>:</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">All previous tests to <kbd class="calibre11">ItReturnsSpeakerFromRepository</kbd> can now be deleted. These were all yak shaving in order to get to this point.</p>
<p class="calibre2">Now, to ensure that this will work with numerous values, convert the last test to a set of theories.</p>
<pre class="calibre19">[Theory]<br class="title-page-name"/>[InlineData(1, "Joshua")]<br class="title-page-name"/>[InlineData(2, "Bill")]<br class="title-page-name"/>[InlineData(3, "Suzie")]<br class="title-page-name"/>public void ItReturnsSpeakerFromRepository(int id, string name)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository, id, name);<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var actualSpeaker = service.Get(expectedSpeaker.Id);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.True(_fakeRepository.GetCalled);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Id, actualSpeaker.Id);<br class="title-page-name"/>  Assert.Equal(expectedSpeaker.Name, actualSpeaker.Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">All the tests should pass. If for some reason a failing test is encountered, do not proceed until the failing test is resolved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing exception cases</h1>
                
            
            <article>
                
<p class="calibre2">Testing exception cases is a very important step. In this case, the business has defined a case where we will return a <span>SPEAKER NOT FOUND</span> error if the speaker does not exist. It is also important for the developer to consider any significant edge cases the business has missed. Discuss them with the business if you can and get them added to the spec.</p>
<p class="calibre2">Now test that the speaker must exist.</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerNotFoundThenSpeakerNotFoundException()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var exception = Record.Exception(() =&gt; service.Get(-1));<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerNotFoundException&gt;(exception);<br class="title-page-name"/>}</pre>
<p class="calibre2">And make it pass.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name<br class="title-page-name"/>  };<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, verify that the speaker is not deleted. If it is deleted, throw the same <kbd class="calibre11">SpeakerNotFoundException</kbd><em class="calibre12">.</em></p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerIsDeletedThenSpeakerNotException()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var expectedSpeaker = SpeakerFactory.Create(_fakeRepository).IsDeleted();<br class="title-page-name"/>  var service = new SpeakerService(_fakeRepository);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var exception = Record.Exception(() =&gt; service.Get(expectedSpeaker.Id));<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.IsAssignableFrom&lt;SpeakerNotFoundException&gt;(exception);<br class="title-page-name"/>}</pre>
<p class="calibre2">The simplest, most effective way to make this test pass is to throw an exception if the speaker found has been deleted. Make the necessary change to the <kbd class="calibre11">Get</kbd> method.</p>
<pre class="calibre19">public SpeakerDetail Get(int id)<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = _repository.Get(id);<br class="title-page-name"/><br class="title-page-name"/>  if (speaker == null || speaker.IsDeleted)<br class="title-page-name"/>  {<br class="title-page-name"/>    throw new SpeakerNotFoundException();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  return new SpeakerDetail<br class="title-page-name"/>  {<br class="title-page-name"/>    Id = speaker.Id,<br class="title-page-name"/>    Name = speaker.Name<br class="title-page-name"/>   };<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Now, you should feel fairly comfortable with the requirements surrounding the <span>Speaker Meet application and have had a decent introduction to the API, Service, and Repository layers for the Speaker section of the back-end application. Mocks and Fakes continue to play a role in the Test-Driving of the program.</span></p>
<p class="calibre2">In <a target="_blank" href="part0277.html#885BQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 8</a>, <em class="calibre12">Abstract Away Problems</em>, more will be discussed with respect to abstractions. The models for <kbd class="calibre11">SpeakerSummary</kbd> and <kbd class="calibre11">SpeakerDetail</kbd> will be grown to include more properties. Additional details will be provided on how best to increase the functionality, and with it the complexity, of the application.</p>
<p class="calibre2"/>
<p class="calibre2"/>


            </article>

            
        </section>
    </body></html>