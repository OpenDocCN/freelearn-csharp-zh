<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in Other JavaScript Frameworks</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 9</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Anti-Patterns and Misconceptions on Dependency Injection</span></em><span class="koboSpan" id="kobo.6.1">, we covered the most important anti-patterns when using Dependency Injection, together with some typical misconceptions when it comes to how to use it. </span><span class="koboSpan" id="kobo.6.2">In this chapter, we're going to deal with Dependency Injection in other framework, specifically in TypeScript 2.3 and Angular 4+.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The reason for reviewing the very basics of TypeScript is that Angular 2+ uses this language, so we need some understanding of how class creation and module management is undertaken to really grasp the main concepts behind this architecture.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will cover:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Class creation and module management in TypeScript 2.3+</span></li>
<li><span class="koboSpan" id="kobo.10.1">Native implementation and usage of DI techniques in AngularJS (version 1.x)</span></li>
<li><span class="koboSpan" id="kobo.11.1">Native implementation and customizable options to use DI in Angular 4+</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">TypeScript</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You probably already know the role that TypeScript plays in the development of modern JavaScript frameworks, and even by itself as an improved replacement for JavaScript.</span></p>
<p><span class="koboSpan" id="kobo.3.1">TypeScript has many times been defined as a strongly typed superset of JavaScript. </span><span class="koboSpan" id="kobo.3.2">It is a superset because it includes everything JavaScript has (and that extends to versions 3, 5, and 6, also called ES2015), plus a number of features to allow programmers to code in an object-oriented paradigm. </span><span class="koboSpan" id="kobo.3.3">At the time of writing, the latest version available is 2.3:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img height="211" width="260" src="assets/4c4122d3-ea45-48e1-b556-b0fd41235c5d.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1">(Image courtesy: </span><a href="http://blog.soat.fr/2016/08/feedback-typescript/"><span class="URLPACKT"><span class="koboSpan" id="kobo.6.1">http://blog.soat.fr/2016/08/feedback-typescript</span></span><span class="koboSpan" id="kobo.7.1">/</span></a><span class="koboSpan" id="kobo.8.1">)</span></div>
<p><span class="koboSpan" id="kobo.9.1">Consequently, we find many syntactical benefits while it still lets you write normal JavaScript if you want to (an important point is that any valid JavaScript is valid TypeScript).</span></p>
<p><span class="koboSpan" id="kobo.10.1">In this way, TypeScript fosters a more declarative style of programming by using interfaces and static typing, it offers the concepts of modules and classes, and it's capable of integrating well with most existing JavaScript libraries and code. </span><span class="koboSpan" id="kobo.10.2">We can see it as a strongly static layer over JavaScript with a bunch of features to make the programmer's work (especially debugging) much more manageable.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.11.1">If you want to get a nice introduction to the TypeScript language, you can read </span><em><span class="koboSpan" id="kobo.12.1">Introducing Object-Oriented Programming with TypeScript</span></em><span class="koboSpan" id="kobo.13.1">, by Remo H. </span><span class="koboSpan" id="kobo.13.2">Jansen, (see </span><a href="https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript"><span class="URLPACKT"><span class="koboSpan" id="kobo.14.1">https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript</span></span></a><span class="koboSpan" id="kobo.15.1">) and, if you prefer to delve deeply into the language and its possibilities, take a look at the excellent </span><em><span class="koboSpan" id="kobo.16.1">Mastering TypeScript</span></em><span class="koboSpan" id="kobo.17.1"> by Nathan Rozentals, available at </span><span class="URLPACKT"><a href="https://www.packtpub.com/web-development/mastering-typescript"><span class="koboSpan" id="kobo.18.1">https://www.packtpub.com/web-development/mastering-typescript</span></a><span class="koboSpan" id="kobo.19.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.20.1">The main goals of Anders Hejlsberg (the TypeScript Chief Architect) when creating the language were:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.21.1">Creating a totally object-oriented language that would convert into JavaScript at compilation time (it's called </span><strong><span class="koboSpan" id="kobo.22.1">transpilation</span></strong><span class="koboSpan" id="kobo.23.1"> since it just produces another language and not a compiled module), allowing the final JavaScript generated to be executed in any browser (or Web platform).</span></li>
<li><span class="koboSpan" id="kobo.24.1">Make the language statically typed, so the tools could offer modern development technologies in any editor: Intellisense, Code Completion, Intelligent Refactoring, and so on.</span></li>
<li><span class="koboSpan" id="kobo.25.1">Engage the community in the project by making the language completely open source. </span><span class="koboSpan" id="kobo.25.2">You can see the current state of the project and collaborate on its website at </span><a href="http://www.typescriptlang.org/"><span class="URLPACKT"><span class="koboSpan" id="kobo.26.1">http://www.typescriptlang.org/</span></span></a><span class="koboSpan" id="kobo.27.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">Actually, TypeScript has been so successful that the Angular development team adopted it for the creation of Angular 2 and keeps on working with the language for coming versions (the most recent being Angular 4.1).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Architectural changes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Understanding some architectural changes is fundamental to realize how you can implement DI in a language that, once transpiled, is not object-oriented, except if you are doing that transpilation into ES2015.</span></p>
<p><span class="koboSpan" id="kobo.3.1">One of the biggest changes in ES2015 (or ES6, for short) is the presence of modules. </span><span class="koboSpan" id="kobo.3.2">A module is, basically, a piece of JavaScript code stored into a file. </span><span class="koboSpan" id="kobo.3.3">Once written, you can say that you have one file per module and one module per file.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Modules in TypeScript</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">TypeScript defines two different types of modules--internal and external. </span><span class="koboSpan" id="kobo.2.2">Moreover, we could still differentiate internal ones into two more categories: those that have a name and those that don't (you could call them implicit). </span><span class="koboSpan" id="kobo.2.3">The difference, in this case, is in the way you define them and use them.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Say you have a TypeScript file including the following:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">    // Implicit module (goes to the global namespace) 
    // It appears as part of the window object 
    class ClassA { 
      private x = "The String"; 
      public y = 4; 
    }; 
    var ca = new ClassA();   </span></pre>
<p><span class="koboSpan" id="kobo.5.1">This code by itself is an implicit module. </span><span class="koboSpan" id="kobo.5.2">It becomes a part of the global namespace and you can find it inside the </span><kbd><span class="koboSpan" id="kobo.6.1">window</span></kbd><span class="koboSpan" id="kobo.7.1"> object at runtime. </span><span class="koboSpan" id="kobo.7.2">You could also consider the global namespace as the implicit (default) module.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Of course, we have better solutions than polluting the global namespace. </span><span class="koboSpan" id="kobo.8.2">The most obvious one is the </span><kbd><span class="koboSpan" id="kobo.9.1">module</span></kbd><span class="koboSpan" id="kobo.10.1"> keyword which allows defining a private code section.</span></p>
<p><span class="koboSpan" id="kobo.11.1">By definition, everything declared inside a module is private to that module. </span><span class="koboSpan" id="kobo.11.2">Therefore, the new reserved words </span><kbd><span class="koboSpan" id="kobo.12.1">import</span></kbd><span class="koboSpan" id="kobo.13.1"> and </span><kbd><span class="koboSpan" id="kobo.14.1">export</span></kbd><span class="koboSpan" id="kobo.15.1"> are used to allow access to a piece of code inside a named module.</span></p>
<p><span class="koboSpan" id="kobo.16.1">If we wrap the previous class inside a module definition, any attempt to reference a module's member outside the module is not recognized (see the following screenshot, inside the Visual Studio 2017 editor):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="201" width="323" class=" image-border" src="assets/0ff8b7b8-20d9-4ff5-9cae-58563dc37040.png"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">To make a module's members available outside the module you should use the </span><kbd><span class="koboSpan" id="kobo.19.1">export</span></kbd><span class="koboSpan" id="kobo.20.1"> keyword. </span><span class="koboSpan" id="kobo.20.2">Change the previous declaration into this:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    export class ClassA </span></pre>
<p><span class="koboSpan" id="kobo.22.1">Then, you can use the module's name to access its public members:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">    var c = new MyClasses.ClassA(); 
    console.log(c.y); // Logs 4 in the console window. </span></pre>
<p><span class="koboSpan" id="kobo.24.1">Notice that the </span><kbd><span class="koboSpan" id="kobo.25.1">ClassA.x</span></kbd><span class="koboSpan" id="kobo.26.1"> member is not accessible either due to its private declaration. </span><span class="koboSpan" id="kobo.26.2">In this manner, we have a convenient way to keep things tied to the namespace they should belong to.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">External modules</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">However, the most useful approach when you're dealing with large applications is the use of external modules. </span><span class="koboSpan" id="kobo.2.2">Actually, as John Papa suggests (</span><a href="https://johnpapa.net/typescriptpost4/"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">https://johnpapa.net/typescriptpost4/</span></span></a><span class="koboSpan" id="kobo.4.1">), it may be useful to organize the functionality of an application in terms of the modules you'll need.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Let's say we have a module definition inside the </span><kbd><span class="koboSpan" id="kobo.6.1">ES6Code.ts</span></kbd><span class="koboSpan" id="kobo.7.1"> file. </span><span class="koboSpan" id="kobo.7.2">To export the </span><kbd><span class="koboSpan" id="kobo.8.1">foo()</span></kbd><span class="koboSpan" id="kobo.9.1">function and </span><kbd><span class="koboSpan" id="kobo.10.1">Timer</span></kbd><span class="koboSpan" id="kobo.11.1"> class, you declare them as follows:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">    // File ES6Code.ts  
    module ES6Code { 
      export function foo() { console.log("Foo executed"); } 
      export class Timer { 
        localTime: string; 
        currentDate: string; 
        constructor( todaysDate:Date ) { 
            this.localTime = todaysDate.toTimeString(); 
            this.currentDate = todaysDate.toLocaleDateString(); 
        } 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.13.1">Now, in a distinct module or script section we can access that functionality using a slightly different reference:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    // File: app.ts --------- 
    // Simple Function Import  
    import foo = ES6Code.foo; 
    foo();  // OK. </span></pre>
<p><span class="koboSpan" id="kobo.15.1">The same goes for the </span><kbd><span class="koboSpan" id="kobo.16.1">Timer</span></kbd><span class="koboSpan" id="kobo.17.1"> class, except that we can also adopt another approach to reference the class:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">    // File: app.ts --------- 
    // Reference Class Import (alternative syntax) 
    var timer = new ES6Code.Timer(new Date()); 
    console.log(timer.currentDate); 
    console.log(timer.localTime); </span></pre>
<p><span class="koboSpan" id="kobo.19.1">In this case, the module's name is used as a prefix to the class instantiation, in a similar way to what you find in C# code when dealing with namespaces.</span></p>
<p><span class="koboSpan" id="kobo.20.1">To test this code, we just have to include references to the corresponding transpiled files (</span><kbd><span class="koboSpan" id="kobo.21.1">.js</span></kbd><span class="koboSpan" id="kobo.22.1"> extension), inside an HTML page, or test it inside the Node console. </span><span class="koboSpan" id="kobo.22.2">For instance, if you use a blank HTML page, you could include the files in this manner:</span></p>
<pre><span class="koboSpan" id="kobo.23.1">    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;&lt;/title&gt; 
      &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt; 
      &lt;script src="ES6Code.js"&gt;&lt;/script&gt; 
      &lt;script src="app.js"&gt;&lt;/script&gt; 
  &lt;/head&gt; </span></pre>
<div class="packt_infobox"><span class="koboSpan" id="kobo.24.1">Note: The </span><kbd><span class="koboSpan" id="kobo.25.1">&lt;link&gt;</span></kbd><span class="koboSpan" id="kobo.26.1"> tag is a fake favicon to prevent Chrome from presenting a </span><span class="packt_screen"><span class="koboSpan" id="kobo.27.1">File Not Found</span></span><span class="koboSpan" id="kobo.28.1"> error in the console, next to the output.</span></div>
<p><span class="koboSpan" id="kobo.29.1">In both cases, the reference is correct, and the code is executed as expected, as we can see in the following screenshot (remember: </span><kbd><span class="koboSpan" id="kobo.30.1">F12/Console</span></kbd><span class="koboSpan" id="kobo.31.1"> inside the developer's tools of any modern browser. </span><span class="koboSpan" id="kobo.31.2">I'm using Chrome here):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.32.1"><img height="136" width="382" class=" image-border" src="assets/4efb9134-695c-4612-b276-7070d1815d10.png"/></span></div>
<p><span class="koboSpan" id="kobo.33.1">This is possible because, once the files are referenced inside a page, their members become accessible as long as they are marked as </span><kbd><span class="koboSpan" id="kobo.34.1">export</span></kbd><span class="koboSpan" id="kobo.35.1">.</span></p>
<p><span class="koboSpan" id="kobo.36.1">Actually, we can reference several files, and they'll be loaded and executed in sequence. </span><span class="koboSpan" id="kobo.36.2">Notice also that the console window indicates which code is responsible for the execution of which entry in the console.</span></p>
<p><span class="koboSpan" id="kobo.37.1">In the initial example, </span><kbd><span class="koboSpan" id="kobo.38.1">MyClasses</span></kbd><span class="koboSpan" id="kobo.39.1"> was stored inside the </span><kbd><span class="koboSpan" id="kobo.40.1">app1.ts</span></kbd><span class="koboSpan" id="kobo.41.1"> file. </span><span class="koboSpan" id="kobo.41.2">So, now, we could also reference it, before the </span><kbd><span class="koboSpan" id="kobo.42.1">&lt;/head&gt;</span></kbd><span class="koboSpan" id="kobo.43.1"> tag, and check how a third source origin shows up in the console, which outputs the number </span><span class="packt_screen"><span class="koboSpan" id="kobo.44.1">4</span></span><span class="koboSpan" id="kobo.45.1">, in the last position (check it in the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img height="143" width="431" class=" image-border" src="assets/4ac5e5ae-8c88-4016-b656-f93411c52070.png"/></span></div>
<p><span class="koboSpan" id="kobo.47.1">Also, you'll notice that Chrome is smart enough to reference the original </span><kbd><span class="koboSpan" id="kobo.48.1">.ts</span></kbd><span class="koboSpan" id="kobo.49.1"> files and not the transpiled ones, allowing you to debug any of these files, setting breakpoints, and so on. </span><span class="koboSpan" id="kobo.49.2">In the following screenshot, I'm showing the debugging window inside Chrome after setting a breakpoint before printing the date and time values:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.50.1"><img height="214" width="387" class=" image-border" src="assets/fcc46658-0505-44bf-821b-3009b34a7095.png"/></span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.51.1">Besides these options, now it's possible to debug within Visual Studio 2017 using Chrome as default browser.</span></div>
<p><span class="koboSpan" id="kobo.52.1">This module separation is important because, as you'll see later, that implies file separation, which becomes crucial in the way TypeScript and, especially, Angular organize the distinct components of an application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in TypeScript</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">All that said, TypeScript itself doesn't have a DI container. </span><span class="koboSpan" id="kobo.2.2">However, you could use some of the third-party options available. </span><span class="koboSpan" id="kobo.2.3">Some of the most popular are </span><kbd><span class="koboSpan" id="kobo.3.1">Infuse.js</span></kbd><span class="koboSpan" id="kobo.4.1"> (available at </span><a href="https://github.com/soundstep/infuse.js"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">https://github.com/soundstep/infuse.js</span></span></a><span class="koboSpan" id="kobo.6.1">) and TypeScript IoC, which you can find on the NPMJS site (</span><a href="https://www.npmjs.com/package/typescript-ioc"><span class="URLPACKT"><span class="koboSpan" id="kobo.7.1">https://www.npmjs.com/package/typescript-ioc</span></span></a><span class="koboSpan" id="kobo.8.1">), both of which work in a very similar way to what we've already seen in .NET Core.</span></p>
<p><span class="koboSpan" id="kobo.9.1">That is, you have to make definitions that map an interface to a class or even a descriptor to a class and then register those options. </span><span class="koboSpan" id="kobo.9.2">Later on, you can make a reference to the type required and expect the DI container to provide you with the corresponding type.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Let's review the way TypeScript IoC works to define a simple injection scenario, the way it's shown on its official page.</span></p>
<p><span class="koboSpan" id="kobo.11.1">First, assuming you have TypeScript installed, you should also install TypeScript IoC, with a typical </span><kbd><span class="koboSpan" id="kobo.12.1">npm</span></kbd><span class="koboSpan" id="kobo.13.1"> command:</span></p>
<pre>    <strong><span class="koboSpan" id="kobo.14.1">npm install typescript-ioc</span></strong>  </pre>
<p><span class="koboSpan" id="kobo.15.1">Besides that, some modern options are also required inside the configuration file (the </span><kbd><span class="koboSpan" id="kobo.16.1">tsconfig.json</span></kbd><span class="koboSpan" id="kobo.17.1"> file):</span></p>
<pre><span class="koboSpan" id="kobo.18.1">    { 
      "compilerOptions": { 
        "experimentalDecorators": true, 
        "emitDecoratorMetadata": true 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.19.1">Once that is configured, you use one of the </span><kbd><span class="koboSpan" id="kobo.20.1">import</span></kbd><span class="koboSpan" id="kobo.21.1"> syntax variants to put it to work:</span></p>
<pre><span class="koboSpan" id="kobo.22.1">    import {AutoWired, Inject} from "typescript-ioc"; 
    class PersonDAO { 
      @Inject restProxy: PersonRestProxy; 
    } </span></pre>
<p><span class="koboSpan" id="kobo.23.1">As you can see, the </span><kbd><span class="koboSpan" id="kobo.24.1">restProxy</span></kbd><span class="koboSpan" id="kobo.25.1"> property, which is of another type (</span><kbd><span class="koboSpan" id="kobo.26.1">PersonRestProxy</span></kbd><span class="koboSpan" id="kobo.27.1">), is marked with an </span><kbd><span class="koboSpan" id="kobo.28.1">@Inject</span></kbd><span class="koboSpan" id="kobo.29.1"> decorator (a new feature in the latest versions of JavaScript and available in TypeScript), to indicate that it can be injected later on inside other code).</span></p>
<p><span class="koboSpan" id="kobo.30.1">Somewhere else in the code, you'll be able to use these definitions with a very simple syntax:</span></p>
<pre><span class="koboSpan" id="kobo.31.1">    let personDAO: PersonDAO = new PersonDAO();  </span></pre>
<p><span class="koboSpan" id="kobo.32.1">The </span><kbd><span class="koboSpan" id="kobo.33.1">restProxy</span></kbd><span class="koboSpan" id="kobo.34.1"> property will be provided by the container, resolving the dependencies. </span><span class="koboSpan" id="kobo.34.2">Parameter injection is also provided, using a class with a constructor, as we can see in the following code:</span></p>
<pre><span class="koboSpan" id="kobo.35.1">    class PersonService { 
     private personDAO: PersonDAO; 
     constructor( @Inject personDAO: PersonDAO ) { 
       this.personDAO = personDAO; 
     } 
   } </span></pre>
<p><span class="koboSpan" id="kobo.36.1">If, later on, you have another class that uses </span><kbd><span class="koboSpan" id="kobo.37.1">PersonService</span></kbd><span class="koboSpan" id="kobo.38.1"> as a property, you mark that property with </span><kbd><span class="koboSpan" id="kobo.39.1">@Inject</span></kbd><span class="koboSpan" id="kobo.40.1">, like in this code:</span></p>
<pre><span class="koboSpan" id="kobo.41.1">    class PersonController {</span><br/><span class="koboSpan" id="kobo.42.1">     @Inject private personService: PersonService;</span><br/><span class="koboSpan" id="kobo.43.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.44.1">You can rely on the chain of dependencies being managed by the container, which will go through all references previously marked as </span><kbd><span class="koboSpan" id="kobo.45.1">@Inject</span></kbd><span class="koboSpan" id="kobo.46.1">.</span></p>
<p><span class="koboSpan" id="kobo.47.1">However, in practice, it's rare to see applications in TypeScript itself and the most common use of this language is to provide other frameworks, such as Angular or Ionic, with a consistent development language.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Angular</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As mentioned in </span><a href="9b8972f9-fedb-457b-a60a-8f62098bfa00.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Dependency Injection and IoC Containers</span></em><span class="koboSpan" id="kobo.6.1">, Angular is a development framework created by a team at Google (led by MiskoHevery), that has become very popular now (you can access the official information at </span><span class="URLPACKT"><a href="http://angularjs.org"><span class="koboSpan" id="kobo.7.1">http://angularjs.org</span></a><span class="koboSpan" id="kobo.8.1">)</span></span><span class="koboSpan" id="kobo.9.1">.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Nowadays, Angular is available in two flavors that follow different release paths or branches:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.11.1">Version 1.x</span></strong><span class="koboSpan" id="kobo.12.1">:  Also called </span><strong><span class="koboSpan" id="kobo.13.1">AngularJS</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">It's recommended for small/medium applications and uses the MVC model to implement a suitable separation of concerns, from the beginning:
</span><ul>
<li><span class="koboSpan" id="kobo.15.1">It's composed of a set of JavaScript libraries, each one supplying a part of the functionality required. </span><span class="koboSpan" id="kobo.15.2">However, all libraries depend on the basic </span><span><span class="koboSpan" id="kobo.16.1">AngularJS</span></span><span class="koboSpan" id="kobo.17.1"> library.</span></li>
<li><span class="koboSpan" id="kobo.18.1">At the time of writing, the latest version is 1.6.4, and the team guarantees support and future updates. </span><span class="koboSpan" id="kobo.18.2">It can also be downloaded via CDN at </span><span class="URLPACKT"><a href="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"><span class="koboSpan" id="kobo.19.1">https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js</span></a><span class="koboSpan" id="kobo.20.1">.</span></span></li>
</ul>
</li>
<li><strong><span class="koboSpan" id="kobo.21.1">Version 2+</span></strong><span class="koboSpan" id="kobo.22.1">: It's just named </span><strong><span class="koboSpan" id="kobo.23.1">Angular</span></strong><span class="koboSpan" id="kobo.24.1"> and it follows a semantic versioning path, which means no breaking changes are allowed in minor revisions, only in new versions. </span><span class="koboSpan" id="kobo.24.2">There was a version number jump that avoided 3.0, so the latest version is Angular 4 (4.1, to be precise). </span><span class="koboSpan" id="kobo.24.3">It has a dedicated website apart from AngularJS at </span><a href="https://angular.io/"><span class="URLPACKT"><span class="koboSpan" id="kobo.25.1">https://angular.io</span></span><span class="koboSpan" id="kobo.26.1">/</span></a><span class="koboSpan" id="kobo.27.1">:
</span><ul>
<li><span class="koboSpan" id="kobo.28.1">Perhaps the biggest change is that Angular is not backward-compatible with AngularJS since it embraces a number of changes that appeared in ES6 and directly affects the way modules are managed.</span></li>
<li><span class="koboSpan" id="kobo.29.1">Its main features are cross-compatibility, improved speed and performance, excellent tooling, and an increasing adoption by the community all over the world.</span></li>
<li><span class="koboSpan" id="kobo.30.1">Angular is built in TypeScript thanks to a joint venture with Microsoft's TypeScript team, which actively collaborates in the project. </span><span class="koboSpan" id="kobo.30.2">Recently, one of the lead members of the team announced: </span><em><span class="koboSpan" id="kobo.31.1">TypeScript has become allowed for unrestricted client development as of March 2017. </span><span class="koboSpan" id="kobo.31.2">TypeScript and Angular on TypeScript are used in Google Analytics, Firebase, and Google Cloud Platform and critical internal tools such as bug tracking, employee reviews, and product approval and launch tools</span></em><span class="koboSpan" id="kobo.32.1">.</span></li>
</ul>
</li>
</ul>
<p><span class="koboSpan" id="kobo.33.1">Both versions have some points in common from an architectural point of view. </span><span class="koboSpan" id="kobo.33.2">They foster SOLID principles, and especially SRP and DIP, so they both rely on Dependency Injection containers. </span><span class="koboSpan" id="kobo.33.3">Furthermore, the adoption of the MVC model helps to structure the separation of concerns.</span></p>
<p><span class="koboSpan" id="kobo.34.1">Let's see how these two popular architectures implement Dependency Injection (although in different ways).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">AngularJS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Creating a very basic Angular application is easy, once the basic principles of the MVC are clear. </span><span class="koboSpan" id="kobo.2.2">The MVC model proposes a foundational separation of application components into three parts (see the following figure): </span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="254" width="222" src="assets/dabe33e4-815f-4207-adb1-a5d71c704cb4.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">(Image courtesy: Wikipedia: </span><a href="https://en.wikipedia.org/wiki/Model-view-controller"><span class="URLPACKT"><span class="koboSpan" id="kobo.5.1">https://en.wikipedia.org/wiki/Model-view-controller</span></span></a><span class="koboSpan" id="kobo.6.1">)</span></div>
<p><span class="koboSpan" id="kobo.7.1">The user's interaction generates a circuit in which the three pillars of MVC are present:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">The </span><strong><span class="koboSpan" id="kobo.9.1">MODEL</span></strong><span class="koboSpan" id="kobo.10.1"> is created automatically in the loading process of the AngularJS library.</span></li>
<li><span class="koboSpan" id="kobo.11.1">The </span><strong><span class="koboSpan" id="kobo.12.1">VIEW</span></strong><span class="koboSpan" id="kobo.13.1"> corresponds to the HTML side, which is marked with custom attributes (all starting with </span><strong><em><span class="koboSpan" id="kobo.14.1">ng-</span></em></strong><span class="koboSpan" id="kobo.15.1">) to indicate the distinct functionality required. </span><span class="koboSpan" id="kobo.15.2">Views also use a syntax called </span><strong><span class="koboSpan" id="kobo.16.1">mustache</span></strong><span class="koboSpan" id="kobo.17.1"> to indicate which parts are subject to data-binding.</span></li>
<li><span class="koboSpan" id="kobo.18.1">The </span><strong><span class="koboSpan" id="kobo.19.1">CONTROLLERS</span></strong><span class="koboSpan" id="kobo.20.1"> are JavaScript fragments, coded to reflect any changes requested by the user, and manipulate the Model if required.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">When the user interacts with a UI element in the page, a controller takes care of the corresponding action, modifies the model if it is necessary, and Angular updates the view reflecting the changes. </span><span class="koboSpan" id="kobo.21.2">Finally, the view is received by the user and this cycle continues uninterruptedly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Examples using Visual Studio 2017</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once you have an HTML page that loads the AngularJS library, you should mark one DOM element with a special attribute (</span><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">ng-app</span></span><span class="koboSpan" id="kobo.4.1">) to notify Angular of its working scope. </span><span class="koboSpan" id="kobo.4.2">This defines the area of action for AngularJS inside the page.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Let's see all this in a very simple example. </span><span class="koboSpan" id="kobo.5.2">We can use Visual Studio 2017 as well, for example creating a new website (notice that we don't need a project since we don't need any compiled code on the server: it all happens on the client side).</span></p>
<p><span class="koboSpan" id="kobo.6.1">So, I suggest choosing an </span><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">ASP.NET Empty Website</span></span><span class="koboSpan" id="kobo.8.1"> for this initial demo. </span><span class="koboSpan" id="kobo.8.2">That will create a folder to hold the solution and will include a </span><kbd><span class="koboSpan" id="kobo.9.1">Web.config</span></kbd><span class="koboSpan" id="kobo.10.1"> file just in case you want to instruct the server about some behavior or require some compiled code as well.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Next, we add an HTML page and save the solution to be able to use the </span><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">Manage NuGet packages</span></span><span class="koboSpan" id="kobo.13.1"> option and search for the </span><span class="packt_screen"><span class="koboSpan" id="kobo.14.1">AngularJS.Core</span></span><span class="koboSpan" id="kobo.15.1"> library. </span><span class="koboSpan" id="kobo.15.2">Make sure you're selecting </span><span class="packt_screen"><span class="koboSpan" id="kobo.16.1">AngularJS.Core</span></span><span class="koboSpan" id="kobo.17.1"> and not just </span><span class="packt_screen"><span class="koboSpan" id="kobo.18.1">angularjs</span></span><span class="koboSpan" id="kobo.19.1"> if you don't want to be overloaded with all available libraries for this framework (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img height="364" width="685" class=" image-border" src="assets/b2496a17-6026-47f4-9948-4c2e58998b24.png"/></span></div>
<p><span class="koboSpan" id="kobo.21.1">Once installed, a new </span><span class="packt_screen"><span class="koboSpan" id="kobo.22.1">Scripts</span></span><span class="koboSpan" id="kobo.23.1"> folder will show up in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.24.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.25.1">, including a few libraries. </span><span class="koboSpan" id="kobo.25.2">You just need to drag and drop the </span><span class="packt_screen"><span class="koboSpan" id="kobo.26.1">angular.js</span></span><span class="koboSpan" id="kobo.27.1"> library inside the </span><kbd><span class="koboSpan" id="kobo.28.1">&lt;head&gt;</span></kbd><span class="koboSpan" id="kobo.29.1"> tag, to let Visual Studio create a </span><kbd><span class="koboSpan" id="kobo.30.1">&lt;script&gt;</span></kbd><span class="koboSpan" id="kobo.31.1"> tag pointing to the library and you're ready to go!</span></p>
<p><span class="koboSpan" id="kobo.32.1">The next step is adding the </span><kbd><span class="koboSpan" id="kobo.33.1">ng-app</span></kbd><span class="koboSpan" id="kobo.34.1"> attribute (for example, to the </span><kbd><span class="koboSpan" id="kobo.35.1">&lt;body&gt;</span></kbd><span class="koboSpan" id="kobo.36.1"> tag) and giving it a valid name, such as </span><kbd><span class="koboSpan" id="kobo.37.1">app</span></kbd><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Currently, we have a page, the angular library loaded, and a scope defined.</span></p>
<p><span class="koboSpan" id="kobo.39.1">How can we see some AngularJS in action with this? </span><span class="koboSpan" id="kobo.39.2">We can create an HTML tag, such as </span><kbd><span class="koboSpan" id="kobo.40.1">&lt;h2&gt;</span></kbd><span class="koboSpan" id="kobo.41.1">, </span><kbd><span class="koboSpan" id="kobo.42.1">&lt;h3&gt;</span></kbd><span class="koboSpan" id="kobo.43.1">, </span><kbd><span class="koboSpan" id="kobo.44.1">&lt;div&gt;</span></kbd><span class="koboSpan" id="kobo.45.1">, </span><kbd><span class="koboSpan" id="kobo.46.1">&lt;article&gt;,</span></kbd><span class="koboSpan" id="kobo.47.1"> and so on, and include a moustache link inside (they're called AngularJS binding expressions) that should be resolved at runtime, for example, a </span><kbd><span class="koboSpan" id="kobo.48.1">&lt;h2&gt;</span></kbd><span class="koboSpan" id="kobo.49.1"> tag that will show the current time. </span><span class="koboSpan" id="kobo.49.2">In all, up to this point, we should have a page like this:</span></p>
<pre><span class="koboSpan" id="kobo.50.1">    &lt;!DOCTYPE html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;AngularJS initial demo&lt;/title&gt; 
      &lt;script src="Scripts/angular.js"&gt;&lt;/script&gt; 
    &lt;/head&gt; 
    &lt;body ng-app="app"&gt; 
      &lt;h2&gt;Current time: {{time}}&lt;/h2&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </span></pre>
<p><span class="koboSpan" id="kobo.51.1">Observe the two identifiers (</span><kbd><span class="koboSpan" id="kobo.52.1">app</span></kbd><span class="koboSpan" id="kobo.53.1"> and </span><kbd><span class="koboSpan" id="kobo.54.1">time</span></kbd><span class="koboSpan" id="kobo.55.1">) that are not defined yet. </span><span class="koboSpan" id="kobo.55.2">That will be our JavaScript section of this page. </span><span class="koboSpan" id="kobo.55.3">So, before the closing </span><kbd><span class="koboSpan" id="kobo.56.1">&lt;/body&gt;</span></kbd><span class="koboSpan" id="kobo.57.1"> tag, we will include an </span><kbd><span class="koboSpan" id="kobo.58.1">&lt;script&gt;</span></kbd><span class="koboSpan" id="kobo.59.1"> tag with the following code:</span></p>
<pre><span class="koboSpan" id="kobo.60.1">    &lt;script&gt; 
      var app = angular.module("app", []); 
      app.controller("TimeController", function ($scope) { 
         $scope.time = new Date().toLocaleTimeString(); 
      }); 
   &lt;/script&gt; </span></pre>
<p><span class="koboSpan" id="kobo.61.1">This needs some explanation: first, we create a </span><kbd><span class="koboSpan" id="kobo.62.1">module</span></kbd><span class="koboSpan" id="kobo.63.1"> named </span><kbd><span class="koboSpan" id="kobo.64.1">app</span></kbd><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">That is an object managed by AngularJS to establish the DOM area of interest, and it is created by calling the </span><kbd><span class="koboSpan" id="kobo.66.1">method</span></kbd><span class="koboSpan" id="kobo.67.1"> module on the </span><kbd><span class="koboSpan" id="kobo.68.1">angular</span></kbd><span class="koboSpan" id="kobo.69.1"> object that the library created at loading time. </span><span class="koboSpan" id="kobo.69.2">We cache the return value in a variable of the same name just to make the following code a bit clearer.</span></p>
<p><span class="koboSpan" id="kobo.70.1">The next step is crucial. </span><span class="koboSpan" id="kobo.70.2">Here we create a controller called </span><kbd><span class="koboSpan" id="kobo.71.1">TimeController</span></kbd><span class="koboSpan" id="kobo.72.1"> and assign a callback function to it. </span><span class="koboSpan" id="kobo.72.2">Well, that function is using Dependency Injection by default! </span><span class="koboSpan" id="kobo.72.3">If you notice the function's definition, there's a </span><kbd><span class="koboSpan" id="kobo.73.1">$scope</span></kbd><span class="koboSpan" id="kobo.74.1"> variable defined. </span><span class="koboSpan" id="kobo.74.2">Where does it come from?</span></p>
<p><span class="koboSpan" id="kobo.75.1">The explanation is that, in several angular's constructions, when you define a callback function and declare a recognizable service as a parameter (such as </span><kbd><span class="koboSpan" id="kobo.76.1">$scope</span></kbd><span class="koboSpan" id="kobo.77.1">), a singleton instance of that service is provided by the </span><kbd><span class="koboSpan" id="kobo.78.1">$injector</span></kbd><span class="koboSpan" id="kobo.79.1"> object to you with no intervention on our own.</span></p>
<p><span class="koboSpan" id="kobo.80.1">And it is precisely that </span><kbd><span class="koboSpan" id="kobo.81.1">$injector</span></kbd><span class="koboSpan" id="kobo.82.1"> object that provides DI container services in AngularJS. </span><span class="koboSpan" id="kobo.82.2">Every object managed by a module has its own instance of that service and takes care of resolving all dependencies.</span></p>
<p><span class="koboSpan" id="kobo.83.1">The official AngularJS documentation defines its implementation in this way:</span></p>
<p class="packt_quote"><span class="koboSpan" id="kobo.84.1">The AngularJS injector subsystem is in charge of creating components, resolving their dependencies, and providing them to other components as requested.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Understanding the structure of AngularJS bootstrap</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following diagram shows the structure of the bootstrap process that takes place when loading an Angular app:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="312" width="381" src="assets/fbb8428a-d617-418a-b24f-52f42df59c2f.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">The detailed explanation is this: HTML elements marked with attributes starting with </span><kbd><span class="koboSpan" id="kobo.5.1">ng-</span></kbd><span class="koboSpan" id="kobo.6.1"> denote a part of the DOM called Dynamic DOM (where no </span><kbd><span class="koboSpan" id="kobo.7.1">ng-</span></kbd><span class="koboSpan" id="kobo.8.1"> attributes are present, considered to be static DOM).</span></p>
<p><span class="koboSpan" id="kobo.9.1">Let's briefly reproduce the steps used:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">When the DOM is loaded, AngularJS searches for a </span><kbd><span class="koboSpan" id="kobo.11.1">ng-app</span></kbd><span class="koboSpan" id="kobo.12.1">-marked element and defines a </span><kbd><span class="koboSpan" id="kobo.13.1">$injector</span></kbd><span class="koboSpan" id="kobo.14.1"> linked to it.</span></li>
<li><span class="koboSpan" id="kobo.15.1">In turn, that injector defines a </span><kbd><span class="koboSpan" id="kobo.16.1">$compile</span></kbd><span class="koboSpan" id="kobo.17.1"> service that teaches the HTML interpreter some new syntax. </span><span class="koboSpan" id="kobo.17.2">To be precise, the documentation explains this point by stating that:</span></li>
</ul>
<p style="padding-left: 90px"><em><span class="koboSpan" id="kobo.18.1">The compiler allows you to attach behavior to any HTML element or attribute and even create new HTML elements or attributes with custom behavior. </span><span class="koboSpan" id="kobo.18.2">AngularJS calls these behavior extensions directives.</span></em></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">With all that in memory, AngularJS also creates a special service called </span><kbd><span class="koboSpan" id="kobo.20.1">$rootScope</span></kbd><span class="koboSpan" id="kobo.21.1">, which serves as the root model for the module. </span><span class="koboSpan" id="kobo.21.2">Of course, you can use it as well in your own code.</span></li>
<li><span class="koboSpan" id="kobo.22.1">Now, every controller that you create has a child of that </span><kbd><span class="koboSpan" id="kobo.23.1">$rootScope</span></kbd><span class="koboSpan" id="kobo.24.1">, called simply </span><kbd><span class="koboSpan" id="kobo.25.1">$scope</span></kbd><span class="koboSpan" id="kobo.26.1">: that's the section of the model that such a controller manages.</span></li>
<li><span class="koboSpan" id="kobo.27.1">As the last step, the </span><kbd><span class="koboSpan" id="kobo.28.1">$compile</span></kbd><span class="koboSpan" id="kobo.29.1"> object traverses the module, searching for elements that have </span><kbd><span class="koboSpan" id="kobo.30.1">ng-*</span></kbd><span class="koboSpan" id="kobo.31.1"> attributes, here called directives, or AngularJS expressions (</span><kbd><span class="koboSpan" id="kobo.32.1">{{moustache}}</span></kbd><span class="koboSpan" id="kobo.33.1"> annotations), and substitutes those elements with the required data or code.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">Consequently, the final aspect of our HTML code will be (I'm including only the contents of the </span><kbd><span class="koboSpan" id="kobo.35.1">&lt;body&gt;</span></kbd><span class="koboSpan" id="kobo.36.1"> element):</span></p>
<pre><span class="koboSpan" id="kobo.37.1">     &lt;body ng-app="app"&gt; 
      &lt;h2 ng-controller="TimeController"&gt;Current time: {{time}}&lt;/h2&gt; 
    &lt;script&gt; 
       var app = angular.module("app", []); 
       app.controller("TimeController", function ($scope) { 
          $scope.time = new Date().toLocaleTimeString(); 
       }); 
      &lt;/script&gt; 
    &lt;/body&gt; </span></pre>
<p><span class="koboSpan" id="kobo.38.1">So, what I'm doing here is creating a model's variable (</span><kbd><span class="koboSpan" id="kobo.39.1">time</span></kbd><span class="koboSpan" id="kobo.40.1">) assigned to the controller named </span><kbd><span class="koboSpan" id="kobo.41.1">TimeController</span></kbd><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">Its value is equal to a string representing the current's system time.</span></p>
<p><span class="koboSpan" id="kobo.43.1">Finally, we need to indicate which AngularJS element is managed by which controller: in this case, it is the </span><kbd><span class="koboSpan" id="kobo.44.1">&lt;h2&gt;</span></kbd><span class="koboSpan" id="kobo.45.1"> element containing the </span><kbd><span class="koboSpan" id="kobo.46.1">time</span></kbd><span class="koboSpan" id="kobo.47.1"> variable defined in the model. </span><span class="koboSpan" id="kobo.47.2">At runtime, AngularJS substitutes the variable's value for the </span><kbd><span class="koboSpan" id="kobo.48.1">{{time}}</span></kbd><span class="koboSpan" id="kobo.49.1"> expression.</span></p>
<p><span class="koboSpan" id="kobo.50.1">The output in the browser changes every time you refresh the page (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.51.1"><img height="97" width="327" class=" image-border" src="assets/85b8713d-4c16-4128-9c84-59c529808163.png"/></span></div>
<p><span class="koboSpan" id="kobo.52.1">This is a very simple demo, but it illustrates the basics of AngularJS and how DI is pervasive throughout the framework since you'll find it all over.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Data access and Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Actually, we can see a better implementation of a controller and how to use the </span><kbd><span class="koboSpan" id="kobo.3.1">$injector</span></kbd><span class="koboSpan" id="kobo.4.1"> object if we access some real data using another AngularJS service, called </span><kbd><span class="koboSpan" id="kobo.5.1">$http</span></kbd><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The following code reads all data from the </span><kbd><span class="koboSpan" id="kobo.8.1">BookStore2.json</span></kbd><span class="koboSpan" id="kobo.9.1"> file that we used in </span><a href="58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml" target="_blank"><span class="koboSpan" id="kobo.10.1">Chapter 9</span></a><span class="koboSpan" id="kobo.11.1">, </span><em><span class="koboSpan" id="kobo.12.1">Anti-Patterns and Misconceptions on Dependency Injection</span></em><span class="koboSpan" id="kobo.13.1">, demos and creates a list of its elements. </span><span class="koboSpan" id="kobo.13.2">I'll show you the code first, and then we'll move to the explanation:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    &lt;!DOCTYPE html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
      &lt;meta charset="utf-8" /&gt; 
      &lt;title&gt;AngularJS Data Access Demo&lt;/title&gt; 
      &lt;link rel="icon" href="data:;base64,iVBORw0KGgo="&gt; 
      &lt;link href="Content/bootstrap.css" rel="stylesheet" /&gt; 
      &lt;script src="Scripts/angular.js"&gt;&lt;/script&gt; 
    &lt;/head&gt; 
    &lt;body ng-app="app" class="container"&gt; 
      &lt;h2&gt;A list of ASP.NET Core Books (by PACKT)&lt;/h2&gt; 
      &lt;ul ng-controller="ListController"&gt; 
        &lt;li ng-repeat="book in Books"&gt; 
            {{book.Title}}, &lt;strong&gt;&lt;em&gt;{{book.Author}}&lt;/em&gt;&lt;/strong&gt; 
        &lt;/li&gt; 
      &lt;/ul&gt; 
      &lt;script&gt; 
        angular.module("app", []); 
        var ListController = function ($scope, $http) { 
               $http.get("BookStore.json"). 
               </span><span class="koboSpan" id="kobo.14.2">then(function (response) { 
                     $scope.Books = response.data; 
               }). 
               </span><span class="koboSpan" id="kobo.14.3">catch(function (error) { 
                     alert(error.statusText); 
               }); 
        };         
        ListController.$inject = ["$scope", "$http"]; 
        angular.module("app").controller("ListController", </span><br/><span class="koboSpan" id="kobo.15.1">           ListController); 
      &lt;/script&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </span></pre>
<p><span class="koboSpan" id="kobo.16.1">Before commenting this out, let us note that I'm also using the </span><span class="packt_screen"><span class="koboSpan" id="kobo.17.1">BootStrap</span></span><span class="koboSpan" id="kobo.18.1"> library, but that's only for presentation purposes; it has nothing to do with DI.</span></p>
<p><span class="koboSpan" id="kobo.19.1">If you look at the previous code in any browser, it will present an output very similar to the one that's shown in the following screenshot:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img height="210" width="510" class=" image-border" src="assets/8780a472-7196-42ea-973a-e4bcdc67b170.png"/></span></div>
<p><span class="koboSpan" id="kobo.21.1">Let's review the most important changes in this code. </span><span class="koboSpan" id="kobo.21.2">On the JavaScript side:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Module creation is not cached into a variable (this avoids unnecessary variables in the global space).</span></li>
<li><span class="koboSpan" id="kobo.23.1">The controller is created using a function expression assigned to a variable of the same name. </span><span class="koboSpan" id="kobo.23.2">It declares two variables to be injected later on:
</span><ul>
<li><kbd><span class="koboSpan" id="kobo.24.1">$scope</span></kbd><span class="koboSpan" id="kobo.25.1">: The reference to the model linked to the controller</span></li>
<li><kbd><span class="koboSpan" id="kobo.26.1">$http</span></kbd><span class="koboSpan" id="kobo.27.1">: A service that facilitates request/response actions with HTTP servers, either using the </span><kbd><span class="koboSpan" id="kobo.28.1">XmlHttpRequest</span></kbd><span class="koboSpan" id="kobo.29.1"> object (AJAX) or JSONP inside AngularJS</span></li>
</ul>
</li>
<li><span class="koboSpan" id="kobo.30.1">Inside the function, </span><kbd><span class="koboSpan" id="kobo.31.1">$http</span></kbd><span class="koboSpan" id="kobo.32.1"> is used to get data by calling its </span><kbd><span class="koboSpan" id="kobo.33.1">get</span></kbd><span class="koboSpan" id="kobo.34.1"> method and passing it the URL of the resource to recover. </span><span class="koboSpan" id="kobo.34.2">That call returns a promise, which is resolved asynchronously:
</span><ul>
<li><span class="koboSpan" id="kobo.35.1">When the promise is resolved, it returns the expected information, and the callback functions linked to it will receive an object with the following properties, according to the official site's documentation:
</span><ul>
<li><kbd><span class="koboSpan" id="kobo.36.1">data{string|Object}</span></kbd><span class="koboSpan" id="kobo.37.1">: The response body transformed with the transform functions</span></li>
<li><kbd><span class="koboSpan" id="kobo.38.1">status{number}</span></kbd><span class="koboSpan" id="kobo.39.1">: HTTP status code of the response</span></li>
<li><kbd><span class="koboSpan" id="kobo.40.1">headers{function([headerName])}</span></kbd><span class="koboSpan" id="kobo.41.1">: Header getter function</span></li>
<li><kbd><span class="koboSpan" id="kobo.42.1">config{Object)</span></kbd><span class="koboSpan" id="kobo.43.1">: The configuration object that was used to generate the request</span></li>
<li><kbd><span class="koboSpan" id="kobo.44.1">statusText{string}</span></kbd><span class="koboSpan" id="kobo.45.1">: HTTP status text of the response</span></li>
</ul>
</li>
<li><span class="koboSpan" id="kobo.46.1">If the status code is a number between 200 and 299, the process is successful, and a subsequent call to </span><kbd><span class="koboSpan" id="kobo.47.1">.then()</span></kbd><span class="koboSpan" id="kobo.48.1"> receives the information inside its </span><kbd><span class="koboSpan" id="kobo.49.1">[parameter].data</span></kbd><span class="koboSpan" id="kobo.50.1"> property</span></li>
<li><span class="koboSpan" id="kobo.51.1">Otherwise (if you get a different status code) there's an error and you should catch it with an extra call to </span><kbd><span class="koboSpan" id="kobo.52.1">.catch(),</span></kbd><span class="koboSpan" id="kobo.53.1"> just as we do in the preceding code</span></li>
</ul>
</li>
<li><span class="koboSpan" id="kobo.54.1">The </span><kbd><span class="koboSpan" id="kobo.55.1">$injector</span></kbd><span class="koboSpan" id="kobo.56.1"> object is able to resolve the names of the variables as singleton instances of the services they represent, but what happens when you package your application and the </span><em><span class="koboSpan" id="kobo.57.1">minifiers</span></em><span class="koboSpan" id="kobo.58.1"> change the name of those variables? </span><span class="koboSpan" id="kobo.58.2">This is where the </span><kbd><span class="koboSpan" id="kobo.59.1">$inject</span></kbd><span class="koboSpan" id="kobo.60.1"> array comes in:
</span><ul>
<li><span class="koboSpan" id="kobo.61.1">It allows the </span><em><span class="koboSpan" id="kobo.62.1">minifiers</span></em><span class="koboSpan" id="kobo.63.1"> to rename the function's parameters and still be able to inject the referred services. </span><span class="koboSpan" id="kobo.63.2">Notice that it is an array linked to the controller, and it can grow or shrink at will.</span></li>
</ul>
</li>
<li><span class="koboSpan" id="kobo.64.1">The final step is to define the controller itself inside the module. </span><span class="koboSpan" id="kobo.64.2">That's why we use the </span><kbd><span class="koboSpan" id="kobo.65.1">angular.module("app")</span></kbd><span class="koboSpan" id="kobo.66.1"> syntax, which accesses the module and invokes the required methods inside (notice this time we don't pass the second argument: that means to access, not creation).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">Of course, there is much more to AngularJS using DI and the framework itself, but I hope now have some idea of how Dependency Injection is implemented here. </span><span class="koboSpan" id="kobo.67.2">Let's summarize and complete the most important points about this pattern inside AngularJS.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summing up Dependency Injection features inside AngularJS</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Dependency creation in AngularJS is the responsibility of the </span><kbd><span class="koboSpan" id="kobo.3.1">injector</span></kbd><span class="koboSpan" id="kobo.4.1"> object. </span><span class="koboSpan" id="kobo.4.2">This object, by the way, uses the constructor injection paradigm. </span><span class="koboSpan" id="kobo.4.3">Actually, the injector behaves as a service locator that takes care of construction and look up for dependencies.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This is achieved using the declarative notation in HTML templates. </span><span class="koboSpan" id="kobo.5.2">When the HTML is processed (parsed), it passes the responsibility for component creation to the injector, thus avoiding the need to pass the injector throughout the application. </span><span class="koboSpan" id="kobo.5.3">All that work is done "behind the scenes".</span></p>
<p><span class="koboSpan" id="kobo.6.1">As the documentation states, working in this manner </span><em><span class="koboSpan" id="kobo.7.1">t</span></em><em><span class="koboSpan" id="kobo.8.1">he application code simply declares the dependencies it needs, without having to deal with the injector. </span><span class="koboSpan" id="kobo.8.2">This setup does not break the Law of Demeter</span></em><span class="koboSpan" id="kobo.9.1">.</span></p>
<p><span class="koboSpan" id="kobo.10.1">Let's now focus on the latest versions of Angular (versions 2.0+), that are, in several ways, based on many of these principles but change its implementation quite a bit since they embrace ES6 and related technologies.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Angular 2+</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Since the release of AngularJS (version 1.x) in 2009, the web has changed immensely. </span><span class="koboSpan" id="kobo.2.2">We now have a multitude of build systems, modular loading capabilities, and Web components available to use. </span><span class="koboSpan" id="kobo.2.3">JavaScript development has also come on in leaps and bounds.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Those changes were not reflected in AngularJS, so it was not as performant as the team wanted, mainly due to the digest cycles (related to the DOM parsing that we mentioned previously), and directly related to change detection.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Change detection in Angular can be imagined as a tree working in one direction from the root to its leaves so that it's both faster and more predictable.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.5.1">The name of any version higher than 1.x is just Angular, without the </span><kbd><span class="koboSpan" id="kobo.6.1">JS</span></kbd><span class="koboSpan" id="kobo.7.1"> suffix</span></div>
<p><span class="koboSpan" id="kobo.8.1">Angular has observable and immutable objects that greatly speed up how many properties are checked.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Besides, observable objects are triggered only if an input that they rely on emits an event. </span><span class="koboSpan" id="kobo.9.2">Immutable objects are only checked if one of their input properties has changed. </span><span class="koboSpan" id="kobo.9.3">In most cases though, these two types of object don't have to be checked, meaning that your whole application will be speeded up.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Microsoft's TypeScript is the preferred language in Angular 2+ </span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another big change is the use of TypeScript as the preferred language (the Angular team also uses TypeScript language services and Visual Studio Code, to detect failures and inconsistencies in code, as Brad Green declared recently).</span></p>
<p><span class="koboSpan" id="kobo.3.1">TypeScript has great support in editors such as Visual Studio Code and WebStorm and it behaves as a permanent assistant when you are importing modules and autocompleting intelligent suggestions.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Moreover, since it is a typed language, hints provided are far more in-depth than JavaScript's Intellisense. </span><span class="koboSpan" id="kobo.4.2">Additionally, any JavaScript is valid TypeScript, so you can use as much or as little of it as you're comfortable with. </span><span class="koboSpan" id="kobo.4.3">Many areas help Angular, such as interfaces, constructors, public variables, classes, typed arguments, and so on.</span></p>
<p><span class="koboSpan" id="kobo.5.1">But perhaps the biggest change in Angular is that its architecture is based on the concept of the component. </span><span class="koboSpan" id="kobo.5.2">And those components are defined using class annotations or decorators, a feature that allows adding metadata to a class.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Before delving into it, let's first remind ourselves of the required tooling to work with Angular.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Angular tools</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To work with the latest versions of Angular you can certainly choose from a variety of tools, but I'm going to use those that the official site recommends, plus those you need as a requirement.</span></p>
<p><span class="koboSpan" id="kobo.3.1">First, you need a recent version of Node.js installed. </span><span class="koboSpan" id="kobo.3.2">At the time of writing, two versions are available on its website (</span><a href="https://nodejs.org/es/"><span class="URLPACKT"><span class="koboSpan" id="kobo.4.1">https://nodejs.org/es</span></span><span class="koboSpan" id="kobo.5.1">/</span></a><span class="koboSpan" id="kobo.6.1">): 6.10.3 and 7.10.0. </span><span class="koboSpan" id="kobo.6.2">Either one will be fine, although I have installed 7.10.0. </span><span class="koboSpan" id="kobo.6.3">This installation provides two basic tools to work with Angular: Node and </span><strong><span class="koboSpan" id="kobo.7.1">NPM</span></strong><span class="koboSpan" id="kobo.8.1"> (</span><strong><span class="koboSpan" id="kobo.9.1">Node Package Manager</span></strong><span class="koboSpan" id="kobo.10.1">).</span></p>
<p><span class="koboSpan" id="kobo.11.1">Once you have completed the installation, make sure the versions are correct by typing the following </span><span><span class="koboSpan" id="kobo.12.1">in a console window</span></span><span class="koboSpan" id="kobo.13.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.14.1">      node-v</span></strong></pre>
<p><span class="koboSpan" id="kobo.15.1">And by typing the following too:</span></p>
<pre><strong><span class="koboSpan" id="kobo.16.1">     npm -v </span></strong></pre>
<p><span class="koboSpan" id="kobo.17.1">With that in place, there are a number of editors suitable for Angular, but you could try the free cross-platform Visual Studio Code, which has debugging capabilities and works fine in Windows, Linux, and OSX.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Working with Angular</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's install Angular CLI, a command line interface to work with Angular, which helps a lot in the initial steps with this framework. </span><span class="koboSpan" id="kobo.2.2">We will be able to create the early application very easily and understand how the architecture changes.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Angular CLI has a dedicated website (</span><a href="https://cli.angular.io/"><span class="URLPACKT"><span class="koboSpan" id="kobo.4.1">https://cli.angular.io/</span></span></a><span class="koboSpan" id="kobo.5.1">), where you'll find the installation process, downloads, and the related documentation. </span><span class="koboSpan" id="kobo.5.2">However, the easiest way to install it is via NPM. </span><span class="koboSpan" id="kobo.5.3">You just have to type the following in a Command Prompt:</span></p>
<pre>    <strong><span class="koboSpan" id="kobo.6.1">npm install -g @angular/cli</span></strong>  </pre>
<p><span class="koboSpan" id="kobo.7.1">This installs the Angular-CLI tools globally, so it is available all over the filesystem.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Once again, it's a good practice to check the final state of the installation, which you can do by typing the following:</span></p>
<pre>    <strong><span class="koboSpan" id="kobo.9.1">ng --version</span></strong></pre>
<p><span class="koboSpan" id="kobo.10.1">The output should show the following information:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="295" width="658" class=" image-border" src="assets/1b2a8589-50ea-4255-ad24-903883c1ac12.png"/></span></div>
<p><span class="koboSpan" id="kobo.12.1">And we're all set! </span><span class="koboSpan" id="kobo.12.2">If you want to take a look at the list of commands that Angular CLI holds, just type </span><kbd><span class="koboSpan" id="kobo.13.1">ng --help</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">A long list will show up, so you can have an idea of how powerful this tool is in current versions.</span></p>
<p><span class="koboSpan" id="kobo.15.1">To create the first application, open a Command Prompt (you can use the Developer Command Prompt link that Visual Studio installs), go to the directory where you want your demos to be located, create a new directory, and type the following:</span></p>
<pre><strong><span class="koboSpan" id="kobo.16.1">     ng new [your-app-name]</span></strong></pre>
<p><span class="koboSpan" id="kobo.17.1">In my case, I typed </span><kbd><span class="koboSpan" id="kobo.18.1">ng new ng4-demo</span></kbd><span class="koboSpan" id="kobo.19.1"> and then you wait until the bunch of libraries from NPM is downloaded and installed in the directory of your choice.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Inside the new directory, you can now see the list of files and directories created by the tool, and ready to launch. </span><span class="koboSpan" id="kobo.20.2">Notice that there are three new directories: </span><kbd><span class="koboSpan" id="kobo.21.1">e2e</span></kbd><span class="koboSpan" id="kobo.22.1">, </span><kbd><span class="koboSpan" id="kobo.23.1">node_modules,</span></kbd><span class="koboSpan" id="kobo.24.1"> and </span><kbd><span class="koboSpan" id="kobo.25.1">src</span></kbd><span class="koboSpan" id="kobo.26.1">.</span></p>
<p><span class="koboSpan" id="kobo.27.1">The first one contains end-to-end tests for the application. </span><span class="koboSpan" id="kobo.27.2">That's done by default and you should modify those definitions further on to suit your needs.</span></p>
<p><span class="koboSpan" id="kobo.28.1">The second and largest one holds the large list of JavaScript libraries required for almost any Angular application. </span><span class="koboSpan" id="kobo.28.2">Don't get scared by its length: they're downloaded and installed locally to provide programmers with the tools they might need, but at deploying time only those required will be included in the bundling and minifying process prior to deployment (it is called </span><strong><span class="koboSpan" id="kobo.29.1">tree-shaking</span></strong><span class="koboSpan" id="kobo.30.1">).</span></p>
<p><span class="koboSpan" id="kobo.31.1">Finally, in the </span><kbd><span class="koboSpan" id="kobo.32.1">src</span></kbd><span class="koboSpan" id="kobo.33.1"> directory, you'll find all the files required for this initial demo. </span><span class="koboSpan" id="kobo.33.2">The rest are files used by Angular CLI and other tools (such as the editors) to manage the project (especially, </span><kbd><span class="koboSpan" id="kobo.34.1">package.json</span></kbd><span class="koboSpan" id="kobo.35.1">, </span><kbd><span class="koboSpan" id="kobo.36.1">tsconfig.json</span></kbd><span class="koboSpan" id="kobo.37.1">, and </span><kbd><span class="koboSpan" id="kobo.38.1">angular-cli.json</span></kbd><span class="koboSpan" id="kobo.39.1">).</span></p>
<p><span class="koboSpan" id="kobo.40.1">You should end up with a list like the following:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.41.1"><img height="236" width="437" class=" image-border" src="assets/ef11a241-5f06-4ac6-8ae3-1f6dee9c8b01.png"/></span></div>
<p><span class="koboSpan" id="kobo.42.1">To see it in action, just type </span><kbd><span class="koboSpan" id="kobo.43.1">ng serve</span></kbd><span class="koboSpan" id="kobo.44.1">. </span><span class="koboSpan" id="kobo.44.2">That will run the Webpack tool to get everything ready and launch a server on port 4200 (by default).</span></p>
<p><span class="koboSpan" id="kobo.45.1">The final step will be to open any browser with the URL </span><kbd><span class="URLPACKT"><span class="koboSpan" id="kobo.46.1">http://localhost:4200</span></span></kbd><span class="koboSpan" id="kobo.47.1"> and see the very simple page saying </span><kbd><span class="koboSpan" id="kobo.48.1">app works</span></kbd><span class="koboSpan" id="kobo.49.1"> (I omit the output; it is pretty obvious).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Editing the initial project</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now that we know everything works, let's view the project inside Visual Studio Code (or the editor of your choice), and try to understand the architecture behind this.</span></p>
<p><span class="koboSpan" id="kobo.3.1">So, I'll open the editor from the Command Prompt, just by typing </span><kbd><span class="koboSpan" id="kobo.4.1">code .</span></kbd><span class="koboSpan" id="kobo.5.1"> on the main project's directory.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.6.1">For more information about the VSCode, visit </span><span class="URLPACKT"><a href="https://code.visualstudio.com/"><span class="koboSpan" id="kobo.7.1">https://code.visualstudio.com/</span></a><span class="koboSpan" id="kobo.8.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.9.1">Perhaps, the most amazing thing about this initial demo (especially if you compare it to our previous demos in Angular 1.6) is the lack of references and directives inside the main HTML page of this app:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    &lt;!doctype html&gt; 
    &lt;html&gt; 
    &lt;head&gt; 
     &lt;meta charset="utf-8"&gt; 
     &lt;title&gt;Ng4demo&lt;/title&gt; 
     &lt;base href="/"&gt; 
     &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 
     &lt;link rel="icon" type="image/x-icon" href="favicon.ico"&gt; 
    &lt;/head&gt; 
    &lt;body&gt; 
     &lt;app-root&gt;Loading...&lt;/app-root&gt; 
    &lt;/body&gt; 
    &lt;/html&gt; </span></pre>
<p><span class="koboSpan" id="kobo.11.1">The only non-static HTML is marked in bold: </span><kbd><span class="koboSpan" id="kobo.12.1">&lt;app-root&gt;</span></kbd><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Angular resolves this customized element into the real page you saw in the browser through a complex process of component-related architectures, in which every component defines its behavior, its visual elements (if it has any), and the way it communicates with the rest of the application.</span></p>
<p><span class="koboSpan" id="kobo.14.1">If you look inside the </span><kbd><span class="koboSpan" id="kobo.15.1">src</span></kbd><span class="koboSpan" id="kobo.16.1"> directory, you'll see several TypeScript files. </span><span class="koboSpan" id="kobo.16.2">The module responsible for instructing the browser what to do when </span><kbd><span class="URLPACKT"><span class="koboSpan" id="kobo.17.1">http://localhost:4200</span></span></kbd><span class="koboSpan" id="kobo.18.1"> is invoked appears inside the </span><kbd><span class="koboSpan" id="kobo.19.1">angular-cli.json</span></kbd><span class="koboSpan" id="kobo.20.1"> file. </span><span class="koboSpan" id="kobo.20.2">This file contains a bunch of definitions about editor and server behaviors, and so on.</span></p>
<p><span class="koboSpan" id="kobo.21.1">It holds an app's entry containing that </span><kbd><span class="koboSpan" id="kobo.22.1">main</span></kbd><span class="koboSpan" id="kobo.23.1"> property and also the entry point of the application, which is linked to an </span><kbd><span class="koboSpan" id="kobo.24.1">index</span></kbd><span class="koboSpan" id="kobo.25.1"> field (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="241" width="313" class=" image-border" src="assets/40ec42a2-507e-4a5c-a169-569022036138.png"/></span></div>
<p><span class="koboSpan" id="kobo.27.1">With those definitions, the browser knows which page to launch, and the server which components should be resolved: whatever the </span><kbd><span class="koboSpan" id="kobo.28.1">main</span></kbd><span class="koboSpan" id="kobo.29.1"> module indicates. </span><span class="koboSpan" id="kobo.29.2">And what it shows is a basic environment configuration:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.30.1"><img height="194" width="512" class=" image-border" src="assets/afc0ddac-9403-43ff-b497-80fd1711ff66.png"/></span></div>
<p><span class="koboSpan" id="kobo.31.1">So, this is how Angular manages the initialization of the app. </span><span class="koboSpan" id="kobo.31.2">Whatever is inside </span><kbd><span class="koboSpan" id="kobo.32.1">AppModule</span></kbd><span class="koboSpan" id="kobo.33.1"> will be loaded and resolved.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The structure of the main module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">However, as it turns out that every angular application must consist of at least one module, the </span><kbd><span class="koboSpan" id="kobo.3.1">app.module.ts</span></kbd><span class="koboSpan" id="kobo.4.1"> becomes the one that sets up the application. </span><span class="koboSpan" id="kobo.4.2">It's mandatory to understand how it works:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="284" width="538" class=" image-border" src="assets/4f8c1e04-cc51-44f4-be70-e0b82eed4403.png"/></span></div>
<p><span class="koboSpan" id="kobo.6.1">First, we find </span><kbd><span class="koboSpan" id="kobo.7.1">import</span></kbd><span class="koboSpan" id="kobo.8.1"> statements that load some previously exported components inside the Angular libraries, such as </span><kbd><span class="koboSpan" id="kobo.9.1">platform-browser</span></kbd><span class="koboSpan" id="kobo.10.1">, </span><kbd><span class="koboSpan" id="kobo.11.1">core</span></kbd><span class="koboSpan" id="kobo.12.1">, </span><kbd><span class="koboSpan" id="kobo.13.1">forms</span></kbd><span class="koboSpan" id="kobo.14.1">, and </span><kbd><span class="koboSpan" id="kobo.15.1">http</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">Some of these libraries are not needed in this basic demo, however.</span></p>
<p><span class="koboSpan" id="kobo.17.1">The last </span><kbd><span class="koboSpan" id="kobo.18.1">import</span></kbd><span class="koboSpan" id="kobo.19.1"> statement is the one that links this module with the rest of the functionality, loading </span><kbd><span class="koboSpan" id="kobo.20.1">app.component</span></kbd><span class="koboSpan" id="kobo.21.1">.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The way you define a module is by means of a class (here named </span><kbd><span class="koboSpan" id="kobo.23.1">AppModule</span></kbd><span class="koboSpan" id="kobo.24.1">), marked with a </span><kbd><span class="koboSpan" id="kobo.25.1">@NgModule</span></kbd><span class="koboSpan" id="kobo.26.1"> decorator. </span><span class="koboSpan" id="kobo.26.2">There are no functionalities or definitions inside. </span><span class="koboSpan" id="kobo.26.3">Only the decorator provides the correct link with the rest of the app's elements.</span></p>
<p><span class="koboSpan" id="kobo.27.1">Actually, the </span><kbd><span class="koboSpan" id="kobo.28.1">bootstrap</span></kbd><span class="koboSpan" id="kobo.29.1"> property indicates which component will be in charge of launching the application.</span></p>
<p><span class="koboSpan" id="kobo.30.1">Let's see how that component is made up:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img height="248" width="548" class=" image-border" src="assets/1282f3d2-3cd8-4bc5-be35-6163ed34f975.png"/></span></div>
<p><span class="koboSpan" id="kobo.32.1">Now we have the </span><kbd><span class="koboSpan" id="kobo.33.1">AppComponent</span></kbd><span class="koboSpan" id="kobo.34.1"> class marked with the </span><kbd><span class="koboSpan" id="kobo.35.1">@Component</span></kbd><span class="koboSpan" id="kobo.36.1"> decorator. </span><span class="koboSpan" id="kobo.36.2">Inside, we find the HTML part that we see in the browser. </span><span class="koboSpan" id="kobo.36.3">It's the title field of the class.</span></p>
<p><span class="koboSpan" id="kobo.37.1">But, inside the decorator, we have some clues:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.38.1">selector</span></kbd><span class="koboSpan" id="kobo.39.1">: Indicates the customized piece of dynamic DOM that will be translated into a real fragment of HTML at runtime. </span><span class="koboSpan" id="kobo.39.2">Remember, the only foreign part of HTML inside </span><kbd><span class="koboSpan" id="kobo.40.1">Index.html</span></kbd><span class="koboSpan" id="kobo.41.1"> is that reference to the </span><kbd><span class="koboSpan" id="kobo.42.1">&lt;app-root&gt;</span></kbd><span class="koboSpan" id="kobo.43.1"> element.</span></li>
<li><kbd><span class="koboSpan" id="kobo.44.1">templateUrl</span></kbd><span class="koboSpan" id="kobo.45.1"> (optionally just template, if indicated next): The file containing the HTML fragments that will replace the selector. </span><span class="koboSpan" id="kobo.45.2">They admit </span><kbd><span class="koboSpan" id="kobo.46.1">{{moustache}}</span></kbd><span class="koboSpan" id="kobo.47.1"> syntax, as it happens here.</span></li>
<li><kbd><span class="koboSpan" id="kobo.48.1">styleUrls</span></kbd><span class="koboSpan" id="kobo.49.1">: An array of CSS files that will be loaded at runtime for presentation purposes. </span><span class="koboSpan" id="kobo.49.2">They will only affect the component that defines them, and not the whole page.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.50.1">Finally, the </span><kbd><span class="koboSpan" id="kobo.51.1">app works</span></kbd><span class="koboSpan" id="kobo.52.1"> sentence that we saw in the browser's initial page is just the </span><kbd><span class="koboSpan" id="kobo.53.1">title</span></kbd><span class="koboSpan" id="kobo.54.1"> property of the </span><kbd><span class="koboSpan" id="kobo.55.1">AppComponent</span></kbd><span class="koboSpan" id="kobo.56.1"> class. </span><span class="koboSpan" id="kobo.56.2">And, yes, it is linked via data-binding to the HTML inside the template, which is just a </span><kbd><span class="koboSpan" id="kobo.57.1">&lt;h1&gt;</span></kbd><span class="koboSpan" id="kobo.58.1"> element:</span></p>
<pre><span class="koboSpan" id="kobo.59.1">    &lt;h1&gt; 
     {{title}} 
    &lt;/h1&gt; </span></pre>
<p><span class="koboSpan" id="kobo.60.1">So, let's make a couple of changes, to see how it goes. </span><span class="koboSpan" id="kobo.60.2">Instead of </span><kbd><span class="koboSpan" id="kobo.61.1">app works</span></kbd><span class="koboSpan" id="kobo.62.1">, I'll change the </span><kbd><span class="koboSpan" id="kobo.63.1">title</span></kbd><span class="koboSpan" id="kobo.64.1"> property to </span><kbd><span class="koboSpan" id="kobo.65.1">First demo in Angular 4</span></kbd><span class="koboSpan" id="kobo.66.1">, and the CSS file, which is empty, will also hold some formatting rules:</span></p>
<pre><span class="koboSpan" id="kobo.67.1">    h1 { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      font-size: 2em; 
      border: 3px solid navy; 
    } </span></pre>
<p><span class="koboSpan" id="kobo.68.1">Of course, we can also add any static content to the </span><kbd><strong><span class="koboSpan" id="kobo.69.1">index.html</span></strong></kbd><span class="koboSpan" id="kobo.70.1"> itself (an image, for example, next to the selector):</span></p>
<pre><span class="koboSpan" id="kobo.71.1">    &lt;img src="http://lorempixel.com/320/200/business" alt=""&gt; </span></pre>
<p><span class="koboSpan" id="kobo.72.1">The environment will take care of every change in the application and incrementally recompile those changes.</span></p>
<p><span class="koboSpan" id="kobo.73.1">Notice that, at the end, the text we see is the class' </span><kbd><span class="koboSpan" id="kobo.74.1">title</span></kbd><span class="koboSpan" id="kobo.75.1"> property, which is evaluated and managed by the component architecture of the Angular framework, and it is this component architecture that facilitates the implementation of Dependency Injection.</span></p>
<p><span class="koboSpan" id="kobo.76.1">So, we should see those changes without any more intervention:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.77.1"><img height="295" width="354" class=" image-border" src="assets/d7fd9cc0-f66b-4eaa-aa72-46f81c7eb9fa.png"/></span></div>
<p><span class="koboSpan" id="kobo.78.1">Some of the procedures implied in this model use types of dependencies that are solved at compile time and runtime. </span><span class="koboSpan" id="kobo.78.2">But how can we see the DI in action?</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">DI in Angular 4</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Well, DI in Angular follows the construction injection pattern; thus, since we are dealing with classes (components) here, most of the injection is required in the constructor's parameter definitions.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.3.1">A dedicated page on the official Angular documentation site supplies more information about </span><span><span class="koboSpan" id="kobo.4.1">Dependency Injection</span></span><span class="koboSpan" id="kobo.5.1"> at </span><span class="URLPACKT"><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html"><span class="koboSpan" id="kobo.6.1">https://angular.io/docs/ts/latest/guide/dependency-injection.html</span></a><span class="koboSpan" id="kobo.7.1">.</span></span></div>
<p><span class="koboSpan" id="kobo.8.1">As with AngularJS, Angular creates an injector object in the bootstrap process, so you don't have to do it by yourself (remember, the </span><kbd><span class="koboSpan" id="kobo.9.1">platformBrowserDynamic().bootstrapModule(AppModule)</span></kbd><span class="koboSpan" id="kobo.10.1">sentence inside </span><kbd><span class="koboSpan" id="kobo.11.1">main.ts</span></kbd><span class="koboSpan" id="kobo.12.1">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The concept of a provider</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With that in mind, the programmer's responsibility is to register those classes that will be served via DI later on. </span><span class="koboSpan" id="kobo.2.2">You can do that, either in the </span><kbd><span class="koboSpan" id="kobo.3.1">NgModule</span></kbd><span class="koboSpan" id="kobo.4.1">, or inside any </span><kbd><span class="koboSpan" id="kobo.5.1">Component</span></kbd><span class="koboSpan" id="kobo.6.1">, but, in either case, the way to declare an injectable class is by adding its name to the </span><kbd><span class="koboSpan" id="kobo.7.1">provider's</span></kbd><span class="koboSpan" id="kobo.8.1"> collection of a component or module.</span></p>
<p><span class="koboSpan" id="kobo.9.1">The difference will be that, when declared inside a </span><kbd><span class="koboSpan" id="kobo.10.1">@</span><strong><span class="koboSpan" id="kobo.11.1">NgModule</span></strong></kbd><span class="koboSpan" id="kobo.12.1">, those services will be available alongside the entire application. </span><span class="koboSpan" id="kobo.12.2">In the remaining cases, it will be limited to the component's hierarchy.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Let's modify the previous example, so you can see this technique in action. </span><span class="koboSpan" id="kobo.13.2">Actually, it is quite simple.</span></p>
<p><span class="koboSpan" id="kobo.14.1">The first step is to create a class that provides the injected information required (I'll call it </span><kbd><span class="koboSpan" id="kobo.15.1">DIClass</span></kbd><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">Let's imagine we want an extra text property and a picture. </span><span class="koboSpan" id="kobo.16.3">Since we only need the picture's URL, we'll define two string properties.</span></p>
<p><span class="koboSpan" id="kobo.17.1">But to make the class injectable, we need to mark it as such. </span><span class="koboSpan" id="kobo.17.2">We do that by importing the "</span><kbd><span class="koboSpan" id="kobo.18.1">Injectable</span></kbd><span class="koboSpan" id="kobo.19.1">" definition from </span><kbd><span class="koboSpan" id="kobo.20.1">@angular/core</span></kbd><span class="koboSpan" id="kobo.21.1"> and decorating the class with that annotation. </span><span class="koboSpan" id="kobo.21.2">The final aspect of this class' code will be:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="121" width="502" class=" image-border" src="assets/b4d6086e-6d07-4c26-a03f-42a807a00f45.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">Now, we can get rid of the </span><kbd><span class="koboSpan" id="kobo.24.1">&lt;img&gt;</span></kbd><span class="koboSpan" id="kobo.25.1"> element we inserted in </span><kbd><span class="koboSpan" id="kobo.26.1">index.html</span></kbd><span class="koboSpan" id="kobo.27.1"> and pass the task of inserting the image to the component.</span></p>
<p><span class="koboSpan" id="kobo.28.1">Besides that, and only for presentation purposes, I've modified the </span><kbd><span class="koboSpan" id="kobo.29.1">app.component.css</span></kbd><span class="koboSpan" id="kobo.30.1"> code to mark the injected information inside a border, so those fragments become clearly visible.</span></p>
<p><span class="koboSpan" id="kobo.31.1">With the class ready, we now define the scope of this service. </span><span class="koboSpan" id="kobo.31.2">Since we only need it for our </span><kbd><span class="koboSpan" id="kobo.32.1">AppComponent</span></kbd><span class="koboSpan" id="kobo.33.1">, we'll add a new definition of </span><kbd><span class="koboSpan" id="kobo.34.1">providers</span></kbd><span class="koboSpan" id="kobo.35.1"> in the </span><kbd><span class="koboSpan" id="kobo.36.1">@Component</span></kbd><span class="koboSpan" id="kobo.37.1"> decorator's class; this will make our </span><kbd><span class="koboSpan" id="kobo.38.1">DIClass</span></kbd><span class="koboSpan" id="kobo.39.1"> content available inside the component.</span></p>
<p><span class="koboSpan" id="kobo.40.1">Finally, we can modify our class to hold two extra properties (</span><kbd><span class="koboSpan" id="kobo.41.1">subtitle</span></kbd><span class="koboSpan" id="kobo.42.1"> and </span><kbd><span class="koboSpan" id="kobo.43.1">fotosource</span></kbd><span class="koboSpan" id="kobo.44.1">), whose values are received by injection. </span><span class="koboSpan" id="kobo.44.2">In practice, this injected class will often be data access services or any other type of resource that might be needed in more than one application's component.</span></p>
<p><span class="koboSpan" id="kobo.45.1">Since the way those values are received is by declaring the injected class (or values) in the constructor, the final version will be:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img height="276" width="409" class=" image-border" src="assets/bb1b2adb-1090-4c00-8933-c3ae394459b7.png"/></span></div>
<p><span class="koboSpan" id="kobo.47.1">Now, if you keep the server running and take a look at the new aspect of the page, next to the initial message, we should see those injected elements, formatted according to the CSS rules inside the </span><kbd><strong><span class="koboSpan" id="kobo.48.1">app.component.css</span></strong></kbd><span class="koboSpan" id="kobo.49.1"> file:</span></p>
<p><span class="koboSpan" id="kobo.50.1">And that's it. </span><span class="koboSpan" id="kobo.50.2">We can inject as many items as needed as long as we have previously declared those values with the </span><kbd><strong><span class="koboSpan" id="kobo.51.1">@Injectable</span></strong></kbd><span class="koboSpan" id="kobo.52.1"> decorator; however, if you need more customizable services or data, I recommend reading the documentation's reference I mentioned previously.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Wrapping it up</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">These techniques make your code more maintainable and scalable, and also less dependent on further changes. </span><span class="koboSpan" id="kobo.2.2">Since you only have to reference the required services, a change in the implementation of one doesn't necessarily mean a change in the high-level classes that use those services.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Of course, there is much more in DI in Angular 4 than the basic information included in this chapter. </span><span class="koboSpan" id="kobo.3.2">By now I hope you have a better understanding of how DI is present in these frameworks, and why it is becoming universally popular implementation design pattern.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we have covered DI in other frameworks, with a special focus on Angular in its two current branches.</span></p>
<p><span class="koboSpan" id="kobo.3.1">First, we've seen the very basics of TypeScript on which Angular 2+ is based and how its capabilities for class definitions and module loading allow the construction of JavaScript-based applications with a more object-oriented, modular approach.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Next, we went through the implementation of DI inside AngularJS (the legacy branch of Angular), still in use in more than 70 percent of Angular projects worldwide.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Finally, we explored the basics of Angular 4 (the latest version available at thetime of writing this), and how the aforementioned object orientation and its component architecture (based on annotations) allow the implementation of Dependency Injection in a very easy way.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In </span><a href="a437ff1b-c4af-41ac-b502-8718dc132272.xhtml" target="_blank"><span class="koboSpan" id="kobo.7.1">Chapter 11</span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Best Practices and Other Related Techniques</span></em><span class="koboSpan" id="kobo.10.1">, we'll cover some of the most common best practices in DI and other related techniques.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>