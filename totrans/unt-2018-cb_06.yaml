- en: Shader Graphs and Video Players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing videos by manually adding a VideoPlayer component to a GameObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scripting to control video playback on scene textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using scripting to play a sequence of videos back-to-back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using a simple Shader Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Shader Graph to create a color glow effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toggling a Shader Graph color glow effect through C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two powerful recent additions to Unity have been the Video Player component
    (and API), and the Shader Graph tool. Between them, they offer easier and more
    configurable ways to work with visual content in games. For example, they help
    with the loading and playing of videos on different visible objects, and provide
    a comprehensive way for non-shader programmers to construct sophisticated shader
    transformations using a visual graphing approach.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two core new Unity features discussed in this chapter are **Shader Graphs**
    and the **Video Player**. Each has its own section below.
  prefs: []
  type: TYPE_NORMAL
- en: The new Shader Graph tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2018, Unity published details about the exciting new **Shader Graph** feature.
    **Shader Graph** is a tool that allows **visual** building of shaders, by creating
    and connecting inputs and output of nodes. Currently, it only works with the Lightweight
    Scriptable Render Pipeline, but should eventually work with many pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's **Scriptable Render Pipeline** allow different, and customizable, rending
    pipelines, that can be efficiently targeted for specific projects and hardware
    settings (for example, exploiting GPUs in powerful desktop computers, or reducing
    performance requirements for less powerful mobile devices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some great **Shader Graph** features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An instant, visual preview of each node in the graph, so that you can see how
    different nodes are contributing to the final **Master** output node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties can be publicly exposed in the graph (via the **Blackboard**), so
    that they become customizable values in the **Inspector** for the **Material**
    using the **Shader Graph**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publicly exposed properties can also be accessed and changed via scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of one node can become one of the inputs to another node, so a sophisticated
    shader can be created from many combined, simple component nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/190af154-9f0f-4288-95be-c62117a37765.png)'
  prefs: []
  type: TYPE_IMG
- en: This screenshot illustrates how Shader Graphs are composed of a graph of connected
    nodes, where the output of one node becomes the input to another node. Node input/outputs
    can be numeric values, Textures, noise, Boolean true/false values, Colors etc.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shader Graph** files are created in the Project panel, and can be selected
    as a graph shader in the `Shader` property of a **Material**.'
  prefs: []
  type: TYPE_NORMAL
- en: Several recipes are presented in this chapter to introduce some of the powerful
    **Shader Graph** features and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Playing videos with the new Video Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2017, Unity replaced the old `MovieTexture` with the VideoPlayer component
    (as well as the associated VideoClip asset file type). Playing videos is as simple
    as manually adding a VideoPlayer component in the Inspector to a GameObject at
    design time, and associating a VideoClip asset file from the Project panel, or
    providing the URL of a online resource.
  prefs: []
  type: TYPE_NORMAL
- en: Videos can be played on the camera's far plane (appearing behind the scene content),
    or near plane (appearing in front of content – often with semi-transparency).
    Video content can also be directed to a `RenderTexture` asset, which can then
    (via a Material) be displayed on a 2D or 3D object in the scene. The internal
    texture used by a VideoPlayer can also be mapped to a texture on screen – such
    as UI Raw Image.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting can be used to manage video playback for single and arrays (sequence)
    of video clips. Several recipes are presented in this chapter to introduce these
    different ways to work with the VideoPlayer.
  prefs: []
  type: TYPE_NORMAL
- en: Online references materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are useful sources of information for the topics of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Shader Graph online resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity documentation and third-party articles about the Shader Graphs can be
    found online at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shader Graph blog introduction: [https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/](https://blogs.unity3d.com/2018/02/27/introduction-to-shader-graph-build-your-shaders-with-a-visual-editor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Unity Shader Graph overview: [https://unity3d.com/shader-graph](https://unity3d.com/shader-graph)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Unity GitHub Shader Graph wiki: [https://github.com/Unity-Technologies/ShaderGraph/wiki](https://github.com/Unity-Technologies/ShaderGraph/wiki)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Shader Graph example library on GitHub: [https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary](https://github.com/UnityTechnologies/ShaderGraph_ExampleLibrary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great video tutorial of Shader Graph from Unity Technology''s Andy Tough at
    GDC 2018: [https://www.youtube.com/watch?v=NsWNRLD-FEI](https://www.youtube.com/watch?v=NsWNRLD-FEI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity''s manual page about the Scriptable Render Pipeline: [https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html](https://docs.unity3d.com/Manual/ScriptableRenderPipeline.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video Player online resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity documentation and third-party articles about the Video Player can be
    found online at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Unity Video Player manual page: [https://docs.unity3d.com/Manual/class-VideoPlayer.html](https://docs.unity3d.com/Manual/class-VideoPlayer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Unity Scripting reference for the VideoPlayer class: [https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html](https://docs.unity3d.com/ScriptReference/Video.VideoPlayer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creative Chris'' blog post about the Video Player: [https://creativechris.me/2017/02/07/unitys-new-video-playback-component/](https://creativechris.me/2017/02/07/unitys-new-video-playback-component/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing videos by manually adding a VideoPlayer component to a GameObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TV sets, projectors, monitors.... If you want complex animated materials in
    your level, you can play video files as texture maps. In this recipe, we will
    learn how to add and use VideoPlayer components on the main camera.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need a video file so that you can follow this recipe, please use the
    `videoTexture.mov` file included in the `13_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To place videos manually with a VideoPlayer component, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided `videoTexture.mov` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a 3D Cube to the scene by choosing menu: GameObject | 3D Object | Cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Main Camera GameObject, and in the Inspector, add a Video Player
    component by clicking Add Component, and choosing Video | Video Player. Unity
    will have noticed that we are adding the Video Player component to a camera, and
    so should have set up the default properties correctly for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play On Awake (Checked)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait For First Frame (Checked)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Render Mode: Camera Far Plane'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Camera: Main Camera (Camera)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drag the video clip asset file videoTexture from the Project panel into the
    Video Clip property slot in the Inspector, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94eec315-4dc5-4382-afce-fd3a7e7575e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Test your scene. You should be able to see the movie being played behind the
    scene content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose whether to stretch the video content by changing the Aspect Ratio
    property in the Inspector (for example, you can change it to Stretch in order
    to fill in the complete background of the screen).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We gave the Video Player component a reference to a Video Clip asset file. Since
    we added the Video Player component to a Camera (the Main Camera, in this example),
    it automatically chose the Camera Far Play Render Mode linked to the Main Camera.
  prefs: []
  type: TYPE_NORMAL
- en: The default setting is Play On Awake, so as soon as the first frame has loaded
    (since Wait For First Frame is also checked by default), the video will start
    playing. The video is displayed behind all main camera content (the far plane).
    Because of this, we see our 3D Cube in the scene, with the video playing in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some additional ways to work with the Video Player component.
  prefs: []
  type: TYPE_NORMAL
- en: Semi-transparent video and Camera Near Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we may want to play a video so that it's the user's main focus, but
    allow them to see scene objects in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this with the Video Player component, we just need to make two changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the Render Mode to Near Camera Plane (so that the video content is played
    in front of the scene content).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To allow the user to partially see through the video, we need to make the Video
    Player semi-transparent. Change its Alpha property to 0.5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you run the scene, you'll see the video playing in front of scene
    content, but now you will be able to see the 3D cube in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Audio issues and AudioSource solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing this book, there seem to be issues with the Direct option
    for Audio Output Mode audio playback for some non-Apple systems. One solution
    is to add an AudioSource component to the same GameObject that has the VideoPlayer
    component, and to set the Audio Output Mode to AudioSource.
  prefs: []
  type: TYPE_NORMAL
- en: Using scripting to control video playback on scene textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the last recipe demonstrated how we can plan videos using the Video Player
    component that's set up at design time, much more is possible when controlling
    video playback through scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll using scripting to play/pause the playback of a video
    rendered onto a 3D cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4333282-1119-4ece-94ac-4daf280a1f0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need a video file to follow this recipe, please use the `videoTexture.mov` file
    included in the `13_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use scripting to control video playback, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided `videoTexture.mov` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a 3D cube by choosing menu: Create | 3D | Cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class named `PlayPauseMainTexture`, and attach an instance
    object as a component to your 3D cube GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that your 3D cube is selected in the Project panel. Then, drag the Video
    Clip asset file `videoTexture` from the Project panel into the Video Clip property
    slot of the `PlayPauseMainTexture` component (script) in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run your scene. Pressing the spacebar should play/pause playback of the video
    on the surfaces of the 3D cube. You should also hear the beeping audio for video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We added the instance object of our scripted class to the 3D cube, and dragged
    a reference to a Video Clip asset file to the public slot. In our code, we are
    telling the VideoPlayer component to override the Material of the object it is
    a component of (in this case, the 3D cube) so that the Video Player will render
    (display) onto the main texture of the 3D cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The basics to using scripting and the VideoPlayer is as follows. As well as
    defining and setting up where the Video Player will render, we also need to do
    the following each time:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create or get references to the VideoPlayer and AudioSource components (we
    will automatically have both components for this recipe since we have the `RequireComponent(...)`
    script instructions immediately before our class declaration):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set their Play On Awake to `true`/`false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define where the Video Player will find a reference to the Video Clip to play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the audio settings (so that you can output to the AudioSource component):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some additional ways to work with Video Player scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that a movie's prepared before playing it with the prepareCompleted
    event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, the movie has time to prepare since the game waits
    until we press the jumo/space key. If we are using scripting to set up a Video
    Player for a video clip, we need to do some initial work before the video is ready
    to play. Unity provides the `prepareCompleted` event, which allows us to register
    a method to be invoked once a VideoPlayer is ready to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty GameObject named video-object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class named `PrepareCompleted`, and attach an instance object
    as a component to GameObject''s video-object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that video-object is selected in the Project panel. Now, drag the Raw
    Image from the Hierarchy into the Raw Image slot. Then, drag the Video Clip asset
    file `videoTexture` from the Project panel into the Video Clip property slot of
    the `PrepareCompleted` component (script) in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your scene. You should be able to see the movie being played behind the
    scene content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see that, in the `Start()` method, we first register a method named `PlayVideoWhenPrepared`
    with the `videoPlayer.prepareCompleted` event, before invoking the `Prepare()`
    method of the `videoPlayer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `PlayVideoWhenPrepared(...)` method has to accept a parameter as a reference
    to a VideoPlayer object. We first directly assign the VideoPlayer's texture property
    to the Raw Image's texture. Then, we send the `Play()` message.
  prefs: []
  type: TYPE_NORMAL
- en: Directly working with the VideoPlayer texture works for this example, but usually
    setting up a separate Render Texture is more reliable and flexible - see the following
    subsection for how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: You can track progress of clip preparation and so on through the Log messages
    in the Console panel.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting video playback to a Render Texture asset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A flexible way to work with Video Players is to output their playback to a Render
    Texture asset file. A Material can be created to get input from the Render Texture,
    and GameObjects using that Material will display the video. Also, some GameObjects
    can directly have the Render Texture assigned as their texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Render Texture asset file named `myRenderTexture`
    (menu: Create | Render Texture).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script) texture
    property to the `myRenderTexture` asset file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new Material asset file named `m_video`. For
    this Material, in the Inspector, set its Albedo Texture property to `myRenderTexture`
    (drag it from the Project panel into the Inspector).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new 3D capsule in the scene, and assign it the Material m_video.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the C# script class `PrepareCompleted` by replacing the public `rawImage` variable
    with a public `renderTexture` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the C# script class `PrepareCompleted` by adding the following statements
    at the end of the `SetupVideoAudioPlayers()` method to output video to `RenderTexture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the C# script class PrepareCompleted in the `PlayVideoWhenPrepared()` method.
    Remove the statement that directly assigns the VideoPlayer''s texture property
    to the Raw Image''s Texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the GameObject video-object is selected in the Project panel. Now,
    drag the `myRenderTexture` asset from the Project panel into the Render Texture
    public property of the Prepare Completed (Script) in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the scene. You should now see the video playing both in the UI Raw Image and
    also rendered over the 3D Capsule object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd64a526-f7d8-4f1a-97b7-073c95a49bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensuring that the movie is prepared before playing with coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Unity programmers are very used to working with coroutines, so instead
    of using the `prepareCompleted` event, we can rewrite the preceding script by
    using a coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `PlayVideoWhenPrepared()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new using statement at the top of the script (so that we can refer to IEnumerator
    interface):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the existing `Start()` method with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, our `Start()` method has become a coroutine (returning an IEnumerator),
    which means that it can yield control back to Unity during its execution. In the
    next frame, it will resume execution at that same statement.
  prefs: []
  type: TYPE_NORMAL
- en: There is a while loop that will continue running until the isPrepared property
    is true for VideoPlayer. So, each frame of Unity will return to this while loop,
    and if the VideoPlayer is still not prepared, it enters the loop again and yields
    execution until the next frame. When VideoPlayer isPrepared is finally true, the
    loop condition is false, so the statement after the loop is executed (`videoPLayer.Play()`),
    and the method finally completes its execution.
  prefs: []
  type: TYPE_NORMAL
- en: For a single video, there is little to choose from between the `isPrepared`
    event and the preceding coroutine. However, for a sequence of videos, the use
    of the `isPrepared` and `loopPointReached` events helps us make much simpler logic
    for preparing and then waiting to play the next video in a sequence (see the next
    recipe for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Downloading an online video (rather than a clip)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than dragging an existing Video Clip asset file to specify which video
    to play, the Video Player can also download Video Clips from an online source.
    We need to assign a string URL to the Video Player's URL property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a public array of strings, in which one or more URLs can be defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a new method that returns one URL string, randomly chosen from the
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `SetupVideoAudioPlayers()` method, we need to get the random
    URL string, and assign it to the Video Player''s `url` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using scripting to play a sequence of videos back-to-back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of scripting is that it allows us to easily work with
    multiple items through loops and arrays, and so on. In this recipe, we'll work
    with an array of Video Clip assets and use scripting to play them back-to-back
    (one starts as soon as the previous clip finishes), illustrating the use of the isPrepared
    and loopPointReached events to avoid complicated loops and coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need video files in order to follow this recipe, please use the `videoTexture.mov`
    file included in the `13_01` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** The Standalone Installer website provides a good online source of
    test videos: http://standaloneinstaller.com/blog/big-list-of-sample-videos-for-testers-124.html.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To play a sequence of videos using scripting, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the provided `videoTexture.mov` file, and perhaps a second video clip,
    so that we can have a sequence of two different videos to test (although you can
    run the same one twice if you wish).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Render Texture asset file named myRenderTexture
    (menu: Create | Render Texture).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a UI Raw Image to the scene by choosing menu: Create | UI | Raw Image.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the UI Raw Image in the Hierarchy, and assign its Raw Image (Script)
    Texture property to the myRenderTexture asset file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new Material asset file named m_video. For this
    Material, in the Inspector, set its Albedo Texture property to myRenderTexture
    (drag it from the Project panel into the Inspector).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a 3D cube by choosing menu: Create | 3D | Cube. Assign the m_video Material
    to your 3D cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty GameObject named video-object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# script class named VideoSequenceRenderTexture, and attach an instance
    object as a component to the GameObject''s video-object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that the GameObject video-object is selected in the Project panel. Now,
    drag the myRenderTexture asset from the Project panel into the Render Texture
    public property of the PrepareCompleted (Script) in the Inspector. For the Video
    Clips property, set the size to 2 – you should now see two video clip elements
    (elements 0 and 1). From the Project panel, drag in a video clip to each slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You should now see the first video clip playing both for the
    UI Raw Image and the 3D cube surface. Once the the first video clip has finished
    playing, the second video clip should immediately start playing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can track the progress of clip preparation and so on through the Log messages
    in the Console panel.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script class makes the Video Player objects output their videos to Render
    Texture's asset file, myRenderTexture. This is used by both 3D cube and the UI
    Raw Image for their surface display.
  prefs: []
  type: TYPE_NORMAL
- en: The videoClips variable is a public array of video clip references.
  prefs: []
  type: TYPE_NORMAL
- en: The instance object of the C# script class VideoSequenceRenderTexture was added
    as a component to GameObject's video-object. This script will create child GameObjects
    of GameObject video-object, each containing a VideoPlayer and AudioSource component,
    ready to play each of the video clips assigned in the public array's videoClips
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupObjectArrays()` method initializes videoPlayers to be an array the
    same length as videoClips. It then loops for each item, invoking `SetupVideoAudioPlayers(...)` by
    passing the current integer index.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetupVideoAudioPlayers(...)` method creates a new child GameObject for
    GameObject's video-object, and adds VideoPlayer and AudioSource components to
    that GameObject. It sets the Video Player clip property to the corresponding element
    in the public videoClips array variable. It also adds a reference to the new VideoPlayer
    component to the appropriate location in the videoPlayers array. It then sets
    the Video Player to output audio to the new AudioSource component, and to output
    its video to the renderTexture public variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Start()` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It invokes `SetupObjectArrays()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the currentVideoIndex variable to 0 (for the first item in the arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It registers `PlayNextVideo` method for the prepareCompleted event of the first
    videoPlayers object (currentVideoIndex = 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It invokes the `Prepare()` method for the videoPlayers object (currentVideoIndex
    = 0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it logs a debug message stating that the item is preparing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `PlayNextVideo(...)` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets a reference to the Video Player element of the videoPlayers array that
    corresponds to the currentVideoIndex variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method ignores the reference to the videoPlayer argument it receives –
    this parameter is required in the method declaration since it is the required
    signature to allow this method to register for the prepareCompleted and loopPointReached
    events.
  prefs: []
  type: TYPE_NORMAL
- en: It sends a `Play()` message to the current Video Player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then increments the value of currentVideoIndex, and tests whether there are
    any remaining video clips in the array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are remaining clips, then it gets a reference to the next clip, and
    sends it a `Prepare()` message; also the currently playing Video Player has its
    loopPointReached event registered for the PlayNextVideo method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (If there are no videos left, then a simple debug log message is printed and
    the method ends)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The clever bit is when the currently playing Video Player has its loopPointReached
    event registered for the PlayNextVideo method. The loopPointReached event occurs
    when a video clip has finished playing, and will start to look again (if its loop
    property is true). What we are doing with this script is say that when the current
    Video Player video clip has finished, the `PlayNextVideo(...)` method should be
    invoked again – once again using the value of currentVideoIndex to send a `Play()`
    message to the next Video Player, and then testing for any remaining Video Players,
    and so on until the end of the array has been reached.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good example of conditions (if statements) being used with events,
    rather than coroutine while loops. As long as you're happy with how methods can
    be registered with C# events, then this approach allows our code to be less complex
    by avoiding loops and coroutine yield null statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see how our video-object GameObject, at
    runtime, ends up with videoPlayer_&lt;n&gt; child GameObjects – one for each element
    in the array. This allows one VideoPlayer to be playing while the next is preparing,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a699930-958c-44a4-a501-da55667644ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating and using a simple Shader Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new Shader Graph feature in Unity 2018 is a powerful and exciting feature,
    opening up shader creation and editing to everyone, without any need for complex
    mathematics or coding skills. In this recipe, we''ll create a simple Shader Graph
    to generate a checkerboard pattern, and create a Material that uses that shader,
    and apply it to a 3D cube. The end result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3659fae-9246-4166-b56f-ec293e82a3f3.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create and use a simple Shader Graph, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up the Lightweight Rendering Pipeline. Use the Package
    Manager to import the Lightweight Rendering Pipeline package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Lightweight Pipeline Asset file named myLightweightAsset.
    Choose menu: Create | Rendering | Lightweight Pipeline Asset.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Inspector, display the project''s graphics settings by choosing menu:
    Edit | Project Settings | Graphics. Then, drag myLightweightAsset from the Project
    panel into the Scriptable Render Pipeline Settings property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29679a07-63e1-4157-8965-841f8d891138.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the Package Manager to import the Shader Graph package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Physically-Based Rendering (PBR) Shader
    Graph, named myShaderGraph. Choose menu: Create | Shader | PBR Graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Material named m_cube. Choose menu: Create
    | Material.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the m_cube selected, in the Inspector, set its Shader property to myShaderGraph.
    For the Material''s Shader property, choose menu: graphs | myShaderGraph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/016a978c-ae54-4e8f-ac9b-294a86f8b7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a 3D cube to the scene (menu: GameObject | 3D Object | Cube). Set the Material
    for this 3D Cube to m_Cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, double click myShaderGraph to open the Shader Graph editing
    panel. A new PRB Shader Graph will open with three components: (1) the BlackBoard
    (for publically exposing parameters); (2) the Master PRB node; (3) the output
    previewer node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is easiest, when editing a Shader Graph, to maximize the Shader Graph panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f836663f-0dfa-4550-b7e5-d8e519d5972e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click the output previewer, and select Cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can zoom and rotate the preview mesh. You can also choose a custom mesh
    from within your project, allowing a preview of the Shader Graph on the intended
    destination's 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a07de4f3-176a-4c94-a72a-552cccc7a5e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's flood the shader with a red color. Choose red from the color picker for
    the top property of the PRB Master node Albedo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new graph node by right-clicking the mouse and choosing menu: Create
    Node | Procedural | Checkerboard. You''ll see the checkerboard patter in the preview
    for this node. Set the X property to 2, and the Y property to 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, drag a link from the checkerboard note output Out(3), to the Emission
    (3) input for the PRB Master node. You should now see a red/pink checkerboard
    patter in the PBR Master node preview, and you''ll also see the following output
    applied to the Cube mesh in the output previewer node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a3af4a4-8c12-4c7d-ab3c-0d772d2968dd.png)'
  prefs: []
  type: TYPE_IMG
- en: You must save the changes to your Shader Graph before you can see them applied
    to the scene. Click the Save Asset button on the top-left of the Shader Graph
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your scene. You should see a red/pink checkerboard 3D cube being
    displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You enabled the Lightweight Rending Pipeline by installing the package, creating
    an asset, and choosing that asset for the Project's Scriptable Rending Pipeline
    Graphics property.
  prefs: []
  type: TYPE_NORMAL
- en: You then created a new Shader Graph asset file, and a new Material that uses
    your shader.
  prefs: []
  type: TYPE_NORMAL
- en: Your Shader Graph feeds a procedurally generated checkerboard into the Emission
    property of the PBR Master output node, and also tints the output by choosing
    a red Color value for the Albedo property. You saved the changes to your Shader
    Graph asset so that they will be available when the scene runs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a glow effect with Shader Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, a simple Shader Graph was created by using a Material
    for a primitive 3D Cube mesh. In this recipe, we''ll take things further, creating
    a Shader Graph that applies a parameterized glow effect to a 3D object. The end
    result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c62fbcaf-c6c6-447a-814c-575c4dbab0d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on the previous one, so make a copy of that project and use
    the copy for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a glow effect with a Shader Graph, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Physically-Based Rendering (PBR) Shader
    Graph, named glowShaderGraph. Choose menu: Create | Shader | PBR Graph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, create a new Material named `m_glow`. Choose menu: Create
    | Material.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. With the m_glow selected, in the Inspector, set its Shader property to
    glowShaderGraph. For the Material''s Shader property, choose menu: graphs | glowShaderGraph.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need a 3D mesh object in the scene that uses `m_glow`. While we could
    just use a 3D Cube again, it''s more fun to add a low-polygon textured character
    to the scene. For this recipe, we''ve used the free Unity Asset Store character
    pack Fantasy Mushroom Mon(ster) from AmusedArt. Once the package has been added,
    drag the Mushroom Monster Prefab into the scene from Project panel folder: amusedART
    | Mushroom Monster | Prefab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b9aa2515-d5dc-4aec-8a50-c8df9d2206d8.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Project panel, double click glowShaderGraph to open the Shader Graph
    editing panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the output previewer, select Custom Mesh, and choose MushroomMon
    from the selection dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Texture** exposed property to your **Shader Graph** by creating
    a new property texture in the **Shader Graph** Blackboard. Click the plus + button
    and choose property type Texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Blackboard, change the Default value of the property Texture from None
    to Mushroom Green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use a publically exposed Blackboard property in our **Shader Graph**, we
    need to drag a reference to the property from the Blackboard into the Graph area.
    Drag the Blackboard property Texture into the Graph area. You should see a new
    node with the title Property, and value Texture (T):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac0e71ae-d4d4-4c3a-89e8-73b48b600156.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no **Texture** input to the Master PDB Node, so we need to add a converter
    node that can take (sample) data from a **2D Texture** image, and turn it into
    RBG values that can be sent to the Albedo input of the **PBR Master Node**. Create
    a new Sample Texture 2D node in your **Shader Graph** by right-clicking the mouse, then
    choose menu: Create Node | Input | Texture | Sample Texture 2D.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's send the **Texture** Mushroom Green into the Master PRB Node via
    the Sample Texture 2D converter node. Link the Texture (T) output from the Property
    node to the Texture (T) input of the Sample Texture 2D node. You should now see
    the Mushroom Green Texture image appear in the 2D rectangular preview at the bottom
    of the Sample Texture 2D node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, link the RGBA (4) output of the Sample Texture 2D node to the Albedo
    (3) input of the Master PRB node (Unity will intelligently just ignore the 4th
    Alpha (A) values). You should now see the Mushroom Green Texture image appear
    in the preview at the bottom of the Master PRB node. You should also see the Mushroom
    Green Texture being applied to the 3D Mushroom Monster Mesh in the **Shader Graph**
    output previewer node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/135b7f81-4e15-4b0e-a312-6c7fd035e885.png)'
  prefs: []
  type: TYPE_IMG
- en: One way to create a glow effect is by applying a Fresnel Effect. Create a new
    Fresnel Effect node in our **Shader Graph**. Link the Out (3) output from the Fresnel
    Effect node to the Emission (3) input of the**PRB Master** node. You should now
    see a brighter glow outline effect in the **Shader Graph** output previewer node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Augustin-Jean Fresnel (1788-1827) studied and documented how an object's reflection
    depends on the viewing angle – for example, looking straight down into still water,
    there is little sunlight reflected and we can see into the water clearly. But
    if our eyes are closer to the level of the water (for example, if we are swimming),
    then much more light is reflected by the water. Simulating this effect in a digital
    shader is a way to make the edges of an object lighter, since light is glancing
    off the edges of the object and reflected to our game camera.
  prefs: []
  type: TYPE_NORMAL
- en: Let's tint our Fresnel Effect by combining it with a publicly exposed Color
    property, which can be set by game designers either in the Inspector or through
    C# code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, delete the link from the Out (3) output from the Fresnel Effect node
    to the Emission (3) input of the PBR Master node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Color exposed property to your **Shader Graph** by creating a new
    property Color in the **Shader Graph** Blackboard. Click the plus + button and
    choose the Color property type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Blackboard, set the Default value of the Color property to red (using
    the Color picker).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Blackboard's Color property into the Graph area. You should see a new
    node with the title Property and a value of  **Color(4)**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new **Multiply** node in your **Shader Graph** by right-clicking the
    mouse and then choosing menu: Create Node | Math | Basic | Multiply.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mathematical Multiply node is an easy way to combine values from two nodes,
    which are then to be passed to a single input of a third node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s combine the Color and Fresnel Effect by making both inputs to the Multiply
    node. Link the Color (4) output from the Property (Color) node to the A (4) input
    of the Multiply node. Next, link the Out (3) output from the Fresnel Effect node
    to the B (4) input of the Multiply node. Finally, link the Out (3) output from
    the Fresnel Effect node to the Emission (3) input of the PRB Master node. You
    should now see a red tinted glow outline effect in the **Shader Graph** output
    previewer node: The overview screenshot below shows these node connections completed
    for our Shader Graph'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aec5981c-5feb-4025-a7a2-c4c7bdabd1c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your updated **Shader Graph** by clicking the Save Asset button at the
    top-right of the **Shader Graph** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your Scene. You should see a red glow around the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Project panel, locate the **Material** that your 3D GameObject uses
    (for the Green Mushroom Monster, it is folder: Project | amusedART | Mushroom_Monster
    | Materials | MusroomMonGreen). The publicly exposed properties of the **Shader
    Graph** Blackboard should appear in the **Inspector** as customizable properties.
    Change the Color property to blue. Run the scene again. The glow effect around
    the 3D GameObject should now be blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a7a69b0-5269-4459-becb-ca27edd6f3a2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a new **Shader Graph**, which has several connected nodes. The output(s)
    of one node become the input(s) of another node.
  prefs: []
  type: TYPE_NORMAL
- en: You created publicly exposed properties for Color and Texture using the **Shader
    Graph** Blackboard, and introduced those properties as inputs in your Graph.
  prefs: []
  type: TYPE_NORMAL
- en: You used a Sample Texture 2D node to convert the **2D Texture** image into RBG
    values suitable for the **Albedo** input for the **PBR Master** node.
  prefs: []
  type: TYPE_NORMAL
- en: You created a Fresnel Effect node, and combined this, via a Multiply node, with
    the publicly exposed Color property, sending the output into the Emission input
    of the PRB Master node.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to change the publicly exposed property for Color in the
    Inspector via the Material's properties.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling a Shader Graph color glow effect through C# code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Effects such as the glow effect from the previous recipe are often features
    we wish to toggle on and off under different circumstances. The effect could be
    turned on or off during a game to visually communicate the status of a GameObject—for
    example, an *angry* character might glow red, while a *happy* monster might glow
    green, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We'll add to the previous recipe to create a new publicly exposed **Shader Graph**
    Blackboard property named Power, and write code that can be used to set this value
    to zero or five in order to turn the glow effect on and off. We'll also access
    the Color property so that we're able to set what color the glow effect displays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds on the previous one, so make a copy of that project and use
    the copy for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To toggle the glow effect from the Shader Graph, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, delete the link from the Out (3) output from the Multiply node to the
    Emission (3) input of the PBR Master node. We are doing this because the output
    of this Multiply node will become an input for a second Multiple node that we
    are about to create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Multiply node in your **Shader Graph** by right-clicking the mouse
    and then choosing menu: Create Node | Math | Basic | Multiply.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the Out (4) output from the original Multiply node to the A (4) input of
    your new Multiply node. Also, link the Out (3) output from the new Multiply node
    to the Emission (3) input of the PBR Master node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new `float` (decimal number), exposed to the Power property, to your **Shader
    Graph** by creating a new property in the **Shader Graph** Blackboard. Click the
    plus + button and choose property type `Vector 1`, and rename this `Power`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Blackboard, set the Default value of the Power property to `5`. Also,
    set the display Mode to Slider with the values of Min 0 and Max 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the Blackboard Power property into the Graph area. You should see a new
    node with the title Property, and a value of Power(1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, link the Power(1) output from Property node (Power) to the B (4) input
    of the new Multiply node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/05d4056a-9c21-44ab-99cb-16c4d235c537.png)'
  prefs: []
  type: TYPE_IMG
- en: Save your updated **Shader Graph** by clicking the Save Asset button at the
    top-right of the **Shader Graph** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script class named `GlowManager` containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Select **Shader Graph** glowShaderGraph in the Project panel, and view its
    properties in the Inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/513e2e16-bfd0-4367-8b45-7d0a1294baa9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Find the internal IDs of the publicly exposed properties Power and Color –
    they will be something like Vector1_AA07C639 and Color_466BE55E. Copy these IDs
    into C# script statements by setting the ID strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing this book, the current version of **Shader Graph** doesn't
    provide a convenient way to access exposed properties using the names chosen in
    the Shader Graph Blackboard, hence the need to look up the internal ID needed
    for the `material.SetFloat(powerId, power)` statement when changing the value.
    It is likely that Unity will soon update the **Shader Graph** scripting API to
    make this action more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy, locate the component of your 3D GameObject that contains the
    Mesh Renderer component (for our Mushroom Monster example, this is the Mushroom
    Mon child of the Mushroom Monster GameObject). Add an instance object of the `GlowManager` script
    class as a component to this **GameObject**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and run your Scene. Pressing the *1* key should turn on the red glow effect,
    pressing the *2* key should turn on the blue glow effect, and pressing the *0*
    key should turn off the glow effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a new Power exposed property for your **Shader Graph** that combined
    with the Fresnel color effect so that a value of zero will turn off the effect.
    You looked up the internal IDs of the Power and Color exposed properties, and
    updated the C# script so that it can update these properties.
  prefs: []
  type: TYPE_NORMAL
- en: The scriptclass checks for the 0/1/2 keys, and correspondingly turns the effect
    off/to a red glow/to a blue glow.
  prefs: []
  type: TYPE_NORMAL
- en: By combining publicly exposed properties with code, you are able to change **Shader
    Graph** values at runtime through events detected by code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some ways to take your **Shader Graph** features even further.
  prefs: []
  type: TYPE_NORMAL
- en: Using Sine Time to create a pulsating glow effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could make the glow effect *pulse* by creating a Time node, and linking
    the Sine Time (1) output to the Fresnel Effect input Power (1). As the Sine Time
    value changes between - 1/0/+1, it will influence how strong the Fresnel Effect
    is, changing the brightness of the glow effect.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Compile and Show Code button as another way to find exposed property
    IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are viewing the properties of a **Shader Graph** asset in the **Inspector**,
    you'll see a button entitled Compile and Show Code. If you click this, you'll
    then see a generated ShaderLab code file in your script editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn''t the actual code used by Unity, but it provides a good idea of the
    code that is generated from your **Shader Graph**. The internal IDs for your publicly
    exposed Blackboard properties are listed in the Properties section, which is at
    the beginning of the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
