<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Abstract Factory</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we explored the Factory Method, a direct, straightforward, variation of the Factory pattern. Now, we will implement a more advanced version of the Factory pattern: the well-named Abstract Factory. The primary goal of both forms of the Factory pattern is to encapsulate the creation process of objects. In this chapter, we will focus on isolating the main differences between the Factory Method and Abstract Factory, so that we can better understand in which context we might choose one over the other.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basics of Abstract Factory</li>
<li>Designing an NPC spawner using the Abstract Factory pattern</li>
</ul>
<div class="packt_tip">Explaining the core differences between the Factory Method and Abstract Factory is sometimes used as a trick question in technical interviews. So, having a clear answer to this type of question can impress your interviewers.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter is very hands-on, so you will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following Unity engine and C# language concept(s):</p>
<ul>
<li>Enums</li>
</ul>
<p>If you are unfamiliar with these concept(s), please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2HKybdy">http://bit.ly/2HKybdy</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the Abstract Factory</h1>
                </header>
            
            <article>
                
<p>The Abstract Factory is often explained in overly complicated terms in academic documentation, but if you distill it to its elementary form, its design and intent are quite simple. The main purpose of the Abstract Factory is to organize the manufacturing process of products (objects) into related groups. This approach allows us to manage factories that produce specific families of products (objects). In other words, we are able to add layers of abstraction to the creation process of particular categories of products (objects), and specific individual types.</p>
<p>In the following diagram, we can see the basic structure of the Abstract Factory described visually:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/880e98a3-46b7-4544-a961-ac8bb087e9b7.png"/></p>
<p> </p>
<p>Notice the following members of this pattern:</p>
<ul>
<li><kbd>FactoryProducer</kbd> is responsible for returning individual factories of a specific category (families) of products (Human or Animal)</li>
<li><kbd>HumanFactory</kbd> and <kbd>AnimalFactory</kbd> are responsible for the creation of Human or Animal products</li>
</ul>
<p>The benefit of using Abstract Factory is obvious when you are dealing with the creation of a catalog of products, with each group having its unique manufacturing specifications.</p>
<div class="packt_tip">When describing a Factory pattern, we often use real-world terms such as <em>products</em>, <em>manufacturing</em>, and <em>producer</em>. It's always a wise approach to find correlations between real-life notions and computer science terms, because it helps in identifying and remembering their core purpose.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p>The benefits and drawbacks of the Abstract Factory are very similar to those of the Factory Method, so it doesn't warrant repeating them in this chapter. But there's one significant benefit, which is the core difference between both patterns, that we need to address. While the Factory Method focuses on exposing a method that permits us to request the creation of objects of specific types, the Abstract Factory goes beyond this, by giving us a way to manage the creation of particular groups of objects.<br/>
<br/>
This distinction might not sound important at first, but, if we consider a real-world analogy, such as the process of <span>manufacturing </span>a car, we can see why the Abstract Factory is advantageous. Your typical car is assembled with individually manufactured components, but the process of constructing an engine and tires is entirely different, so you need separate factories to create those crucial pieces of the final product. That's why the Abstract Factory is beneficial in software development, because it offers us a similar approach to structuring and organizing the way we produce a final, complex product, featuring multiple components with different object creation processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p>We are going to extend the use case from the <a href="53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml">Chapter 4</a>, The <em>Factory Method</em>, by adding a new type of spawnable NPC, called Animals. So, in our example, Humans and Animals are considered non-playable characters, but have separate manufacturing processes, so they will need individual factories. This type of requirement is easily implementable with the Abstract Factory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>Our code example is almost the same as the one that we completed in <a href="53f1b25e-e9c8-47b4-aa76-82c71fffdb8c.xhtml">Chapter 4</a>, <em>The Factory Method</em>. But we are going to add more depth to the system by including specific families of NPCs; in our case, Humans and Animals.</p>
<ol>
<li>One key element of the Abstract Factory is that each family of products has an associated factory:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class FactoryProducer : MonoBehaviour<br/>{<br/>    public static AbstractFactory GetFactory(FactoryType factoryType)<br/>    {<br/>        switch (factoryType)<br/>        {<br/>            case FactoryType.Human:<br/>                AbstractFactory humanFactory = new HumanFactory();<br/>                return humanFactory;<br/>            case FactoryType.Animal:<br/>                AbstractFactory animalFactory = new AnimalFactory();<br/>                return animalFactory;<br/>        }<br/>            return null;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Notice that the class is implemented like a Factory Method, because we use a simple <kbd>switch</kbd> case to return the correct <kbd>Factory</kbd> to the client depending on the requested type.</p>
<ol start="2">
<li>Now, we need an <kbd>abstract</kbd> class to maintain consistency in the implementation of each product-specific <kbd>Factory</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public abstract class AbstractFactory<br/>{<br/>    public abstract IHuman GetHuman(HumanType humanType);<br/>    public abstract IAnimal GetAnimal(AnimalType animalType);<br/>}</pre>
<ol start="3">
<li>Next up is our first concrete product factory, <kbd>HumanFactory</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public class HumanFactory : AbstractFactory<br/>{<br/>    public override IHuman GetHuman(HumanType humanType)<br/>    {<br/>        switch (humanType)<br/>        {<br/>            case HumanType.Beggar:<br/>                IHuman beggar = new Beggar();<br/>                return beggar;<br/>            case HumanType.Farmer:<br/>                IHuman farmer = new Farmer();<br/>                return farmer;<br/>            case HumanType.Shopowner:<br/>                IHuman shopowner = new Shopowner();<br/>                return shopowner;<br/>        }<br/>        return null;<br/>    }<br/>    <br/>    public override IAnimal GetAnimal(AnimalType animalType)<br/>    {<br/>        return null;<br/>    }<br/>}</pre>
<ol start="4">
<li class="mce-root">And now, <kbd>AnimalFactory</kbd>, which will produce cats and dogs:</li>
</ol>
<pre style="padding-left: 60px">public class AnimalFactory : AbstractFactory<br/>{<br/>    public override IAnimal GetAnimal(AnimalType animalType)<br/>    {<br/>        switch (animalType)<br/>        {<br/>            case AnimalType.Cat:<br/>                IAnimal cat = new Cat();<br/>                return cat;<br/>            case AnimalType.Dog:<br/>                IAnimal dog = new Dog();<br/>                return dog;<br/>        }<br/>        return null;<br/>    }<br/><br/>    public override IHuman GetHuman(HumanType humanType)<br/>    {<br/>        return null;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Notice that both classes implement each other's <kbd>GetAnimal()</kbd> or <kbd>GetHuman()</kbd> function, but return a <kbd>null</kbd>, depending on the context. This approach is in case a client refers to the wrong factory when requesting a specific type of NPC; instead of throwing an exception, it will receive a null.</p>
<ol start="5">
<li>Instead of using strings in our <kbd>switch</kbd>-type condition block, we are going to implement enums for each type of product we support, including the associated factories, as follows. This approach will avoid errors and maintain consistency:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>FactoryType</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public enum FactoryType<br/>{<br/>    Human,<br/>    Animal<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>HumanType</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public enum HumanType<br/>{<br/>    Farmer,<br/>    Beggar,<br/>    Shopowner<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>AnimalType</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public enum AnimalType<br/>{<br/>    Dog,<br/>    Cat<br/>}</pre>
<p class="mce-root"/>
<ol start="6">
<li>Our Animals don't speak, but our Humans do, so they can't share a standard interface. In that case, we are going to implement one for each type, as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>IHuman</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public interface IHuman<br/>{<br/>    void Speak();<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>IAnimal</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public interface IAnimal<br/>{<br/>    void Voice();<br/>}</pre>
<ol start="7">
<li>Now, we need to write each concrete class for all our human and animal NPCs, as follows:</li>
</ol>
<ul>
<li style="padding-left: 30px"><kbd>Beggar</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Beggar : IHuman<br/>{<br/>    public void Speak()<br/>    {<br/>        Debug.Log("Beggar: Do you have some change to spare?");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Farmer</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Farmer : IHuman<br/>{<br/>    public void Speak()<br/>    {<br/>            Debug.Log("Farmer: You reap what you sow!");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Shopowner</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Shopowner : IHuman<br/>{<br/>    public void Speak()<br/>    {<br/>        Debug.Log("Shopowner: Do you wish to purchase something?");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Dog</kbd>:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Dog : IAnimal<br/>{<br/>    public void Voice()<br/>    {<br/>        Debug.Log("Dog: Woof!");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px"><kbd>Cat</kbd>:</li>
</ul>
<pre style="padding-left: 60px">public class Cat : IAnimal<br/>{<br/>    public void Voice()<br/>    {<br/>        Debug.Log("Cat: Meow!");<br/>    }<br/>}</pre>
<ol start="8">
<li>Finally, we can extend our <kbd>NPCSpawner</kbd> class to support the spawning of Animal and Human NPCs:</li>
</ol>
<pre style="padding-left: 60px">public class NPCSpawner : MonoBehaviour<br/>{<br/>    private IAnimal m_Cat;<br/>    private IAnimal m_Dog;<br/><br/>    private IHuman m_Farmer;<br/>    private IHuman m_Beggar;<br/>    private IHuman m_Shopowner;<br/>    <br/>    private AbstractFactory factory;<br/><br/>    public void SpawnAnimals()<br/>    {<br/>        factory = FactoryProducer.GetFactory(FactoryType.Animal);<br/>        <br/>        m_Cat = factory.GetAnimal(AnimalType.Cat);<br/>        m_Dog = factory.GetAnimal(AnimalType.Dog);<br/><br/>        m_Cat.Voice();<br/>        m_Dog.Voice();<br/>    }<br/>    <br/>    public void SpawnHumans()<br/>    {<br/>        factory = FactoryProducer.GetFactory(FactoryType.Human);<br/><br/>        m_Beggar = factory.GetHuman(HumanType.Beggar);<br/>        m_Farmer = factory.GetHuman(HumanType.Farmer);<br/>        m_Shopowner = factory.GetHuman(HumanType.Shopowner);<br/><br/>        m_Beggar.Speak();<br/>        m_Farmer.Speak();<br/>        m_Shopowner.Speak();<br/>    }<br/>}</pre>
<ol start="9">
<li>As proof of our concept, our <kbd>Client</kbd> class can request <kbd>Animal</kbd> and <kbd>Human</kbd> NPCs from our <kbd>Spawner</kbd> without having to know the process behind the creation of the final product:</li>
</ol>
<pre style="padding-left: 60px">public class Client : MonoBehaviour<br/>{<br/>    public NPCSpawner m_SpawnerNPC;<br/> <br/>    public void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.U))<br/>        {<br/>            m_SpawnerNPC.SpawnHumans();<br/>        }<br/> <br/>        if (Input.GetKeyDown(KeyCode.A))<br/>        {<br/>            m_SpawnerNPC.SpawnAnimals();<br/>        }<br/>    }<br/>}</pre>
<p>As you can see, the Abstract Factory gives us a lot more flexibility than its cousin, the Factory Method. We can now manage families of products, and add more layers of abstraction to manufacturing processes.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the Abstract Factory, a close cousin of the Factory Method. As its name implies, Abstract Factory permits us to add layers of abstraction to the manufacturing process of specific types of product (objects). This pattern is very beneficial when dealing with multiple families of products. The main drawback of Abstract Factory, compared to the Factory Method, is that it's more wordy and involved.</p>
<p>In the next chapter, we are going to explore what is arguably the most famous design pattern of them all: the Singleton.</p>
<div class="packt_infobox">While learning about Factory patterns, you might notice that we are using several terms related to traditional manufacturing processes. The manufacturing and software industries are quite related. Best practices associated with managing factories inspired several core ideas behind DevOps and Kanban, which are now cornerstones of robust software development processes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practice exercise</h1>
                </header>
            
            <article>
                
<p class="mce-root">At this point in the book, we have reviewed the two most popular forms of the Factory pattern: the Abstract Factory and the Factory Method. However, as an exercise, I would recommend expanding your knowledge of factories by implementing a third form, for example, the static Factory Method.</p>
<p>You can learn about the static Factory Method pattern in Joshua Bloch's classic book, <em>Effective Java</em>. More information can be found in the <em>Further reading</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>The Phoenix Project</em> by <span class="a-size-large a-text-bold">Kevin Behr, George Spafford,</span> <span class="a-size-large a-text-bold">and</span> <span class="a-size-large a-text-bold">Gene Kim</span><strong><span class="a-size-large a-text-bold"><br/></span></strong> <a href="https://itrevolution.com/book/the-phoenix-project/">https://itrevolution.com/book/the-phoenix-project</a></span></li>
<li><span><em>Effective Java</em> by Joshua Bloch</span><span><strong><span class="a-size-large a-text-bold"><br/></span></strong> <a href="https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html">https://www.pearson.com/us/higher-education/program/Bloch-Effective-Java-3rd-Edition/PGM1763855.html</a></span></li>
</ul>


            </article>

            
        </section>
    </body></html>