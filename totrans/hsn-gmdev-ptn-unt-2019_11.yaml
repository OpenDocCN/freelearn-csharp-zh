- en: Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strategy is one of those patterns whose name doesn''t indicate its intent explicitly.
    This uncertainty can make it hard to grasp and remember its purpose. But the Strategy
    pattern is quite simple: it offers a way to dynamically select algorithms and
    assign them to an object at runtime. We could imagine the Strategy pattern acting
    as a master chess player, analyzing the chessboard and choosing what strategy
    is best depending on the context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of the Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a series of target-seeking behaviors for missiles using the Strategy
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a hands-on chapter, so you will need to have a basic understanding
    of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following specific Unity engine and C# language concept:'
  prefs: []
  type: TYPE_NORMAL
- en: Composition over inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If unfamiliar with this concept, please review them before starting this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2UlVjVG](http://bit.ly/2UlVjVG)'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary goal of the Strategy pattern is to defer the decision of which algorithm
    to use until runtime. This approach allows more flexibility and reusability of
    segments of code that implement logic and behaviors. This idea may sound very
    complicated, but it's a simple mechanism that's possible because of the object-oriented
    programming concept of *composition*. So, instead of sharing reusable algorithms
    by implementing them in a parent class that can be inherited by other classes,
    we instead wrap each algorithm into self-contained individual *components* that
    we attach to objects at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds familiar and resembles a lot how Unity's component system works,
    it's because the engine has what we call in object-oriented programming a *composition
    over inheritance* approach. So, this makes the Strategy pattern harmonious with
    Unity's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following simple diagram of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53644f50-1166-4f66-95a1-c4603bca9f51.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, this example of the Strategy pattern implements an interface
    that permits us to assign various seeking behaviors to any objects of the **Missile**
    type. But like most patterns, it can be tough to follow it's design just by looking
    at a UML diagram. Therefore, we can only truly understand the mechanism behind
    this pattern by implementing it in code, which we will see in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will often use the terms algorithms, logic, and behaviors
    as synonyms because, in the context of the Strategy pattern, they are manageable
    as individual components.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Strategy pattern has a good reputation, but like most sophisticated patterns,
    its complexity can cause some drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An alternative to subclassing**: Because it focuses on composition over inheritance,
    the Strategy offers a way to avoid hardwiring behaviors in each subclass of a
    parent type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fewer condition statements to manage**: By implementing each behavior into
    individual components that can be managed by the Strategy pattern, the need for
    long conditional statements when dealing with complex contextual behavior selection is
    eliminated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client must be aware of the various strategies**: The Strategy pattern doesn''t
    abstract itself from the client, so it must be aware of the different strategies
    and how to call them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased code complexity**: A common drawback of this type of sophisticated
    pattern is that it does increase the number of classes and objects to manage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the main reasons that a lot of programmers hesitate to use sophisticated
    patterns is because they are afraid that junior members of the team might get
    lost in the complexity that it adds to a code base. So, it's important to diagram
    and document complex parts of your code and also list the patterns you are using
    to implement a system.
  prefs: []
  type: TYPE_NORMAL
- en: Use case example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this use case, let''s imagine we are working on a military simulation game
    and we are assigned to implement the following behaviors for the missile homing
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Heat**: The missile seeks a target by its heat signature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sonar**: The missile uses sound propagation to find a target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPS**: The missile uses GPS coordinates to home onto the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The design document also emphasizes that there will be three types of missiles
    using a homing system. But at the moment, it''s not decided which missile will
    be using which homing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tomahawk**: Usually launched from a carrier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SideWinder**: They are intended for jet fighters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Torpado**: They are designed to destroy underwater targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, now we have technical choices to make:'
  prefs: []
  type: TYPE_NORMAL
- en: Do we hard code each seeking behavior in the class of each type of missile?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we write a single homing system class that will contain all the missile-seeking
    behaviors?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we instead write each missile-seeking behavior as a separate component that
    we can attach dynamically to any missile?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third option is the best one because it removes any duplicate code and offers
    flexibility in the form of composition. In the next section, we will implement
    this use case, and we will see how the Strategy pattern provides us a lot of extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: Good code is flexible and never rigid. Rigidity might seem more stable, but
    it makes changes difficult and expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to keep this example very simple, so we can focus on understanding
    the Strategy pattern and not get lost in wordiness. Let''s follow a step-by-step
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by implementing the following critical element that makes this
    pattern work, which is the interface that will be used to access the seeking behaviors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a standard interface for all our seeking behaviors, let's implements
    them in individual concrete classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first one is our `SeekWithGPS` behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have our `SeekWithHeat` behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have our `SeekWithSonar` behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have encapsulated each seeking behavior into individual classes,
    the next step is to find a way to assign them dynamically to missiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write an abstract class that will group each type of missile with a
    common parent and permit us to give them a shared interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two key things to notice: the `ApplySeek()` and `SetSeekBehaviour()`
    functions will apply a specified behavior to any missile type that derives from
    the `Missile` class. We have given ourselves a single point of access to all our
    missile types and a way to apply a seek behavior dynamically. Let''s see how this
    looks in our concrete missile classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are starting with our `Torpedo`. By default, let''s give it the `SeekWithSonar`
    behavior, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up is our `SideWinder`. We should give it the `SeekWithHeat` behavior,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final missile type is going to be `Tomahawk`. Let''s give it the `SeekWithGPS`
    behavior because it''s a long-distance missile, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can notice that each concrete missile class assigns an instance of the seeking
    behavior to `this.seekBehaviour` at `Awake()`, and this is because we want to
    make sure each missile type has a default seeking behavior associated with it
    at initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see in our `Client` class example that we can reassign a new behavior
    to a missile at any time we want, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we are now able to attach dynamically a seek behavior to any
    missile. This mechanism is beneficial because it means we could launch a missile
    and switch its seeking behavior mid-flight; a very cool feature to have in a game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned how to implement the Strategy pattern by building a series
    of targeting seeking behaviors that can be attached to any missile at runtime.
    An important takeaway from this pattern is the importance of isolating behaviors
    into separate classes that can be assigned dynamically to objects. This approach
    has become a pillar of good architecture and very popular among game programmers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the command pattern, a behavioral pattern
    that is often used to manage the triggering of events.
  prefs: []
  type: TYPE_NORMAL
- en: Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding code example, we only implemented a simple prototype of missile
    targeting seeking behaviors to keep the chapter within a reasonable length and
    focus on learning the core concepts behind the Strategy pattern. However, it would
    be a great exercise to complete the implementation of those targeting behaviors
    and build a demo of a launching system that can dynamically switch a missile's
    homing system from a heat, sonar, or GPS seeking behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composition over inheritance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Composition_over_inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
