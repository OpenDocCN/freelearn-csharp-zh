- en: Using WPF Standard Controls
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `TextBlock` control to add plain text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Label` to add other controls in text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a user option to input text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding images in your application UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ready-to-use 2D shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tooltips to show additional information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a standard menu to the WPF application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing extra functionalities using the context menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding user options with radio buttons and checkboxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the progress bar control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Slider` control to pick a numeric value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the calendar control in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing items in a `ListBox` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing options to select from a ComboBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a status bar to your window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a toolbar panel to perform quick tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every UI Framework must provide the standard controls to design the application
    UI and **Windows Presentation Foundation** (**WPF**) is one of them. WPF provides
    a set of standard controls and UI elements such as `TextBlock`, `TextBox`, `Button`,
    `Image`, various shapes, `ProgressBar`, `Slider`, various menus, `Toolbar`, `ListBox`,
    `ComboBox`, `DataGrid`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following diagram, UI controls can be of two types—**ItemsControl**
    and **ContentControl**, which inherit from `Control` class. All the panels available
    in WPF share the same base class `Panel`. The `Control` and `Panel` class have
    the base **FrameworkElement**, which again inherits from the **UIElement**. It
    has the base class as the **DependencyObject** and the superbase as the **Object**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e83d2e8a-1116-4709-be6b-2f19213d7589.png)'
  prefs: []
  type: TYPE_IMG
- en: Every control has some common set of properties exposed. This includes `FontFamily`,
    `FontSize`, `FontStyle`, `Foreground`, `Background`, `BorderBrush`, `BorderThickness`,
    and more. Every framework element exposes additional properties such as `Width`,
    `MaxWidth`, `MinWidth`, `ToolTip`, `Height`, `Name`, `Language`, `Margin`, and
    more. When using any element in the UI, you will use these common properties to
    set the UIElement's style and other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Using the TextBlock control to add plain text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TextBlock` control in WPF is a lightweight UI element, which is used to
    display text content to the screen. Almost everywhere, you will use this element
    in your application UI to display plain text in a single line or a multiline format.
    To add simple plain text, you can either write `<TextBlock Text="Text message"
    />` or `<TextBlock>Text message</TextBlock>` in your XAML page.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore more about this UI element.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open your Visual Studio IDE, and create a new WPF project called
    `CH02.TextBlockDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now open the `MainWindow.xaml`, and follow these steps to add `TextBlock` control
    with various formatting options:'
  prefs: []
  type: TYPE_NORMAL
- en: First, change the pre-existing `Grid` panel to a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add the following two `TextBlock` controls to it, which will have plain
    text in them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following XAML to have a few more `TextBlock` controls, with some basic
    text formatting applied to them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's build the project and run it. You will see the following UI on the screen:![](img/b3cc071e-0e83-4da9-a642-65145fa8a9ec.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the first two `TextBlock` controls, the UI will have a plain text on it.
    The third `TextBlock` control will have **Bold**, **Italic**, and **Underline**
    applied to it, by specifying the `FontWeight`, `FontStyle`, and `TextDecoration`
    properties of the control. Also, the foreground color of it has been set to *red*,
    by specifying the `Foreground` property.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a different font to your `TextBlock` control. Use the `FontFamily`
    property to set it. As you can see, the fourth `TextBlock` control has a **Lucida
    Handwriting** font applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a long text, which is not viewable in a single line, you can either
    wrap it to multiline or trim it, based on the available space. `TextWrapping="Wrap"`,
    in the fifth `TextBlock` spans it to multiline. Try making the window bigger or
    smaller, and you will see that the `TextBlock` automatically adjusts itself to
    match the available space, whereas, the text of the sixth `TextBlock` control
    trims with the `TextTrimming` property set to character ellipsis (three dots at
    the end). This says that more text is available but it has been `cropped.`
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to `CharacterEllipsis`, you may use `WordEllipsis`, which
    will trim the text at the end of the last possible word, instead of the last possible
    character.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TextBlock` control also supports inline formatting. Just like HTML tags,
    you can surround a text content with `Bold`, `Italic`, and `Underline` tags to
    format it, as shown in the following XAML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add a line break to a text content, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following XAML code demonstrates how to add a hyperlink element to a `TextBlock`
    control that matches the style of your Windows theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `NavigateUri` property is used to define the URL that you wish to navigate
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `Span` element to set the style of individual text content
    that includes font style, size, foreground color, and so on. It also allows you
    to specify other inline elements inside it. The `Run` element allows you to style
    a text content using all the available properties of the `Span` element. The following
    example demonstrates how easy it is to use the `Span` and `Run` elements inside
    a `TextBlock` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Span` element may contain other inline elements, but a `Run` element can
    contain only plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding example will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac786411-589f-4d00-a3dd-aeb3f4f9b488.png)'
  prefs: []
  type: TYPE_IMG
- en: Using Label to add other controls in text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Label` control is another way of representing text in WPF application.
    It looks like what `TextBlock` control offers, but instead of having only text
    support, it can also host any kind of other controls. It exposes the `Content`
    property to host text and other controls.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore how to use the `Label` control in a WPF.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this control, open Visual Studio to create an application
    based on the WPF project template and call it `CH02.LabelDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project gets created, follow these simple steps to add text in your
    application UI, using the `Label` control:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file to change the application UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the existing `Grid` panel with the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now build and run the application. You will see the following output on the
    screen:![](img/c1e62b20-d3d3-47ca-8ed6-12bd94fed2ce.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first control added in the `StackPanel` is a very basic label, which has
    plain text as its `Content` property. The second `Label` control also contains
    plain text, but has various formatting (such as, `FontWeight`, `Foreground`, and
    `FontStyle`) applied to it to give it a bold, italic, and red color look to its
    style.
  prefs: []
  type: TYPE_NORMAL
- en: As the `Label` control derives from `System.Windows.Controls.ContentControl`,
    it also supports adding other controls to its content. The third label added to
    the UI is a little different than the previous two examples. It not only contains
    text, but also other controls, such as `StackPanel`, `TextBlock`, and a `Rectangle`,
    owing to its `Content` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, for the third label, the `TextBlock` control is used
    to hold the actual text content, and `StackPanel` is used as a panel control to
    hold both the `TextBlock` and the `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: A point to remember is that `Label` is heavier than a `TextBlock`. So, when
    you need to render a plain text on the UI, prefer `TextBlock` only.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows and other operating systems, it's a widespread practice to access
    the controls in a window by holding the *Alt* key and then pressing a character
    defined as its access key. For example, to open the File menu of any Windows application,
    we use *Alt* + *F*. Here, the character *F* is the access key, which gets invoked
    when we press *Alt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to add an access key to labels in the WPF application, using
    the `Label` control. Create a new project called `CH02.LabelAccessKeyDemo`, open
    the `MainWindow.xaml` page, and replace the default `Grid` by a `StackPanel`.
    Now add two labels and two textboxes inside the `StackPanel`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application. Press *Alt* + *U* to activate the access key for the
    first label, and place the focus on the `txbUsername` field. Press *Alt* + *P*
    to automatically focus on the `txbPassword` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e48a981-b8a1-4b6d-b84a-5c9a13596a5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Windows Form application uses "`&`" as its access key specifier, but in
    the WPF application it's a little different, as it uses XML notation to create
    the UI. So, in the WPF application, if you want to add an access key specifier
    to labels, you need to specify `_` (underscore) before the character which you
    want to highlight.
  prefs: []
  type: TYPE_NORMAL
- en: For example, adding `_` before the `U` in Username, activates the said label
    when *Alt* + *U* is pressed. It's a similar case for the Password field, in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: The frequently used practice is to use the first character that's not already
    used as an access key of another control. But, on a need basis, you can specify
    any character part of the label content.
  prefs: []
  type: TYPE_NORMAL
- en: The `Target` property of the `Label` control passes the instruction to the designated
    control to activate automatically when the access key gets triggered by the user.
    The `ElementName` property, which is present in the binding (`Target="{Binding
    ElementName=txbPassword}"`), tells the name of the control where you want to send
    the activation instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a user option to input text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TextBox` control in WPF is used to allow the user to input plain text in
    a single line or multiline format. A single-line textbox is the commonly used
    control for form inputs; whereas the multiline textbox is used like an editor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE, and create a new project named `CH02.TextBoxDemo`,
    based on the WPF application template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project gets created, follow the mentioned steps to play with some
    of the `TextBox` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `StackPanel`
    so that we can add the controls in a stacked fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add five `TextBox` controls inside the `StackPanel`, and set various properties,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the application so that it has the following UI on the screen:![](img/693d146f-aec0-4187-bd03-d11145e6e1ad.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first `TextBox` control, which we added to the `StackPanel`, is the simplest
    one, and when it is rendered in the UI, it contains empty text. The user can enter
    any plain text here. You can also specify text from code, by using the `Text`
    property, as shown in the second control.
  prefs: []
  type: TYPE_NORMAL
- en: You can also define a range of styles for the text of the `TextBox` control.
    As shown in the second control, we specified `FontSize`, `Foreground`, `FontWeight`.
    You can specify other properties too, as part of any control.
  prefs: []
  type: TYPE_NORMAL
- en: The third one is a `ReadOnly` textbox, which you can define by setting the `IsReadOnly`
    property value to `True`. When you want to disable a `TextBox`, set its `IsEnabled`
    property to `False`, as shown in the fourth example.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth example demonstrates how easy it is to define a multiline textbox.
    Just set its `AcceptsReturn` property to `True` and `TextWrapping` to `Wrap`.
    The control will behave like a multiline text editor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using `TextBox` as a multiline text-input control, don't forget
    to set its `VerticalScrollBarVisibility`. This will allow your user to scroll
    the text content. As shown in the last example, set it to `Auto` to make it enabled
    on demand, based on its content.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Clipboard support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TextBox` control automatically supports the **Windows Clipboard**. Right-click
    on it to see the context menu pop up in the screen with common clipboard functions,
    such as Select all, Cut, Copy, and Paste. Along with these functions, it also
    supports the common keyboard shortcuts for clipboard operations, undo/redo, by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Adding spellcheck support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The attached `SpellCheck.IsEnabled` property allows you to add spellcheck support
    to the `TextBox` control. Set it to `True` to enable it. Let''s add a multiline
    textbox in the UI with this feature enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application to have a window with a multiline text-input field in
    the UI. Enter some text with some spelling mistakes. You will see that the wrongly
    spelled words get highlighted with red underline. Right-click on it to see a context
    menu, which suggests words from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, select the one that is best suited in
    this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19d967d7-39fe-4348-8165-c31aa4f066fd.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding images to your application UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are used to create a UI that looks good, with a background, icons, and
    thumbnails, and they convey more information to the user. In WPF, the `Image`
    element is used to display images. Let's take a look at this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with images in WPF, launch your Visual Studio IDE and create
    a WPF project called `CH02.ImageDemo`, and add an image called `demoImage.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to add images in the `MainWindow.xaml` page:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page, and replace the existing `Grid` with a `StackPanel`.
    Set its `Orientation` property to `Horizontal` so that the items added to this
    panel stack themselves horizontally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add four images to the `StackPanel`, and set their `Source` property to `demoImage.jpg`,
    which is available within the project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the width and the height of each image to `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first image, set its `Stretch` property to `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second image, set its `Stretch` property to `Fill`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the third and fourth images, set their `Stretch` property to `Uniform` and
    `UniformToFill`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the complete XAML code, to which you can refer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's build and run the application. You will see the following output in the
    application UI:![](img/3f2a1bb2-785d-412a-98fd-61b871504c94.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In XAML, the `Source` property of the `Image` control is the path of the image
    file that you want to display. When you access the same from code, it's a `BitmapImage`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Stretch` property of an image describes how it should be stretched to fill
    the destination. For the first image, that we set as `Stretch= "None"`, it preserves
    the original size of the image. When you set it as `Fill`, for the second image
    in the example, the content is resized to fill the destination dimensions without
    preserving its aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: For the third and fourth image, setting it to `Uniform` and `UniformToFill`,
    respectively, set its content resized to fit in the destination dimensions while
    preserving its native aspect ratio. But for the fourth case, if the aspect ratio
    of the destination image differs from the source, the source content is clipped
    to fit in the destination dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of the image `Stretch` property is `Uniform`. That means,
    when you add an image to the UI, by default, it sets its content resized to fit
    in the destination dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also set an image in XAML by creating a `BitmapImage` instance and
    assigning it to its `Source` property. The `BitmapImage` instance exposes the
    `UriSource` property to set the image path. Here''s an example of how to set the
    image source in XAML, using the `BitmapImage` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also rotate an image by setting the `Rotation` property of `BitmapImage`.
    It contains four values `Rotate0`, `Rotate90`, `Rotate180`, and `Rotate270`. Here''s
    an example to demonstrate how to rotate an image by 180 degrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can also use the `StretchDirection` property of an `Image`
    control. The value indicates how the image is scaled. There are three values `UpOnly`,
    `DownOnly`, and `Both`. The content scales upward, downward, or in both directions,
    based on the size of the image content.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ready-to-use 2D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WPF, a `Shape` is an `UIElement` that enables you to draw a 2D shape in
    your application. There are a couple of ready-to-use shapes already provided by
    WPF, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ellipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polygon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these `UIElements` expose some common properties to draw the shape. The
    `Stroke` and `StrokeThickness` properties describe the color and the thickness
    to draw the shape's outline. The `Fill` property describes the color used to decorate
    the interior of the shape.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create various shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin with creating a new project. Open your Visual Studio, and create
    a WPF project called `CH02.ShapesDemo`. As we will be creating multiple shapes,
    we will be using the `UniformGrid` panel to host the shapes in this demonstration.
    You can learn more about this panel in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create various shapes in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `MainWindow.xaml` file, and replace the existing `Grid` panel with
    `UniformGrid`. Set its maximum columns count to `3`, by setting its `Column` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add our first shape, a `Rectangle`. Add the following XAML code inside
    the `UniformGrid`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add an `Ellipse`, which you can change to a circle by setting the
    same value to its `Height` and `Width` properties. Add the following code to create
    the ellipse:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a `Line` in the panel, add the following XAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Polyline` is a series of connected straight lines. Add the following XAML
    to easily create a polyline shape, where the line is being drawn based on the
    data points provided in the `Points` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can add a `Polygon` shape to the UI. Add the following code
    inside the `UniformGrid` to draw the shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a `Path` shape control, add the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now let's build your project and run the application. You will see the following
    shapes on the screen, as we have added the preceding code:![](img/ab6686d8-03b9-4a1d-a145-0a8b80cdd096.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A rectangular shape is being drawn by setting the `Height` and `Width` properties
    of the `Rectangle` class, along with the stroke color and the thickness of it.
    To create a square, you can use this shape by setting its dimension properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, a circular shape has been drawn using the `Ellipse` control.
    It uses the same property sets to create the shape. To make it a complete circle,
    set its `Height` and `Width` to the same value.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to draw a straight line in the UI, use the `Line` class. It exposes
    four properties to draw the line. Set the `X1` and `Y1` properties to mark the
    starting point; set `X2` and `Y2` properties to mark the ending point of the line.
    In the preceding example, a line has been drawn from the (`10`,`80`) coordinate
    point to the (`190`,`20`) coordinate point.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth example, we have seen how to create a series of connected straight
    lines using the `Polyline` shape control. You need to set the (*X*, *Y*) coordinate
    points of the lines in its `Points` property. In the preceding example, it creates
    the shape connecting the following coordinate points (`10`,`60`), (`60`,`180`),
    (`100`,`20`), (`180`,`80`), and (`120`,`140`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Polygon` also uses the same concept to draw a series of lines, but it completes
    the connected series of lines to draw a closed shape.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Path` control, in the sixth example, you can draw a series of connected
    lines and curves. The `Data` property is used to set the geometry that specifies
    the shape to be drawn. The data points always start with `M` to begin drawing
    the lines. In any part, if you want to create a curve, prefix the character `C`
    at that point.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PathGeometry` objects are used to draw lines, curves, arcs, and complex
    shapes. WPF provides two classes to describe the geometric paths using the mini
    language **Path Markup Syntax**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/path-markup-syntax](http://bit.ly/path-markup-syntax)'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to draw simple shapes, you can use the `EllipseGeometry`, `LineGeometry`,
    and `RectangleGeometry` objects. Composite geometries are created by `GeometryGroup`
    and to create combine geometries, use the `CombineGeometry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following example to demonstrate a complex path geometry using
    a `PathSegmentCollection` of three segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection consists of one `ArcSegment` and two `BeizerSegments` to set
    the geometry points to draw the following shape, but you can also add additional
    segments, such as `LineSegment`, `PolyBeizerSegment`, `PolyLineSegment`, `PolyQuadraticBeizerSegment`,
    and `QuadraticBeizerSegment` to create a more complex path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a66c8f25-8bc5-43b5-89da-aa953de19b19.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that all shapes are stretchable. You can use the `Stretch` property to
    define a shape's stretching behavior. If you set it to `None`, the `Shape` object
    will not be stretchable. If you set it to `Fill`, `Uniform`, or `UniformToFill`,
    the `Shape` content will be stretched to fill the space with or without preserving
    the aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tooltips to show additional information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tooltips are used to show additional information about a specific control or
    a link when hovering your mouse over it. The `FrameworkElement` class exposes
    a property named `Tooltip`, which you can find on all the controls available in
    WPF.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with the tooltips in WPF. We will
    also cover how to design a tooltip using other controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE and create a new WPF application project called
    `CH02.TooltipDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page, and then follow these steps to add simple
    tooltips to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: First, replace the default `Grid` with a `StackPanel`, and set its `Orientation`
    property to `Horizontal` to have some horizontally stacked items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add three buttons to the `StackPanel`, and set their `ToolTip` property. To
    add a show duration of the tooltip, set its `ToolTipService.ShowDuration` attached
    property to a value in milliseconds. You can use the following XAML as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the application, and hover over the buttons to see the tooltip pop up on
    the screen, as shown in the following screenshot:![](img/8d2ddd15-8dd4-447a-8b81-f3a657b88836.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ToolTip` property, when set in any WPF control, gets visible when you hover
    over the control. Apart from this, the `ToolTipService` class has a bunch of attached
    properties to help you set various behaviors of the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: Like the second example, as shown earlier, if you hover over the `Open` button,
    the `Tooltip` property will be visible on screen for 2 seconds. This is because
    we set the `ShowDuration` property of the `ToolTipService` to `2000` milliseconds
    (2 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `ToolTipService.ShowOnDisabled` property to show or hide
    a `Tooltip` on an element that is disabled. The `HasDropShadow` property of the
    class ensures whether the `Tooltip` will have a shadow on it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `ToolTip` property is of `object` type, you can assign anything to it,
    including various UI controls. Hence, it helps you to customize the UI of the
    tooltip with a much richer experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `Tooltip` property of the third button in the preceding example.
    Place a few `TextBlock` and `Border` controls in a `StackPanel` to design the
    UI, as shared in the following XAML code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the application, hover over the third button to see the customized
    UI of the tooltip for that button, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7fc67f6d-3aa2-4225-8c13-26b74a759b48.png)'
  prefs: []
  type: TYPE_IMG
- en: The `ToolTipService` class also exposes a few additional properties, such as
    `HorizontalOffset` and `VerticalOffset` to position `Tooltip` in a specific position
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a standard menu to the WPF application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common parts of WPF applications is the menu, as it gives various
    options within a very little space. WPF comes with a control named `Menu`, to
    hold items named `MenuItem`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn more about this menu control and how to add it to Windows applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio, and create a new WPF project called `CH02.MenuDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add menus to your WPF application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `DockPanel`.
    We will discuss more about this panel in the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add the `Menu` control inside the `DockPanel`. This will create the base
    to hold all the menu items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can then add root-level menu items and sub-menu items in a hierarchical
    fashion, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the application to see the following window containing the added menu items:![](img/87d60ca0-d2a4-4bad-94e6-b5de9b81b094.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you add the first menu item under the `<Menu>` tag, it creates the root-level
    menu item; for example, File menu, Edit menu. Each root menu item can contain
    one or more hierarchical sub-menu items. In the preceding example, the File menu
    contains four sub-menu items.
  prefs: []
  type: TYPE_NORMAL
- en: The header property of the `MenuItem` is used to add the label of each item.
    When you want to add a separator, you can do so by adding the `<Separator />`
    tag, as shown in the preceding example. A separator does not need any `Header`
    content.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can further customize a menu entry to have an icon, a check-mark, a shortcut
    key, or a keyboard access specifier. Let's discuss each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an access key to menus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a general practice to access application menus by holding the *Alt* key
    and then pressing the character defined as its access key. For example, to open
    the File menu of any Windows application, we use *Alt* + *F*, and to access the
    File | New menu, we use *Alt* + *F*, *N*. Here, the character *F* and *N* are
    used as access keys that are invoked when we press *Alt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the WPF application, you need to specify `_` (underscore) before the character
    you want to highlight as the access key. For example, adding `_` before the `F`
    in File menu header content activates the said menu when *Alt* + *F* is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The frequently used practice is to use the first character that's not already
    used as an access key of another control. But, on a need basis, you can specify
    any character part of the label content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding icons to menus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add icons to menus to give a better look to the application's menu items.
    The `MenuItem` element contains a property named `Icon` to add an image icon or
    a Unicode character as an icon to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a Unicode character to add an icon for the Open and Save menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bda3a86-7da1-4640-a4e6-db3e65fc6d4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the application now to see the icons added to the said menus, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b0694bb-2137-483a-b028-5184ac645a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding checkable menu items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add checkable menu items too. The WPF menu item exposes two properties
    to handle this. The `IsCheckable` property tells the menu item that it can handle
    check/uncheck options. When `IsCheckable` is set to `True`, it sets to the check/uncheck
    icon on an alternate click of that menu item.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also programmatically check/uncheck a menu item. Set its `IsChecked`
    property to `True` or `False`. Make sure to set `IsCheckable="True"`. Let''s add
    the following menu item, under the Edit menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Adding click-event handlers to menus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Menus are not just to add to the application; you need to perform some actions
    on the menu with a click by adding the `Click` event handler, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code behind, implement the handler, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will first show a message box and then exit the application when the user
    clicks on the Exit menu item.
  prefs: []
  type: TYPE_NORMAL
- en: Providing extra functionalities using the context menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The context menu provides a vital role in any Windows applications offering
    additional functionalities to the user, within that context. This is often done
    relevant to a single control or a window.
  prefs: []
  type: TYPE_NORMAL
- en: When you right-click on a control or a window, you can provide a popup context
    menu to the user, to perform single-click actions. WPF provides a `ContextMenu`
    property to all framework elements to hold a `ContextMenu`, having hierarchical
    `MenuItems`.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this recipe to learn more about adding a context menu in your WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project named `CH02.ContextMenuDemo`, using the WPF application
    project template of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add a context menu to a `TextBlock` control. The same
    steps can be followed to add a context menu to any of the controls inheriting
    `FrameworkElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` file to modify the application UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the entire `Grid` block with the following XAML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the application. You will see a text saying Right-click on me to open Context
    Menu!.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the window. You will see the following context menu pop up on
    the screen:![](img/c711319d-e3e4-4b76-8f6f-ac764520cb7f.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you see from the preceding example, each `FrameworkElement` exposes a property
    named `ContextMenu`, which can hold a `ContextMenu` item. Just like the menu,
    as we learnt in the previous recipe, the context menu can also hold multiple items
    as `MenuItem`, and each menu item can again hold one or more menu items to make
    the context menu hierarchical.
  prefs: []
  type: TYPE_NORMAL
- en: Labels of menu items are assigned by setting its `Header` property. You can
    also set icons for each menu item, by assigning an image or a Unicode character
    to its `Icon` property. If you have binded a command to the menu, you can assign
    the shortcut key text as `InputGestureText` property.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can create checkable context menu items. As shown in the Menu
    item 3, you can set the `IsCheckable` property to `True`, to make the menu checkable.
    Then you can use the `IsCheck` property to show/hide the check mark on it.
  prefs: []
  type: TYPE_NORMAL
- en: To add a separator between a group of context menu items, you can use the `<Separator
    />` tag, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user options with radio buttons and checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Radio buttons and check boxes have a vital role in Windows Application Development.
    They are mostly used to provide the user an option to select from a group of items.
    Radio buttons allow you to select one from a group of options, whereas a checkbox
    allows you to toggle an option.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `RadioButton` and `CheckBox` controls
    in the WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, open your Visual Studio IDE, and create a new project named
    `CH02.OptionSelectorsDemo`. Make sure you select the WPF application project template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MainWindow.xaml` page, and follow these steps to add a set of radio
    buttons and checkbox controls to it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, replace the default `Grid` panel with a `StackPanel` to hold items stacked
    vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add the following `StackPanel` with a set of radio buttons with a `GroupName="rdoGroup1"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another set of radios, with the `GroupName="rdoGroup2"`, in a horizontally
    placed `StackPanel`, and add it to the root `StackPanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now place the following `CheckBox` controls in a horizontal `StackPanel` and
    add it to the root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the application, which will give you the following output on screen:![](img/34fdcd90-9735-4fe5-9315-6f5121fdd8ce.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a few of the radio and checkbox controls to feel the behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first set of radio button controls are placed in a group with the same name
    `rdoGroup1`. When a group name is set to a set of radio buttons, the selection
    follows that. The first radio button in that group is by default selected, by
    setting its `IsChecked` property to `True`. If you select any other radio button
    within that group, the previous selection resets to unchecked status.
  prefs: []
  type: TYPE_NORMAL
- en: The same is true for the second group too, but selection of one group does not
    affect the other group. So, when you check one radio button from the first group,
    it will not uncheck the radio buttons from the other group.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the same for `CheckBox` controls. `Checkbox` controls allow you
    to have many checked items. When you select a checkbox, it can just toggle from
    one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: Both the radio button and checkbox control expose the `IsChecked` property to
    return a Boolean value to tell whether the control is checked or unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To disable the radio button or the checkbox control, set its `IsEnabled` property
    to `False`. Both the controls expose two events—`Checked` and `Unchecked`. When
    you register the events, the `Checked` event of the control will trigger when
    you check that. Similarly, the `Unchecked` event will trigger when you uncheck
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the progress bar control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you perform a lengthy task in the background, you probably would like to
    add a progress indicator in your application UI to give a visual indication that
    some work is in progress. WPF provides us with a control name, `ProgressBar`,
    to show a percentage value of the work between 0% to 100%, in general.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn about the progress bar control and its various
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open the Visual Studio and create a new WPF application project. Name
    it `CH02.ProgressBarDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project gets created, follow these steps to add a progress indicator
    to the application''s UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml`, and replace the existing `Grid` panel with a `StackPanel`,
    so that, we can add our controls stacked vertically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the following code snippet, add three `ProgressBar` controls in
    the `StackPanel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Set the `Minimum` and `Maximum` properties of both the three controls to `0`
    (zero) and `100` (hundred) respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shared in the preceding XAML code snippet, set the `Value` of the first progress
    bar to `20`, and the second progress bar to `70`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `IsIndeterminate` property of the third progress bar to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now run the application. You will see the following output for the XAML code
    we shared earlier:![](img/e4d047ef-e99a-4c8e-8021-b1abe517703d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value of the first progress indicator is set to `20`, whereas the second
    progress indicator is set to `70`. This denotes that the 20% and 70% job is done
    respectively. As and when you progress with the task, you can just increment the
    value to have the visual indication of the progress in the UI, with the `ProgressBar`
    control.
  prefs: []
  type: TYPE_NORMAL
- en: For the third `ProgressBar` control, in the preceding example, it's a bit different.
    When you are unsure about the total job to be done, you can set its `IsIndeterminate`
    property to `True`, as shown in the preceding screenshot. When your job is done,
    you can stop the indeterminate state and set its `Value` to 100.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Slider control to pick a numeric value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Slider` control is used to pick a numeric value by dragging a thumb button
    along a horizontal or vertical line. This is often used to provide a visualization
    of a playing video and as a volume indicator.
  prefs: []
  type: TYPE_NORMAL
- en: WPF provides us a control named `Slider` to quickly implement this in your application
    UI, and, with a lot of properties for various configurations. Let's learn more
    about it, in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create a project named `CH02.SliderDemo`, based on the WPF application
    template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integration of the slider in WPF is very easy. Just place `<Slider />` in your
    XAML page, and it will start working. But to customize it further, let''s follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page, and replace the default `Grid` with a `StackPanel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add a `Slider` and a `TextBlock` control inside the `StackPanel`, as shown
    in the following XAML snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Run the application. You will see a `Slider` control in the UI, along with a
    text that shows the current value, which is set to `25`. Move the slider thumb
    to right, and it will show you the currently selected value. In our demonstration,
    it's now `65`, as shown in the following screenshot:![](img/3a973d7c-a749-4983-99f3-0789b373ba4d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It works based on the current value. The property named `Value`, provides us
    with an integer, which denotes the current position. You can programmatically
    set it to move the slider thumb to a smaller or larger value.
  prefs: []
  type: TYPE_NORMAL
- en: The `Minimum` and `Maximum` properties denote the minimum and maximum value
    that the slider can accept. In our example, we set it to `0` (zero) and `100`
    (hundred), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The other control, `TextBlock`, in our example code, has a data binding to the
    `Value` property of the slider that we have in the XAML. It displays the current
    value of the slider in a plain text format.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also enable the tick display in a slider control, to provide a better
    indication of the thumb placement. Use the `TickPlacement` property to turn on
    the tick markers. It has four values `None`, `TopLeft`, `BottomRight`, and `Both`.
    Let's add `TickPlacement="BottomRight"` in our previous slider control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TickFrequency` property is used to set the range of possible values between
    `0` and `100`. Let''s add `TickFrequency="20"` to our code and then run the application
    again. You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a495a98-7121-427d-974e-17f4c3e648ef.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, you can see that some dots are added to
    the bottom of the slider. They represent the tick. As we have added `TickFrequency`
    as `20`, it divided the entire slider range to `100/20 = 5` sections.
  prefs: []
  type: TYPE_NORMAL
- en: In general, moving the slider will not snap to the tick. Thus, you will observe
    the thumb placed between ticks. Use the `IsSnapToTickEnabled` property and set
    it to `True`, to make sure that the thumb always stays on the tick marker only.
    In this case, dragging the slider will move the thumb based on the tick frequency
    count.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Calendar control in your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Calendar` control, part of the `System.Windows.Controls` namespace, allows
    you to create a visual calendar in WPF applications. It allows you to select a
    date or a collection of dates. As it inherits from the `Control` class, all common
    properties and events from `Control` class are available to it.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn more about `Calendar` control and how to use that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with this recipe, let's create a WPF application project named
    `CH02.CalendarDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add the basic controls to the main window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the default `Grid` panel, add the tag `<Calendar />` to create the basic
    calendar control in the application UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To retrieve the date selected by the user, register the `SelectedDatesChanged`
    event to it, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the associated event handler (`OnSelectedDateChanged`) in the code-behind
    class (`MainWindow.xaml.cs`), as shown in the following code, to retrieve the
    selected date and show it in a message box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the application. You will see the following UI on the screen:![](img/6faaf605-cc79-453c-8efb-ed6b7a45dc60.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select a date from the calendar, the selected date will be shown in
    a message box, like this:![](img/02bf24de-b18e-408e-91f1-38da3fcb53d3.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a different date. This will show the message to the UI with the newly
    selected date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WPF `Calendar` control provides you with the basic UI to begin the calendar
    integration in your application. The top two arrow-heads, allow you to navigate
    back and forth to other months and select the desired date from the calendar.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation also supports year view and decade view, so, you can select the
    desired year and month very easily. Click on the month name (in our case, it's
    August 2017) present at the top, to navigate to the year view. When you are in
    the year view, it will show you the Jan–Dec month range, and clicking on the year
    will navigate you to the decade view where you can select the desired year.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Calendar` control exposes many properties and events for you to customize
    the behavior and look of the control. Let's discuss this further.
  prefs: []
  type: TYPE_NORMAL
- en: The SelectionModes property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SelectionMode` property allows you to get or set the value indicating
    what kind of selections are allowed on the calendar. There are four values available,
    named `None`, `SingleDate`, `SingleRange`, and `MultipleRange`. The `enum` value
    `SingleDate` is default, and allows you to select only a single date. But when
    you want multi-selection, set it as `MultipleRange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The DisplayDate property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Calendar` control allows you to set the start and end display dates. The
    `DisplayDate` property represents the current date to display; whereas, setting
    the `DisplayDateStart` and `DisplayDateEnd` properties limits you to select only
    the dates from the period ranging from the start date to the end date.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following XAML code demonstrates how to set the `DisplayDate`, `DisplayDateStart`,
    and `DisplayDateEnd` properties in `Calendar` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application now to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/810c4ae3-71da-430f-be41-ae9a57dc53b6.png)'
  prefs: []
  type: TYPE_IMG
- en: The DisplayMode property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DisplayMode` property allows you to select the format of the calendar,
    which can be a month, a year, or a decade. When you launch a basic calendar, by
    default, it shows the month view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bea06995-55f1-4e70-a9e8-de56c0d77db6.png)'
  prefs: []
  type: TYPE_IMG
- en: But a user can easily navigate from month to year to decade by clicking the
    header text of the `Calendar` control.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the display mode from code, you can set the `DisplayMode` property
    to `Month`, `Year`, or `Decade`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The user can initiate the downward transitions by clicking any of the calendar
    cells, and they can easily navigate from decade to year to month and select the
    correct date.
  prefs: []
  type: TYPE_NORMAL
- en: The BlackoutDates property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can choose ranges of dates to be non-selectable despite being displayed.
    You can implement the same by using the calendar's `BlackoutDates` property, which
    takes a collection of `CalendarDateRange` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Calendar` control will block the date range from August 1^(st),
    2017 to August 8^(th), 2017, and August 21^(st), 2017 to August 31^(st), 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All non-selection dates are marked by a cross, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20a6f4fa-8982-412d-aab4-754c42ae1736.png)'
  prefs: []
  type: TYPE_IMG
- en: Listing items in a Listbox control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, the `ListBox` control is used to display a list of items. Users can
    select one or more items from the list, depending on the `SelectionMode` specified.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to create a `ListBox` control and
    use it in WPF applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your Visual Studio IDE and create a new WPF application project, called
    `CH02.ListBoxDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a `ListBox` control in the UI is as easy as writing a `<ListBox />`
    tag in any XAML page. But to hold the data in it, you will have to use its properties
    properly. Follow these steps to add a `ListBox` control with some static data:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page of the WPF project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the default `Grid` panel, add the `<ListBox></ListBox>` tag to add the
    control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a few `ListBoxItem` inside the control, as shared here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add two buttons labelled `+` and `-` to perform the `add` and `delete` operations
    on the said `Listbox` control. Register the `Click` event of both the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code-behind file, `MainWindow.xaml.cs`, implement the button-click event
    handler as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now run the application. You will see the following UI in the screen:![](img/217b3d74-43b9-4416-add8-c85ded5b4d5d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, the `ListBox` control contains five items as `ListBoxItem`.
    When you launch the application, by default, the second item is selected due to
    its property `IsSelected` being set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The two buttons are used to `add` or `delete` items in the `Listbox` control.
    Click on the `+` button to trigger the `OnAddItemClicked` event, which will create
    a new instance of the `ListBoxItem` and add it to the `ListBox` control. Scroll
    the list to see the newly added entry. As the `SelectedItem` property of the `ListBox`
    is assigned with the latest item, it will now get selected, removing the previous
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the `-` button to trigger the `OnDeleteItemClicked` event. This will
    get the current selected item, and, if it is not `null`, it will be removed from
    the `ListBox` control. The property `SelectedIndex` will set to `0` (zero), to
    select the first element after deletion.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ListBox` has numerous properties to perform specific actions. Let''s learn
    a few of them. Later in this section, we will also cover how to add a customized
    `ListBoxItem` having additional UI controls.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing multi selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListBox` supports multi selection. By default, when the `SelectionMode` property
    is set to `Single`, it only accepts a single selection of items. If you set `SelectionMode`
    to `Multiple`, it will accept multi selection. The `Extended` mode allows you
    to perform single selection, but if you press the *Ctrl* key while selecting items,
    it will act as a multi selection.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the ListBoxItem with multiple controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can easily customize the `ListBoxItem`, by adding additional UI controls
    to it. Consider the following XAML code snippet, where we have added a `ListBox`,
    which has four `ListBoxItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the preceding code snippet, each `ListBoxItem` has a `StackPanel`
    to hold a `Rectangle` control and a `TextBlock` control. If you run the preceding
    code, you will see the following UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b1ef087-c85a-4fb9-a882-c73d1ad90c1f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, notice the way the items have been listed. Each
    item consists of a rectangle to preview the color that is listed as an item. This
    is more useful when displaying information on an entity.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, this is done using the `DataTemplate` property of `ListBox` control,
    which we will learn in the later chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Providing options to select from a ComboBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `ComboBox` control is an items control and works like `ListBox`, but only
    one item from the list is selectable. A `ListBox` control by default lists multiple
    items on screen, but `ComboBox` control displays the scrollable list only on a
    user click. Thus, it takes up a lot less space.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will talk about `ComboBox` control and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Begin with creating a new WPF application project, called `CH02.ComboBoxDemo`,
    using your Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these simple steps to add a `ComboBox` control in your application UI:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the default `Grid` with a `StackPanel` to host UI controls horizontally
    stacked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following XAML code, inside the `StackPanel`, to have a simple `ComboBox`
    control with some items in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another `ComboBox` to have customized items, as shown in the following
    example code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application, which will look like the following screenshot, with
    an expandable pop up menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d69e062-04c5-425e-be18-71c0c25a84b9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though a `ComboBox` control is like `ListBox`, it does not show the list of
    items by default. A user intervention is required to display the items. The UI
    of a `ComboBox` is a combination of three controls:'
  prefs: []
  type: TYPE_NORMAL
- en: A **TextBox**, which displays the selected item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Button**, which is used to show or hide available items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Popup**, which displays a list of items inside a scrollable pane and gives
    the user the option to select one item from the available list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComboBox` contains a collection of `ComboBoxItem`. You can add those to its
    `Items` property. When you click on the arrow-head, the list of items will pop
    up in the screen, as demonstrated in the preceding screenshot. To preselect an
    item from code, set its `IsSelected` property to `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also add custom contents to a `ComboBoxItem` to represent a better UI
    component. The second `ComboBox` in the preceding example, demonstrates how easy
    it is to customize the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `ListBox`, it also exposes `SelectedItem`, `SelectedIndex`, `SelectedValue`
    properties to help you to easily set or get the selected item.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ComboBox` control is not editable by default. But you can control this
    behavior to provide the user with the option to manually enter the desired value,
    directly in the `ComboBox` control. The `IsEditable` property is used to add this
    functionality. Set it to `True`, to change it to an editable `ComboBox`. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you can see the following UI, where the control
    now allows you to enter text to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/185b9bbd-49e8-47a8-94b9-010674e662c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a status bar to your window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The status bar is used to show various information about the current state of
    the application. You can use this to show cursor position, word counts, progress
    of tasks, and more. Generally, a status bar is placed at the bottom of the window
    whereas the menus, toolbars are placed at the top.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add a status bar in a WPF window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with the status bar, let's create a WPF application project called
    `CH02.StatusBarDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you create the WPF project, open the `MainWindow.xaml` page and follow
    these steps to add the `StatusBar` control to the window:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Grid` panel, add a `StatusBar` tag and set its `Height` to `26`
    and `VerticalAlignment` to `Bottom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now change its items panel template to host a `Grid` with five columns (we
    will discuss more about grid columns in the next chapter), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `StatusBar` tag, add the controls that you want to show. Let''s
    add two `StatusBarItem`; one having a plain text content and the other with a
    `ProgressBar` control. Place two separators in between, as shown in the following
    XAML snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete XAML code, which you need to place inside the default
    `Grid` panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once your UI is ready, let's run the application. You will see the following
    screen:![](img/d61f4392-43fa-4873-8663-81289c776b9c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we have placed a plain text content Running Process...
    as a `StatusBarItem` inside the first column of the `Grid`. The second and fourth
    columns of the `Grid` contain a `Separator` control, having one pixel width. The
    fifth column contains a `ProgressBar` control, having an indeterminate state.
  prefs: []
  type: TYPE_NORMAL
- en: When you resize the window, the status bar will follow its parent to resize
    itself automatically and position it to the bottom of the window. Instead of `Grid`,
    you can also use `DockPanel` to dock the status bar at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a toolbar panel to perform quick tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any windows-based application, you can find a toolbar, usually placed just
    below the main menu of a window. It contains a set of controls to provide easy
    access to common functions.
  prefs: []
  type: TYPE_NORMAL
- en: WPF offers you a `ToolBarTray` element to host one or more `ToolBar` controls,
    containing various UI controls. It provides you with some extra features, such
    as an automatic overflowing mechanism and a manual repositioning feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with toolbars in a WPF application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, open your Visual Studio IDE and create a new WPF application
    project called `CH03.ToolBarDemo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the project gets created, follow these steps to add a toolbar in the application
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainWindow.xaml` page from the Solution Explorer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, replace the existing `Grid` with a `DockPanel` so that we can host the
    toolbar docking to the top of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ToolBarTray` element inside the `DockPanel` and dock it to `Top`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `ToolBar` control inside the `ToolBarTray` and then add a few buttons
    inside it, as shown in the following XAML markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Add a `TextBox` control inside the `DockPanel`, just below the `ToolBarTray`,
    so that, it can cover the remaining space of the window. Give it the following
    name `txtBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can add a multiple toolbar inside a `ToolBarTray`. You can also add other
    controls inside a `ToolBar`. Let''s add the following `ToolBar` with a `ComboBox`
    inside it. Place it just after the first `ToolBar` control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete XAML code to take as a reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have associated a click event of the first button of the first toolbar,
    we need to write the event body. Open the `MainWindow.xaml.cs` file, and add the
    following button-click event implementation inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the application, you will see the following UI containing two toolbars
    inside a toolbar panel:![](img/2f71918f-75d8-4677-997c-f811c8b63b30.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the first button (denoted by the character B). You will see that the
    text Sample Text becomes bold. If you click the same button again, the text will
    change the font weight to normal:![](img/18536de1-fec6-4eb6-ac9c-b2c4f968544d.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `ToolBarTray` can contain one or more `ToolBar` controls. Each `ToolBar` control
    can contain one or more controls inside it. A `ToolBar` control can also remain
    empty. When you start adding other controls to it, the toolbar starts changing
    its size and position, based on the available space.
  prefs: []
  type: TYPE_NORMAL
- en: The controls placed inside a `ToolBar` can have its associated events registered.
    If you want, you can also use command bindings to have a more granular association
    between the view and the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the first button, denoted by the character B, stands
    for applying `Bold` weightage to the associated `TextBox`. When you click it for
    the first time, the `FontWeight` property of the text will set it to `Bold`. When
    you click it again, it will set to `Normal`. By following the same logic, you
    can add a `Click` event for other buttons and a `SelectionChange` event for the
    combobox, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
