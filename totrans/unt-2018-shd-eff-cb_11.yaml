- en: Advanced Shading Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity's built-in CgInclude files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your shader world modular with CgInclude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a Fur Shader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Heatmaps with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers some advanced shader techniques that you can use for your
    game. You should remember that many of the most eye-catching effects you see in
    games are made by testing the limits of what shaders can do. This book provides
    you with the technical foundations to modify and create shaders, but you are strongly
    encouraged to play and experiment with them as much as you can. Making a good
    game is not a quest for photorealism; you should not approach shaders with the
    intention of replicating reality because this is unlikely to happen. Instead,
    you should try to use shaders as a tool to make your game truly unique. With the
    knowledge of this chapter, you will be able to create the materials that you want.
  prefs: []
  type: TYPE_NORMAL
- en: Using Unity's built-in CgInclude files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first step in writing our own `CgInclude` files is to understand what Unity
    is already providing with us for shaders. When writing Surface Shaders, there
    is a lot happening under the hood, which makes the process of writing Surface
    Shaders so efficient. We can see this code in the included `CgInclude` files found
    in the directory that you installed Unity in at `Editor `| `Data `| `CGIncludes`.
    All the files contained within this folder do their part to render our objects
    with our shaders on the screen. Some of these files take care of shadows and lighting,
    some take care of helper functions, and some manage platform dependencies. Without
    them, our shader-writing experience would be much more laborious.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of the information that Unity has provided us with at the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html](http://docs.unity3d.com/Documentation/Components/SL-BuiltinIncludes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin the process of understanding these built-in `CgInclude` files,
    using some of the built-in helper functions from the `UnityCG.cginc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00216.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start diving into the meat of writing the shader, we need to get
    a few items set up in our scene. Let''s do the following and then open the shader
    in your IDE of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and fill it with a simple sphere model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new shader (`Desaturate`) and material (`DesaturateMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the new shader to the new material and assign the material to the sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a directional light and position it above your sphere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, open the `UnityCG.cginc` file from Unity's `CgInclude` folder located
    in Unity's install directory. This will let us analyze some of the helper functions'
    code so that we can understand what is happening when we use them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have a simple scene set up to work on the shader. Refer to the
    following screenshot, which is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00217.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the scene prepared, we can now begin the process of experimenting with
    some of the built-in helper functions included with the `UnityCG.cginc` file.
    Double-click on the shader that was created for this scene in order to open it
    in your IDE of choice and insert the code given in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `Properties` block of the new shader file. We
    will need a single texture and slide for our example shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We then need to make sure that we create the data connection between our `Properties`
    and `CGPROGRAM` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code, placed after the `CGPROGRAM` declaration and `#pragma`
    directives, removing the other default properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we just have to update our `surf()` function to include the following
    code. We introduce a new function that we haven''t seen yet, which is built into
    Unity''s `UnityCG.cginc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. From there, you should be
    able to assign a material to the `DesaturateMat` (I used the `TerrainBlend` texture
    from the `Chapter 3 `| `Textures` folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00218.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the shader code modified, you should see something similar to the preceding
    screenshot. We have simply used a helper function, built into Unity''s `CgInclude`
    file, to give us an effect of desaturating the main texture of our shader. Notice
    that if we change the value to `1`, all of the color leaves, giving us a grayscale
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00219.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the built-in helper function named `Luminance()`, we are able to quickly
    get a desaturation or grayscale effect on our shaders. This is all possible because
    of the `UnityCG.cginc` file is brought automatically to our shader as we are using
    a Surface Shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you search through the `UnityCG.cginc` file when opened in a script editor,
    you will find the implementation of this function at line *473*. The following
    snippet is taken from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As this function is included in the file and Unity automatically compiles with
    this file, we can use the function in our code as well, thereby reducing the amount
    of code that we have to write over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Notice there is also a `Lighting.cginc` file, which Unity comes with. This file
    houses all the lighting models that we use when we declare something like `#pragma
    Surface surf Lambert`. Sifting through this file reveals that all the built-in
    lighting models are defined here for reuse and modularity.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll notice that the `Luminance` function we are using will return the dot
    product between the color passed in and a property called `unity_ColorSpaceLuminance`.
    To see what that is, you can use Find menu in your text editor (*Ctrl *+ *F*)
    and type it in. After searching for it, you should be able to see the following
    on line *28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that, depending on the color space being used, the values given will
    change. By default, Unity uses a Gamma color space as only certain platforms support
    linear. To check what color space you are using in your project, you can go to Edit
    | Project Settings| Player | Other Settings and look at the Color Space property.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on color spaces check out: [http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ](http://www.kinematicsoup.com/news/2016/6/15/gamma-and-linear-space-what-they-are-how-they-differ).
  prefs: []
  type: TYPE_NORMAL
- en: Making your shader world in a modular way with CgInclude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing about the built-in `CgInclude` files is great, but what if we want to
    build our own `CgInclude` files to store our own lighting models and helper functions?
    We can, in fact, create our own `CgInclude` files, but we need to learn a little
    more code syntax before we can start using them efficiently in our shader-writing
    pipelines. Let's take a look at the process of creating a new `CgInclude` file
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through the process of generating a new item for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Project tab, right-click on the `Assets` folder and select Show in
    Explorer. You should see your project folder. Then create a text file by right-clicking
    and selecting New | Text Document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00220.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rename the file to `MyCGInclude` and replace the `.txt` file extension with
    `.cginc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00221.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Windows will give you a warning message saying that the File may become unusable,
    but it will still work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import this new `.cginc` file into your Unity project and let it compile. If
    all goes well, you will see that Unity knew to compile it into a `CgInclude` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now ready to begin creating our own custom `CgInclude` code. Simply double-click
    on the `CgInclude` file that you created in order to open it in your IDE of choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our `CgInclude` file open, we can begin to enter the code that will get
    it working with our Surface Shaders. The following steps will get our `CgInclude`
    file ready for use within our Surface Shaders and allow us to continually add
    more code to it as we develop more shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin our `CgInclude` file with what is called a preprocessor directive.
    These are statements such as `#pragma` and `#include`. In this case, we want to
    define a new set of code that will be executed if our shader includes this file
    in its compiler directives. Enter the following code at the top of your `CgInclude`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We always need to make sure that we close `#ifndef` or `#ifdef` with `#endif`
    to close the definition check, just like an `if` statement needs to be closed
    with two brackets in C#. Enter the following code just after the `#define` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we just need to implement the contents of the `CgInclude` file.
    So, we finish off our `CgInclude` file by entering the following code after the
    `#define` and before the `#endif`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this completed, you now have your very first `CgInclude` file. With just
    this little bit of code, we can greatly reduce the amount of code that we have
    to rewrite, and we can begin to store the lighting models that we use all the
    time here so that we never lose them. Your `CgInclude` file should look similar
    to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple more steps that we need to complete before we can fully
    utilize this `CgInclude` file. We simply need to tell the current shader that
    we are working with to use this file and its code. To complete the process of
    creating and using `CgInclude` files, let''s complete the next set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to have our `CgInclude` file in the same directory as our shader, so
    drag and drop it into the `Chapter 11 `| `Shaders` folder from the Project tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *step 1* is not completed, you will get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are in the folder, select the `Desaturate` shader created in the
    previous recipe and duplicate it (*Ctrl *+ *D*). Name the duplicate `Colorize`,
    and double-click on it to open it up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, update the shader name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you turn your attention to our shader, you will see that we need to tell
    our `CGPROGRAM` block to include our new `CgInclude` file, so that we can access
    the code it contains. Modify the directives of our `CGPROGRAM` block to include
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our current shader is currently using the built-in Standard lighting model,
    but we want to use the Half Lambert lighting model that we created in our `CgInclude`.
    As we have included the code from our `CgInclude` file, we can use the Half Lambert
    lighting model with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have also declared a custom variable in our `CgInclude` file to
    show that we can set up default variables for our shaders to use. To see this
    in action, enter the following code in the `Properties` block of your shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to update our `surf` function header since we use `SurfaceOutput`
    in our `LightingHalfLambert` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in Unity, create a new material that will use the newly created `Colorize`
    shader (`ColorizeMat`) and assign it to the sphere we created in the last recipe.
    Assign the material as normal and modify the MyColor value from the Inspector
    to see how it modifies the object. The following screenshot shows the result of
    using our `CgInclude` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00222.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using shaders, we can include other sets of code using the `#include` preprocessor
    directive. This tells Unity that we want to let the current shader use the code
    from within the included file in the shader; this is the reason why these files
    are called `CgInclude` files. We are including snippets of Cg code using the `#include`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have declared the `#include` directive and Unity is able to find the
    file in the project, Unity will then look for code snippets that have been defined.
    This is where we start to use the `#ifndef` and `#endif` directives. When we declare
    the `#ifndef` directive, we are simply saying "if not defined, define something
    with a name." In this recipe's case, we said we wanted to `#define MY_CG_INCLUDE`.
    So, if Unity doesn't find a definition called `MY_CG_INCLUDE`, it goes and creates
    it when the `CgInclude` file is compiled, thereby giving us access to the code
    that follows. The `#endif` method simply says that this is the end of this definition,
    so stop looking for more code.
  prefs: []
  type: TYPE_NORMAL
- en: You can now see how powerful this is we can now store all of our lighting models
    and custom variables in one file and greatly reduce the amount of code that we
    have to write. The real power is when you can begin to give your shaders flexibility
    by defining multiple states of functions in the `CgInclude` files.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Fur Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The look of a material depends on its physical structure. The shaders attempt
    to simulate them, but, in doing so, they oversimplify the way light behaves. Materials
    with a complex macroscopic structure are particularly hard to render. This is
    the case for many fabrics and animal furs. This recipe will show you how it is
    possible to simulate fur and other materials (such as grass) that are more than
    just a flat surface. In order to do this, the same material is drawn multiple
    times over and over, increasing in size every time. This creates the illusion
    of fur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shader presented here is based on the work of Jonathan Czeck and Aras Pranckevičius:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00223.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for this recipe to work, you will need a texture that shows how you
    wish to have your fur displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00224.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I have provided two examples in `Chapter 11 `| `Textures` folder with the book's
    example code (`Faux Fur` and `panda`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all the other shaders before, you will need to create a new Standard Surface
    Shader (`Fur`) and a material (`FurMat`) to host it, and attach it to a sphere
    for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00225.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we can start modifying a Standard Surface Shader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click on the `Fur` Shader to open it up in your IDE of choice. Once
    opened, add the following bolded `Properties`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This shader requires you to repeat the same pass several times. We will use
    the technique introduced in the *Making your shader world modular with CgIncludes *recipe
    to group all the code necessary from a single pass in an external file. Let''s
    start creating a new `CgInclude` file called `FurPass.cginc` with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Got back to your original shader and add this extra pass after the `ENDCG`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back into Unity and assign the `FauxFur` texture in the Albedo (RGB) property.
    You should notice little dots along the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00226.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add more passes, progressively increasing `FUR_MULTIPLIER`. You can get decent
    results with 20 passes, from `0.05` to `0.95`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the shader has been compiled and attached to a material, you can change
    its appearance from the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Fur Length` property determines the space between the fur shells, which
    will alter the length of the fur. Longer fur might require more passes to look
    realistic.
  prefs: []
  type: TYPE_NORMAL
- en: '`Alpha Cutoff` and `Alpha Cutoff End` are used to control the density of the
    fur and how it gets progressively thinner.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Edge Fade` determines the final transparency of the fur and how fuzzy it looks.
    Softer materials should have a high `Edge Fade`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `Gravity Direction` and `Gravity Strength` curve the fur shells to
    simulate the effect of gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00227.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technique presented in this recipe is known as Lengyel''s concentric fur-shell
    technique or simply the shell technique. It works by creating progressively bigger
    copies of the geometry that needs to be rendered. With the right transparency,
    it gives the illusion of a continuous thread of hair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00228.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The shell technique is extremely versatile and relatively easy to implement.
    Realistic fur requires not only extruding the geometry of the model but also altering
    its vertices. This is possible with tessellation shaders, which are much more
    advanced and not covered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pass in this `Fur` Shader is contained in `FurPass.cginc`. The vertex
    function creates a slightly bigger version of the model, which is based on the
    principle of normal extrusion. Additionally, the effect of gravity is taken into
    account, so that it gets more intense the further we are from the center:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the alpha channel is used to determine the final length of
    the `Fur`. This allows for more precise control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the surface function reads the control mask from the alpha channel.
    It uses the cutoff value to determine which pixels to show and which ones to hide.
    This value changes from the first to the final fur shell to match `Alpha Cutoff`
    and `Alpha Cutoff End`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The final alpha value of the fur also depends on its angle from the camera,
    giving it a softer look.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Fur` shader has been used to simulate fur. However, it can be used for
    a variety of other materials. It works very well for materials that are naturally
    made of multiple layers, such as forest canopies, fuzzy clouds, human hair, and
    even grass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional examples of the same shader being used by just tweaking the
    parameters can be seen in the book''s example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00229.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are many other improvements that can dramatically increase its realism.
    You can add a very simple wind animation by changing the direction of the gravity
    based on the current time. If calibrated correctly, this can give the impression
    that the fur is moving because of the wind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can make your fur move when the character is moving. All
    these little tweaks contribute to the believability of your fur, giving the illusion
    that it is not just a static material drawn on the surface. Unfortunately, this
    shader comes at a price: 20 passes are very heavy to compute. The number of passes
    determines roughly how believable the material is. You should play with fur length
    and passes in order to get the effect that works best for you. Given the performance
    impact of this shader, it is advisable to have several materials with different
    numbers of passes; you can use them at different distances and save a lot of computation.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Heatmaps with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One characteristic that makes shaders hard to master is the lack of proper documentation.
    Most developers learn shaders by messing around with the code, without having
    a deep knowledge of what's going on. The problem is amplified by the fact that
    Cg/HLSL makes a lot of assumptions, some of which are not properly advertised.
    Unity3D allows C# scripts to communicate with shaders using methods such as `SetFloat`,
    `SetInt`, `SetVector`, and so on. Unfortunately, Unity3D doesn't have a `SetArray`
    method, which leads many developers to believe that `Cg/HLSL` doesn't support
    arrays either. This is not true. This post will show you how it's possible to
    pass arrays to shaders. Just remember that GPUs are highly optimized for parallel
    computations, and using for loops in a shader will dramatically decrease its performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will implement a heatmap, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00230.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The effect in this recipe creates a heatmap from a set of points. This heatmap
    can be overlaid on top of another picture, like in the preceding screenshot. The
    following steps are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a quad with the texture that you want to use for the `Heatmap` (`GameObject`
    | `3D Object` | `Quad`). In this example, a map of London has been used. In order
    to put the texture on the quad, create a new material (`Map`) using the Unlit/Texture
    shader, and assign the image to the Base (RGB) property. Once created, drag and
    drop that object onto the quad. The position of quad object must be set to (0,
    0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another quad and place it on top of the previous one. Our `Heatmap` will
    appear on this quad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach a new shader (`Heatmap`) and material (`HeatmapMat`) to the second quad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00231.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For ease of visualization, I also selected the MainCamera and changed the Projection
    to `Orthographic` and the Size property to `0.5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shader is quite different from the ones created before, yet it is relatively
    short. For this reason, the entire code is provided in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy this code to the newly created shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have attached this script to your material, you should provide a ramp
    texture for the heatmap. It''s important to configure it so that its Wrap Mode
    is set to Clamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00232.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If your heatmap is going to be used as an overlay, then make sure that the ramp
    texture has an alpha channel and the texture is imported with the Alpha is Transparency option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script called `HeatmapDrawer` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Attach the script to an object in your scene, preferably to the quad. Then,
    drag the material created for this effect to the `Material` slot of the script.
    By doing this, the script will be able to access the `Material` and initialize
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, expand the positions, radiuses, and intensities fields of your script
    and fill them with the values of your heatmap. Positions indicate the points (in
    world coordinates) of your heatmaps, radii indicate their size, and intensities
    indicate how strongly they affect the surrounding area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00233.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If all went well, once you play the game you should notice something similar
    to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00234.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you do not see this, make sure that the heatmap is placed in front of the
    map quad and that both objects are in front of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: If you get a warning saying the number of points has changed, go into your shader,
    modify the script by adding a space, and then save it again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shader relies on things that have not been introduced before in this book;
    the first one is arrays. Cg allows arrays that can be created with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Cg doesn''t support arrays with an unknown size: you must preallocate all the
    space that you need beforehand. The preceding line of code creates an array of
    `20` elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Unity allows us to set arrays through using a number of methods, including `SetVectorArray`,
    `SetColorArray`, `SetFloatArray`, and `GetMatrixArray`.
  prefs: []
  type: TYPE_NORMAL
- en: The `SetVectorArray` function only works with the `Vector4` class at present.
    That will not cause us any issues, though, as you can automatically assign a `Vector3` to
    a `Vector4`, and Unity will automatically include a zero in for the last element.
    Also, it is possible to instead use our `Start` code in an `Update` loop to be
    able to see the values change as we're modifying them, but it would be computationally
    expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the fragment function of the shader, there is a similar for loop, which,
    for each pixel of the material, queries all the points to find their contribution
    to the heatmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `h` variable stores the heat from all the points, given their radii and
    intensities. It is then used to look up which color to use from the ramp texture.
  prefs: []
  type: TYPE_NORMAL
- en: The shaders and arrays are a winning combination, especially as very few games
    are using them at their full potential. However, they introduce a significant
    bottleneck, as, for each pixel, the shader has to loop through all the points.
  prefs: []
  type: TYPE_NORMAL
