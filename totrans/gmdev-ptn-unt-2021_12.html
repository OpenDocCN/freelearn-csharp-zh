<html><head></head><body>
        

                            
                    Implementing Power-Ups with the Visitor Pattern
                
            
            
                
<p>In this chapter, we are going to implement a power-up mechanic for our game. Power-ups have been a core ingredient of video games since their early inception. One of the first games that implemented power-ups is <em>Pac-Man</em> from 1980. In the game, you could eat Power Pellets that would give Pac-Man temporary invincibility. Another classic example is the mushrooms in <em>Mario Bros.</em>, which made Mario taller and more robust.</p>
<p>The power-up ingredients that we will build will be similar to the classics but with a little more granularity. Instead of having a power-up boost a singular ability of an entity, we can create combos that give out multiple benefits at once. For instance, we could have a power-up named "<strong>Protector</strong>"<strong> </strong>that adds durability to the front-facing shield and increments the strength of the primary weapon.</p>
<p>And so, in this chapter, we are going to implement a power-up mechanic that's scalable and configurable, not just for us programmers but also for designers that might be assigned the responsibility of creating and adjusting unique power-up ingredients. We will achieve this using a combination of the Visitor pattern and a unique Unity API feature named ScriptableObjects.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The basic principles behind the Visitor pattern</li>
<li>The implementation of a power-up mechanic for a racing game</li>
</ul>
<p>This section includes simplified code examples for the sake of simplicity and readability. If you wish to review a complete implementation in the context of an actual game project, open the <kbd>FPP</kbd> folder in the GitHub project, the link for which can be found under the <em>Technical requirements</em> section.</p>
<h1 id="uuid-590b55b1-fdfe-4555-bf29-d30a7a2e66c8">Technical requirements</h1>
<p class="mce-root">This chapter is hands-on. You will need to have a basic understanding of Unity and C#. We will be using the following Unity engine and C# language concepts:</p>
<ul>
<li>Interfaces</li>
<li>ScriptableObjects</li>
</ul>
<p>If you are unfamiliar with these concepts, please review them before starting this chapter. The code files for this chapter can be found on <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10</a><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10">.</a><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2020"/></p>
<p class="mce-root">Check out the following video to see the code in action: <a href="https://bit.ly/3eeknGC">https://bit.ly/3eeknGC</a><a href="https://bit.ly/3eeknGC">.</a><a href="http://bit.ly/2OsR6d6"/></p>
<p>We often use ScriptableObjects in the code examples of this book because when building game systems and mechanics, it is essential to make them easily configurable by non-programmers. The process of balancing systems and authoring new ingredients usually falls under the responsibility of game and level designers. Therefore, we use ScriptableObjects because it offers a consistent way of establishing an authoring pipeline to create and configure in-game assets.</p>
<h1 id="uuid-12d01887-fbb2-4104-9668-ec7b337f49bc">Understanding the Visitor pattern</h1>
<p>The primary purpose of the Visitor pattern is simple once you grasp it; a <em>Visitable</em> object permits a <em>Visitor</em> to operate on a specific element of its structure. This process allows the visited object to acquire new functionality from visitors without being directly modified. This description might seem very abstract at first, but it is easier to visualize if we imagine an object as a structure instead of a closed-off container of data and logic. Therefore, it is possible with the Visitor pattern to traverse an object's structure, operate on its elements, and extend its functionality without modifying it.</p>
<p>Another way to imagine the Visitor pattern in action is by visualizing the bike in our game colliding with a power-up. Like an electronic current, the power-up flows through the inner structure of the vehicle. Components marked as visitable get visited by the power-up, and new functionalities are added, but nothing is modified.</p>
<p>In the following diagram, we can visualize those principles:</p>
<div><img src="img/84326d4d-0653-464b-9d6c-eb5f5d361c0f.png" style="width:33.67em;height:31.58em;"/></div>
<p>Figure 10.1 - UML diagram of the Visitor pattern</p>
<p>There are two key participants in this pattern that we need to know well:</p>
<ul>
<li><strong>IVisitor</strong> is the interface that a class that wishes to be a visitor must implement. The visitor class will have to implement a visitor method per visitable element.</li>
<li><strong>IVisitable</strong> is the interface that classes that wish to become visitable must implement. It includes an <kbd>accept()</kbd> method that offers an entry point to a visitor object to come and visit.</li>
</ul>
<p class="mce-root">Before proceeding, it is essential to declare that the code example that we will review in the upcoming sections breaks a potential rule of the Visitor pattern. In the example, the visitor object changes some of the properties of the visited objects. However, whether this transgresses the integrity of the pattern and invalidates its original design intention is open to debate.</p>
<p class="mce-root">Nevertheless, in this chapter, we focus more on how the Visitor pattern permits us to traverse the elements that compose the structure of visitable objects. In our use case, this structure represents the core elements of our bike, which include the engine, shield, and primary weapon.</p>
<p>The Visitor is considered by some to be one of the hardest patterns to understand. So don't feel bad if you don't grasp its core concepts at first. I believe one reason it's a difficult pattern to learn is that it's one of the hardest patterns to explain.</p>
<h2 id="uuid-0a87a76d-4ad5-4ec7-ae76-fbee395afdb0">Benefits and drawbacks of the Visitor pattern</h2>
<p class="mce-root">I've written a short list of the benefits and drawbacks of using this pattern.</p>
<p>The following are the benefits:</p>
<ul>
<li><strong>Open/Closed</strong>: You can add new behaviors that can work with objects of different classes without modifying them directly. This approach follows the object-oriented programming principle of Open/Closed that states that entities should be open for extension but closed for modification.</li>
<li><strong> Single Responsibility</strong>: The Visitor pattern can adhere to the single responsibility principle in the sense you can have an object (visitable) that holds the data and another object (visitor) is responsible for introducing specific behaviors.</li>
</ul>
<p>The following are some of the potential drawbacks:</p>
<ul>
<li><strong>Accessibility</strong>: Visitors could lack the necessary access to specific private fields and methods of the elements that they are visiting. Therefore, we might need to expose more public properties in our classes than we usually would if we didn't use the pattern.</li>
<li><strong>Complexity</strong>: We could argue that the Visitor pattern is structurally more complex than straightforward patterns such as the Singleton, State, and Object Pool. Therefore, it could bring a degree of complexity to your code base that other programmers might find confusing if they are not familiar with the structure and intricacies of the pattern.</li>
</ul>
<p> </p>
<p>The Visitor uses a software engineering concept in its fundamental design named <strong>Double Dispatch</strong>. The simplest definition of the concept is that it's a mechanism that relegates a method call to different concrete methods depending on the types of two objects implicated in the call at runtime. <em>It's not essential to comprehend this concept completely to follow the example of the pattern presented in this chapter.</em></p>
<h1 id="uuid-f2beee4e-8df5-49cf-8505-5daf6b3eba90">Designing a power-up mechanic</h1>
<p>As mentioned at the beginning of this chapter, the power-up is a staple of video games. And it's a core ingredient of our game. But first, we will review some of the key specifications of our mechanic:</p>
<ul>
<li><strong>Granularity</strong>: Our power-up entities will have the ability to boost multiple properties at the same time. For example, we could have a power-up that increases offensive capabilities such as the primary weapon's range while repairing the front-facing shield.</li>
<li><strong>Time</strong>: The power-up effects are not temporal so they don't expire after a certain amount of time. And the benefits of the next power-up are added on top of the previous one until they hit the maximum settings of the boosted properties.</li>
</ul>
<p>Take note that these specifications are limited to the following code example, but are not final. We could easily make the benefits of a power-up temporary or change the overall design of the mechanic with slight changes to the code example presented in the next section.</p>
<p>Our level designers will position the power-ups in strategic points across the race track; they will have 3D shapes that are easy to spot at high speed. The player will have to collide with a power-up to activate the abilities and benefits it contains.</p>
<p class="mce-root">We will use a combination of the Visitor pattern and ScriptableObjects to implement this game mechanic so designers can author new variations of power-ups without needing to write a single line of code.</p>
<p>In video games, the core difference between an item and a power-up is that a player can collect items, store them, and choose when to use their benefits. But in contrast, a power-up takes effect immediately after the player touches it.</p>
<h1 id="uuid-167690b5-f064-46b9-94df-12a40b41d96c">Implementing a power-up mechanic</h1>
<p>In this section, we will write the necessary skeleton code to implement a power-up system with the Visitor pattern. Our goal is to have a valid proof of concept by the end of this section.</p>
<h2 id="uuid-db0e5f65-bf6d-477f-915b-496eea6f8cea">Implementing the power-up system</h2>
<p>Let's look at the steps for implementation: </p>
<ol>
<li class="mce-root">We'll start by writing a core element of the pattern, the <kbd>Visitor</kbd> interface:</li>
</ol>
<pre style="color: black;padding-left: 60px">namespace Pattern.Visitor<br/>{<br/>    public interface IVisitor<br/>    { <br/>        void Visit(BikeShield bikeShield);<br/>        void Visit(BikeEngine bikeEngine);<br/>        void Visit(BikeWeapon bikeWeapon);<br/>    }<br/>}</pre>
<ol start="2">
<li>Next up, we are going to code an interface that each visitable element will have to implement:</li>
</ol>
<pre style="color: black;padding-left: 60px">namespace Pattern.Visitor<br/>{<br/>    public interface IBikeElement<br/>    { <br/>        void Accept(IVisitor visitor);<br/>    }<br/>}</pre>
<ol start="3">
<li>Now that we have our primary interfaces, let's implement the main class that makes our power-up mechanism work; because of its length, we will review it in two parts:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    [CreateAssetMenu(fileName = "PowerUp", menuName = "PowerUp")]<br/>    public class PowerUp : ScriptableObject, IVisitor<br/>    {<br/>        public string powerupName;<br/>        public GameObject powerupPrefab;<br/>        public string powerupDescription;<br/><br/>        [Tooltip("Fully heal shield")]<br/>        public bool healShield;<br/><br/>        [Range(0.0f, 50f)]<br/>        [Tooltip(<br/>            "Boost turbo settings up to increments of 50/mph")]<br/>        public float turboBoost;<br/><br/>        [Range(0.0f, 25)]<br/>        [Tooltip(<br/>            "Boost weapon range in increments of up to 25 units")]<br/>        public int weaponRange;<br/><br/>        [Range(0.0f, 50f)]<br/>        [Tooltip(<br/>            "Boost weapon strength in increments of up to 50%")]<br/>        public float weaponStrength;<br/></pre>
<p style="padding-left: 60px">The first thing to notice is that this class is a <kbd>ScriptableObject</kbd> with a <kbd>CreateAssetMenu</kbd> attribute. Therefore, we will be able to use it to create new power-up assets from the Asset menu. And then, we will be able to configure the parameters of each new power-up in the engine's Inspector. But another important detail is that this class implements the <kbd>IVisitor</kbd> interface, which we will review in the following part:</p>
<pre style="padding-left: 60px">        public void Visit(BikeShield bikeShield) <br/>        {<br/>            if (healShield) <br/>                bikeShield.health = 100.0f;<br/>        } <br/><br/>        public void Visit(BikeWeapon bikeWeapon) <br/>        {<br/>            int range = bikeWeapon.range += weaponRange;<br/><br/>            if (range &gt;= bikeWeapon.maxRange)<br/>                bikeWeapon.range = bikeWeapon.maxRange;<br/>            else<br/>                bikeWeapon.range = range;<br/><br/>            float strength = <br/>                bikeWeapon.strength += <br/>                    Mathf.Round(<br/>                        bikeWeapon.strength <br/>                        * weaponStrength / 100);<br/><br/>            if (strength &gt;= bikeWeapon.maxStrength)<br/>                bikeWeapon.strength = bikeWeapon.maxStrength;<br/>            else<br/>                bikeWeapon.strength = strength;<br/>        }<br/><br/>        public void Visit(BikeEngine bikeEngine)<br/>        {<br/>            float boost = bikeEngine.turboBoost += turboBoost;<br/><br/>            if (boost &lt; 0.0f)<br/>                bikeEngine.turboBoost = 0.0f;<br/><br/>            if (boost &gt;= bikeEngine.maxTurboBoost)<br/>                bikeEngine.turboBoost = bikeEngine.maxTurboBoost;<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As we can see, for each visitable element, we have a unique method associated with it; inside each of them, we implement the operation we want to execute when visiting a specific element.</p>
<p style="padding-left: 60px" class="mce-root">In our case, we are changing specific properties of the visited object while taking into account the defined maximum values. Therefore, we encapsulate the expected behavior of a power-up when it visits a specific visitable element of the bike's structure inside individual <kbd>Visit()</kbd> methods.</p>
<p style="padding-left: 60px" class="mce-root">We need to change specific values, modify operations, and add new behaviors for a particular visitable element; we can do these things inside this single class.</p>
<ol start="4">
<li>Next up is the <kbd>BikeController</kbd> class, responsible for controlling the bike's key components that comprise its structure:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/>using System.Collections.Generic;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    public class BikeController : MonoBehaviour, IBikeElement<br/>    {<br/>        private List&lt;IBikeElement&gt; _bikeElements = <br/>            new List&lt;IBikeElement&gt;();<br/><br/>        void Start()<br/>        {<br/>            _bikeElements.Add(<br/>                gameObject.AddComponent&lt;BikeShield&gt;());<br/><br/>            _bikeElements.Add(<br/>                gameObject.AddComponent&lt;BikeWeapon&gt;());<br/><br/>            _bikeElements.Add(<br/>                gameObject.AddComponent&lt;BikeEngine&gt;());<br/>        }<br/><br/>        public void Accept(IVisitor visitor)<br/>        {<br/>            foreach (IBikeElement element in _bikeElements)<br/>            {<br/>                element.Accept(visitor);<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">Notice that the class is implementing the <kbd>Accept()</kbd> method from the <kbd>IBikeElement</kbd> interface. This method will get called automatically when the bike collides with a power-up item positioned on the race track. And through this method, a power-up entity will be able to pass a visitor object to the <kbd>BikeController</kbd>.</p>
<p style="padding-left: 60px">The controller will proceed to forward the received visitor object to each of its visitable elements. And the visitable elements will get their properties updated as configured in the instance of the visitor object. Hence, this is how the power-up mechanism is triggered and operates.</p>
<ol start="5">
<li>It's time to implement our individual visitable elements, starting with our skeleton <kbd>BikeWeapon</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    public class BikeWeapon : MonoBehaviour, IBikeElement<br/>    {<br/>        [Header("Range")]<br/>        public int range = 5; <br/>        public int maxRange = 25;<br/><br/>        [Header("Strength")]<br/>        public float strength = 25.0f;<br/>        public float maxStrength = 50.0f;<br/><br/>        public void Fire()<br/>        {<br/>            Debug.Log("Weapon fired!");<br/>        }<br/><br/>        public void Accept(IVisitor visitor)<br/>        {<br/>            visitor.Visit(this);<br/>        }<br/><br/>        void OnGUI() <br/>        {<br/>            GUI.color = Color.green;<br/><br/>            GUI.Label(<br/>                new Rect(125, 40, 200, 20), <br/>                "Weapon Range: " + range);<br/><br/>            GUI.Label(<br/>                new Rect(125, 60, 200, 20), <br/>                "Weapon Strength: " + strength);<br/>        }<br/>    }<br/>}</pre>
<ol start="6">
<li>The following is the <kbd>BikeEngine</kbd> class; take note that in a complete implementation, this class would have the responsibility of simulating some of the behaviors of an engine, including activating the turbocharger, managing the cooling system, and controlling the speed:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    public class BikeEngine : MonoBehaviour, IBikeElement<br/>    {<br/>        public float turboBoost = 25.0f; // mph<br/>        public float maxTurboBoost = 200.0f;<br/><br/>        private bool _isTurboOn;<br/>        private float _defaultSpeed = 300.0f; // mph<br/><br/>        public float CurrentSpeed<br/>        {<br/>            get<br/>            {<br/>                if (_isTurboOn) <br/>                    return _defaultSpeed + turboBoost;<br/>                return _defaultSpeed;<br/>            }<br/>        }<br/><br/>        public void ToggleTurbo()<br/>        {<br/>            _isTurboOn = !_isTurboOn;<br/>        }<br/><br/>        public void Accept(IVisitor visitor)<br/>        {<br/>            visitor.Visit(this);<br/>        }<br/><br/>        void OnGUI() <br/>        {<br/>            GUI.color = Color.green;<br/><br/>            GUI.Label(<br/>                new Rect(125, 20, 200, 20), <br/>                "Turbo Boost: " + turboBoost);<br/>        }<br/>    }<br/>}</pre>
<ol start="7">
<li>And finally, <kbd>BikeShield</kbd>, the name of which implies its main function, is done as follows:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    public class BikeShield : MonoBehaviour, IBikeElement<br/>    { <br/>        public float health = 50.0f; // Percentage<br/><br/>        public float Damage(float damage)<br/>        {<br/>            health -= damage;<br/>            return health;<br/>        }<br/><br/>        public void Accept(IVisitor visitor)<br/>        {<br/>            visitor.Visit(this);<br/>        }<br/><br/>        void OnGUI() <br/>        {<br/>            GUI.color = Color.green;<br/><br/>            GUI.Label(<br/>                new Rect(125, 0, 200, 20), <br/>                "Shield Health: " + health);<br/>        }<br/>    }<br/>}</pre>
<p>As we can see, each individual visitable bike element class implements the <kbd>Accept()</kbd> method, thus making themselves visitable.</p>
<h2 id="uuid-517fd8df-cc3a-47e3-bd06-5367ae1e3fa3">Testing the power-up system implementation</h2>
<p>To quickly test our implementation in your own instance of Unity, you need to follow these steps:</p>
<ol>
<li>Copy all the scripts we just reviewed into your Unity project.</li>
<li>Create a new scene.</li>
<li>Add a GameObject to the scene.</li>
<li>Attach the following <kbd>ClientVisitor</kbd> script to the new GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Pattern.Visitor<br/>{<br/>    public class ClientVisitor : MonoBehaviour<br/>    {<br/>        public PowerUp enginePowerUp;<br/>        public PowerUp shieldPowerUp;<br/>        public PowerUp weaponPowerUp;<br/><br/>        private BikeController _bikeController;<br/><br/>        void Start()<br/>        {<br/>            _bikeController = <br/>                gameObject.<br/>                    AddComponent&lt;BikeController&gt;();<br/>        }<br/><br/>        void OnGUI()<br/>        {<br/>            if (GUILayout.Button("PowerUp Shield"))<br/>                _bikeController.Accept(shieldPowerUp);<br/><br/>            if (GUILayout.Button("PowerUp Engine"))<br/>                _bikeController.Accept(enginePowerUp);<br/><br/>            if (GUILayout.Button("PowerUp Weapon"))<br/>                _bikeController.Accept(weaponPowerUp);<br/>        }<br/>    }<br/>}</pre>
<ol start="5">
<li>Go to the <strong>Assets/Create</strong> menu option and create three <kbd>PowerUp</kbd> assets. </li>
<li>Configure and name the new <kbd>PowerUp</kbd> assets with your desired parameters.</li>
<li>Name the new <kbd>PowerUp</kbd> assets and adjust their parameters in the Inspector.</li>
<li>Add the new <kbd>PowerUp</kbd> assets to the public properties of the <kbd>ClientVisitor</kbd> component. </li>
</ol>
<p style="padding-left: 60px">Once you start the scene, you should see the following GUI buttons and debug output on your screen:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c84cf0c5-925b-4d5f-af9f-4cd806b5e0ee.png" style="width:65.50em;height:37.83em;"/></p>
<p>Figure 10.2 - Screenshot of the code example in action</p>
<p class="CDPAlignLeft CDPAlign">But you might be asking yourself, how do I create an actual pickup entity that I can spawn on the race track?  </p>
<p>A quick way to do this is simply to create a <kbd>Pickup</kbd> class like the following:</p>
<pre>using System;<br/>using UnityEngine;<br/><br/>public class Pickup : MonoBehaviour<br/>{<br/>    public PowerUp powerup;<br/><br/>    private void OnTriggerEnter(Collider other)<br/>    {<br/>        if (other.GetComponent&lt;BikeController&gt;())<br/>        {<br/>            other.GetComponent&lt;BikeController&gt;().Accept(powerup);<br/>            Destroy(gameObject);<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">By attaching this script to a GameObject with a collider component configured as a trigger, we can detect when an entity with the <kbd>BikeController</kbd> component enters the trigger. Then we just need to call its <kbd>Accept()</kbd> method and pass the <kbd>PowerUp</kbd> instance. Setting up triggers is beyond the scope of this chapter, but I recommend looking at the FPP project in the Git repo to review how we set it up in a playable prototype of the game.</p>
<h2 id="uuid-f520b6f3-d132-4251-bd69-2a4eef21e59c">Reviewing the power-up system implementation</h2>
<p>We were able to combine the structure of the Visitor pattern and the API features of ScriptableObjects to create a power-up mechanic that permits anyone on our project to author and configure new power-ups without writing a single line of code.</p>
<p class="mce-root">If we need to adjust how power-ups affect various components of our vehicle, we can do so by modifying a single class. So, in conclusion, we achieved a degree of scalability while keeping our code easily maintainable.</p>
<p>The implementations of the standard software design patterns in this book are experimental and adapted in creative ways. We are adapting them to utilize Unity API features and adjusting them for game development use cases. So we should not consider the examples to be academic or standardized references, just interpretations.</p>
<h1 id="uuid-9b80b1f8-7719-417f-b475-f370187fc27d">Summary</h1>
<p>In this chapter of the book, we built a power-up mechanic for our game using the Visitor pattern as our foundation. We also established a workflow to create and configure power-ups. Therefore, we combined the technical and creative mindsets, which is the core of game development.</p>
<p class="mce-root">In the next chapter, we are going to design and implement attack maneuvers for enemy drones. We are going to use the Strategy pattern as the foundation of our system.</p>


            

            
        
    </body></html>