- en: Gaze-Based Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our diorama is a third-person virtual reality experience. When you
    go into it, you're like an observer or a third-person camera. Sure, you can look
    around and add controls that let you move the camera's viewpoint. However, any
    action in the scene is from a third-person perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll pretty much stay in the third-person mode, but we''ll
    get a little more personally involved. We will explore techniques that can be
    used to control objects in your virtual world by looking and staring. Our character,
    Ethan, will be under your control, responding to where you look. Furthermore,
    we''ll start programming the Unity scripts. Along the way, we will discuss the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Adding **AI** (short for **artificial intelligence**) and **NavMesh** to our
    third-person character, Ethan
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity programming in C#
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using our gaze to move a 3D cursor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shooting and killing Ethan, the zombie, to good effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most intros to Unity development tip-toe you through the easy stuff and maybe
    never even get to the more interesting, although more complex, things. We're going
    to mix things up in this chapter, throwing you into a few different 3D graphics
    topics, some a little advanced. If it's new to you, think of this as a survey
    tutorial. Nonetheless, we go through it step by step so you should be able to
    follow along and have a lot of fun too!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Ethan, the walker
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gaming is a common application of virtual reality. So, we might as well start
    out from there, too! We are going to give our character, Ethan, a life of his
    own. Well, sort of (or not), because he's going to become a zombie!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We left off at the diorama, with Ethan hanging out. You can make him run around
    the scene if you have a hand controller with a thumbstick or touchpad, but that
    is not guaranteed on some VR devices. In fact, if you're viewing the scene with
    a Google Cardboard, it's pretty unlikely that you'll have a handheld controller
    (notwithstanding the Bluetooth game controllers). In the next chapter, [Chapter
    5](21722631-9544-4b1e-a888-877d34b0fff7.xhtml), *Handy Interactables*, we will
    go into handheld input controllers. For now, we will consider another way to make
    him move around, using the direction of your gaze while wearing your VR headset.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Before we attempt this, we'll first transform Ethan into a zombie and have him
    walk around aimlessly without any user control. We'll do this by giving him some
    AI and writing a script that sends him to random target locations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*AI controllers* and *N**avMesh* are somewhat advanced topics in Unity, but
    we''re going to throw you into it just for fun. Besides, it''s not as scary as
    zombies.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Artificially intelligent Ethan
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we want to replace the `ThirdPersonController` prefab that we used
    initially with Unity''s AI character, `AIThirdPersonController`, using the following
    steps. Unity uses the word *artificial intelligence* loosely to mean *script-driven*.
    Perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Open the Unity project from the previous chapters with the `Diorama` scene,
    and have the `Characters` package imported from `Standard Assets`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, open the `Standard Assets/Characters/ThirdPersonCharacter/Prefabs`
    folder and drag `AIThirdPersonController` into the scene. Name it `Ethan`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel (or in Scene), select the previous `ThirdPersonController`,
    (the old Ethan). Then, in the Inspector panel's Transform pane, choose the *gear*
    icon on the upper right of the Transform pane and select Copy Component.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new `Ethan` object (from the Hierarchy panel or Scene). Then, in
    the Inspector panel's Transform pane, choose the *gear* icon and select Paste
    Component Values.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can delete the old `Ethan` object by selecting it from the Hierarchy
    panel, right-clicking to open options, and clicking on Delete.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you cannot find the `Characters` package to import, you may not have installed
    `Standard Assets` when you installed Unity. To get them now, you will need to
    run the `UnityDownloadAssistant` again as described at the beginning of [Chapter
    2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content, Objects, and Scale*
    (and it may already be in your Downloads folder).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this controller has a `NavMesh Agent` component and an `AICharacterControl`
    script. The NavMesh Agent has parameters for how Ethan will move around the scene.
    The `AICharacterControl` script takes a target object where Ethan will walk to.
    Let''s populate that, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Add an empty game object to the Hierarchy panel, and rename it `WalkTarget`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reset its Transform values to position (`0`,`0`,`0`) (using the gear icon in
    upper-right of the Transform pane).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Ethan and drag `WalkTarget` into the Target property in the Inspector
    panel''s AI Character Control pane, as shown here:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2a9356ba-90ad-4be3-84d2-f815b39dc149.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: At this point, we have an AI character in the scene (`Ethan`), an empty game
    object that will be used as a navigation target (`WalkTarget`) initially in the
    center of our scene, and we told the AI Character Controller to use this target
    object. When we run the game, wherever `WalkTarget` is, Ethan will go there. But
    not yet.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The NavMesh bakery
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ethan cannot just go walking around without being told where he's allowed to
    roam! We need to define a *NavMesh*-a simplified geometrical plane that enables
    a character to plot its path around obstacles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, Ethan is an agent. Where he's allowed to walk is the *navmesh*. Note
    that he has a **NavMesh Agent** component and an `AICharacterControl` script.
    The NavMesh Agent has parameters for how Ethan will move around the scene.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `NavMesh` by first identifying the objects in the scene that affect
    navigation by marking them Navigation Static, and then baking the NavMesh, as
    follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Select the Navigation panel. If it's not already a tab in your editor, open
    the Navigation window from the main menu by navigating to Window | Navigation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select its **Object** tab.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Ground Plane in Hierarchy, then in the Navigation window's Object
    pane, check the Navigation Static checkbox. (Alternatively, you can use the object's
    Inspector window Static dropdown list.)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Repeat step 3 for each of the objects that should get in his way: the cubes
    and the sphere. An example is shown for the sphere.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Navigation window, select the Bake tab, and click on the Bake button
    at the bottom of the panel:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a01bed04-a01e-45fb-b9bb-d09bcbbdc4c1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'The Scene view should now show a blue overlay where the NavMesh is defined,
    as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82919baf-4059-475f-9f5f-02d831ccae58.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Let's test this out. Ensure that the Game panel's Maximize on Play is deselected.
    Click on the *Play* mode button (the triangle at the top of editor). In the Hierarchy
    panel, select the `WalkTarget` object and ensure that the Translate gizmo is active
    in the Scene panel (press the W key on keyboard). Now, drag the red (x) and/or
    the blue (z) arrow handles on the `WalkTarget` object to move it around the floor
    plane. As you do, Ethan should follow! Click on *Play* again to stop Play Mode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: A random walker in the town
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll write a script that moves the `WalkTarget` object to random places.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts is an important part of developing with Unity. If you've done
    anything more that tinker with Unity, you've probably already written at least
    some scripts. We're going to use the C# programming language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to programming, don't panic! We provide a more detailed introduction
    to Unity scripting at the end of this chapter. You can skip to that now and come
    back, or just follow along.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'For this first script, we''ll take it slow. We will attach the script to the
    `WalkTarget` object, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Select the `WalkTarget` object in the Hierarchy panel or the Scene view.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Inspector panel, click on the Add Component button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New Script (you many need to scroll down to find it).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `RandomPosition`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the C Sharp language is selected.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create and Add.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should create a script component on the `WalkTarget` object. Double-click
    on the `RandomPosition` script in the slot to the right of Script in the Inspector
    pane to open it in your code editor.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The RandomPosition script
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to move the `WalkTarget` object to a random location so that Ethan
    will head in that direction, wait a few seconds, and move the `WalkTarget` object
    again. That way, he''ll appear to be wandering around aimlessly. We can do this
    with a script. Rather than developing the script incrementally, I''m presenting
    the finished version first, and we''ll go through it line by line. The `RandomPosition.cs`
    script looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This script defines a `MonoBehaviour` sub-class named `RandomPosition`. The
    first thing we do when defining the class is declare any variables that we'll
    be using. A variable is a placeholder for a value. The value can be initialized
    here or assigned elsewhere, just as long as it has a value before the script uses
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The meat of the script is further down, the function named `SetRandomPosition()`.
    Let's see what that does.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, the `GroundPlane` plane is 10 units square, with the origin in
    the middle. So, any (x, z) location on the plane will be within a range from `-5`
    to `5` along each axis. The line `float x = Random.Range (-5.0f, 5.0f)` picks
    a random value within the given range and assigns it to a new `float x` variable.
    We do the same thing to get a random *z* value. (Usually, I discourage *hardcoding*
    constant values like this instead of using variables, but I'm keeping things simple for
    illustration purposes.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The line `Debug.Log ("X,Z: " + x.ToString("F2") + ", " + z.ToString("F2"))` prints
    the `x` and `z` values in the Console panel when the game is running. It''ll output
    something like `X, Z: 2.33, -4.02` because `ToString("F2")` says round up to two
    decimal places. Note that we''re using plus signs to combine the parts of the
    output string together.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We actually move the target to the given location with the line `transform.position
    = new Vector3 (x, 0.0f, z);`. We're setting the transform position of the object
    that this script is attached to. In Unity, values that have an X, Y, and Z are
    represented by the `Vector3` objects. So, we create a new one with the `x` and
    `z` values that we generated. We give `y=0` so that it sits on `GroundPlane`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Each `MonoBehaviour` class has a built-in variable called `this`, which refers
    to the object that the script is attached to. That is, when the script is a component
    of an object and appears in its Inspector panel, the script can refer to its object
    as `this`. In fact, `this` is so obvious, if you want to call functions on the
    `this` object, you don't even need to say it. We could have said `this.transform.position
    = ...`, but the `this` object is implied and is normally omitted. On the other
    hand, if you had a variable for some other object (for example, `GameObject` that;),
    then you'd need to say that when you set its position, like `that.transform.position
    = ...`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The last mysterious bit is how we handle time delays in Unity, using co-routines.
    This is a somewhat advanced coding technique, but very handy. In our case, the
    transform position should get changed once every five seconds. It''s solved in
    several parts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In the `Start()` function, there's the line `StartCoroutine (RePositionWithDelay());`.
    A **co-routine** is a piece of code that runs separately from the function from
    which it was called. So, this line kicks off the `RePositionWithDelay()` function
    in a co-routine.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside that, there's a `while (true)` loop, which as you might guess, runs forever
    (as long as the game is running).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It calls the `SetRandomPosition()` function, which actually repositions the
    object.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, at the bottom of this loop, we do a `yield return new WaitForSeconds (5);`
    statement, which basically says to Unity, *hey, go do what you want for five seconds
    and then come back here so that I can go through my loop again*.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all of this to work, the `RePositionWithDelay` co-routine must be declared
    as the `IEnumerator` type (because the documentation says so).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This co-routine/yield mechanism, although an advanced programming topic, is
    a common pattern in time-sliced programs such as Unity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Our script should be saved to a file named `RandomPosition.cs`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: We are now good to go. In the Unity editor, click on *Play*. Ethan is running
    from one place to another like a madman!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '"Zombie-ize" Ethan!'
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, that''s pretty random. Let''s adjust the NavMesh steering parameters to
    slow him down to a nice zombie-like pace. For that, perform the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Select `Ethan` in the Hierarchy panel
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to Inspector | Nav Mesh Agent | Steering and set the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Speed: `0.3`'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular Speed: `60`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Acceleration: `2`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Play again. He has slowed down. That's better.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'One more finishing touch: let''s turn him into a zombie. I have a texture image
    named `EthanZombie.png` that will help (included with this book). Perform the
    following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: From the Assets tab on the main menu, select Import New Asset.... Navigate to
    the files folder with the assets that came with this book.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `EthanZombie.png` file.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Import. For tidiness, ensure that it resides in the `Assets/Textures`
    folder. (Alternatively, you can just drag and drop the file from Windows Explorer
    into the Project panel Assets/Textures folder.)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, unfold the `Ethan` object (click on the triangle) and
    select `EthanBody`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Inspector` panel, unfold the `EthanGray` shader by clicking on the triangle
    icon to the left of Shader.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `EthanZombie` texture from the `Project Assets/Textures` folder.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag it onto the Albedo texture map. It's a small square just to the left of
    the Albedo label under Main Maps.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select `EthanGlasses` and uncheck it to disable glasses
    in the Inspector panel. After all, zombies don't need glasses!
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'His portrait is featured below. *What''d you say? That''s not a scary enough
    zombie??* Well, maybe he''s just recently turned. Go ahead and make a better one
    yourself. Use Blender, Gimp, or Photoshop and paint your own (or even import a
    whole different zombie humanoid model to replace `EthanBody` itself):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8c9774a-a357-4cd9-8c99-92a6e52f56f8.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Now, build the project and try it in VR.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We're looking from a third-person perspective. You can look around and watch
    what's going on. It's kind of fun, and it's pretty interesting. And it's passive.
    Let's get more active.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Go where I'm looking
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next script, instead of being random, we'll send Ethan to wherever we
    look. In Unity, this is accomplished by using **ray casting. **It's like shooting
    a ray from the camera and seeing what it hits (for more information, visit [http://docs.unity3d.com/Manual/CameraRays.html](http://docs.unity3d.com/Manual/CameraRays.html)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a new script, which will be attached to `WalkTarget`
    like before, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Select the `WalkTarget` object in the Hierarchy panel or the Scene view.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its Inspector panel, click on the Add Component button.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select New Script.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `LookMoveTo`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the C Sharp language is selected.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create and Add.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should create a script component on the `WalkTarget` object. Double-click
    on it to open it in your code editor.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This `LookMoveTo` script replaces the `RandomPosition` one we created before.
    Disable the `RandomPosition` component of `WalkTarget` before proceeding.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The LookMoveTo script
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our script, each time `Update()` is called, we'll read where the camera is
    pointing (by using its transform position and rotation), cast a ray in that direction,
    and ask Unity to tell us where it hits the ground plane. Then, we'll use this
    location to set the `WalkTarget` object's position.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the full `LookMoveTo.cs` script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's go through the script a bit at a time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing the script does is declare a variable for the `GroundPlane`
    object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it''s `public`, we can use the Unity editor to assign the actual object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside `Update()`, we define a few local variables, `camera`, `ray`, `hit`,
    and `hitObject`, which have datatypes that are required by the Unity functions
    that we're going to use.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`Camera.main` is the current active camera object (that is, tagged as `MainCamera`).
    We get its current transform, which will be assigned to the camera variable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ignoring the handy `Debug` statements for a moment, we first determine the ray
    from the camera using `new Ray()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'A **ray** can be defined by a starting position in the x, y, and z space and
    a direction vector. A **direction vector** can be defined as the relative offsets
    from a 3D starting point to some other point in space. The forward direction,
    where z is positive, is (`0`, `0`, `1`). Unity will do the math for us. So, if
    we take a unit vector (`Vector3.forward`), multiply it by a three-axis rotation
    (`camera.rotation`), and scale it by a length (`100.0f`), we''ll get a ray pointing
    in the same direction as the camera, measuring 100 units long:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we cast the ray and see if it hit anything. If so, the `hit` variable
    will
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: now contain more details about what was hit, including the specific object in
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`hit.collider.gameObject`. (The `out` keyword means that the `hit` variable
    value is filled in by the `Physics.Raycast()` function.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We check whether the ray hit the `GroundPlane` object and if so, we'll assign
    that as the position to move the `WalkTarget` object to the `hit` location.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The `==`compare operator should not to be confused with `=`, which is the assignment
    operator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: This script contains two `Debug` statements, which are a useful way to monitor
    what's going on while a script is running in Play Mode. `Debug.DrawRay()` will
    draw the given ray in the Scene view so that you can actually see it, and `Debug.Log()`
    will dump the current hit position to the console if and when there's a hit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the script, switch into the Unity editor, and perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: With `WalkTarget` selected, in the `Inspector` panel, the `LookMoveTo` script
    component now has a field for the `GroundPlane` object.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Hierarchy panel, select and drag the `GroundPlane` game object onto
    the Ground field.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the scene. The script pane looks like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3c0f63f-6c1d-4304-a55c-8bde8c46f55e.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: Then, click the *Play* button. Ethan should follow our gaze (at his own pace).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In projects with more than a few objects with colliders, in order to optimize
    the performance of your raycast, it is advised to place the objects on a specific
    layer (for example, named "Raycast") and then add that layer mask to the Raycast
    call. For example, if "Raycast" is layer 5, `int layerMask = 1 << 5`, then `Physics.Raycast(ray,
    out hit, maxDistance, layerMask);`. See [https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)
    and [https://docs.unity3d.com/Manual/Layers.html](https://docs.unity3d.com/Manual/Layers.html)
    for details and examples.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Adding a feedback cursor
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given it''s not always obvious where your gaze is hitting the ground plane,
    we''ll now add a cursor to the scene. It''s really easy because what we''ve been
    doing is moving around an invisible, empty `WalkTarget` object. If we give it
    a mesh by using the following steps, it''ll be visible:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select the `WalkTarget` object.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the mouse and navigate to 3D Object | Cylinder. This will create
    a cylindrical object parented by `WalkTarget`. (Alternatively, you can use the
    GameObject tab on the main menu bar, and then drag and drop the object onto `WalkTarget`.)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that we're starting with the reset values of transform by clicking on
    Reset from the *gear* icon menu in the Transform pane.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new cylinder and in its Inspector panel, change the Scale to (`0.4`,
    `0.05`, `0.4`). This will create a flat disk with a diameter of `0.4`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disable its Capsule Collider by unchecking that checkbox.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a performance optimization, in Mesh Renderer you can also disable Cast Shadows,
    Receive Shadows, Use Light Probes, and Reflection Probes.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, try to play again. The cursor disk follows our gaze.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: If you want, decorate the disk better with a colored material. Better yet, find
    an appropriate texture. For example, we used a grid texture in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml),
    *Content, Objects, and Scale*, for the `GridProjector` file (`Standard Assets/Effects/Projectors/Textures/Grid.psd`).
    The `CircleCrossHair.png` file is provided with the files for this book. Drop
    the texture onto the cylinder cursor. When you do, set its Shader to Standard.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Observing through obstacles
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we got Ethan to follow where we're looking by moving the `WalkTarget`
    object to a position on the ground plane determined by raycasting from the camera
    and seeing where it intersected that plane.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the cursor seems to get *stuck* when we slide our
    gaze over the cube and sphere. That''s because the **physics engine** has determined
    which object is hit first, never getting to the ground plane. In our script, we
    have the conditional statement `if (hitObject == ground)` before moving `WalkTarget`.
    Without it, the cursor would float over any object in 3D space where the cast
    ray hits something. Sometimes, that''s interesting, but in our case, it is not.
    We want to keep the cursor on the ground. However now, if the ray hits something
    other than the ground, it doesn''t get repositioned and seems *stuck*. Can you
    think of a way around it? Here''s a hint: look up `Physics.RaycastAll`. Alright,
    I''ll show you. Replace the body of `Update()` with the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On calling `RaycastAll`, we get back a list, or an array, of hits. Then, we
    loop
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: through each one looking for a ground hit anywhere along the path of the ray
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: vector. Now our cursor will trace along the ground, whether or not there's another
    object in between.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra challenge**: Another more efficient solution is to use the *layer system*.
    Create a new layer, assign it to the plane, and pass it as an argument to `Physics.raycast()`.
    Can you see why that''s much more efficient?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If looks could kill
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We got this far. We might as well try to kill Ethan (haha!). Here are the specifications
    for this new feature:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Ethan hits him with our line-of-sight raygun
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sparks are emitted when the gun hits its target
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After 3 seconds of being hit, Ethan is killed
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When he's killed, Ethan explodes (we get a point) and then he respawns at a
    new location
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KillTarget script
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we''ll attach the script to a new empty `GameController` object
    by performing the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty game object and name it `GameController`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach a new C# script to it, using Add Component, named `KillTarget`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the script in MonoDevelop.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the completed `KillTarget.cs` script:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s go through this. First, we declare a number of public variables, as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like we did in the previous `LookMoveTo` script, our target will be Ethan. We're
    also adding a `hitEffect` particle emitter, a `killEffect` explosion, and a start
    value for the countdown timer, `timeToSelect`. Lastly, we'll keep track of our
    kills in the `score` variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method, which is called at the start of the gameplay, initializes
    the score to zero and sets the `countDown` timer to its starting value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the `Update()` method, like in the `LookMoveTo` script, we cast a ray
    from the camera and check whether it hits our target, Ethan. When it does, we
    check the `countDown` timer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: If the timer is still counting, we decrement its value by the amount of time
    that's gone by since the last time `Update()` was called, using `Time.deltaTime`,
    and make sure that `hitEffect` is emitting at the hit point.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: If the ray is still on its target and the timer is done counting down, Ethan
    is killed. We explode, bump up the score by one, reset the timer to its starting
    value, and move (respawn) Ethan to a random new location.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: For an explosion, we'll use one of Unity's standard assets found in the `ParticleSystems`
    package. To activate it, `killEffect` should be set to the prefab named `Explosion`.
    Then, the script *instantiates* it. In other words, it makes it an object in the
    scene (at a specified transform), which kicks off its awesome scripts and effects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the ray did not hit Ethan, we reset the counter and turn off the
    particles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and go into the Unity Editor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra challenge**: Refactor the script to use co-routines to manage the delay
    timing, like we did in the `RandomPosition` script at the start of this chapter.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Adding particle effects
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to populate the `public` variables, we will perform the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: First, we need the `ParticleSystems` package that comes with Unity standard
    assets. If you do not have them, navigate to Assets | Import Package | ParticleSystems,
    choose All, and then click on Import.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `GameController` from the Hierarchy panel and go to the Kill Target (Script)
    pane in the Inspector panel.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Ethan` object from the Hierarchy panel onto the Target field.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the main menu bar, navigate to GameObject | Effects | Particle System and
    name it `SparkEmitter`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reselect `GameController` and drag `SparkEmitter` onto the Hit Effect field.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, find the `Explosion` prefab in `Assets/Standard Assets/ParticleSystems/Prefabs` and
    drag the `Explosion` prefab onto the Kill Effect field.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script pane looks like the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b918629c-942d-4dc1-a14b-adfbbddfc55e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'We created a default particle system that will be used as the spark emitter.
    We need to set that up to our liking. I''ll get you started, and you can play
    with it as you desire, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Select `SparkEmitter` from the Hierarchy panel.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And in its Inspector panel, under Particle System, set the following values:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start Size: `0.15`'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Color: pick a red/orange color'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start Lifetime: `0.3`'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Max Particles: `50`'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under Emission, set Rate over Time: `100`'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under Shape, set Shape: Sphere and Radius: `0.01`'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s what my Scene view looks like as I run Play Mode and zap Ethan in the
    chest:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b8034be-eab0-4897-ab40-875301f2ada0.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: When Ethan is shot, the `hitEffect` particle system is activated. After 3 seconds
    (or whatever value you set in the `TimeToSelect` variable), his *health* is depleted,
    the explosion effect is instantiated, the score is incremented, and he respawns
    at a new location. In  [Chapter 6](36d3f24b-8acf-42df-92cc-abb5147d4a1f.xhtml)*,
    World Space UI*, we'll see how we can show the current score to the player.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One last thing before we''re done: let''s clean up the `Assets` folder a bit
    and move all the scripts into an `Assets/Scripts/` subfolder. Select the Project
    Assets folder in Project, create a folder, name it Scripts, and drag all your
    scripts into it.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Short intro to Unity C# programming
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we just saw, Unity does a lot of things: it manages objects, renders them,
    animates them, calculates the physics of those objects, and so on. Unity itself
    is a program. It''s made of code. Probably a lot of good code written by some
    very smart people. This internal Unity code can be accessed by you, the game developer,
    through the Unity Editor point-and-click interface that we''ve already been using.
    Within the Unity Editor, scripts are manifested as configurable components. However,
    it''s also made more directly accessible to you through the Unity scripting API.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**API** (short for **Application Programming Interface**), refers to published
    software functions that you can access from your own scripts. Unity''s API is
    very rich and nicely designed. That''s one reason why people have written amazing
    applications and plugin add-ons for Unity.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: There are many programming languages in the world. Unity has chosen to support
    the C# language from Microsoft. Computer languages have a specific syntax that
    must be obeyed. Otherwise, the computer will not understand your script. In Unity,
    script errors (and warnings) appear in the Console panel of the editor as well
    as in the bottom footer of the app window.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The default script editor for Unity is an integrated development environment,
    or an IDE, called **MonoDevelop**. You can configure a different editor or an
    IDE if you want, such as Microsoft's Visual Studio. MonoDevelop has some nice
    features such as autocompletion and pop-up help that understand the Unity documentation.
    C# scripts are text files that are named with a `.cs` extension.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In a Unity C# script, some of the words and symbols are a part of the C# language
    itself, some come from the Microsoft .NET Framework, and others are provided by
    the Unity API. And then there's the code that you write.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty default Unity C# script looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's dissect it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines indicate that this script needs some other stuff to run.
    The `using` keyword belongs to the C# language. The line using `UnityEngine` says
    that we'll be using the `UnityEngine` API. The line using `System.Collections` says
    that we also might use a library of functions named `Collections` to access lists
    of objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In C#, each line of code ends with a semicolon. Double slashes (`//`) indicate
    comments in the code, and anything from there to the end of that line will be
    ignored.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'This Unity script defines a class named `RandomPosition`. **Classes** are like
    code templates with their own properties (variables) and behavior (functions).
    Classes derived from the `MonoBehaviour` base class are recognized by Unity and
    used when your game runs. For example, in the first script we wrote at the top
    of this chapter, the line `public class RandomPosition : MonoBehaviour` basically
    says *we are defining a new public class named* `RandomPosition`*," which inherits
    all the abilities of the* `MonoBehaviour`* Unity base class*, including the capabilities
    of the `Start()` and `Update()` functions. The body of the class is enclosed in
    a pair of curly braces (`{}`).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: When something is `public`, it can be seen by other code outside this specific
    script file. When it's `private`, it can only be referenced within this file.
    We want Unity to see the `RandomPosition` class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Classes define variables and functions. A **variable** holds data values of
    a specific type, such as `float`, `int`, `boolean`, `GameObject`, `Vector3`, and
    so on. **Functions** implement logic (step-by-step instructions). Functions can
    receive *arguments*-variables enclosed in a parenthesis used by its code-and can
    return new values when it's done.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Numeric `float` constants, such as `5.0f`, require an `f` at the end in C# to
    ensure
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: that the data type is a *simple* floating point value and not a *double-precision* floating
    point value.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Unity will automatically call some special functions if you've defined them `Start()` and `Update()` are
    two examples. Empty versions of these are provided in the default C# script. The
    datatype in front of a function indicates the type of value returned. `Start()` and `Update()` do
    not return values, so they're `void`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Each `Start()` function from all `MonoBehaviour` scripts in your game is called
    before the gameplay begins. It's a good place for data initialization. All the `Update()` functions
    are called during each time slice, or frame, while the game is running. This is
    where most of the action lies.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Once you've written or modified a script in the MonoDevelop or Visual Studio
    editor, save it. Then, switch to the Unity Editor window. Unity will automatically
    recognize that the script has changed and will reimport it. If errors are found,
    it will report them right away in the Console panel.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: This is just a cursory introduction to Unity programming. As we work through
    the projects in this book, I will explain additional bits as they're introduced.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the relationship between the VR camera and objects
    in the scene. We first made Ethan (the zombie) walk randomly around the scene
    and enabled him to move by using a NavMesh, but then we directed his wanderings
    using a 3D cursor on the x, z ground plane. This cursor follows our gaze as we
    look around the scene in virtual reality. Lastly, we also used our gaze to shoot
    a ray at Ethan, causing him to lose health and eventually explode.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了VR相机与场景中物体之间的关系。我们首先让Ethan（僵尸）在场景中随机行走，并使用NavMesh使他能够移动，但随后我们通过在x、z地面平面上使用3D光标来引导他的漫步。这个光标随着我们在虚拟现实中环顾四周而跟随我们的视线。最后，我们还使用我们的视线向Ethan发射一束光线，导致他失去健康并最终爆炸。
- en: These look-based techniques can be used in non-VR games, but in VR, it's very
    common and almost essential. We'll be using them more in the later chapters of this
    book too.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于外观的技术可以用于非VR游戏，但在VR中，它们非常常见，几乎是必需的。我们也会在本书的后续章节中更多地使用它们。
- en: In the next chapter, we will use our hands to interact with the virtual scene.
    We will learn about Unity Input events, as well as input systems for SteamVR,
    Oculus, and Windows Mixed Reality, to name a few. As this can get complicated,
    we'll write our own VR input event system to keep our application independent
    of the specific VR devices.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用我们的手与虚拟场景进行交互。我们将学习Unity输入事件，以及SteamVR、Oculus和Windows Mixed Reality等输入系统。由于这可能会变得复杂，我们将编写我们自己的VR输入事件系统，以保持我们的应用程序独立于特定的VR设备。
