- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crafting Web APIs for Service Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As part of ASP.NET Core 9, web APIs can be used to build HTTP services, which
    can be made available for both web page consumption and mobile applications. The
    structure provided by the .NET Core platform enables the development of APIs with
    high quality and performance. In this chapter, we will learn more about web APIs
    and the standards, conventions, and best practices for delivering solutions using
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Delivering business as a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing APIs using the controller-based approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the Postman tool, which will be used as a client for consuming
    APIs. This tool will also be used in other chapters of the book and its installation
    and use are free.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Postman on your operating system through the following link:
    [https://www.postman.com/downloads/](https://www.postman.com/downloads/) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Delivering business as a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have learned in the last chapters, ASP.NET Core 9 offers different frameworks
    for the development of rich web-based applications. Regardless of the chosen model,
    whether client-side or server-side, we must implement negotiation flows that are
    responsible for the operation of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a system for a digital bank where users can perform different types
    of operations in their checking account, such as transfers, analyzing extracts,
    checking the account balance, and even purchasing a new service package. Each
    of these operations has business requirements and rules. For example, it should
    not be possible to transfer 200 euros if the user’s account balance is 100 euros.
  prefs: []
  type: TYPE_NORMAL
- en: This negotiation flow can be implemented perfectly using Razor Pages, MVC, or
    a hybrid model, as we have learned. We can easily have a web-based application
    being performed on a server.
  prefs: []
  type: TYPE_NORMAL
- en: However, imagine that users have requested a mobile application. It should offer
    the same features as the web version.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, any technologies could be used for this purpose, either for native
    or hybrid development. But how would the business logic of the application be
    developed? What if there was a change to an application rule? Would it be necessary
    to update two distinct types of code to make the applications run correctly?
  prefs: []
  type: TYPE_NORMAL
- en: The best practice, in this case, is to centrally manage all the code that concerns
    the business rules. This would allow different types of application interfaces,
    whether browsers, mobile applications, or even other applications, to interact
    with a business context.
  prefs: []
  type: TYPE_NORMAL
- en: This centralized application is made available in web API format, which is actually
    an application that is distributed through the internet. The **Representational
    State Transfer** ( **REST** ) protocol, which is based on the HTTP protocol commonly
    used in web application interactions, allows clients (browsers, mobile apps, and
    other applications) to consume resources independently in a controlled and centralized
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The model for providing business contexts over the internet is called **business
    as a service** ( **BaaS** ), allowing organizations to offer specific features
    or resources such as services that can be consumed by other companies or applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – BaaS](img/B21788_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – BaaS
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ASP.NET Core 9 offers us a powerful model for creating web APIs;
    however, we must understand some foundations before learning how to create BaaS
    resources. In the rest of this section, we look at some of the important foundational
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs and conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Communication with an API is done through the **HTTP** protocol, which has some
    operations called **HTTP verbs** .
  prefs: []
  type: TYPE_NORMAL
- en: 'These verbs determine the type of intention in a given resource. The most common
    HTTP verbs are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET** : This method is used to request data in a feature, such as a read-only
    operation; when we type a URL in the browser, as a response, we receive an HTML
    page. GET can also be used to determine the intention to obtain a list of registered
    users, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST** : When you send a POST request, you are usually creating a new feature
    on the server. This method includes data in the body of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT** : PUT requests are used to update a feature. In this case, any changes
    made to a resource’s attributes must be sent in the request body, and the server
    replaces the resource with the sent data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE** : DELETE requests are used to request the removal of a specified
    feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PATCH** : PATCH requests are used to apply partial modifications to a feature.
    Unlike the PUT verb, which replaces the entire feature, PATCH updates only the
    specified parts of the feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HEAD** : This is often used to verify the availability and metadata of a
    feature without downloading its content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPTIONS** : An OPTION requirement is used to describe communication options
    for the destination feature. It can be used to consult the server about the supported
    methods and other information about the feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verbs are very important to determine which type of operation will be performed
    by an API. As we can see from the preceding list, there are some verbs that are
    similar to each other, such as POST and PUT. Both can be used to create and update
    resources. However, using the right verb means the integration process can always
    be easily understood. There is no strict rule for the use of certain verbs, but
    it is a good practice to use the right ones.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST is an architectural style, a set of constraints and principles that encourage
    stateless, scalable, and easily maintainable web service design.
  prefs: []
  type: TYPE_NORMAL
- en: One of the characteristics of REST services is stateless communication, where
    each request from a client to a server must contain all the information necessary
    to understand and process the request. The server must not store any information
    about the client’s state between requests. This ensures that requests can be handled
    independently, making the system scalable and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: There is also the concept of resources, be it a physical object, a conceptual
    entity, or a piece of data. Each resource is identified by a unique URL.
  prefs: []
  type: TYPE_NORMAL
- en: REST services use standard HTTP methods to perform **Create** , **Read** , **Update**
    , **Delete** ( **CRUD** ) operations on resources. Each HTTP method corresponds
    to a specific action on the resource. For example, GET is used to retrieve data,
    POST to create a new resource, PUT to update a resource, and DELETE to remove
    a resource. This approach provides a uniform and consistent interface for interacting
    with resources. This means that the same HTTP verbs and methods are used consistently
    across different resources.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP codes are important and enable easy integrations and use of APIs. HTTP
    status codes, in the same way, make API responses standardized and allow applications
    to handle different scenarios appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP status codes indicate the result of an HTTP request and help clients understand
    the result of their actions. These status codes are essential for effective communication
    between clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP status codes are grouped into five classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Information responses (100-199)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Successful responses (200-299)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection responses (300-399)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client error responses (400-499)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server error responses (500-599)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP status code references
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about status codes here: [https://httpwg.org/specs/rfc9110.html#overview.of.status.codes](https://httpwg.org/specs/rfc9110.html#overview.of.status.codes)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Each status code has a return type that can be used by the client application
    or even the browser. When making an HTTP request, the response has a header, where
    the HTTP status code is located, and there may even be a body providing further
    details about the request response.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the main HTTP status codes used are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 OK** : Indicates a successful request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**201 Created** : Indicates that a resource was created successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400 Bad Request** : Indicates an error in the client request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 Unauthorized** : Indicates that the client does not have proper authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found** : Indicates that the requested resource does not exist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500 Internal Server Error** : Indicates a server-side problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code represents an example of a successful response to an API
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the status code (in the first line of code) is **200** , indicating
    that the request was successful. Furthermore, there is a body in the response
    containing more information.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP status codes appropriately allows APIs to be easily integrated into
    different types of systems. As we create our APIs using them, this will become
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: BaaS delivery offers several benefits for teams to segregate the responsibilities
    of each context into applications that can be easily integrated into different
    scenarios. We’ve learned enough about the fundamentals of APIs; it’s time to start
    creating APIs using the ASP.NET Core 9 minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring minimal APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways to create web services in ASP.NET Core 9 is to use the minimal
    APIs approach, which offers a simple way to make APIs available and add features
    and configurations as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The simple structure of minimal APIs allows developers and teams to provide
    REST-based functionalities in an agile manner.
  prefs: []
  type: TYPE_NORMAL
- en: There are many applicable scenarios for using this approach, and the one you
    choose will depend on the size of the project and the teams involved. The fact
    is that minimal APIs offer, in general, the same functionalities as the controller-based
    model, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a minimal API project, we will base ourselves on a product management
    model. To do this, we will provide an API according to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Route** | **Description** | **Request Body** | **Response Body** |'
  prefs: []
  type: TYPE_TB
- en: '| GET /Product | Get all products | None | Array of products |'
  prefs: []
  type: TYPE_TB
- en: '| GET /Product/{id} | Get a product by ID | None | A product object |'
  prefs: []
  type: TYPE_TB
- en: '| POST /Product | Add a new product | Product object | A product object |'
  prefs: []
  type: TYPE_TB
- en: '| PUT /Product/{id} | Update an existing product | Product Item | None |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE /Product/{id} | Delete an existing product by ID | None | None |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 - Product management actions
  prefs: []
  type: TYPE_NORMAL
- en: The Table 3.1 basically maps the routes that will be used in the product API,
    mapping the corresponding HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see in the table that some routes are similar, differing only by
    the HTTP verbs used. This is a convention used by the REST model, where HTTP verbs
    indicate the intention for a given resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the resource is the product, defined by the **/Product** route.
    In some cases, the **/Product/{id}** route indicates that there will be a parameter
    added to the resource route. This parameter will be part of the resource URL and
    will be mapped as a parameter of the method to be executed in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a minimal API project and implement product registration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your operating system’s command prompt, in a directory of your choice,
    and run the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The web project template is a shortcut for creating an empty ASP.NET Core project,
    which will be used as the minimal API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A folder called **ProductAPI** will be created containing all the files needed
    for the project. The main file is **Program.cs** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to the **ProductAPI** directory and then type the following command
    and press *Enter* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Visual Studio Code editor will appear.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, open the **Program.cs** file, which will have the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, there is no definition of a class. This is the main application
    file, the entry point that will be used to execute the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first two lines of the file, we have the app definition, through the
    **web application** builder class. This definition was presented in [*Chapter
    2*](B21788_02.xhtml#_idTextAnchor031) , where we discussed the structure of a
    project in ASP.NET Core 9. However, it is important to note that the app will
    be created with some basic configurations, abstracted by the framework, such as
    filters and settings, among other aspects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another important aspect of this file is the **MapGet** method of the **app**
    variable. This is a method that extends the previously created app, allowing the
    creation of a route that will be accessed via URL using the HTTP GET verb.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method has a parameter that defines the route pattern; in this case, **/**
    is used, which means the root of the application. The second parameter is an action,
    which uses one of C#’s features. This action will be executed when this route
    is requested.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Actions and methods
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions can be seen as methods defined inline and are composed of two main
    parts, just like methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**- Setting parameters** : Setting parameters if necessary'
  prefs: []
  type: TYPE_NORMAL
- en: '**- Action body** : The code that will be executed'
  prefs: []
  type: TYPE_NORMAL
- en: Actions can be replaced by methods, instead of being defined inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a test, just run the application by typing the following command
    at the prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Logs containing the API URL will be displayed. Now, open **Postman** , select
    **File** | **New Tab** , enter the application address, and then click **Send**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Getting an API resource using a minimal API](img/B21788_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Getting an API resource using a minimal API
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, in just a few lines of code, it was possible to execute an API,
    even returning a simple **Hello** **World** string.
  prefs: []
  type: TYPE_NORMAL
- en: The minimal API offers the ability to quickly make APIs available in a simple
    way and allow other features and configurations to be added according to a project’s
    needs. This brings great agility to teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some features to the **ProductAPI** project. To do this, create a
    class called **Product.cs** in the root of the project. The class will be defined
    according to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are just defining an object that will represent a product. Now you will need
    to change the **Program.cs** file; we will include the methods listed in the preceding
    table, mapping the API routes and adding functionality to the API methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Program.cs** file will contain some methods as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the APIs were created similarly to the previously defined route
    table, respecting the HTTP verbs defined through the **MapGet** , **MapPost**
    , **MapPut** , and **MapDelete** methods.
  prefs: []
  type: TYPE_NORMAL
- en: The code in question is very simple, creating a simulation of a product register.
    To do this, a variable was defined using the code **List<Product> products = new
    List<Product>()** , which will contain the products available in the API at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Another important functionality described in the preceding code is the use of
    the utility class called **Results** . This class is used in all methods, encapsulating
    important functionalities for returning the request, such as defining the status
    code related to the request in the response header.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the API for the POST verb in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The **MapPost** method defines the **/Products** string as a route and as an
    action; it expects a product as a parameter, adds it to the list, and returns
    **OK** (status code 200).
  prefs: []
  type: TYPE_NORMAL
- en: But how do we submit a product to the API? ASP.NET Core 9 has the concept of
    a **bind** , which processes the request and creates and maps an object according
    to the request’s needs. In this case, an object in JSON format must be sent, which
    will be mapped to a product object when the POST method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent feature of ASP.NET Core 9, which abstracts all the complexity
    and, during the execution of a route, resolves the parameters expected by the
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a product using the API with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then open Postman and go to **File** | **New Tab** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the method to **POST** and add the API address with the **/** **Product**
    suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then select the **Body** tab, as shown in *Figure 3* *.3* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Configuring a POST request](img/B21788_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Configuring a POST request
  prefs: []
  type: TYPE_NORMAL
- en: Select the **raw** option and then set the type to **JSON** , as shown in *Figure
    3* *.4* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Defining the request body](img/B21788_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Defining the request body
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code just represents a JSON object that has the properties of
    a product. These properties were defined in the **Product.cs** class that was
    added to the project. You can see the full code through the book’s source code
    link, provided in the *Technical* *requirements* section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – POST request result](img/B21788_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – POST request result
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the registered product object was returned. Note the HTTP status
    code highlighted in *Figure 3* *.5* , with the value **200** and the description
    **OK** .
  prefs: []
  type: TYPE_NORMAL
- en: When executing a POST call to the API, ASP.NET Core identified a route mapped
    to the HTTP verb. Then, it binds the JSON object, sent as the request body, to
    the product object, defined as the POST request parameter. After that, the action
    request is made, which finally registers a product in the memory list and returns
    it, again serialized in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned, it is very simple to create an API using a minimal API. With
    just a few lines of code, it was possible to create a complete product register.
    Of course, as it is a .NET platform project, it is possible to define different
    classes to better structure your projects, since as the complexity increases,
    along with the number of APIs, it will become very difficult to manage all the
    routes in just one file.
  prefs: []
  type: TYPE_NORMAL
- en: However, even though a minimal API supports most ASP.NET Core 9 functionality
    for creating web APIs, using a more structured and prepared approach for large
    projects can be a great option, and this is the case for controller-based projects,
    which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing APIs using the controller-based approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controller-based projects are another way to deliver APIs using ASP.NET Core
    9. This project type also implements the **Model-View-Controller** ( **MVC** )
    pattern, which we learned about in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The controller-based approach has a more complete and robust structure to deliver
    any type of API, so it supports different business contexts. In the same way as
    minimal APIs, it is possible to extend API functionalities by adding different
    types of configurations and customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a controller-based API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a controller-based API, you just need to type the following code
    in the terminal, in a directory of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the **webapi** template, which by default creates a minimal
    API project. In this case, we are adding a **-controllers** argument to state
    that a web API should be created using the controller-based approach.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 3* *.6* , the structure of the controller-based API
    project is very similar to MVC, which we learned about in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Controller-based project structure](img/B21788_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Controller-based project structure
  prefs: []
  type: TYPE_NORMAL
- en: The difference between this project and minimal APIs is the segregation of responsibilities
    and organization of the project. Since each controller is related to a specific
    resource, there is no need to implement all the API code in the **Program.cs**
    file, in addition to bringing greater possibilities, especially in larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: However, the approach to configurations and extensions is similar to what we
    learned about in regard to minimal APIs; it is all done through the **Program.cs**
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default project has some settings already defined, which can be easily
    modified. The following code is from the **Program.cs** file, which is created
    automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we will focus on two main configurations added in the file,
    which concern the **AddEndpointsApiExplorer** and **MapControllers** methods.
    The rest of the methods will be discussed later:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddEndpointsApiExplorer** : This is an extension method that aims to register
    services that are used to expose information about the application’s endpoints.
    This information is used by API documentation generation services, such as **Swagger**
    , which we will discuss in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MapControllers** : This is an application configuration responsible for mapping
    added attributes into controller classes and, therefore, automatically defining
    APIs and routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods allow the application to adapt more easily to the need to expose
    services as APIs and enable the implementation of good practices, making any additions
    and modifications more dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Using the same example of a product service previously created in the minimal
    API approach, let’s understand this implementation adapted for the controller
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the product controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of the product API using the controller-based approach follows
    the class definition model. Therefore, each API must have a controller, which
    will be responsible for processing requests for each resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the previous example, the product API will have the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Some code blocks have been omitted to make it easier to read and understand
    the most important points in this class definition.
  prefs: []
  type: TYPE_NORMAL
- en: The class represents a controller that will handle requests to the product API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze some details of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ApiController** : This is an attribute that is added to a class, causing
    it to be mapped as an API controller. This way, when adding the **MapController**
    configuration to the **Program.cs** file, all classes marked as attributes will
    be responsible for processing requests from the respective APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route** : This attribute can be used either in a controller, represented
    by a class, or in an action, represented by a method. Its function is to define
    a URL pattern for the route. The **[controller]** parameter is a token that is
    automatically replaced, at runtime, by the class name, without the **controller**
    suffix. For the route to take the method name into account, in the case of annotating
    an action with the route attribute, the **[action]** token must be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProductController** : This is the name of the class following the MVC convention.
    There is no obligation to use this suffix, but it is a good practice, as controllers
    do not need to be in the **Controllers** folder, making it easier for other members
    of a development team to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ControllerBase** : All controller classes should inherit from the **ControllerBase**
    class, which is appropriate for APIs. This class provides many properties and
    methods that are useful for handling HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HttpGet** : This attribute determines the HTTP verb that an action should
    respond to processing. For each verb, there is a different attribute. In the preceding
    example, there are two GET methods, but one is an overload, with one parameter.
    For the controller to know which GET method should be requested, a different route
    must be defined for methods with the same name. In this case, the second GET method
    has an **{id}** parameter, which will be included in the route, differentiating
    the actions. The ASP.NET Core 9 framework will take care of binding the method’s
    **id** parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, a big difference in relation to the innovative approach of the
    minimal API is the ability to segregate responsibility into different controllers.
    Furthermore, the controller-based approach brings other features that are important
    in large projects, such as various types of utilities, both through the framework
    and other resources available in **ControllerBase** , such as bind resources and
    model validations.
  prefs: []
  type: TYPE_NORMAL
- en: ControllerBase utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, the **ControllerBase** class has several properties
    and methods that are useful for handling HTTP requests, making the APIs capable
    of handling requests using REST API best practices and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: The standard for communication between applications through HTTP is extensive,
    and a book entirely dedicated to this subject would be needed in order to cover
    it properly. However, let’s address some patterns used in the **ProductController**
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned at the beginning of the chapter, requests in APIs are made to
    a specific resource, and for each request, there is an intention associated with
    a verb. Each request has a set of information that is sent to the API, such as
    a body and headers. Likewise, after being processed, this request returns headers
    and, in addition, may contain a body. An HTTP status code is also defined in the
    response.
  prefs: []
  type: TYPE_NORMAL
- en: This entire pattern is abstracted by the methods available in **ControllerBase**
    , which takes care of the return definitions for each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the GET method for retrieving a product by **id** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this method is to return a product according to the ID, passed
    as a parameter to the method. This API could be used, for example, in a frontend,
    where the user clicks on a product link to see its details. Since the API consumer
    does not have access to the implementation details, the API needs to be consistent
    in returning appropriate responses.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the preceding method, if the product is not found, a **NotFound**
    response is returned, using the HTTP status code 404. This is the same approach
    as when trying to access a non-existent URL through the browser, which generally
    displays a 404 message, stating that a resource was not found.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the product is found, an **Ok** response is returned,
    using the HTTP status code 200. Note that the **Ok** method has one parameter,
    which is exactly the product found. In this case, this object will be serialized
    in JSON format and returned to the client. The **Ok** method is responsible for
    serializing the object and creating the response taking into account the body,
    the serialized product object, and the headers, including stating that **Content-Type**
    is **application/json** . This way, the client can process the message return
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The **ControllerBase** class has several other methods that abstract the complexity
    of interacting with the HTTP protocol in addition to implementing REST standards
    and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that APIs serve different types of clients, whether
    they are web-ready frontends, operating systems, or mobile applications, and they
    even allow integration between systems. Each of these consumers does not have
    any details about the API implementations, having access only to the signatures
    of the required methods and parameters, as well as the possible returns.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is necessary to use standards and conventions correctly, making
    the API consistent and interoperable between consumers.
  prefs: []
  type: TYPE_NORMAL
- en: More details
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know more about the **ControllerBase** class, see the documentation
    at the following link: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core 9 abstracts most of the complexity involved in this service
    delivery model by using APIs, in addition to providing other types of functionality
    such as a consistent validation model and object binding.
  prefs: []
  type: TYPE_NORMAL
- en: Working with binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Binds are important features available in ASP.NET Core. Their main function
    is to translate or adapt the API request model to the actions that are performed
    in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: As we observed in our examples of the **ProductController** call, the methods
    receive as parameters these primitive types, such as **int** , or even complex
    types, such as objects of type **product** .
  prefs: []
  type: TYPE_NORMAL
- en: Each method or action has a signature or interface, which describes the attributes
    required, if any, for the method or action to be processed. When you make a request
    for action and enter the attributes according to the action signature, these will
    be mapped by the ASP.NET Core pipeline execution flow, which will bind the information
    for each attribute entered, taking into account its type, attribute name, and
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **product** object has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This object represented in JSON format would be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the objects are identical but represented differently. ASP.NET
    Core does the work of transforming the JSON **product** object into a C# **product**
    object, mapping the properties according to the name.
  prefs: []
  type: TYPE_NORMAL
- en: This is a standard behavior of the framework, but there is the possibility of
    customizing and even binding different aspects of a request.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, a request has a body, URL, query string parameters, and also parameters
    that are sent through forms. A request has an abstraction in a C# object called
    **HttpRequest** . You can easily access all the properties of a request through
    the **Request** property of the previously mentioned **ControllerBase** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is necessary, for example, to obtain a value in a query string, the following
    code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this same value could be obtained from the query string, using the
    bind model provided by the **FromQuery** attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, **isCompleted** was annotated with the
    **FromQuery** attribute. This way, ASP.NET will be responsible for binding the
    query string to the action parameter. In this case, it is expected that the query
    string has the same name as the method parameter. But if this is not the case,
    just use an attribute overload and define the parameter name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other types of attributes that can be used to perform binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **HTTP verb** | **When** **to use** | **Data format** | **Example**
    **of use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **FromBody** | POST, PUT, PATH | Use to bind parameter data from the request
    body. It can only be used once per action method, as it assumes the entire request
    body is used to bind to the action’s parameter. | JSON, XML | **[** **HttpPost]****public
    IActionResult Create([FromBody] Product product) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: '| **FromForm** | POST | Use to bind parameter data from form fields. | Form
    data ( key-value pairs) | **[** **HttpPost]****public IActionResult Update([FromForm]
    ProductUpdateDto dto) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: '| **FromService** | Any | Use to inject services directly into action methods.
    This is useful for obtaining services without using constructor injection. | Depends
    on the service being injected | **public IActionResult Get([FromServices] IProductService
    productService) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: '| **FromHeader** | Any | Use when you need to retrieve data from HTTP headers.
    Useful for tokens or API versioning. | Simple string or comma-separated values
    in a single header | **public IActionResult Get([FromHeader(Name = "X-Custom-Header")]
    string value) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: '| **FromQuery** | GET | Use to bind parameters from the query string of the
    URL. Ideal for filtering or pagination parameters in a RESTful API. | Simple types
    such as strings, integers, or custom string-convertible types | **public IActionResult
    Search([FromQuery] string keyword) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: '| **FromRoute** | Any | Use when parameter values are embedded in the URL path.
    Typically used with REST URLs that include resource IDs. | Simple types compatible
    with URL segments | **[HttpGet("{id}")] public IActionResult GetById([FromRoute]
    int id) { ... }** |'
  prefs: []
  type: TYPE_TB
- en: Each of these parameters can be used as a means of customizing the bind model
    in each action of a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Custom binds
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the default bind model available in ASP.NET Core may be limited
    in relation to the needs of an application, which can often have other, more complex
    types. With this, it is possible to implement customized binds. This implementation
    is outside the scope of this book, but you can learn more here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The binds model available in ASP.NET Core abstracts much of the implementation
    complexity by taking care of filling in the values that each action requires.
    However, there is no guarantee that the parameters were filled in correctly in
    accordance with the application’s business rules. To do this, you need to perform
    validations, and ASP.NET Core offers a powerful validation model.
  prefs: []
  type: TYPE_NORMAL
- en: Performing validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to creating robust APIs, model validation is one of the fundamental
    pillars. ASP.NET Core 9 makes this process easier and more powerful than ever,
    thanks to **ModelState** . Think of it as a border guard that checks and validates
    data before it enters the core of your application.
  prefs: []
  type: TYPE_NORMAL
- en: '**ModelState** is a framework in ASP.NET Core that acts to verify that data
    complies with the rules defined in your models. If a piece of data does not meet
    the validation criteria, **ModelState** marks it as invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the product registration API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, there is a condition that evaluates the **ModelState.IsValid**
    property. If false, then an HTTP status code of 400 (for a bad request) is returned,
    containing a body that will represent the **ModelState** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**ModelState** is actually a dictionary, which, when serialized in JSON format,
    is represented by an object. Each object property represents a validated property.
    The value of each object property is represented by an array of strings that contains
    the validation results.'
  prefs: []
  type: TYPE_NORMAL
- en: In order for **ModelState** to consider the model valid or not, it is necessary
    to annotate the properties of the objects with validation attributes; otherwise,
    the validations will be disregarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The product class was changed by adding validation to the **Name** attribute,
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the **Name** property is considered mandatory and, in addition,
    must have at least three characters. This way, it is possible to combine validation
    attributes in the same property, and this is managed by **ModelState** through
    the execution flow of an action, provided by ASP.NET Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validations are part of an API, whether through attributes added to models
    or even manually, in the body of an action, using the **ModelState.AddModelError**
    method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Other attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core also offers several other attributes that can be used as model
    validation: [https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, ASP.NET Core 9 provides a great feature for managing the states
    of models used by APIs, with parameters or even objects, allowing us to have the
    ability to carry out validations in a rich way on the application’s endpoints,
    in addition to giving us a simple way to maintain the integrity of information.
  prefs: []
  type: TYPE_NORMAL
- en: These features become even more powerful with the use of approaches such as
    documentation, response formatting, and error management. Therefore, in the next
    section, we will see how to make APIs even more consistent for consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are a powerful resource for delivering an application’s business model
    through services, and for an API project to be made available properly, it is
    important to add features that standardize the interaction model with customers.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, every API must be documented, allowing customers to know which
    resources are available and how this documentation is done.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s learn how we can benefit from API feature documentation automatically
    using Swagger’s NuGet package, which implements the OpenAPI specification.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting APIs with Swagger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APIs are consumed by clients and other applications through the HTTP protocol,
    where there is a request and a response. For this communication to happen, it
    is necessary to have knowledge about what is provided by the API, in this case,
    which methods are available and which contracts are used to establish connections.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we have to establish a source of knowledge about the resources made
    available by APIs, such as methods, HTTP verbs, parameters, and bodies. To achieve
    this objective, it is necessary to have documentation.
  prefs: []
  type: TYPE_NORMAL
- en: However, this documentation needs to be dynamic, since, especially during the
    development process, APIs can constantly change, adding functionalities or new
    features. It would be laborious to make changes to each bit of documentation and
    send it to all API consumers.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 9 still supports Swagger for providing API documentation. However,
    Swagger is no longer part of the project template by default as it was in previous
    releases. New projects can now support OpenAPI document generation in controller-based
    and minimal API applications. The OpenAI specification provides a programming
    language-agnostic approach to API documentation. As such, ASP.NET Core 9 provides
    built-in support for generating endpoint information in an application through
    the **Microsoft.AspNetCore.OpenAI** package, avoiding dependencies on external
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in order to have documentation, as well as an experience of using
    a UI to test the APIs, we will integrate the API project with Swagger, which is
    easy-to-use suite of API developer tools, in addition to implementing the OpenAPI
    specification standards.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI Specification
  prefs: []
  type: TYPE_NORMAL
- en: The OpenAPI Specification is part of the Linux Foundation and aims to specify
    RESTFul interfaces to provide ease in the development and consumption of APIs.
    You can learn more about OpenAPI at [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about ASP.NET Core 9 OpenAPI, visit the following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When integrating it into your API solution, Swagger acts as a specification
    generator in the OpenAPI format, which is based on a JSON file, where all the
    APIs available in your application are described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON describes the resources available for an API, the response
    schema, and the available verbs, in addition to the prediction of objects used
    in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To integrate Swagger into a project, we must add the Nuget package by running
    the following command on the command line, in the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must change the Program.cs file. We will perform this configuration
    for the Product MVC project, and you can analyze the changed code, adding Swagger,
    in the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Line 4 adds the Swagger generation services through the **builder.Services.AddSwaggerGen()**
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between lines 6 and 10, we have the addition of Swagger to the ASP.NET execution
    pipeline, through the **app.UseSwagger()** method, and also the provision of the
    UI through the **app.UseSwaggerUI()** method. These methods are only executed
    if the application is running in development mode, **if (app.Environment.IsDevelopment)**
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When running the application, simply access the API link with the swagger suffix,
    as shown in *Figure 3* *.7* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Swagger UI for the Product MVC API](img/B21788_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Swagger UI for the Product MVC API
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *Figure 3* *.7* , we can see that the methods available in the product
    API were listed in the UI, in addition to the specification of the objects worked
    on the API. No changes were required to the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger identifies the controllers and actions available in the source code,
    generates the specification, and consequently generates the UI. However, more
    details can be added to the documentation in order to enrich the API usage model.
    Let’s take a closer look at how to improve documentation using the features available
    in the Swagger package.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we learned previously, Swagger is added by default in ASP.NET Core 9 API
    projects and automatically generates a UI containing a minimum version of the
    usage details of the API, inferring the data by reading the controllers and actions.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 3* *.8* , to add a product, it is necessary to provide
    JSON as the body of the request; in addition, we have a description of the response,
    containing the HTTP status code 200, which represents the success.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Documentation details for an API](img/B21788_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Documentation details for an API
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we look at the POST method code (made available through the **ProductController**
    class available in the book repository mentioned in the *Technical requirements*
    section), which registers a product, there is no explicit definition of the HTTP
    status code 200:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The method returns two possible HTTP status codes, which are 400, represented
    by calling the **BadRequest** method, and 201, which is represented by the **CreatedAtAction**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 3* *.8* , there is a button labeled **Try it out**
    . Upon clicking this button, the UI will be prepared so that it is possible to
    add the request body, which in this case will be some JSON that represents a product
    and its respective properties. Modify the JSON to add a new product, defining
    the properties as in the example proposed in *Figure 3* *.9* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Running an API request from the Swagger UI](img/B21788_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Running an API request from the Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: After defining the body of the request, click the **Execute** button. Just make
    sure your application is running.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the execution, the Swagger UI displays the API response, and as
    we can clearly see in *Figure 3* *.10* , we have an HTTP status code of 201, in
    addition to the JSON of the newly registered product and some information in the
    header.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Swagger API Response screen](img/B21788_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Swagger API Response screen
  prefs: []
  type: TYPE_NORMAL
- en: The **CreatedAtAction** method creates a response with HTTP status code 201
    and adds a link to the header to access the resource created using the GET method,
    as highlighted in the preceding figure using the address **http://localhost:5037/Product/1**
    . This address may vary depending on the execution address in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: This type of return is good practice and follows the standards defined in the
    REST protocol. However, although it is not a major problem in the context in which
    we are presenting the examples, API consumers must be clear about how to consume
    and what to expect in return to properly deal with each response. In the case
    of the product registration method, there being no information means that this
    method would also return an error status, which could cause some non-compliance
    for the API consumer.
  prefs: []
  type: TYPE_NORMAL
- en: To adjust this behavior, we must add more information to the API methods using
    attributes provided by ASP.NET Core 9 such as **ProducesResponseType** and **Consumes**
    .
  prefs: []
  type: TYPE_NORMAL
- en: The **ProducesResponseType** attribute is used to determine the type of HTTP
    status code that will be returned as a response and also the type of content that
    will be returned. This attribute can also be used in the generic version, typing
    the return.
  prefs: []
  type: TYPE_NORMAL
- en: The **Consumes** attribute determines the type of content expected by the API.
    The content is defined as a media type and the complete list can be obtained through
    the **MediaTypeNames** class available in the **System.Net.Mime** namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the new implementation of the POST method with the addition of
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the **ProducesResponseType** attribute
    can be added as many times as necessary to represent different return types. In
    this example, the HTTP status code 201 is being reported, for created items, and
    one type of return with the HTTP status code 400.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the application again, we can observe the changes made to the
    code and automatically generated in the Swagger UI, according to *Figure 3* *.11*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – API response documentation](img/B21788_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – API response documentation
  prefs: []
  type: TYPE_NORMAL
- en: We now have the correct documentation on the aspects involved in the product
    controller’s POST method, which enables the API to be consumed appropriately by
    taking into account alternative response flows.
  prefs: []
  type: TYPE_NORMAL
- en: XML comments
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the attributes added to the API methods, it is also possible
    to use XML comments for each method as part of the Swagger UI documentation. To
    do this, it will be necessary to configure the project so that the documentation
    XML is generated during the compilation process and is obtained from the Swagger
    UI. You can find a complete explanation of this configuration at the following
    address: [https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments](https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to having the ability to create quality APIs with ASP.NET Core 9,
    we also have the support of a rich API documentation interface, in addition to
    the option to execute requests and get more details about the request parameters
    and response.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding this documentation approach will greatly help you to generate
    quality services that can be integrated into different systems and contexts. As
    we progress through the next few chapters, we will further study the use of APIs,
    documentation, and other technologies such as database connections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deep into the world of HTTP-delivered APIs, discovering
    the power they have to provide services to a variety of clients. With the robust
    support of ASP.NET Core, we learned how to make the most of this potential, learning
    about approaches such as using minimal APIs to create HTTP APIs quickly and efficiently.
    We also explored the creation of robust APIs using controller-based projects.
    We looked at other aspects that involve APIs, such as documentation. In the next
    chapter, we will continue to explore the characteristics of ASP.NET Core 9, understanding
    how to develop real-time applications using SignalR.
  prefs: []
  type: TYPE_NORMAL
