<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Performing Symmetric and Asymmetric Encryption</h1>
                </header>
            
            <article>
                
<p class="mce-root">While working on distributed applications, it is very important to keep information secure, in particular, in the case of eCommerce applications, where user data, such as your personal and credit card-related information, is collected and transmitted over the internet. Cryptography enables us to encrypt and decrypt plain text. To understand it in simple terms, let's suppose that there is plain text in our application that can be transformed by adding a static value to each character in the text, thereby rendering it non-readable. This process is called <strong>encryption</strong>. Conversely, decryption is the process of transforming this unreadable text back into readable text. </p>
<p>When you encrypt text, it looks like random bytes, and is called <strong>cipher-text</strong>. </p>
<p>After reading this chapter, you will be able to understand how to encrypt and decrypt text, the different algorithms that are available to perform these encrypt and decrypt operations, and the options that .NET Framework affords us in terms of their application to actual projects.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Cryptography</li>
<li>Symmetric encryption</li>
<li>Asymmetric encryption</li>
<li>Digital signatures</li>
<li>Hash values</li>
</ul>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The exercises in this chapter can be practiced using Visual Studio 2012 or above with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and above require Visual Studio 2017.</p>
<p>If you don't have a license for any of the products, you can download the community version of Visual Studio 2017 from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>Sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter12</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cryptography</h1>
                </header>
            
            <article>
                
<p>When working with public networks involved with creating and managing web applications that are accessible over the internet, your application is at high risk of being intercepted and modified by unauthorized parties. Cryptography allows us to protect data from such unauthorized parties from being viewed or modified. Cryptography also provides ways to protect our data and assists in the transfer of data securely over the network. To perform such operations, we can use encryption algorithms to create cipher data prior to transmission. When intercepted by unauthorized parties, it will be difficult for them to decrypt this in order to read or modify this data.</p>
<p>To perform such operations, .NET framework is shipped with the <kbd>System.Secure.Cryptography</kbd> namespace, which comes with many algorithms, including the following:</p>
<ul>
<li>Secret key encryption</li>
<li>Public key encryption</li>
<li>Digital signatures</li>
<li>Hash values</li>
</ul>
<p>Let's jump into an example regarding where cryptography can be used. Suppose, as a customer, that I am trying to place an order for a laptop over the internet. For this, I am chatting with the company's representative. Once I am sufficiently satisfied with the quote, the discount offered, and the terms and conditions to place an order, I then need to provide personal and credit card information via this channel. </p>
<p class="mce-root"/>
<p>So, how can we ensure the following in this regard?</p>
<ul>
<li>That this information is unclear for anyone listening in on our conversation</li>
<li>That there was no unauthorized access to the information transferred</li>
<li>That the information received is from the company's representative</li>
</ul>
<p>All of this can be achieved with the implementation of cryptographic algorithms. These algorithms facilitate confidentiality, data integrity, authentication, and non-repudiation.</p>
<p>Confidentiality protects the identity of users, data integrity protects data from being changed, authentication ensures that data is from an authenticated party, and non-repudiation prevents any party from denying that a message was sent.</p>
<p>.NET Framework provides different algorithms, as mentioned earlier. Although these are numerous, we will limit our discussion to four major ones in this chapter. </p>
<p>Secret-key encryption, which is also referred to as symmetric encryption, uses a single shared key to encrypt and decrypt data. In this regard, however, it is important to keep the secret information safe from unauthorized access because anyone in possession of this key can then access the data and misuse it. Because it uses the same key for both encryption and decryption, this works faster and is suitable for large amounts of data. There are different types of algorithm available, such as <strong>DES</strong> (short for <strong>Data Encryption Standard</strong>), triple DES, and <strong>AES</strong> (short for <strong>Advanced Encryption Standard</strong>). These algorithms encrypt blocks of data simultaneously, so they are also referred to as block ciphers. DES and Triple DES use 8 bytes as a block, while AES uses 16 bytes as a block, but also supports 24 and 32 bytes.</p>
<p>Public-key encryption, also referred to as asymmetric encryption, uses public/private keys to encrypt and decrypt data. Of these two keys, the private key must be kept secret from unauthorized access, as anyone with the private key can access your data. Public and private keys in this encryption technique are mathematically linked and use a fixed buffer size. These are slow compared to secret key encryption, and are useful for encrypting small amounts of data. Any data encrypted using a public key can only be decrypted using a private key. Also, if you sign data using a private key, it can only be verified using a public key.</p>
<p>Digital signing uses digital signatures that are unique to that party. As mentioned in public key encryption, a party can sign the data using a private key and, when the other party receives information and when the public key of the sending party is trusted, you can identify who sent the message and, in turn, maintain the integrity of the data.</p>
<p>Since the public key of the sending party is public, anyone in possession of the public key can process the message, meaning that your message is not secret. To keep it secret, you also need to encrypt the message.</p>
<p class="mce-root"/>
<p>Hash values map data of any length to a fixed-length byte sequence. When you have a block of text and change it prior to rehashing, it will produce a new hash. This way, we can maintain data integrity during transfer.</p>
<p>However, as has been discussed in relation to other cryptographic methods, this method does not authenticate the sender of the message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Symmetric encryption</h1>
                </header>
            
            <article>
                
<p>Symmetric encryption uses a single key and works on blocks of text. This method works quicker than others. While using this method, it is important to maintain the confidentiality of the secret key, and both the sender and receiver should use the same key, which is a disadvantage of this method.</p>
<p>Let's look at an example and understand how we can encrypt a message or block of text: </p>
<ol>
<li>Here, we use the encrypt method, where we read a block of text from a file, encrypt it using a symmetric algorithm, and write the encrypted content to a different file.</li>
<li>The encrypt method accepts an instance of <kbd>SymmetricAlgorithm</kbd>, which is used to create an instance of <kbd>ICryptoTransform</kbd> by passing a key and initial vector. The system allows you to generate your own key or use the one it generates.</li>
<li>Then, we create a memory stream to store the buffer at runtime:</li>
</ol>
<pre style="padding-left: 60px">public static void EncryptSymmetric(SymmetricAlgorithm sem)<br/>{<br/>    //Read content from file<br/>    string filecontent = File.ReadAllText("..\\..\\inputfile.txt");<br/>    //Create encryptor using key and vector<br/>    ICryptoTransform encryptor = sem.CreateEncryptor(sem.Key, sem.IV);<br/>    //create memory stream used at runtime to store data<br/>    using (MemoryStream outputstream = new MemoryStream())<br/>    {<br/>        //Create crypto stream in write mode<br/>        using (CryptoStream encStream = new CryptoStream(outputstream, encryptor, CryptoStreamMode.Write))<br/>        {<br/>            //use streamwrite <br/>            using (StreamWriter writer = new StreamWriter(encStream))<br/>            {<br/>                // Write the text in the stream writer <br/>                writer.Write(filecontent);<br/>            }<br/>        }<br/>        // Get the result as a byte array from the memory stream <br/>        byte[] encryptedDataFromMemory = outputstream.ToArray();<br/>        // Write the data to a file <br/>        File.WriteAllBytes("..\\..\\Outputfile.txt", encryptedDataFromMemory);<br/>    }<br/>}</pre>
<p style="padding-left: 60px"><span>A cryptostream is created using the memory stream, <kbd>ICryptoTransform</kbd>, along with the write mode. A cryptostream is used to write to memory, which can then be converted into an array and written to an output file.</span></p>
<ol start="4">
<li>Once you execute the encrypt method, you can now open the output file from the solution and check the results.</li>
<li>Now, we will read the data from the output file and decrypt it to plain text:</li>
</ol>
<pre style="padding-left: 60px">public static string DecryptSymmetric(SymmetricAlgorithm sem)<br/>{<br/>    string result = string.Empty;<br/>    //Create decryptor<br/>    ICryptoTransform decryptor = sem.CreateDecryptor(sem.Key, sem.IV);<br/>    //read file content<br/>    byte[] filecontent = File.ReadAllBytes("..\\..\\Outputfile.txt");<br/>    //read file content to memory stream<br/>    using (MemoryStream outputstream = new MemoryStream(filecontent))<br/>    {<br/>        //create decrypt stream<br/>        using (CryptoStream decryptStream = new CryptoStream(outputstream, decryptor, CryptoStreamMode.Read))<br/>        {<br/>            using (StreamReader reader = new StreamReader(decryptStream))<br/>            {<br/>                //read content of stream till end<br/>                result = reader.ReadToEnd();<br/>            }<br/>        }<br/>    }<br/>    return result;<br/>    <br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>The</span> decrypt <span>method</span><span> uses the same signature a</span>s the encrypt me<span>thod. However, instead of creating an <kbd>encryptor</kbd> class, we create a <kbd>decryptor</kbd> class, which implements the <kbd>ICryptoTransform</kbd> interface.</span></p>
<p>The following is the main program, where we create <kbd>SymmetricAlgorithm</kbd> of the <kbd>AESManaged</kbd> instance type, and then pass it to the encrypt and decrypt methods:</p>
<pre> static void Main(string[] args)<br/> {<br/>     Console.WriteLine("Using AES symmetric Algorithm");<br/>     SymmetricAlgorithm sem = new AesManaged();<br/>     Console.WriteLine("Encrypting data from inputfile");<br/>     EncryptDecryptHelper.EncryptSymmetric(sem);<br/>     Console.WriteLine("Data Encrypted. You can check in outputfile. Press any key to decrypt message");<br/>     System.Console.ReadKey();<br/>     Console.WriteLine("Decrypting content form outputfile");<br/>     string message = EncryptDecryptHelper.DecryptSymmetric(sem);<br/>     Console.WriteLine($"Decrypted data : {message}");<br/>     // Keep the console window open in debug mode.<br/>     System.Console.WriteLine("Press any key to exit.");<br/>     System.Console.ReadKey();<br/> }</pre>
<p>Before executing the program, check the input file in the solution where you can change the content and execute it. Following encryption, the output file in the solution can be verified for the encrypted content:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8e6106fb-9c05-4d06-8682-c8aff8eb3d9e.png"/></div>
<p>When you practice this example, make sure that you have all the helper methods in one class, and the main method in another class, as specified in the sample code on GitHub. Now that you have all the methods, when you execute them, you see the preceding output.</p>
<p>Your encryption method uses the AES algorithm. It reads data from the input file, encrypts data using the AES algorithm, and then writes a message on the screen. Once you press any key, your decrypt method is initiated, decrypts the message, and writes to the output file. The same message is displayed on screen.</p>
<p class="mce-root"/>
<p>In a real-time scenario, when you want to perform secure transactions using file transfers, this is one way to do so. Because you will be using symmetric algorithms, it will be easy to encrypt or decrypt the content.</p>
<p>A sender encrypts the content of the file and sends it to the receiver. The receiver decrypts the file content and processes it. In this method, both the sender and receiver should be aware of the key used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asymmetric encryption</h1>
                </header>
            
            <article>
                
<p>Asymmetric encryption uses two keysâ€”a public key and a private key. Because of this, it runs bit slowly. Also, it is necessary to keep the private key safe at all times. Unless you have the private key, you cannot decrypt the message.</p>
<p>Now, let's jump into an example and try to understand how this is done. In this scenario, we will be using <kbd>RSACryptoServiceProvider</kbd>. This algorithm provides us with public and private keys that can be used to encrypt and decrypt messages. The encrypt method accepts a public key and text to encrypt, and we then convert the text to a byte array since the encrypt method accepts byte arrays. Then, we set the public key for the algorithm and invoke the encrypt method:</p>
<pre>public static byte[] EncryptAsymmetric(string publicKey, string texttoEncrypt)<br/>{<br/>    byte[] result;<br/>    UnicodeEncoding uc = new UnicodeEncoding();<br/>    byte[] databytes = uc.GetBytes(texttoEncrypt);<br/>    using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider())<br/>    {<br/>        rsa.FromXmlString(publicKey);<br/>        result = rsa.Encrypt(databytes, true);<br/>    }<br/>    return result;<br/>}</pre>
<p>In the decrypt method, we pass the byte array that needs to be decrypted along with a private key. Once a message is encrypted using a public key, it can only be decrypted using its corresponding private key:</p>
<pre>public static string DecryptAsymmetric(string privateKey, byte[] bytestoDecrypt)<br/>{<br/>    byte[] result;<br/>    using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider())<br/>    {<br/>        rsa.FromXmlString(privateKey);<br/>        result = rsa.Decrypt(bytestoDecrypt, true);<br/>    }<br/>    UnicodeEncoding uc = new UnicodeEncoding();<br/>    string resultText = uc.GetString(result);<br/>    return resultText;<br/>}</pre>
<p>The following is the main method, where we create the <kbd>RSACryptoproviderservice</kbd> class to get public and private keys. <kbd>rsa.ToXmlString(false)</kbd> provides a public key, and setting it to <kbd>true</kbd> will give us a private key. We will use these keys to encrypt and decrypt messages:</p>
<pre>static void Main(string[] args)<br/>{<br/>    #region asymmetric Encryption<br/>    Console.WriteLine("Using asymmetric Algorithm");<br/>    RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();<br/> string publicKey = rsa.ToXmlString(false);<br/> string privateKey = rsa.ToXmlString(true);<br/>    Console.WriteLine("Encrypting data ");<br/>    byte[] resultbytes = EncryptDecryptHelper.EncryptAsymmetric(publicKey,"This is a dummy text to encrypt");<br/>    Console.WriteLine("Data Encrypted. Press any key to decrypt message");<br/>    System.Console.ReadKey();<br/>    Console.WriteLine("Decrypting content");<br/>    string resultText = EncryptDecryptHelper.DecryptAsymmetric(pricateKey, resultbytes);<br/>    Console.WriteLine($"Decrypted data : {resultText}");<br/>    #endregion<br/><br/>    // Keep the console window open in debug mode.<br/>    System.Console.WriteLine("Press any key to exit.");<br/>    System.Console.ReadKey();<br/>}</pre>
<p>Execute the program by changing the input text, or you can try changing the algorithm. However, when you change the algorithm, you may need to apply any syntactical changes that are required in order for the program to run and work:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/133e0fd4-14f3-414a-8909-1289f9e6d1db.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">When you execute the program, you see the preceding output. In the sample, you are using an asymmetric algorithm to encrypt content. As the control flows through the code, it display messages. Once the message is encrypted, it will ask you to press any key. Upon pressing any key, the program decrypts the message and displays it on screen.</p>
<p>In the scenario that we discussed under symmetric algorithms, where you want to perform secure transactions between two parties, you can use public-private key combinations.</p>
<p>A receiver performs encryption using a private key and sends the file or block of text to the receiver, where a public key is used to decrypt the content. In the event the public-private keys do not match, you cannot read or validate the data. This is one way to validate input data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital signatures</h1>
                </header>
            
            <article>
                
<p>Digital signatures can be used to sign the message that will authenticate the sender. However, signing a message doesn't prevent a third party from reading the message. To achieve this, we need to encrypt the message and sign it. </p>
<p>In the following example, we are using a public key and a private key (asymmetric algorithm). We use the sender's private key to sign the message and the receiver's public key to encrypt the message. If you observe the code, we also use hash computing in this example. After encrypting the message, we hash the message.</p>
<p>We are going to use <kbd>RSACryptoServiceProvider</kbd>, along with <kbd>RSAPKCS1SignatureFormatter</kbd>, which will be used to create a signature.</p>
<p>In the following program, we convert text to a byte array using <kbd>UnicodeEncoding</kbd> classes, encrypt the message using the receiver's public key and the symmetric or asymmetric algorithms we learned in previous sections, compute the hash of the content, and then digitally sign the message. Once all of these processes have been implemented, we transmit the data across, where we recompute the hash, verify the signature, and then decrypt the message using the keys.</p>
<p class="mce-root"/>
<p>In the following <span>example</span>, we are using public-private keys to perform encryption. As mentioned previously, simply signing the message doesn't secure the content of the message. Instead, it will allow you to authenticate the sender:</p>
<pre><span>public static void DigitalSignatureSample(string senderPrivatekey, string receiverspublickey, string texttoEncrypt)<br/>{<br/> UnicodeEncoding uc = new UnicodeEncoding();<br/> Console.WriteLine("Converting to bytes from text");<br/> //get bytearray from the message<br/> byte[] databytes = uc.GetBytes(texttoEncrypt);<br/> Console.WriteLine("Creating cryptoclass instance");<br/> //Creating instance for RSACryptoservice provider as we are using for sender and receiver<br/> RSACryptoServiceProvider rsasender = new RSACryptoServiceProvider();<br/> RSACryptoServiceProvider rsareceiver = new RSACryptoServiceProvider();<br/> //getting private and public key<br/> rsasender.FromXmlString(senderPrivatekey);<br/> rsareceiver.FromXmlString(receiverspublickey);<br/> Console.WriteLine("Creating signature formatter instance");<br/> //GEt signature from RSA<br/> RSAPKCS1SignatureFormatter signatureFormatter = new RSAPKCS1SignatureFormatter(rsasender);<br/> //set hashalgorithm<br/> signatureFormatter.SetHashAlgorithm("SHA1");<br/> //encrypt message<br/> Console.WriteLine("encrypting message");<br/> byte[] encryptedBytes = rsareceiver.Encrypt(databytes, false);<br/> //compute hash<br/> byte[] computedhash = new SHA1Managed().ComputeHash(encryptedBytes);<br/> Console.WriteLine("Creating signature");<br/> //create signature for the message<br/> byte[] signature = signatureFormatter.CreateSignature(computedhash);<br/> Console.WriteLine("Signature: " + Convert.ToBase64String(signature));<br/> Console.WriteLine("Press any key to continue...");<br/> Console.ReadKey();<br/> //receive message then recompute hash<br/> Console.WriteLine("recomputing hash");<br/> byte[] recomputedHash = new SHA1Managed().ComputeHash(encryptedBytes);<br/> //signature deformatter<br/> Console.WriteLine("Creating signature dformatter instance");<br/> RSAPKCS1SignatureDeformatter signatureDFormatter = new RSAPKCS1SignatureDeformatter(rsareceiver);<br/> signatureDFormatter.SetHashAlgorithm("SHA1");<br/> //verify signature<br/> Console.WriteLine("verifying signature");<br/> if (!signatureDFormatter.VerifySignature(recomputedHash, signature))<br/> {<br/>  Console.WriteLine("Signature did not match from sender");<br/> }<br/> Console.WriteLine("decrypting message");<br/> //decrypt message<br/> byte[] decryptedText = rsasender.Decrypt(encryptedBytes, false);<br/> Console.WriteLine(Encoding.UTF8.GetString(decryptedText));<br/>}</span></pre>
<p>The following is the main program, where we create an instance of the <kbd>RSACryptoServiceProvider</kbd> class and collect public and private keys. However, as we are encrypting and decrypting the message in the same method, a single set of public and private keys was used.</p>
<p>As part of this example, we perform both encryption and decryption. We can create multiple RSA providers and use their public-private keys for senders and receivers. You can create different console applications, one as a sender and the other as a receiver, and simulate a real-world scenario. For simplicity's sake, I have used one pair of public-private keys to perform operations:</p>
<pre>static void Main(string[] args)<br/>{<br/>    #region Digital Signatures<br/>    RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();<br/>    string publicKey = rsa.ToXmlString(false);<br/>    string pricateKey = rsa.ToXmlString(true);<br/>    EncryptDecryptHelper.DigitalSignatureSample(pricateKey, publicKey,"This is a sample text for Digital signatures");<br/>    #endregion<br/><br/>    // Keep the console window open in debug mode.<br/>    System.Console.WriteLine("Press any key to exit.");<br/>    System.Console.ReadKey();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Check the output by changing the input message and algorithms. However, as said earlier, you may need to take care of any syntactical changes before executing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5c7417d1-6458-4e10-96b3-5291bbeba425.png"/></div>
<p>In a real-world scenario, suppose two entities are communicating via web services where such digital signatures are implemented. The sender will have a set of public and private keys, and the receiver will have public and private keys. Both parties should exchange their respective public keys to facilitate application communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hash values</h1>
                </header>
            
            <article>
                
<p>Computing a hash creates a fixed-length numeric value from a byte array. A hash maps a variable-length binary string to a fixed-length binary string. A hash cannot be used for two-way conversion. When you apply a hash algorithm, each character gets hashed into a different binary string.</p>
<p>In the following example, we use the <kbd>SHA1Managed</kbd> algorithm to compute the hash. We compute the hash twice to check whether the result is the same. As mentioned earlier, this method is used to maintain data integrity.</p>
<p>In the following code, we are using the <kbd>UnicodeEncoding</kbd> class to convert the text to a byte array, and the <kbd>SHA1Managed</kbd> algorithm to compute the hash for the byte array. Once converted, we display each and every hashed byte on the screen. To validate the hash, we recompute the hash on the string and compare the hash values. This is one way to validate input data:</p>
<pre>public static void HashvalueSample(string texttoEncrypt)<br/>{<br/>    UnicodeEncoding uc = new UnicodeEncoding();<br/>    Console.WriteLine("Converting to bytes from text");<br/>    byte[] databytes = uc.GetBytes(texttoEncrypt);<br/>    byte[] computedhash = new SHA1Managed().ComputeHash(databytes);<br/>    foreach (byte b in computedhash)<br/>    {<br/>        Console.Write("{0} ", b);<br/>    }<br/>    Console.WriteLine("Press any key to continue...");<br/>    byte[] reComputedhash = new SHA1Managed().ComputeHash(databytes);<br/>    bool result = true;<br/>    for (int x = 0; x &lt; computedhash.Length; x++)<br/>    {<br/>        if (computedhash[x] != reComputedhash[x])<br/>        {<br/>            result = false;<br/>        }<br/>        else<br/>        {<br/>            result = true;<br/>        }<br/>    }<br/><br/>    if (result)<br/>    {<br/>        Console.WriteLine("Hash value is same");<br/>    }<br/>    else<br/>    {<br/>        Console.WriteLine("Hash value is not same");<br/>    }<br/>}</pre>
<p>The main method for invoking the hash value example is as follows. Here, we just call the helper method that performs the hash compute on the text provided:</p>
<pre>static void Main(string[] args)<br/>{ <br/>    #region Hashvalue<br/>    EncryptDecryptHelper.HashvalueSample("This a sample text for hashvalue sample");<br/>    #endregion<br/><br/><br/>    // Keep the console window open in debug mode.<br/>    System.Console.WriteLine("Press any key to exit.");<br/>    System.Console.ReadKey();<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>When we compute the hash, we display the result and then we undertake a comparison to see whether the result from both calls is the same:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e9da11f-81c9-4994-8f5c-cd99d45b3573.png"/></div>
<p>The preceding screenshot shows the program where you compute the hash and display the hashed array. Also, when the program recomputes the hash and effects a comparison, you see the same hash value message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we focused on understanding cryptography and how we can use symmetric and asymmetric algorithms. We also focused on how we <span>can </span>use these to validate senders, receivers, and the content of messages. We can use the techniques learned in the chapter to validate input data and perform similar operations when working with secure transactions. We also looked at how we can sign messages using digital signatures, and how can we maintain data integrity using hash values. </p>
<p>In the next chapter, we will focus on .NET assemblies, how we can manage them, and how we can debug C# applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Out of the four methods discussed in this chapter, which two can be used to authenticate the sender?
<ol start="1">
<li>Symmetric algorithm</li>
<li>Asymmetric algorithm</li>
<li>Hash values</li>
<li>Digital signatures</li>
</ol>
</li>
<li><span>When two parties need to communicate using an asymmetric algorithm, which key do they need to share?</span>
<ol>
<li>Private key</li>
<li>Public key</li>
<li>Both</li>
<li>None </li>
</ol>
</li>
<li>Which type of algorithm is used to encrypt large amounts of data?
<ol>
<li>Symmetric</li>
<li>Asymmetric</li>
<li>Both</li>
<li>None</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>Digital signatures</strong></li>
<li><strong>Public key</strong></li>
<li><strong>Symmetric</strong></li>
</ol>


            </article>

            
        </section>
    </body></html>