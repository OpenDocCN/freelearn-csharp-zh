- en: Using the Decorator to Implement a Weapon System
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to build a customizable weapon system. Throughout
    the game, the player will be able to upgrade its bike's primary weapon by purchasing
    attachments that will augment specific properties, such as range and strength.
    The primary weapon is mounted on the front of the bike and has two expansion slots
    for attachments that the player can use to build various combinations. To build
    this system, we are going to use the Decorator pattern. It should not be a surprise
    because its name implies its use, as we will see further in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic principles behind the Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of a weapon system with attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have a basic understanding of Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the following Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScriptableObjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml),
    *A Short Primer to Programming in Unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action:[ https://bit.ly/3r9rvJD](https://bit.ly/3r9rvJD).
  prefs: []
  type: TYPE_NORMAL
- en: We often use **ScriptableObjects** in the code examples in this book because
    we want to establish an authoring workflow for our designers to create new weapon
    attachments or configure existing ones without modifying a single line of code.
    It's good practice to make your systems, ingredients, and mechanics easy to configure
    for non-programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, the Decorator is a pattern that permits the addition of new functionalities
    to an existing object without altering it. And this is made possible by creating
    a decorator class that wraps the original class. And with this mechanism, we easily
    attach but also detach new behaviors to an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the following diagram to visualize the Decorator''s structure
    before diving deeply into the subject matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06a1b37f-1842-42c4-a927-a15c3e7f6eaf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – UML diagram of the Decorator pattern
  prefs: []
  type: TYPE_NORMAL
- en: The `IWeapon` interface establishes an implementation contract that will maintain
    a consistent method signature between the decorated object and its decorators.
    `WeaponDecorator` wraps the target object, and the concrete decorator classes
    (`WithGrip` and `WithStabilizer`) decorate it by enhancing or overriding its behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The method signatures and the overall structure of the *decorated* object are
    not modified during the process, just its behaviors or property values. Thus,
    we can easily remove decorations from an object and return it to its initial form.
  prefs: []
  type: TYPE_NORMAL
- en: Most textbook examples of this pattern are heavily dependent on the class constructor.
    However, native Unity API base classes, such as `MonoBehaviour` and `ScriptableObject`,
    don't use the concept of a constructor to initialize an instance of an object.
    Instead, in the case of MonoBehaviours, the engine takes care of initializing
    the classes that are attached to GameObjects. And any initialization code is expected
    to be implemented in the `Awake()` or `Start()` callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we are challenged to find a way to adapt the Decorator pattern so
    that it will use core Unity API features while not losing its primary benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some of the benefits of the Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alternative to subclassing**: Inheritance is a static process. Unlike the
    Decorator pattern, it doesn''t permit extending an existing object''s behavior
    at runtime. You can only replace an instance with another with the same parent
    class that has the desired behavior. Therefore, the Decorator pattern is a more
    dynamic alternative to subclassing and overcomes the limits of inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime dynamics**: The Decorator pattern permits us to add functionality
    to an object at runtime by attaching decorators to it. But this also means that
    the reverse is possible, and you can restore an object back to its original form
    by removing its decorators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the potential drawbacks of the Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Relationship complexity**: Keeping track of the chain of initialization and
    the relationships between decorators can become very complicated if there are
    multiple layers of decorators around an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code complexity**: Depending on how you implement the Decorator pattern,
    it can add complexity to your code base as you might need to maintain several
    little decorator classes. But when and how this becomes an actual drawback is
    very contextual and not a constant. In the upcoming code example that we will
    review, this is not an issue as each decorator is a `ScriptableObject` instance
    that we save as a configurable asset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Decorator pattern is a part of the structural design pattern family; some
    of its members include the Adapter, Bridge, Façade, and Flyweight patterns.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the Decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we are implementing a weapon system with attachments. We have
    a couple of specifications to consider, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to be able to attach multiple attachments to a weapon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to be able to add and remove them at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Decorator pattern offers us a way to fulfill these two core requirements.
    Therefore, it's a pattern to consider when implementing a system in which we need
    to support the ability to add and remove behaviors to an individual object in
    a dynamic manner.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we are assigned to work on a **CCG** (**collectible card game**),
    we might have to implement a mechanism in which the player can augment a base
    card's powers with artifact cards stacked on top of each other. Another use case
    is imagining having to implement a wardrobe system in which players can decorate
    their armor with accessories to buff specific stats.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, using the Decorator pattern could be a good starting point to
    build these types of mechanics and systems. Now that we have a basic understanding
    of the Decorator pattern, we will review the design of our weapon attachment system
    before writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a weapon system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, every bike model in our game comes equipped with a front-mounted
    gun that fires laser beams. The player can use this weapon to destroy obstacles
    that might be in the way, and very skilled players can shoot at flying drones
    while doing wheelies. The player can also purchase various attachments that boost
    the basic stats of the bike''s weapon, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a64774-90d0-4763-a64b-a09aecd8f27a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Diagram of the weapon attachment system
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review a shortlist of potential attachments that the player could buy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Injector**: A plasma injector that amplifies the weapon''s damage capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stabilizer**: An attachment that reduces vibrations caused when the bike
    hits its top speed. It stabilizes the weapon''s shooting mechanism and expands
    its range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cooler**: A water-cooling system that attaches itself to the weapon''s firing
    mechanism. It enhances the rate of fire and reduces the cool-down duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples are high-level concepts of potential attachment variations. Each
    of these attachments modifies or, in other words, "decorates" specific properties
    of the weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement to keep in mind while implementing our system is that our
    weapon will have a maximum of two expansion slots for attachments. The player
    must be able to add and remove them dynamically when adjusting the settings on
    their vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good overview of the requirements of the design of our system,
    it's time to translate this into code, which we will do in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a weapon system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to implement the core classes of our weapon system.
    However, please note that we are not going to write the weapon's core behaviors
    for reasons of brevity. We want to keep the focus on understanding how the Decorator
    pattern works. But if you wish to review a more advanced version of this code
    example, check out the `FPP` folder in this book's GitHub repo. The link can be
    found in the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the weapon system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many steps need to be performed as we have a lot of code to review together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we are going to implement the `BikeWeapon` class. Because it''s quite
    long, we will split it up into three segments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first segment is the initialization code. Note that we are setting the weapon's
    configuration at the `Start()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second segment of the class, it is just `GUI` labels that will help
    us with debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is in the last segment that things start to get interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Reset()` method resets the weapon to its initial configurations by initializing
    a new `Weapon` with its default weapon configurations. This is a quick and simple
    way to remove the attachments that we set in the `Decorate()` method. It's not
    always the best approach, but it works in the context of this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `Decorate()` is where the magic happens, and the Decorator pattern
    mechanism is triggered. You might notice that we can stack attachments over one
    another by chaining them in the constructor, as we see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That's a little trick that the Decorator and constructors permit us to do. How
    it works will be made more apparent when we start implementing the other classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next class to implement is the `Weapon` class. Notice that it''s not a
    `MonoBehaviour`. Therefore, we will initialize it with its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `BikeWeapon`, the `Weapon` class doesn't implement any behaviors; it's
    just a representation of the configurable properties of a weapon. This is the
    object we will decorate with attachments. In its constructor, we are passing an
    instance of a `WeaponConfig` object. As we are going to see further on, this is
    a `ScriptableObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a common interface between the decorator class and the weapon, so we
    are going to implement one named `IWeapon`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a standard interface that defines a set of properties that
    we can decorate, we can implement a `WeaponDecorator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `WeaponDecorator` is wrapping itself around an instance of an object
    that shares a similar interface, in this case, the `IWeapon` interface. It never
    modifies directly the object that's its wrapping; it's only decorating its public
    properties with those of a `WeaponAttachment`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in our code example, we are just modifying the values of the
    properties of a weapon. And this fits with our design because the attachments
    don't alter the weapon's core mechanism. Instead, they just enhance specific properties
    through an attachment slot.
  prefs: []
  type: TYPE_NORMAL
- en: One last detail to keep in mind is the fact that we are defining the weapon's
    behavior inside the `BikeWeapon` class and its behavior is determined by the properties
    set in an instance of a `Weapon` object. Therefore, by decorating the `Weapon`
    object, we are modifying how the bike weapon behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following step is where we are starting to deviate from a traditional implementation
    of the Decorator pattern. Instead of defining individual concrete decorator classes,
    we are going to implement a `ScriptableObject` named `WeaponConfig`. This approach
    will permit us to author separate attachments and configure their properties through
    the inspector. Then, we will use these attachment assets to decorate the weapon,
    as we can see here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that `WeaponAttachment` implements the `IWeapon` interface.
    This keeps it consistent with `WeaponDecorator` and `Weapon` classes as all three
    of them share the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'And for our last step, we are going to implement the `ScriptableObject` class
    named `WeaponConfig`. We are using to it create various configurations for our
    `Weapon` object that we can then configure with attachments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We now have all the key ingredients for our weapon attachment system, and it's
    time to test them inside the Unity engine.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the weapon system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to test the code we just reviewed in your own instance of Unity,
    you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy all the classes we just reviewed in your Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty Unity scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new GameObject to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following client script to the new GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Add to the new GameObject the `BikeWeapon` script we implemented in the previous
    section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Assets** | **Create** | **Weapon** menu option, create a new **Config**
    and configure it as you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Assets** | **Create** | **Weapon** menu option, create several **Attachment**
    variations with various configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now add `WeaponConfig` and `WeaponAttachment` assets to the `BikeWeapon`
    component properties in `Inspector`, as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eff3396f-8fe2-4109-9670-00320555bbe2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – BikeWeapon component properties
  prefs: []
  type: TYPE_NORMAL
- en: 'When you start your scene, you should see the following buttons in the top-left
    corner of the screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/372aed4f-bb8d-4731-ad96-fd9b270cbec5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Screenshot of the code example in action inside Unity
  prefs: []
  type: TYPE_NORMAL
- en: You now test the weapon attachment system and adjust it as you wish by pressing
    the buttons and look at the weapon stats change as you modify the decorator's
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the weapon system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our Decorator implementation is unorthodox because we are mixing native C# language
    features such as constructors while trying to utilize the best parts of the Unity
    API. By converting decorator classes into configurable `ScriptableObject` assets,
    we gain the ability to make our weapon attachments authorable and configurable
    by non-programmers. And under the hood, our attachment system is constructed on
    the foundation of a solid design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we endeavored to strike a balance between usability and maintainability.
    However, as we are going to see in the next section, there are always alternative
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are guidelines, not commandments. Therefore, it's OK to experiment
    with patterns and test out different ways of implementing them. The code example
    in this chapter is experimental because it's not a traditional implementation
    of the Decorator pattern. But we encourage you, as the reader, to continue experimenting
    with the patterns showcased in this book and find new ways of using them in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing alternative solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the context of the use case presented in this chapter, we could have implemented
    the weapon system without the Decorator pattern and with ScriptableObjects only.
    We could have iterated through a list of acquired weapon attachments and apply
    each of their properties to those of a `Weapon` class. We would lose the ability
    of chaining decorators, but our code will be more straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The core benefit of using the Decorator pattern in our case was that it gave
    us a structured and repeatable approach to implementing our system. Still, in
    consequence, we added additional complexity to our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented a weapon attachment system that's authorable
    and configurable. Non-programmers will be able to create and adjust new attachments
    without writing a single line of code. Therefore, we can focus on building systems
    while designers work on balancing them. The Decorator pattern has proven itself
    to be a handy pattern for game development, and so it's a pattern to keep in our
    programmer's toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the Spatial Partition pattern—a subject
    matter that's quite important to understand when building games with large maps.
  prefs: []
  type: TYPE_NORMAL
