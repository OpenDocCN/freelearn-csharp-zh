- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Working with Remote Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理远程数据
- en: 'So far, we’ve dug deep into MVVM and .NET MAUI, covering everything from the
    basics of the MVVM design, from data binding and Dependency Injection to navigation
    and handling user input. But there’s one big piece of the puzzle we haven’t tackled
    yet: getting data from the internet.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入探讨了 MVVM 和 .NET MAUI，涵盖了从 MVVM 设计的基础，到数据绑定和依赖注入，再到导航和处理用户输入的各个方面。但是，还有一块重要的拼图我们没有解决：从互联网获取数据。
- en: It’s hard to imagine an app these days that doesn’t talk to an online service
    to grab fresh data. Adding backend communications also means we need to tackle
    some architectural challenges such as maintaining separation of concerns, building
    your app with maintainability in mind, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很难想象一个应用程序不与在线服务通信来获取新鲜数据。添加后端通信也意味着我们需要解决一些架构挑战，例如保持关注点的分离、以可维护性为前提构建应用程序等。
- en: 'Here’s what we’ll dive into in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨以下内容：
- en: Revisiting the model architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视模型架构
- en: API communication with Refit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Refit 进行 API 通信
- en: API communication from ViewModels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewModels 的 API 通信
- en: By the end of this chapter, our *Recipes!* app will be more than just a standalone
    thing. It’ll communicate with a backend service to fetch fresh data and push updates.
    We’re going to equip it with the essential tools and skills needed for solid MVVM
    apps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们的 *Recipes!* 应用程序将不仅仅是一个独立的东西。它将与后端服务通信以获取新鲜数据并推送更新。我们将为其配备构建坚实的 MVVM
    应用程序所需的必要工具和技能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we update the general architecture of the *Recipes!* app to
    better facilitate communication with remote APIs. To ensure you’re on the same
    page, all resources and code snippets are available on GitHub: [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10).
    If you wish to code along, start with the code in the `Start` folder, which has
    been refactored to serve as the foundation for this chapter. Upon completion,
    you can compare your work with the `Finish` folder to see the finalized version.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更新了 *Recipes!* 应用程序的一般架构，以更好地促进与远程 API 的通信。为了确保你与我们在同一页面上，所有资源和代码片段都可在
    GitHub 上找到：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter10)。如果你希望一起编码，请从
    `Start` 文件夹中的代码开始，该代码已被重构，作为本章的基础。完成之后，你可以将你的工作与 `Finish` 文件夹中的最终版本进行比较。
- en: Revisiting the model architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视模型架构
- en: In our journey so far, our model has been straightforward. We simply used services
    that read local JSON files and fed **Data Transfer Objects (DTOs)** directly to
    our ViewModels. But as we introduce remote data, this simplistic model won’t suffice.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的旅程中，我们的模型很简单。我们只是使用了读取本地 JSON 文件的服务，并将 **数据传输对象 (DTOs)** 直接提供给我们的 ViewModels。但是，随着我们引入远程数据，这种简单的模型将不再足够。
- en: A straightforward approach would be to make an API call directly within our
    service and pass the resulting DTOs to our ViewModels. However, leaning on the
    principle of SoC, I believe services shouldn’t be making API calls. Moreover,
    using API-specific DTOs directly within our ViewModels is a slippery slope. It
    tightly couples our application with the external API, which can lead to maintenance
    nightmares, especially if the API changes often or isn’t under our control.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一种直接的方法是在我们的服务中直接进行 API 调用，并将结果 DTOs 传递给我们的 ViewModels。然而，根据 SoC 原则，我相信服务不应该进行
    API 调用。此外，直接在 ViewModels 中使用特定于 API 的 DTOs 是一条滑梯。这会紧密地将我们的应用程序与外部 API 相关联，可能导致维护噩梦，尤其是如果
    API 经常更改或不受我们控制的话。
- en: Instead, I advocate for mapping these DTOs to **Plain Old CLR Objects (POCOs)**,
    or entities or domain models – whatever you prefer to name them. The core idea?
    Work with types we own and control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我主张将这些 DTOs 映射到 **Plain Old CLR Objects (POCOs)**，或者实体或领域模型——无论你更喜欢叫它们什么。核心思想？与我们所拥有和控制的数据类型一起工作。
- en: Tip
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: By keeping the interaction points between our app and the API to a minimum,
    our code will be less impacted by potential API changes, enhancing maintainability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的应用程序和 API 之间的交互点保持在最低限度，我们的代码将受到潜在 API 变化的影响较小，从而提高可维护性。
- en: 'To realize this, we’ll introduce the concept of **repositories** in our architecture.
    These repositories will interface with the API (or any data source), fetch the
    DTOs, map them to our domain models, and then supply them to our services and
    ViewModels. The following diagram captures this envisioned architecture:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将在我们的架构中引入**存储库**的概念。这些存储库将与API（或任何数据源）接口，获取DTOs，将它们映射到我们的领域模型，然后提供给我们的服务和ViewModel。以下图表展示了这一设想架构：
- en: '![Figure 10.1: Architectural overview](img/B20941_10_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：架构概述](img/B20941_10_01.jpg)'
- en: 'Figure 10.1: Architectural overview'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：架构概述
- en: 'Now, one might ask: is this really needed? Can’t we just directly call an API
    from a service while using DTOs in our ViewModels? The answer is no, it is not
    needed; you can perfectly well call an API from a service if you want. This can
    definitely work for smaller “dumb” apps where all the business logic is done on
    the server. But as we scale or tackle more complex scenarios, thoughtful architecture
    becomes crucial for several reasons:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有人可能会问：这真的有必要吗？我们难道不能直接从服务中调用API，同时在ViewModel中使用DTOs吗？答案是：不需要；如果你想，完全可以从服务中调用API。这绝对适用于所有业务逻辑都在服务器上完成的较小“傻瓜”应用程序。但随着我们规模的扩大或处理更复杂的场景，深思熟虑的架构对于几个原因来说变得至关重要：
- en: '**Separation of concerns**: By introducing repositories, we distinctly segregate
    the roles within our system. Repositories are primarily concerned with fetching
    data from a data source – be it an API or another data store – and then translating
    it into a format our services can readily use. Positioning the repository layer
    outside of the core project not only emphasizes its distinct responsibility but
    also ensures that changes or expansions to data sources don’t interfere with the
    core business logic. This separation enhances the system’s adaptability and maintainability.
    It becomes clear that the repository’s sole purpose is data retrieval, acting
    as a thin layer that fetches data from various sources and feeds it to the core
    services. With repositories acting as intermediaries, changes to the data source
    or alterations to the data structure are centralized, streamlining modifications.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**: 通过引入存储库，我们明确地分离了系统中的角色。存储库主要关注从数据源（无论是API还是另一个数据存储）获取数据，并将其转换为服务可以轻松使用的格式。将存储库层放置在核心项目之外不仅强调了其独特的责任，还确保了数据源的变化或扩展不会干扰核心业务逻辑。这种分离增强了系统的适应性和可维护性。很明显，存储库的唯一目的是数据检索，它作为一个薄层从各种来源获取数据，并将其提供给核心服务。作为中介的存储库，数据源的变化或数据结构的更改都集中管理，简化了修改过程。'
- en: '**Improved testability**: By introducing a repository layer, we enhance our
    app’s testability. With repositories in place, we can effortlessly mock the data
    layer in our tests. This abstraction ensures our tests focus on the logic within
    our services, free from dependencies on external data sources. In [*Chapter 13*](B20941_13.xhtml#_idTextAnchor223),
    *Unit Testing*, we will be looking at this in much more detail.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高可测试性**: 通过引入存储库层，我们增强了应用程序的可测试性。有了存储库，我们可以在测试中轻松地模拟数据层。这种抽象确保我们的测试专注于服务内部的逻辑，不受外部数据源的依赖。在[*第13章*](B20941_13.xhtml#_idTextAnchor223)
    *单元测试*中，我们将更详细地探讨这一点。'
- en: '**Augmented services**: The service layer remains free to introduce additional
    features such as caching, business logic, or data aggregation from multiple repositories.
    This decoupling means services aren’t tied directly to specific data sources and
    can evolve independently.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强服务**: 服务层可以自由地引入额外的功能，例如缓存、业务逻辑或从多个存储库中进行数据聚合。这种解耦意味着服务不会直接绑定到特定的数据源，并且可以独立演进。'
- en: Before we dive deep into the concepts of repositories and other details, let’s
    explore the solution found in the `Start` folder of this chapter’s accompanying
    code base to understand the changes that have been made.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨存储库和其他细节的概念之前，让我们先探索本章配套代码库的`Start`文件夹中找到的解决方案，以了解所进行的更改。
- en: Updates to the codebase
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码库的更新
- en: 'As we journey deeper into creating a robust MVVM architecture, it’s crucial
    to familiarize ourselves with changes and additions that have been made to the
    code base. If you take a look at the `Start` folder of the accompanying repository
    for this chapter, you’ll notice some changes. Here are notable updates:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入创建一个健壮的MVVM架构，熟悉代码库中已进行的更改和新增内容至关重要。如果你查看本章配套存储库的`Start`文件夹，你会注意到一些变化。以下是一些显著的更新：
- en: A `Recipes.Web.Api` API project has been added. At its core, it still reads
    from local JSON files, reminiscent of our earlier services. The implementation
    of the API is pretty bare-bones and only for demo purposes.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了一个`Recipes.Web.Api` API项目。在核心上，它仍然从本地JSON文件中读取，类似于我们早期的服务。API的实现相当简单，仅用于演示目的。
- en: The new `Recipes.Shared` project holds the DTOs that the API returns and accepts.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`Recipes.Shared`项目包含了API返回并接受的DTOs。
- en: In the `Features` folder of the `Recipes.Client.Core` project, we’ve added new
    POCO or domain entities. These are reflections of our DTOs but designed to be
    entirely under our control, ensuring a smoother integration with the rest of our
    app’s infrastructure.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Recipes.Client.Core`项目的`Features`文件夹中，我们添加了新的POCO或领域实体。这些实体是DTOs的反映，但设计上完全受我们控制，确保与我们的应用程序基础设施的集成更加顺畅。
- en: A new `Recipes.Client.Repositories` project has been created. This project will
    hold the implementations of the repositories that we will be creating. The idea
    is to keep them separate from the `Recipes.Client.Core` project so that the core
    project is completely isolated from the API and its DTOs. This project also contains
    mappers that map the DTOs returned by the API to POCO entities that we will be
    using throughout the app.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已创建一个新的`Recipes.Client.Repositories`项目。该项目将包含我们将要创建的存储库的实现。我们的想法是将它们与`Recipes.Client.Core`项目分开，以便核心项目完全独立于API及其DTOs。该项目还包含将API返回的DTOs映射到我们将在整个应用程序中使用的POCO实体的映射器。
- en: The services and ViewModels no longer depend upon DTOs. Now, they interact solely
    with our own POCOs, ensuring a clean and maintainable architecture.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务和ViewModels不再依赖于DTOs。现在，它们仅与我们的POCO交互，确保架构干净且易于维护。
- en: The `ratings.json` and `recipedetails.json` files have been removed from the
    `Recipes.Mobile` project as we are going to fetch our data from the API.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将从API获取数据，因此已从`Recipes.Mobile`项目中删除了`ratings.json`和`recipedetails.json`文件。
- en: 'The registrations of `IRecipeService` and `IRatingsService` in the `MauiProgram`
    class have been updated to the following:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MauiProgram`类中`IRecipeService`和`IRatingsService`的注册已更新为以下内容：'
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These changes set the stage for the introduction of repositories and interactions
    with the API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改为引入存储库和与API的交互奠定了基础。
- en: Always return a result
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总是返回一个结果
- en: In conventional coding, exceptions are commonly used to indicate failure. While
    they’re useful for *exceptional* cases, they might not be the best choice for
    regular, expected error scenarios. Using exceptions for expected errors can clutter
    the code and make it harder to follow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的编码中，异常通常用于指示失败。虽然它们对于*异常*情况很有用，但它们可能不是处理常规、预期错误场景的最佳选择。使用异常处理预期错误可能会使代码变得混乱，难以理解。
- en: 'That’s why I tend to use a `Result<TSuccess>` object to handle such cases.
    This object acts as a wrapper around the data we expect on success (`TSuccess`)
    and provides fields for an error code, error data, and an `Exception` error in
    the case of failure. It’s a very simple and convenient wrapper, as you can see
    here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我倾向于使用`Result<TSuccess>`对象来处理此类情况。该对象作为成功时预期的数据（`TSuccess`）的包装器，并提供错误代码、错误数据和失败情况下的`Exception`错误字段。它是一个非常简单且方便的包装器，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As the following code block shows, this class also contains some static methods
    that instantiate a `Success` or `Fail` `Result` object, facilitating the usage
    of this object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码块所示，该类还包含一些静态方法，用于实例化`Success`或`Fail` `Result`对象，从而简化该对象的使用：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By using the `Result` object, we can easily distinguish between two types of
    errors:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Result`对象，我们可以轻松地区分两种类型的错误：
- en: '**Unexpected errors**: These are real “exceptions” that we can’t predict and
    don’t know how to handle. They are still best managed by throwing exceptions.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意外错误**：这些是我们无法预测且不知道如何处理的“异常”。它们仍然最好通过抛出异常来管理。'
- en: '`Result` object.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result`对象。'
- en: 'For example, a mobile app unable to retrieve data isn’t an exceptional case;
    it’s a scenario we should plan for. The `Result` object allows us to handle such
    situations gracefully without resorting to exceptions. It offers a richer context
    than simply returning `null` or `false`, letting us understand why an operation
    failed. This even works when we talk to an API that we don’t control: this is
    just a simple wrapper around an object.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个无法检索数据的移动应用程序不是一个异常情况；这是我们应计划的情况。`Result`对象允许我们优雅地处理此类情况，而无需求助于异常。它提供的上下文比简单地返回`null`或`false`更丰富，使我们能够了解操作失败的原因。即使当我们与不控制的API通信时，这也同样有效：这只是一个围绕对象的简单包装器。
- en: The `Result` object brings clarity and consistency to our code. It removes uncertainties
    such as “*Can this method throw an exception? If so, what type? Is it the same
    exception type thrown in* *similar scenarios?*”
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 对象使我们的代码更加清晰和一致。它消除了诸如“*这个方法会抛出异常吗？如果是，是什么类型的异常？它在* *类似场景中抛出的异常类型是否相同？*”这样的不确定性。'
- en: Errors versus exceptions
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 错误与异常
- en: 'By segregating expected errors from true exceptions, we make the code more
    readable and maintainable. It lets exceptions be what they should be: indicators
    of critical, unexpected failures.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将预期错误与真正的异常分开，我们使代码更易于阅读和维护。它让异常成为它们应该成为的东西：指示关键、意外的失败。
- en: As we extend our *Recipes!* app to communicate with a backend API, the chances
    for various types of errors increase significantly. To prepare for this complexity,
    we’ll be wrapping the return values of our services and repositories in a `Result`
    object. This approach not only helps us deal effectively with expected errors
    but also brings a level of standardization and clarity to our error-handling strategy.
    Let’s see how this `Result` object brings elegance and robustness to the ViewModels.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们将 *Recipes!* 应用程序扩展到与后端 API 通信，各种类型错误的可能性显著增加。为了应对这种复杂性，我们将把服务和仓库的返回值包裹在一个
    `Result` 对象中。这种方法不仅帮助我们有效地处理预期错误，还为我们错误处理策略带来了标准化和清晰度。让我们看看这个 `Result` 对象如何为我们的
    ViewModels 带来优雅和健壮性。
- en: Putting the Result object to work
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Result 对象投入使用
- en: 'The following code snippet shows how the `Result` object can gracefully handle
    both successful and unsuccessful outcomes in the `RecipeRatingsDetailViewModel`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `Result` 对象如何在 `RecipeRatingsDetailViewModel` 中优雅地处理成功和失败的结果：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example underscores the elegance and robustness the `Result` object brings
    to our ViewModels. By using the `IsSuccess` property, we can immediately determine
    the success of the operation. If it’s successful, we proceed to work with the
    data we’ve received. If not, we offer the user a chance to retry or go back. Additionally,
    the `Result` object also contains valuable error information in `ErrorMessage`,
    `ErrorCode`, and `Exception`, allowing us to tailor our error-handling strategy,
    such as displaying specific error messages to the user. This approach removes
    the necessity of adding exception-handling sections across our ViewModels, leading
    to a cleaner, easier-to-read, and more maintainable code structure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子强调了 `Result` 对象为我们的 ViewModels 带来的优雅和健壮性。通过使用 `IsSuccess` 属性，我们可以立即确定操作的成功与否。如果成功，我们继续处理我们接收到的数据。如果不成功，我们给用户一个重试或返回的机会。此外，`Result`
    对象还包含在 `ErrorMessage`、`ErrorCode` 和 `Exception` 中的有价值错误信息，使我们能够定制我们的错误处理策略，例如向用户显示特定的错误消息。这种方法消除了在
    ViewModels 中添加异常处理部分的必要性，从而使得代码结构更清晰、易于阅读和维护。
- en: 'If we would like to leverage C# **pattern matching** abilities, we could make
    the preceding code even more elegant, like so:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想利用 C# 的 **模式匹配** 能力，我们可以使前面的代码更加优雅，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using pattern matching, we could check for the `Result` object’s `IsSuccess`
    property to be `true`, and in the same statement, assign the `Result` object’s
    `Data` property to the `ratings` variable. This allows us to access the `Data`
    property more easily through the `ratings` variable inside that `if` block. Now
    that we have a good understanding of the `Result` object, we can start adding
    repositories to our architecture.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模式匹配，我们可以检查 `Result` 对象的 `IsSuccess` 属性是否为 `true`，并在同一语句中，将 `Result` 对象的
    `Data` 属性赋值给 `ratings` 变量。这使得我们能够通过 `if` 块内部的 `ratings` 变量更轻松地访问 `Data` 属性。现在我们已经很好地理解了
    `Result` 对象，我们可以开始向我们的架构中添加仓库。
- en: Adding repository interfaces
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加仓库接口
- en: 'Let’s start adding repositories, the pieces of code that will directly interact
    with our API:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始添加仓库，这些代码片段将直接与我们的 API 交互：
- en: 'In the `Recipes.Client.Core` project, add an interface called `IRecipeRepository`
    to the `Features/Recipes` folder. Here’s what this interface looks like:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes.Client.Core` 项目中，将一个名为 `IRecipeRepository` 的接口添加到 `Features/Recipes`
    文件夹中。这个接口看起来是这样的：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This interface defines the contract that any class needs to implement in order
    to be able to fetch recipes from a data source. There are two methods defined
    in this interface: `LoadRecipes` and `LoadRecipe`. The first method returns a
    `LoadRecipesResponse` object, which is a response containing a paged collection
    of recipes. The second method returns a `RecipeDetail` object for a recipe identified
    by its ID. The return value of both of these methods is wrapped in a `Result`
    object, allowing us to deal with the fact that the requested data (temporarily)
    couldn’t be retrieved, for example.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此接口定义了任何类需要实现以从数据源获取菜谱的合同。在此接口中定义了两种方法：`LoadRecipes`和`LoadRecipe`。第一种方法返回一个`LoadRecipesResponse`对象，它包含一个分页的菜谱集合。第二种方法返回一个ID标识的`RecipeDetail`对象。这两种方法的返回值都包裹在`Result`对象中，使我们能够处理请求的数据（暂时）无法检索的情况。
- en: 'Head over to the `RecipeService` class and add a parameter of type `IRecipeRepository`
    to its constructor. A field is also added to keep a reference to this instance,
    as shown in the following snippet:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`RecipeService`类，并在其构造函数中添加一个类型为`IRecipeRepository`的参数。还添加了一个字段来保持对这个实例的引用，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As there isn’t much “business logic” going on in the `RecipeService` class,
    its methods should just call the injected repository’s methods and return their
    result. Have a look:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`RecipeService`类中几乎没有“业务逻辑”，其方法应该只是调用注入的仓库的方法并返回其结果。请看以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can add the same treatment to the `RatingsService` class: create a repository
    interface, add it as a dependency to the service, and call the interface’s methods
    from the `RatingsService` class’s methods. We’ll proceed as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的处理方式应用到`RatingsService`类中：创建一个仓库接口，将其作为依赖项添加到服务中，并在`RatingsService`类的方法中调用该接口的方法。我们将按以下步骤进行：
- en: 'Let’s create an `IRatingsRepository` interface for the `Features/Ratings` folder
    and add the following definitions to the newly created interface:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`Features/Ratings`文件夹中创建一个`IRatingsRepository`接口，并将以下定义添加到新创建的接口中：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are two methods defined in this interface: `GetRatings` and `GetRatingsSummary`.
    The first method returns a collection of `Rating` objects associated with the
    specified recipe ID. The second method returns a `RatingsSummary` for a recipe
    identified by its ID. As noted earlier, the return values are wrapped in a `Result`
    object.'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此接口中定义了两种方法：`GetRatings`和`GetRatingsSummary`。第一种方法返回与指定菜谱ID关联的`Rating`对象集合。第二种方法返回一个ID标识的菜谱的`RatingsSummary`。如前所述，返回值都包裹在`Result`对象中。
- en: 'Next, we add `IRatingsRepository` as a dependency of the `RatingsService` class,
    by defining it as a constructor parameter:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`IRatingsRepository`作为`RatingsService`类的依赖项添加，通过将其定义为构造函数参数：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, as the `RatingsService` class doesn’t contain any additional logic,
    this class will just call the repository’s methods, as you can see here:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于`RatingsService`类不包含任何额外的逻辑，这个类将只调用仓库的方法，正如您在这里看到的：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That leaves us with one service left to update: `FavoritesService`. Unlike
    the previous services that we’ve been updating, `FavoritesService` does contain
    some additional logic. But let’s first take a look at what the `IFavoritesRepository`
    interface looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下最后一个需要更新的服务：`FavoritesService`。与之前我们一直在更新的服务不同，`FavoritesService`确实包含一些额外的逻辑。但让我们首先看看`IFavoritesRepository`接口的样子：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This interface defines three methods: `LoadFavorites`, `Add`, and `Remove`.
    Since our favorites are stored on a centralized server, it’s essential to pass
    the user’s identifier (or `userId`) to the API. This ensures that favorites fetched,
    added, or removed are specific to that user. Neither the `Add` method nor the
    `Remove` method has an intrinsic return value. To be consistent with the rest
    of our APIs, we want to return a value wrapped in a `Result` object. That’s why
    a custom `Nothing` type is returned. This is just an empty struct, as you can
    see here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了三个方法：`LoadFavorites`、`Add`和`Remove`。由于我们的收藏夹存储在集中式服务器上，因此将用户的标识符（或`userId`）传递给API是必不可少的。这确保了获取、添加或删除的收藏夹是针对该用户的。`Add`方法或`Remove`方法没有固有的返回值。为了与我们的其他API保持一致，我们希望返回一个包裹在`Result`对象中的值。这就是为什么返回一个自定义的`Nothing`类型的原因。正如您在这里看到的，这只是一个空的struct：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s update the `FavoritesService` so that it leverages the `IFavoritesRepository`
    interface:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`FavoritesService`，使其利用`IFavoritesRepository`接口：
- en: Go ahead and add the `IFavoritesRepository` interface to the `Features/Favorites`
    folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IFavoritesRepository`接口添加到`Features/Favorites`文件夹。
- en: 'Update `FavoritesService` so that its constructor accepts a parameter of type
    `IFavoritesRepository`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `FavoritesService`，使其构造函数接受一个类型为 `IFavoritesRepository` 的参数：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`FavoritesService` keeps a list of the user’s favorites in memory. This in-memory
    list can easily be used in the `IsFavorite` method to rapidly check whether the
    given `recipeId` exists in the list. Here’s how we can load this list in memory:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FavoritesService` 在内存中保存用户喜欢的列表。这个内存中的列表可以很容易地在 `IsFavorite` 方法中使用，以快速检查给定的
    `recipeId` 是否存在于列表中。以下是我们在内存中加载此列表的方法：'
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `LoadList` method calls the `LoadFavorites` method on the `IFavoritesRepository`
    when the favorites list is `null`. The “dummy” `GetCurrentUserId` method provides
    a fake identifier for the given user of the app. In a real-life scenario, this
    could be retrieved from an injected service.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当喜欢列表为 `null` 时，`LoadList` 方法会在 `IFavoritesRepository` 上调用 `LoadFavorites` 方法。这个“虚拟”的
    `GetCurrentUserId` 方法为应用中给定的用户提供一个假的标识符。在实际场景中，这可以从注入的服务中检索。
- en: 'As said before, this in-memory list facilitates the implementation of the `IsFavorite`
    method, as shown in the next code block:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，这个内存中的列表有助于实现 `IsFavorite` 方法，如下一个代码块所示：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method calls the `LoadList` method, which will retrieve the favorites from
    the API if the in-memory list is `null`. When favorites have been loaded, we can
    check whether the list contains the given ID.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法调用 `LoadList` 方法，如果内存中的列表为 `null`，则从 API 获取喜欢的项目。当喜欢的项目被加载后，我们可以检查列表是否包含给定的
    ID。
- en: 'In contrast to the earlier services we discussed, where each method simply
    invoked a corresponding method in the injected repository, things are slightly
    more complex here due to the presence of an in-memory list. Also, because both
    the `Add` and `Remove` methods send a `FavoriteUpdateMessage` instance, they require
    some extra logic for implementation. Here’s how it’s done:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前讨论的早期服务不同，其中每个方法只是调用了注入的仓库中相应的方法，这里由于内存中列表的存在，事情稍微复杂一些。此外，由于 `Add` 和 `Remove`
    方法都发送一个 `FavoriteUpdateMessage` 实例，它们在实现上需要一些额外的逻辑。以下是它是如何完成的：
- en: 'The first thing to do in `FavoritesService`’s `Add` method is to call the repository’s
    `Add` method, passing in the (fake) `userId` value, as shown here:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FavoritesService` 的 `Add` 方法中要做的第一件事是调用仓库的 `Add` 方法，传入（假的）`userId` 值，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Add` method of the `IFavoritesRepository` returns a `Nothing` object wrapped
    in a `Result` object. Thanks to the `Result` object, we can check if the API call
    was successful or not. If that’s the case, we add the ID of the favorited recipe
    to the in-memory list of favorites and send the `FavoriteUpdateMessage` as shown
    here:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IFavoritesRepository` 的 `Add` 方法返回一个包裹在 `Result` 对象中的 `Nothing` 对象。多亏了 `Result`
    对象，我们可以检查 API 调用是否成功。如果是这样，我们将喜欢的菜谱的 ID 添加到内存中的喜欢列表中，并发送 `FavoriteUpdateMessage`，如下所示：'
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Remove` method is very similar:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Remove` 方法非常相似：'
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With all of our code in place, it’s time to add implementations for these repositories
    and make sure they get registered in the DI container.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有代码就绪后，是时候为这些仓库添加实现，并确保它们在 DI 容器中注册。
- en: Adding and registering repository implementations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和注册仓库实现
- en: 'There’s a dedicated project in which we can place the implementations of the
    repository interfaces. As these repositories will communicate to our API, I tend
    to use `ApiGateway` as the naming. Personally, I think this name perfectly illustrates
    its functionality. In the `Recipes.Client.Repositories` project, we can add three
    classes: `FavoritesApiGateway`, `RatingsApiGateway`, and `RecipeApiGateway`. These
    classes should implement the `IFavoritesRepository`, `IRatingsRepository`, and
    `IRecipeRepository` interfaces respectively. In the next section, we will be discussing
    how to effectively activate API communication using Refit.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以放置仓库接口实现的专用项目中。由于这些仓库将与我们自己的 API 进行通信，我倾向于使用 `ApiGateway` 作为命名。我个人认为这个名字完美地说明了其功能。在
    `Recipes.Client.Repositories` 项目中，我们可以添加三个类：`FavoritesApiGateway`、`RatingsApiGateway`
    和 `RecipeApiGateway`。这些类应分别实现 `IFavoritesRepository`、`IRatingsRepository` 和 `IRecipeRepository`
    接口。在下一节中，我们将讨论如何使用 Refit 有效地激活 API 通信。
- en: 'Now, let’s turn our attention to registering these repositories in the DI container.
    Instead of handling each registration in the `MauiProgram` class, we’ll delegate
    this task entirely to the code in the `Recipes.Client.Repositories` project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向将这些仓库注册到 DI 容器中。我们不会在 `MauiProgram` 类中处理每个注册，而是将这项任务完全委托给 `Recipes.Client.Repositories`
    项目的代码：
- en: Add the `Microsoft.Extensions.DependencyInjection.Abstractions` NuGet package
    to the `Recipes.Client.Repositories` project.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Microsoft.Extensions.DependencyInjection.Abstractions` NuGet 包添加到 `Recipes.Client.Repositories`
    项目中。
- en: 'In the `Recipes.Client.Repositories` project, add a `ServiceCollectionExtension`
    class. Here’s what this static class looks like:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes.Client.Repositories` 项目中，添加一个 `ServiceCollectionExtension` 类。以下是这个静态类的样子：
- en: '[PRE19]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class contains one method: `RegisterRepositories`. This method is an extension
    method that extends the `IServiceCollection` interface. To use `IServiceCollection`,
    ensure you’ve included the `Microsoft.Extensions.DependencyInjection` namespace,
    which is part of the NuGet package we added in the first step. This method is
    all about registering the repositories. Ending the method by returning the `services`
    instance allows us to adopt a builder pattern, enabling the chaining of additional
    extension methods.'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类包含一个方法：`RegisterRepositories`。这是一个扩展方法，它扩展了 `IServiceCollection` 接口。要使用 `IServiceCollection`，请确保你已经包含了
    `Microsoft.Extensions.DependencyInjection` 命名空间，这是我们在第一步中添加的 NuGet 包的一部分。这个方法完全是关于注册仓库的。通过在方法结束时返回
    `services` 实例，我们可以采用构建器模式，从而允许链式调用额外的扩展方法。
- en: 'Now, we can head over to the `MauiProgram.cs` file and add the following to
    the `CreateMauiApp` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以转到 `MauiProgram.cs` 文件，并在 `CreateMauiApp` 方法中添加以下内容：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `RegisterRepositories` extension method can only be resolved when the `Recipes.Client.Repositories`
    namespace is added.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RegisterRepositories` 扩展方法只能在添加了 `Recipes.Client.Repositories` 命名空间时才能解析。'
- en: With all of this in place, the services of our app now depend on repositories
    that will eventually communicate to the app’s API. The implementation of those
    repository interfaces and their registration is done in the dedicated `Recipes.Client.Repositories`
    project. This keeps everything organized and modular and ensures a clear separation
    of concerns, making our codebase more maintainable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，我们应用程序的服务现在依赖于最终将与应用程序 API 通信的仓库。这些仓库接口的实现及其注册是在专门的 `Recipes.Client.Repositories`
    项目中完成的。这保持了所有内容的组织和模块化，并确保了关注点的清晰分离，使我们的代码库更容易维护。
- en: Although we now have repositories that are being registered, they still lack
    communication with our API. Moreover, we registered the `RatingsApiGateway`, `RecipeApiGateway`,
    and `FavoritesApiGateway` classes, which don’t exist yet. Let’s see how we can
    add these and leverage Refit to make API requests and receive strongly typed responses,
    making it easier to handle errors and parse data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在已经注册了仓库，但它们仍然缺乏与我们的 API 的通信。此外，我们还注册了 `RatingsApiGateway`、`RecipeApiGateway`
    和 `FavoritesApiGateway` 类，这些类目前还不存在。让我们看看我们如何添加这些类，并利用 Refit 来进行 API 请求并接收强类型响应，这使得处理错误和解析数据变得更加容易。
- en: API communication with Refit
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Refit 进行 API 通信
- en: Up to this point, we’ve set up a neat architecture for our repositories, but
    they’re still missing the ability to talk to our API. To add this functionality,
    we could use `HttpClient` manually to make API calls and deserialize the response.
    While that’s entirely possible, it’s also cumbersome and prone to errors, not
    to mention it takes a lot of boilerplate code to get it right.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为我们的仓库设置了一个整洁的架构，但它们仍然缺少与我们的 API 通信的能力。为了添加这个功能，我们可以手动使用 `HttpClient`
    来进行 API 调用并反序列化响应。虽然这是完全可能的，但它也很繁琐且容易出错，更不用说它需要大量的样板代码才能正确实现。
- en: This is where Refit comes into the picture. Refit is a powerful library that
    simplifies API calls by providing a more declarative and less error-prone approach.
    Instead of writing tedious HTTP requests and responses, you just define a C# interface
    that maps to the API’s endpoints. Refit takes care of the underlying `HttpClient`
    calls, serialization, and deserialization for you, letting you focus on what matters
    – the logic of your application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Refit 发挥作用的地方。Refit 是一个强大的库，通过提供更声明式和更少错误的方法来简化 API 调用。你不需要编写繁琐的 HTTP 请求和响应，只需定义一个映射到
    API 端点的 C# 接口。Refit 会为你处理底层的 `HttpClient` 调用、序列化和反序列化，让你专注于最重要的部分——你应用程序的逻辑。
- en: In this section, we’ll see how Refit can make our life easier by reducing code
    complexity and increasing readability, while still offering customization options
    for more complex scenarios. So, let’s get our repositories talking to our API
    the smart way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到 Refit 如何通过减少代码复杂性和提高可读性来简化我们的工作，同时仍然为更复杂的场景提供定制选项。因此，让我们以智能的方式让我们的仓库与
    API 进行通信。
- en: Getting started with Refit
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Refit
- en: 'Refit is a type-safe REST client for .NET that allows you to easily make API
    calls by defining an interface. You annotate the interface methods with HTTP attributes
    such as `[Get]`, `[Post]`, and so on, specifying the API endpoints. Refit is then
    able to generate the implementation for you, turning those interface methods into
    API calls. Let’s take a look at an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Refit 是一个类型安全的 .NET REST 客户端，允许您通过定义接口轻松地执行 API 调用。您使用 HTTP 属性（如 `[Get]`、`[Post]`
    等）注释接口方法，指定 API 端点。然后 Refit 能够为您生成实现，将这些接口方法转换为 API 调用。让我们看看一个例子：
- en: 'First, we need to define the API endpoints we’ll be interacting with by declaring
    an interface:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过声明一个接口来定义我们将与之交互的 API 端点：
- en: '[PRE21]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `IRecipeApi` interface defines an API call for fetching a single recipe
    by its ID. The `Refit.Get` attribute is used to define an `HTTP GET` method for
    a specific endpoint. The `{recipeId}` portion of the endpoint specifies a path
    parameter that is used to pass the `recipeId` parameter to the method. When the
    `GetRecipe` method is called with a recipe ID, we want the Refit library to send
    an `HTTP GET` request to the specified endpoint, replacing the `{recipeId}` portion
    of the endpoint with the specified ID.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`IRecipeApi` 接口定义了一个通过其 ID 获取单个菜谱的 API 调用。使用 `Refit.Get` 属性来定义一个针对特定端点的
    `HTTP GET` 方法。端点中的 `{recipeId}` 部分指定了一个路径参数，用于将 `recipeId` 参数传递给方法。当使用菜谱 ID 调用
    `GetRecipe` 方法时，我们希望 Refit 库向指定的端点发送一个 `HTTP GET` 请求，并将端点的 `{recipeId}` 部分替换为指定的
    ID。
- en: 'Secondly, we use `RestService.For` to generate an implementation of your interface,
    as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们使用 `RestService.For` 生成接口的实现，如下所示：
- en: '[PRE22]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This single line of code creates an object that knows how to make the API calls
    defined in `IRecipeApi`. This `RestService.For` method accepts a string parameter
    that defines the base URL of the API. Alternatively, an instance of `HttpClient`
    can be passed as a parameter, instead of the string value. Refit will use the
    given `HttpClient` to communicate with the API. Later on in the chapter, we’ll
    see why passing in an `HttpClient` can be useful.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行代码创建了一个知道如何调用 `IRecipeApi` 中定义的 API 调用的对象。`RestService.For` 方法接受一个字符串参数，用于定义
    API 的基本 URL。或者，也可以传递 `HttpClient` 的实例作为参数，而不是字符串值。Refit 将使用提供的 `HttpClient` 与
    API 进行通信。在章节的后面部分，我们将看到为什么传递 `HttpClient` 可能是有用的。
- en: 'Finally, we can use the generated object to make API calls and handle the responses,
    as the following code snippet demonstrates:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用生成的对象来执行 API 调用并处理响应，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This would just return the deserialized object. I prefer the approach that returns
    `ApiResponse<T>` because it provides a fuller picture of what’s happening during
    the API interaction, which is crucial for robust error handling and insightful
    logging.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将只返回反序列化的对象。我更喜欢返回 `ApiResponse<T>` 的方法，因为它提供了关于 API 交互过程中发生情况的更全面的信息，这对于健壮的错误处理和有洞察力的日志记录至关重要。
- en: 'And there you have it: three simple steps to replace what would have otherwise
    been much more boilerplate code. Now, let’s get back to our *Recipes!* app and
    put this into practice.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们就完成了三个简单的步骤，替换了原本可能需要更多样板代码的情况。现在，让我们回到我们的 *Recipes!* 应用程序，并将这些应用到实践中。
- en: Creating API interfaces
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 API 接口
- en: 'Let’s add API interfaces to the `Recipes.Client.Repositories` project. Later
    on, we will be using them together with Refit to generate the required code to
    effectively communicate to the API:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Recipes.Client.Repositories` 项目中添加 API 接口。稍后，我们将与 Refit 一起使用它们来生成与 API
    通信所需的代码：
- en: In the `Recipes.Client.Repositories` project and select `Api`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes.Client.Repositories` 项目中选择 `Api`。
- en: 'Add an interface called `IFavoritesApi` to the newly created folder. The following
    code snippet shows what this interface looks like:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件夹中添加一个名为 `IFavoritesApi` 的接口。下面的代码片段显示了该接口的外观：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This interface maps directly to the API endpoints responsible for managing
    user favorites. The `Get`, `Post` and `Delete` attributes specify the HTTP methods
    that should be used for each API call. Parameters such as `userId` that appear
    in the URL are automatically populated from the method arguments. Notice the `favorite`
    parameter in the `AddFavorite` method. This parameter is not part of the defined
    endpoint URL; instead, it gets serialized and sent as the request body. Alternatively,
    it’s also possible to explicitly indicate that the favorite parameter needs to
    be sent in the message’s body by using the `Body` attribute. This is what that
    looks like:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个接口直接映射到负责管理用户收藏的 API 端点。`Get`、`Post` 和 `Delete` 属性指定了每个 API 调用应使用的 HTTP 方法。出现在
    URL 中的参数，如 `userId`，将自动从方法参数中填充。注意 `AddFavorite` 方法中的 `favorite` 参数。这个参数不是定义的端点
    URL 的一部分；相反，它被序列化并发送为请求体。或者，也可以通过使用 `Body` 属性显式地指出需要将收藏参数发送到消息体中。这看起来是这样的：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: public interface IRatingsApi
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public interface IRatingsApi
- en: '{'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '[Get("/recipe/{recipeId}/ratings")]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Get("/recipe/{recipeId}/ratings")]'
- en: Task<ApiResponse<RatingDto[]>> GetRatings(
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Task<ApiResponse<RatingDto[]>> GetRatings(
- en: string recipeId);
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: string recipeId);
- en: '[Get("/recipe/{recipeId}/ratingssummary")]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Get("/recipe/{recipeId}/ratingssummary")]'
- en: Task<ApiResponse<RatingsSummaryDto>>
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Task<ApiResponse<RatingsSummaryDto>>
- en: GetRatingsSummary(string recipeId);
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GetRatingsSummary(string recipeId);
- en: '}'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, let’s define the `IRecipeApi` interface:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义 `IRecipeApi` 接口：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you probably know by now, as with the previous ones, this interface also
    maps to certain API endpoints. The `pageSize` and `pageIndex` parameters of the
    `GetRecipes` method don’t appear in the endpoint of the `Get` attribute. As a
    result, they will be added as query string parameters when doing the request.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您现在可能已经知道的那样，与之前的接口一样，这个接口也映射到某些 API 端点。`GetRecipes` 方法的 `pageSize` 和 `pageIndex`
    参数没有出现在 `Get` 属性的端点中。因此，在执行请求时，它们将作为查询字符串参数添加。
- en: With our API interfaces defined, it’s finally time to bridge the gap between
    our repositories and the actual API calls.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了我们的 API 接口之后，现在是时候弥合我们的存储库和实际 API 调用之间的差距了。
- en: Integrating Refit
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成 Refit
- en: 'Let’s integrate Refit into our repositories to make the API calls a breeze.
    It all starts with adding the Refit NuGet package to the `Recipes.Client.Repositories`
    project. To make integrating Refit even easier and avoid duplicate code later
    on, let’s first add a new `ApiGateway` abstract class to the `Recipes.Client.Repositories`
    project. The purpose of this class is to help us in executing a call and mapping
    the `ApiResponse` result to another type. This is what the `InvokeAndMap` method’s
    signature looks like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Refit 集成到我们的存储库中，使 API 调用变得轻松。一切从向 `Recipes.Client.Repositories` 项目添加 Refit
    NuGet 包开始。为了使集成 Refit 更加容易并避免以后重复代码，让我们首先在 `Recipes.Client.Repositories` 项目中添加一个新的
    `ApiGateway` 抽象类。这个类的作用是帮助我们执行调用并将 `ApiResponse` 结果映射到另一个类型。`InvokeAndMap` 方法的签名如下所示：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This method returns a `Task<TResult>` object and takes in two parameters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个 `Task<TResult>` 对象并接受两个参数：
- en: The `call` parameter is the API call to make, which returns an `ApiResponse<TDtoResult>`
    object
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`call` 参数是要执行的 API 调用，它返回一个 `ApiResponse<TDtoResult>` 对象'
- en: The `mapper` parameter is a method that takes in the `TDtoResult` object from
    the response and maps it to the `TResult` object that the `InvokeAndMap` method
    returns
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapper` 参数是一个方法，它接受响应中的 `TDtoResult` 对象并将其映射到 `InvokeAndMap` 方法返回的 `TResult`
    对象'
- en: 'The implementation is fairly straightforward: the method must execute the provided
    `call` parameter. If the resulting `ApiResponse` instance indicates success, the
    passed-in `mapper` parameter will be used to map the result from `TDtoResult`
    to `TResult`, which is wrapped in a `Result` object that indicates success. If
    the response doesn’t indicate success, a failed result is returned, containing
    the response’s status code. The following code block shows how it’s done:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当直接：方法必须执行提供的 `call` 参数。如果 resulting `ApiResponse` 实例表示成功，则将使用传入的 `mapper`
    参数将结果从 `TDtoResult` 映射到 `TResult`，并将其包装在一个表示成功的 `Result` 对象中。如果响应不表示成功，则返回一个失败的结果，其中包含响应的状态码。下面的代码块显示了如何实现：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On top of that, we also need to be wary of potential exceptions being thrown,
    which we can handle as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要警惕可能抛出的潜在异常，我们可以像下面这样处理：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When an exception occurs, we should return a `Result` object that indicates
    failure, containing relevant data about the exception.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生异常时，我们应该返回一个 `Result` 对象，该对象表示失败，并包含有关异常的相关数据。
- en: A note on robustness
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于鲁棒性的说明
- en: 'When developing mobile applications, it’s important to remember that network
    conditions can be unpredictable. Mobile devices might move between different network
    zones, causing unstable connections. As a best practice, always consider implementing
    resilience patterns such as `ApiGateway` class is the perfect spot to add this
    kind of retry logic instead of directly returning a `Fail` result. Find out more
    about Polly here: [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发移动应用程序时，重要的是要记住网络条件可能是不可预测的。移动设备可能会在不同的网络区域之间移动，导致连接不稳定。作为一个最佳实践，始终考虑实现弹性模式，例如，在`ApiGateway`类中添加这种重试逻辑而不是直接返回一个`Fail`结果是完美的位置。更多关于Polly的信息请在这里了解：[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)。
- en: 'In situations where the data type returned by the API interface is identical
    to the type we wish to encapsulate in a `Result` object, we can provide an overloaded
    `InvokeAndMap` method that eliminates the need for a type mapper. This is particularly
    useful when dealing with primitive types. The following snippet shows this overload:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在API接口返回的数据类型与我们希望封装在`Result`对象中的类型相同的情况下，我们可以提供一个重载的`InvokeAndMap`方法，从而消除对类型映射器的需求。这在处理原始类型时特别有用。以下代码片段显示了这种重载：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This base class will drastically simplify the mapping of a DTO returned by
    the API to a domain entity that gets encapsulated in a `Result` object. Now, let’s
    have a look at how we can utilize this `InvokeAndMap` method in our repositories:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类将极大地简化将API返回的DTO映射到封装在`Result`对象中的域实体的过程。现在，让我们看看我们如何在我们的仓库中利用这个`InvokeAndMap`方法：
- en: 'First, make sure that all of our repositories (`FavoritesApiGateway`, `RatingsApiGateway`,
    and `RecipeApiGateway`) inherit this abstract `ApiGateway` class by adding the
    following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保所有我们的仓库（`FavoritesApiGateway`、`RatingsApiGateway`和`RecipeApiGateway`）通过添加以下代码继承这个抽象的`ApiGateway`类：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, each of these repositories should get its corresponding API interface
    injected through its constructor. Let’s see what this looks like for `RatingsApiGateway`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，这些仓库中的每一个都应该通过其构造函数注入相应的API接口。让我们看看`RatingsApiGateway`的例子：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The injected `IRatingsApi` interface can now be used to do the network calls
    and retrieve the requested data from the API. The following code block shows the
    implemented `GetRatings` method:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注入的`IRatingsApi`接口现在可以用来进行网络调用并从API检索所需的数据。以下代码块显示了实现的`GetRatings`方法：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `GetRatings` method calls the `InvokeAndMap` method of the base class.
    The `GetRatings` API call is passed in as a parameter, as well as the `MapRatings`
    method, which maps the `RatingDto` array returned by the API to an `IReadOnlyCollection`
    of `Rating` objects. The `MapRatings` method is a static method on the static
    `RatingsMapper` class. We can directly access `RatingsMapper`’s static mapping
    methods inside this class without explicitly needing to prepend its name because
    the following `using` statement is added to the class:'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetRatings`方法调用基类的`InvokeAndMap`方法。将`GetRatings` API调用作为参数传递，以及`MapRatings`方法，它将API返回的`RatingDto`数组映射到`Rating`对象的`IReadOnlyCollection`。`MapRatings`方法是在静态`RatingsMapper`类上的静态方法。我们可以在类内部直接访问`RatingsMapper`的静态映射方法，而无需显式地在其名称前添加，因为以下`using`语句被添加到了类中：'
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can now do the exact same thing for the `GetRatingsSummary` method on this
    class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以为这个类的`GetRatingsSummary`方法做完全相同的事情：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Analogous to the previous examples, the implementation of the `FavoritesApiGateway`
    class can be done following the same pattern: inject the `IFavoritesApi` interface
    and use its methods to retrieve data from the API, leveraging the `InvokeAndMap`
    method of the `ApiGateway` base class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前面的示例类似，`FavoritesApiGateway`类的实现可以遵循相同的模式：注入`IFavoritesApi`接口并使用其方法从API检索数据，利用`ApiGateway`基类的`InvokeAndMap`方法：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'All of these methods in the `FavoritesApiGateway` use the overloaded `InvokeAndMap`
    method, which doesn’t do additional mapping: the data type returned by the API
    interface is the same as the one the repository returns, but it’s encapsulated
    in a `Result` object.'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`FavoritesApiGateway`中的所有这些方法都使用了重载的`InvokeAndMap`方法，该方法不执行额外的映射：API接口返回的数据类型与仓库返回的类型相同，但它被封装在一个`Result`对象中。
- en: 'The implementation of the `RecipeApiGateway` class shouldn’t contain any surprises;
    it only contains more mapping. But at its core, it follows the exact same pattern
    as the previous two classes. First, a field of type `IRecipeApi` needs to be added
    as a member and constructor parameter, as the following snippet shows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RecipeApiGateway`类的实现不应该有任何惊喜；它只包含更多的映射。但就其核心而言，它遵循与前面两个类完全相同的模式。首先，需要添加一个类型为`IRecipeApi`的字段作为成员和构造函数参数，如下面的代码片段所示：'
- en: '[PRE38]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `LoadRecipes` method and the mappings it uses look like this:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LoadRecipes`方法和它使用的映射看起来是这样的：'
- en: '[PRE39]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`LoadRecipes` calls the `InvokeAndMap` method, passing in the `GetRecipes`
    method of the API interface. The `MapRecipesOverview` method is used to map the
    resulting object of type `RecipesOverviewItemsDto` to a `LoadRecipesResponse`
    object.'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LoadRecipes`调用`InvokeAndMap`方法，传入API接口的`GetRecipes`方法。`MapRecipesOverview`方法用于将类型为`RecipesOverviewItemsDto`的结果对象映射到`LoadRecipesResponse`对象。'
- en: 'And finally, we can implement the `LoadRecipe` method. It can use the `GetRecipe`
    method of the `IRecipeApi` to get the data. The result will be mapped using the
    static `MapRecipe` method of the static `RecipeMapper` class. Take a look:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`LoadRecipe`方法。它可以使用`IRecipeApi`的`GetRecipe`方法来获取数据。结果将使用静态`RecipeMapper`类的静态`MapRecipe`方法进行映射。看看这个：
- en: '[PRE40]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also need to update our `ServiceCollectionExtension` class. Because every
    repository now has a dependency on a particular API interface, we need to make
    sure these dependencies get registered as well. But first, we might want to add
    a new `RepositorySettings` class to the `Recipes.Client.Repositories` project.
    This class should be a way to pass settings from the app to the repositories,
    such as a specific `HttpClient` instance that needs to be used, for example. As
    the following code block shows, there’s not much to this class for this particular
    demo project. But in more complex applications, things such as particular serialization
    or authentication settings can be added here as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`ServiceCollectionExtension`类。因为每个仓库现在都依赖于特定的API接口，我们需要确保这些依赖也被注册。但首先，我们可能想要在`Recipes.Client.Repositories`项目中添加一个新的`RepositorySettings`类。这个类应该是一种将设置从应用传递到仓库的方式，例如，需要使用特定`HttpClient`实例的情况。如下面的代码块所示，对于这个特定的演示项目，这个类并没有多少内容。但在更复杂的应用中，可以在这里添加诸如特定的序列化或认证设置等。
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s fit the final pieces of the puzzle together, update the `ServiceCollectionExtension`,
    and call it from our app. Here’s what we need to do:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些拼图的最后几块拼在一起，更新`ServiceCollectionExtension`，并在我们的应用中调用它。以下是我们需要做的：
- en: Add the `RepositorySettings` class, as shown earlier, to the `Recipes.Client.Repositories`
    project.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面提到的`RepositorySettings`类添加到`Recipes.Client.Repositories`项目中。
- en: 'Add a parameter of type `RepositorySettings` to the `RegisterRepositories`
    extension method of the `ServiceCollectionExtension` class, as shown here:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ServiceCollectionExtension`类的`RegisterRepositories`扩展方法中添加一个类型为`RepositorySettings`的参数，如下所示：
- en: '[PRE42]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we saw earlier, Refit’s `RestService.For` method can be used to generate
    implementations of the API interfaces. The following snippet shows how we can
    register the generated implementations in the DI container:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Refit的`RestService.For`方法可以用来生成API接口的实现。以下代码片段展示了我们如何将生成的实现注册到DI容器中：
- en: '[PRE43]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `RestService.For` method accepts an instance of `HttpClient` that will be
    used by Refit to do the API communication. An `HttpClient`, should be configured
    in the app and passed-in via the `RepositorySettings`.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RestService.For`方法接受一个`HttpClient`实例，该实例将由Refit用于API通信。`HttpClient`应该在应用中进行配置并通过`RepositorySettings`传入。'
- en: 'Finally, in the `MauiProgram` class, we can call the updated `RegisterRepositories`
    and pass-in a configured `HttpClient` as shown here:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MauiProgram`类中，我们可以调用更新的`RegisterRepositories`并传入一个配置好的`HttpClient`，如下所示：
- en: '[PRE44]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As the Android emulator runs in an isolated network environment behind a virtual
    router, it cannot directly access the development machine using `localhost`. Instead,
    the emulator provides a special `10.0.2.2` alias that routes to the development
    machine’s loopback interface, enabling you to access local web services.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于Android模拟器在虚拟路由器后的隔离网络环境中运行，它不能直接使用`localhost`访问开发机器。相反，模拟器提供了一个特殊的`10.0.2.2`别名，该别名路由到开发机器的环回接口，使您能够访问本地网络服务。
- en: The `Recipes.Mobile` project contains an `HttpClientHelper` class that configures
    an `HttpClient` instance to be used for connecting to local web services. This
    is needed as some additional configuration specific to each platform needs to
    be done in order to effectively communicate to web services hosted locally.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Recipes.Mobile` 项目包含一个 `HttpClientHelper` 类，该类配置一个 `HttpClient` 实例以用于连接到本地网络服务。这是必要的，因为需要对每个平台进行一些特定的配置，以便有效地与本地托管的服务进行通信。'
- en: Connecting to local web services
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到本地网络服务
- en: 'While developing software, it’s typical to run a local web service and access
    it using an app in either an Android emulator or an iOS simulator. Some additional
    configuration is needed in order for the app to communicate with your local web
    service. More information about connecting to a local web service and how to configure
    each platform can be found here: [https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services](https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发软件时，通常需要在 Android 模拟器或 iOS 模拟器中运行本地网络服务，并使用应用访问它。为了使应用能够与你的本地网络服务通信，需要一些额外的配置。有关连接到本地网络服务以及如何配置每个平台的更多信息，请参阅此处：[https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services](https://learn.microsoft.com/dotnet/maui/data-cloud/local-web-services)。
- en: If you want to debug the *Recipes!* app, we need to tell Visual Studio to run
    both the mobile app and the API. To do this, right-click **Solution ‘Recipes App’**
    in the **Solution Explorer** and select **Properties**. In the pop-up, select
    **Multiple startup projects** and set the **Action** of both the **Recipes.Mobile**
    and **Recipes.Web.Api** projects to **Start**.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要调试 *Recipes!* 应用，我们需要告诉 Visual Studio 同时运行移动应用和 API。为此，在 **Solution Explorer**
    中右键单击 **Solution ‘Recipes App’** 并选择 **Properties**。在弹出的窗口中，选择 **Multiple startup
    projects** 并将 **Recipes.Mobile** 和 **Recipes.Web.Api** 项目的 **Action** 设置为 **Start**。
- en: As we wrap up this chapter, let’s briefly turn our attention to how we can call
    APIs from ViewModels, deal with loading indicators, and handle potential errors,
    all while providing a seamless user experience.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，让我们简要地关注一下我们如何从 ViewModels 调用 API、处理加载指示器以及处理潜在的错误，同时提供无缝的用户体验。
- en: API communication from ViewModels
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 ViewModels 发送的 API 通信
- en: When navigating to the `RecipeDetailPage`, you’ll see some data on the screen
    while the recipe is being loaded. The data being shown is the values defined as
    `FallbackValue` or `TargetNullValue` in the binding statements as a result of
    the data in `RecipeDetailViewModel` not being loaded yet. Although effective,
    I don’t think it looks pretty. Let’s see how we can improve this by showing a
    loading indicator while the data is being loaded.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到 `RecipeDetailPage` 时，你会看到屏幕上显示一些数据，同时正在加载数据。显示的数据是绑定语句中定义的 `FallbackValue`
    或 `TargetNullValue` 的值，这是由于 `RecipeDetailViewModel` 中的数据尚未加载。虽然有效，但我认为它看起来不太美观。让我们看看我们如何在数据加载时显示加载指示器来改进这一点。
- en: Showing a loading indicator
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示加载指示器
- en: 'One of the simplest yet effective ways to improve user experience is to provide
    visual feedback during API calls. Consider the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提高用户体验的最简单有效的方法之一是在 API 调用期间提供视觉反馈。考虑以下代码片段：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we set the `IsLoading` property of the `RecipeDetailViewModel` to `true`
    before we start loading the data and it is reverted back to `false` afterward.
    Thanks to the use of `async`/`await`, the UI thread is not blocked during this
    operation, allowing UI elements such as loading indicators to be updated and rendered.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在开始加载数据之前将 `RecipeDetailViewModel` 的 `IsLoading` 属性设置为 `true`，并在之后将其还原为
    `false`。多亏了 `async`/`await` 的使用，在此操作期间 UI 线程不会被阻塞，允许更新和渲染 UI 元素，如加载指示器。
- en: 'You can bind this property to a loading spinner in your XAML like so:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此属性绑定到 XAML 中的加载旋转器，如下所示：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As a result of this setup, whenever the API call – or any long-running process,
    for that matter – is in progress, the user receives a visual cue, indicating that
    the app is currently busy. In the preceding example, we’ve used a `Grid` property
    that overlays the entire page and contains an `ActivityIndicator`. However, you’re
    not limited to this approach; you could also use a message, an animation, or any
    other UI element that best suits your app’s design and user experience.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设置，每当 API 调用——或者任何长时间运行的过程——正在进行时，用户会收到一个视觉提示，表明应用当前正忙。在上一个示例中，我们使用了 `Grid`
    属性，它覆盖了整个页面并包含一个 `ActivityIndicator`。然而，你并不局限于这种方法；你也可以使用消息、动画或任何其他最适合你应用设计和用户体验的
    UI 元素。
- en: Using a property to indicate that a task is in progress, and binding this property
    to the UI, is a common MVVM pattern for managing longer-running operations. The
    responsiveness is made possible by the `async`/`await` construct, which keeps
    the UI thread unblocked, allowing for a smoother user experience.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个属性来指示任务正在进行中，并将此属性绑定到UI，是管理长时间运行操作的一种常见的MVVM模式。响应性是通过`async`/`await`构造实现的，它保持UI线程不被阻塞，从而提供更流畅的用户体验。
- en: Earlier in this chapter, we already saw how the `Result` object can help us
    elegantly handle successful and unsuccessful results. Now, let’s take it a step
    further by enhancing the user experience by handling a `Result` object that indicates
    failure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们已经看到了`Result`对象如何帮助我们优雅地处理成功和失败的结果。现在，让我们更进一步，通过处理表示失败的`Result`对象来增强用户体验。
- en: Handling failures
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理失败
- en: 'Earlier in this chapter, we introduced the `Result` object as a way to elegantly
    handle failures. The object’s `IsSuccess` property indicates whether an operation
    is completed successfully or not. We’ve already seen that in successful cases,
    the `Data` property gives us access to the result. However, when `IsSuccess` is
    `false`, it’s crucial not to leave the user guessing. Instead, we should provide
    clear feedback and offer a way to resolve the issue. Let’s see how this is tackled
    in the `LoadRecipes` method of `RecipesOverviewViewModel`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期部分，我们介绍了`Result`对象作为优雅处理失败的一种方式。对象的`IsSuccess`属性指示操作是否成功完成。我们已经看到，在成功的情况下，`Data`属性为我们提供了访问结果的方式。然而，当`IsSuccess`为`false`时，至关重要的是不要让用户猜测。相反，我们应该提供清晰的反馈并提供解决问题的方法。让我们看看这是如何在`RecipesOverviewViewModel`的`LoadRecipes`方法中解决的：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, when the task isn’t successful, the `LoadFailed` property is
    set to `true`. Also, the `ReloadCommand` property gets initialized. The following
    code block shows how both properties are data-bound to the UI and will provide
    the user with some information and the ability to retry loading the list of recipes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当任务未成功时，`LoadFailed`属性被设置为`true`。此外，`ReloadCommand`属性被初始化。下面的代码块展示了这两个属性如何与UI数据绑定，并将为用户提供一些信息和重新加载食谱列表的能力：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Additionally, we could show a custom error message to the user when a specific
    failure occurs. The `ErrorMessage`, `ErrorCode`, and `Exception` properties of
    the `Result` object could be used for that. This approach eliminates the need
    for scattering various exception-handling blocks throughout our ViewModels, thereby
    creating a more streamlined, readable, and maintainable code base.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当发生特定失败时，我们还可以向用户显示自定义错误消息。`Result`对象的`ErrorMessage`、`ErrorCode`和`Exception`属性可以用于此目的。这种方法消除了在ViewModel中散布各种异常处理块的需要，从而创建了一个更流畅、可读性和可维护性更强的代码库。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We kicked off this chapter by revisiting the architecture of our *Recipes!*
    app to include repositories. This addition was aimed at adhering to the principle
    of SoC and minimizing our app’s dependency on the API itself. We also introduced
    the `Result` object, a transformative component in our error-handling strategy.
    This single object encapsulates both success and failure states, making our ViewModels
    more robust and intelligible. By using the `Result` object, we’ve made it easier
    to handle anticipated errors in a graceful manner, while still keeping exceptions
    reserved for critical failures.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过回顾我们的*Recipes!*应用架构，并包含存储库来开启本章。这次增加是为了遵循SoC原则并最小化我们的应用对API本身的依赖。我们还引入了`Result`对象，这是我们错误处理策略中的一个变革性组件。这个单一的对象封装了成功和失败状态，使我们的ViewModel更加健壮和易于理解。通过使用`Result`对象，我们使优雅地处理预期错误变得更加容易，同时仍然保留异常用于关键性故障。
- en: After setting this architectural foundation, we moved on to explore the power
    and simplicity of Refit, a type-safe REST client. Refit has substantially streamlined
    the way we interact with APIs, making the code more readable and maintainable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立这个架构基础之后，我们继续探索Refit的强大和简单性，Refit是一个类型安全的REST客户端。Refit极大地简化了我们与API交互的方式，使代码更易于阅读和维护。
- en: We also looked at how the `Result` object elegantly fits into our ViewModels,
    making it far easier to handle expected errors and providing a uniform approach
    to error management. Alongside this, we discussed practical UI considerations,
    including loading indicators and error overlays, to offer the user an engaging
    and informative experience.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 `Result` 对象如何优雅地融入我们的 ViewModels，这使得处理预期错误变得更容易，并提供了统一的方法来管理错误。与此同时，我们讨论了实用的
    UI 考虑因素，包括加载指示器和错误覆盖层，以提供吸引用户并富有信息性的体验。
- en: You should now have a solid understanding of how to make API calls, manage responses,
    and provide real-time user feedback, all in a resilient and easily maintainable
    way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经对如何进行 API 调用、管理响应以及以弹性和易于维护的方式提供实时用户反馈有了稳固的理解。
- en: In the next chapter, we will be looking at how to create MVVM-friendly controls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建适合 MVVM 的控件。
- en: Further reading
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Refit documentation: [https://reactiveui.github.io/refit/](https://reactiveui.github.io/refit/)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Refit 文档：[https://reactiveui.github.io/refit/](https://reactiveui.github.io/refit/)
- en: 'Consuming a REST-based web service with `HttpClient`: [https://learn.microsoft.com/dotnet/maui/data-cloud/rest](https://learn.microsoft.com/dotnet/maui/data-cloud/rest)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `HttpClient` 消费基于 REST 的 Web 服务：[https://learn.microsoft.com/dotnet/maui/data-cloud/rest](https://learn.microsoft.com/dotnet/maui/data-cloud/rest)
- en: 'Part 3: Mastering MVVM Development'
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：掌握 MVVM 开发
- en: This final part is all about refining and hardening your .NET MAUI app. We will
    delve deep into crafting controls that seamlessly integrate with MVVM. You will
    learn how to expand your app's reach with techniques for localization and fortify
    your code base with robust unit testing, ensuring stability and reliability. And
    when things don't go as planned, you will be able to rely on valuable troubleshooting
    and debugging tips to steer back on course.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分主要介绍如何精炼和加固你的 .NET MAUI 应用。我们将深入探讨如何制作与 MVVM 无缝集成的控件。你将学习如何通过本地化技术扩展你应用的范围，并通过强大的单元测试加固你的代码库，确保稳定性和可靠性。当事情没有按计划进行时，你将能够依赖有价值的故障排除和调试技巧来重新回到正确的轨道。
- en: 'This part has the following chapters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B20941_11.xhtml#_idTextAnchor182), *Creating MVVM-Friendly Controls*'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B20941_11.xhtml#_idTextAnchor182)，*创建适合 MVVM 的控件*'
- en: '[*Chapter 12*](B20941_12.xhtml#_idTextAnchor196), *Localization with MVVM*'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B20941_12.xhtml#_idTextAnchor196)，*使用 MVVM 进行本地化*'
- en: '[*Chapter 13*](B20941_13.xhtml#_idTextAnchor223), *Unit Testing*'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B20941_13.xhtml#_idTextAnchor223)，*单元测试*'
- en: '[*Chapter 14*](B20941_14.xhtml#_idTextAnchor238), *Troubleshooting and Debugging
    Tips*'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B20941_14.xhtml#_idTextAnchor238)，*故障排除和调试技巧*'
