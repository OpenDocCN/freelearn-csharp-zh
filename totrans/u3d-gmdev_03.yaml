- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程
- en: 'Welcome to Chapter 3! We are going to cover all the basics of C# and how to
    use it in Unity. We’ll go over the primary chunk of programming knowledge required
    for most projects. This chapter should serve as a referenceable chapter throughout
    the rest of the book when we get into scripting in each future chapter. We will
    first need to begin by ensuring that your computer’s environment is set up to
    start programming with Unity and then flow into the fundamentals of programming.
    This chapter will serve as a foundational lynchpin to your Unity projects. Topics
    include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第3章！我们将涵盖C#的所有基础知识以及如何在Unity中使用它。我们将回顾大多数项目所需的编程知识的主要部分。当我们在每个未来的章节中进行脚本编写时，本章应作为可参考的章节。我们首先需要确保您的计算机环境已设置好，以便开始使用Unity进行编程，然后进入编程的基础知识。本章将作为您Unity项目的基石。包括以下主题：
- en: Setting up the environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Data types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Programming logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程逻辑
- en: Methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Setting up the environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Programming environment specifically refers to the **Integrated Development
    Environment** (**IDE**) that you will use, and the dependencies associated with
    it. C# is part of .NET Framework from Microsoft, which needs to be installed on
    your machine to work. Luckily for us, many of the IDEs in the world will install
    that for you when you start working in C#. Even more luckily for us, Visual Studio,
    if installed from Unity Hub, is preconfigured and you can get right to developing
    your project straight away! Let’s go through the steps to see how you can set
    up your environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编程环境特指您将使用的**集成开发环境**（**IDE**）以及与之相关的依赖项。C#是微软.NET框架的一部分，需要在您的机器上安装才能工作。幸运的是，对于世界上的许多IDE来说，当您开始用C#工作时会为您安装它。更幸运的是，如果您从Unity
    Hub安装，Visual Studio将预先配置好，您可以立即开始开发您的项目！让我们一步步看看您如何设置您的环境。
- en: The Unity environment
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity环境
- en: Microsoft Visual Studio is free, directly connects to Unity, and comes with
    tools to help you right off the bat! This is like needing to work on your car
    and someone just hands you the right tool for what you need as you put your hand
    in the engine bay.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Visual Studio是免费的，可以直接连接到Unity，并附带一些工具，可以帮助您立即开始工作！这就像需要修理您的汽车，有人正好在你把手伸进引擎舱时给你正确的工具。
- en: There are some steps to ensure that every application is talking to each other.
    Let’s walk through them together so we can ensure we’re on the same page moving
    through the book as well as the rest of this chapter; we will work through small
    snippets of code right away. No need to check the water’s temperature, let’s dive
    in!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每个应用程序都能相互通信有一些步骤。让我们一起来了解一下，这样我们就可以确保我们在阅读本书以及本章的其余部分时处于同一页面上；我们将立即通过一些小的代码片段来工作。无需检查水温，让我们直接跳入！
- en: Install Unity Hub by googling `Unity Hub` and selecting the top link. This will
    take you to the official Unity webpage where you can download Unity Hub. After
    installing the hub, you will need to install a version of Unity to use.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过谷歌搜索“Unity Hub”并选择顶部链接来安装Unity Hub。这将带您到官方Unity网页，您可以下载Unity Hub。安装好Hub后，您需要安装一个Unity版本来使用。
- en: As the previous chapter explained the version of Unity, we are going to recommend
    production using the latest LTS version. In Unity Hub, when you’re installing
    a version of Unity and if you do not have Visual Studio installed, there will
    be an option to install it for you preconfigured. In *Figure 3.1* below, you can
    see that we already have Visual Studio installed, however, if you do not, there
    will be a checkbox next to it to select it. It will then install the application
    for you ready to go!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们将推荐使用最新的LTS版本进行生产。在Unity Hub中，当您安装Unity版本且未安装Visual Studio时，将有一个选项为您预先配置安装。在下图3.1中，您可以看到我们已安装了Visual
    Studio，但如果您没有安装，旁边将有一个复选框供您选择。然后它会为您安装好应用程序，准备使用！
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_03_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_03_01.png)'
- en: 'Figure 3.1: Unity Hub Install Unity modal'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Unity Hub安装Unity模式
- en: If you didn’t have Visual Studio installed, then this will take care of configuring
    Unity and Visual Studio for you. If you did already have it installed, you will
    need to check to ensure the connection between the programs is ready for them
    to work together. Let’s connect Unity to it and start learning.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有安装 Visual Studio，那么这将为你配置 Unity 和 Visual Studio。如果你已经安装了它，你需要检查以确保程序之间的连接已经准备好协同工作。让我们将
    Unity 连接到它并开始学习。
- en: To begin, close Visual Studio and open the Unity project we created in the previous
    chapter. If you didn’t make one, no better time than now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关闭 Visual Studio 并打开我们在上一章中创建的 Unity 项目。如果你没有创建，现在是一个好时机。
- en: 'Navigate to these respective menus to connect Visual Studio to Unity:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到这些相应的菜单以将 Visual Studio 连接到 Unity：
- en: 'Mac: **Unity (Top left of the screen) -> Preferences -> External Tools tab**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'Mac: **Unity（屏幕左上角）-> 首选项 -> 外部工具选项卡**'
- en: 'PC: **Edit -> Preferences -> External Tools tab**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'PC: **编辑 -> 首选项 -> 外部工具选项卡**'
- en: 'In the external scripting tool dropdown, choose **Visual Studio**. After this
    has been selected, go to your **Assets** folder in the project window and right-click
    in the gray open space. Following *Figure 3.2*, you can create a script by choosing:
    **Create -> C# Script**. Name it `ScriptingLesson` and double-click it to open
    it. This should open Visual Studio with the proper hooks from Unity. This means
    that Visual Studio will read in the project file and Unity will keep it up to
    date with any changes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部脚本工具下拉菜单中，选择 **Visual Studio**。选择后，转到项目窗口中的 **Assets** 文件夹，在灰色空白区域右键单击。根据
    *图 3.2*，你可以通过选择：**创建 -> C# 脚本** 来创建一个脚本。将其命名为 `ScriptingLesson` 并双击它以打开。这应该会打开带有从
    Unity 来的适当钩子的 Visual Studio。这意味着 Visual Studio 将读取项目文件，Unity 将根据任何更改保持其更新。
- en: '![Graphical user interface  Description automatically generated](img/B17304_03_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 描述自动生成](img/B17304_03_02.png)'
- en: 'Figure 3.2: Creating a C# script in the editor'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：在编辑器中创建 C# 脚本
- en: Now we can get started on scripting! In the next sections, we will be working
    through the fundamentals. These will stick with you and be part of every project
    that you work on in the future. This would be a good section to put a sticky note
    in to come back to for reference.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写脚本了！在接下来的几节中，我们将学习基础知识。这些知识将伴随你，并成为你未来参与的所有项目的一部分。这是一个很好的地方放便利贴，以便于回来查阅。
- en: Before we get too far, we wanted to make a point here. There may be a spot this
    and other chapters where the code will get unruly. Your script may not work due
    to a single line difference or a forgotten semicolon. This happens very often.
    There is no need to worry; we will have all the scripts in the project safely
    set up for you to recover from. However, a note is that we have heavily commented
    on the lines for readability. This may result in different lines being stated
    in the chapters than you see in the code. We will try to be as accurate in the
    book as possible, but sometimes a single line comment can cause this. Be flexible
    with us as a comment can make the difference in understanding the entire script’s
    inner workings and is more important than a single line number being accurate.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走得太远之前，我们想在这里强调一点。在这个章节和其他章节中，代码可能会变得杂乱无章。你的脚本可能因为单行差异或遗漏的分号而无法工作。这种情况非常常见。无需担心；我们将在项目中为所有脚本提供安全设置，以便你可以从中恢复。然而，需要注意的是，我们对代码行进行了大量的注释，以提高可读性。这可能会导致章节中陈述的行与你在代码中看到的不同。我们将尽力在书中保持准确，但有时单行注释可能会导致这种情况。请对我们保持灵活，因为注释可以在理解整个脚本的内部工作原理方面起到关键作用，比单行数字的准确性更重要。
- en: Fundamentals
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'With Visual Studio installed and connected to Unity’s editor, we should go
    over the basics. In this section, we will talk about data types, variables, logic
    or code flow, methods, classes, and `MonoBehaviour`. There is a lot of knowledge
    in this section of the chapter, but it is meant to be referenced. If you have
    a sticky note, it might be a good idea to place it in this chapter to easily be
    referenced. When you open the file, there will be autopopulated C# that we will
    not need for this part. For now, delete the extra parts so that it looks like
    this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装并连接到 Unity 编辑器后，我们应该回顾一下基础知识。在本节中，我们将讨论数据类型、变量、逻辑或代码流程、方法、类和 `MonoBehaviour`。本章的这一部分包含了很多知识，但它的目的是为了查阅。如果你有便利贴，把它放在这一章里以便于查阅。当你打开文件时，会有自动填充的
    C# 代码，这部分我们暂时不需要。现在，删除多余的部分，使其看起来像这样：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code here is doing two primary tasks. The first line imports the `UnityEngine`
    library so that we can use types and methods from the `UnityEngine` namespace
    for our game. This is called the “using directive”. Inside the UnityEngine namespace,
    we have access to all of our game types, such as GameObject. Since we will be
    working in the editor to manipulate these GameObjects, we should be using this
    namespace in our class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码正在执行两个主要任务。第一行导入`UnityEngine`库，这样我们就可以使用`UnityEngine`命名空间中的类型和方法来为我们的游戏服务。这被称为“使用指令”。在`UnityEngine`命名空间内部，我们可以访问我们所有的游戏类型，例如GameObject。由于我们将在这个编辑器中工作以操作这些GameObject，因此我们应该在我们的类中使用这个命名空间。
- en: The next portion is a class named`ScriptingLesson` that inherits from `MonoBehaviour`.
    Inheritance is part of **Object Oriented Programing**. This class needs to inherit
    from `MonoBehaviour` as it’s directly affecting objects in the game. During the
    *Programming* logic portion below we will explain how we utilize inheriting from
    `MonoBehaviour`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是一个名为`ScriptingLesson`的类，它继承自`MonoBehaviour`。继承是面向对象编程的一部分。这个类需要继承自`MonoBehaviour`，因为它直接影响到游戏中的对象。在下面的编程逻辑部分，我们将解释我们如何利用从`MonoBehaviour`继承。
- en: The **//** means comment. Anything on that line will not be compiled by the
    IDE. You can use this to help yourself out with pseudocode or by adding some defining
    words to your code to help other programmers that may work with your code. We’re
    using it for organization purposes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**//** 表示注释。该行上的任何内容都不会被IDE编译。你可以使用这个功能来帮助你编写伪代码，或者通过在代码中添加一些定义性词汇来帮助其他可能与你代码一起工作的程序员。我们使用它是为了组织目的。'
- en: After you make the change to the script, save it by pressing *Cmd + s* or *Ctrl
    + s*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在你对脚本进行更改后，通过按*Cmd + s*或*Ctrl + s*来保存它。
- en: If you then go back to Unity, you will see that Unity will compile the scripts.
    Every time we make a significant change to the script, we will go back to Unity
    and check on how we are doing. There will be times that the Unity Editor will
    not like the code we are working with, but Visual Studio doesn’t get these editor
    warnings or errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你然后回到Unity，你会看到Unity会编译脚本。每次我们对脚本进行重大更改时，我们都会回到Unity并检查我们的进度。有时Unity编辑器可能不喜欢我们正在处理的代码，但Visual
    Studio不会收到这些编辑器警告或错误。
- en: In the **Scene**, add an empty **GameObject**. Name it `Scripting Lesson` and
    then select it. In the **Inspector**, click **Add Component** and type `scriptinglesson`
    in the search bar. Left-click the script to add it to the empty GameObject. There
    is another way to add the component. If you have the scripting lesson selected,
    you can also click and drag the script onto the inspector to add the script onto
    the component section of the GameObject. Both ways are commonly used. Smaller
    projects may drag more than larger projects. Where there are many scripts and
    you know exactly what you’re looking to add, you may use the **Add component**
    button and type in the script name to add it. Now, when we make changes, you will
    see them on this GameObject.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**中，添加一个空的**GameObject**。将其命名为`Scripting Lesson`，然后选择它。在**检查器**中，点击**添加组件**并在搜索栏中输入`scriptinglesson`。左键单击脚本将其添加到空GameObject。还有另一种添加组件的方法。如果你已经选择了脚本课程，你也可以点击并拖动脚本到检查器中，以将其添加到GameObject的组件部分。两种方法都很常见。小型项目可能比大型项目拖动得更多。当有多个脚本并且你知道你想要添加的确切内容时，你可以使用**添加组件**按钮并输入脚本名称来添加它。现在，当我们进行更改时，你将在这个GameObject上看到它们。
- en: Before we get into any data types, we should have a small discussion about variables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论任何数据类型之前，我们应该有一个关于变量的简短讨论。
- en: Variables
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Just like in algebra, variables are named containers for something. C# is a
    strongly-typed programming language. This means that each variable needs to have
    its own data type associated with it when it is declared. There are guidelines
    on how to name your variables and which data type to use for certain situations.
    We will go into detail on this within each section. Naming conventions are case
    sensitive, and each type of naming has its own set of rules that need to be followed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在代数中一样，变量是某种内容的命名容器。C#是一种强类型编程语言。这意味着在声明时，每个变量都需要与其自己的数据类型相关联。有一些关于如何命名变量以及在某些情况下使用哪种数据类型的指南。我们将在每个部分中详细介绍这一点。命名约定是区分大小写的，每种命名类型都有自己的规则集需要遵循。
- en: Data types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: There are 10 Unity data types that are utilized in C#, however, in Unity, we
    will primarily need to know 4 well. They are **bool**, **int**, **float**, and
    **string**. We will be creating each of these data types in the `ScriptingLesson.cs`
    file that we created.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，有 10 种 Unity 数据类型被使用，然而，在 Unity 中，我们主要需要了解 4 种。它们是 **bool**、**int**、**float**
    和 **string**。我们将在我们创建的 `ScriptingLesson.cs` 文件中创建这些数据类型。
- en: Bool
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Bool
- en: This stands for the Boolean data type, which is designed for either true or
    false variables. These values are also represented by a `1` (True) or `0` (False).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表布尔数据类型，它设计用于 true 或 false 变量。这些值也由 `1`（True）或 `0`（False）表示。
- en: As an example, this could be used when your character enters an area that they
    shouldn’t have to trigger something to happen, like a SPIKE TRAP!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这可以在你的角色进入他们不应该触发任何事件的地方时使用，比如一个 SPIKE TRAP！
- en: 'On line 5 add:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 行添加：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are four parts to this line and all of them have specific purposes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行有四个部分，它们都有特定的用途：
- en: '`public` allows Unity to access the item we are creating for use in the editor.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public` 允许 Unity 访问我们在编辑器中创建的项目。'
- en: '`bool` is the data type of the item we are creating.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool` 是我们创建的项目数据类型。'
- en: '`isActive` is the name of the `bool` data we are creating. It will default
    to `false` as a value.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isActive` 是我们创建的 `bool` 数据的名称。它的默认值将是 `false`。'
- en: The semicolon (`;`) is being used here to denote that it’s the end of the instruction.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里使用分号（`;`）是为了表示指令的结束。
- en: 'If you save and go back into the Unity Editor, you will now see there is a
    checkbox in the inspector named **Is Active**. It should look similar to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存并回到 Unity 编辑器，你现在会看到检查器中有一个名为 **Is Active** 的复选框。它应该看起来像这样：
- en: '![](img/B17304_03_03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17304_03_03.png)'
- en: 'Figure 3.3: “Is Active” checkbox visible'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：“Is Active” 复选框可见
- en: Int
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Int
- en: An integer, or int, is a whole number such as 1, 100, 200, -234571, or 0\. It
    cannot take decimal places. This is used, for example, if you have a discrete
    value needed to count up or down. How many points are gathered in a play session
    is a great place to use ints.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 整数，或 int，是一个完整的数字，例如 1、100、200、-234571 或 0。它不能有小数位。例如，如果你需要一个离散值来计数上升或下降，这会被使用。在游戏会话中收集了多少点是一个很好的使用
    int 的地方。
- en: 'On line 6 add:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 行添加：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is very similar to the `bool`. We are declaring that `myInt` is a publicly
    accessible integer data type variable. When you save and go back to the Unity
    Editor, you will now notice a text input to the right of a variable named `myInt`.
    Since it is an integer, you cannot put a period (`.`) in there to make a decimal
    as it’s an int and only whole numbers are allowed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `bool` 非常相似。我们声明 `myInt` 是一个公开可访问的整数数据类型变量。当你保存并回到 Unity 编辑器时，你现在会注意到一个名为
    `myInt` 的变量右侧有一个文本输入框。由于它是一个整数，你不能在那里输入小数点（`.`）来创建一个十进制数，因为它是一个 int，只允许整数。
- en: Float
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: You might be asking, how can I get decimal places in my numbers? The answer
    you seek is the almighty float! With a float, you can get decimal places such
    as 1.3 or 100.454\.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我如何在数字中获取小数位？你寻求的答案是万能的 float！使用 float，你可以得到小数位，如 1.3 或 100.454。
- en: There is a small unique factor to the float. When you are scripting, you must
    put a small `f` after the value to help the compiler know the value is a float.
    C# assumes that any number without `f` at the end, such as 3.14, is a type of
    `double`. We won’t be using a `double` for our scripting, so we need to remember
    to add the little `f` after our floats.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: float 有一个小独特的因素。当你编写脚本时，你必须在值后加上一个小 `f` 来帮助编译器知道该值是一个 float。C# 假设任何没有 `f` 结尾的数字，如
    3.14，都是 `double` 类型。我们不会在我们的脚本中使用 `double`，所以我们需要记住在 float 后面加上那个小 `f`。
- en: 'On line 7 add:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7 行添加：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you tried to enter this, there was an issue with the number and there
    was a red line underneath the **3.14**, right? If you hover over the red-underlined
    area, you will get an error. It might look something like *Figure 3.4*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试输入这个时，数字有问题，在 **3.14** 下面出现了一条红色横线，对吧？如果你将鼠标悬停在红色下划线区域，你会得到一个错误。它可能看起来像
    *图 3.4*：
- en: '![Graphical user interface, application  Description automatically generated](img/B17304_03_04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B17304_03_04.png)'
- en: 'Figure 3.4: CS0664 error display'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：CS0664 错误显示
- en: Visual Studio is trying to tell you that the number you entered will be thought
    of as a `double`, so let’s make a bit of a change to help the IDE.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 正在试图告诉你你输入的数字将被视为 `double`，所以让我们做一点改变以帮助 IDE。
- en: 'Change line 7 to:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将第 7 行更改为：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There we go. Now we have a float declared and initialized. We declared it as
    `myFloat` and initialized the value as `3.14`. The default float is `0`, but when
    you tell it to assign a value as you are declaring it, the IDE overwrites that
    default `0` with the value you set it to. When you go into Unity and look at the
    inspector, you will now see the value starts out as **3.14**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。现在我们声明并初始化了一个浮点数。我们将其声明为 `myFloat` 并将其值初始化为 `3.14`。默认的浮点数是 `0`，但当你告诉它在声明时分配一个值时，IDE
    会用你设置的值覆盖那个默认的 `0`。当你进入 Unity 并查看检查器时，现在你会看到值从 **3.14** 开始。
- en: String
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: We’ve been working with numbers this whole time. Now it’s time for letters to
    shine. Strings hold the values of characters. An example of this could be the
    character’s display name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在这个时间都在处理数字。现在轮到字母发光了。字符串持有字符的值。这个例子可以是角色的显示名称。
- en: 'On line 8 add:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 行添加：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This looks the same as well, but now you can add letters! The interesting point
    to be made here is that these public values’ inputs all look the same, so we need
    to make sure our variable names are unique.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来也差不多，但现在你可以添加字母！这里有趣的一点是，这些公共值的输入看起来都一样，所以我们需要确保我们的变量名是唯一的。
- en: GameObject
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GameObject
- en: This is an interesting data type as it’s unique to Unity. Its reference is to
    a GameObject that you place in it from the scene or prefab. This is extremely
    powerful as the item you place in here has components and we can access them from
    the script to do a great many things.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的数据类型，因为它对 Unity 来说是独特的。它的引用是从场景或预制件中放置在其内的 GameObject。这非常强大，因为放置在这里的项目有组件，我们可以从脚本中访问它们来执行许多事情。
- en: 'On line 8 add:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 行添加：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save your code and head back into the editor. You will notice this time, instead
    of an input field, it is wanting a GameObject to be placed here. In our scene,
    there is a directional light. Let’s drag that light from the hierarchy and into
    that spot. You now have a reference to a scene GameObject! Let’s continue a bit
    further to logic and flow to see what we can do with our initial variables.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的代码并返回到编辑器。这次，你会注意到，它想要的不是一个输入字段，而是一个要放置在这里的 GameObject。在我们的场景中有一个方向光。让我们从层次结构中将那个灯光拖动到那个位置。你现在有一个场景
    GameObject 的引用！让我们继续一点逻辑和流程，看看我们可以用我们的初始变量做什么。
- en: Programming logic
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程逻辑
- en: We’ve created some amazing variables filled with such fantastic data. The only
    problem is that we aren’t doing anything with it. Why don’t we start working some
    logic into our little script to start making some connection as to why we would
    need to program in the first place? For this, we are going to go into **if statements**
    and **while loops**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一些充满如此奇妙数据的变量。唯一的问题是，我们并没有对它们做任何事情。为什么我们不开始在我们的小脚本中添加一些逻辑，以开始了解为什么我们最初需要编程呢？为此，我们将进入
    **if 语句** 和 **while 循环**。
- en: Before we get to do some runtime work, we need to add `MonoBehaviour` to our
    class. The term for the actions we’re about to take is inheritance. We will derive
    our class from `MonoBehaviour`, which will give us access to its class by inheriting
    them! To do this is very simple.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行一些运行时工作之前，我们需要将 `MonoBehaviour` 添加到我们的类中。我们即将采取的行动术语是继承。我们将从 `MonoBehaviour`
    派生我们的类，这将通过继承它们来给我们访问其类的方法！这样做非常简单。
- en: 'Remembering line 3:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第 3 行：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are inheriting properly by adding `: MonoBehaviour` after our class name,
    and now we have access to any of the methods inside the `MonoBehaviour` class.
    There are quite a few methods we are able to use from `MonoBehaviour`. For now,
    we will use the `Start()` and `Update()` methods that are inherited from `MonoBehaviour`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '我们通过在类名后添加 `: MonoBehaviour` 正确地进行了继承，现在我们可以访问 `MonoBehaviour` 类中的任何方法。我们可以从
    `MonoBehaviour` 使用相当多的方法。现在，我们将使用从 `MonoBehaviour` 继承的 `Start()` 和 `Update()`
    方法。'
- en: If statements
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果语句
- en: We’re now going to set up some simple code to turn a GameObject off and on according
    to the state of the `isActive` bool we’ve defined. To do this, we will need to
    check it on an `update` method, which is part of `MonoBehaviour`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置一些简单的代码，根据我们定义的 `isActive` bool 的状态来关闭和打开 GameObject。为此，我们需要在 `update`
    方法中检查它，这是 `MonoBehaviour` 的一部分。
- en: 'Starting with line 13, we made these changes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 13 行开始，我们做了以下更改：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inside the `Start` method from `MonoBehaviour`, we are setting `isActive` to
    true. This was added here to set the `Boolean` to be considered regardless of
    what was set in the editor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MonoBehaviour` 的 `Start` 方法中，我们将 `isActive` 设置为 true。这是在这里添加的，以便将 `Boolean`
    设置为在编辑器中设置的任何内容都应考虑。
- en: After that, there is an `update` method. The `update` method from `MonoBehaviour`
    will do a check of the entire code inside the curly braces in every frame. Initially,
    we check out the GameObject we defined by comparing it to a **null**. This is
    a validity check. `Null` is a special keyword that denotes the lack of type or
    data. If you do not perform these checks, your editor will not be able to play
    as there will be a null exception. An example of this is if you have a public
    GameObject that isn’t assigned in the inspector, this will throw a null exception
    as the GameObject is null!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，有一个`update`方法。`MonoBehaviour`中的`update`方法会在每一帧检查花括号内的整个代码。最初，我们通过将其与一个**null**进行比较来检查我们定义的GameObject。这是一个有效性检查。`Null`是一个特殊的关键字，表示类型或数据的缺失。如果你不执行这些检查，你的编辑器将无法播放，因为将会有一个空指针异常。一个例子是，如果你在检查器中有一个未分配的公共GameObject，这将抛出一个空指针异常，因为GameObject是空的！
- en: Inside the validity check, we have an if/else statement. It’s currently saying
    if the `isActive` variable is true, then set `myGameObject` to active. For anything
    other than true, set `myGameObject` to inactive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效性检查中，我们有一个if/else语句。它目前表示如果`isActive`变量为true，则将`myGameObject`设置为活动状态。对于除了true之外的所有情况，将`myGameObject`设置为非活动状态。
- en: If you save and press play, you will be able to select the scripting lesson
    GameObject and then uncheck the `isActive` boolean checkbox. It will turn off
    the light. Since this is checking every frame, you can do this forever and it
    will turn on and off until your heart’s content.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存并按下播放，你将能够选择脚本课程GameObject，然后取消选中`isActive`布尔复选框。这将关闭灯光。由于这是每一帧都在检查，你可以一直这样做，直到你满意为止。
- en: 'Before we move on to `while` loops, we wanted to do a bit of a refactor of
    our block above. This is a good time to learn about this as well. We went through
    this `if` block to learn the syntax, but we could’ve made it better! We are running
    this check every frame, so the `if` block isn’t needed here as we have a `Boolean`
    to compare it with. You could instead write the following code to refactor this
    down, saving compute time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到`while`循环之前，我们想要对我们的上面的代码块进行一些重构。这也是学习这个的好时机。我们通过这个`if`块学习了语法，但我们可以做得更好！我们每帧都在运行这个检查，所以这里的`if`块是不需要的，因为我们有一个`Boolean`可以与之比较。你可以用以下代码重构这个代码，节省计算时间：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How this can be read is, every frame, if `myGameObject` isn’t null, set its
    active state to either true or false depending on what the `Boolean` is set to.
    We don’t have to ask it if it’s true or not since the data type only has two states!
    This is awesome.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这样读取的方式是，每一帧，如果`myGameObject`不为空，则根据`Boolean`的设置将其活动状态设置为true或false。我们不需要询问它是否为true或false，因为数据类型只有两种状态！这真是太棒了。
- en: Let’s move on to `while` loops for a take on looping code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到`while`循环，看看如何循环代码。
- en: While loops
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: An `if` statement is a simple branching pattern checking for a true or false
    to execute something. `while` loops will continually run code until the statement
    is true or false. This can cause issues – as you can imagine, some tasks could
    go on forever. This is called an infinite loop and can hang your application indefinitely
    or until it’s forced to close. For the most part, we catch infinite loops quickly
    and they don’t cause much of a fuss. We should still pay attention to our criteria
    when creating a `while` loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是一个简单的分支模式，用于检查true或false以执行某些操作。`while`循环将不断运行代码，直到语句为true或false。这可能会引起问题——正如你可以想象的那样，一些任务可能会无限期地进行。这被称为无限循环，可能会无限期地挂起你的应用程序，或者直到它被强制关闭。大多数情况下，我们能够快速捕获无限循环，并且它们不会引起太大的麻烦。我们仍然应该在创建`while`循环时注意我们的标准。'
- en: 'On line 32, add these lines to the `update` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第32行，将这些行添加到`update`方法中：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are several new things we’re doing here in this `while` loop. We are doing
    a **debug log**, **string interpolation**, and a **decrementer**. Let’s go through
    those.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`while`循环中，我们正在做几件新的事情。我们正在执行一个**调试日志**、**字符串插值**和一个**递减器**。让我们逐一来看。
- en: Debug log
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试日志
- en: '`Debug.Log` allows us to pass in a string and it will be written out in the
    console inside Unity. This is very helpful if there are strange things happening
    and you want to get some runtime information out to the console.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log`允许我们传入一个字符串，它将在Unity的控制台内输出。如果有奇怪的事情发生，并且你想要在控制台获取一些运行时信息，这非常有帮助。'
- en: String interpolation
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Inside the log, we are performing an action called string interpolation. This
    is a very handy way to add your variables into a string. This is started off with
    a **$** followed by double quotes. Inside this is a string that you want to write
    out. It is a literal string to include spaces. The interesting thing is that there
    are curly braces **{}** inside the string! If you place the variable name inside
    the curly braces, you will get the data passed into the string. In the `while`
    loop just slightly above you can see us performing this in the `Debug` line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志内部，我们执行一个称为字符串插值的操作。这是一种非常方便的方法，可以将变量添加到字符串中。它从**$**符号开始，后跟双引号。在这个双引号内部是一个你想要写出的字符串。它是一个包含空格的文本字符串。有趣的是，字符串内部有花括号**{}**！如果你在花括号内放置变量名，你将得到传递到字符串中的数据。在上面的`while`循环中，你可以看到我们在`Debug`行中执行此操作。
- en: Decrementer
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递减器
- en: 'The next line is a decrementer. This is an efficient way to write this line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是一个递减器。这是编写此行的有效方法：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you save this and then run it, there will be nothing in the console. This
    is because we haven’t set `MyInt` to anything, so it defaults to 0\. The `while`
    loop will not run because `MyInt` is not greater than 0 – it is 0\. Let’s make
    this change:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存然后运行它，控制台将没有任何内容。这是因为我们没有设置`MyInt`的值，所以它默认为0。由于`MyInt`不是大于0（它是0），`while`循环将不会运行。让我们进行以下更改：
- en: 'On line 16, add this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16行，添加以下内容：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save and run the game. Now if you look at the console, it will quickly decrement
    `MyInt` down to 0 and print out the line letting you know its current value. If
    you look in the inspector, you will see that `MyInt` is showing 0 as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行游戏。现在如果你查看控制台，它将快速将`MyInt`递减到0并打印出显示其当前值的行。如果你查看检查器，你也会看到`MyInt`显示为0。
- en: Now that we have an idea about programming logic, let’s add some functionality.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对编程逻辑有了些了解，让我们添加一些功能。
- en: For loops
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'Like `while` loops, `for` loops are an iteration over a set number of items.
    `for` loops are most used if there is an idea of how many times the iteration
    will need to run. We will do a simple `for` loop to show the syntax of it and
    go over it below:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环一样，`for`循环是对一组固定项的迭代。如果有一个迭代需要运行多少次的预期，那么`for`循环是最常用的。我们将执行一个简单的`for`循环来展示其语法，并在下面进行说明：
- en: First, let’s comment out line 35 as we don’t need the `while` loop debug log
    cluttering up our `for` loop debug lines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们注释掉第35行，因为我们不需要`while`循环调试日志在我们的`for`循环调试行中造成混乱。
- en: 'Then, on line 39, add this block of code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第39行，添加以下代码块：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`for` loops tend to be more common, but let’s go over a bit of reasoning as
    to why you would want to use one or the other.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环通常更常见，但让我们简要讨论一下为什么你可能想要使用其中一个。'
- en: Choosing between for and while
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择`for`循环和`while`循环
- en: '`for` and `while` loops are similar in function. They are designed to iterate
    over some set of items. The rules on this aren’t written in stone. They are interchangeable
    technically, but there is some nuance to readability. The `for` loop reads as
    if there is a set number to iterate over. This value doesn’t need to be known
    to the `for` loop, but an example of this is a group of GameObjects. If you needed
    to iterate over all of them and perform logic on all of them, you wouldn’t need
    to code the number of items to iterate over as the grouping has a count. You can
    iterate over this count. We will see an example of this in *Chapter 6*, *Interactions
    and Mechanics*.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环和`while`循环在功能上相似。它们被设计为遍历一组固定项。关于这些规则并没有一成不变的规定。技术上它们可以互换，但在可读性方面有一些细微差别。`for`循环看起来像是有固定数量的迭代。这个值不需要`for`循环知道，但一个例子是一组GameObject。如果你需要遍历所有这些并对其执行逻辑，你不需要编写要迭代的项数，因为分组有一个计数。你可以遍历这个计数。我们将在*第6章*，*交互和机制*中看到这个例子。'
- en: 'The difference between this and the `while` loop is that the `while` loop reads
    as follows: Do something until a condition is set to true. It doesn’t matter how
    many items need to be iterated on as it will go until the other condition is met.
    `while` loops have an inherent issue in them for making infinite loops. If you
    don’t 100% understand what you are looping over or accidentally use the wrong
    symbol (< instead of >) for your condition, you can run into that infinite loop
    explained in the `while` loop section. `while` loops aren’t used as much as `for`
    loops, but they do have a good place in programming.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`while`循环的区别在于，`while`循环的读法如下：在条件设置为真之前执行某些操作。无论需要迭代多少项，它都会一直执行，直到满足另一个条件。`while`循环在制作无限循环方面存在固有的问题。如果你不完全理解你正在循环的内容，或者意外地使用了错误的符号（<而不是>）作为你的条件，你可能会遇到`while`循环部分中解释的无限循环。`while`循环不像`for`循环那样常用，但在编程中也有其合适的位置。
- en: Methods
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'If logic is the butter of programming, this is the bread. The purpose of a
    method is to perform actions in a concise manner. A very simple example of a method
    is a basic calculator function called `Add`. To perform this function, we will
    do three things: Create some public variables to add with, have a way to trigger
    the method, and the method itself. We decided to use the input system for all
    our inputs. To get this working, there are a few new concepts to add here as well.
    Previously, we asked you to insert code into specific lines. We will now just
    ask you to insert the code into the specific sections instead.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑是编程的黄油，那么这就是面包。方法的目的是以简洁的方式执行操作。一个方法非常简单的例子是一个基本的计算器函数，称为`Add`。为了执行这个函数，我们将做三件事：创建一些公共变量来进行加法运算，有一种方式可以触发方法，以及方法本身。我们决定使用输入系统来处理所有输入。为了使它工作，这里还需要添加一些新的概念。之前，我们要求你将代码插入到特定的行中。现在，我们只要求你将代码插入到特定的部分。
- en: 'At the top, we need to let the program know we want to use the input system.
    To do this, we will add a `using` statement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们需要让程序知道我们想要使用输入系统。为此，我们将添加一个`using`语句：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the class’s variable section, add these lines:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的变量部分，添加以下这些行：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’re making the `int` variables public so we can make changes to them and see
    that they are able to be changed during runtime when we run the method. The input
    system is private as it doesn’t need to be affected by any other scripts. This
    is a good practice to think about when writing your code. If a variable will not
    be changed from another script, then keep it as a private variable. Though it
    may not adversely influence the current working environment on a small project,
    there could be conflicts later on when projects get more fleshed out. We want
    to keep the code clean from the beginning.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`int`变量设置为公共的，这样我们就可以修改它们，并在运行时运行方法时看到它们是可以被修改的。输入系统是私有的，因为它不需要受到任何其他脚本的干扰。这是编写代码时需要考虑的良好实践。如果一个变量不会被其他脚本修改，那么就将其保持为私有变量。虽然它可能不会对小型项目的工作环境产生不利影响，但在项目更加完善时可能会出现冲突。我们希望从一开始就保持代码的整洁。
- en: InputSystem requires the input to have listeners turned on and disabled when
    not being used. We will create two methods that are native to `MonoBehaviour`;
    `OnEnable` and `OnDisable`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputSystem`需要输入具有开启的监听器，并在不使用时禁用。我们将创建两个原生于`MonoBehaviour`的方法；`OnEnable`和`OnDisable`。'
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These methods automatically fire during runtime. `OnEnable` is directly after
    `Awake` on initialization. Do not worry if this is a little bit much, we will
    go over them multiple times throughout this book for different perspectives.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在运行时自动触发。`OnEnable`在初始化后直接位于`Awake`之后。不要担心这有点多，我们将在本书的不同章节中多次回顾它们，从不同的角度进行讲解。
- en: For now, the reason these methods are here is to add the method `OnTestInput`
    when `testInput` is performed. We bound the letter **B** to our input in the variable
    portion, now we’re adding a method to be performed when it’s pressed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些方法在这里的原因是当执行`testInput`时添加`OnTestInput`方法。我们在变量部分将字母**B**绑定到我们的输入，现在我们正在添加一个当按下时执行的方法。
- en: Below and outside the `update` method let’s add our addition method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法下方和外部，让我们添加我们的添加方法。
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a method that is private, which means outside of this class, we can’t
    access this method. This is going to return an `int` and its name is `intAdd`.
    Inside the parenthesis after the name are arguments for the method. We have two
    ints: **a** and **b**. We need to define their data types and their names. When
    the method is running, our method makes two ints with the values at that time
    and assigns them to variable **a** and **b**. We made `totalAdd` equal to it so
    we could show the values change in the inspector as well as in the console to
    debug it even further.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个私有方法，这意味着在这个类之外，我们无法访问这个方法。这个方法将返回一个`int`，其名称为`intAdd`。在名称之后括号内的参数是方法的参数。我们有两个整数：**a**和**b**。我们需要定义它们的数据类型和名称。当方法运行时，我们的方法会创建两个具有当时值的整数，并将它们分配给变量**a**和**b**。我们将`totalAdd`设置为它，这样我们就可以在检查器和控制台中显示值的变化，以便进一步调试。
- en: To bring this all together, we need to create the `OnTestInput` method. This
    method has new terms, but for this instance, we will give them to you to get the
    test going for a simple button press. Later on, in the mechanics portion of the
    book, we will need to have more logic involved with our input. Having this system
    set up early allows for quick iteration and scalability with new input schemes,
    such as controllers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容整合在一起，我们需要创建`OnTestInput`方法。这个方法包含了一些新术语，但在这个例子中，我们将把它们提供给你，以便开始对简单按钮点击进行测试。稍后，在本书的机械部分，我们需要在输入中包含更多的逻辑。在早期设置好这个系统，可以快速迭代和扩展新的输入方案，例如控制器。
- en: 'Create a new method below the `intAdd` method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`intAdd`方法下方创建一个新的方法：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The magic here is that this method is placed on the `performed` of the `testInput`
    we enable in this script. This script gets called with the action assigned to
    that input. Currently, we are only running simple logic to allow for the debug
    log to print out if the `actionContext` is performed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的魔法在于，这个方法被放置在我们在脚本中启用的`testInput`的`performed`上。这个脚本会调用分配给该输入的动作。目前，我们只运行简单的逻辑，以便让调试日志打印出如果`actionContext`被执行。
- en: In our case, this will be true when the method is called. If we needed other
    logic, such as if a cooldown for a skill wasn’t completed yet, we could tell the
    user they can’t perform that skill within this method. This is a very powerful
    system that can be built to be extremely robust.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，当方法被调用时，这将是真的。如果我们需要其他逻辑，例如如果技能的冷却时间还没有完成，我们可以在该方法中告诉用户他们不能在这个方法中执行那个技能。这是一个非常强大的系统，可以构建得非常健壮。
- en: Back in Unity, click on the script in the hierarchy and then put some values
    in the `addA` and `addB` variables in the inspector. Start the game and press
    **b**. You should see `totalAdd` change as well as the console print out the number
    from the `Debug` line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，点击层次结构中的脚本，然后在检查器中为`addA`和`addB`变量输入一些值。开始游戏并按**b**键。你应该会看到`totalAdd`的变化，以及控制台打印出`Debug`行中的数字。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This may have been your first time reading anything about programming. Going
    through these small examples is going to provide you with strong fundamentals.
    Take your time to fully understand what we went over in this chapter as it will
    be the glue holding together the rest of the chapters. We will be using all these
    features when programming later as well as adding new libraries and different
    implementations of classes. These are the foundations of programming; we will
    build upon them thoroughly throughout the book. If you ever get lost, refer to
    GitHub where you’ll find these scripts in their completed form, which you can
    reference if something isn’t working correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是你第一次阅读关于编程的任何内容。通过这些小例子，你将获得坚实的基础。花时间完全理解本章中我们讨论的内容，因为它将是连接其他章节的粘合剂。在后面的编程过程中，我们将使用所有这些特性，以及添加新的库和类的不同实现。这些都是编程的基础；我们将在整本书中彻底地构建在这些基础之上。如果你迷失方向，可以参考GitHub，在那里你可以找到这些脚本的完整形式，如果你发现某些东西工作不正常，可以参考它们。
- en: 'This is the end of the foundations that we will build upon greatly over the
    next five chapters. *Part 2*: *Build and Design* will add onto everything you’ve
    learned so far, answer even more questions about building the design of our prototype,
    and show you how Unity can help you create games with as much ease as possible.
    Let’s move on to building out the character and put some of these programming
    skills together to get Myvari moving around with input.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要在接下来的五章中大力构建的基础的终结。**第二部分**：**构建与设计**将补充你迄今为止所学的所有内容，回答更多关于构建原型设计的问题，并展示Unity如何帮助你尽可能轻松地创建游戏。让我们继续构建角色，并将一些编程技能结合起来，让Myvari能够通过输入移动。
