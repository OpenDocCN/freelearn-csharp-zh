- en: '*Chapter 6*: Gallery: Building an AR App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：画廊：构建AR应用'
- en: In this chapter, we will begin building a full **Augmented Reality** (**AR**)
    app, an AR *art gallery* that lets you hang virtual framed photos on your real-world
    walls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建一个完整的**增强现实**（AR）应用，一个AR**艺术画廊**，让你能在现实世界的墙上挂上虚拟的框架照片。
- en: First, we'll define the goals of the project and discuss the importance of project
    planning and **user experience** (**UX**) design. When the user presses the **Add**
    button in the main menu, they'll see a **Select Image** menu. When they pick one,
    they'll be prompted to place a framed copy of the image on their real-world wall.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义项目的目标，并讨论项目规划和**用户体验**（UX）设计的重要性。当用户在主菜单中按下**添加**按钮时，他们将看到一个**选择图像**菜单。当他们选择一个时，他们将被提示将图像的框架副本放置在他们的现实世界墙上。
- en: To implement the project, we will start with the AR user framework scene template
    that we created earlier in this book. We'll build a Select Image UI panel and
    interaction mode, and define the image data used by the app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要实施项目，我们将从本书早期创建的AR用户框架场景模板开始。我们将构建一个选择图像UI面板和交互模式，并定义应用使用的图像数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Specifying a new project and UX design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定新的项目和UX设计
- en: Using data structures and arrays, and passing data between objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据结构和数组，以及在对象之间传递数据
- en: Creating a detailed UI menu panel with a grid of buttons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有按钮网格的详细UI菜单面板
- en: Creating prefabs for instantiating in an AR scene
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于在AR场景中实例化的预制件
- en: Implementing a complete scenario based on a given user story
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于给定的用户故事实现完整场景
- en: 'By the end of the chapter, you''ll have a working prototype of the app that
    implements one scenario: placing pictures on the wall. Then we''ll continue to
    build and improve the project in the next chapter.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个实现一个场景的工作原型：在墙上放置图片。然后我们将在下一章继续构建和改进项目。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To implement the project in this chapter, you need Unity installed on your development
    computer, connected to a mobile device that supports AR applications (see [*Chapter
    1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013), *Setting Up for AR Development*,
    for instructions). We also assume that you have the `ARFramework` template and
    its prerequisites installed; see [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*,
    Using the AR User Framework*. The completed project can be found in this book's
    GitHub repository, [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中实现项目，您需要在您的开发计算机上安装Unity，并将其连接到一个支持AR应用程序的移动设备（有关说明，请参阅[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*）。我们还假设您已安装了`ARFramework`模板及其先决条件；请参阅[*第5章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*，使用AR用户框架*。完成的项目可以在本书的GitHub存储库中找到，[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Specifying the Art Gallery project UX
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定艺术画廊项目的UX
- en: 'An important step before beginning any new project is to do some design and
    specifications ahead of time. This often entails writing it down in a document.
    For games, this may be referred to as the **Game Design Document** (**GDD**).
    For applications, it may be a **Software Design Document** (**SDD**). Whatever
    you call it, the purpose is to put into writing a blueprint of the project before
    development begins. A thorough design document for a Unity AR project might include
    details such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何新项目之前的一个重要步骤是在事先做一些设计和规范。这通常意味着将其写入文档。对于游戏，这可能被称为**游戏设计文档**（GDD）。对于应用程序，它可能是一个**软件设计文档**（SDD）。无论你称之为什么，其目的是在开发开始之前将项目的蓝图写入文档。一个Unity
    AR项目的详细设计文档可能包括以下细节：
- en: '*Project overview*: Summarize the concept and purpose of the project, identify
    the primary audience, and perhaps include some background on why the project exists
    and how and why it will be successful.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目概述*：总结项目的概念和目的，确定主要受众，并可能包括一些关于项目存在的原因以及它将如何成功的背景信息。'
- en: '*Use cases*: Identify the real-life problems the product will solve. It''s
    often effective to define separate user **personas** (with real or fictitious
    names) representing types of users of the application, their main goals, and how
    they''ll use the app to achieve these objectives.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用例*：确定产品将解决的实际生活问题。通常，定义代表应用程序不同用户类型、他们的主要目标和如何使用应用程序来实现这些目标的单独用户**角色**（可以是真实或虚构的名字）是有效的。'
- en: '*Key features*: Identify the discrete areas of functionality that deliver value
    to your users, perhaps with an emphasis on what distinguishes it from other similar
    solutions.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关键特性*：确定为用户提供价值的离散功能区域，可能强调其与其他类似解决方案的区别。'
- en: '*UX design*: The **user experience (UX)** design may include a variety of user
    scenarios that detail specific workflows, often presented as a **storyboard**
    using abstract pencil or wireframe sketches. In lieu of drawing skills, photo
    captures of a whiteboard session and sticky notes may be sufficient.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UX设计*：**用户体验（UX）**设计可能包括各种用户场景，详细说明特定的工作流程，通常以**故事板**的形式呈现，使用抽象的铅笔或线框草图。如果没有绘画技巧，白板会议的照片捕捉和便利贴可能就足够了。'
- en: Separately, you may also include UI graphic designs that define actual style
    guides and graphics, for example, color schemes, typography, button graphics,
    and so on.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，你还可以包括UI图形设计，定义实际的风格指南和图形，例如，色彩方案、字体、按钮图形等。
- en: '*Assets*: Collect and categorize the graphic assets you anticipate needing,
    including concept art, 3D models, effects, and audio.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资产*：收集和分类你预计需要的图形资产，包括概念艺术、3D模型、效果和音频。'
- en: '*Technical plan*: This includes software architecture and design patterns that
    will be used, development tools (such as Unity, Visual Studio, and GitHub), the
    Unity version, third-party packages (for example, via Package Manager), plus Unity
    Services and other cloud services (such as advertising, networking, and data storage).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*技术计划*：这包括将要使用的软件架构和设计模式，开发工具（例如Unity、Visual Studio和GitHub），Unity版本，第三方包（例如，通过包管理器），以及Unity服务和其它云服务（如广告、网络和数据存储）。'
- en: '*Project plan*: The implementation plan may show the anticipated project phases,
    production, and release schedules. This could involve the use of tools such as
    Jira or Trello.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*项目计划*：实施计划可能显示预期的项目阶段、生产和发布时间表。这可能涉及使用诸如Jira或Trello之类的工具。'
- en: '*Business plan*: Non-technical planning may include plans for project management,
    marketing, funding, monetization, user acquisition, and community-building.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商业计划*：非技术规划可能包括项目管理、营销、资金、货币化、用户获取和社区建设计划。'
- en: 'For very large projects, these sections could be separate documents. For small
    projects, the entire thing may only be a few pages long with bullet points. Just
    keep in mind that the main purpose is to think through your plans before committing
    to code. That said, don''t over-design. Keep in mind one of my favorite quotes
    from Albert Einstein:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常大的项目，这些部分可能是单独的文档。对于小型项目，整个文档可能只有几页长，包含项目符号。记住，主要目的是在编写代码之前思考你的计划。话虽如此，不要过度设计。记住我非常喜欢爱因斯坦的一句话：
- en: '"Make everything as simple as possible, but not simpler."'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '"尽可能使一切变得尽可能简单，但不能过于简单。"'
- en: 'Assume things can and will change as the project progresses. Rapid iteration,
    frequent feedback from stakeholders, and engaging real users may reaffirm your
    plans. Or it may expose serious shortcomings with an original design and can take
    a project in new, better directions. As I tell my clients and students:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设随着项目的发展，事情可能会并且将会发生变化。快速迭代、利益相关者的频繁反馈和吸引真实用户可能会重申你的计划。或者，它可能会暴露原始设计中的严重缺陷，并将项目引向新的、更好的方向。正如我对我客户和学生的建议：
- en: '"The time you know least about a project is at the beginning!"'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '"你对项目了解最少的时候是在项目开始时！"'
- en: In this book, I'll provide an abbreviated design plan at the beginning of each
    project that tries to capture the most important points without going into a lot
    of detail. Let's start with this AR Gallery project, and spec out the project
    objective, use cases, a UX design, and a set of user stories that define the key
    features of the project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将在每个项目的开始提供一个简化的设计计划，试图捕捉最重要的点，而不涉及太多细节。让我们从这个AR画廊项目开始，并具体说明项目目标、用例、一个UX设计和一组定义项目关键特性的用户故事。
- en: Project objectives
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目目标
- en: We are going to build an AR art gallery project that allows users to place their
    favorite photos on walls of their home or office as virtual framed images using
    AR.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个 AR 艺术画廊项目，允许用户使用 AR 将他们最喜欢的照片作为虚拟相框图像放置在他们的家或办公室的墙上。
- en: Use cases
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: '*Persona: Jack*. Jack works from home and doesn''t have time to decorate his
    drab apartment. Jack wants to spruce up the walls by adding some nice pictures
    on the wall. But his landlord doesn''t allow putting nails in the walls. John
    also wants to be able to change his hung pictures frequently. Jack spends many
    hours per day using his mobile phone, so looking at the walls through his phone
    is satisfying.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*人物：杰克*。杰克在家工作，没有时间装饰他那单调的公寓。杰克希望通过在墙上添加一些漂亮的图片来装饰墙壁。但他的房东不允许在墙上钉钉子。约翰也希望能够经常更换他挂的照片。杰克每天花费很多时间使用他的手机，所以通过手机看墙壁是令人满意的。'
- en: '*Persona: Jill.* Jill has a large collection of favorite photos. She would
    like to hang them on the walls of her office but it''s not very appropriate for
    a work environment. Also, she is a bit obsessive and thus would like to frequently
    rearrange the photos and swap the pictures.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*人物：吉尔*。吉尔有一大堆喜欢的照片。她希望将它们挂在办公室的墙上，但这在办公环境中并不太合适。此外，她有点强迫症，因此希望经常重新排列照片并交换图片。'
- en: UX design
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UX 设计
- en: 'The **user experience** (**UX)** for this application must include the following
    requirements and scenarios:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序的用户体验（UX）必须包括以下要求和场景：
- en: When the user wants to place a photo on the wall, they select an image from
    a menu and then tap the screen, indicating where to place the photo.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户想要在墙上放置照片时，他们从菜单中选择一张图片，然后轻触屏幕，指示放置照片的位置。
- en: When the user wants to modify a photo already placed on the wall, they can tap
    the photo to enable editing. Then the user can drag to move, pinch to resize,
    choose a different photo or frame, or swipe to remove the photo.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户想要修改已经放置在墙上的照片时，他们可以轻触照片以启用编辑功能。然后用户可以拖动来移动，捏合来调整大小，选择不同的照片或相框，或者滑动来移除照片。
- en: When the framed photo is rendered, it matches the current room lighting conditions
    and casts shadows on real-world surfaces.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相框照片渲染时，它会匹配当前的房间照明条件，并在真实世界的表面上投下阴影。
- en: When the user exits and re-opens the app, all the photos they placed in the
    room will be saved and restored in their locations.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户退出并重新打开应用时，他们放置在房间中的所有照片都将被保存并恢复到它们的位置。
- en: 'I asked a professional UX designer (and friend of mine) Kirk Membry ([https://kirkmembry.com/](https://kirkmembry.com/))
    to prepare UX wireframe sketches specifically for this book''s project. The following
    image shows a few frames of a full storyboard:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我请了一位专业的 UX 设计师（也是我的朋友）Kirk Membry ([https://kirkmembry.com/](https://kirkmembry.com/))
    为这本书的项目准备 UX 线框草图。以下图像显示了整个故事板的一些框架：
- en: '![Figure 6.1 – UX design wireframe sketches'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – UX 设计线框草图'
- en: '](img/Figure_6.01-ux-design-example.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.01-ux-design-example.jpg)'
- en: Figure 6.1 – UX design wireframe sketches
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – UX 设计线框草图
- en: The leftmost frame shows the image gallery menu that appears when the user has
    chosen to add a new photo into the scene. The middle frame depicts the user choosing
    a location to hang the photo on a wall. And the rightmost frame shows the user
    editing an existing picture, including finger gestures to move and resize, and
    a menu of other edit options on the bottom of the screen.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最左侧的框架显示了当用户选择将新照片添加到场景中时出现的图像库菜单。中间的框架描述了用户选择在墙上挂照片的位置。最右侧的框架显示了用户正在编辑现有的图片，包括用于移动和调整大小的手势，以及屏幕底部的其他编辑选项菜单。
- en: Storyboards like this can be used to communicate the design intent to graphic
    designers, coders, and stakeholders alike. It can form the basis of discussion
    for ironing out kinks in the user workflow and inconsistencies in the user interface.
    It can go a long way to make the project management more efficient by preventing
    unnecessary rework when it's most costly – after features have been implemented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的故事板可以用来与图形设计师、编码人员和利益相关者沟通设计意图。它可以作为讨论的基础，以消除用户工作流程中的瑕疵和用户界面的不一致性。它可以大大提高项目管理效率，通过在成本最高的阶段——在功能实现之后——防止不必要的返工。
- en: With enough of the design drafted, we can now select some of the assets we'll
    use while building the project.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计草案足够的情况下，我们现在可以选出一些在构建项目时将使用的资产。
- en: User stories
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户故事
- en: 'It is useful to break up the features into a set of "user stories" or bite-sized
    features that can be implemented incrementally, building up the project a piece
    at a time. In an agile-managed project, the team may choose a specific set of
    stories to accomplish in one- or two-week *sprints*. And these stories could be
    managed and tracked on a shared project board such as Trello ([https://trello.com/](https://trello.com/))
    or Jira ([https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira)).
    Here are a set of stories for this project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能分解成一系列“用户故事”或小块功能，可以逐步实现，一次构建项目的一部分，这是很有用的。在一个敏捷管理的项目中，团队可能会选择在一到两周的*冲刺*中完成的一组特定的故事。这些故事可以在共享的项目板上进行管理和跟踪，例如Trello
    ([https://trello.com/](https://trello.com/)) 或 Jira ([https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira))。以下是本项目的几个故事：
- en: When the app starts, I am prompted to scan the room while the device detects
    and tracks vertical walls in the environment.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用启动时，我被提示扫描房间，同时设备在环境中检测和跟踪垂直墙壁。
- en: After tracking is established, I see a main menu with an **Add** button.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跟踪建立后，我可以看到一个主菜单，其中有一个**添加**按钮。
- en: When I press the **Add** button, I am presented with a selection of photos.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我按下**添加**按钮时，我可以看到一组照片的选择。
- en: When I choose a photo from the selection, I see the tracked vertical planes
    and I am prompted to tap to hang a framed photo (picture) on a wall.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我从选择中选择一张照片时，我可以看到跟踪的垂直平面，并被提示在墙上挂一个带框的图片（图片）。
- en: When the picture is instantiated, it hangs squarely upright and flush against
    the wall plane.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图片实例化时，它垂直地紧贴墙面。
- en: When I tap on an existing virtual picture to begin editing the picture.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我点击现有的虚拟图片以开始编辑图片时。
- en: When editing a picture, I see an edit menu with options to change the photo,
    change the frame, or remove the framed picture.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编辑图片时，我可以看到一个编辑菜单，可以选择更改照片、更改框架或删除带框的图片。
- en: When editing a picture, I can drag the picture to a new location.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编辑图片时，我可以将图片拖动到新位置。
- en: When editing a picture, I can pinch (using two fingers) to resize it.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编辑图片时，我可以使用捏合（使用两个手指）来调整大小。
- en: That seems like a good set of features. We'll try to get through the first half
    of them in this chapter and complete it in the next chapter. Let's get started.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一组很好的功能。我们将尝试在本章中完成它们的前半部分，并在下一章中完成它们。让我们开始吧。
- en: Getting started
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'To begin, we''ll create a new scene named `ARGallery` using the `ARFramework`
    scene template, with the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使用`ARFramework`场景模板创建一个名为`ARGallery`的新场景，以下是步骤：
- en: Select **File | New Scene**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 | 新场景**。
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新场景**对话框中，选择**ARFramework**模板。
- en: Select **Create**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建**。
- en: Select `Scenes/` folder in your project's `Assets` folder, give it the name
    `ARGallery`, and select **Save**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目`Assets`文件夹中的`Scenes/`文件夹中，将其命名为`ARGallery`，并选择**保存**。
- en: 'The new AR scene already has the following objects:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新的AR场景已经包含以下对象：
- en: An **AR Session** game object.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**AR会话**游戏对象。
- en: An **AR Session Origin** rig with raycast manager and plane manager components.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有射线管理器和平面管理器组件的**AR会话起源**装置。
- en: '**UI Canvas** is a screen space canvas with child panels Startup UI, Scan UI,
    Main UI, and NonAR UI. It has the UI Controller component script that we wrote.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI Canvas**是一个屏幕空间画布，包含子面板启动UI、扫描UI、主UI和非AR UI。它具有我们编写的UI控制器组件脚本。'
- en: '**Interaction Controller** is a game object with the Interaction Controller
    component script we wrote that helps the app switch between interaction modes,
    including Startup, Scan, Main, and NonAR modes. It also has a **Player Input**
    component configured with the **AR Input Actions** asset we created previously.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互控制器**是一个具有我们编写的交互控制器组件脚本的游戏对象，它帮助应用在交互模式之间切换，包括启动、扫描、主和非AR模式。它还配置了**玩家输入**组件，该组件使用我们之前创建的**AR输入动作**资产。'
- en: An **OnboardingUX** prefab from the AR Foundation Demos project that provides
    AR session status and feature detection status messages, and animated onboarding
    graphics prompts.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自AR Foundation Demos项目的**OnboardingUX**预制件，它提供AR会话状态和特征检测状态消息，以及动画引导图形提示。
- en: We now have a plan for the AR gallery project, including a statement of objectives,
    use cases, and a UX design with some user stories to implement. With this scene,
    we're ready to go. Let's find a collection of photos we can work with and add
    them to the project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为AR画廊项目制定了计划，包括目标声明、用例和带有一些用户故事的UX设计以实现。有了这个场景，我们就准备好了。让我们找到我们可以工作的照片集合并将它们添加到项目中。
- en: Collecting image data
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集图像数据
- en: In Unity, images can be imported for use in a variety of purposes. Textures
    are images that can be used for texturing the materials for rendering the surface
    of 3D objects. The UI uses images as sprites for button and panel graphics. For
    our framed photos, we're going to use images as… images.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，图像可以导入用于各种目的。纹理是可以用于渲染3D对象表面的材质的图像。UI使用图像作为按钮和面板图形的精灵。对于我们的相框照片，我们将使用图像作为…图像。
- en: The most basic approach to using images in your application is to import them
    into your `Assets` folder and reference them as Unity textures. A more advanced
    solution would be to dynamically find and load them at runtime. In this chapter,
    we'll use the former technique and build the list of images into the application.
    Let's start by importing the photos you want to use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用图片的最基本方法是将它们导入到您的`Assets`文件夹中，并将它们作为Unity纹理进行引用。一个更高级的解决方案是在运行时动态查找和加载它们。在本章中，我们将使用前者技术并将图像列表构建到应用程序中。让我们首先导入您想要使用的照片。
- en: Importing photos to use
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入照片以使用
- en: Go ahead and choose some images for your gallery from your favorites. Or you
    can use the images included with the files in this book's GitHub repository, containing
    a collection of freely usable nature photos found on Unsplash.com ([https://unsplash.com/](https://unsplash.com/))
    that I found, along with a photo of my own named `WinterBarn.jpg`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请从您的收藏夹中选择一些图像用于您的画廊。或者，您可以使用本书GitHub仓库中包含的图像，这些图像是从Unsplash.com（[https://unsplash.com/](https://unsplash.com/））找到的免费可用的自然照片集合，以及我自己的一张名为`WinterBarn.jpg`的照片。
- en: 'To import images into your project, use the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像导入到您的项目中，请按照以下步骤操作：
- en: In the `Photos` by right-clicking, then selecting **Create | Folder**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Photos`中，通过右键单击，然后选择**创建 | 文件夹**。
- en: From your Windows Explorer or OSX Finder, locate an image you want to use. Then
    drag the image file into Unity, dropping it in your `Photos/` folder.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的Windows资源管理器或OSX Finder中找到您想要使用的图像。然后将图像文件拖入Unity，将其放入`Photos/`文件夹中。
- en: In the **Inspector** window, you can check the size of the imported image. Because
    we're using it in AR and on a relatively low-resolution mobile device, let's limit
    the max size to 1,024 pixels. Note that Unity requires textures be imported into
    a size that is a power of 2 for best compression and runtime optimization. In
    the **Inspector**, ensure the **Default** tab is selected and choose **Max Size
    | 1024**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，您可以检查导入的图像的大小。因为我们将在AR和相对低分辨率的移动设备上使用它，所以让我们将最大尺寸限制为1,024像素。请注意，Unity要求将纹理导入到2的幂次大小，以获得最佳压缩和运行时优化。在**检查器**中，确保选择了**默认**选项卡，并选择**最大尺寸
    | 1024**。
- en: Now we'll add a way to reference your images in the scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一种在场景中引用您的图像的方法。
- en: Adding image data to the scene
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将图像数据添加到场景
- en: 'To add the image data to the scene, we''ll create an empty GameObject with
    an `ImagesData` script that contains a list of images. First, create a new C#
    script in your project''s `Scripts/` folder, name it `ImagesData`, and write it
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像数据添加到场景中，我们将创建一个包含图像列表的`ImagesData`脚本的空GameObject。首先，在您的项目`Scripts/`文件夹中创建一个新的C#脚本，命名为`ImagesData`，并编写如下：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script starts by defining an `ImageInfo` data structure containing the image
    `Texture` and the pixel dimensions of the image. It is `public` so it can be referenced
    from other scripts. Then the `ImagesData` class declares an array of this data
    in the `images` variable. The `ImageInfo` structure requires a `[System.Serializable]`
    directive so it will appear in the Unity Inspector.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先定义一个包含图像`Texture`和图像像素尺寸的`ImageInfo`数据结构。它是`public`的，因此可以从其他脚本中引用。然后`ImagesData`类在`images`变量中声明了这个数据结构的数组。`ImageInfo`结构需要`[System.Serializable]`指令，以便在Unity检查器中显示。
- en: 'Now we can add the image data to the scene, using the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下步骤将图像数据添加到场景中：
- en: From the main menu, select `Images Data` (reset its **Transform** for tidiness,
    using the 3-dot context menu and **Reset**).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择`Images Data`（使用三点上下文菜单和**重置**来整理其**变换**）。
- en: Drag the **ImagesData** script onto the **Images Data** object, making it a
    component.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **ImagesData** 脚本拖放到 **Images Data** 对象上，使其成为一个组件。
- en: To populate the `images` array, in the **Inspector**, enter the number of images
    you plan to use, or simply press the **+** button in the bottom right to incrementally
    add elements to the array.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要填充 `images` 数组，在 **检查器** 中输入你计划使用的图像数量，或者简单地按右下角的 **+** 按钮以递增方式向数组中添加元素。
- en: Add your imported image files one at a time by unfolding an **Element** from
    the **Images** list, then drag an image file from the **Project** window onto
    the **Texture** slot for the element. Please also enter the **Width** and **Height**
    in pixels of each image.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开 **Images** 列表中的一个 **Element**，逐个添加导入的图像文件，然后从 **项目** 窗口将图像文件拖放到元素的 **Texture**
    槽中。请务必输入每个图像的 **Width** 和 **Height** 像素值。
- en: 'My **Images Data** looks like this in the **Inspector**:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的 **Images Data** 在 **检查器** 中的样子如下：
- en: '![Figure 6.2 – Images Data component with a list of images'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 带有图像列表的图像数据组件'
- en: '](img/Figure_6.02-ImagesData-inspector.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像 6.02-图像数据检查器.jpg](img/Figure_6.02-ImagesData-inspector.jpg)'
- en: Figure 6.2 – Images Data component with a list of images
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 带有图像列表的图像数据组件
- en: Using ScriptableObjects
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ScriptableObjects
- en: A different, and probably better, approach to providing the list of images is
    to use ScriptableObjects instead of GameObjects. ScriptableObjects are data container
    objects that live in your `Assets/` folder rather than in the scene hierarchy.
    You can learn more about ScriptableObjects at [https://docs.unity3d.com/Manual/class-ScriptableObject.html](https://docs.unity3d.com/Manual/class-ScriptableObject.html)
    and [https://learn.unity.com/tutorial/introduction-to-scriptable-objects](https://learn.unity.com/tutorial/introduction-to-scriptable-objects).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提供图像列表的另一种，可能更好的方法，是使用 ScriptableObjects 而不是 GameObjects。ScriptableObjects 是存在于你的
    `Assets/` 文件夹中的数据容器对象，而不是在场景层次结构中。你可以在 [https://docs.unity3d.com/Manual/class-ScriptableObject.html](https://docs.unity3d.com/Manual/class-ScriptableObject.html)
    和 [https://learn.unity.com/tutorial/introduction-to-scriptable-objects](https://learn.unity.com/tutorial/introduction-to-scriptable-objects)
    上了解更多关于 ScriptableObjects 的信息。
- en: It is a little tedious having to manually enter the pixel dimensions of each
    image. It would be nice if there were a better way because that's not very easy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 手动输入每张图像的像素尺寸有点繁琐。如果能有一种更好的方法那就太好了，因为这样做并不容易。
- en: Obtaining the pixel dimensions of an image
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取图像的像素尺寸
- en: 'Unfortunately, when Unity imports an image as a texture, it resizes it to a
    power of two to optimize runtime performance and compression, and the original
    dimension data is not preserved. There are several ways around this, none of which
    are very pretty:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当 Unity 将图像导入为纹理时，它会将其缩放到 2 的幂以优化运行时性能和压缩，并且原始尺寸数据不会被保留。有几种方法可以解决这个问题，但没有一种是特别美观的：
- en: Require the developer to specify the pixel dimensions manually for each image.
    This is the approach we are taking here.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求开发者手动为每个图像指定像素尺寸。这是我们在这里采取的方法。
- en: Tell Unity to not resize the image when it is imported. For this, select an
    image asset, and in its `Texture.width` and `Texture.height`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉 Unity 在导入图像时不进行缩放。为此，选择一个图像资产，并在其 `Texture.width` 和 `Texture.height`。
- en: Take the first method but automatically determine the pixel size using an Editor
    script. Unity allows you to write scripts that only run in the Editor, not runtime.
    The Editor has access to the original image file in your **Assets** folder before
    it has been imported as a texture. So it's possible to read and query this information,
    either using system I/O functions, or possibly (undocumented) the Unity API (see
    [https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/](https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/)).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用第一种方法，但使用编辑器脚本来自动确定像素大小。Unity 允许你编写仅在编辑器中运行的脚本，而不是在运行时。编辑器在将原始图像文件导入为纹理之前，可以访问你的
    **Assets** 文件夹中的原始图像文件。因此，可以使用系统 I/O 函数或可能是（未记录的）Unity API（见 [https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/](https://forum.unity.com/threads/getting-original-size-of-texture-asset-in-pixels.165295/)）来读取和查询这些信息。
- en: Given that, we'll stick with the manual approach in this chapter, and you can
    explore the other options on your own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 既然如此，我们将在本章中坚持手动方法，你可以自己探索其他选项。
- en: Perhaps you're also wondering, what if I don't want to build the images into
    my project and want to find and load them at runtime?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你还在想，如果我不想将图像构建到我的项目中，想在运行时查找和加载它们怎么办？
- en: Loading the pictures list at runtime
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在运行时加载图片列表
- en: 'Loading assets at runtime from outside your build is an advanced topic and
    outside the scope of this chapter. There are several different approaches that
    I will briefly describe, and I will point you to more information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时从构建外部加载资源是一个高级主题，并且超出了本章的范围。我将简要描述几种不同的方法，并将提供更多信息的链接：
- en: '**Including images in Asset Bundles**: In Unity, you have the option of bundling
    assets into an Asset Bundle that the application can download after the user has
    installed the app, as **downloadable content** (**DLC**). See [https://docs.unity3d.com/Manual/AssetBundlesIntro.html](https://docs.unity3d.com/Manual/AssetBundlesIntro.html).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在资源包中包含图像**：在Unity中，你可以选择将资源打包到资源包中，应用程序在用户安装应用程序后可以下载这些资源，作为**可下载内容**（**DLC**）。请参阅[https://docs.unity3d.com/Manual/AssetBundlesIntro.html](https://docs.unity3d.com/Manual/AssetBundlesIntro.html)。'
- en: '**Downloading images from a web URL**: If you have the web address of an image
    file, you can download the image at runtime using a web request and use it as
    a texture in the app. See [https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html](https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从网络URL下载图像**：如果你有图像文件的网址，你可以使用网络请求在运行时下载图像，并将其用作应用程序中的纹理。请参阅[https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html](https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequestTexture.GetTexture.html)。'
- en: '**Getting images from the device''s photos app**: For an application such as
    our Gallery, it''s natural to want to get photos from the user''s own photos app.
    To access data from other apps on the mobile device you need a library with native
    access. It may also require your app to obtain additional permissions from the
    user. Search the Unity Asset Store for packages.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从设备的照片应用获取图像**：对于像我们的图库这样的应用程序，从用户的照片应用中获取照片是很自然的。要访问移动设备上其他应用程序的数据，你需要一个具有本地访问权限的库。这也可能需要你的应用程序从用户那里获得额外的权限。在Unity
    Asset Store中搜索包。'
- en: If you want to implement these features, I'll leave that up to you.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想实现这些功能，那就由你自己来决定。
- en: We have now imported the photos we plan to use, created a C# `ImageInfo` data
    structure including the pixel dimensions of each image, and populated this image
    data in the scene. Let's create a framed photo prefab containing a default image
    and a picture frame that we can place on a wall plane.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经导入了我们计划使用的照片，创建了一个包含每个图像像素尺寸的C# `ImageInfo`数据结构，并在场景中填充了这些图像数据。让我们创建一个包含默认图像和可以放置在墙面上的照片框架的装框照片预制体。
- en: Creating a framed photo prefab
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个装框照片预制体
- en: The user will be placing a framed photo on their walls. So, we need to create
    a prefab game object that will be instantiated. We want to make it easy to change
    images and frames, as well as resize them for various orientations (landscape
    versus portrait) and image aspect ratios. For the default frame, we'll create
    a simple block from a flattened 3D cube and mount the photo on the face of it.
    For the default image, you may choose your own or use one that's included with
    the files for this chapter in the GitHub repository.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将在他们的墙上放置一个装框的照片。因此，我们需要创建一个预制游戏对象，它将被实例化。我们希望使其易于更改图像和框架，以及根据不同的方向（横向与纵向）和图像宽高比进行缩放。对于默认框架，我们将从一个压扁的3D立方体创建一个简单的块，并将照片安装在其表面上。对于默认图像，你可以选择自己的，或者使用GitHub仓库中本章文件包含的一个。
- en: Creating the prefab hierarchy
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制体层次结构
- en: 'First, create an empty prefab named `FramedPhoto` in your project''s `Assets/`
    folder. Follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在项目文件夹的`Assets/`中创建一个名为`FramedPhoto`的空预制体。按照以下步骤操作：
- en: In the `Prefabs/` folder (create one if needed). Then *right-click* in the folder
    and select **Create | Prefab**.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹中（如果需要，请创建一个）。然后在该文件夹中*右键单击*并选择**创建 | 预制体**。
- en: Rename the new prefab `FramedPhoto`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新预制体重命名为`FramedPhoto`。
- en: '*Double-click* the **FramedPhoto** asset (or click its **Open Prefab** button
    in the **Inspector** window).'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击* **FramedPhoto** 资产（或在**检查器**窗口中点击其**打开预制体**按钮）。'
- en: We're now editing the empty prefab.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在正在编辑一个空预制体。
- en: Add a child `AspectScaler`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个子`AspectScaler`。
- en: Let's create a modern-looking rectangular black frame using a flattened cube.
    With the `Frame`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用一个压扁的立方体来创建一个看起来现代的黑色矩形框架。使用`Frame`。
- en: Give the frame some thickness. In the frame's `0.05` (that's in meters).
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给框架一些厚度。在框架的`0.05`（这是以米为单位）。
- en: Likewise, offset it from the wall by setting `-0.025`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，通过设置`-0.025`将其从墙上偏移。
- en: To give this frame a black finish, create and add a new material as follows.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要给这个框架一个黑色表面，创建并添加一个新的材质，如下所示。
- en: In the `Materials/` folder (create one if needed). Then *right-click* in the
    folder and select `Black Frame Material`.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Materials/` 文件夹中（如果需要，请创建一个）。然后 *右键单击* 文件夹并选择 `Black Frame Material`。
- en: Set its **Base Map** color to a charcoal black color.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其 **基础地图** 颜色设置为炭黑色。
- en: Then, in the **Hierarchy**, select the **Default Frame** object and drag the
    **Black Frame Material** onto it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 **层次结构** 中，选择 **Default Frame** 对象，并将 **Black Frame Material** 拖放到它上面。
- en: 'The current frame properties are shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当前的框架属性：
- en: '![Figure 6.3 – The FramedPhoto''s frame properties'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – FramedPhoto的框架属性'
- en: '](img/Figure_6.03-FrameProperties.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.03-FrameProperties.jpg)'
- en: Figure 6.3 – The FramedPhoto's frame properties
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – FramedPhoto的框架属性
- en: 'Next, we''ll add a default image to the `WinterBarn.jpg` that is included with
    the files for this book. Use the following steps to create an image object with
    a material that uses this photo as its texture image:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向包含在此书文件中的 `WinterBarn.jpg` 添加一个默认图像。使用以下步骤创建一个使用此照片作为纹理图像的材质图像对象：
- en: With the `Image`. A **quad** is the simplest Unity 3D primitive object, a flat
    quadrilateral plane with only four edges and facing in a single direction.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Image`。一个 **quad** 是最简单的Unity 3D基本对象，是一个只有四个边且朝一个方向的面板。
- en: To add your image as a texture on the quad, we need to create a material. In
    the `Materials/` folder, *right-click* in the folder and select `Image Material`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将你的图像作为quad上的纹理添加，我们需要创建一个材质。在 `Materials/` 文件夹中，*右键单击* 文件夹并选择 `Image Material`。
- en: Drag your image file (`WinterBarn.jpg`) from the **Project** window into the
    **Inspector** window, dropping it onto the little square "chip" slot on the left
    side of the **Base Map** property.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的图像文件（`WinterBarn.jpg`）从 **项目** 窗口拖动到 **检查器** 窗口，将其放置在 **基础地图** 属性左侧的小正方形“芯片”槽中。
- en: Drag the **Image Material** onto the **Image** game object.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Image Material** 拖动到 **Image** 游戏对象上。
- en: Offset the image quad so it's slightly in front of the frame cube's plane. Set
    its `-0.06`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像quad偏移，使其略微位于框架立方体的平面之前。设置其 `-0.06`。
- en: You should be able to see the image now. But the frame is hidden because the
    image quad is scaled to the same size as the frame. Shrink the image by setting
    its `0.9`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能看到图像。但是框架是隐藏的，因为图像quad被缩放到了与框架相同的大小。通过设置其 `0.9` 来缩小图像。
- en: 'The prefab hierarchy now looks like the following screenshot, where the image
    is currently selected and visible in the **Inspector**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件层次结构现在看起来如下截图所示，其中图像当前被选中并在 **检查器** 中可见：
- en: '![Figure 6.4 – The FramedPhoto prefab'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – FramedPhoto预制件'
- en: '](img/Figure_6.04-FramedPhoto-prefab.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.04-FramedPhoto-prefab.jpg)'
- en: Figure 6.4 – The FramedPhoto prefab
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – FramedPhoto预制件
- en: Next, let's add a simple script that will help our other code set the image
    of a **FramedPhoto** object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个简单的脚本，它将帮助我们的其他代码设置 **FramedPhoto** 对象的图像。
- en: Writing a FramedPhoto script
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写FramedPhoto脚本
- en: We are going to need to set various properties of each instance of the `SetImage`
    function for this that gets the image data for this picture.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要为 `SetImage` 函数的每个实例设置各种属性，该函数获取此图片的图像数据。
- en: 'Create a new C# script named `FramedPhoto`, open it for editing, and write
    the script as follows::'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `FramedPhoto` 的新C#脚本，打开它进行编辑，并编写以下脚本：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the top of the `FramedPhoto` class, we declare two properties. The `imageObject`
    is a reference to the child `scalerObject` is a reference to the **AspectScaler**
    for when the script needs to change its aspect ratio (we do this at the end of
    this chapter).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FramedPhoto` 类的顶部，我们声明了两个属性。`imageObject` 是对子 `scalerObject` 的引用，`scalerObject`
    是对 **AspectScaler** 的引用，当脚本需要更改其纵横比时（我们在本章末尾这样做）。
- en: When a `SetImage` to change the `Renderer`, then gets its `Material`, and then
    sets its base texture.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `SetImage` 用于更改 `Renderer`，然后获取其 `Material`，接着设置其基础纹理。
- en: 'We can now add this script to the prefab as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将此脚本按以下方式添加到预制件中：
- en: With the **FramedPhoto** prefab opened for editing, drag the **FramedPhoto**
    script onto the **FramedPhoto** root object to make it a component.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑 **FramedPhoto** 预制件时，将 **FramedPhoto** 脚本拖动到 **FramedPhoto** 根对象上，使其成为一个组件。
- en: From the **Hierarchy**, drag the **AspectScaler** object into the **Inspector**
    and drop it onto the **Framed Photo | Scaler Object** slot.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 中，将 **AspectScaler** 对象拖动到 **检查器** 并将其放置在 **Framed Photo | Scaler
    Object** 槽中。
- en: From the **Hierarchy**, drag the **Image** object onto the **Framed Photo |
    Image Object** slot.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 中，将 **Image** 对象拖动到 **Framed Photo | Image Object** 槽中。
- en: Our prefab is now almost ready to be used. Of course, the picture we're using
    isn't really supposed to be square, so let's scale it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预制件现在几乎准备好使用了。当然，我们使用的图片并不是真的应该是正方形的，所以让我们将其缩放。
- en: Scaling the picture's shape
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放图片的形状
- en: 'The photo I''m using by default is landscape orientation, but our frame is
    square, so it looks squished. To fix it, we need to get the original pixel size
    of the image and calculate its aspect ratio. For example, the `WinterBarn.jpg`
    image included on GitHub for this book is 4,032x3,024 (width x height), or 3:4
    (`height:width` landscape ratio). Let''s scale it now for the image''s aspect
    ratio (`0.75`). Follow these steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我默认使用的照片是横向的，但我们的框架是正方形的，所以看起来被压扁了。为了修复它，我们需要获取图像的原始像素大小并计算其宽高比。例如，GitHub上包含在此书中的`WinterBarn.jpg`图像是4,032x3,024（宽度x高度），或3:4（`高度:宽度`的横向比例）。现在让我们根据图像的宽高比（`0.75`）进行缩放。按照以下步骤操作：
- en: In the **Hierarchy** window, select the **Scaler** object.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**缩放器**对象。
- en: Set its `0.75` (if your image is portrait, scale the `1.0`).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`0.75`（如果你的图像是竖直的，则缩放`1.0`）。
- en: 'The properly scaled prefab now looks like the following:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确缩放的预制件现在看起来如下：
- en: '![Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio]'
- en: '](img/Figure_6.05-FramedPhoto-aspect.jpg)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_6.05-FramedPhoto-aspect.jpg]'
- en: Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Figure 6.5 – FramedPhoto prefab with corrected 3:4 landscape aspect ratio
- en: Save the prefab by clicking the **Save** button in the top-right of the **Scene**
    window.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**场景**窗口右上角的**保存**按钮保存预制件。
- en: Return to the scene editor using the **<** button in the top-left of the **Hierarchy**
    window.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**<**按钮返回场景编辑器，该按钮位于**层次结构**窗口的左上角。
- en: Setting up the `1, 1, 1`) regardless of the aspect ratio of the photo within
    it or the thickness of the frame. This will help with the user interface for placing
    and scaling the framed photo in the scene.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`1, 1, 1`)，无论其中照片的宽高比或框架的厚度如何。这将有助于放置和缩放场景中带框照片的用户界面。
- en: The `0.75` height for the 3:4 aspect ratio.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3:4宽高比的高度为`0.75`。
- en: The `0.05` size border, so the `0.9`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`0.05`大小的边框，所以`0.9`。'
- en: The front-back offset of the image will also depend on the frame's model. In
    this case, I moved it closer, `-0.06` versus `-0.025` units, so it sits slightly
    in front of the frame's surface.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图像的前后偏移量也将取决于框架的模型。在这种情况下，我将它移得更近，从`-0.06`到`-0.025`单位，因此它稍微位于框架表面之前。
- en: When assembling a prefab, thinking through how it can head off gotchas later.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当组装预制件时，思考它如何避免后续的麻烦。
- en: In this section, we created a scalable `Assets` folder so copies can be instantiated
    in the scene when the user places a picture on a wall. The prefab includes a `FramedPhoto`
    script that manages some aspects of the behavior of the prefab, including setting
    its image texture. This script will be expanded later in the chapter. We now have
    a **FramedPhoto** prefab with a frame. We're ready to add the user interaction
    for placing pictures on your walls.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个可缩放的`Assets`文件夹，以便当用户在墙上放置图片时，可以在场景中实例化副本。预制件包括一个`FramedPhoto`脚本，该脚本管理预制件的一些行为方面，包括设置其图像纹理。这个脚本将在本章后面进行扩展。我们现在有一个带有框架的**FramedPhoto**预制件。我们准备好添加放置图片在墙上的用户交互。
- en: Hanging a virtual photo on your wall
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在墙上挂虚拟照片
- en: For this project, the app scans the environment for vertical planes. When the
    user wants to hang a picture on the wall, we'll show a UI panel that instructs
    the user to tap to place the object, using an animated graphic. Once the user
    taps the screen, the **AddPicture** mode instantiates a **FramedPhoto** prefab,
    so it appears to hang on the wall, upright and flush against the wall plane. Many
    of these steps are similar to what we did in [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*,
    Using the AR User Framework*, so I'll offer a little less explanation here. We'll
    start with a similar script and then enhance it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，应用会扫描环境中的垂直平面。当用户想要在墙上挂一幅画时，我们会显示一个UI面板，指导用户点击放置对象，并使用动画图形。一旦用户点击屏幕，**AddPicture**模式就会实例化一个**FramedPhoto**预制件，使其看起来挂在墙上，垂直且与墙面平面齐平。许多这些步骤与我们之前在[*第5章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*，使用AR用户框架*中做的类似，所以这里我会提供较少的解释。我们将从一个类似的脚本开始，然后进行增强。
- en: Detecting vertical planes
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测垂直平面
- en: 'Given the AR Session Origin already has an AR Plane Manager component (provided
    in the default `ARFramework` template), use the following steps to set up the
    scene to scan for vertical planes (instead of horizontal ones):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AR会话原点已经有一个AR Plane Manager组件（在默认的`ARFramework`模板中提供），请按照以下步骤设置场景以扫描垂直平面（而不是水平平面）：
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR会话原点**对象。
- en: In its **Inspector** window, set the **AR Plane Manager | Detection Mode** to
    **Vertical** by first selecting **Nothing** (clearing all the selections) and
    then selecting **Vertical**.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**检查器**窗口中，首先选择**Nothing**（清除所有选择），然后选择**Vertical**，将**AR Plane Manager |
    Detection Mode**设置为**垂直**。
- en: Now let's create the **AddPicture** UI panel that prompts the user to tap a
    vertical plane to place a new picture.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个**AddPicture** UI面板，提示用户点击垂直平面以放置新图片。
- en: Creating the AddPicture UI panel
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AddPicture UI面板
- en: 'The **AddPicture UI** panel is similar to the **Scan UI** one included with
    the scene template, so we can duplicate and modify it as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**AddPicture UI**面板类似于场景模板中包含的**Scan UI**，因此我们可以复制并按以下方式修改它：'
- en: In the **Hierarchy** window, unfold the **UI Canvas**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，展开**UI Canvas**。
- en: '*Right-click* the `AddPicture UI`.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击* `AddPicture UI`。'
- en: Unfold **AddPicture UI** and select its child, **Animated Prompt**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**AddPicture UI**并选择其子项，**动画提示**。
- en: In the **Inspector**, set the **Animated Prompt | Instruction** to **Tap To
    Place**.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**动画提示 | 指示**设置为**点击放置**。
- en: To add the panel to the UI Controller, in the **Hierarchy**, select the **UI
    Canvas** object.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将面板添加到UI控制器中，在**层次结构**中，选择**UI Canvas**对象。
- en: In the **Inspector**, at the bottom-right of the **UI Controller** component,
    click the **+** button to add an item to the UI Panels dictionary.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，在**UI Controller**组件的右下角点击**+**按钮，向UI Panels字典中添加一个项。
- en: Enter `AddPicture` in the **Id** field.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**字段中输入`AddPicture`。
- en: Drag the **AddPicture UI** game object from the **Hierarchy** onto the **Value**
    slot.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中将**AddPicture UI**游戏对象拖动到**值**槽位。
- en: We added an instructional user prompt for the **AddPicture** UI. When the user
    chooses to add a picture to the scene, we'll go into **AddPicture** mode, and
    this panel will be displayed. Let's create the **AddPicture** mode now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为**AddPicture** UI添加了一个指导性用户提示。当用户选择将图片添加到场景中时，我们将进入**AddPicture**模式，并显示此面板。现在让我们创建**AddPicture**模式。
- en: Writing the initial AddPictureMode script
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写初始AddPictureMode脚本
- en: To add a mode to the framework, we create a child GameObject under the **Interaction
    Controller** and write a mode script. The mode script will show the mode's UI,
    handle any user interactions, and then transition to another mode when it is done.
    For AddPicture mode, it will display the **AddPicture UI** panel, wait for the
    user to tap the screen, instantiate the prefab object, and then return to main
    mode.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模式添加到框架中，我们在**Interaction Controller**下创建一个子GameObject并编写一个模式脚本。模式脚本将显示模式的UI，处理任何用户交互，并在完成后过渡到另一个模式。对于AddPicture模式，它将显示**AddPicture
    UI**面板，等待用户点击屏幕，实例化预制对象，然后返回主模式。
- en: The script starts out like the `PlaceObjectMode` script we wrote in [*Chapter
    5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*, Using the AR User Framework*.
    Then we'll enhance it to ensure the framed picture object is aligned with the
    wall plane, facing into the room, and hanging straight.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本开始时类似于我们在[*第五章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*中编写的`PlaceObjectMode`脚本，使用*AR用户框架*。然后我们将增强它以确保框架中的图片对象与墙面平面对齐，面向房间，并垂直悬挂。
- en: 'Let''s write the `AddPictureMode` script, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写`AddPictureMode`脚本，如下所示：
- en: Begin by creating a new script in your project's `Scripts/` folder by right-clicking
    and selecting `AddPictureMode`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过右键单击并选择`AddPictureMode`在你的项目的`Scripts/`文件夹中创建一个新的脚本。
- en: '*Double-click* the file to open it for editing. Paste the following code, which
    is the same as the **PlaceObjectMode** script you may already have to hand, with
    differences highlighted. The first half of the script is as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*文件以打开它进行编辑。粘贴以下代码，它与您可能已经拥有的**PlaceObjectMode**脚本相同，但有差异突出显示。脚本的前半部分如下：'
- en: '[PRE2]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The second part of the script is actually unchanged from the `PlaceObjectMode`
    script:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的后半部分实际上与`PlaceObjectMode`脚本没有变化：
- en: '[PRE3]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the top of `AddPictureMode`, we declare a `placedPrefab` variable that will
    reference the `ARRaycastManager` and a private list of `ARRaycaseHit hits` that
    we'll use in the `PlaceObject` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AddPictureMode` 的顶部，我们声明了一个 `placedPrefab` 变量，它将引用 `ARRaycastManager` 和一个私有的
    `ARRaycaseHit hits` 列表，我们将在 `PlaceObject` 函数中使用它。
- en: When the mode is enabled, we show the `AddPicture` UI panel. Then, when there's
    an `OnPlaceObject` user input action event, `PlaceObject` does a `Raycast` on
    the trackable planes. If there's a hit, it instantiates a copy of the **FramedPhoto**
    into the scene, and then goes back to main mode.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式启用时，我们显示 `AddPicture` UI 面板。然后，当有 `OnPlaceObject` 用户输入动作事件时，`PlaceObject`
    对可追踪平面进行 `Raycast`。如果有碰撞，它将在场景中实例化一个 **FramedPhoto** 的副本，然后返回到主模式。
- en: Let's go with this initial script for now and fix any problems we discover later.
    The next step is to add the AddPicture mode to the app.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用这个初始脚本，稍后修复我们发现的任何问题。下一步是将 AddPicture 模式添加到应用中。
- en: Creating the AddPicture Mode object
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AddPicture 模式对象
- en: 'We can now add the AddPicture mode to the scene by creating an **AddPicture
    Mode** object under the **Interaction Controller**, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在 **Interaction Controller** 下创建一个 **AddPicture Mode** 对象来将 AddPicture
    模式添加到场景中，如下所示：
- en: In the `AddPicture Mode`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AddPicture Mode`。
- en: Drag the `AddPictureMode` script from the **Project** window onto the **AddPicture
    Mode** object, adding it as a component.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `AddPictureMode` 脚本从 **Project** 窗口拖动到 **AddPicture Mode** 对象上，将其添加为组件。
- en: Drag the **AR Session Origin** object from the **Hierarchy** onto the **Add
    Picture Mode | Raycaster** slot.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AR Session Origin** 对象从 **Hierarchy** 拖动到 **Add Picture Mode | Raycaster**
    插槽。
- en: Locate your **FramedPhoto Prefab** asset in the **Project** window and drag
    it onto the **Add Picture Mode | Placed Prefab** slot. The **AddPicture Mode**
    component now looks like the following (note that this screenshot also shows two
    more parameters, **Image Data** and **Default Scale**, that we add to the script
    at the end of this chapter):![Figure 6.6 – AddPicture Mode added to the scene
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 窗口中定位你的 **FramedPhoto Prefab** 资产，并将其拖动到 **Add Picture Mode |
    Placed Prefab** 插槽。现在 **AddPicture Mode** 组件看起来如下（注意，此截图还显示了我们在本章末尾添加到脚本中的两个更多参数，**Image
    Data** 和 **Default Scale**）：![图 6.6 – 场景中添加了 AddPicture 模式
- en: '](img/Figure_6.06-addpicturemode-insp.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.06-addpicturemode-insp.jpg)'
- en: Figure 6.6 – AddPicture Mode added to the scene
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.6 – 场景中添加了 AddPicture 模式
- en: Now we'll add the mode to the **Interaction Controller**. In the **Hierarchy**,
    select the **Interaction Controller** object.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将模式添加到 **Interaction Controller**。在 **Hierarchy** 中选择 **Interaction Controller**
    对象。
- en: In the **Inspector**, at the bottom-right of the **Interaction Controller**
    component, click the **+** button to add an item to the **Interaction Modes**
    dictionary.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中，在 **Interaction Controller** 组件的右下角点击 **+** 按钮向 **Interaction
    Modes** 字典添加一个项。
- en: Enter `AddPicture` in the **Id** field.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Id** 字段中输入 `AddPicture`。
- en: 'Drag the **AddPicture Mode** game object from the **Hierarchy** onto the **Value**
    slot. The Interaction Controller component now looks like the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AddPicture Mode** 游戏对象从 **Hierarchy** 拖动到 **Value** 插槽。交互控制器组件现在看起来如下：
- en: '![Figure 6.7 – Interaction Controller with AddPicture Mode added to the Interaction
    Modes dictionary'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 在交互模式字典中添加了 AddPicture 模式的交互控制器'
- en: '](img/Figure_6.07-interactioncont-addpicture.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.07-interactioncont-addpicture.jpg)'
- en: Figure 6.7 – Interaction Controller with AddPicture Mode added to the Interaction
    Modes dictionary
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 在交互模式字典中添加了 AddPicture 模式的交互控制器
- en: We now have an **AddPicture** mode that will be enabled from **Main** mode when
    the user clicks an **Add** button. Let's create this button now.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 **Addpicture** 模式，当用户点击 **Add** 按钮时将从 **Main** 模式启用。现在让我们创建这个按钮。
- en: Creating a main menu Add button
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主菜单添加按钮
- en: 'When the app is in Main mode, the **Main UI** panel is displayed. On this panel,
    we''ll have an **Add** button for the user to press when they want to place a
    new picture in the scene. I''ll use a large plus sign as its icon, with the following
    steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用处于主模式时，**Main UI** 面板显示。在这个面板上，我们将有一个 **Add** 按钮供用户在想要在场景中放置新图片时按下。我将使用一个大的加号作为其图标，以下步骤：
- en: In the **Hierarchy** window, unfold the **UI Canvas** object, and unfold its
    child **Main UI** object.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中，展开 **UI Canvas** 对象，然后展开其子 **Main UI** 对象。
- en: The default child text in the panel is a temporary placeholder; we can remove
    it. *Right-click* the child **Text** object and select **Delete**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面板中的默认子文本是一个临时占位符；我们可以将其删除。*右键点击* 子 **Text** 对象并选择 **Delete**。
- en: Now we add a button. *Right-click* the `Add Button`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一个按钮。*右键单击*`Add Button`。
- en: With the **Add Button** selected, in its **Inspector** window use the *anchor
    menu* (upper-left) to select a **Bottom-Right** anchor. Then press *Shift + Alt
    +* click **Bottom-Right** to also set its **Pivot** and **Position** in that corner.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加按钮**，在其**检查器**窗口中使用**锚点菜单**（左上角）选择**底右**锚点。然后按*Shift + Alt +*点击**底右**以在该角落设置其**枢轴**和**位置**。
- en: Adjust the button size and position, either using the *Rect Tool* from the `175,
    175`), and`-30, 30`), as shown in the following screenshot:![Figure 6.8 – The
    Add button Rect Transform settings
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整按钮大小和位置，可以使用以下截图中的**矩形工具**（`175, 175`），和`-30, 30`），如下所示：![图6.8 – 添加按钮矩形变换设置
- en: '](img/Figure_6.08-Addbutton-recttransform-insp.jpg)'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.08-Addbutton-recttransform-insp.jpg)'
- en: Figure 6.8 – The Add button Rect Transform settings
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.8 – 添加按钮矩形变换设置
- en: In the **Hierarchy** window, unfold the **Add Button** by clicking its *triangle-icon*
    and select its child object, **Text (TMP)**.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，通过点击其**三角形图标**展开**添加按钮**，并选择其子对象，**文本（TMP）**。
- en: Set its `+` and set its `192`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`+`并设置其`192`。
- en: You can add another text element to label the button. *Right-click* the `Add`,
    `24`, `55`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以添加另一个文本元素来标记按钮。*右键单击*`Add`，`24`，`55`。
- en: 'Our button now looks like the following:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在按钮看起来如下：
- en: '![Figure 6.9 – The Add button'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图6.9 – 添加按钮'
- en: '](img/Figure_6.09-AddButton-view.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_6.09-AddButton-view.jpg)'
- en: Figure 6.9 – The Add button
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.9 – 添加按钮
- en: To set up the button to enable **PlacePicture Mode**, select the **Add Button**
    in the **Hierarchy**. In its **Inspector**, in the **OnClick** section of the
    **Button** component, press the **+** button on the bottom-right to add an event
    action.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置按钮以启用**放置图片模式**，在**层次结构**中选择**添加按钮**。在其**检查器**中，在**按钮组件**的**OnClick**部分，按下底部的**+**按钮以添加事件动作。
- en: Drag the **Interaction Controller** from the **Hierarchy** and drop it onto
    the **Object** slot of the **OnClick** action.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中拖动**交互控制器**并将其放置在**OnClick动作**的**对象**槽中。
- en: In the **Function** select list, choose **InteractionController | EnableMode**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**函数选择列表**中，选择**交互控制器 | 启用模式**。
- en: In its string parameter field, enter the text `AddPicture`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其字符串参数字段中，输入文本`AddPicture`。
- en: 'The **On Click** property of now looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的**OnClick**属性看起来如下：
- en: '![Figure 6.10 – When the Add button is clicked, it calls EnableMode("AddPicture")'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.10 – 当添加按钮被点击时，它调用EnableMode("AddPicture")'
- en: '](img/Figure_6.10-Addbutton-onclick.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10-Addbutton-onclick.jpg)'
- en: Figure 6.10 – When the Add button is clicked, it calls EnableMode("AddPicture")
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 当点击添加按钮时，它调用EnableMode("AddPicture")
- en: We have now added **AddPicture Mode** to our framework. It will be enabled by
    the Interaction Controller when the **Add** button is clicked. When enabled, the
    script shows the **AddPicture** instructional UI, then waits for a **PlaceObject**
    input action event. Then it uses Raycast to determine where in 3D space the user
    wants to place the object, instantiates the prefab, and then returns to Main mode.
    Let's try it out.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将**AddPicture模式**添加到我们的框架中。当点击**添加**按钮时，交互控制器将启用它。启用后，脚本显示**AddPicture**指导UI，然后等待**放置对象**输入动作事件。然后它使用射线投射来确定用户想在3D空间中的哪个位置放置对象，实例化预制体，然后返回主模式。让我们试试。
- en: Build And Run
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和运行
- en: 'Save the scene. If you want to try and see how it looks, you can now **Build
    And Run**, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景。如果您想尝试并查看其外观，现在可以**构建和运行**，如下所示：
- en: Select **File | Build Settings**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 | 构建设置**。
- en: Click the `ARGallery`) is not already in the **Scenes In Build** list.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`ARGallery`)是否已在**场景在构建**列表中。
- en: Ensure that the `ARGallery` scene is the only one checked in the **Scenes In
    Build** list.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**场景在构建**列表中只选中了`ARGallery`场景。
- en: Click **Build And Run** to build the project.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**构建和运行**以构建项目。
- en: The app will start and prompt you to scan the room. Slowly move your device
    around to scan the room, concentrating on the general area of the walls where
    you want to place the photos.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将启动并提示您扫描房间。慢慢移动您的设备以扫描房间，集中注意您想放置照片的墙壁大致区域。
- en: What makes for good plane detection?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 什么因素有助于良好的平面检测？
- en: When AR plane detection uses the device's built-in white light camera for scanning
    the 3D environment, it relies on good visual fidelity of the camera image. The
    room should be well lit. The surfaces being scanned should have distinctive and
    random textures to assist the detection software. For example, our AR Gallery
    project may have difficulty detecting vertical planes if your walls are too smooth.
    (Newer devices may include other sensors, such as laser-based **LIDAR** depth
    sensors that don't suffer from these limitations). If your device has trouble
    detecting vertical wall planes, try strategically adding some sticky notes or
    other markers on the walls to make the surfaces more distinctive to the software.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当AR平面检测使用设备内置的白色光摄像头扫描3D环境时，它依赖于摄像头图像的良好视觉保真度。房间应该光线充足。被扫描的表面应该具有独特且随机的纹理，以帮助检测软件。例如，如果您的墙壁太光滑，我们的AR画廊项目可能难以检测垂直平面。（较新的设备可能包括其他传感器，例如基于激光的**LIDAR**深度传感器，这些传感器不受这些限制）。如果您的设备在检测垂直墙面平面时遇到困难，请尝试在墙上战略性地添加一些贴纸或其他标记，使表面对软件更具辨识度。
- en: 'When at least one vertical plane is detected, the scan prompt will disappear,
    and you''ll see the Main UI **Add** button. Tapping the **Add** button will enable
    **AddPicture Mode**, showing the **AddPicture** UI panel with its tap-to-place
    instructional graphic. When you tap a tracked plane, the **FramedPhoto** prefab
    will be instantiated in the scene. Here''s what mine looks like, on the left side:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当至少检测到一个垂直平面时，扫描提示将消失，你将看到主UI的**添加**按钮。点击**添加**按钮将启用**添加图片模式**，显示带有点击放置说明图形的**添加图片**UI面板。当你点击一个跟踪到的平面时，**FramedPhoto**预制件将在场景中实例化。以下是我的样子，在左侧：
- en: '![Figure 6.11 – Placing an object on the wall (left) and correcting for surface
    normal and upright (right)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 – 在墙上放置一个物体（左）和校正表面法线和垂直（右）'
- en: '](img/Figure_6.11-PlaceOnWall.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.11 – 在墙上放置一个物体（左）和校正表面法线和垂直（右）'
- en: Figure 6.11 – Placing an object on the wall (left) and correcting for surface
    normal and upright (right)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 在墙上放置一个物体（左）和校正表面法线和垂直（右）
- en: Oops! The picture is sticking out of the wall perpendicularly, as shown in the
    preceding screenshot (on the left side). We want it to hang like a picture on
    the wall like in the right-hand image. Let's update the script to take care of
    this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！图片垂直地从墙上突出出来，如前一张截图（左侧所示）。我们希望它像右侧图像中的墙上的画一样悬挂。让我们更新脚本以处理这个问题。
- en: Completing the AddPictureMode script
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成AddPictureMode脚本
- en: 'There are a number of improvements we need to implement to complete the `AddPictureMode`
    script, including the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实施一些改进来完成`AddPictureMode`脚本的编写，包括以下内容：
- en: Rotate the picture so it is upright and flat against the wall plane.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图片旋转，使其垂直并平贴在墙面平面上。
- en: Tell the picture which image to show in its frame.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉图片在其框架中显示哪张图片。
- en: Include a default scale when the picture is first placed on a wall.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图片首次放置在墙上时，包括一个默认的缩放比例。
- en: 'The `AddPictureMode` script contains the following line in the code that sets
    the rotation to `hitPose.rotation`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddPictureMode`脚本中包含以下设置旋转为`hitPose.rotation`的代码行：'
- en: '[PRE4]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the previous screenshot, the "up" direction of a tracked plane
    is perpendicular to the surface of the plane, so with this code the picture appears
    to be sticking out of the wall. It makes sense to instantiate a placed object
    using this default up direction for horizontal planes, where you want your object
    standing up on the floor or a table. But in this project, we don't want to do
    that. We want the picture to be facing in the same direction as the wall. And
    we want it hanging straight up/down.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在上一张截图中所见，跟踪平面的“向上”方向垂直于平面表面，因此，使用此代码图片看起来像是从墙上突出出来。对于水平平面，您希望物体站立在地板或桌子上，因此使用此默认向上方向实例化放置的物体是有意义的。但在本项目，我们不想这样做。我们希望图片与墙面朝向相同。我们希望它垂直向上/向下悬挂。
- en: Instead of using the `hit.pose.rotation`, we should calculate the rotation using
    the plane's normal vector (`pose.up`). Then we call the `Quaternion.LookRotation`
    function to create a rotation with the specified forward and upward directions
    (see [https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html](https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该使用`hit.pose.rotation`，而应该使用平面的法线向量（`pose.up`）来计算旋转。然后我们调用`Quaternion.LookRotation`函数来创建具有指定前进和向上方向的旋转（见[https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html](https://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html)）。
- en: Quaternions
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数
- en: A quaternion is a mathematical construct that can be used to represent rotations
    in computer graphics. As a Unity developer, you simply need to know that rotations
    in Transforms use the `Quaternion` class. See [https://docs.unity3d.com/ScriptReference/Quaternion.html](https://docs.unity3d.com/ScriptReference/Quaternion.html).
    However, if you'd like an explanation of the underlying math, check out the great
    videos by *3Blue1Brown* such as *Quaternions and 3D rotation, explained interactively*
    at [https://www.youtube.com/watch?v=zjMuIxRvygQ](https://www.youtube.com/watch?v=zjMuIxRvygQ).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数是一种可以用于表示计算机图形中旋转的数学结构。作为Unity开发者，你只需要知道Transform中的旋转使用`Quaternion`类。参见[https://docs.unity3d.com/ScriptReference/Quaternion.html](https://docs.unity3d.com/ScriptReference/Quaternion.html)。然而，如果你想要了解底层数学的解释，可以查看*3Blue1Brown*的精彩视频，例如在[https://www.youtube.com/watch?v=zjMuIxRvygQ](https://www.youtube.com/watch?v=zjMuIxRvygQ)上互动解释的*四元数和3D旋转*。
- en: Another thing we need is the ability to tell the FramedPhoto which image to
    display. We'll add a public variable for the `imageInfo` that will be set by the
    Image Select menu (developed in the next section of this chapter).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要的是能够告诉FramedPhoto显示哪张图片的能力。我们将为`imageInfo`添加一个公共变量，它将由Image Select菜单（在本章下一节开发）设置。
- en: Also, we will add a `defaultScale` property that scales the picture when it's
    instantiated. If you recall, we defined our prefab as normalized to 1 unit max
    size, which would make it 1 meter wide on the wall unless we scale it. We're only
    scaling the X and Y axes, leaving the Z at `1.0` so that the frame's depth is
    not scaled too. I'll set the default scale to `0.5`, but you can change it later
    in the Inspector.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将添加一个`defaultScale`属性，在实例化图片时对其进行缩放。如果你还记得，我们定义的预制件是按1单位最大尺寸归一化的，这会使它在墙上宽1米，除非我们对其进行缩放。我们只缩放X和Y轴，将Z轴保留为`1.0`，这样框架的深度就不会被缩放太多。我将默认缩放设置为`0.5`，但你可以稍后在检查器中更改它。
- en: 'Modify the `AddPictureMode` script as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式修改`AddPictureMode`脚本：
- en: 'Add the following declarations at the top of the class:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加以下声明：
- en: '[PRE5]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Replace the `PlaceObject` function with the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlaceObject`函数替换为以下内容：
- en: '[PRE6]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the script and return to Unity.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity。
- en: Note that I had to negate the wall plane normal vector (`-hit.pose.up`), because
    when we created our prefab, by convention, the picture is facing in the minus-Z
    direction.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我必须取反墙面的法向量（`-hit.pose.up`），因为在创建我们的预制件时，按照惯例，图片是朝向负Z方向的。
- en: When you place a picture, it should now hang properly upright and be flush against
    the wall, as shown in right-hand panel of the screenshot at the top of this section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你放置一张图片时，它现在应该垂直悬挂并紧贴墙面，如本节顶部截图的右侧面板所示。
- en: Showing tracked planes in AddPicture mode
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在添加图片模式下显示追踪平面
- en: 'Another enhancement might be to hide the tracked planes while in Main mode
    and show them while in `AddPicture` mode. This would allow the user to enjoy their
    image gallery without that distraction. Take a look at how we did that in the
    *Hiding tracked object when not needed* topic of [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*,
    Using the AR User Framework*. At that time, we wrote a script, `ShowTrackablesOnEnable`,
    that we can use now too. Follow these steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的增强是，在主模式下隐藏追踪的平面，在`添加图片`模式下显示它们。这将使用户能够在没有这种干扰的情况下享受他们的图片库。查看我们在[*第5章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)的*在不需要时隐藏追踪对象*主题中是如何做到的，使用*AR用户框架*。当时，我们编写了一个脚本`ShowTrackablesOnEnable`，现在我们也可以使用它。按照以下步骤操作：
- en: With the **AddPicture Mode** game object selected in the **Hierarchy** (under
    **Interaction Controller**).
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中（在**交互控制器**下）选择**添加图片模式**游戏对象。
- en: In the `ShowTrackablesOnEnable` script and drag it onto the **AddPicture Mode**
    object.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ShowTrackablesOnEnable`脚本中，并将其拖动到**添加图片模式**对象上。
- en: From the **Hierarchy**, drag the **AR Session Origin** object into the **Inspector**
    and drop it onto the **Show Trackables On Enable | Session Origin** slot.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中，将**AR会话原点**对象拖动到**检查器**中，并将其放置在**启用时显示可追踪对象 | 会话原点**槽位上。
- en: That is all we need to implement this feature.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现这个功能所需的所有内容。
- en: To recap, we configured the scene to detect and track vertical planes, for the
    walls of your room. Then we created an `AddPictureMode` script. The script instantiates
    a copy of the **FramedPhoto** prefab when the user taps on a vertical plane. Then
    we improved the script by ensuring the picture is oriented flat on the wall and
    upright. The script also lets us change the image in the frame and its scale.
    Lastly, we display the trackable planes when in AddPicture mode and hide them
    when we return to Main mode.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们配置了场景以检测和跟踪垂直平面，用于你的房间墙壁。然后我们创建了一个 `AddPictureMode` 脚本。当用户在垂直平面上轻触时，该脚本实例化一个
    **FramedPhoto** 预制件的副本。然后我们通过确保图片在墙上平放且直立来改进脚本。该脚本还允许我们更改框架中的图像及其缩放。最后，我们在 **AddPicture**
    模式下显示可跟踪的平面，并在返回到主模式时隐藏它们。
- en: The next step is to give the user a choice to select an image before hanging
    a new picture on the wall. We can now go ahead and create an image select menu
    for the user to pick one to use.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为用户提供在墙上挂新画之前选择图像的选择。我们现在可以继续创建一个图像选择菜单，供用户选择使用。
- en: Selecting an image to use
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择要使用的图像
- en: The next thing we want to do is create an image select menu containing image
    buttons for the user to choose a photo before adding it to the scene. When the
    `ImageButtons` script that builds the menu using the **Images** list you've already
    added to the project (the **Image Data** game object). And then we'll insert the
    **SelectImage** mode before **AddPicture** mode, so the selected image is the
    one placed on the wall. Let's define the **SelectImage** mode first.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是创建一个包含图像按钮的图像选择菜单，用户可以在将其添加到场景之前选择一张照片。当使用你已添加到项目中的 **Images** 列表（**图像数据**
    游戏对象）构建菜单的 `ImageButtons` 脚本时。然后我们将 **SelectImage** 模式插入到 **AddPicture** 模式之前，这样选中的图像就是放置在墙上的图像。让我们首先定义
    **SelectImage** 模式。
- en: Creating the SelectImage mode
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SelectImage 模式
- en: When `SelectImage` mode is enabled by the user, all we need to do is display
    the SelectImage UI menu panel with buttons for the user to pick which image to
    use. Clicking a button will notify the mode script by calling the public function,
    `SetSelectedImage`, that in turn tells the `AddPictureMode` which image to use.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启用 `SelectImage` 模式时，我们只需要显示 SelectImage UI 菜单面板，其中包含供用户选择的按钮。点击按钮将通过调用公共函数
    `SetSelectedImage` 通知模式脚本，该函数反过来告诉 `AddPictureMode` 使用哪张图像。
- en: 'Create a new C# script named `SelectImageMode` and write it as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `SelectImageMode` 的新 C# 脚本，并按照以下内容编写：
- en: '[PRE7]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Simple. When `SelectImageMode` is enabled, we display the **SelectImage UI**
    panel (containing the buttons menu).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。当 `SelectImageMode` 被启用时，我们显示 **SelectImage UI** 面板（包含按钮菜单）。
- en: 'Now we can add it to the **Interaction Controller** as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式将其添加到 **Interaction Controller**：
- en: In the `SelectImage Mode`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SelectImage 模式` 中。
- en: Drag the `SelectImageMode` script from the **Project** window onto the **SelectImage
    Mode** object adding it as a component.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SelectImageMode` 脚本从 **Project** 窗口拖到 **SelectImage Mode** 对象上，将其添加为组件。
- en: Now we'll add the mode to the **Interaction Controller**. In the **Hierarchy**,
    select the **Interaction Controller** object.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将此模式添加到 **Interaction Controller**。在 **Hierarchy** 中选择 **Interaction Controller**
    对象。
- en: In the **Inspector**, at the bottom-right of the **Interaction Controller**
    component, click the **+** button to add an item to the **Interaction Modes**
    dictionary.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中，在 **Interaction Controller** 组件的右下角，点击 **+** 按钮向 **Interaction
    Modes** 字典添加一个项。
- en: Enter `SelectImage` in the **Id** field.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Id** 字段中输入 `SelectImage`。
- en: 'Drag the **SelectImage Mode** game object from the **Hierarchy** onto the **Value**
    slot. The **Interaction Controller** component now looks like the following:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **SelectImage Mode** 游戏对象从 **Hierarchy** 拖到 **Value** 槽。现在 **Interaction Controller**
    组件看起来如下所示：
- en: '![Figure 6.12 – Interaction Controller with SelectImage Mode added'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – 添加了 SelectImage 模式的交互控制器'
- en: '](img/Figure_6.12_(new).jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_(new).jpg)'
- en: Figure 6.12 – Interaction Controller with SelectImage Mode added
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 添加了 SelectImage 模式的交互控制器
- en: Next, we'll add the UI for this mode.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加此模式的 UI。
- en: Creating the Select Image UI panel
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Select Image UI 面板
- en: 'To create the **SelectImage UI** panel, we''ll duplicate the existing **Main
    UI** and adapt it. The panel will include a Header title and **Cancel** button.
    Follow these steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 **SelectImage UI** 面板，我们将复制现有的 **Main UI** 并进行适配。该面板将包括一个标题和 **取消** 按钮。按照以下步骤操作：
- en: In the `SelectImage UI`. Delete any child objects, including **Add Button**,
    using *right-click* **Delete**.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SelectImage UI` 中。使用 *右键点击* **删除** 删除任何子对象，包括 **添加按钮**。
- en: Make the panel size a little smaller than fullscreen so it looks like a modal
    popup. In its `50`. Set the `150` to leave room for the app title.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面板大小设置为略小于全屏，使其看起来像模态弹出窗口。在`50`处设置，将`150`留出空间用于应用标题。
- en: We want this panel to have a solid background so on its **Image** component,
    select **Component | UI | Image** from the main menu.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个面板有一个实心背景，因此在其**图像**组件中，从主菜单中选择**组件 | UI | 图像**。
- en: Create a menu header sub-panel. In the `Header`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个菜单标题子面板。在`Header`。
- en: Position and stretch the `100`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并拉伸`100`。
- en: '*Right-click* the `Header Text`.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**标题文本**。
- en: On the `Select Image`, `48`, **Alignment** to **Center** and **Middle**, and
    **Anchor Presets** to **Stretch-Stretch**. Also, *Alt + Shift +* click **Stretch-Stretch**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Select Image`，`48`，**对齐**设置为**居中**和**中间**，**锚点预设**设置为**拉伸-拉伸**。同时，*Alt + Shift
    +* 点击**拉伸-拉伸**。
- en: We'll also add a `Cancel Button`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将添加一个**取消按钮**。
- en: Set the Cancel button's `80` and `-20`. Also set its **Image | Color** to a
    light gray color.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置取消按钮的`80`和`-20`。还将其**图像 | 颜色**设置为浅灰色。
- en: For the `X` and `48`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`X`和`48`。
- en: With the **Cancel Button** selected in **Hierarchy**, in its **Inspector** click
    the **+** button on the bottom-right of the **Button | OnClick** actions.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**取消按钮**，在其**检查器**中点击**按钮 | OnClick**动作右下角的**+**按钮。
- en: Drag the **Interaction Controller** game object from the **Hierarchy** onto
    the **OnClick** **Object** slot.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**交互控制器**游戏对象从**层次结构**拖放到**OnClick** **对象**槽中。
- en: From the `Main` in the text parameter field. The **X** cancel button will now
    send you back to Main mode.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文本参数字段中的`Main`。现在，X取消按钮将带您返回主模式。
- en: 'The header of the **SelectImage** UI panel is shown in the following screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**SelectImage** UI面板的标题如下截图所示：'
- en: '![Figure 6.13 – The header panel of the SelectImage UI'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.13 – SelectImage UI的标题面板]'
- en: '](img/Figure_6.13-SelectImageHeader.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.13-SelectImageHeader.jpg]'
- en: Figure 6.13 – The header panel of the SelectImage UI
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – SelectImage UI的标题面板
- en: 'Next, we''ll add a panel to contain the image buttons that will display photos
    for the user to pick. These will be laid out in a grid. Use the following steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个面板来包含将显示供用户选择的图片的图像按钮。这些按钮将按网格排列。使用以下步骤：
- en: In the `Image Buttons`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Image Buttons`。
- en: On the **Image Buttons** panel, uncheck its **Image** component or remove it.
    We don't need a separate background.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图像按钮**面板上，取消选中其**图像**组件或删除它。我们不需要单独的背景。
- en: Its `100`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其`100`。
- en: Select `layout` and add a **Grid Layout Group** component.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`layout`并添加一个**网格布局组**组件。
- en: On the `20, 20, 20, 20`, set `200, 200`, and set `20, 20`. Set **Child Alignment**
    to **Upper Center**.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`20, 20, 20, 20`处设置`200, 200`，并将`20, 20`设置为`20, 20`。将**子对齐**设置为**上居中**。
- en: 'We now have an **ImageSelect UI** panel with a header and a container for the
    image buttons. Parts of the current hierarchy are shown in the following screenshot:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个带有标题和图像按钮容器的**ImageSelect UI**面板。当前层次结构的一部分如下截图所示：
- en: '![Figure 6.14 –UI Canvas with SelectImage UI, and Interaction Controller with
    SelectImage Mode'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.14 – 带有SelectImage UI的UI画布和具有SelectImage模式的交互控制器]'
- en: '](img/Figure_6.14-uicanvas-selectimage-hier.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_6.14-uicanvas-selectimage-hier.jpg]'
- en: Figure 6.14 –UI Canvas with SelectImage UI, and Interaction Controller with
    SelectImage Mode
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 带有SelectImage UI的UI画布和具有SelectImage模式的交互控制器
- en: 'Lastly, we need to add the panel to the UI Controller as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要按照以下步骤将面板添加到UI控制器中：
- en: To add the panel to the UI Controller, in the **Hierarchy**, select the **UI
    Canvas** object.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将面板添加到UI控制器中，在**层次结构**中选择**UI Canvas**对象。
- en: In the **Inspector**, at the bottom-right of the **UI Controller** component,
    click the **+** button to add an item to the **UI Panels** dictionary.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，在**UI控制器**组件的右下角，点击**+**按钮向**UI面板**字典中添加一个项目。
- en: Enter `SelectImage` in the **Id** field.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**字段中输入`SelectImage`。
- en: Drag the **SelectImage UI** game object from the **Hierarchy** onto the **Value**
    slot.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SelectImage UI**游戏对象从**层次结构**拖放到**值**槽中。
- en: We now have a UI panel with a container for the image buttons. To make the buttons,
    we'll create a prefab and then write a script to populate the **Image Buttons**
    panel.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含图像按钮容器的UI面板。为了制作按钮，我们将创建一个预制件，然后编写一个脚本以填充**图像按钮**面板。
- en: Creating an Image Button prefab
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图像按钮预制件
- en: 'We will define an **Image Button** as a prefab so it can be duplicated for
    each image that we want to provide to the user in the selection menu. Create the
    button as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个**图像按钮**为预制件，以便它可以复制，为用户在选择菜单中提供的每个图像。创建按钮如下：
- en: In the `Image Button`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Image Button`中。
- en: Under the **Image Button**, delete its child **Text** element.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图像按钮**下，删除其子**文本**元素。
- en: On the **Image Button**, remove its **Image** component (using *right-click*
    and **Remove Component**) and then press **Add Component**. Search and add a **Raw
    Image** component instead.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**图像按钮**上，移除其**图像**组件（使用*右键单击*和**移除组件**），然后按**添加组件**。搜索并添加一个**原始图像**组件。
- en: Its **Button** component needs a reference to its graphic that we just replaced.
    In the **Inspector**, drag the **Raw Image** component onto **Button | Target
    Graphic** slot.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其**按钮**组件需要对其刚刚替换的图形的引用。在**检查器**中，将**原始图像**组件拖到**按钮 | 目标图形**槽中。
- en: Now drag your default image texture, such as the `WinterBarn` asset, from the
    `Photos/` folder into the **Inspector** and drop it onto the **Raw Image | Texture**
    slot.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将默认图像纹理，例如`WinterBarn`资产，从`Photos/`文件夹拖到**检查器**，并将其放置在**原始图像 | 纹理**槽中。
- en: UI Image versus Raw Image
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UI图像与原始图像
- en: An **Image** component takes an image sprite for its graphic. A **Raw Image**
    component takes a texture for its graphic. Sprites are small, highly efficient,
    preprocessed images used for UI and 2D applications. Textures tend to be larger
    with more pixel depth and fidelity used for 3D rendering and photographic images.
    You can change an imported image between these and other type using the image
    file's Inspector properties. To use the same photo asset (PNG files) for both
    the FramedPhoto prefab and the button, we're using a Raw Image component on the
    buttons.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**图像**组件用于其图形的图像精灵。**原始图像**组件用于其图形的纹理。精灵是用于UI和2D应用的小型、高效、预处理的图像。纹理通常更大，具有更多的像素深度和保真度，用于3D渲染和摄影图像。您可以使用图像文件的检查器属性在导入的图像之间以及其他类型之间进行更改。为了同时使用相同的照片资产（PNG文件）作为FramedPhoto预制件和按钮，我们在按钮上使用了一个原始图像组件。'
- en: Let's save the `Prefabs/` folder. This creates a prefab asset and changes its
    color in the **Hierarchy** to blue, indicating it's a prefab instance.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们保存`Prefabs/`文件夹。这会创建一个预制资产，并将其在**层次结构**中的颜色改为蓝色，表示它是一个预制实例。
- en: 'In the **Hierarchy** window, *right-click* the **Image Button** object, select
    **Duplicate** (or press *Ctrl/Option + D* on the keyboard), and make several copies.
    Because the buttons are parented by the **Image Buttons** panel that has a **Grid
    Layout Group**, they are rendered in a grid, as shown in the following screenshot:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，*右键单击***图像按钮**对象，选择**复制**（或按*Ctrl/Option + D*键），并制作几个副本。因为按钮由具有**网格布局组**的**Image
    Buttons**面板作为父级，所以它们以网格形式渲染，如下面的截图所示：
- en: '![](img/Figure_6.15-SelectImageGrid.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_6.15-SelectImageGrid.jpg)'
- en: Figure 6.15 – Select image panel with Image Buttons in a grid layout
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 带有网格布局的图像按钮的图像选择面板
- en: Next, we'll write a script to populate the buttons with actual images we want
    to use.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个脚本，用我们想要使用的实际图像填充按钮。
- en: Writing an ImageButtons script
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写ImageButtons脚本
- en: 'The `ImageButtons` script will be a component on the `ImageButtons`, open it
    for editing, and write it as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageButtons`脚本将是`ImageButtons`上的一个组件，打开它进行编辑，并按照以下方式编写：'
- en: '[PRE8]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's go through this script. At the top of the class, we declare three variables.
    `imageButtonPrefab` will be a reference to the `imagesData` is a reference to
    the object containing our list of images. And `addPicture` is a reference to `AddPictureMode`
    for each button to tell which image has been selected.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历这个脚本。在类的顶部，我们声明了三个变量。`imageButtonPrefab`将是一个对`imagesData`对象的引用，该对象包含我们的图像列表。`addPicture`是对每个按钮的`AddPictureMode`的引用，以告诉哪个图像已被选中。
- en: The first thing `Start()` does is clear out any child objects in the buttons
    panel. For example, we created a number of duplicates of the button to help us
    develop and visualize the panel, and they'll still be in the scene when it runs
    unless we remove them first.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`首先做的事情是清除按钮面板中的任何子对象。例如，我们创建了许多按钮的副本以帮助我们开发和可视化面板，当它运行时，除非我们首先删除它们，否则它们仍然会出现在场景中。'
- en: Then, `Start` loops through each of the images, and for each one, creates an
    `onClick` events.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Start`遍历每个图像，并为每个图像创建一个`onClick`事件。
- en: When one of the buttons is clicked, our `OnClick` function will be called, with
    that button's `image` as a parameter. We pass this `image` data to the `AddPictureMode`
    that will be used when **AddPictureMode** instantiates a new **FramedPhoto** object.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当其中一个按钮被点击时，我们的`OnClick`函数将被调用，并将该按钮的`image`作为参数传递。我们将此`image`数据传递给`AddPictureMode`，该模式将在**AddPictureMode**实例化新的**FramedPhoto**对象时使用。
- en: 'Add the script to the scene as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式将脚本添加到场景中：
- en: In the **Hierarchy**, select the **Image Buttons** object (under **UI Canvas/Select
    Image Panel**).
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**图像按钮**对象（位于**UI Canvas/选择图片面板**）。
- en: Drag the **ImageButtons** script onto the **Image Buttons** object, making it
    a component.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ImageButtons**脚本拖动到**Image Buttons**对象上，使其成为一个组件。
- en: From the **Project** window, drag the **Image Button** prefab into the **Inspector**
    and drop it onto the **Image Buttons | Image Button Prefab** slot.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口中，将**Image Button**预制拖动到**检查器**中，并将其放置在**Image Buttons | Image Button
    Prefab**槽位上。
- en: From the **Hierarchy**, drag the **AddPicture Mode** object into the **Inspector**
    and drop it onto the **Image Buttons | Add Picture** slot.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**中，将**AddPicture Mode**对象拖动到**检查器**中，并将其放置在**Image Buttons | Add Picture**槽位上。
- en: Also from the **Hierarchy**, drag the **Images Data** object and drop it onto
    the **Image Buttons | Images Data** slot.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样从**层次结构**中，将**Images Data**对象拖动到**Image Buttons | Images Data**槽位上。
- en: 'The **Image Buttons** component now looks like the following screenshot:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**Image Buttons**组件现在看起来如下截图所示：'
- en: '![Figure 6.16 – Image buttons panel with the ImageButtons script that builds
    the menu at runtime'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.16 – Image buttons panel with the ImageButtons script that builds
    the menu at runtime]'
- en: '](img/Figure_6.16-imagebuttons-insp.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.16-imagebuttons-insp.jpg]'
- en: Figure 6.16 – Image buttons panel with the ImageButtons script that builds the
    menu at runtime
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 带有在运行时构建菜单的ImageButtons脚本的图像按钮面板
- en: OK. When the app starts up, the `AddPictureMode` which image was selected, and
    then enabled AddPicture mode.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。当应用启动时，`AddPictureMode`选择了哪张图片，然后启用了添加图片模式。
- en: Reroute the Add button
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向添加按钮
- en: 'There is just one last step before we can try it out. Currently, the main menu''s
    Add button enables AddPicture mode directly. We need to change it to call **SelectImage**
    instead, as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试之前，还有最后一步。目前，主菜单的添加按钮直接启用AddPicture模式。我们需要将其更改为调用**SelectImage**，如下所示：
- en: In the **Hierarchy**, select the **Add** button (located in **UI Canvas** /
    **Main UI**).
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**添加**按钮（位于**UI Canvas** / **主 UI**）。
- en: In the **Inspector**, in the **Button | On Click** action list, change the **EnableMode**
    parameter from **AddPicture** to **SelectImage**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，在**按钮 | 点击**动作列表中，将**EnableMode**参数从**AddPicture**更改为**SelectImage**。
- en: Save the scene.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'If you got all this right, you should be able to **Build and Run** the scene
    and run through the complete scenario: pressing the **Add** button will present
    a **Select Image** menu. Tapping an image, the select panel is replaced with a
    prompt to tap to place the image, with its frame, on a wall. The following screenshots
    from my phone show, on the left, the **Select Image** menu. After selecting an
    image and placing it on the wall, the result is shown on the right. Then the app
    returns to the main menu:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把这些都做对了，你应该能够**构建并运行**场景，并运行完整的场景：按下**添加**按钮将显示一个**选择图片**菜单。点击一个图片，选择面板将被替换为提示点击以将图片及其框架放置在墙上的提示。以下是我手机上的截图显示了左边的**选择图片**菜单。选择图片并放置在墙上后，结果在右边显示。然后应用返回主菜单：
- en: '![Figure 6.17 – Pressing the Add button, I see an image menu (left), and the
    result after placing (right)'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.17 – Pressing the Add button, I see an image menu (left), and the
    result after placing (right)]'
- en: '](img/Figure_6.17-PlaceImageRun.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.17-PlaceImageRun.jpg]'
- en: Figure 6.17 – Pressing the Add button, I see an image menu (left), and the result
    after placing (right)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 按下添加按钮，我看到一个图像菜单（左），放置后的结果（右）
- en: To summarize, in this section we added the `ImageButtons` script that instantiates
    buttons for each image we want to include in the app. Clicking one of the buttons
    will pass the selected image data to **AddPicture** mode. When the user taps to
    place and a **FramedPhoto** is instantiated, we set the image to the one the user
    has selected. We also included a **Cancel** button in the menu so the user can
    cancel the add operation.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在本节中，我们添加了`ImageButtons`脚本，为应用中要包含的每个图片实例化按钮。点击其中一个按钮会将所选图片数据传递给**AddPicture**模式。当用户点击放置并实例化**FramedPhoto**时，我们将图片设置为用户所选的图片。我们还菜单中包含了一个**取消**按钮，以便用户可以取消添加操作。
- en: This is looking good so far. One problem we have is all the pictures are rendered
    in the same sized landscape frame and thus may look distorted. Let's fix that.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 目前看起来还不错。我们有一个问题是所有图片都在相同大小的横幅框架中渲染，因此可能看起来扭曲。让我们修复这个问题。
- en: Adjusting for image aspect ratio
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图像宽高比
- en: Currently, we're ignoring the actual size of the images and making them all
    fit into a landscape orientation with a 3:4 aspect ratio. Fortunately, we've included
    the actual (original) pixel dimensions of the image with our `ImageInfo`. We can
    use that now to scale the picture accordingly. We can make this change to the
    `FramedPhoto` script that's on the **FramedPhoto** prefab.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在忽略图像的实际大小，并将所有图像都调整到3:4的宽高比，使其适应横幅方向。幸运的是，我们在`ImageInfo`中包含了图像的实际（原始）像素尺寸。我们现在可以使用它来相应地缩放图片。我们可以将这个更改应用到位于**FramedPhoto**预制件上的`FramedPhoto`脚本中。
- en: 'The algorithm for calculating the aspect ratio can be separated as a utility
    function in the `ImagesData` script. Open the `ImagesData` script and add the
    following code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 计算宽高比的算法可以作为一个实用函数在`ImagesData`脚本中分离。打开`ImagesData`脚本并添加以下代码：
- en: '[PRE9]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the `width` is larger than `height`, the image is landscape, so we'll keep
    the X scale at `1.0` and scale down Y. When the `height` is larger than the `width`,
    it is portrait, so we'll keep the Y scale at `1.0` and scale down X. If they're
    the same or zero, we return `(1,1)`. The function is declared `static` so it can
    be called using the `ImagesData` class name.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当`width`大于`height`时，图片是横幅，我们将保持X缩放为`1.0`并缩小Y。当`height`大于`width`时，它是肖像，我们将保持Y缩放为`1.0`并缩小X。如果它们相同或为零，我们返回`(1,1)`。该函数被声明为`static`，因此可以使用`ImagesData`类名来调用它。
- en: 'Open the `FramedPhoto` script for editing and make the changes highlighted
    in the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`FramedPhoto`脚本进行编辑，并对以下内容进行修改：
- en: '[PRE10]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you recall, the `SetImage` function is called by `AddPictureMode` immediately
    after a `ImageData.AspectRatio` to get the new local scale and updates the `scalerObject`
    transform.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`SetImage`函数在`ImageData.AspectRatio`之后立即由`AddPictureMode`调用，以获取新的局部缩放并更新`scalerObject`变换。
- en: You may notice that the frame width is slightly different on the horizontal
    versus vertical sides when the picture is not square. Fixing this requires an
    additional adjustment to the `1.0 – 0.01/aspectratio`. I'll leave that implementation
    up to you.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当图片不是正方形时，你可能注意到框架的宽度在水平方向和垂直方向上略有不同。解决这个问题需要额外调整`1.0 – 0.01/aspectratio`。我将把这个实现的细节留给你。
- en: When you run the project again and place a picture on your wall, it'll be the
    correct aspect ratio according to the photo you picked. One improvement you could
    add is to scale the images on the **Select Image Panel** buttons so they too are
    not squished. I'll leave that exercise up to you.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行项目并在墙上放置图片时，它将根据你选择的图片具有正确的宽高比。你可以添加的一个改进是调整**选择图片面板**按钮上的图像大小，使它们也不会被压缩。我将这个练习留给你。
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the beginning of this chapter, I gave you the requirements and a plan for
    this AR gallery project, including a statement of the project objectives, use
    cases, UX design, and user stories. You started the implementation using the **ARFramework**
    template created in [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*,
    Creating an AR User Framework*, and built upon it to implement new features for
    placing a framed photo on your walls.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我给你提供了这个增强现实画廊项目的需求和计划，包括项目目标、用例、用户体验设计和用户故事。你开始使用在[*第4章*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*，创建AR用户框架*中创建的**ARFramework**模板进行实现，并在此基础上实现将带框照片放置在墙上等新功能。
- en: To implement this feature, you created a `ImageButton` prefab you created. Clicking
    an image, you're prompted to tap an AR tracked wall, and a new framed photo of
    that image is placed on the wall, correctly scaled to the image's aspect ratio.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，你创建了一个你创建的`ImageButton`预制件。点击图片后，你会被提示在AR追踪的墙上轻触，然后在该墙上放置一个新的带框照片，并正确缩放以适应图像的宽高比。
- en: We now have a fine start to an interesting project. There is a lot more that
    can be done. For example, presently pictures can be placed on top of one another,
    which would be a mistake. Also, it would be good to be able to move, resize, and
    remove pictures. We'll add that functionality in the next chapter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个有趣项目的良好开端。还有很多工作可以完成。例如，目前图片可以重叠放置，这将是错误的。此外，能够移动、调整大小和删除图片会更好。我们将在下一章中添加这个功能。
