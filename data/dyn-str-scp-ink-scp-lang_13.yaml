- en: '*Chapter 10*: Dialogue Systems with ink'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*: 使用ink的对话系统'
- en: In this chapter, we will explore three different approaches to create a `#`),
    can be used to mark different lines in ink as being associated with certain characters
    in a story. Then, we will discuss an alternative to tags, where the name of the
    speaker precedes their dialogue. Finally, we will conclude the first part by reviewing
    how tags can be used and how both approaches can be combined.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨三种不同的方法来创建与故事中特定角色关联的ink中的不同行（`#`），然后我们将讨论标签的替代方案，即说话者的名字位于其对话之前。最后，我们将通过回顾标签的使用方法和两种方法的结合来结束第一部分。
- en: In the second topic, we will look at how to recreate the **click-to-continue**
    dialogue pattern that is found in many video games using ink. We will explore
    various ways of saving time and effort by using tunnels to move to different knots
    and back again in an ink project for use when needed. Following this, we will
    examine several different ways in which to generate dialogue trees in ink where
    players can explore different paths through extended branches of conversation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个主题中，我们将探讨如何使用ink重现许多视频游戏中常见的**点击继续**对话模式。我们将通过使用隧道在不同节点之间移动并在ink项目中保存时间与精力来探索各种节省时间与精力的方法。在此之后，我们将检查ink中生成对话树的不同方法，玩家可以通过扩展的对话分支探索不同的路径。
- en: In the third and final topic, we will look at two common visual patterns in
    which to present dialogue options to players, that is, lists and radial menus,
    and how they affect both writing ink code and how information is displayed to
    a player in Unity. We will begin with the visual pattern of a list, where all
    options are shown to the player in a vertical pattern. Then, we will examine the
    **radial menu pattern**, where options are limited to a smaller number of options
    arranged in a specific, visual way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个也是最后一个主题中，我们将探讨两种常见的视觉模式，用于向玩家展示对话选项，即列表和环形菜单，以及它们如何影响ink代码的编写和Unity中向玩家显示信息的方式。我们将从列表的视觉模式开始，其中所有选项都按垂直模式向玩家展示。然后，我们将检查**环形菜单模式**，其中选项限制在更少的选项中，这些选项以特定的、视觉的方式排列。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing dialogue in ink using tags
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签在ink中编写对话
- en: Dialogue loops and story knots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话循环和故事节点
- en: User interface models for conversations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话的用户界面模型
- en: Note
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike previous chapters, where sections built toward a completed project, this
    chapter will examine different approaches toward more visually complex systems.
    Each approach covered by a section can be found online on GitHub as a completed
    project. Only selected files and code, as they relate to the approach of each
    section, will be shown in this chapter. The specific files of each example are
    also noted within each section.
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与前几章不同，前几章的章节是朝着完成的项目构建的，而本章将探讨更多视觉复杂系统的不同方法。每个章节中涵盖的方法都可以在GitHub上作为完成的项目找到。本章中仅展示与每个章节方法相关的选定文件和代码。每个示例的具体文件也已在每个章节中注明。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The completed code for the different sections of this chapter can be found on
    GitHub at [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不同部分的完成代码可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter10)。
- en: Writing dialogue in Ink using tags
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签在ink中编写对话
- en: 'When ink was first introduced in [*Chapter 1*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Text, Flow, Choices, and Weaves*, the importance of a single line was also discussed.
    Each line in ink can consist of code, text, or a combination of the two. Depending
    on the use of other concepts, such as glue or comments, what counts as a single
    line can often be composed of multiple blocks of text or include notes for the
    authors as part of a single line. However, in addition to these previously reviewed
    concepts is another concept that has not previously been discussed: **hashtags**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当ink首次在[*第1章*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014)中介绍时，*文本、流程、选择和编织*，也讨论了单行的重要性。ink中的每一行可以由代码、文本或两者的组合组成。根据其他概念的使用，如粘合剂或注释，单行可以由多个文本块组成，或者包括作为单行一部分的作者注释。然而，除了之前审查的概念之外，还有一个之前未讨论的概念：**标签**。
- en: 'In ink, a new, single *hashtag* is created when a hash (`#`) is used before
    any text. Starting from the hash (`#`) and until the end of that line, any text
    that appears between the two is considered part of the single *tag*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在墨水（ink）中，当在任意文本前使用哈希符号（`#`）时，会创建一个新的单个 *标签*。从哈希符号（`#`）开始，直到该行的末尾，出现在这两个符号之间的任何文本都被视为单个
    *标签* 的部分：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Hashtags in ink are specifically designed to work with other systems. They
    have no meaning within Inky itself and are shown in the middle of the output:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 墨水中的标签专门设计用来与其他系统协同工作。在 Inky 本身中它们没有意义，并且在输出中间显示：
- en: '![Figure 10.1 – A hashtag used within Inky'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – Inky 中使用的哈希标签'
- en: '](img/Figure_10.1_B17597.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B17597.jpg)'
- en: Figure 10.1 – A hashtag used within Inky
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Inky 中使用的哈希标签
- en: When working with another system such as Unity, hashtags can be used to add
    extra data to a single line in ink. The current tags for the loaded chunk of the
    ink story exist within a property provided by the Story API, called `currentTags`,
    which contains a `List<string>` of all tags detected within the last load of story
    content. As with other text-related content, the `currentTags` property is also
    affected by any usages of the `Continue()` or `ContinueMaximally()` methods.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他系统（如 Unity）一起工作时，标签可以用来在墨水单行中添加额外数据。加载的墨水故事块当前标签存在于 Story API 提供的属性中，称为
    `currentTags`，它包含一个 `List<string>`，其中包含在最后一次加载故事内容中检测到的所有标签。与其他文本相关内容一样，`currentTags`
    属性也会受到 `Continue()` 或 `ContinueMaximally()` 方法的任何使用的影响。
- en: We will begin by learning how to use hashtags in ink. We will retrieve their
    values using the `currentTags` property in Unity to build a simple dialogue system
    where each spoken line has a name associated with who is communicating it. Next,
    we will examine a different approach to the same dialogue system using speech
    tags in front of the text of each ink line. The last section of this topic will
    compare the two approaches and review when one might be better than the other
    or whether a combination of the two might be needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何在墨水中使用标签。我们将使用 Unity 中的 `currentTags` 属性来检索它们的值，以构建一个简单的对话系统，其中每条说话的行都与一个与之通信的人的名字相关联。接下来，我们将检查使用文本前的语音标签来处理相同对话系统的不同方法。本主题的最后一部分将比较这两种方法，并回顾何时一个方法可能比另一个方法更好，或者是否需要两种方法的组合。
- en: Tagging ink text
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记墨水文本
- en: In ink, hashtags are used on a per-line basis. They exist for that line but
    remain part of the current hashtags until the next part of the story is loaded
    using the `Continue()` or `ContinueMaximally()` methods. In this section, we will
    review an example that uses hashtags with dialogue and the name of the speaker
    as part of a single line in ink. We will learn how the `currentTags` property
    is affected using the `Continue()` and `ContinueMaximally()` methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在墨水中，标签是按行使用的。它们仅存在于该行，但在使用 `Continue()` 或 `ContinueMaximally()` 方法加载故事的下一部分之前，仍然是当前标签的一部分。在本节中，我们将回顾一个使用标签和说话者名字作为墨水单行一部分的示例。我们将学习如何使用
    `Continue()` 和 `ContinueMaximally()` 方法来影响 `currentTags` 属性。
- en: Reminder
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub; these are under the name of *Chapter10-TaggingInkText*. Only
    selected parts of the code will be shown as they relate to the concepts examined
    in this section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在 GitHub 上的 [*第 10 章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    找到；这些示例以 *Chapter10-TaggingInkText* 的名称命名。只会展示与本章探讨的概念相关的代码部分。
- en: 'Dialogue lines are meaningless unless attributed to a character within a piece
    of work. This helps establish who is communicating and enables you to build continuity
    within the story. In the `Chapter10-TaggingInkText` example, each line of dialogue
    ends with the name of its speaker as a hashtag in ink. This helps attribute who
    is communicating each line:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对话行如果没有指明是某个角色所说的话，则没有意义。这有助于确定谁在进行交流，并使你能够在故事中建立连贯性。在 `Chapter10-TaggingInkText`
    示例中，每条对话的末尾都以其说话者的名字作为墨水中的标签结束。这有助于确定每条对话的说话者：
- en: 'Example 1 (InkDialogueTags.ink):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1（InkDialogueTags.ink）：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The ink code of *Example 1* contains the lines of dialogue and the name of
    the speaker for each line. Moving over to Unity, this translates into using the
    `currentTags` property to access the tags after at least one use of the `Continue()`
    or `ContinueMaximally()` methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1* 的墨水代码包含了每条对话的行和说话者的名字。在 Unity 中，这转化为使用 `currentTags` 属性在至少使用一次 `Continue()`
    或 `ContinueMaximally()` 方法后访问标签：'
- en: 'Example 2 (InkStoryScript.cs):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2（InkStoryScript.cs）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In *Example 2*, because the `currentTags` property is a `List<string>`, the
    first (`0`) position can be retrieved using the number of its index. The result
    is the separation of the tagged speaker and their lines in Unity despite them
    being written as one line in ink.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例 2*中，因为`currentTags`属性是一个`List<string>`，所以可以使用其索引的数量来检索第一个（`0`）位置。结果是，尽管在墨迹中它们被写为同一行，但在Unity中仍然可以分离标记的说话者和他们的台词。
- en: Hashtags are a powerful tool in which to add extra data to a single line in
    ink. As demonstrated in this section, they can be used to add the name of the
    character communicating the line at the end each time. However, there is another
    way to achieve the same outcome. In the next section, we will repeat the same
    general code but use *speech tags* in front of each line instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希标签是一种强大的工具，可以在墨迹中为单行添加额外数据。正如本节所示，它们可以用来在每次结束时添加传达该行的角色的名字。然而，还有另一种实现相同结果的方法。在下一节中，我们将重复相同的通用代码，但将在每行前面使用*语标*。
- en: Using speech tags
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用语标
- en: 'In creative writing, a **speech tag** appears before or after some dialogue
    and signals who is doing the communicating. For example, a common example found
    in many novels might use the word *said* in the following way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创意写作中，一个**语标**出现在某些对话之前或之后，并表明谁在进行交流。例如，在许多小说中常见的例子可能会用以下方式使用单词*说*：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The use of *Dan said* acts as a *tag* to the speech captured in the quotation
    marks. It signals who is doing the talking (*Dan*) and what is being said (*Hello*).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “Dan 说”作为引用中话语的*标签*。它表明谁在说话（*Dan*）以及说了什么（*Hello*）。
- en: 'Often, many people who write for games or other interactive projects follow
    a slightly different format where the name of the speaker appears before the speech.
    This style borrows from conventions found in screenwriting. The same words used
    in the previous example might appear as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，许多为游戏或其他交互式项目写作的人遵循一种略微不同的格式，其中说话者的名字出现在台词之前。这种风格借鉴了剧本中的惯例。在先前的示例中使用的相同词语可能如下所示：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the updated form, the use of quotation marks is dropped, and the name of
    the speaker precedes their words. There is also an introduction of a colon (`:`).
    This marks the end of the speaker and the beginning of their words. In screenwriting,
    both the name of the speaker and their dialogue will be centered. However, in
    an updated form that is more commonly used as part of game writing, this formatting
    is dropped, and the text appears as part of one line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新形式中，省略了引号的使用，说话者的名字出现在他们的话语之前。还有一个冒号（`:`）的引入。这标志着说话者的结束和话语的开始。在剧本中，说话者的名字和他们的对话都将居中。然而，在更常见地作为游戏写作一部分的更新形式中，这种格式被省略，文本作为一行的一部分出现。
- en: Reminder
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-UsingSpeechTags`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在GitHub上的[*第10章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)示例中找到，名称为`Chapter10-UsingSpeechTags`。将仅展示与本章探讨的概念相关的代码部分。
- en: 'The ink code in `Chapter10-UsingSpeechTags` follows a different pattern from
    the one found in the previous section. Instead of the name of the speaker included
    as a hashtag after the dialogue lines, it now precedes it. Often, this format
    is used for dialogue by writers working on video games and other interactive projects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter10-UsingSpeechTags`章节中的ink代码与上一节中找到的模式不同。它不再将说话者的名字作为哈希标签包含在对话行之后，而是现在在它之前。通常，这种格式被视频游戏和其他交互式项目的作家用于对话：
- en: 'Example 3 (InkSpeechTags.ink):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3（InkSpeechTags.ink）：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the *Example 3* code is run in Inky, because the code is no longer using
    hashtags, the first output and weave will be updated:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Inky中运行*示例 3*代码时，因为代码不再使用哈希标签，所以第一个输出和编织将被更新：
- en: '![Figure 10.2 – Speech tag usage in Inky'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – Inky 中的语标使用'
- en: '](img/Figure_10.2_B17597.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B17597.jpg)'
- en: Figure 10.2 – Speech tag usage in Inky
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Inky 中的语标使用
- en: Immediately, there is a visual difference between using ink hashtags and formatting
    the dialogue using speech tags. When testing the code in Inky, it is obvious who
    is communicating because their name will precede the text. However, while testing
    in Inky is easier, the removal of the hashtags within the ink code means the `currentTags`
    property cannot be used. Instead, more C# code must be added to parse the name
    from each line of text.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，使用墨迹井号和用语音标签格式化对话之间存在视觉差异。在Inky中测试代码时，很明显谁在交流，因为他们的名字将出现在文本之前。然而，尽管在Inky中测试更容易，但墨迹代码中井号的移除意味着无法使用`currentTags`属性。相反，必须添加更多的C#代码来从每行文本中解析名字。
- en: 'To detect, parse, and remove the use of the colon (`:`) within the ink output,
    multiple lines of C# code are needed:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测、解析和删除墨迹输出中的冒号（`:`）的使用，需要多行C#代码：
- en: 'Example 4 (InkStoryScript.cs):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 示例4（InkStoryScript.cs）：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Example 4* now detects whether a colon (`:`) exists in the output using the
    `Contains()` method. If it does, the string is split into two parts using the
    `Split()` method. The colon (`:`) is then trimmed from the first (`0`) string
    using the `Trim()` method and its value is then used for the speaker''s name.
    The second (`1`) string is used for the output of Ink.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例4*现在使用`Contains()`方法检测输出中是否存在冒号（`:`）。如果存在，则使用`Split()`方法将字符串分成两部分。然后使用`Trim()`方法从第一个（`0`）字符串中去除冒号（`:`），其值随后用于演讲者的名字。第二个（`1`）字符串用于墨迹的输出。'
- en: The result of this new code appears to be the same as the previous section.
    However, it uses speech tags to mark who is speaking and when. This makes it easier
    to test the ink code outside of Unity, as hashtags in ink have no meaning in Inky.
    However, this approach also comes with the issue that a colon (`:`) can *only*
    appear as part of the speech tag. If the text contains a colon, the C# code might
    become confused and attempt to split the text as though it contained a speech
    tag instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码的结果看起来与上一节相同。然而，它使用语音标签来标记谁在说话以及何时说话。这使得在Unity之外测试墨迹代码变得更加容易，因为在Inky中墨迹的井号没有意义。然而，这种方法也带来了一个问题，即冒号（`:`）只能作为语音标签的一部分出现。如果文本中包含冒号，C#代码可能会困惑并尝试将文本分割成似乎包含语音标签的样子。
- en: 'In the next section, we will compare each of the approaches outlined earlier:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将比较之前概述的每种方法：
- en: The *first* approach, using hashtags in ink, allows us to add extra data to
    a single line and then use the `currentTags` property to retrieve this in the
    C# code.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法，使用墨迹中的井号，允许我们在单行中添加额外数据，然后使用`currentTags`属性在C#代码中检索这些数据。
- en: The *second* approach, using speech tags directly in the text, makes the ink
    code easier to test but creates a need for more C# code to parse the resulting
    ink.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法，直接在文本中使用语音标签，使得墨迹代码更容易测试，但需要更多的C#代码来解析生成的墨迹。
- en: As we will mention in the next section, there might be contexts in which both
    approaches can be combined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中提到的，可能存在两种方法都可以结合使用的情况。
- en: Reviewing approaches to tagging dialogue
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查标记对话的方法
- en: In ink, hashtags add extra data per line. They can be used, as we learned in
    the *Tagging ink text* section, to add hashtags to each line of dialogue and then
    retrieve this data using the `currentTags` property in C# code as part of a Unity
    project. However, hashtags in ink come with two issues. The first is that they
    can only be used *per line*. The second is that only *one tag per line* can be
    used at a time. This makes hashtags very useful, for example, in the task of adding
    who is communicating to the line, but it also means they can only be used once
    per line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在墨迹中，每个井号都会为每行添加额外数据。正如我们在*标记墨迹文本*部分所学，它们可以用来给每行对话添加井号，然后使用C#代码中的`currentTags`属性作为Unity项目的一部分来检索这些数据。然而，墨迹中的井号有两个问题。第一个是它们只能*按行使用*。第二个是每次只能使用*一个标签*。这使得井号非常有用，例如，在添加谁在交流到行中的任务中，但也意味着它们只能每行使用一次。
- en: Dialogue can be directly marked using speech tags in the text. As we learned
    in the *Using speech tags* section, a colon can be used to mark who the speaker
    is and what they are communicating. This can be very useful for testing in Inky,
    as the speaker and their lines are closely connected and appear together. However,
    using speech tags in ink requires additional C# code to understand the output.
    Additionally, it means the colon can only be used as part of speech tags, as any
    other user might create confusion.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对话可以直接在文本中使用语音标签进行标记。正如我们在*使用语音标签*部分所学，冒号可以用来标记说话者是谁以及他们正在传达什么。这对于在Inky中进行测试非常有用，因为说话者和他们的台词紧密相连，并一起出现。然而，在墨水中使用语音标签需要额外的C#代码来理解输出。此外，这意味着冒号只能作为语音标签的一部分使用，因为任何其他用户都可能会造成混淆。
- en: Both approaches have benefits and potential obstacles when used separately.
    However, there are also contexts in which both approaches might be combined to
    present the name of the speaker using speech tags and to convey extra data using
    a tag in ink at the same time. For example, many games not only present text to
    a player but also use audio, video, or some type of animation closely linked to
    the text itself. In these cases, the text could contain a speech tag and the ink
    code could also use tags to signal that additional media should be played as part
    of the combined delivery of the dialogue to a player.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独使用时，这两种方法都有其优点和潜在障碍。然而，在某些情况下，这两种方法可以结合使用，以语音标签的形式呈现说话者姓名，并使用墨水中的标签同时传达额外数据。例如，许多游戏不仅向玩家展示文本，还使用音频、视频或与文本本身紧密相关的某种类型的动画。在这些情况下，文本可以包含语音标签，墨水代码也可以使用标签来指示应作为对话向玩家传达的合并交付的一部分播放的额外媒体。
- en: 'For games with spoken dialogue lines, it is very common to use a database or
    a spreadsheet of the text line and its corresponding audio based on a naming convention
    as part of the same row. Depending on the team, company, and other factors, the
    naming convention might use specific formatting or numbers, but a general example
    might include the type of audio, the character''s name, their state of mind or
    emotion, and any additional information for the context, level, or area of the
    game:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有语音对话行的游戏，使用数据库或电子表格来存储文本行及其对应的音频，并根据命名约定作为同一行的一部分是非常常见的。根据团队、公司和其他因素，命名约定可能使用特定的格式或数字，但一个一般示例可能包括音频类型、角色姓名、他们的心理状态或情绪以及与游戏上下文、级别或区域相关的任何其他信息：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because ink hashtags can add extra data, a single line within the ink code can
    use speech tags to mark who was communicating and then use the hashtag after the
    line with the media file to play. Such code will combine both approaches.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于墨水标签可以添加额外数据，墨水代码中的一行可以使用语音标签来标记谁在交流，然后在该行的媒体文件标签后使用标签来播放。此类代码将结合两种方法。
- en: Reminder
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-CombiningTags`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的工程可以在GitHub上的[*第10章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)示例中找到，名称为`Chapter10-CombiningTags`。由于与本章探讨的概念相关，只会展示代码的部分内容。
- en: 'The ink code in the `Chapter10-CombiningTags` example uses the combined approach.
    It includes both the name of the speaker preceding the dialogue lines and the
    use of a hashtag with the corresponding media file or reference to be used when
    the line is shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chapter10-CombiningTags`示例中的墨水代码使用的是结合方法。它包括对话行前的说话者姓名以及当行显示时使用的对应媒体文件或引用的标签：'
- en: 'Example 5 (InkCombiningTags.ink):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 5 (InkCombiningTags.ink):'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For simplicity, the project for this section only displays the text of the
    hashtag. By adding an extra `Text` game object and associating it with an existing
    property, the adjusted C# code will incorporate the changes to parsing speech
    tags along with the usage of the `currentTags` property:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，本节的工程只显示标签的文本。通过添加一个额外的`Text`游戏对象并将其与现有属性关联，调整后的C#代码将包含对解析语音标签的使用以及`currentTags`属性的用法：
- en: 'Example 6 (InkStoryScript.cs):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6 (InkStoryScript.cs):'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In *Example 6*, the new code tests for the number of entries in the `currentTags`
    property. If it contains at least one hashtag, the first (`0`) entry is used as
    text for a `Text` game object. When run, the project shows the speaker, their
    communication, and the name of the media file that will be played or used as part
    of the dialogue in a smaller font.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 6* 中，新的代码测试 `currentTags` 属性中的条目数量。如果它至少包含一个标签，则第一个（`0`）条目用作 `Text` 游戏对象的文本。运行项目时，项目将显示说话者、他们的交流以及将要播放或作为对话一部分使用的媒体文件的名称，字体较小。
- en: In the next topic, we will recreate some common patterns found in video game
    dialogue. We will learn how to create a click-to-continue pattern as well as more
    complex dialogue trees for players to explore. There will also be advice for those
    starting new projects on how to plan and then allow the code in ink to guide you
    to create an interface in Unity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将重新创建一些在视频游戏对话中常见的模式。我们将学习如何创建点击继续模式以及更复杂的对话树供玩家探索。同时，也会为那些开始新项目的人提供如何规划和允许
    ink 中的代码引导你创建 Unity 界面的建议。
- en: Dialogue loops and story knots
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话循环和故事节点
- en: Writing dialogue in ink often means being aware of how it will be used with
    other systems. In the previous section, we investigated two approaches to using
    tags when writing single lines of dialogue. In this topic, we will move away from
    a focus on individual lines and work with the larger structures within an ink
    project. By inspecting two common patterns in which to present choices to a player,
    we will learn how knots in ink can be reused within projects to save future time
    and effort. The last section in this topic also includes advice for starting a
    new project or converting it using ink.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ink 中编写对话通常意味着要意识到它将如何与其他系统一起使用。在前一节中，我们研究了在编写单行对话时使用标签的两种方法。在本主题中，我们将从关注单个行转向处理
    ink 项目中的更大结构。通过检查两种向玩家呈现选择时的常见模式，我们将学习 ink 中的节点如何在项目中重用以节省未来的时间和精力。本主题的最后一部分还包括有关开始新项目或使用
    ink 转换项目的建议。
- en: 'Because it appears most often, we will begin with a pattern that appears in
    the *Writing dialogue in ink using tags* section as part of the ink code examples
    using tags: click to continue.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它出现得最频繁，所以我们将从一个出现在 ink 代码示例中的*使用标签编写 ink 中的对话*部分的模式开始，该模式是作为点击继续的一部分：点击继续。
- en: Click to continue
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击继续
- en: Reminder
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found inside the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-ClickToContinue`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在 GitHub 上的[*第 10 章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)示例中找到，名称为
    `Chapter10-ClickToContinue`。将仅展示与本章探讨的概念相关的代码部分。
- en: There are many repeating patterns found in video game writing. One of the most
    common is the **click-to-continue** pattern. This is the presentation of information
    across a series of messages to a player, where they must press a button or click
    on the screen to progress through them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏写作中可以发现许多重复的模式。其中最常见的是**点击继续**模式。这是将信息通过一系列消息呈现给玩家，他们必须按下按钮或点击屏幕才能继续的过程。
- en: 'In ink, one way to create the click-to-continue pattern is with a single choice
    and then, usually, a gathering point to collapse the weave right after it. In
    its most simplistic form, it only contains these concepts and a single word to
    indicate an action, such as *Continue*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ink 中，创建点击继续模式的一种方法是通过一个单一的选择，然后通常是一个聚集点，在它之后立即折叠编织。在其最简单的形式中，它只包含这些概念和一个表示动作的单个单词，例如
    *继续*：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Breaking out the click-to-continue code into a knot allows a writer to reuse
    the same section multiple times by writing it once and then tunneling to it and
    back again when needed. In an extended example, the use of a specific knot for
    this purpose saves more lines of code the more times it appears:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将点击继续的代码拆分成一个节点允许作者通过一次编写并在需要时通过隧道进入和返回来多次重用相同的部分。在一个扩展的例子中，用于此目的的特定节点出现的次数越多，节省的代码行数就越多：
- en: 'Example 7 (InkClickToContinue.ink):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 7 (InkClickToContinue.ink):'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the code for *Example 7*, the `continue` ink knot is reused multiple times.
    Each usage tunnels to the knot and returns. This allows the code to decrease the
    number of overall lines.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 7* 的代码中，`continue` ink 节点被多次重用。每次使用都会进入节点并返回。这使得代码可以减少总行数。
- en: 'Based on the structure in ink, the amount of C# code can also be reduced. The
    pattern in the ink code can be reflected in a simplified technique in the C# code
    by providing a method and attaching to the overall panel holding two `Text` game
    objects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据墨水的结构，C#代码的数量也可以减少。墨水代码中的模式可以通过提供一个方法和将其附加到包含两个`Text`游戏对象的整个面板上来反映在C#代码中的简化技术：
- en: 'Example 8 (InkStoryScript.cs):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '示例8（InkStoryScript.cs）:'
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the new *Example 8* code, the `ProgressDialogue()` method is used by a `Panel`
    game object as part of an **EventTrigger** component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的**示例8**代码中，`ProgressDialogue()`方法被一个`Panel`游戏对象作为**事件触发（EventTrigger**）组件的一部分使用：
- en: '![Figure 10.3 – Event Trigger on the Panel game object'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 – 面板游戏对象的触发事件'
- en: '](img/Figure_10.3_B17597.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B17597.jpg)'
- en: Figure 10.3 – Event Trigger on the Panel game object
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 面板游戏对象的触发事件
- en: By associating the `ProgressDialogue()` method with the `Panel` game object,
    you can click on a visual representation of a dialogue. This then loads the next
    part of the click-to-continue pattern based on the ink code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`ProgressDialogue()`方法与`Panel`游戏对象关联，你可以点击对话的视觉表示。然后根据墨水代码加载点击继续模式的下一部分。
- en: 'While the click-to-continue pattern is the most common, there is another, more
    advanced pattern found in many role-playing games and narrative-heavy interactive
    projects: dialogue trees. In this pattern, multiple options are presented with
    each expanding out to separate branches of dialogue for players to explore. In
    the next section, we will learn how to create this pattern in ink and how new
    options can be easily added to branches.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然点击继续模式是最常见的，但在许多角色扮演游戏和叙事密集型交互项目中，还存在另一种更高级的模式：对话树。在这个模式中，会展示多个选项，每个选项都扩展成独立的对话分支供玩家探索。在下一节中，我们将学习如何在墨水中创建这种模式以及如何轻松地将新选项添加到分支中。
- en: Counting choices for trees
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话树的选择计数
- en: In ink, a weave is composed of one or more choices. Depending on the code following
    each choice, multiple levels can be created, and the flow of an ink story can
    branch off into different paths. When it comes to presenting options, there are
    often contexts where a user will progress through what is known as a **dialogue
    tree**. The use of the word *tree* is named after the shape created by the different
    parts, or branches, with all of them together as a single trunk.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在墨水（ink）中，一个编织（weave）由一个或多个选择（choices）组成。根据每个选择后的代码，可以创建多个层级，墨水故事的流程可以分支成不同的路径。当涉及到展示选项时，通常会有这样的上下文：用户会通过所谓的**对话树（dialogue
    tree**）来推进。使用“树”这个词是为了描述由不同部分或分支形成的形状，所有这些分支共同构成一个单一的树干。
- en: 'Often, in role-playing and narrative-heavy games, this pattern appears as part
    of a scene with information about an event or as part of a character explaining
    something to a player. In these scenarios, the normal use of weaves does not quite
    work as intended. Instead of needing to pick a single choice among a set, we need
    to progress *across* the collection instead. For this, a special built-in ink
    function is required: `CHOICE_COUNT()`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色扮演和叙事密集型游戏中，这种模式通常作为场景的一部分出现，其中包含有关事件的信息，或者作为角色向玩家解释某事的一部分。在这些场景中，正常使用编织并不完全符合预期。我们不需要在集合中选择一个单一的选择，而是需要**跨过**集合前进。为此，需要一个特殊的内置墨水函数：`CHOICE_COUNT()`。
- en: 'The ink runtime keeps track of the current number of options within the loaded
    chunk. This number can be accessed as part of the `CHOICE_COUNT()` ink function.
    When used as part of a conditional option in ink, this allows an author to limit
    the number of options presented to a reader by comparing the current count with
    the value returned by the `CHOICE_COUNT()` function. However, to keep track of
    values across loops, a variable is required:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 墨水运行时跟踪加载块中当前选项的数量。这个数字可以作为`CHOICE_COUNT()`墨水函数的一部分访问。当作为墨水中的条件选项的一部分使用时，这允许作者通过将当前计数与`CHOICE_COUNT()`函数返回的值进行比较来限制向读者展示的选项数量。然而，为了在循环之间跟踪值，需要一个变量：
- en: 'Example 9 (oneBranch.ink):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '示例9（oneBranch.ink）:'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The use of the `count` variable in *Example 9* records the current choice count
    at the start of the loop. Then, for each choice in turn, the value is compared
    with the increased number of uses of the choice before the comparison. The effect
    is the loading of each choice, in turn, from the set. At the beginning of the
    loop, the `This is the first` option will be provided. The use of a gathering
    point will automatically loop the code. This will continue until there are no
    choices left except the sticky choice of `Return`. This last choice will always
    remain and allow the player to either close the dialogue or *return* to a previous
    point.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 9* 中使用 `count` 变量记录循环开始时的当前选择计数。然后，对于每个选择依次，将值与比较之前选择使用增加的数量进行比较。结果是依次从集合中加载每个选择。在循环开始时，将提供“这是第一个”选项。使用集合点将自动循环代码。这将一直持续到除了“返回”的粘性选择之外没有其他选项。最后一个选择将始终保留，并允许玩家关闭对话或
    *返回* 到先前的位置。
- en: 'This model can be extended into multiple branches as well. For each tree, there
    needs to be a separate knot or stitch with tunnels used to move between to maintain
    the flow of the ink story. The use of multiple sections with their choice counts
    also means using another ink concept: temporary variables. The `temp` keyword
    can be used inside any knot or stitch to create a variable that does not exist
    outside of it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型也可以扩展为多个分支。对于每一棵树，都需要一个单独的结或缝合点，使用隧道在它们之间移动以保持墨水故事的流动。使用具有其选择计数的多个部分还意味着使用另一个墨水概念：临时变量。`temp`
    关键字可以在任何结或缝合点内部使用来创建一个在它之外不存在的变量：
- en: 'Example 10 (multipleBranches.ink):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 10 (multipleBranches.ink):'
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code for *Example 10*, each branch is broken out into its own
    stitches within a larger collected knot. Starting with the `loop` knot, threads
    are used to pull in the two stitches and create a unified appearance of options
    from two different parts of the code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *示例 10* 的前述代码中，每个分支都被拆分到更大的集合结内的单独缝合点中。从 `loop` 结开始，使用线将两个缝合点拉入并创建来自代码两个不同部分的选项的统一外观。
- en: Depending on the structure of the project, the `CHOICE_COUNT()` ink function
    can be used to limit one choice per set, in order, or a more traditional collection
    can be created. Each of these approaches provides different ways in which to create
    a dialogue tree for a player to explore. They can either exhaust each option one
    after another or use tunnels to pass the flow to the knot containing the tree
    structure and then back again.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的结构，可以使用 `CHOICE_COUNT()` 墨水函数来限制每个集合中按顺序的一个选择，或者创建一个更传统的集合。这些方法中的每一个都提供了为玩家创建对话树的不同方式。他们可以依次耗尽每个选项，或者使用隧道将流程传递到包含树结构的结，然后再返回。
- en: 'In this section, we examined two different structures for dialogue systems:
    click-to-continue and dialogue trees. In the last topic in this chapter, we will
    finally transition from ink structures into their visual representations in Unity.
    We will examine two models for presenting options to users: lists and radial menus.
    We will determine when each is best used and how the models affect both the structures
    in ink and the designs in Unity.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们考察了两种不同的对话系统结构：点击继续和对话树。在本章的最后一个主题中，我们将最终从墨水结构过渡到它们在 Unity 中的视觉表示。我们将考察两种向用户展示选项的模型：列表和径向菜单。我们将确定何时使用每个模型最佳，以及这些模型如何影响墨水中的结构和
    Unity 中的设计。
- en: User interface models for conversations
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话的用户界面模型
- en: 'There is a long history of presenting dialogue options to players in video
    games and other interactive projects. From the earliest text prompts to complicated
    layers of menus in more modern video games, each generation of video game systems
    has introduced different methods of presenting information. However, two general
    models appear in many games: lists and radial menus. They can be explained as
    follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子游戏和其他交互式项目中向玩家展示对话选项有着悠久的历史。从最早期的文本提示到更现代电子游戏中复杂的菜单层，每一代电子游戏系统都引入了不同的信息展示方法。然而，在许多游戏中出现了两种通用模型：列表和径向菜单。它们可以这样解释：
- en: Based on the original presentation of one choice after another in a vertical
    arrangement, the **list pattern** first appeared in early computer games and continues
    in visual designs where there is more space to show a variety of longer-text options
    to a player.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于一个接一个的垂直排列中的原始选择展示，**列表模式**首先出现在早期的计算机游戏中，并在有更多空间展示各种较长的文本选项给玩家的视觉设计中继续存在。
- en: The second model, the **radial menu pattern**, generally appears as part of
    role-playing games on video game consoles or mobile game spaces where there is
    limited visual space and, thus, options are arranged in a circle for easy access
    when using a controller.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种模型，**环形菜单模式**，通常出现在视频游戏机或移动游戏空间中的角色扮演游戏中，在这些游戏中，视觉空间有限，因此选项以圆形排列，以便在控制器使用时易于访问。
- en: In the first section, we will start with lists. As we have already mentioned
    in multiple Unity examples across this book, and in earlier topics in this chapter,
    the vertical arrangement of options is a very common approach. However, we will
    discuss some common pitfalls when using this model and review several examples
    where they are best used and others where you might want to avoid them before
    we move on to cover the radial menu model next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们将从列表开始。正如我们在本书中的多个Unity示例中提到的，以及在本章早期主题中提到的，选项的垂直排列是一种非常常见的方法。然而，在我们转向介绍环形菜单模型之前，我们将讨论使用此模型时的一些常见陷阱，并回顾一些最佳使用和可能需要避免使用的示例。
- en: Listing dialogue options
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出对话选项
- en: 'There is one question we should ask when considering the user interface model
    of a list: how much visual spacing is allowed for each option? In computer games
    focused on text or with narrative-heavy designs, the list model is often the best
    to use. However, the reason for this is based not on computer games themselves,
    but on the assumed input peripherals used with the system. Often, computer games
    use the mouse as a primary input. This means a user can click on various things
    and scroll through a long *list* of options. Because the user is accustomed to
    this form of input and is willing to move through a longer presentation of text,
    the list is often a great model to follow.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑列表的用户界面模型时，我们应该问一个问题：每个选项允许多少视觉间距？在以文本为重点或叙事设计较重的计算机游戏中，列表模型通常是最佳选择。然而，这并非基于计算机游戏本身，而是基于假设的系统输入外围设备。通常，计算机游戏使用鼠标作为主要输入。这意味着用户可以点击各种东西，并滚动通过一个长长的*列表*选项。因为用户习惯了这种输入方式，并且愿意通过较长的文本展示进行移动，所以列表通常是一个很好的模型。
- en: Reminder
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-ListingOptions`. Only selected
    parts of the code will be shown as they relate to the concepts examined in this
    section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在GitHub上的[*第10章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)中找到，名称为`Chapter10-ListingOptions`。将仅展示与本章探讨的概念相关的代码部分。
- en: In some role-playing or visual novel-based video games, the player might be
    presented with many options based on their past associations with other characters,
    political parties, or organizations. The number of options might also be influenced
    by certain skills, traits, or other in-game perks that grant the player additional
    benefits within dialogue selection. The `Chapter10-ListingOptions` project is
    based on such a premise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些角色扮演或视觉小说为基础的视频游戏中，玩家可能会根据他们与其他角色、政党或组织的过去关联，面对许多选项。选项的数量也可能受到某些技能、特质或其他游戏中给予玩家额外对话选择利益的特权的影响。`Chapter10-ListingOptions`项目就是基于这样的前提。
- en: 'In the dialogue presented in the ink code, the player is aboard a passenger
    ship and on their way to another city where they encounter another character in
    a crew-only area. There are multiple programmed options for the player to consider,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在墨迹代码中展示的对话中，玩家在一艘客船上，正在前往另一个城市，在那里他们在船员专用区域遇到了另一个角色。玩家有多种程序化的选项可以考虑，如下所示：
- en: 'Example 11 (InkListingOptions.ink):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 示例11（InkListingOptions.ink）：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Because of the amount of visual space taken up by the dialogue selection in
    the code for *Example 11*, the multiple options extend off the screen. The player
    must scroll down and carefully read over the list in order to consider their choice.
    Such an interface works well in visual designs with a heavy narrative focus or
    on platforms such as desktop computers where the user might feel comfortable reviewing
    everything before making a final decision when progressing through a dialogue
    tree. However, this is not the only model a developer might want to use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码中*示例11*的对话选择占用的视觉空间量，多个选项延伸到了屏幕之外。玩家必须向下滚动并仔细阅读列表，以便考虑他们的选择。这种界面在注重叙事的视觉设计中工作得很好，或者在桌面计算机等平台上，用户可能在通过对话树进行决策之前感到舒适地回顾一切。然而，这并不是开发者想要使用的唯一模型。
- en: In the next section, we will examine the radial menu pattern. Popularized by
    role-playing games on video game consoles where the number of inputs is limited,
    the radial menu pattern presents not only a design challenge but a writing one
    as well. As we will explore in more detail, the radial menu pattern limits the
    amount of text that appears on the screen and forces a developer to make sure
    the intent of a single word or phrase conveys the outcome the player will experience
    when choosing an option.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨径向菜单模式。这种模式在视频游戏控制台上的角色扮演游戏中流行起来，因为输入的数量有限。径向菜单模式不仅提出了设计挑战，也提出了写作挑战。正如我们将更详细地探讨的那样，径向菜单模式限制了屏幕上显示的文本量，迫使开发者确保单个单词或短语的意图传达了玩家选择选项时将体验到的结果。
- en: Presenting a radial menu for dialogue
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示对话的径向菜单
- en: Many video game controllers have at least one joystick and a limited number
    of buttons. Because of this reduced set of inputs, designing a user interface
    for a player to decide between multiple options often means presenting options
    arranged in a clockwise pattern on the screen. More commonly, this visual design
    pattern is called a **radial menu**. This term takes its name from the mathematical
    concept *radius*, which is the distance from the center of a circle to its perimeter.
    A *radial* menu shows options based on a circular pattern.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多视频游戏控制器至少有一个摇杆和有限数量的按钮。由于这个输入集的减少，为玩家设计用户界面以在多个选项之间进行选择通常意味着在屏幕上以顺时针模式展示选项。更常见的是，这种视觉设计模式被称为**径向菜单**。这个术语的名字来源于数学概念*半径*，即从圆心到圆周的距离。*径向*菜单基于圆形模式展示选项。
- en: Reminder
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found in the [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)
    examples on GitHub under the name of `Chapter10-OptionWheel`. Only selected parts
    of the code will be shown as they relate to the concepts examined in this section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目可以在GitHub上的[*第10章*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145)示例中找到，名称为`Chapter10-OptionWheel`。由于与本章探讨的概念相关，只会展示代码的部分内容。
- en: 'Demonstrating a common use of the radial menu, the `Chapter10-OptionWheel`
    example presents a scene where a player must confront a door and has multiple
    skills based on their in-game statistics. The outcomes for each option are represented
    by the name of the statistic:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过展示径向菜单的常见用法，`Chapter10-OptionWheel`示例呈现了一个场景，玩家必须面对一扇门，并基于他们在游戏中的统计数据拥有多种技能。每个选项的结果由统计数据的名称表示：
- en: 'Example 12 (InkOptionWheel.ink):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 示例12（InkOptionWheel.ink）：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the code for *Example 12*, there are four options, each with the name of
    an example game statistic. When arranged in a simplified *radial* pattern, they
    might appear as the following in Unity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在*示例12*的代码中，有四个选项，每个选项都有一个示例游戏统计数据的名称。当以简化的*径向*模式排列时，它们在Unity中可能看起来如下：
- en: '![Figure 10.4 – The arrangement of dialogue options as a simplified radial
    menu'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 对话选项的简化径向菜单排列'
- en: '](img/Figure_10.4_B17597.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B17597.jpg)'
- en: Figure 10.4 – The arrangement of dialogue options as a simplified radial menu
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 对话选项的简化径向菜单排列
- en: The **radial menu pattern** comes with the built-in limitation of reduced visual
    space. As mentioned in the *Listing dialogue options* section, the visual space
    given to the presentation of the options dictates how the information is presented.
    For the radial menu model, this is even more true.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**径向菜单模式**自带减少视觉空间的内置限制。正如在*列出对话选项*部分中提到的，分配给选项展示的视觉空间决定了信息如何呈现。对于径向菜单模型，这一点尤为重要。'
- en: As with the code for *Example 12*, the options presented on the screen must
    be matched to either the in-game statistics or the known outcomes to the player.
    For example, a player might know that if they select a certain icon, it will match
    a certain action. In these scenarios, they will be limited to no words in Ink
    to represent the option, with Unity taking more of the load to represent the option
    to the player as part of the user interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与*示例12*的代码一样，屏幕上显示的选项必须与游戏中的统计数据或玩家已知的结局相匹配。例如，玩家可能知道如果他们选择某个图标，它将匹配某个动作。在这些情况下，他们将在Ink中无法用文字表示选项，Unity将承担更多责任，将选项作为用户界面的一部分呈现给玩家。
- en: In this section, we reviewed the radial menu pattern. Presenting options in
    a clockwise arrangement, this pattern most often appears as part of a dialogue
    system for video game consoles with controllers or as part of a visual design
    with limited visual space. However, the use of the pattern has a direct effect
    on how options are written in ink. In one pattern, that is, lists, longer sentences
    can be included, but a player might not see all of them at once. For the other
    model, that is, the radial menu pattern, the options are only single words or
    perhaps even icons that represent more complex reactions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了环形菜单模式。以顺时针排列呈现选项，这种模式通常作为具有控制器或有限视觉空间的视觉设计的一部分出现在视频游戏控制台对话系统中。然而，该模式的使用直接影响到ink中选项的编写。在一个模式中，即列表，可以包含较长的句子，但玩家可能一次看不到所有这些。对于另一种模式，即环形菜单模式，选项仅是单个单词或甚至代表更复杂反应的图标。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored three different approaches to dialogue systems.
    In the first approach, we worked through hashtags and speech tags. In ink, we
    can add a hashtag to the end of a line. This allows you to add extra information
    per line such as the speaker for a line of dialogue or which media file to play
    for the line. With speech tags, a colon (`:`) can be added in front of the dialogue
    to mark the speaker. The speech tag helps with testing with Inky but requires
    more C# code in Unity. Hashtags and speech tags can be combined in various contexts
    where the hashtag can represent the media file or additional data for the developer
    whereas the speech tag contains who is communicating the line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三种不同的对话系统方法。在第一种方法中，我们通过标签和语音标签进行了操作。在ink中，我们可以在一行的末尾添加一个标签。这允许你为每行添加额外信息，例如对话的说话者或为该行播放的媒体文件。使用语音标签，可以在对话前添加一个冒号（`:`）来标记说话者。语音标签有助于使用Inky进行测试，但需要在Unity中编写更多的C#代码。在可以结合各种上下文的情况下，标签和语音标签可以组合使用，其中标签可以代表媒体文件或开发者的额外数据，而语音标签包含谁在传达该行。
- en: In the second approach, we zoomed out from the line-by-line emphasis with tags
    to the structures within ink. To replicate a click-to-continue pattern, we can
    combine a knot and the use of tunnels in ink. This is also true of dialogue trees,
    which we can break out into their own stitches within a larger knot. We also learned
    about the use of the `CHOICE_COUNT()` ink function and how to progress through
    a set of options.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，我们从带有标签的逐行强调扩展到ink中的结构。为了复制点击继续模式，我们可以结合ink中的节点和隧道的使用。这也适用于对话树，我们可以将其从更大的节点中分离出来作为自己的线。我们还学习了`CHOICE_COUNT()`
    ink函数的使用以及如何遍历一系列选项。
- en: In the final approach, we zoomed out from ink to consider visual designs in
    Unity and how they affect the writing of dialogue. The pattern used, whether a
    list or radial menu, will dictate how dialogue is created within ink. For a list,
    where each option can include multiple lines of text, a player will only see a
    limited selection at a time. For the radial menu pattern, where options are presented
    in a clockwise pattern on the screen, the dialogue within ink will be limited
    or nonexistent. In either case, the visual space for user interface elements directly
    affects how options are presented to a player.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的方法中，我们从墨迹扩展到考虑Unity中的视觉设计以及它们如何影响对话的编写。所使用的模式，无论是列表还是环形菜单，都将决定在ink中如何创建对话。对于列表，其中每个选项可以包含多行文本，玩家一次只能看到有限的选择。对于环形菜单模式，其中选项在屏幕上以顺时针模式呈现，ink中的对话将受到限制或不存在。在任一情况下，用户界面元素的视觉空间直接影响到选项如何呈现给玩家。
- en: In [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159), *Quest Tracking
    and Branching Narratives*, we will move from smaller dialogue systems to the much
    larger ones of quest tracking and creating branching narratives. While many video
    games often present dialogue to a player, some track multiple values over longer
    periods. We will examine how the `LIST` ink keyword can be used to track quest
    progression and how larger ink projects can be broken up across multiple files
    for easier asset maintenance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159) *任务追踪和分支叙事*中，我们将从较小的对话系统转向更大的任务追踪和创建分支叙事。虽然许多视频游戏经常向玩家呈现对话，但一些游戏会在较长时间内跟踪多个值。我们将研究如何使用`LIST`
    ink关键字来跟踪任务进度，以及如何将较大的ink项目拆分为多个文件以简化资产维护。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a hashtag in ink?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ink中的标签是什么？
- en: What are the differences between a hashtag and a speech tag?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签和语音标签之间的区别是什么？
- en: How did the term *dialogue tree* get its name?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “**对话树**”这个术语是如何得名的？
- en: What is a list pattern?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**列表模式**？
- en: What is a radial menu pattern?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是**径向菜单模式**？
