- en: Working with Plain Text, XML, and JSON Text Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading external text files using the TextAsset public variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading external text files using C# file streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving external text files with C# file streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and parsing external XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating XML text data manually using XMLWriter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and Loading XML text data automatically through serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating XML text files, and saving XML directly to text files with XMLDocument.Save()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating JSON strings from individual objects and lists of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating individual objects and lists of objects from JSON strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text-based external data is very common and very useful as it is both computer-
    and human- readable. Text files may be used to allow non-technical team members
    to edit written content or for recording game performance data during development
    and testing. Text-based formats also permit **serialization**—the encoding of
    live object data suitable for transmission, storing, and later retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity treats all of the following (and also C# scripts) as **Text Assets**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.txt`: Plain text file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.html`, `.htm`: HTML page markup (HyperText Markup Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.xml`: XML data (eXtensible Markup Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.bytes`: Binary data (accessed through bytes property)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.json`: JSON (JavaScript Object Notation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.csv`: CSV (Comma Separate Variable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.yaml`: YAML Ain''t Markup Language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fnt`: Bitmap font data (with associated image texture file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about Unity Text Assets in the manual pages, click on the following
    link: [https://docs.unity3d.com/Manual/class-TextAsset.html](https://docs.unity3d.com/Manual/class-TextAsset.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many web-based systems use XML for asynchronous communications without requiring
    user interaction, leading to the term **AJAX**: **Asynchronous JavaScript XML**.
    Some modern web-based systems now use JSON for text-based communication. For this
    reason, this chapter puts special focus on these two text file formats.'
  prefs: []
  type: TYPE_NORMAL
- en: The Big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from plain text, there are two common text interchange file formats:
    XML and JSON. Each is discussed and illustrated through recipe examples in this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: XML – the eXtensible markup language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'XML is a meta-language, that is, a set of rules that allows markup languages
    to be created to encode specific kinds of data. Some examples of data-description
    language formats using the XML syntax include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.txt`: Plain text file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.html`, `.htm`: HTML page markup (HyperText Markup Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.xml`: XML data (eXtensible Markup Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SVG`: Scalable Vector Graphics—an open standard method of describing graphics
    supported by the Worldwide Web consortium'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOAP`: Simple Object Access Protocol for the exchange of messages between
    computer programs and web services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X3D`: Xml 3D—an ISO standard for representing 3D objects—it is the successor
    to **VRML** (**Virtual Reality Modeling Language**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON – the JavaScript object notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSON is sometimes referred to as the *fat-free alternative to XML*—offering
    similar data interchange strengths, but being smaller, and simpler, both by not
    offering extensibility and using just three characters for formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`property : value`: the colon character separates a property name form its
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{ }`: braces are for an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ ]`: square brackets are for an array of values/objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about JSON versus XML at [https://www.json.org/xml.html](https://www.json.org/xml.html)
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 10, *Working with External Resource Files*, several methods for loading
    external resource files were demonstrated, which work for image, audio, and text
    resources. In this chapter, several additional methods for loading text files
    in particular are presented.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](80a35b7a-7c45-4b18-adcf-b9c99c2e486d.xhtml),  *Shader Graphs
    and Video Players*, some recipes illustrate the use of JSON for a database-driven
    web leaderboard, and Unity game communication with that leaderboard.
  prefs: []
  type: TYPE_NORMAL
- en: Loading external text files using the TextAsset public variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A straightforward way to store data in text files and then choose between them
    before compiling is to use a public variable of the class `TextAsset`.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is only appropriate when there will be no change to the data
    file after game compilation, since the text file data is serialized (mixed into)
    the general build resources, and so cannot be changed after the build has been
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, you''ll need a text `(.txt`) file. In the `11_01` folder,
    we have provided two such files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cities.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`countries.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load external text files using `TextAsset`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **UI TextGameObject**, center it on screen with the **Rect Transform**,
    and set its horizontal and vertical overflow to overflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the text file you wish to use into your project (for example, `cities.txt`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a C# `ReadPublicTextAsset` script class and attach an instance as a
    component to your **UI Text GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With **Ma****in Camera** selected in the **Hierarchy** view, drag the `cities.txt`
    file into the public string variable `dataTextFile` in the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the scene starts, the text content of the text file is read into variable
    `textFromFile`. A reference is found to the **UI Text** component, and the text
    property of that UI component is set to be the content of `textFromFile`. The
    user can then see the content of the text file displayed in the middle of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Loading external text files using C# file streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For standalone executable games that both read from and write to (create or
    change) text files, **.NET** data streams are often used for both reading and
    writing. This recipe illustrates how to read a text file, while the next recipe
    illustrates how to write text data to files.
  prefs: []
  type: TYPE_NORMAL
- en: This technique only works when you compile to a Windows or Mac standalone executable;
    it will not work for **WebGL** builds, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, you'll need a text file; two have been provided in the `11_01`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load external text files using C# file streams, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script-class `FileReadWriteManager`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `ReadWithStream` script class and attach an instance as a component
    to your **UI Text GameObject**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Save the current scene and then add this to the list of scenes in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the text file containing your data into your standalone's `Resources` folder
    (that is, the filename you set in the first statement in the `Start()` method—in
    our listing, this is the `cities.txt` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to place the files in the `Resources` folder manually after every
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows and Linux users: When you create a Windows or Linux standalone
    executable, there is a `_Data` folder that is created with the executable application
    file. The `Resources` folder can be found inside this data folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Mac users: A Mac standalone application executable looks like a single
    file, but it is actually a macOS "package" folder. Right-click on the executable
    file and select Show Package Contents. You will then find the standalone''s Resources
    folder inside the Contents folder.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run your built executable, you should see the text file content loaded
    and displayed in the middle of the application window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the game runs, the `Start()` method creates the `filePath` string and then
    calls the `ReadTextFile()` method from the `fileReadWriteManager` object, to which
    it passes the filePath string. This method reads the content of the file and returns
    them as a string, which is stored in the `textFileContents` variable. Our `OnGUI()`
    method displays the values of these two variables (`filePath` and `textFileContents`).
  prefs: []
  type: TYPE_NORMAL
- en: Note the need to use the `System.IO` package for this recipe. The C# script
    `FileReadWriteManager.cs` contains two general purpose file read and write methods
    that you may find useful in many different projects.
  prefs: []
  type: TYPE_NORMAL
- en: Saving external text files with C# file streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe illustrates how to use C# streams to write text data to a text file,
    either into the standalone project's `Data` folder or to the `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This technique only works when you compile to a Windows or Mac standalone executable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `11_02` folder, we have provided a text file containing the completed
    C# script class created in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save external text files using C# file streams, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new 2D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the C# `FileReadWriteManager.cs` script class into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following C# `SaveTextFile` script class to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save the current scene and then add this to the list of scenes in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After running the built executable, you should now find a new text file named
    `hello.txt` in the `Data` folder of your project's standalone files, containing
    the lines hello and and goodbye
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/67d41db9-a45d-42d8-ae2f-c5d5a3c59641.png)'
  prefs: []
  type: TYPE_IMG
- en: It is possible to test this when running within the Unity editor (that is, before
    building a standalone application). To test this way, you'll need to create a
    `Data` folder in your project panel.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the game runs, the `Start()` method creates the `filePath` string from
    the public variables `fileName` and `folderName`, and then calls the `WriteTextFile()`
    method from the `fileReadWriteManager` object, to which it passes the `filePath`
    and `textData` strings. This method creates (or overwrites) a text file (for the
    given file path and filename) containing the string data received.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Data or the Resources folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standalone build applications contain both a `Data` folder and a `Resources`
    folder. Either of these can be used for writing (or some other folder, if desired).
    We generally put read-only files into the `Resources` folder and use the `Data`
    folder for files that are to be created from scratch or that have had their content
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Before you build your executable, you can specify a different file and folder
    name (for example, `Resources` instead of `Data`). Ensure the **Main Camera GameObject**
    is selected in the **Hierarchy**, and then change the values in those public variables
    in the **Inspector** component Save text File (Script).
  prefs: []
  type: TYPE_NORMAL
- en: Loading and parsing external XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is useful to be able to parse (process the content of) text files and strings
    containing data in the XML format. C# offers a range of classes and methods to
    make such processing straightforward, which we'll explore in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ll find player name and score data in XML format in the `playerScoreData.xml`
    file in the `11_04` folder. The content of this file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The data is structured by a root element named `scoreRecordList`, which contains
    a sequence of `scoreRecord` elements. Each `scoreRecord` element contains a player
    element (which contains a player's name), a score element (which has the integer
    content of the player's score), and a date element, which itself contains three
    child elements – day, month, and year.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load and parse external XML files, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C# `PlayerScoreDate` script class containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `ParseXML` script class and attach an instance as a component to
    the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the scene, and the output of the `print()` statements should be visible
    in the Console window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e7b5cdc-274f-4065-bbec-6eb17cad6056.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `PlayerScoreDate` script class simply contains the three pieces of data
    for player-dated scores:'
  prefs: []
  type: TYPE_NORMAL
- en: The player's name (string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player's score (integer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date the score was recorded (string—to keep this recipe short...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the need to use the `System`, `System.Xml` and `System.IO` packages for
    the C# `ParseXML` script class.
  prefs: []
  type: TYPE_NORMAL
- en: The `text` property of the `TextAsset` variable `scoreDataTextFile` provides
    the content of the XML file as a string, which is passed to the `ParseScoreXML(...)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This `ParseScoreXML(...)` method creates a new `XmlDocument` variable with the
    content of this string. The `XmlDocument` class provides the `SelectNodes()` method,
    which returns a list of node objects for a given element path. In this example,
    a list of `scoreRecord` nodes is requested. A for-each statement loops for each
    scoreRecord, passing the current node to method `NodeToPlayerScoreObject(...),`
    and storing the returned object into the next slot in the `playerScores `array.
  prefs: []
  type: TYPE_NORMAL
- en: The `NodeToPlayerScoreObject(...)` method relies on the ordering of the XML
    elements to retrieve the player's name, score, and data strings. The score string
    is parsed into an integer, and the date node is converted to a date string using
    method `NodeToDateString(...)`. A new `PlayerScoreDate` object is created, and
    the name, score and date stored in it, and then that object is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `NodeToDateString(...)` method creates a date string as a slash-separated
    string by parsing the node containing the three date components.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving XML data files from the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the WWW Unity class if the XML file is located on the web rather
    than in your Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating XML text data manually using XMLWriter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to create XML data structures from game objects and properties is by
    hand-coding a method to create each element and its content, using the `XMLWriter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create XML text data using `XMLWriter`, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C# `CreateXMLString` script class to add an instance as a component
    to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML text data should be visible in the Console panel when the scene is
    run, and should look as follows (some newline characters have been added to make
    the output more human-readable...):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Start()` method calls `BuildXMLString()` and stores the returned string
    in the output variable. This output text is then printed to the Console debug
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: The `BuildXMLString()` method creates a `StringWriter` object, into which `XMLWriter`
    builds the string of XML elements. The XML document starts and ends with the `WriteStartDocument()`
    and `WriteEndDocument()` methods. Elements start and end with `WriteStartElement()`
    and `WriteEndElement().` String content for an element is added using `WriteElementString().`
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new lines to make XML strings more human readable.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After every instance of the `WriteStartElement()` and `WriteElementString()`
    methods, you can add a newline character using `WriteWhiteSpace().` These are
    ignored by XML parsing methods, but if you intend to display the XML string for
    a human to see, the presence of the new line''s characters makes it much more
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Making data class responsible for creating XML from list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The XML to be generated is often from a list of objects, all of the same class.
    In this case, it makes sense to make the class of the objects responsible for
    generating the XML for a list of those objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `CreateXMLFromArray` class simply creates an instance of `List<T>` containing
    `PlayerScore` objects, and then calls the (static) method `ListToXML(),` passing
    in the list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following should be a single block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All the hard work is now the responsibility of the `PlayerScore` class. This
    class has two private variables for the player''s name and score and a constructor
    that accepts values for these properties. The public static method `ListToXML()`
    takes a `List` object as an argument, and uses `XMLWriter` to build the XML string,
    looping through each object in the list and calling the object''s `ObjectToElement()`
    method. This method adds an XML element to the `XMLWriter` argument received for
    the data in that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Saving and loading XML text data automatically through serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to work with XML data structures from game objects and properties
    is by serializing the content of an object automatically. This technique automatically
    generates XML for all the public properties of an object. This recipe uses the
    `XmlSerializer` class that can be found in the standard `System.Xml` C# package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe has been adapted from this 2013 (still works!) Unify Community
    Wiki article: [http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer](http://wiki.unity3d.com/index.php?title=Saving_and_Loading_Data:_XmlSerializer)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `11_06` folder, you'll find two XML data files, allowing you to test
    the reader with different XML text file data files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create XML text data through serialization, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a C# `PlayerScore` script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `PlayerScoreCollection` scrip class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `XmlWriter` script class and attach an instance as a component
    to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can quickly test the scene in the Unity Editor if you create a `Data` folder
    in the Project panel and then run the scene. After 10-20 seconds, you should now
    find that text file `playerData.xml` has been created in the `Data` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current scene and then add this to the list of scenes in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now find a new text file named `playerData.xml` in the `Data` folder
    of your project's standalone files, containing the XML data for the three players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The content of the `playerData.xml` file should be the XML player list data,
    that is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Start()` method of class `XmlWriter` defines the file path (`Data/playerData.xml`)
    and creates a new `PlayerScoreCollection` object psc, by invoking the method `CreatePlayScoreCollection().`
    The Save(...) method of the `PlayerScoreCollection` object is then invoked, passing
    the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreatePlayScoreCollection()` method of class `XmlWriter` creates a new
    `PlayerScoreCollection`, and inserts into this an array of two `PlayerScore` objects
    with name/score/version values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Save(...)` method of class `PlayerScoreCollection` creates a new `XmlSerializer`
    for the class type, and uses a `FileStream` to tell C# to serialize the content
    of the `PlayerScoreCollection` object (that is, its array of `PlayerScore` objects)
    as text to that file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the XML node names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use compiler statements to define the XML element name that will be
    used to encode each object property. For example, we have defined element Name
    (with a capital letter N) for the name property of each `PlayerScore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If this hadn't been declared, then the XML Serializer would have defaulted to
    the lowercase property name `name` for these data elements.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data objects from XML text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can write static (class) methods for class `PlayerScoreCollection` that use
    the `XML``Serializer` to load XML data and create data objects from that loaded
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a method to load from a filepath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method can be written to load from a text string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, you could create a public `TextAsset` variable, and then create
    a `PlayerScoreCollection` object by invoking this static method, then loop through
    and print out the loaded objects with code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating XML text files – saving XML directly to text files with XMLDocument.Save()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to create an XML data structure and then save that data directly
    to a text file using the `XMLDocument.Save()` method; this recipe illustrates
    how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To save XML data to text files directly, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# `PlayerXMLWriter` script class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `CreateXMLTextFile` script class and attach an instance as a component
    to the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can quickly test the scene in the Unity Editor if you create a `Data` folder
    in the Project panel and then run the scene. After 10-20 seconds, you should now
    find that text file `playerData.xml` has been created in the `Data` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the current scene and then add this to the list of scenes in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run your (Windows, Mac, or Linux) standalone executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now find a new text file named `playerData.xml` in the `Data` folder
    of your project''s standalone files, containing the XML data for the three players:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The content of the `playerData.xml` file should be the XML player list data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/921244fb-5937-498c-944b-9212e785db90.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Start()` method creates `playerXMLWriter`, a new object of the `PlayerXMLWriter`
    class, to which it passes the new, required XML text file `filePath` as an argument.
    Three elements are added to the `PlayerXMLWriter` object, which store the names
    and scores of three players. The `SaveXMLFile()` method is called and a debug
    `print()` message is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor method of the `PlayerXMLWriter` class works as follows: when
    a new object is created, the provided file path string is stored in a private
    variable; at the same time, a check is made to see whether any file already exists.
    If an existing file is found, the content elements are removed; if no existing
    file is found, then a new root element, `playerScoreList`, is created as the parent
    for child data nodes. The method `AddXMLElement()` appends a new data node for
    the provided player name and score. The method `SaveXMLFile()` saves the XML data
    structure as a text file for the stored file path string.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating JSON strings from individual objects and lists of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `JsonUtility` class allows us to easily create JSON strings from individual
    objects, and also **Lists** of objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create JSON strings from individual and **Lists** of objects perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class named `PlayerScore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class named `PlayerScoreList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `ToJson` script class and attach an instance as a component to
    the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the scene. Two messages should be output to the Console panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These should be followed by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `PlayerScore` scrip class declares two public properties: `name` and `score`.
    It also defines a public method `ToJson()` that returns a string containing the
    values of the properties encoded in JSON via the `JsonUtility.ToJson(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerScoreList` script class declares a single public property `list`
    , which is a C# `List<>` of `PlayerScore` obejcts. So, we can store zero, one,
    or any number of `PlayerScore` objects in our list. Also declared is a single
    public method `ToJson()` that returns a string containing the values of the content
    of the `list` property encoded in JSON via the `JsonUtility.ToJson(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: It also defines a public `ToJson()` method that returns a string containing
    the values of the properties encoded in JSON via the `JsonUtility.ToJson(...)`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Awake()` method creates two `PlayerScore` objects, with some demo data
    in objects `playerScore1` and `playerScore2`. It also creates an instance-object
    of class `PlayerScoreList`, and adds references to the two objects to this list.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method first invokes the `ObjectToJson()` method, then it invokes
    the `CollectionToJson()`.
  prefs: []
  type: TYPE_NORMAL
- en: Method `ObjectToJson()` invokes the `ToJson()` method of object `playerScore1`,
    which returns a string, which is then printed to the Console panel.
  prefs: []
  type: TYPE_NORMAL
- en: Method `CollectionToJson()` invokes the `ToJson()` method of object list `playerScoreList`
    which returns a string, which is then printed to the Console panel.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both `PlayerScore` and `PlayerScoreList` classes define a `ToJson()`
    method, which makes use of the `JsonUtilty``ToJson()` method. In both cases, their
    `ToJson()` method returns a string that is the JSON representation of the object's
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlayerScore` class''s `ToJson()` method outputs a JSON object string in
    this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ToJson()` method of the  `PlayerScoreList` class outputs a JSON array
    string in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `JsonUtility` class's `ToString()` method is capable of serializing
    individual objects, and C# Lists of objects into a storable string.
  prefs: []
  type: TYPE_NORMAL
- en: Creating individual objects and Lists of objects from JSON strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `JsonUtility` class allows us to easily parse (process) JSON strings and
    extract individual objects, and also Lists of objects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create individual objects and Lists of objects from JSON strings, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script class named `PlayerScore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new C# script class named `PlayerScoreList`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a C# `ToJson` script class and attach an instance as a component to
    the **Main Camera**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the scene. Three messages should be output to the Console panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'They should be followed by this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Start()` method first invokes method `JsonToObject()`, and then it invokes
    method `JsonToList().`
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `JsonToObject()` declares a string that defines one `PlayerScore`
    object: `{name:matt, score:201}.` The string is created using escaped double-quote
    characters for property names and text data (quotes aren''t needed for the numeric
    data). The JSON string contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using escaped double-quote characters for property names and text data (quotes
    aren't needed for the numeric data). The **static** method `FromJSON(...)` of
    the class `PlayerScore` is then invoked with this JSON data string as its argument.
    The method returns a `PlayerScore` object, whose value is then printed to the
    Console panel.
  prefs: []
  type: TYPE_NORMAL
- en: The **static** method `FromJSON(...)` of class `PlayerScore` invokes the `FromJson()`
    method of the `JsonUtility` class, and provides the class type `PlayerScore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `JsonToList()` declares a string that defines a list of two `PlayerScore`
    objects: `{name:matt, score:800}` and `{name:joelle, score:901}`. The JSON string
    contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The **static** method `FromJSON(...)` of the class `PlayerScoreList` is then
    invoked with this JSON data string as its argument. The method returns a `PlayerScoreList`
    object. A `foreach` loop extracts each `PlayerScore` object from the list property
    of the `PlayerScoreList` object. Each object's `name` and `score` values are printed
    out to the Console panel, prefixed with the text from the list.
  prefs: []
  type: TYPE_NORMAL
- en: The **static** method `FromJSON(...)` of class `PlayerScoreList` invokes the
    `FromJson()` method of the `JsonUtility` class, and provides the class type `PlayerScoreList`.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `JsonUtility` class's `FromJson()` method is capable of deserializing
    data into individual objects, and C# **Lists** of objects inside repository objects,
    such as `PlayerScoreList`.
  prefs: []
  type: TYPE_NORMAL
