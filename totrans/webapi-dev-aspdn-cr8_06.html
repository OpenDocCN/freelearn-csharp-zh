<html><head></head><body>
<div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.2.1">Data Access in ASP.NET Core (Part 2 â€“ Entity Relationships)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In </span><a href="B18971_05.xhtml#_idTextAnchor198"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.5.1">, we introduced the fundamentals of </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">EF Core</span></strong><span class="koboSpan" id="kobo.9.1">), including how to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">DbContext</span></strong><span class="koboSpan" id="kobo.11.1"> class and how to use it to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">access data.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">You can recap the basic concepts of relationships in </span><a href="B18971_01.xhtml#_idTextAnchor012"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.15.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Defining the Relationships between Resources </span></em><span class="koboSpan" id="kobo.17.1">section, where we introduced relationships between resources. </span><span class="koboSpan" id="kobo.17.2">For example, in a blog system, a post has a collection of comments, and a user has a collection of posts. </span><span class="koboSpan" id="kobo.17.3">In an invoice system, an invoice has a collection of invoice items, and an invoice item belongs to an invoice. </span><span class="koboSpan" id="kobo.17.4">An invoice also has a contact, which can have one or more contact persons and can have </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">one address.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, we will continue to explore the features of EF Core. </span><span class="koboSpan" id="kobo.19.2">We will learn how to manage relationships between entities using Fluent APIs. </span><span class="koboSpan" id="kobo.19.3">Finally, we will discuss how to implement CRUD operations for entities </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with relationships.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.23.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">one-to-many relationships</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">one-to-one relationships</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">many-to-many relationships</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">owned entities</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">After reading this chapter, you should be able to configure relationships between entities using Fluent APIs in EF Core and implement CRUD operations for entities with relationships in your ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Core applications.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">The code examples in this chapter can be found at </span><a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6"><span class="koboSpan" id="kobo.35.1">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6</span></a><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">You can use VS 2022 or VS Code to open </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">You are expected to have basic knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">Structured Query Language</span></strong><span class="koboSpan" id="kobo.40.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.41.1">SQL</span></strong><span class="koboSpan" id="kobo.42.1">) queries and </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Language-Integrated Query</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">LINQ</span></strong><span class="koboSpan" id="kobo.46.1">). </span><span class="koboSpan" id="kobo.46.2">If you are not familiar with them, you can refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">following resources:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">SQL </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.49.1">queries</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">: </span></span><a href="https://www.w3schools.com/sql/"><span class="No-Break"><span class="koboSpan" id="kobo.51.1">https://www.w3schools.com/sql/</span></span></a></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">LINQ</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/"><span class="No-Break"><span class="koboSpan" id="kobo.54.1">https://learn.microsoft.com/en-us/dotnet/csharp/linq/</span></span></a></li>
</ul>
<h1 id="_idParaDest-129"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.55.1">Understanding one-to-many relationships</span></h1>
<p><span class="koboSpan" id="kobo.56.1">One-to-many relationships </span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.57.1">are the most common relationships in a relational database. </span><span class="koboSpan" id="kobo.57.2">They are </span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.58.1">also called </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">parent-child (children)</span></strong><span class="koboSpan" id="kobo.60.1"> relationships. </span><span class="koboSpan" id="kobo.60.2">For example, an invoice has a collection of invoice items. </span><span class="koboSpan" id="kobo.60.3">In this section, we will learn how to configure a one-to-many relationship in EF Core and how to implement CRUD operations for entities with a </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">one-to-many relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Let us continue to use the invoice sample application. </span><span class="koboSpan" id="kobo.62.2">You can find the sample code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">EfCoreRelationshipsDemo</span></strong><span class="koboSpan" id="kobo.64.1"> project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">chapter6</span></strong><span class="koboSpan" id="kobo.66.1"> folder. </span><span class="koboSpan" id="kobo.66.2">If you would like to test the code following the book, you can continue to work on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">BasicEfCoreDemo</span></strong><span class="koboSpan" id="kobo.68.1"> project. </span><span class="koboSpan" id="kobo.68.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">InvoiceDbContext</span></strong><span class="koboSpan" id="kobo.70.1"> class has been renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">SampleDbContext</span></strong><span class="koboSpan" id="kobo.72.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">sample code.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Next, let us update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">Invoice</span></strong><span class="koboSpan" id="kobo.76.1"> class and create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.78.1"> class, then define the one-to-many relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">between them</span><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.80.1">.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.81.1">One-to-many configuration</span></h2>
<p><span class="koboSpan" id="kobo.82.1">To demonstrate a</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.83.1"> one-to-many relationship, we need to add a new class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.85.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">Models</span></strong><span class="koboSpan" id="kobo.87.1"> folder and add some additional properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Invoice</span></strong><span class="koboSpan" id="kobo.89.1"> class to represent the relationship </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">between them.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.93.1"> class is </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
public class InvoiceItem{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â public string Name { get; set; } = string.Empty;
Â Â Â Â public string? </span><span class="koboSpan" id="kobo.95.2">Description { get; set; }
Â Â Â Â public decimal UnitPrice { get; set; }
Â Â Â Â public decimal Quantity { get; set; }
Â Â Â Â public decimal Amount { get; set; }
Â Â Â Â public Guid InvoiceId { get; set; }
Â Â Â Â public Invoice? </span><span class="koboSpan" id="kobo.95.3">Invoice { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.96.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.98.1"> class has a set of properties to store the invoice item data, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Name</span></strong><span class="koboSpan" id="kobo.100.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Description</span></strong><span class="koboSpan" id="kobo.102.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">UnitPrice</span></strong><span class="koboSpan" id="kobo.104.1">, and so on. </span><span class="koboSpan" id="kobo.104.2">It also has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.106.1"> property to store the ID of the invoice that the invoice item belongs to, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Invoice</span></strong><span class="koboSpan" id="kobo.108.1"> property </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.109.1">to reference the invoice. </span><span class="koboSpan" id="kobo.109.2">To get started with the configuration process, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.111.1">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">Invoice</span></strong><span class="koboSpan" id="kobo.113.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.115.1">
public class Invoice{Â Â Â Â public Guid Id { get; set; }Â Â Â Â // Omitted for brevityÂ Â Â Â // Add a collection of invoice itemsÂ Â Â Â public List&lt;InvoiceItem&gt; InvoiceItems { get; set; } = new ();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.116.1">In the preceding code, we defined a relationship between </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Invoice</span></strong><span class="koboSpan" id="kobo.118.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">An invoice has a collection of invoice items, and an invoice item belongs to an invoice. </span><span class="koboSpan" id="kobo.120.3">It is a one-to-many relationship, where we can identify </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">these terms:</span></span></p><ul><li><strong class="bold"><span class="koboSpan" id="kobo.122.1">Principal entity</span></strong><span class="koboSpan" id="kobo.123.1">: This</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.124.1"> is the </span><em class="italic"><span class="koboSpan" id="kobo.125.1">one</span></em><span class="koboSpan" id="kobo.126.1"> entity in a one-to-many relationship. </span><span class="koboSpan" id="kobo.126.2">It is also called the parent entity. </span><span class="koboSpan" id="kobo.126.3">In the preceding case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Invoice</span></strong><span class="koboSpan" id="kobo.128.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">principal entity.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Dependent entity</span></strong><span class="koboSpan" id="kobo.131.1">: This</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.132.1"> is the </span><em class="italic"><span class="koboSpan" id="kobo.133.1">many</span></em><span class="koboSpan" id="kobo.134.1"> entity in a one-to-many relationship. </span><span class="koboSpan" id="kobo.134.2">It is also called the child entity. </span><span class="koboSpan" id="kobo.134.3">In the preceding case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.136.1"> is the dependent entity. </span><span class="koboSpan" id="kobo.136.2">It has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.138.1"> foreign key property to identify the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">parent entity.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.140.1">Principal key</span></strong><span class="koboSpan" id="kobo.141.1">: This is </span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.142.1">the primary key of the principal entity, which uniquely identifies the principal entity. </span><span class="koboSpan" id="kobo.142.2">In the preceding case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">Id</span></strong><span class="koboSpan" id="kobo.144.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">Invoice</span></strong><span class="koboSpan" id="kobo.146.1"> class is the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">principal key.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.148.1">Foreign key</span></strong><span class="koboSpan" id="kobo.149.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.151.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.153.1"> class is the foreign key, which</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.154.1"> is used to store the principal key value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">parent entity.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.156.1">Navigation property</span></strong><span class="koboSpan" id="kobo.157.1">: This </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.158.1">is used to reference the related entity. </span><span class="koboSpan" id="kobo.158.2">It can be defined on the principal or dependent entity. </span><span class="koboSpan" id="kobo.158.3">There are two types of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">navigation properties:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.160.1">Collection navigation property</span></strong><span class="koboSpan" id="kobo.161.1">: This</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.162.1"> is defined on the principal entity, which is used to reference a collection of related entities. </span><span class="koboSpan" id="kobo.162.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.164.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Invoice</span></strong><span class="koboSpan" id="kobo.166.1"> class is a collection </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">navigation property.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.168.1">Reference navigation property</span></strong><span class="koboSpan" id="kobo.169.1">: This is defined on the dependent entity, which is</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.170.1"> used to reference a single related entity. </span><span class="koboSpan" id="kobo.170.2">For example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Invoice</span></strong><span class="koboSpan" id="kobo.172.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.174.1"> class is a reference </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">navigation property.</span></span></li></ul></li></ul></li> <li><span class="koboSpan" id="kobo.176.1">Because </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.177.1">we added a new model, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">DbContext</span></strong><span class="koboSpan" id="kobo.179.1"> class. </span><span class="koboSpan" id="kobo.179.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">SampleDbContext</span></strong><span class="koboSpan" id="kobo.181.1"> class and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.183.1">
public DbSet&lt;InvoiceItem&gt; InvoiceItems =&gt; Set&lt;InvoiceItem&gt;();</span></pre></li> <li><span class="koboSpan" id="kobo.184.1">Also, it is a good practice to configure the mapping for the new model. </span><span class="koboSpan" id="kobo.184.2">Add a new class </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.185.1">in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Data</span></strong><span class="koboSpan" id="kobo.187.1"> folder and name </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">InvoiceItemConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.191.1">
public class InvoiceItemConfiguration : IEntityTypeConfiguration&lt;InvoiceItem&gt;{Â Â Â Â public void Configure(EntityTypeBuilder&lt;InvoiceItem&gt; builder)Â Â Â Â {Â Â Â Â Â Â Â Â builder.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.192.1">"InvoiceItems"</span></span><span class="koboSpan" id="kobo.193.1">);Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.Id).HasColumnName(nameof(InvoiceItem.Id));Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.Name).HasColumnName(nameof(InvoiceItem.Name)).HasMaxLength(64).IsRequired();Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.Description).HasColumnName(nameof(InvoiceItem.Description)).HasMaxLength(256);Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.UnitPrice).HasColumnName(nameof(InvoiceItem.UnitPrice)).HasPrecision(8, 2);Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.Quantity).HasColumnName(nameof(InvoiceItem.Quantity)).HasPrecision(8, 2);Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.Amount).HasColumnName(nameof(InvoiceItem.Amount)).HasPrecision(18, 2);Â Â Â Â Â Â Â Â builder.Property(p =&gt; p.InvoiceId).HasColumnName(nameof(InvoiceItem.InvoiceId));Â Â Â Â }}</span></pre></li> <li><span class="koboSpan" id="kobo.194.1">Once we define navigation properties for </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">Invoice</span></strong><span class="koboSpan" id="kobo.196.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.198.1">, EF Core can discover the relationship between these two entities. </span><span class="koboSpan" id="kobo.198.2">Let us create a migration using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">dotnet ef migrations add AddInvoiceItem</span></strong><span class="koboSpan" id="kobo.200.1"> command. </span><span class="koboSpan" id="kobo.200.2">Then, check the generated migration file. </span><span class="koboSpan" id="kobo.200.3">You will find that EF Core </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.201.1">has added the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
migrationBuilder.CreateTable(Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.204.1">"InvoiceItems"</span></span><span class="koboSpan" id="kobo.205.1">,Â Â Â Â columns: table =&gt; newÂ Â Â Â {Â Â Â Â Â Â Â Â Id = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.206.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.207.1">, nullable: false),Â Â Â Â Â Â Â Â // Omitted for brevityÂ Â Â Â Â Â Â Â InvoiceId = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.208.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.209.1">, nullable: false)Â Â Â Â },Â Â Â Â constraints: table =&gt;Â Â Â Â {Â Â Â Â Â Â Â Â table.PrimaryKey(</span><span class="StringTok"><span class="koboSpan" id="kobo.210.1">"PK_InvoiceItems"</span></span><span class="koboSpan" id="kobo.211.1">, x =&gt; x.Id);Â Â Â Â Â Â Â Â table.ForeignKey(Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.212.1">"FK_InvoiceItems_Invoices_InvoiceId"</span></span><span class="koboSpan" id="kobo.213.1">,Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.InvoiceId,Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.214.1">"Invoices"</span></span><span class="koboSpan" id="kobo.215.1">,Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.216.1">"Id"</span></span><span class="koboSpan" id="kobo.217.1">,Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);Â Â Â Â });// Omitted for brevitymigrationBuilder.CreateIndex(Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.218.1">"IX_InvoiceItems_InvoiceId"</span></span><span class="koboSpan" id="kobo.219.1">,Â Â Â Â table: </span><span class="StringTok"><span class="koboSpan" id="kobo.220.1">"InvoiceItems"</span></span><span class="koboSpan" id="kobo.221.1">,Â Â Â Â column: </span><span class="StringTok"><span class="koboSpan" id="kobo.222.1">"InvoiceId"</span></span><span class="koboSpan" id="kobo.223.1">);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.224.1">EF Core will create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.226.1"> table and add a foreign key constraint to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.228.1"> column. </span><span class="koboSpan" id="kobo.228.2">The name of the foreign key constraint is </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">FK_&lt;dependent type name&gt;_&lt;principal type name&gt;_&lt;foreign key property name&gt;</span></strong><span class="koboSpan" id="kobo.230.1">. </span><span class="koboSpan" id="kobo.230.2">It will also create an index on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">InvoiceId</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1"> column.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.233.1">Another </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.234.1">thing you need to be aware of is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">onDelete</span></strong><span class="koboSpan" id="kobo.236.1"> action is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">ReferentialAction.Cascade</span></strong><span class="koboSpan" id="kobo.238.1">, which means that if the parent entity is deleted, all related child entities will also </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">be deleted.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">Let's think about a question â€“ what if we do not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.242.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.244.1"> class? </span><span class="koboSpan" id="kobo.244.2">Can EF Core still discover the relationship between these two entities? </span><span class="koboSpan" id="kobo.244.3">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">dotnet ef migrations remove</span></strong><span class="koboSpan" id="kobo.246.1"> command to remove the last migration, delete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.248.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.250.1"> class, and then add a migration again. </span><span class="koboSpan" id="kobo.250.2">You will see that EF Core can still create a column named </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.252.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.254.1"> table, and apply the foreign key constraint to it, which is </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.255.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">shadow foreign key</span></strong><span class="koboSpan" id="kobo.257.1"> property. </span><span class="koboSpan" id="kobo.257.2">This is because EF Core has its built-in convention to do this. </span><span class="koboSpan" id="kobo.257.3">There are a few scenarios where EF Core can discover one-to-many relationships </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">between entities:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.259.1">The dependent entity has a reference navigation property to the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">principal entity</span></span></li>
<li><span class="koboSpan" id="kobo.261.1">The principal entity has a collection navigation property to the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">dependent entity</span></span></li>
<li><span class="koboSpan" id="kobo.263.1">The reference navigation property and the collection navigation property are included at </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">both ends</span></span></li>
<li><span class="koboSpan" id="kobo.265.1">The reference navigation property and the collection navigation property are included at both ends, and the foreign key property is included in the </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">dependent entity</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.267.1">We can </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.268.1">explicitly configure the relationship between entities to change the default behavior of EF Core if the convention does not work for us. </span><span class="koboSpan" id="kobo.268.2">Follow </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.270.1">To explicitly configure the one-to-many relationship between entities, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">HasOne()</span></strong><span class="koboSpan" id="kobo.272.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">WithMany()</span></strong><span class="koboSpan" id="kobo.274.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">HasMany()</span></strong><span class="koboSpan" id="kobo.276.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">WithOne()</span></strong><span class="koboSpan" id="kobo.278.1"> methods. </span><span class="koboSpan" id="kobo.278.2">Add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">InvoiceConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.281.1">
builder.HasMany(x =&gt; x.InvoiceItems)Â Â Â Â .WithOne(x =&gt; x.Invoice)Â Â Â Â .HasForeignKey(x =&gt; x.InvoiceId);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.282.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">HasMany()</span></strong><span class="koboSpan" id="kobo.284.1"> method is used to configure the collection navigation property, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">WithOne()</span></strong><span class="koboSpan" id="kobo.286.1"> method is used to configure the reference navigation property. </span><span class="koboSpan" id="kobo.286.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">HasForeignKey()</span></strong><span class="koboSpan" id="kobo.288.1"> method is used to configure the foreign key property. </span><span class="koboSpan" id="kobo.288.2">So, the preceding code explicitly configures that one invoice can have many invoice items, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.290.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.292.1"> class is the foreign key. </span><span class="koboSpan" id="kobo.292.2">If you add a migration now, you will find that EF Core will generate the same code as that generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the convention.</span></span></p></li> <li><span class="koboSpan" id="kobo.294.1">A relationship can be also defined for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.296.1"> class. </span><span class="koboSpan" id="kobo.296.2">Remove the preceding configuration code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Invoice</span></strong><span class="koboSpan" id="kobo.298.1"> class, and add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">InvoiceItemConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
builder.HasOne(i =&gt; i.Invoice)Â Â Â Â .WithMany(i =&gt; i.InvoiceItems)Â Â Â Â .HasForeignKey(i =&gt; i.InvoiceId)Â Â Â Â .OnDelete(DeleteBehavior.Cascade);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.302.1">It should be easy to understand now. </span><span class="koboSpan" id="kobo.302.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">HasOne()</span></strong><span class="koboSpan" id="kobo.304.1"> method is used to configure the reference navigation property, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">WithMany</span></strong><span class="koboSpan" id="kobo.306.1"> method is used to configure the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">navigation property.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.308.1">Note that we also explicitly configured the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">OnDelete()</span></strong><span class="koboSpan" id="kobo.310.1"> action to </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Cascade</span></strong><span class="koboSpan" id="kobo.312.1">, which is the same as the one generated by the convention. </span><span class="koboSpan" id="kobo.312.2">But we can change it to other options if needed. </span><span class="koboSpan" id="kobo.312.3">That said, the Fluent API is more flexible than </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">the convention.</span></span></p></li> <li><span class="koboSpan" id="kobo.314.1">We </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.315.1">just need to configure the relationship on one side of the relationship. </span><span class="koboSpan" id="kobo.315.2">So, please clean up the test code before you add the migration file and apply the migration to the database. </span><span class="koboSpan" id="kobo.315.3">After the migration is applied, you can check the database schema to see if the foreign key constraint is created, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">following figure:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.317.1"><img alt="Figure 6.1 â€“ A foreign key constraint is created in the database" src="image/B18971_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.318.1">Figure 6.1 â€“ A foreign key constraint is created in the database</span></p>
<p><span class="koboSpan" id="kobo.319.1">As a one-to-many relationship can be defined in either direction, which side should we configure the relationship on? </span><span class="koboSpan" id="kobo.319.2">It depends on the scenario. </span><span class="koboSpan" id="kobo.319.3">If the two entities have a strong one-to-many relationship, it does not really matter which side we configure the relationship on. </span><span class="koboSpan" id="kobo.319.4">But if the two entities are loosely coupled, we had better configure the relationship on the </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">dependent entity.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">User</span></strong><span class="koboSpan" id="kobo.323.1"> entity is shared by many other entities, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">Post</span></strong><span class="koboSpan" id="kobo.325.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">Comment</span></strong><span class="koboSpan" id="kobo.327.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">Invoice</span></strong><span class="koboSpan" id="kobo.329.1">, and so on. </span><span class="koboSpan" id="kobo.329.2">Each </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">Post</span></strong><span class="koboSpan" id="kobo.331.1"> entity can have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">Author</span></strong><span class="koboSpan" id="kobo.333.1"> property that is a reference navigation property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">User</span></strong><span class="koboSpan" id="kobo.335.1"> entity, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Comment</span></strong><span class="koboSpan" id="kobo.337.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Invoice</span></strong><span class="koboSpan" id="kobo.339.1"> also do the same. </span><span class="koboSpan" id="kobo.339.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">User</span></strong><span class="koboSpan" id="kobo.341.1"> entity does not need to have the collection navigation properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">Post</span></strong><span class="koboSpan" id="kobo.343.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Comment</span></strong><span class="koboSpan" id="kobo.345.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Invoice</span></strong><span class="koboSpan" id="kobo.347.1"> entities. </span><span class="koboSpan" id="kobo.347.2">In this case, we should configure the relationship on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">Post</span></strong><span class="koboSpan" id="kobo.349.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">Comment</span></strong><span class="koboSpan" id="kobo.351.1">, and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Invoice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.353.1"> entities.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">To configure</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.355.1"> this kind of relationship, we can ignore the parameter for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">WithMany</span></strong><span class="koboSpan" id="kobo.357.1"> method, because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">User</span></strong><span class="koboSpan" id="kobo.359.1"> entity does not have the collection navigation property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Post</span></strong><span class="koboSpan" id="kobo.361.1"> entity, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.363.1">
public void Configure(EntityTypeBuilder&lt;Post&gt; builder){
Â Â Â Â // Omitted for brevity
Â Â Â Â builder.HasOne(x =&gt; x.Author)
Â Â Â Â Â Â Â Â .WithMany()
Â Â Â Â Â Â Â Â .HasForeignKey(x =&gt; x.AuthorId);
Â Â Â Â // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.364.1">Next, let's see how we implement CRUD operations for entities with a </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">one-to-m</span><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.366.1">any relationship.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.367.1">One-to-many CRUD operations</span></h2>
<p><span class="koboSpan" id="kobo.368.1">CRUD operations</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.369.1"> for entities with</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.370.1"> a one-to-many relationship differ from those without a relationship. </span><span class="koboSpan" id="kobo.370.2">For example, when retrieving an invoice, we may need to query both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">Invoices</span></strong><span class="koboSpan" id="kobo.372.1"> table and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.374.1"> table in order to also retrieve the associated invoice items. </span><span class="koboSpan" id="kobo.374.2">Additionally, when deleting an invoice, we must consider whether to delete the related invoice items </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">EF Core can assist us in managing various scenarios. </span><span class="koboSpan" id="kobo.376.2">For instance, when we need to retrieve an invoice and its invoice items, EF Core can generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">LEFT JOIN</span></strong><span class="koboSpan" id="kobo.378.1"> query to join the two tables. </span><span class="koboSpan" id="kobo.378.2">To implement</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.379.1"> CRUD operations for entities with a one-to-many relationship, let us explore the</span><a id="_idTextAnchor253"/> <span class="No-Break"><span class="koboSpan" id="kobo.380.1">following sections.</span></span></p>
<h3><span class="koboSpan" id="kobo.381.1">Creating data</span></h3>
<p><span class="koboSpan" id="kobo.382.1">First, let </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.383.1">us create a new invoice with a few invoice items. </span><span class="koboSpan" id="kobo.383.2">You do not need to update the code of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">PostInvoice</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.385.1"> action:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.386.1">Run the application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">dotnet run</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">POST</span></strong><span class="koboSpan" id="kobo.390.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">/api/Invoices</span></strong><span class="koboSpan" id="kobo.392.1"> endpoint. </span><span class="koboSpan" id="kobo.392.2">The JSON body is </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">like this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
{Â Â "invoiceNumber": </span><span class="StringTok"><span class="koboSpan" id="kobo.395.1">"INV-004"</span></span><span class="koboSpan" id="kobo.396.1">,Â Â "contactName": </span><span class="StringTok"><span class="koboSpan" id="kobo.397.1">"Hulk"</span></span><span class="koboSpan" id="kobo.398.1">,Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.399.1">"Invoice for the first month"</span></span><span class="koboSpan" id="kobo.400.1">,Â Â "amount": 300,Â Â "invoiceDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.401.1">"2022-12-28T01:39:42.915Z"</span></span><span class="koboSpan" id="kobo.402.1">,Â Â "dueDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.403.1">"2022-12-28T01:39:42.915Z"</span></span><span class="koboSpan" id="kobo.404.1">,Â Â "status": 1,Â Â "invoiceItems": [Â Â Â Â {Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.405.1">"Invoice Item 1"</span></span><span class="koboSpan" id="kobo.406.1">,Â Â Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.407.1">""</span></span><span class="koboSpan" id="kobo.408.1">,Â Â Â Â Â Â "unitPrice": 100,Â Â Â Â Â Â "quantity": 2,Â Â Â Â Â Â "amount": 200Â Â Â Â },Â Â Â Â {Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.409.1">"Invoice Item 2"</span></span><span class="koboSpan" id="kobo.410.1">,Â Â Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.411.1">""</span></span><span class="koboSpan" id="kobo.412.1">,Â Â Â Â Â Â "unitPrice": 50,Â Â Â Â Â Â "quantity": 2,Â Â Â Â Â Â "amount": 100Â Â Â Â }Â Â ]}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.413.1">Note that it does not need to contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Id</span></strong><span class="koboSpan" id="kobo.415.1"> property for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">Invoice</span></strong><span class="koboSpan" id="kobo.417.1"> class, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Id</span></strong><span class="koboSpan" id="kobo.419.1"> property for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.421.1"> class is also not included. </span><span class="koboSpan" id="kobo.421.2">EF Core will generate </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">them automatically.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.423.1">After you</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.424.1"> send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">POST</span></strong><span class="koboSpan" id="kobo.426.1"> request, you will see an exception in </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the log:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.428.1">An unhandled exception has occurred while executing the request.System.Text.Json.JsonException: A possible object cycle was detected. </span><span class="koboSpan" id="kobo.428.2">This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 32. </span><span class="koboSpan" id="kobo.428.3">Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. </span><span class="koboSpan" id="kobo.428.4">Path: $.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.429.1">The exception is thrown because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Invoice</span></strong><span class="koboSpan" id="kobo.431.1"> class has a collection navigation property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.433.1"> class, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.435.1"> class has a reference navigation property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Invoice</span></strong><span class="koboSpan" id="kobo.437.1"> class. </span><span class="koboSpan" id="kobo.437.2">So, there is a cycle in the JSON serialization. </span><span class="koboSpan" id="kobo.437.3">Some serialization frameworks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.439.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.441.1">, do not allow such cycles. </span><span class="koboSpan" id="kobo.441.2">ASP.NET Core uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.443.1"> for JSON serialization by default. </span><span class="koboSpan" id="kobo.443.2">So, we need to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.445.1"> framework to ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">the cycle.</span></span></p></li> <li><span class="koboSpan" id="kobo.447.1">Open </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.448.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">Program.cs</span></strong><span class="koboSpan" id="kobo.450.1"> file and add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">builder.Services.AddControllers()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.454.1">
builder.ServicesÂ Â Â Â .AddControllers()Â Â Â Â .AddJsonOptions(options =&gt;Â Â Â Â {Â Â Â Â Â Â Â Â options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;Â Â Â Â });</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.455.1">Another way to fix the exception is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">[JsonIgnore]</span></strong><span class="koboSpan" id="kobo.457.1"> attribute to decorate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Invoice</span></strong><span class="koboSpan" id="kobo.459.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.461.1"> class. </span><span class="koboSpan" id="kobo.461.2">But if you have many entities with such a relationship, it is tedious to decorate all of them. </span><span class="koboSpan" id="kobo.461.3">Choose the way </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">you prefer.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.463.1">This exception occurs after data is saved to the database. </span><span class="koboSpan" id="kobo.463.2">So, if you check the database, you will find that the invoice and the invoice items are saved to </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">the database:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.465.1"><img alt="Figure 6.2 â€“ The invoice items are saved to the database with the invoice ID" src="image/B18971_06_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.466.1">Figure 6.2 â€“ The invoice items are saved to the database with the invoice ID</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.467.1">What is System.Text.Json?</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.469.1"> is a new JSON serialization framework provided since .NET Core 3.0. </span><span class="koboSpan" id="kobo.469.2">It is faster and more efficient than </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">It is also the default JSON serialization framework in ASP.NET Core 3.0 and later versions. </span><span class="koboSpan" id="kobo.471.3">It is recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.473.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">Newtonsoft.Json</span></strong><span class="koboSpan" id="kobo.475.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">new projects.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">From the </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.478.1">preceding example, you can see </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">these points:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.480.1">EF Core generates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">Id</span></strong><span class="koboSpan" id="kobo.482.1"> property of the principal entity if it is not defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">the model.</span></span></li>
<li><span class="koboSpan" id="kobo.484.1">EF Core generates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">Id</span></strong><span class="koboSpan" id="kobo.486.1"> property of the dependent entity if it is not defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">the model.</span></span></li>
<li><span class="koboSpan" id="kobo.488.1">EF Core generates a foreign key property of the dependent entity, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.490.1"> in this case, if it is not defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">the model.</span></span></li>
<li><span class="koboSpan" id="kobo.492.1">When the principal entity is added to the database, dependent entities are also added to the database automatically. </span><span class="koboSpan" id="kobo.492.2">You do not need to add dependent </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">entities explicitly.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.494.1">So, what if you want to add a new invoice item to an existing invoice? </span><span class="koboSpan" id="kobo.494.2">You can do it in </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">two ways:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.496.1">Get the invoice first, then add the new invoice item to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.498.1"> collection of the invoice, and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.500.1"> method to save the changes to the database. </span><span class="koboSpan" id="kobo.500.2">This is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">Update</span></strong><span class="koboSpan" id="kobo.502.1"> operation for the invoice, which means it should be a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">PUT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.504.1"> action.</span></span></li>
<li><span class="koboSpan" id="kobo.505.1">Create a new invoice item, set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">InvoiceId</span></strong><span class="koboSpan" id="kobo.507.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Id</span></strong><span class="koboSpan" id="kobo.509.1"> property of the invoice, and then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">SaveChanges()</span></strong><span class="koboSpan" id="kobo.511.1"> method to save the changes to the database. </span><span class="koboSpan" id="kobo.511.2">This is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">Create</span></strong><span class="koboSpan" id="kobo.513.1"> operation for the invoice item, which means it should be a </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">POST</span></strong><span class="koboSpan" id="kobo.515.1"> action. </span><span class="koboSpan" id="kobo.515.2">Also, you need to provide an endpoint for the invoice </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">item separately.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.517.1">An invoice item cannot exist without an invoice. </span><span class="koboSpan" id="kobo.517.2">So, typically, you interact with the invoice item through the invoice. </span><span class="koboSpan" id="kobo.517.3">From a practical point of view, the first way is more common if the dependent entity count is not large. </span><span class="koboSpan" id="kobo.517.4">However, it depends on your scenario. </span><span class="koboSpan" id="kobo.517.5">If the principal entity has a large number of dependent entities, updating the entire principal entity may be inefficient and expensive. </span><span class="koboSpan" id="kobo.517.6">In this case, you can expose a separate endpoint to operate the dependent entity. </span><span class="koboSpan" id="kobo.517.7">For example, one blog post </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.518.1">may have a large number of comments. </span><span class="koboSpan" id="kobo.518.2">It is common to add a new comment to a blog post, but it is not necessary to update the entire blog post and other comments. </span><span class="koboSpan" id="kobo.518.3">This is related to another concept, </span><strong class="bold"><span class="koboSpan" id="kobo.519.1">domain-driven design</span></strong><span class="koboSpan" id="kobo.520.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.521.1">DDD</span></strong><span class="koboSpan" id="kobo.522.1">), which is </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.523.1">to model domain objects and their relationships. </span><span class="koboSpan" id="kobo.523.2">We will talk ab</span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.524.1">out it in </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">later chapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.526.1">Querying data</span></h3>
<p><span class="koboSpan" id="kobo.527.1">Now we have </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.528.1">an invoice and some invoice items in the database, we can send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">GET</span></strong><span class="koboSpan" id="kobo.530.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">/api/Invoices</span></strong><span class="koboSpan" id="kobo.532.1"> endpoint. </span><span class="koboSpan" id="kobo.532.2">You can see the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">following response:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
[Â Â {
Â Â Â Â "id": </span><span class="StringTok"><span class="koboSpan" id="kobo.535.1">"a224e90a-c01c-499b-7a9b-08dae9f04218"</span></span><span class="koboSpan" id="kobo.536.1">,
Â Â Â Â "invoiceNumber": </span><span class="StringTok"><span class="koboSpan" id="kobo.537.1">"INV-004"</span></span><span class="koboSpan" id="kobo.538.1">,
Â Â Â Â "contactName": </span><span class="StringTok"><span class="koboSpan" id="kobo.539.1">"Hulk"</span></span><span class="koboSpan" id="kobo.540.1">,
Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.541.1">"Invoice for the first month"</span></span><span class="koboSpan" id="kobo.542.1">,
Â Â Â Â "amount": 300,
Â Â Â Â "invoiceDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.543.1">"2022-12-28T01:39:42.915+00:00"</span></span><span class="koboSpan" id="kobo.544.1">,
Â Â Â Â "dueDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.545.1">"2022-12-28T01:39:42.915+00:00"</span></span><span class="koboSpan" id="kobo.546.1">,
Â Â Â Â "status": 1,
Â Â Â Â "invoiceItems": []
Â Â },
Â Â ...
</span><span class="koboSpan" id="kobo.546.2">]</span></pre>
<p><span class="koboSpan" id="kobo.547.1">The response contains a list of invoices. </span><span class="koboSpan" id="kobo.547.2">But the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.549.1"> property is empty. </span><span class="koboSpan" id="kobo.549.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.551.1"> property is a collection navigation property. </span><span class="koboSpan" id="kobo.551.2">By default, EF Core does not include dependent entities in the query result, so you need to explicitly include these in the query result. </span><span class="koboSpan" id="kobo.551.3">Follow these steps to query the invoice and invoice</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.552.1"> items from </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">the database:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.554.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">InvoicesController.cs</span></strong><span class="koboSpan" id="kobo.556.1"> file, and update the code of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">GetInvoices()</span></strong><span class="koboSpan" id="kobo.558.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">to this:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.560.1">
// GET: api/Invoices[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,Â Â Â Â InvoiceStatus? </span><span class="koboSpan" id="kobo.560.2">status = null){Â Â Â Â // Omitted for brevityÂ Â Â Â return await context.InvoicesÂ Â Â Â Â Â Â Â .Include(x =&gt; x.InvoiceItems)Â Â Â Â Â Â Â Â .Where(x =&gt; status == null || x.Status == status)Â Â Â Â Â Â Â Â .OrderByDescending(x =&gt; x.InvoiceDate)Â Â Â Â Â Â Â Â .Skip((page - 1) * pageSize)Â Â Â Â Â Â Â Â .Take(pageSize)Â Â Â Â Â Â Â Â .ToListAsync();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.561.1">In the preceding code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">Include</span></strong><span class="koboSpan" id="kobo.563.1"> method to include dependent entities in the </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">query result.</span></span></p></li> <li><span class="koboSpan" id="kobo.565.1">Restart the application and send the same request again. </span><span class="koboSpan" id="kobo.565.2">Now, you will see the result includes invoice items, as </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.567.1">
[Â Â {Â Â Â Â "id": </span><span class="StringTok"><span class="koboSpan" id="kobo.568.1">"a224e90a-c01c-499b-7a9b-08dae9f04218"</span></span><span class="koboSpan" id="kobo.569.1">,Â Â Â Â "invoiceNumber": </span><span class="StringTok"><span class="koboSpan" id="kobo.570.1">"INV-004"</span></span><span class="koboSpan" id="kobo.571.1">,Â Â Â Â "contactName": </span><span class="StringTok"><span class="koboSpan" id="kobo.572.1">"Hulk"</span></span><span class="koboSpan" id="kobo.573.1">,Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.574.1">"Invoice for the first month"</span></span><span class="koboSpan" id="kobo.575.1">,Â Â Â Â "amount": 300,Â Â Â Â "invoiceDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.576.1">"2022-12-28T01:39:42.915+00:00"</span></span><span class="koboSpan" id="kobo.577.1">,Â Â Â Â "dueDate": </span><span class="StringTok"><span class="koboSpan" id="kobo.578.1">"2022-12-28T01:39:42.915+00:00"</span></span><span class="koboSpan" id="kobo.579.1">,Â Â Â Â "status": 1,Â Â Â Â "invoiceItems": [Â Â Â Â Â Â {Â Â Â Â Â Â Â Â "id": </span><span class="StringTok"><span class="koboSpan" id="kobo.580.1">"8cc52722-5b99-4d0c-07ef-08dae9f04223"</span></span><span class="koboSpan" id="kobo.581.1">,Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.582.1">"Invoice Item 1"</span></span><span class="koboSpan" id="kobo.583.1">,Â Â Â Â Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.584.1">""</span></span><span class="koboSpan" id="kobo.585.1">,Â Â Â Â Â Â Â Â "unitPrice": 100,Â Â Â Â Â Â Â Â "quantity": 2,Â Â Â Â Â Â Â Â "amount": 200,Â Â Â Â Â Â Â Â "invoiceId": </span><span class="StringTok"><span class="koboSpan" id="kobo.586.1">"a224e90a-c01c-499b-7a9b-08dae9f04218"</span></span><span class="koboSpan" id="kobo.587.1">,Â Â Â Â Â Â Â Â "invoice": nullÂ Â Â Â Â Â },Â Â Â Â Â Â {Â Â Â Â Â Â Â Â "id": </span><span class="StringTok"><span class="koboSpan" id="kobo.588.1">"2d3f739a-2280-424b-07f0-08dae9f04223"</span></span><span class="koboSpan" id="kobo.589.1">,Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.590.1">"Invoice Item 2"</span></span><span class="koboSpan" id="kobo.591.1">,Â Â Â Â Â Â Â Â "description": </span><span class="StringTok"><span class="koboSpan" id="kobo.592.1">""</span></span><span class="koboSpan" id="kobo.593.1">,Â Â Â Â Â Â Â Â "unitPrice": 50,Â Â Â Â Â Â Â Â "quantity": 2,Â Â Â Â Â Â Â Â "amount": 100,Â Â Â Â Â Â Â Â "invoiceId": </span><span class="StringTok"><span class="koboSpan" id="kobo.594.1">"a224e90a-c01c-499b-7a9b-08dae9f04218"</span></span><span class="koboSpan" id="kobo.595.1">,Â Â Â Â Â Â Â Â "invoice": nullÂ Â Â Â Â Â }Â Â Â Â ]Â Â },Â Â ...]</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.596.1">In the response, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Invoice</span></strong><span class="koboSpan" id="kobo.598.1"> property of the invoice item is </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">null</span></strong><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">It is not required to include the principal entity in the dependent entity. </span><span class="koboSpan" id="kobo.600.3">As we explained in the previous section, this is a cyclic reference. </span><span class="koboSpan" id="kobo.600.4">If you do not want to</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.601.1"> include a </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">null</span></strong><span class="koboSpan" id="kobo.603.1"> value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">Invoice</span></strong><span class="koboSpan" id="kobo.605.1"> property in the response, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">[JsonIgnore]</span></strong><span class="koboSpan" id="kobo.607.1"> attribute to decorate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Invoice</span></strong><span class="koboSpan" id="kobo.609.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.611.1"> model so that </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">System.Text.Json</span></strong><span class="koboSpan" id="kobo.613.1"> will not serialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Invoice</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.615.1">property anymore.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.616.1">The generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.618.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â Executed DbCommand (35ms) [Parameters=[@__p_0=</span><span class="StringTok"><span class="koboSpan" id="kobo.619.1">'?'</span></span><span class="koboSpan" id="kobo.620.1"> (DbType = Int32), @__p_1=</span><span class="StringTok"><span class="koboSpan" id="kobo.621.1">'?'</span></span><span class="koboSpan" id="kobo.622.1"> (DbType = Int32)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.623.1">'Text'</span></span><span class="koboSpan" id="kobo.624.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.625.1">'30'</span></span><span class="koboSpan" id="kobo.626.1">]Â Â Â Â Â Â SELECT [t].[Id], [t].[Amount], [t].[ContactName], [t].[Description], [t].[DueDate], [t].[InvoiceDate], [t].[InvoiceNumber], [t].[Status], [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice]Â Â Â Â Â Â FROM (Â Â Â Â Â Â Â Â Â Â SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]Â Â Â Â Â Â Â Â Â Â FROM [Invoices] AS [i]Â Â Â Â Â Â Â Â Â Â ORDER BY [i].[InvoiceDate] DESCÂ Â Â Â Â Â Â Â Â Â OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLYÂ Â Â Â Â Â ) AS [t]Â Â Â Â Â Â LEFT JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]Â Â Â Â Â Â ORDER BY [t].[InvoiceDate] DESC, [t].[Id]</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.627.1">As you see, when the LINQ query uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">Include()</span></strong><span class="koboSpan" id="kobo.629.1"> method to include dependent entities, EF Core will generate a </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">LEFT </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">JOIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1"> query.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.633.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.634.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Include()</span></strong><span class="koboSpan" id="kobo.636.1"> method is a convenient way to include dependent entities. </span><span class="koboSpan" id="kobo.636.2">However, it may cause performance issues when the collection of dependent entities is large. </span><span class="koboSpan" id="kobo.636.3">For example, a post may have hundreds or thousands of comments. </span><span class="koboSpan" id="kobo.636.4">It is not a good idea to include all comments in the query result for a list page. </span><span class="koboSpan" id="kobo.636.5">In this case, it is not necessary to include dependent entities in </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">the query.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.638.1">Note </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.639.1">that the query includes </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">Invoice</span></strong><span class="koboSpan" id="kobo.641.1"> data in each row of the result. </span><span class="koboSpan" id="kobo.641.2">For some scenarios, it may cause a </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.642.1">so-called </span><strong class="bold"><span class="koboSpan" id="kobo.643.1">Cartesian explosion</span></strong><span class="koboSpan" id="kobo.644.1"> problem, which means the amount of duplicated data in the result is too large and may cause performance issues. </span><span class="koboSpan" id="kobo.644.2">In this case, we can split the queries into two steps. </span><span class="koboSpan" id="kobo.644.3">First, we query the invoices, and then we query the invoice items. </span><span class="koboSpan" id="kobo.644.4">You need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">AsSplitQuery()</span></strong><span class="koboSpan" id="kobo.646.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.648.1">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,Â Â Â Â InvoiceStatus? </span><span class="koboSpan" id="kobo.648.2">status = null){Â Â Â Â // Omitted for brevityÂ Â Â Â return await context.InvoicesÂ Â Â Â Â Â Â Â .Include(x =&gt; x.InvoiceItems)Â Â Â Â Â Â Â Â .Where(x =&gt; status == null || x.Status == status)Â Â Â Â Â Â Â Â .OrderByDescending(x =&gt; x.InvoiceDate)Â Â Â Â Â Â Â Â .Skip((page - 1) * pageSize)Â Â Â Â Â Â Â Â .Take(pageSize)Â Â Â Â Â Â Â Â .AsSplitQuery()Â Â Â Â Â Â Â Â .ToListAsync();}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.649.1">The </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.650.1">generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.652.1">info: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â FROM (Â Â Â Â Â Â Â Â Â Â SELECT [i].[Id], [i].[InvoiceDate]Â Â Â Â Â Â Executed DbCommand (2ms) [Parameters=[@__p_0=</span><span class="StringTok"><span class="koboSpan" id="kobo.653.1">'?'</span></span><span class="koboSpan" id="kobo.654.1"> (DbType = Int32), @__p_1=</span><span class="StringTok"><span class="koboSpan" id="kobo.655.1">'?'</span></span><span class="koboSpan" id="kobo.656.1"> (DbType = Int32)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.657.1">'Text'</span></span><span class="koboSpan" id="kobo.658.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.659.1">'30'</span></span><span class="koboSpan" id="kobo.660.1">]Â Â Â Â Â Â SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]Â Â Â Â Â Â FROM [Invoices] AS [i]Â Â Â Â Â Â ORDER BY [i].[InvoiceDate] DESC, [i].[Id]Â Â Â Â Â Â OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLYinfo: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â Executed DbCommand (2ms) [Parameters=[@__p_0=</span><span class="StringTok"><span class="koboSpan" id="kobo.661.1">'?'</span></span><span class="koboSpan" id="kobo.662.1"> (DbType = Int32), @__p_1=</span><span class="StringTok"><span class="koboSpan" id="kobo.663.1">'?'</span></span><span class="koboSpan" id="kobo.664.1"> (DbType = Int32)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.665.1">'Text'</span></span><span class="koboSpan" id="kobo.666.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.667.1">'30'</span></span><span class="koboSpan" id="kobo.668.1">]Â Â Â Â Â Â SELECT [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice], [t].[Id]Â Â Â Â Â Â FROM (Â Â Â Â Â Â Â Â Â Â SELECT [i].[Id], [i].[InvoiceDate]Â Â Â Â Â Â Â Â Â Â FROM [Invoices] AS [i]Â Â Â Â Â Â Â Â Â Â ORDER BY [i].[InvoiceDate] DESCÂ Â Â Â Â Â Â Â Â Â OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLYÂ Â Â Â Â Â ) AS [t]Â Â Â Â Â Â INNER JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]Â Â Â Â Â Â ORDER BY [t].[InvoiceDate] DESC, [t].[Id]</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.669.1">The query contains two </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">SELECT</span></strong><span class="koboSpan" id="kobo.671.1"> statements. </span><span class="koboSpan" id="kobo.671.2">The first </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">SELECT</span></strong><span class="koboSpan" id="kobo.673.1"> statement is used to query the invoices. </span><span class="koboSpan" id="kobo.673.2">The second </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">SELECT</span></strong><span class="koboSpan" id="kobo.675.1"> statement is used to query the invoice items. </span><span class="koboSpan" id="kobo.675.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">INNER JOIN</span></strong><span class="koboSpan" id="kobo.677.1"> query is used to join the </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">two queries.</span></span></p></li> <li><span class="koboSpan" id="kobo.679.1">You can</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.680.1"> also configure the default query-splitting behavior globally by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">UseQuerySplittingBehavior()</span></strong><span class="koboSpan" id="kobo.682.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">OnConfiguring()</span></strong><span class="koboSpan" id="kobo.684.1"> method of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">DbContext</span></strong><span class="koboSpan" id="kobo.686.1"> class. </span><span class="koboSpan" id="kobo.686.2">The following code shows how to configure the default query splitting behavior to </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">SplitQuery</span></strong><span class="koboSpan" id="kobo.688.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">SampleDbContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.690.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.691.1">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder){Â Â Â Â base.OnConfiguring(optionsBuilder);Â Â Â Â optionsBuilder.UseSqlServer(_configuration.GetConnectionString(</span><span class="StringTok"><span class="koboSpan" id="kobo.692.1">"DefaultConnection"</span></span><span class="koboSpan" id="kobo.693.1">),Â Â Â Â Â Â Â Â b =&gt; b.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.694.1">In this case, you</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.695.1"> donâ€™t need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1"> AsSplitQuery()</span></strong><span class="koboSpan" id="kobo.697.1"> method in your LINQ queries. </span><span class="koboSpan" id="kobo.697.2">If you want to execute a specific query in a single query, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">AsSingleQuery()</span></strong><span class="koboSpan" id="kobo.699.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">like this:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.701.1">[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,Â Â Â Â InvoiceStatus? </span><span class="koboSpan" id="kobo.701.2">status = null){Â Â Â Â // Omitted for brevityÂ Â Â Â return await _context.InvoicesÂ Â Â Â Â Â Â Â .Include(x =&gt; x.InvoiceItems)Â Â Â Â Â Â Â Â .Where(x =&gt; status == null || x.Status == status)Â Â Â Â Â Â Â Â .OrderByDescending(x =&gt; x.InvoiceDate)Â Â Â Â Â Â Â Â .Skip((page - 1) * pageSize)Â Â Â Â Â Â Â Â .Take(pageSize)Â Â Â Â Â Â Â Â .AsSingleQuery()Â Â Â Â Â Â Â Â .ToListAsync();}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.702.1">However, split queries may cause other issues. </span><span class="koboSpan" id="kobo.702.2">For example, multiple queries increase the number of round trips to the database. </span><span class="koboSpan" id="kobo.702.3">In addition, if another thread modifies the </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.703.1">data between the two queries, the result may be inconsistent. </span><span class="koboSpan" id="kobo.703.2">Therefore, you should consider the pros and cons of sp</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.704.1">lit queries to fit </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">your scenarios.</span></span></p>
<h3><span class="koboSpan" id="kobo.706.1">Retrieving data</span></h3>
<p><span class="koboSpan" id="kobo.707.1">Next, let's</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.708.1"> see how to retrieve data by ID. </span><span class="koboSpan" id="kobo.708.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">GetInvoice</span></strong><span class="koboSpan" id="kobo.710.1"> action, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">await _context.Invoices.FindAsync(id)</span></strong><span class="koboSpan" id="kobo.712.1"> to find the invoice by its ID. </span><span class="koboSpan" id="kobo.712.2">Send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Get</span></strong><span class="koboSpan" id="kobo.714.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">/api/Invoices/{id}</span></strong><span class="koboSpan" id="kobo.716.1"> endpoint with a valid ID. </span><span class="koboSpan" id="kobo.716.2">You will see the response contains an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.718.1"> array. </span><span class="koboSpan" id="kobo.718.2">This is because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.720.1"> property is not included in the query. </span><span class="koboSpan" id="kobo.720.2">To include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.722.1"> property in the query, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">Include</span></strong><span class="koboSpan" id="kobo.724.1"> method in the LINQ query. </span><span class="koboSpan" id="kobo.724.2">The following code shows how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">Include</span></strong><span class="koboSpan" id="kobo.726.1"> method to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">InvoiceItems</span></strong><span class="koboSpan" id="kobo.728.1"> property in </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">the query:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.730.1">
[HttpGet(</span><span class="StringTok"><span class="koboSpan" id="kobo.731.1">"{id}"</span></span><span class="koboSpan" id="kobo.732.1">)]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(int id)
{
Â Â Â Â var invoice = await context.Invoices
Â Â Â Â Â Â Â Â .Include(x =&gt; x.InvoiceItems)
Â Â Â Â Â Â Â Â .SingleOrDefaultAsync(x =&gt; x.Id == id);
Â Â Â Â if (invoice == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound();
Â Â Â Â }
Â Â Â Â return invoice;
}</span></pre>
<p><span class="koboSpan" id="kobo.733.1">The generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.735.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â Executed DbCommand (4ms) [Parameters=[@__id_0=</span><span class="StringTok"><span class="koboSpan" id="kobo.736.1">'?'</span></span><span class="koboSpan" id="kobo.737.1"> (DbType = Guid)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.738.1">'Text'</span></span><span class="koboSpan" id="kobo.739.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.740.1">'30'</span></span><span class="koboSpan" id="kobo.741.1">]
Â Â Â Â Â Â SELECT [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice], [t].[Id]
Â Â Â Â Â Â FROM (
Â Â Â Â Â Â Â Â Â Â SELECT TOP(1) [i].[Id]
Â Â Â Â Â Â Â Â Â Â FROM [Invoices] AS [i]
Â Â Â Â Â Â Â Â Â Â WHERE [i].[Id] = @__id_0
Â Â Â Â Â Â ) AS [t]
Â Â Â Â Â Â INNER JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]
Â Â Â Â Â Â ORDER BY [t].[Id]</span></pre>
<p><span class="koboSpan" id="kobo.742.1">The query </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.743.1">contains two </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">SELECT</span></strong><span class="koboSpan" id="kobo.745.1"> statements, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">INNER JOIN</span></strong><span class="koboSpan" id="kobo.747.1"> query is used to join the two statements. </span><span class="koboSpan" id="kobo.747.2">In this way, you can retrieve the invoice </span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.748.1">and invoice items in a </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">single query.</span></span></p>
<h3><span class="koboSpan" id="kobo.750.1">Deleting data</span></h3>
<p><span class="koboSpan" id="kobo.751.1">In the </span><em class="italic"><span class="koboSpan" id="kobo.752.1">One-to-many configuration</span></em><span class="koboSpan" id="kobo.753.1"> section, we introduced how to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">OnDelete</span></strong><span class="koboSpan" id="kobo.755.1"> action to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.757.1"> enum to </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">Cascade</span></strong><span class="koboSpan" id="kobo.759.1">. </span><span class="koboSpan" id="kobo.759.2">There are other options for</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.760.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.762.1"> enum. </span><span class="koboSpan" id="kobo.762.2">Think about the following scenario in a </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">one-to-many relationship:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.764.1">An invoice has a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">invoice items</span></span></li>
<li><span class="koboSpan" id="kobo.766.1">A user deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">an invoice</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.768.1">In this case, you may want to delete the related invoice items when the invoice is deleted because an invoice item cannot exist without an invoice. </span><span class="koboSpan" id="kobo.768.2">This behavior is called </span><strong class="bold"><span class="koboSpan" id="kobo.769.1">cascade delete</span></strong><span class="koboSpan" id="kobo.770.1">. </span><span class="koboSpan" id="kobo.770.2">To</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.771.1"> delete the data, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.773.1">Run the application and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">Delete</span></strong><span class="koboSpan" id="kobo.775.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">/api/Invoices/{id}</span></strong><span class="koboSpan" id="kobo.777.1"> endpoint with a valid ID. </span><span class="koboSpan" id="kobo.777.2">You will see the invoice and the related invoice items are deleted from the database. </span><span class="koboSpan" id="kobo.777.3">Note that if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">OnDelete()</span></strong><span class="koboSpan" id="kobo.779.1"> method is configured as </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">Cascade</span></strong><span class="koboSpan" id="kobo.781.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">ClientCascade</span></strong><span class="koboSpan" id="kobo.783.1">, loading related entities using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">Include()</span></strong><span class="koboSpan" id="kobo.785.1"> method in the LINQ query is not required. </span><span class="koboSpan" id="kobo.785.2">The</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.786.1"> cascade delete behavior is applied at the database level. </span><span class="koboSpan" id="kobo.786.2">You can see the generated SQL query, which just deletes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">Invoice</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.788.1">entity, here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â Executed DbCommand (9ms) [Parameters=[@__id_0=</span><span class="StringTok"><span class="koboSpan" id="kobo.790.1">'?'</span></span><span class="koboSpan" id="kobo.791.1"> (DbType = Guid)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.792.1">'Text'</span></span><span class="koboSpan" id="kobo.793.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.794.1">'30'</span></span><span class="koboSpan" id="kobo.795.1">]Â Â Â Â Â Â DELETE FROM [i]Â Â Â Â Â Â FROM [Invoices] AS [i]Â Â Â Â Â Â WHERE [i].[Id] = @__id_0</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.796.1">However, in some scenarios, you may want to keep dependent entities when the principal entity is deleted, </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">for example:</span></span></p><ul><li><span class="koboSpan" id="kobo.798.1">A category has a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">blog posts</span></span></li><li><span class="koboSpan" id="kobo.800.1">A user deletes </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">a category</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.802.1">It is not necessary to delete blog posts when a category is deleted, because the blog posts can still exist without a category and can be assigned to another category. </span><span class="koboSpan" id="kobo.802.2">However, if a category is deleted, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">CategoryId</span></strong><span class="koboSpan" id="kobo.804.1"> property of a blog post, which is a foreign key, will no longer match the primary key of any category. </span><span class="koboSpan" id="kobo.804.2">Therefore, you may want to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">CategoryId</span></strong><span class="koboSpan" id="kobo.806.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">null</span></strong><span class="koboSpan" id="kobo.808.1"> when a category is deleted. </span><span class="koboSpan" id="kobo.808.2">This behavior is called </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">nullification</span></strong><span class="koboSpan" id="kobo.810.1">. </span><span class="koboSpan" id="kobo.810.2">To </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.811.1">allow this, the requirement is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">CategoryId</span></strong><span class="koboSpan" id="kobo.813.1"> property is nullable. </span><span class="koboSpan" id="kobo.813.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">CategoryId</span></strong><span class="koboSpan" id="kobo.815.1"> property of a blog post entity is not nullable, EF Core will throw an exception when you try to delete a category because it will violate the foreign </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">key constraint.</span></span></p></li> <li><span class="koboSpan" id="kobo.817.1">In the sample code, there is an example of this case. </span><span class="koboSpan" id="kobo.817.2">You can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">Category</span></strong><span class="koboSpan" id="kobo.819.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">Post</span></strong><span class="koboSpan" id="kobo.821.1"> classes in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">Models</span></strong><span class="koboSpan" id="kobo.823.1"> folder. </span><span class="koboSpan" id="kobo.823.2">Similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">Invoice</span></strong><span class="koboSpan" id="kobo.825.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.827.1"> classes, they have a one-to-many relationship. </span><span class="koboSpan" id="kobo.827.2">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">CategoryId</span></strong><span class="koboSpan" id="kobo.829.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">Post</span></strong><span class="koboSpan" id="kobo.831.1"> class is nullable. </span><span class="koboSpan" id="kobo.831.2">Therefore, you can set </span><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.833.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">ClientSetNull</span></strong><span class="koboSpan" id="kobo.835.1"> to nullify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">CategoryId</span></strong><span class="koboSpan" id="kobo.837.1"> property when a category </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">is deleted.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.839.1">The following </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.840.1">code shows how to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">DeleteBehavior</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.842.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">ClientSetNull</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.845.1">
public class PostConfiguration : IEntityTypeConfiguration&lt;Post&gt;{Â Â Â Â public void Configure(EntityTypeBuilder&lt;Post&gt; builder)Â Â Â Â {Â Â Â Â Â Â Â Â builder.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.846.1">"Posts"</span></span><span class="koboSpan" id="kobo.847.1">);Â Â Â Â Â Â Â Â // Omitted for brevityÂ Â Â Â Â Â Â Â builder.Property(p =&gt; p.CategoryId).HasColumnName(</span><span class="StringTok"><span class="koboSpan" id="kobo.848.1">"CategoryId"</span></span><span class="koboSpan" id="kobo.849.1">);Â Â Â Â Â Â Â Â builder.HasOne(p =&gt; p.Category)Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(c =&gt; c.Posts)Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey(p =&gt; p.CategoryId)Â Â Â Â Â Â Â Â Â Â Â Â .OnDelete(DeleteBehavior.ClientSetNull);Â Â Â Â }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.850.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">OnDelete()</span></strong><span class="koboSpan" id="kobo.852.1"> method, you can pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.854.1"> enum to set </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.856.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">ClientSetNull</span></strong><span class="koboSpan" id="kobo.858.1">. </span><span class="koboSpan" id="kobo.858.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">ClientSetNull</span></strong><span class="koboSpan" id="kobo.860.1"> value means that the foreign key property will be set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">null</span></strong><span class="koboSpan" id="kobo.862.1"> when the principal entity </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">is deleted.</span></span></p></li> <li><span class="koboSpan" id="kobo.864.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">CategoriesController</span></strong><span class="koboSpan" id="kobo.866.1"> class, you can find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">DeleteCategory()</span></strong><span class="koboSpan" id="kobo.868.1"> method. </span><span class="koboSpan" id="kobo.868.2">It is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">DeleteInvoice()</span></strong><span class="koboSpan" id="kobo.870.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">InvoicesController</span></strong><span class="koboSpan" id="kobo.872.1"> class. </span><span class="koboSpan" id="kobo.872.2">The only difference is that we need to remove the relationship between the category and the blog posts before deleting the category. </span><span class="koboSpan" id="kobo.872.3">The following code shows how to remove the relationship between the category and the </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">blog posts:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.874.1">
var category = await context.Categories.Include(x =&gt; x.Posts).SingleOrDefaultAsync(x =&gt; x.Id == id);if (category == null){Â Â Â Â return NotFound();}category.Posts.Clear();// Or you can update the posts to set the category to null// foreach (var post in category.Posts)// {//Â Â Â Â Â post.Category = null;// }context.Categories.Remove(category);await context.SaveChangesAsync();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.875.1">You </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.876.1">can clear the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">Posts</span></strong><span class="koboSpan" id="kobo.878.1"> property of the category entity, or you can update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">Category</span></strong><span class="koboSpan" id="kobo.880.1"> property of the blog posts to set it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">null</span></strong><span class="koboSpan" id="kobo.882.1">. </span><span class="koboSpan" id="kobo.882.2">In this way, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">CategoryId</span></strong><span class="koboSpan" id="kobo.884.1"> property of the blog posts will be set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">null</span></strong><span class="koboSpan" id="kobo.886.1"> when the category is deleted. </span><span class="koboSpan" id="kobo.886.2">Also, it is required to load related entities using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Include</span></strong><span class="koboSpan" id="kobo.888.1"> method, because EF Core needs to track the changes of related entities </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">as well.</span></span></p></li> <li><span class="koboSpan" id="kobo.890.1">Run the application and send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">Delete</span></strong><span class="koboSpan" id="kobo.892.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">/api/Categories/{id}</span></strong><span class="koboSpan" id="kobo.894.1"> endpoint with a valid ID. </span><span class="koboSpan" id="kobo.894.2">Check the database, and you will see the category is deleted, but the blog posts are not deleted. </span><span class="koboSpan" id="kobo.894.3">Instead, the </span><strong class="bold"><span class="koboSpan" id="kobo.895.1">CategoryId</span></strong><span class="koboSpan" id="kobo.896.1"> property of the blog posts is set </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.898.1">NULL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.900.1"><img alt="Figure 6.3 â€“ The CategoryId property of the blog posts is set to NULL when the category is deleted" src="image/B18971_06_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.901.1">Figure 6.3 â€“ The CategoryId property of the blog posts is set to NULL when the category is deleted</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.902.1">Check </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.903.1">the generated SQL query, and you will see that EF Core executes two SQL queries. </span><span class="koboSpan" id="kobo.903.2">The first query is to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">CategoryId</span></strong><span class="koboSpan" id="kobo.905.1"> property of the blog posts to </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">null</span></strong><span class="koboSpan" id="kobo.907.1">. </span><span class="koboSpan" id="kobo.907.2">The second query is to delete the category. </span><span class="koboSpan" id="kobo.907.3">The generated SQL query is </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.909.1">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]Â Â Â Â Â Â Executed DbCommand (6ms) [Parameters=[@p1=</span><span class="StringTok"><span class="koboSpan" id="kobo.910.1">'?'</span></span><span class="koboSpan" id="kobo.911.1"> (DbType = Guid), @p0=</span><span class="StringTok"><span class="koboSpan" id="kobo.912.1">'?'</span></span><span class="koboSpan" id="kobo.913.1"> (DbType = Guid), @p2=</span><span class="StringTok"><span class="koboSpan" id="kobo.914.1">'?'</span></span><span class="koboSpan" id="kobo.915.1"> (DbType = Guid)], CommandType=</span><span class="StringTok"><span class="koboSpan" id="kobo.916.1">'Text'</span></span><span class="koboSpan" id="kobo.917.1">, CommandTimeout=</span><span class="StringTok"><span class="koboSpan" id="kobo.918.1">'30'</span></span><span class="koboSpan" id="kobo.919.1">]Â Â Â Â Â Â SET NOCOUNT ON;Â Â Â Â Â Â UPDATE [Posts] SET [CategoryId] = @p0Â Â Â Â Â Â OUTPUT 1Â Â Â Â Â Â WHERE [Id] = @p1;Â Â Â Â Â Â DELETE FROM [Categories]Â Â Â Â Â Â OUTPUT 1Â Â Â Â Â Â WHERE [Id] = @p2;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.920.1">That says the posts now have no category, which means the relationship between the category and the blog posts is removed. </span><span class="koboSpan" id="kobo.920.2">You can assign the blog posts to another category to recreate the relationship following your </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">business logic.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.922.1">It is important </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.923.1">to understand the consequences of deleting an entity when it has relationships. </span><span class="koboSpan" id="kobo.923.2">Keep in mind that some databases may not support cascading deletes. </span><span class="koboSpan" id="kobo.923.3">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">DeleteBehavior</span></strong><span class="koboSpan" id="kobo.925.1"> enum contains quite a few values to allow you to fine-tune the behavior when deleting an entity. </span><span class="koboSpan" id="kobo.925.2">Generally, it is recommended to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">ClientCascade</span></strong><span class="koboSpan" id="kobo.927.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">ClientSetNull</span></strong><span class="koboSpan" id="kobo.929.1"> because EF Core can perform cascading deletes or nullification if the database does not support </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">cascading deletes.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">So far, we have learned how to configure a one-to-many relationship and how to implement CRUD operations for entities with a one-to-many relationship. </span><span class="koboSpan" id="kobo.931.2">Next, let's move on to another type </span><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.932.1">of relationship: a </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">one-to-one relationship.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.934.1">Understanding one-to-one relationships</span></h1>
<p><span class="koboSpan" id="kobo.935.1">A one-to-one relationship</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.936.1"> means that one entity has a relationship with only one entity of another type. </span><span class="koboSpan" id="kobo.936.2">For example, a bicycle requires one lock, which can only be used for that particular bicycle. </span><span class="koboSpan" id="kobo.936.3">Similarly, a person is only allowed to possess one driverâ€™s license, which is designated for their use only. </span><span class="koboSpan" id="kobo.936.4">In our sample code, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">Contact</span></strong><span class="koboSpan" id="kobo.938.1"> entity has only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">Address</span></strong><span class="koboSpan" id="kobo.940.1"> entity, and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.941.1">Address</span></strong><span class="koboSpan" id="kobo.942.1"> entity belongs to only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">Contact</span></strong><span class="koboSpan" id="kobo.944.1"> entity. </span><span class="koboSpan" id="kobo.944.2">In the previous section, you learned how to configure a one-to-many relationship using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">HasOne()/WithMany()</span></strong><span class="koboSpan" id="kobo.946.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">HasMany()/WithOne()</span></strong><span class="koboSpan" id="kobo.948.1"> methods. </span><span class="koboSpan" id="kobo.948.2">In this section, you will learn how to configure a one-to-one relati</span><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.949.1">onship using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">HasOne()</span></strong><span class="koboSpan" id="kobo.951.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">WithOne()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> methods.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.954.1">One-to-one configuration</span></h2>
<p><span class="koboSpan" id="kobo.955.1">In a</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.956.1"> one-to-one relationship, both sides have a reference navigation property. </span><span class="koboSpan" id="kobo.956.2">Technically, both sides have equal positions. </span><span class="koboSpan" id="kobo.956.3">However, to explicitly configure the relationship, we need to specify which side is the dependent side and which side is the principal side. </span><span class="koboSpan" id="kobo.956.4">The foreign key property is normally defined on the dependent side. </span><span class="koboSpan" id="kobo.956.5">In the following example, we will configure a one-to-one relationship between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">Contact</span></strong><span class="koboSpan" id="kobo.958.1"> class and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">Address</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.960.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.961.1">
public class Contact{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â public string FirstName { get; set; } = string.Empty;
Â Â Â Â public string LastName { get; set; } = string.Empty;
Â Â Â Â public string? </span><span class="koboSpan" id="kobo.961.2">Title { get; set; }
Â Â Â Â public string Email { get; set; } = string.Empty;
Â Â Â Â public string Phone { get; set; } = string.Empty;
Â Â Â Â public Address Address { get; set; }
}
public class Address
{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â public string Street { get; set; } = string.Empty;
Â Â Â Â public string City { get; set; } = string.Empty;
Â Â Â Â public string State { get; set; } = string.Empty;
Â Â Â Â public string ZipCode { get; set; } = string.Empty;
Â Â Â Â public string Country { get; set; } = string.Empty;
Â Â Â Â public Guid ContactId { get; set; }
Â Â Â Â public Contact Contact { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.962.1">In the </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.963.1">preceding code, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">ContactId</span></strong><span class="koboSpan" id="kobo.965.1"> foreign key is defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">Address</span></strong><span class="koboSpan" id="kobo.967.1"> class, which implies that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">Address</span></strong><span class="koboSpan" id="kobo.969.1"> class is the dependent entity, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">Contact</span></strong><span class="koboSpan" id="kobo.971.1"> class is the principal entity. </span><span class="koboSpan" id="kobo.971.2">If you do not define a foreign key property here, EF Core will automatically choose one of the entities to be the dependent entity. </span><span class="koboSpan" id="kobo.971.3">However, because </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">Contact</span></strong><span class="koboSpan" id="kobo.973.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">Address</span></strong><span class="koboSpan" id="kobo.975.1"> are equal in a one-to-one relationship, EF Core may not choose the correct </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.976.1">entity as we expect. </span><span class="koboSpan" id="kobo.976.2">So, we need to explicitly define a foreign key property in the </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">dependent entity.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">The configuration of a one-to-one relationship is </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.980.1">
public class ContactConfiguration : IEntityTypeConfiguration&lt;Contact&gt;{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;Contact&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.981.1">"Contacts"</span></span><span class="koboSpan" id="kobo.982.1">);
Â Â Â Â Â Â Â Â builder.HasKey(c =&gt; c.Id);
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â builder.Property(c =&gt; c.Phone).IsRequired();
Â Â Â Â }
}
public class AddressConfiguration : IEntityTypeConfiguration&lt;Address&gt;
{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;Address&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.983.1">"Addresses"</span></span><span class="koboSpan" id="kobo.984.1">);
Â Â Â Â Â Â Â Â builder.HasKey(a =&gt; a.Id);
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â builder.Ignore(a =&gt; a.Contact);
Â Â Â Â Â Â Â Â builder.HasOne(a =&gt; a.Contact)
Â Â Â Â Â Â Â Â Â Â Â Â .WithOne(c =&gt; c.Address)
Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey&lt;Address&gt;(a =&gt; a.ContactId);
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.985.1">The </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.986.1">preceding code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">HasOne</span></strong><span class="koboSpan" id="kobo.988.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">WithOne</span></strong><span class="koboSpan" id="kobo.990.1"> to define the one-to-one relationship. </span><span class="koboSpan" id="kobo.990.2">This can be defined in either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">Contact</span></strong><span class="koboSpan" id="kobo.992.1"> configuration or </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">Address</span></strong><span class="koboSpan" id="kobo.994.1"> configuration. </span><span class="koboSpan" id="kobo.994.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">HasForeignKey</span></strong><span class="koboSpan" id="kobo.996.1"> method is used to specify the foreign key property. </span><span class="koboSpan" id="kobo.996.2">If you want to define the relationship in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">Contact</span></strong><span class="koboSpan" id="kobo.998.1"> configuration, the code may look </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
builder.HasOne(c =&gt; c.Address)Â Â Â Â .WithOne(a =&gt; a.Contact)
Â Â Â Â .HasForeignKey&lt;Address&gt;(a =&gt; a.ContactId);</span></pre>
<p><span class="koboSpan" id="kobo.1001.1">Run the following code to add the migration and update </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">the database:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1003.1">
dotnet ef migrations add AddContactAndAddressdotnet ef database update</span></pre>
<p><span class="koboSpan" id="kobo.1004.1">You will see the following code creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">ContactId</span></strong><span class="koboSpan" id="kobo.1006.1"> foreign key on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">Addresses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1"> table:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
migrationBuilder.CreateTable(Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1010.1">"Addresses"</span></span><span class="koboSpan" id="kobo.1011.1">,
Â Â Â Â columns: table =&gt; new
Â Â Â Â {
Â Â Â Â Â Â Â Â Id = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1012.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.1013.1">, nullable: false),
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â },
Â Â Â Â constraints: table =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â table.PrimaryKey(</span><span class="StringTok"><span class="koboSpan" id="kobo.1014.1">"PK_Addresses"</span></span><span class="koboSpan" id="kobo.1015.1">, x =&gt; x.Id);
Â Â Â Â Â Â Â Â table.ForeignKey(
Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1016.1">"FK_Addresses_Contacts_ContactId"</span></span><span class="koboSpan" id="kobo.1017.1">,
Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.ContactId,
Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.1018.1">"Contacts"</span></span><span class="koboSpan" id="kobo.1019.1">,
Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.1020.1">"Id"</span></span><span class="koboSpan" id="kobo.1021.1">,
Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);
Â Â Â Â });</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">After the </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.1023.1">migration is applied, the relationship between </span><strong class="bold"><span class="koboSpan" id="kobo.1024.1">Contacts</span></strong><span class="koboSpan" id="kobo.1025.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.1026.1">Addresses</span></strong><span class="koboSpan" id="kobo.1027.1"> is configured successfully, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1028.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1029.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.1031.1"><img alt="Figure 6.4 â€“ A ContactId foreign key is created on the Addresses table" src="image/B18971_06_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1032.1">Figure 6.4 â€“ A ContactId foreign key is created on the Addresses table</span></p>
<p><span class="koboSpan" id="kobo.1033.1">Next, let's see how to implement CRUD operati</span><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.1034.1">ons for entities with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">one-to-one relationship.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.1036.1">One-to-one CRUD operations</span></h2>
<p><span class="koboSpan" id="kobo.1037.1">The CRUD operations </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.1038.1">of a one-to-one relationship </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1039.1">are similar to those of a one-to-many relationship. </span><span class="koboSpan" id="kobo.1039.2">EF Core can simplify CRUD operations for you. </span><span class="koboSpan" id="kobo.1039.3">So, in this section, we will not explain all CRUD operations in detail. </span><span class="koboSpan" id="kobo.1039.4">You will find a controller named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">ContactsController.cs</span></strong><span class="koboSpan" id="kobo.1041.1"> in the sample repo, which implements CRUD operations for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">Contact</span></strong><span class="koboSpan" id="kobo.1043.1"> entity. </span><span class="koboSpan" id="kobo.1043.2">You can check the code for </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">the details.</span></span></p>
<p><span class="koboSpan" id="kobo.1045.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">Contact</span></strong><span class="koboSpan" id="kobo.1047.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">Address</span></strong><span class="koboSpan" id="kobo.1049.1"> entities </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1050.1">have a one-to-one relationship, meaning each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">Contact</span></strong><span class="koboSpan" id="kobo.1052.1"> entity has one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">Address</span></strong><span class="koboSpan" id="kobo.1054.1"> property and each </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">Address</span></strong><span class="koboSpan" id="kobo.1056.1"> entity belongs to only one </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">Contact</span></strong><span class="koboSpan" id="kobo.1058.1"> property. </span><span class="koboSpan" id="kobo.1058.2">To illustrate how to query a </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.1059.1">contact with its address, we will use </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">this example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1061.1">To create a new contact with its address, you can send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1062.1">POST</span></strong><span class="koboSpan" id="kobo.1063.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">api/contacts</span></strong><span class="koboSpan" id="kobo.1065.1"> endpoint. </span><span class="koboSpan" id="kobo.1065.2">The request body is </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
{Â Â Â Â "firstName": </span><span class="StringTok"><span class="koboSpan" id="kobo.1068.1">"John"</span></span><span class="koboSpan" id="kobo.1069.1">,Â Â Â Â "lastName": </span><span class="StringTok"><span class="koboSpan" id="kobo.1070.1">"Doe"</span></span><span class="koboSpan" id="kobo.1071.1">,Â Â Â Â "email": </span><span class="StringTok"><span class="koboSpan" id="kobo.1072.1">"john.doe@example.com"</span></span><span class="koboSpan" id="kobo.1073.1">,Â Â Â Â "phone": </span><span class="StringTok"><span class="koboSpan" id="kobo.1074.1">"1234567890"</span></span><span class="koboSpan" id="kobo.1075.1">,Â Â Â Â "address": {Â Â Â Â Â Â Â Â "street": </span><span class="StringTok"><span class="koboSpan" id="kobo.1076.1">"123 Main St"</span></span><span class="koboSpan" id="kobo.1077.1">,Â Â Â Â Â Â Â Â "city": </span><span class="StringTok"><span class="koboSpan" id="kobo.1078.1">"Wellington"</span></span><span class="koboSpan" id="kobo.1079.1">,Â Â Â Â Â Â Â Â "state": </span><span class="StringTok"><span class="koboSpan" id="kobo.1080.1">"Wellington"</span></span><span class="koboSpan" id="kobo.1081.1">,Â Â Â Â Â Â Â Â "zipCode": </span><span class="StringTok"><span class="koboSpan" id="kobo.1082.1">"6011"</span></span><span class="koboSpan" id="kobo.1083.1">,Â Â Â Â Â Â Â Â "country": </span><span class="StringTok"><span class="koboSpan" id="kobo.1084.1">"New Zealand"</span></span><span class="koboSpan" id="kobo.1085.1">Â Â Â Â }}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1086.1">In the JSON request body, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">address</span></strong><span class="koboSpan" id="kobo.1088.1"> object is a property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">Contact</span></strong><span class="koboSpan" id="kobo.1090.1"> object. </span><span class="koboSpan" id="kobo.1090.2">It is not required to send the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">ContactId</span></strong><span class="koboSpan" id="kobo.1092.1"> property in the request body. </span><span class="koboSpan" id="kobo.1092.2">EF Core will automatically set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">ContactId</span></strong><span class="koboSpan" id="kobo.1094.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">Id</span></strong><span class="koboSpan" id="kobo.1096.1"> property of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">Contact</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.1099.1">Similarly, when you query the contacts through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">api/contacts</span></strong><span class="koboSpan" id="kobo.1101.1"> endpoint, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">Address</span></strong><span class="koboSpan" id="kobo.1103.1"> object will not be included in the response body by default. </span><span class="koboSpan" id="kobo.1103.2">You need to explicitly use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">Include</span></strong><span class="koboSpan" id="kobo.1105.1"> method to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">Address</span></strong><span class="koboSpan" id="kobo.1107.1"> object </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.1108.1">in the query, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">following code:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1110.1">
// GET: api/Contacts[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Contact&gt;&gt;&gt; GetContacts(){Â Â Â Â if (context.Contacts == null)Â Â Â Â {Â Â Â Â Â Â Â Â return NotFound();Â Â Â Â }Â Â Â Â return await context.Contacts.Include(x =&gt; x.Address).ToListAsync();}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1111.1">You can </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.1112.1">check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">ContactsController.cs</span></strong><span class="koboSpan" id="kobo.1114.1"> file for other CRUD operations and test them in Postman or any other REST client </span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">you like.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">We have explored two types of relationships: one-to-many and one-to-one. </span><span class="koboSpan" id="kobo.1116.2">Now, let us </span><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.1117.1">delve into another type of </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">relationship: many-to-many.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.1119.1">Understanding many-to-many relationships</span></h1>
<p><span class="koboSpan" id="kobo.1120.1">A </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.1121.1">many-to-many relationship is when an entity can be associated with multiple entities and vice versa. </span><span class="koboSpan" id="kobo.1121.2">For example, a movie can have many actors, and an actor can act in many movies; a post can have many tags, and a tag can have many posts; a student can enroll in many courses, and a course can have many students, and so on. </span><span class="koboSpan" id="kobo.1121.3">In this section, we will introduce h</span><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.1122.1">ow to configure a many-to-many relationship in </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">EF Core.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.1124.1">Many-to-many configuration</span></h2>
<p><span class="koboSpan" id="kobo.1125.1">In a </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.1126.1">many-to-many relationship, we need to define a collection navigation property on both sides. </span><span class="koboSpan" id="kobo.1126.2">Here is an example of a many-to-many relationship between a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1127.1">Movie</span></strong><span class="koboSpan" id="kobo.1128.1"> entity and an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">Actor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1"> entity:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1131.1">
public class Movie{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â public string Title { get; set; } = string.Empty;
Â Â Â Â public string? </span><span class="koboSpan" id="kobo.1131.2">Description { get; set; }
Â Â Â Â public int ReleaseYear { get; set; }
Â Â Â Â public List&lt;Actor&gt; Actors { get; set; } = new List&lt;Actor&gt;();
}
public class Actor
{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â public string Name { get; set; } = string.Empty;
Â Â Â Â public List&lt;Movie&gt; Movies { get; set; } = new List&lt;Movie&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.1132.1">EF Core can detect the many-to-many relationship automatically following the convention. </span><span class="koboSpan" id="kobo.1132.2">If you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">dotnet ef migrations add AddMovieAndActor</span></strong><span class="koboSpan" id="kobo.1134.1"> command to add a migration, you will see the following code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">migration file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
migrationBuilder.CreateTable(Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1137.1">"ActorMovie"</span></span><span class="koboSpan" id="kobo.1138.1">,
Â Â Â Â columns: table =&gt; new
Â Â Â Â {
Â Â Â Â Â Â Â Â ActorsId = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1139.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.1140.1">, nullable: false),
Â Â Â Â Â Â Â Â MoviesId = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1141.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.1142.1">, nullable: false)
Â Â Â Â },
Â Â Â Â constraints: table =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â table.PrimaryKey(</span><span class="StringTok"><span class="koboSpan" id="kobo.1143.1">"PK_ActorMovie"</span></span><span class="koboSpan" id="kobo.1144.1">, x =&gt; new { x.ActorsId, x.MoviesId });
Â Â Â Â Â Â Â Â table.ForeignKey(
Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1145.1">"FK_ActorMovie_Actors_ActorsId"</span></span><span class="koboSpan" id="kobo.1146.1">,
Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.ActorsId,
Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.1147.1">"Actors"</span></span><span class="koboSpan" id="kobo.1148.1">,
Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.1149.1">"Id"</span></span><span class="koboSpan" id="kobo.1150.1">,
Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);
Â Â Â Â Â Â Â Â table.ForeignKey(
Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1151.1">"FK_ActorMovie_Movies_MoviesId"</span></span><span class="koboSpan" id="kobo.1152.1">,
Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.MoviesId,
Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.1153.1">"Movies"</span></span><span class="koboSpan" id="kobo.1154.1">,
Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.1155.1">"Id"</span></span><span class="koboSpan" id="kobo.1156.1">,
Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);
Â Â Â Â });</span></pre>
<p><span class="koboSpan" id="kobo.1157.1">Besides the code that creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">Movies</span></strong><span class="koboSpan" id="kobo.1159.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">Actors</span></strong><span class="koboSpan" id="kobo.1161.1"> tables, the migration file also creates a join table named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">ActorMovie</span></strong><span class="koboSpan" id="kobo.1163.1"> to store the foreign keys for both sides. </span><span class="koboSpan" id="kobo.1163.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">ActorMovie</span></strong><span class="koboSpan" id="kobo.1165.1"> table has two foreign key properties, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">ActorsId</span></strong><span class="koboSpan" id="kobo.1167.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">MoviesId</span></strong><span class="koboSpan" id="kobo.1169.1">, to associate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">Actor</span></strong><span class="koboSpan" id="kobo.1171.1"> entity and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">Movie</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1"> entity.</span></span></p>
<p><span class="koboSpan" id="kobo.1174.1">However, sometimes </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.1175.1">the automatic detection of the many-to-many relationship may not meet our requirements. </span><span class="koboSpan" id="kobo.1175.2">For example, we may want to call the table </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">MovieActor</span></strong><span class="koboSpan" id="kobo.1177.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">ActorMovie</span></strong><span class="koboSpan" id="kobo.1179.1">, we may want to specify the foreign key properties as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">ActorId</span></strong><span class="koboSpan" id="kobo.1181.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">MovieId</span></strong><span class="koboSpan" id="kobo.1183.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">ActorsId</span></strong><span class="koboSpan" id="kobo.1185.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">MoviesId</span></strong><span class="koboSpan" id="kobo.1187.1">, or we may even want to add some additional properties to the join table. </span><span class="koboSpan" id="kobo.1187.2">In these cases, we can explicitly configure the </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">many-to-many relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.1189.1">First, we need to define a join entity to store the foreign keys for both sides. </span><span class="koboSpan" id="kobo.1189.2">Here is an example of a join entity </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">MovieActor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1193.1">
public class MovieActor{
Â Â Â Â public Guid MovieId { get; set; }
Â Â Â Â public Movie Movie { get; set; } = null!;
Â Â Â Â public Guid ActorId { get; set; }
Â Â Â Â public Actor Actor { get; set; } = null!;
Â Â Â Â public DateTime UpdateTime { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.1194.1">Also, we need to add a collection navigation property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">Movie</span></strong><span class="koboSpan" id="kobo.1196.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">Actor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1"> entities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1199.1">
public class Movie{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â // Omitted other properties
Â Â Â Â public List&lt;MovieActor&gt; MovieActors { get; set; } = new ();
}
public class Actor
{
Â Â Â Â public Guid Id { get; set; }
Â Â Â Â // Omited other properties
Â Â Â Â public List&lt;MovieActor&gt; MovieActors { get; set; } = new ();
}</span></pre>
<p><span class="koboSpan" id="kobo.1200.1">Then, we</span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.1201.1"> configure the many-to-many relationship in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">Movie</span></strong><span class="koboSpan" id="kobo.1203.1"> configuration using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">HasMany()/WithMany()</span></strong><span class="koboSpan" id="kobo.1205.1"> methods, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1207.1">
public class MovieConfiguration : IEntityTypeConfiguration&lt;Movie&gt;{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;Movie&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â builder.HasMany(m =&gt; m.Actors)
Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(a =&gt; a.Movies)
Â Â Â Â Â Â Â Â Â Â Â Â .UsingEntity&lt;MovieActor&gt;(
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j =&gt; j
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .HasOne(ma =&gt; ma.Actor)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(a =&gt; a.MovieActors)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey(ma =&gt; ma.ActorId),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j =&gt; j
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .HasOne(ma =&gt; ma.Movie)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(m =&gt; m.MovieActors)
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey(ma =&gt; ma.MovieId),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // You can add more configuration here
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j.Property(ma =&gt; ma.UpdateTime).HasColumnName(</span><span class="StringTok"><span class="koboSpan" id="kobo.1208.1">"UpdateTime"</span></span><span class="koboSpan" id="kobo.1209.1">).HasDefaultValueSql(</span><span class="StringTok"><span class="koboSpan" id="kobo.1210.1">"CURRENT_TIMESTAMP"</span></span><span class="koboSpan" id="kobo.1211.1">);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â j.HasKey(ma =&gt; new { ma.MovieId, ma.ActorId });
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â Â Â Â Â );
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1212.1">Similarly, the </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.1213.1">configuration can be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">Actor</span></strong><span class="koboSpan" id="kobo.1215.1"> configuration as well. </span><span class="koboSpan" id="kobo.1215.2">After adding the configuration, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">dotnet ef migrations add AddMovieAndActor</span></strong><span class="koboSpan" id="kobo.1217.1"> command to add a migration; you will see the following code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">migration file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1219.1">
migrationBuilder.CreateTable(Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1220.1">"MovieActor"</span></span><span class="koboSpan" id="kobo.1221.1">,
Â Â Â Â columns: table =&gt; new
Â Â Â Â {
Â Â Â Â Â Â Â Â MovieId = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1222.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.1223.1">, nullable: false),
Â Â Â Â Â Â Â Â ActorId = table.Column&lt;Guid&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1224.1">"uniqueidentifier"</span></span><span class="koboSpan" id="kobo.1225.1">, nullable: false),
Â Â Â Â Â Â Â Â UpdateTime = table.Column&lt;DateTime&gt;(type: </span><span class="StringTok"><span class="koboSpan" id="kobo.1226.1">"datetime2"</span></span><span class="koboSpan" id="kobo.1227.1">, nullable: false, defaultValueSql: </span><span class="StringTok"><span class="koboSpan" id="kobo.1228.1">"CURRENT_TIMESTAMP"</span></span><span class="koboSpan" id="kobo.1229.1">)
Â Â Â Â },
Â Â Â Â constraints: table =&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â table.PrimaryKey(</span><span class="StringTok"><span class="koboSpan" id="kobo.1230.1">"PK_MovieActor"</span></span><span class="koboSpan" id="kobo.1231.1">, x =&gt; new { x.MovieId, x.ActorId });
Â Â Â Â Â Â Â Â table.ForeignKey(
Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1232.1">"FK_MovieActor_Actors_ActorId"</span></span><span class="koboSpan" id="kobo.1233.1">,
Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.ActorId,
Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.1234.1">"Actors"</span></span><span class="koboSpan" id="kobo.1235.1">,
Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.1236.1">"Id"</span></span><span class="koboSpan" id="kobo.1237.1">,
Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);
Â Â Â Â Â Â Â Â table.ForeignKey(
Â Â Â Â Â Â Â Â Â Â Â Â name: </span><span class="StringTok"><span class="koboSpan" id="kobo.1238.1">"FK_MovieActor_Movies_MovieId"</span></span><span class="koboSpan" id="kobo.1239.1">,
Â Â Â Â Â Â Â Â Â Â Â Â column: x =&gt; x.MovieId,
Â Â Â Â Â Â Â Â Â Â Â Â principalTable: </span><span class="StringTok"><span class="koboSpan" id="kobo.1240.1">"Movies"</span></span><span class="koboSpan" id="kobo.1241.1">,
Â Â Â Â Â Â Â Â Â Â Â Â principalColumn: </span><span class="StringTok"><span class="koboSpan" id="kobo.1242.1">"Id"</span></span><span class="koboSpan" id="kobo.1243.1">,
Â Â Â Â Â Â Â Â Â Â Â Â onDelete: ReferentialAction.Cascade);
Â Â Â Â });</span></pre>
<p><span class="koboSpan" id="kobo.1244.1">You can </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.1245.1">see that the join table is renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1246.1">MovieActor</span></strong><span class="koboSpan" id="kobo.1247.1">, and the foreign key properties are renamed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1248.1">MovieId</span></strong><span class="koboSpan" id="kobo.1249.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">ActorId</span></strong><span class="koboSpan" id="kobo.1251.1">. </span><span class="koboSpan" id="kobo.1251.2">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">UpdateTime</span></strong><span class="koboSpan" id="kobo.1253.1"> property is added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">join table.</span></span></p>
<p><span class="koboSpan" id="kobo.1255.1">After the migration is applied, you can see the join table in </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">the database:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.1257.1"><img alt="Figure 6.5 â€“ The join table in the database" src="image/B18971_06_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1258.1">Figure 6.5 â€“ The join table in the database</span></p>
<p><span class="koboSpan" id="kobo.1259.1">Another way (before EF Core 5.0) to configure a many-to-many relationship is to use the</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.1260.1"> join entity to represent two separate one-to-many relationships. </span><span class="koboSpan" id="kobo.1260.2">Here is an example of configuring a many-to-many relationship for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">Movie</span></strong><span class="koboSpan" id="kobo.1262.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">Actor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1"> entities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1265.1">
public class MovieActorsConfiguration : IEntityTypeConfiguration&lt;MovieActor&gt;{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;MovieActor&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â builder.ToTable("MovieActors");
Â Â Â Â Â Â Â Â builder.HasKey(sc =&gt; new { sc.MovieId, sc.ActorId });
Â Â Â Â Â Â Â Â builder.HasOne(sc =&gt; sc.Actor)
Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(s =&gt; s.MovieActors)
Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey(sc =&gt; sc.ActorId);
Â Â Â Â Â Â Â Â builder.HasOne(sc =&gt; sc.Movie)
Â Â Â Â Â Â Â Â Â Â Â Â .WithMany(c =&gt; c.MovieActors)
Â Â Â Â Â Â Â Â Â Â Â Â .HasForeignKey(sc =&gt; sc.MovieId);
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1266.1">In the preceding code, we configured two one-to-many relationships for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">Movie</span></strong><span class="koboSpan" id="kobo.1268.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">Actor</span></strong><span class="koboSpan" id="kobo.1270.1"> entities on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">MovieActor</span></strong><span class="koboSpan" id="kobo.1272.1"> join entity. </span><span class="koboSpan" id="kobo.1272.2">Each one-to-many relationship uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">HasMany(), WithMany()</span></strong><span class="koboSpan" id="kobo.1274.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">HasForeignKey()</span></strong><span class="koboSpan" id="kobo.1276.1"> methods to configure the relationship. </span><span class="koboSpan" id="kobo.1276.2">This </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.1277.1">combination of one-to-one relationships creates a </span><span class="No-Break"><span class="koboSpan" id="kobo.1278.1">many-to-many relationship.</span></span></p>
<p><span class="koboSpan" id="kobo.1279.1">You can use either way to configure a many-to-many relationship. </span><span class="koboSpan" id="kobo.1279.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">HasMany()/WithMany()</span></strong><span class="koboSpan" id="kobo.1281.1"> methods is more convenient and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">to use.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.1283.1">Many-to-many CRUD operations</span></h2>
<p><span class="koboSpan" id="kobo.1284.1">In a </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.1285.1">many-to-many relationship, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">Movie</span></strong><span class="koboSpan" id="kobo.1287.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1288.1">Actor</span></strong><span class="koboSpan" id="kobo.1289.1">, we may need to get the actors of a movie or get the movies of an actor. </span><span class="koboSpan" id="kobo.1289.2">So, we need to expose both entities through the REST API. </span><span class="koboSpan" id="kobo.1289.3">You can create two controllers using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1290.1">following commands:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1291.1">
dotnet-aspnet-codegenerator controller -name MoviesController -api -outDir Controllers --model Movie --dataContext SampleDbContext -async -actionsdotnet-aspnet-codegenerator controller -name ActorsController -api -outDir Controllers --model Actor --dataContext SampleDbContext -async -actions</span></pre>
<p><span class="koboSpan" id="kobo.1292.1">Run the application and create some movies </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">and actors.</span></span></p>
<p><span class="koboSpan" id="kobo.1294.1">We can include the actors of a movie when creating a movie. </span><span class="koboSpan" id="kobo.1294.2">For example, we can create a movie with a couple of actors using the following JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">payload format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1296.1">
{Â Â Â Â "title": </span><span class="StringTok"><span class="koboSpan" id="kobo.1297.1">"The Shawshank Redemption"</span></span><span class="koboSpan" id="kobo.1298.1">,
Â Â Â Â "releaseYear": </span><span class="StringTok"><span class="koboSpan" id="kobo.1299.1">"1994"</span></span><span class="koboSpan" id="kobo.1300.1">,
Â Â Â Â "actors": [
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.1301.1">"Tim Robbins"</span></span><span class="koboSpan" id="kobo.1302.1">
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.1303.1">"Morgan Freeman"</span></span><span class="koboSpan" id="kobo.1304.1">
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.1305.1">"Bob Gunton"</span></span><span class="koboSpan" id="kobo.1306.1">
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.1307.1">"William Sadler"</span></span><span class="koboSpan" id="kobo.1308.1">
Â Â Â Â Â Â Â Â }
Â Â Â Â ]
}</span></pre>
<p><span class="koboSpan" id="kobo.1309.1">You will </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.1310.1">see the following result in </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">the database:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.1312.1"><img alt="Figure 6.6 â€“ The join table has been populated" src="image/B18971_06_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1313.1">Figure 6.6 â€“ The join table has been populated</span></p>
<p><span class="koboSpan" id="kobo.1314.1">Similarly, you can also include the movies of an actor when creating an actor. </span><span class="koboSpan" id="kobo.1314.2">However, if we include related entities arbitrarily, we may end up with duplicate entities. </span><span class="koboSpan" id="kobo.1314.3">For example, we create an actor with a couple of movies using the following JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">payload format:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1316.1">
{Â Â Â Â "name": </span><span class="StringTok"><span class="koboSpan" id="kobo.1317.1">"Tim Robbins"</span></span><span class="koboSpan" id="kobo.1318.1">,
Â Â Â Â "movies": [
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "title": </span><span class="StringTok"><span class="koboSpan" id="kobo.1319.1">"The Shawshank Redemption"</span></span><span class="koboSpan" id="kobo.1320.1">,
Â Â Â Â Â Â Â Â Â Â Â Â "releaseYear": </span><span class="StringTok"><span class="koboSpan" id="kobo.1321.1">"1994"</span></span><span class="koboSpan" id="kobo.1322.1">
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "title": </span><span class="StringTok"><span class="koboSpan" id="kobo.1323.1">"Green Mile"</span></span><span class="koboSpan" id="kobo.1324.1">,
Â Â Â Â Â Â Â Â Â Â Â Â "releaseYear": </span><span class="StringTok"><span class="koboSpan" id="kobo.1325.1">"1999"</span></span><span class="koboSpan" id="kobo.1326.1">
Â Â Â Â Â Â Â Â }
Â Â Â Â ]
}</span></pre>
<p><span class="koboSpan" id="kobo.1327.1">As a result, you</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.1328.1"> will have two movies with the same title in the database. </span><span class="koboSpan" id="kobo.1328.2">To avoid this, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">some options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1330.1">Add a unique index to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">Title</span></strong><span class="koboSpan" id="kobo.1332.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">Movie</span></strong><span class="koboSpan" id="kobo.1334.1"> entity to ensure that the title is unique. </span><span class="koboSpan" id="kobo.1334.2">This is the simplest solution and can prevent duplicate entities from being added to </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">the database.</span></span></li>
<li><span class="koboSpan" id="kobo.1336.1">Check if the entity already exists in the database before </span><span class="No-Break"><span class="koboSpan" id="kobo.1337.1">adding it.</span></span></li>
<li><span class="koboSpan" id="kobo.1338.1">Add movies and actors separately, and then update either the movie or the actor to include the other entity using the IDs of the other entity, instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">whole entity.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1340.1">You can use a combination of the preceding options to improve the implementation. </span><span class="koboSpan" id="kobo.1340.2">To add a unique index to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">Title</span></strong><span class="koboSpan" id="kobo.1342.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">Movie</span></strong><span class="koboSpan" id="kobo.1344.1"> entity, you can update the following code of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">MovieConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1347.1">
public void Configure(EntityTypeBuilder&lt;Movie&gt; builder){
Â Â Â Â builder.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.1348.1">"Movies"</span></span><span class="koboSpan" id="kobo.1349.1">);
Â Â Â Â builder.HasKey(m =&gt; m.Id);
Â Â Â Â builder.Property(p =&gt; p.Title).HasColumnName(</span><span class="StringTok"><span class="koboSpan" id="kobo.1350.1">"Title"</span></span><span class="koboSpan" id="kobo.1351.1">).HasMaxLength(128).IsRequired();
Â Â Â Â // Add a unique index to the Title property
Â Â Â Â builder.HasIndex(p =&gt; p.Title).IsUnique();
Â Â Â Â // Omitted for brevity
}</span></pre>
<p><span class="koboSpan" id="kobo.1352.1">You can make </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.1353.1">the same change to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">Name</span></strong><span class="koboSpan" id="kobo.1355.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">Actor</span></strong><span class="koboSpan" id="kobo.1357.1"> entity. </span><span class="koboSpan" id="kobo.1357.2">After the change, you need to create a new migration and apply it to the database. </span><span class="koboSpan" id="kobo.1357.3">This helps to prevent duplicate entities on the database level. </span><span class="koboSpan" id="kobo.1357.4">If a request contains duplicate entities, the database will throw </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">It is possible to add or update related entities in the same request as the main entity. </span><span class="koboSpan" id="kobo.1359.2">But sometimes, it might not be necessary. </span><span class="koboSpan" id="kobo.1359.3">For example, an actor just acts in a new movie, and you want to create a new movie and add the actor to the movie. </span><span class="koboSpan" id="kobo.1359.4">You can update the actor to include the new movie, but you have to send the whole actor entity in the request, including existing movies. </span><span class="koboSpan" id="kobo.1359.5">It causes unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1">data transfer.</span></span></p>
<p><span class="koboSpan" id="kobo.1361.1">To make the API easy to use, it is pragmatic to expose an additional API endpoint to update a collection of related entities only, rather than updating the whole entity. </span><span class="koboSpan" id="kobo.1361.2">For example, we can create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">/api/actors/{id}/movies</span></strong><span class="koboSpan" id="kobo.1363.1"> endpoint to update the movies of an actor. </span><span class="koboSpan" id="kobo.1363.2">It is a good practice to avoid updating a collection of related entities in the same request. </span><span class="koboSpan" id="kobo.1363.3">We can just send the IDs of the related entities to the API endpoint. </span><span class="koboSpan" id="kobo.1363.4">From the perspective of the API, the relationship is treated as a resource. </span><span class="koboSpan" id="kobo.1363.5">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">ActorsController.cs</span></strong><span class="koboSpan" id="kobo.1365.1"> file, you will find the </span><span class="No-Break"><span class="koboSpan" id="kobo.1366.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1367.1">
[HttpPost(</span><span class="StringTok"><span class="koboSpan" id="kobo.1368.1">"{id}/movies/{movieId}"</span></span><span class="koboSpan" id="kobo.1369.1">)]public async Task&lt;IActionResult&gt; AddMovie(Guid id, Guid movieId)
{
Â Â Â Â if (_context.Actors == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound("Actors is null.");
Â Â Â Â }
Â Â Â Â var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync(x =&gt; x.Id == id);
Â Â Â Â if (actor == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound($"Actor with id {id} not found.");
Â Â Â Â }
Â Â Â Â var movie = await _context.Movies.FindAsync(movieId);
Â Â Â Â if (movie == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound($"Movie with id {movieId} not found.");
Â Â Â Â }
Â Â Â Â if (actor.Movies.Any(x =&gt; x.Id == movie.Id))
Â Â Â Â {
Â Â Â Â Â Â Â Â return Problem($</span><span class="StringTok"><span class="koboSpan" id="kobo.1370.1">"Movie </span></span><span class="koboSpan" id="kobo.1371.1">with id {movieId}</span><span class="StringTok"><span class="koboSpan" id="kobo.1372.1"> already exists for Actor {id}."</span></span><span class="koboSpan" id="kobo.1373.1">);
Â Â Â Â }
Â Â Â Â actor.Movies.Add(movie);
Â Â Â Â await _context.SaveChangesAsync();
Â Â Â Â return CreatedAtAction(</span><span class="StringTok"><span class="koboSpan" id="kobo.1374.1">"GetActor"</span></span><span class="koboSpan" id="kobo.1375.1">, new { id = actor.Id }, actor);
}
[HttpGet(</span><span class="StringTok"><span class="koboSpan" id="kobo.1376.1">"{id}/movies"</span></span><span class="koboSpan" id="kobo.1377.1">)]
public async Task&lt;IActionResult&gt; GetMovies(Guid id)
{
Â Â Â Â if (_context.Actors == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound("Actors is null.");
Â Â Â Â }
Â Â Â Â var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync();
Â Â Â Â if (actor == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound($"Actor with id {id} not found.");
Â Â Â Â }
Â Â Â Â return Ok(actor.Movies);
}
[HttpDelete(</span><span class="StringTok"><span class="koboSpan" id="kobo.1378.1">"{id}/movies/{movieId}"</span></span><span class="koboSpan" id="kobo.1379.1">)]
public async Task&lt;IActionResult&gt; DeleteMovie(Guid id, Guid movieId)
{
Â Â Â Â if (_context.Actors == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound("Actors is null.");
Â Â Â Â }
Â Â Â Â var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync();
Â Â Â Â if (actor == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound($"Actor with id {id} not found.");
Â Â Â Â }
Â Â Â Â var movie = await _context.Movies.FindAsync(movieId);
Â Â Â Â if (movie == null)
Â Â Â Â {
Â Â Â Â Â Â Â Â return NotFound($"Movie with id {movieId} not found.");
Â Â Â Â }
Â Â Â Â actor.Movies.Remove(movie);
Â Â Â Â await _context.SaveChangesAsync();
Â Â Â Â return NoContent();
}</span></pre>
<p><span class="koboSpan" id="kobo.1380.1">The preceding code exposes a few endpoints to add, get, and delete the movies of an actor. </span><span class="koboSpan" id="kobo.1380.2">You can test the endpoints using the JSON payload format, as shown in the preceding </span><a id="_idIndexMarker608"/><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">code snippet:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1382.1">To add a movie to an actor, send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">POST</span></strong><span class="koboSpan" id="kobo.1384.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">/api/actors/{id}/movies/{movieId}</span></strong><span class="koboSpan" id="kobo.1386.1"> endpoint. </span><span class="koboSpan" id="kobo.1386.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">AddMovie</span></strong><span class="koboSpan" id="kobo.1388.1"> action will check if the movie already exists in the database. </span><span class="koboSpan" id="kobo.1388.2">If it does, it will then check if the movie already exists in the movies of the actor. </span><span class="koboSpan" id="kobo.1388.3">If not, it adds the movie to the collection and then saves the changes to </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">the database.</span></span></li>
<li><span class="koboSpan" id="kobo.1390.1">To get the movies of an actor, send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">GET</span></strong><span class="koboSpan" id="kobo.1392.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">/api/actors/{id}/movies</span></strong><span class="koboSpan" id="kobo.1394.1"> endpoint. </span><span class="koboSpan" id="kobo.1394.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">GetMovies</span></strong><span class="koboSpan" id="kobo.1396.1"> action will return the movies of the actor. </span><span class="koboSpan" id="kobo.1396.2">This endpoint can be updated to support pagination, sorting, </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">and filtering.</span></span></li>
<li><span class="koboSpan" id="kobo.1398.1">To delete a movie from an actor, send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1399.1">DELETE</span></strong><span class="koboSpan" id="kobo.1400.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1401.1">/api/actors/{id}/movies/{movieId}</span></strong><span class="koboSpan" id="kobo.1402.1"> endpoint. </span><span class="koboSpan" id="kobo.1402.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1403.1">DeleteMovie</span></strong><span class="koboSpan" id="kobo.1404.1"> action will remove the movie from the collection and then save the changes to the database. </span><span class="koboSpan" id="kobo.1404.2">Note that it does not delete the movie from the database; it just deletes the relationship between the movie and </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">the actor.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1406.1">It is also possible to add a similar endpoint to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1407.1">MoviesController.cs</span></strong><span class="koboSpan" id="kobo.1408.1"> file to update the actors of a movie. </span><span class="koboSpan" id="kobo.1408.2">You can use the same approach to implement endpoints. </span><span class="koboSpan" id="kobo.1408.3">Try </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">it yourself!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1410.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1411.1">When you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1412.1">/api/actors</span></strong><span class="koboSpan" id="kobo.1413.1"> endpoint, you may find that the response contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">MovieActors</span></strong><span class="koboSpan" id="kobo.1415.1"> as well. </span><span class="koboSpan" id="kobo.1415.2">This is not useful for the client. </span><span class="koboSpan" id="kobo.1415.3">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1416.1">JsonIgnore</span></strong><span class="koboSpan" id="kobo.1417.1"> attribute to ignore the property when serializing </span><span class="No-Break"><span class="koboSpan" id="kobo.1418.1">the response.</span></span></p>
<p><span class="koboSpan" id="kobo.1419.1">We have now discussed three common types of relationships: one-to-many, one-to-one, and many-to-many. </span><span class="koboSpan" id="kobo.1419.2">You should now have a good understanding of how to configure relationships and implement CRUD operations for entities with rel</span><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.1420.1">ationships. </span><span class="koboSpan" id="kobo.1420.2">Let's move on to our next topic: owned </span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">entity types.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.1422.1">Understanding owned entities</span></h1>
<p><span class="koboSpan" id="kobo.1423.1">In the previous sections, we</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.1424.1"> have learned some relationships are optional, but some are required. </span><span class="koboSpan" id="kobo.1424.2">For example, a post can exist without a category, but a student ID card cannot exist without a student. </span><span class="koboSpan" id="kobo.1424.3">For the latter, we can say a student owns an ID card. </span><span class="koboSpan" id="kobo.1424.4">Similarly, a contact owns an address. </span><span class="koboSpan" id="kobo.1424.5">We can also find some examples of one-to-many relationships. </span><span class="koboSpan" id="kobo.1424.6">For example, an invoice owns many invoice items because an invoice item cannot exist without an invoice. </span><span class="koboSpan" id="kobo.1424.7">In this section, we will introduce the concept of </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">owned entities.</span></span></p>
<p><span class="koboSpan" id="kobo.1426.1">Owned entity types are entity types that are part of the owner and cannot exist without the owner. </span><span class="koboSpan" id="kobo.1426.2">You can use common one-to-one or one-to-many relationships to model the owned entities, but EF Core provides a more convenient way called owned entity types. </span><span class="koboSpan" id="kobo.1426.3">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">OwnsOne()</span></strong><span class="koboSpan" id="kobo.1428.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">OwnsMany()</span></strong><span class="koboSpan" id="kobo.1430.1"> method to define owned entity types, instead of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">HasOne()</span></strong><span class="koboSpan" id="kobo.1432.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">HasMany()</span></strong><span class="koboSpan" id="kobo.1434.1"> method. </span><span class="koboSpan" id="kobo.1434.2">For example, to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.1436.1"> entity as an owned entity type of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1437.1">Invoice</span></strong><span class="koboSpan" id="kobo.1438.1"> entity, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1440.1">
public class InvoiceConfiguration : IEntityTypeConfiguration&lt;Invoice&gt;{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;Invoice&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â // Use the owned type to configure the InvoiceItems collection
Â Â Â Â Â Â Â Â builder.OwnsMany(p =&gt; p.InvoiceItems, a =&gt;
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â a.WithOwner( =&gt; x.Invoice).HasForeignKey(x =&gt; x.InvoiceId);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â a.ToTable(</span><span class="StringTok"><span class="koboSpan" id="kobo.1441.1">"InvoiceItems"</span></span><span class="koboSpan" id="kobo.1442.1">);
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â );
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1443.1">As shown in</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.1444.1"> the preceding code, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1445.1">OwnsMany()/WithOwner()</span></strong><span class="koboSpan" id="kobo.1446.1"> methods to configure the owned entity type. </span><span class="koboSpan" id="kobo.1446.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">OwnsMany()/WithOwner()</span></strong><span class="koboSpan" id="kobo.1448.1"> method specifies the owner of the owned entity type. </span><span class="koboSpan" id="kobo.1448.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1449.1">HasForeignKey()</span></strong><span class="koboSpan" id="kobo.1450.1"> method specifies the foreign key property of the owned entity type. </span><span class="koboSpan" id="kobo.1450.2">The configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">InvoiceItem</span></strong><span class="koboSpan" id="kobo.1452.1"> entity is stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">InvoiceConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.1455.1">Similarly, the configuration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1456.1">Address</span></strong><span class="koboSpan" id="kobo.1457.1"> entity could be stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1458.1">ContactConfiguration</span></strong><span class="koboSpan" id="kobo.1459.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.1460.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1461.1">
public class ContactConfiguration : IEntityTypeConfiguration&lt;Contact&gt;{
Â Â Â Â public void Configure(EntityTypeBuilder&lt;Contact&gt; builder)
Â Â Â Â {
Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â // Use owned entity type
Â Â Â Â Â Â Â Â builder.OwnsOne(c =&gt; c.Address, a =&gt;
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â a.WithOwner(x =&gt; x.Contact);
Â Â Â Â Â Â Â Â Â Â Â Â a.Property(a =&gt; a.Street).HasColumnName(</span><span class="StringTok"><span class="koboSpan" id="kobo.1462.1">"Street"</span></span><span class="koboSpan" id="kobo.1463.1">).HasMaxLength(64).IsRequired();
Â Â Â Â Â Â Â Â Â Â Â Â // Omitted for brevity
Â Â Â Â Â Â Â Â });
Â Â Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.1464.1">When you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">OwnsOne()/WithOwner()</span></strong><span class="koboSpan" id="kobo.1466.1"> methods, you do not need to specify the foreign key property because the owned entity type will be stored in the same table as the owner by default. </span><span class="koboSpan" id="kobo.1466.2">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">ToTable</span></strong><span class="koboSpan" id="kobo.1468.1"> method to specify the table name of the owned </span><span class="No-Break"><span class="koboSpan" id="kobo.1469.1">entity type.</span></span></p>
<p><span class="koboSpan" id="kobo.1470.1">So, what is the </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.1471.1">difference between normal one-to-one or one-to-many and owned entity types? </span><span class="koboSpan" id="kobo.1471.2">There are </span><span class="No-Break"><span class="koboSpan" id="kobo.1472.1">some differences:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1473.1">You cannot create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">DbSet&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1475.1"> property for an owned entity type. </span><span class="koboSpan" id="kobo.1475.2">You can only use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">DbSet&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.1477.1"> property for the owner. </span><span class="koboSpan" id="kobo.1477.2">That means you do not have any way to access the owned entity type directly. </span><span class="koboSpan" id="kobo.1477.3">You must access the owned entity type through </span><span class="No-Break"><span class="koboSpan" id="kobo.1478.1">the owner.</span></span></li>
<li><span class="koboSpan" id="kobo.1479.1">When you query the owner, the owned entity type will be included automatically. </span><span class="koboSpan" id="kobo.1479.2">You do not need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">Include()</span></strong><span class="koboSpan" id="kobo.1481.1"> method to include the owned entity type explicitly. </span><span class="koboSpan" id="kobo.1481.2">So, please be careful if the owner has many owned entities. </span><span class="koboSpan" id="kobo.1481.3">It may cause </span><span class="No-Break"><span class="koboSpan" id="kobo.1482.1">performance issues.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1483.1">If your entities have a simple one-to-one or one-to-many relationship and the data is not large, you can use owned entity types to simplify the configuration. </span><span class="koboSpan" id="kobo.1483.2">However, if the relationship is complex and the data size is large, you would be better off using normal one-to-one or one-to-many relationships </span><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.1484.1">because you can decide which related entities to </span><span class="No-Break"><span class="koboSpan" id="kobo.1485.1">include explicitly.</span></span></p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.1486.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1487.1">In this comprehensive chapter, we delved into modeling relationships between entities in EF Core. </span><span class="koboSpan" id="kobo.1487.2">We explored various common relationship types, including one-to-one, one-to-many, and many-to-many relationships. </span><span class="koboSpan" id="kobo.1487.3">We learned how to configure these relationships using essential methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">HasOne()/WithMany()</span></strong><span class="koboSpan" id="kobo.1489.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1490.1">HasMany()/WithOne()</span></strong><span class="koboSpan" id="kobo.1491.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1492.1">HasMany()/WithMany()</span></strong><span class="koboSpan" id="kobo.1493.1">. </span><span class="koboSpan" id="kobo.1493.2">To broaden our understanding, we also explored configuring owned entity types using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">OwnsOne()/WithOwner()</span></strong><span class="koboSpan" id="kobo.1495.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">OwnsMany/WithOwner()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.1498.1">To effectively operate on entities with relationships, we explained how to implement CRUD operations for each type of relationship. </span><span class="koboSpan" id="kobo.1498.2">Particularly, we explained cascading delete operations, ensuring data integrity and efficient management of </span><span class="No-Break"><span class="koboSpan" id="kobo.1499.1">related entities.</span></span></p>
<p><span class="koboSpan" id="kobo.1500.1">The concepts learned in this chapter will help you model relationships between entities in your ASP.NET Core applications. </span><span class="koboSpan" id="kobo.1500.2">In the next chapter, we will learn about some advanced topics of EF Core, such as concurrency control, performance tuning, </span><span class="No-Break"><span class="koboSpan" id="kobo.1501.1">and more.</span></span></p>
</div>
</body></html>