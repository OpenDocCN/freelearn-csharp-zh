<html><head></head><body>
        

                            
                    <h1 class="header-title">Managing and Implementing Multithreading</h1>
                
            
            
                
<p>What happens when a long-running program starts executing on a client's computer? How do operating systems handle such long-running processes? Does the operating system notify the user about their progress? How does the operating system let the user know when it has finished with these processes? Threading is the way in which the operating system handles the responsiveness of your program while managing other system resources. This is achieved using multiple threads of execution, which is one of the most powerful ways to keep your application responsive while using the processor for other events.</p>
<p>An operating system organizes each running application as a process. Each process may contain one or more threads. A thread allows the operating system to allocate processor time as required. Each thread holds scheduling priority and a set of structures that are used by the system to pause or execute the thread. This is called <strong>thread context</strong>. In other words, the thread context holds all the information that's required by the system to seamlessly resume execution. As we've already mentioned, a process can contain multiple threads, all of which share the same virtual address space of the process.</p>
<p>In this chapter, we will focus on creating and managing threads, synchronizing data across threads, and multithreading. We'll also look at how the operating system uses this concept to keep the responsiveness of the application.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding threads and the threading process</li>
<li>Synchronizing data in multithreading</li>
<li>Multithreading</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The exercises in this chapter can be practiced using Visual Studio 2012 or above with .NET Framework 2.0 or above. However, any new C# features from C# 7.0 and above require that you have Visual Studio 2017 installed.</p>
<p>If you don't have a license for any of the aforementioned products, you can download the community version of Visual Studio 2017 from <a href="https://visualstudio.microsoft.com/downloads/" target="_blank">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>The sample code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06" target="_blank">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter06</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding threads and the threading process</h1>
                
            
            
                
<p>A primary thread is started whenever a .NET program is started. Additional threads are created by this primary thread to execute the application login either concurrently or in parallel. These threads are called <strong>worker threads</strong>. These threads can execute any part of the program code, which may include parts that are executed by another thread. As these threads are free to cross application boundaries, .NET Framework provides a way to isolate these threads within a process using application domains (not available in .NET Core).</p>
<p>If our program can perform multiple operations in parallel, it will drastically decrease the total execution time. This can be achieved by utilizing multiple threads with multiprocessors or the multicore environment. The Windows operating system, when used alongside .NET Framework, ensures that these threads complete their respective tasks. Managing these tasks does have overhead, however. The OS allocates each thread a certain period of CPU time so that they can execute. After this period, a thread switch happens, which is called context switching. This context is saved and restored for each switch. To do this, Windows uses CPU registers and state data.</p>
<p>In an environment where multiple processors and multicore systems are available, we can take advantage of these resources and increase the throughput of the application. Consider a Windows application in which one thread (the primary thread) is handling the user interface by responding to user actions and other threads (worker threads) perform operations that require more time and processing. If the primary thread completes all of these operations, the user interfaces won't be responsive.</p>
<p class="mce-root"/>
<p>Because of this overhead, we need to carefully determine when to use multithreading.</p>
<p>In the upcoming sections, we will focus on how we can create and manage threads, understand different thread properties, how we can create and pass parameters to threads, the difference between foreground and background threads, how to destroy threads, and more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing threads</h1>
                
            
            
                
<p class="mce-root">Threads can be created by creating a new instance of the <kbd>System.Threading</kbd> thread class and providing the name of the method that you want to execute on a new thread to the constructor. Using this class gives us more control and configuration of the program; for example, you can set the priority of the thread and whether it is a long-running thread, abort it, put it to sleep, and implement advanced configuration options. The <kbd>Thread.Start</kbd> method is used to create a thread call, while the <kbd>Thread.Abort</kbd> method is used to terminate the execution of a thread. The abort method raises <kbd>ThreadAbortException</kbd> when invoked. <kbd>Thread.Sleep</kbd> can be used to pause the execution of the thread for a certain amount of time. Finally, the <kbd>Thread.Interrupt</kbd> method is used to interrupt a blocked thread.</p>
<p>Let's understand these concepts by looking at a few examples.</p>
<p>In the following code, <kbd>ThreadSample</kbd> is the primary thread, which starts the worker thread. The worker thread loops 10 times and writes to the console, letting the process know it has completed. After starting the worker thread, the primary thread loops four times. Note that the output depends on the environment you are running this program on. Try to change the seconds in the <kbd>thread.sleep</kbd> statement and observe the output:</p>
<pre>internal class ThreadingSamples<br/>    {<br/>        public static void ThreadSample()<br/>        {<br/>            Console.WriteLine("Primary thread: Starting a new worker thread.");<br/>            Thread t = new Thread(new ThreadStart(ThreadOne));<br/>            t.Start();<br/>            //Thread.Sleep(1);<br/>            for (int i = 0; i &lt; 4; i++)<br/>            {<br/>                Console.WriteLine("Primary thread: Do something().");<br/>                Thread.Sleep(1);<br/><br/>            }<br/>            Console.WriteLine("Primary thread: Call Join(), to wait until ThreadOne ends.");<br/>            t.Join();<br/>            Console.WriteLine("Primary thread: ThreadOne.Join has returned.");<br/>        }<br/><br/>        public static void ThreadOne()<br/>        {<br/>            for (int i = 0; i &lt; 10; i++)<br/>            {<br/>                Console.WriteLine("ThreadOne running: {0}", i);<br/>                Thread.Sleep(0);<br/>            }<br/>        }<br/>    }</pre>
<p>Let's check the output of our program. <kbd>ThreadOne</kbd> starts its execution first and initiates 10 different worker threads and then the primary thread is executed. If you delay the execution of <kbd>ThreadOne</kbd> by using sleep, you will see the primary thread wait until <kbd>ThreadOne</kbd> returns:</p>
<div><img src="img/fca1f269-d3ff-4f46-8c44-8455d1ac33a3.png" style=""/></div>
<p>When the program is executed, a foreground thread is created automatically to execute the code. This primary thread then creates worker threads as required to execute the sections of the code from the same process. As you can see, the thread takes a delegate in its constructor. </p>
<p>In the preceding program, we used <kbd>thread.join</kbd>, which lets the primary thread wait until all the worker threads have completed their execution. Also, <kbd>Thread.Sleep(0)</kbd> tells Windows that the current thread has finished its execution so that a context switch can happen instead of Windows having to wait for the allocated time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread properties</h1>
                
            
            
                
<p>Each thread carries certain properties. The following table details each of them:</p>
<table border="1" style="border-collapse: collapse;width: 90%">
<tbody>
<tr>
<td><kbd>IsAlive</kbd></td>
<td>Returns <kbd>true</kbd> if the thread is in a started state.</td>
</tr>
<tr>
<td><kbd>IsBackground</kbd></td>
<td>Gets or sets this property to let the system know how to execute the thread.</td>
</tr>
<tr>
<td><kbd>Name</kbd></td>
<td>Name of the thread.</td>
</tr>
<tr>
<td><kbd>Priority</kbd></td>
<td>Gets or sets thread priority. The default is <kbd>Normal</kbd>.</td>
</tr>
<tr>
<td><kbd>ThreadState</kbd></td>
<td>Gets the thread's current state.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In the following code sample, we will call a method that will display information about some thread properties. We will also understand how we can pause a thread and terminate it:</p>
<pre>public static void ThreadProperties()<br/>{<br/>     var th = new Thread(ThreadTwo);<br/>     th.Start();<br/>     Thread.Sleep(1000);<br/>     Console.WriteLine("Primary thread ({0}) exiting...",Thread.CurrentThread.ManagedThreadId);<br/>}<br/><br/>private static void ThreadTwo()<br/>{<br/>    var sw = Stopwatch.StartNew();<br/>    Console.WriteLine("ThreadTwo Id: {0} Threadtwo state: {1}, Threadtwo Priority: {2}",<br/>                              Thread.CurrentThread.ManagedThreadId,<br/>                              Thread.CurrentThread.ThreadState,<br/>                              Thread.CurrentThread.Priority);<br/>    do<br/>    {<br/>        Console.WriteLine("Threadtwo Id: {0}, Threadtwo elapsed time {1:N2} seconds",<br/>                                  Thread.CurrentThread.ManagedThreadId,<br/>                                  sw.ElapsedMilliseconds / 1000.0);<br/>        Thread.Sleep(500);<br/>    } while (sw.ElapsedMilliseconds &lt;= 3000);<br/>        sw.Stop();<br/>}</pre>
<p>When you execute the program, you will see the properties of each thread. You will also observe that although the primary thread has completed, the worker threads are still executing:</p>
<div><img src="img/aca30cc8-553f-4a9a-8a8f-e5bc29f52fa6.png" style=""/></div>
<p>You might have observed that only one thread is writing to the console at a time. This is known as <strong>synchronization</strong>. In this case, it is handled by the console class for us. Synchronization allows no two threads to execute the same code block at the same time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parameterized threads</h1>
                
            
            
                
<p>Here, we will look at how we can pass arguments to the <kbd>ThreadStart</kbd> method. To achieve this, we will be using the <kbd>ParameterizedThreadStart</kbd> delegate on the constructor. The signature of this delegate is as follows:</p>
<pre>public delegate void ParameterizedThreadStart(object obj)</pre>
<p>When you pass a parameter as an object to the <kbd>ThreadStart</kbd> method, it will cast the parameter to the appropriate type. The following sample program uses the same logic that we used previously, except that we pass the interval as an argument via the <kbd>ThreadStart</kbd> method:</p>
<pre> public static void ParameterizedThread()<br/> {<br/>     var th = new Thread(ThreadThree);<br/>     th.Start(3000);<br/>     Thread.Sleep(1000);<br/>     Console.WriteLine("Primary thread ({0}) exiting...", Thread.CurrentThread.ManagedThreadId);<br/>}<br/><br/>private static void ThreadThree(object obj)<br/>{<br/>    int interval = Convert.ToInt32(obj);<br/>    var sw = Stopwatch.StartNew();<br/>    Console.WriteLine("ThreadTwo Id: {0} ThreadThree state: {1}, ThreadThree Priority: {2}",<br/>            Thread.CurrentThread.ManagedThreadId,<br/>            Thread.CurrentThread.ThreadState,<br/>            Thread.CurrentThread.Priority);<br/>    do<br/>    {<br/>        Console.WriteLine("ThreadThree Id: {0}, ThreadThree elapsed time {1:N2} seconds",<br/>            Thread.CurrentThread.ManagedThreadId,<br/>            sw.ElapsedMilliseconds / 1000.0);<br/>        Thread.Sleep(500);<br/>    } while (sw.ElapsedMilliseconds &lt;= interval);<br/>    sw.Stop();<br/>}</pre>
<p>The following screenshot shows the output of the preceding code:</p>
<div><img src="img/f28de47d-495f-4785-a190-8d100e291557.png" style=""/></div>
<p>Now, let's look at foreground and background threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Foreground and background threads</h1>
                
            
            
                
<p>By default, when a thread is created, it is created as a foreground thread. You can use the <kbd>IsBackground</kbd> property to make a thread a background thread. The main difference between foreground and background threads is that a background thread does not run if all the foreground threads are terminated. The runtime aborts all the background threads when foreground threads are stopped. If a thread is created using a thread pool, then these threads are executed as background threads. Note that when an unmanaged thread enters the managed execution environment, it is executed as a background thread.</p>
<p class="mce-root"/>
<p>Let's jump into an example to understand the difference between foreground and background threads:</p>
<pre>public static void BackgroundThread()<br/>{<br/>    Console.WriteLine("Thread Id: {0}" + Environment.NewLine + "Thread State: {1}" + Environment.NewLine + "Priority {2}" + Environment.NewLine + "IsBackground: {3}",<br/>                              Thread.CurrentThread.ManagedThreadId,<br/>                              Thread.CurrentThread.ThreadState,<br/>                              Thread.CurrentThread.Priority,<br/>                              Thread.CurrentThread.IsBackground);<br/>    var th = new Thread(ExecuteBackgroundThread);<br/>    th.IsBackground = true;<br/>    th.Start();<br/>    Thread.Sleep(500);<br/>    Console.WriteLine("Main thread ({0}) exiting...",Thread.CurrentThread.ManagedThreadId);<br/>}<br/>private static void ExecuteBackgroundThread()<br/>{<br/>    var sw = Stopwatch.StartNew();<br/>    Console.WriteLine("Thread Id: {0}" + Environment.NewLine + "Thread State: {1}" +         Environment.NewLine + "Priority {2}" + Environment.NewLine + "IsBackground {3}",<br/>                              Thread.CurrentThread.ManagedThreadId,<br/>                              Thread.CurrentThread.ThreadState,<br/>                              Thread.CurrentThread.Priority,<br/>                              Thread.CurrentThread.IsBackground);<br/>    do<br/>    {<br/>        Console.WriteLine("Thread {0}: Elapsed {1:N2} seconds",<br/>                                  Thread.CurrentThread.ManagedThreadId,<br/>                                  sw.ElapsedMilliseconds / 1000.0);<br/>        Thread.Sleep(2000);<br/>    } while (sw.ElapsedMilliseconds &lt;= 5000);<br/>    sw.Stop();<br/>}</pre>
<p>The following screenshot shows the output of the preceding code:</p>
<div><img src="img/67377582-684b-4fc3-ac09-29a9b7eb8ac8.png" style=""/></div>
<p>As you can see, the primary thread was created as a foreground thread while the worker thread was created as a background thread. When we stopped the primary thread, it stopped the background thread. This is why the elapsed time statement was not displayed through the loop, which is running for 5 seconds (<kbd>while(sw.ElapsedMilliseconds &lt;=5000)</kbd>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread states</h1>
                
            
            
                
<p>When a thread is created, it will be in an <strong>Unstarted</strong> state until the <strong>Start</strong> method is invoked. A thread is always in at least one state and sometimes it may be in multiple states at the same time. In the following diagram, each oval represents a state. The text on each line represents the action that is performed:</p>
<div><img src="img/575bba21-2b4f-4c23-8c09-30d501edae13.png" style=""/></div>
<p class="mce-root"/>
<p>A thread can be in two different states at the same time. For example, if a thread is in a waiting state and another thread aborts, it can be in both the <strong>Wait/Join Sleep</strong> and <strong>Abort Requested</strong> states. When the thread returns to the wait call, it will receive a <kbd>ThreadAbortException</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Destroying threads</h1>
                
            
            
                
<p>The <kbd>Thread.Abort</kbd> method is used to stop a thread. Once aborted, it cannot be restarted. However, when you invoke <kbd>Thread.Abort</kbd>, it doesn't terminate the thread immediately since the <kbd>Thread.Abort</kbd> statement throws a <kbd>ThreadAbortException</kbd>, which needs to be caught. Then, the cleanup code should be executed. If you call the <kbd>Thread.Join</kbd> method, this will make sure the thread waits until the other thread's execution is completed. The <kbd>join</kbd> method depends on the timeout interval, so if it's not specified, then the wait is not guaranteed.</p>
<p>When your own code aborts a thread and you don't want to rethrow it, use the <kbd>ResetAbort</kbd> method. You will learn more about how to rethrow exceptions in <a href="7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml">Chapter 7</a>, <em>Implementing Exception Handling</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread pools</h1>
                
            
            
                
<p>A thread pool provides a pool of threads that can be used as worker threads and are managed by the system. This allows us to focus on application logic instead of managing threads. This is an easy way for us to use multiple threads. From .NET Framework 4 onward, it became easy to use thread pools as they allowed us to create tasks and perform asynchronous tasks. The <strong>Task Parallel Library</strong> (<strong>TPL</strong>) and asynchronous method calls are mainly dependent on the thread pool.</p>
<p>Threads that are created from a thread pool are background threads. Each thread uses default properties. When a thread completes its task, it is returned to a queue of waiting threads so that they can be reused. In turn, this reduces the cost of creating new threads for every task. You can have one thread pool per process.</p>
<p>.NET Framework allows us to set and get <kbd>MaxThread</kbd> for a thread pool, though the number of threads that can be queued is limited by available memory. Once the thread pool threads are busy, other tasks are queued until the threads are available.</p>
<p class="mce-root"/>
<p>It is important to understand that any unhandled exception in a thread pool will terminate this process. More information on thread pools can be found at <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool">https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool</a>.</p>
<p>The following example shows how we can create multiple threads using a thread pool:</p>
<pre> public static void PoolOfThreads()<br/> {<br/>     Console.WriteLine("Primary Thread Id: {0}" + Environment.NewLine + "Thread State: {1}" + Environment.NewLine + "Priority {2}" ,<br/>                              Thread.CurrentThread.ManagedThreadId,<br/>                              Thread.CurrentThread.ThreadState,<br/>                              Thread.CurrentThread.Priority);<br/>    PoolProcessmethod();<br/>    //Thread.CurrentThread.Join();<br/> }<br/>private static void PoolProcessmethod()<br/>{<br/>    for (int i = 0; i &lt; 5; i++)<br/>    {<br/>        ThreadPool.QueueUserWorkItem(new WaitCallback(PoolMethod)); <br/>    }<br/>}<br/>private static void PoolMethod(object callback)<br/>{<br/>    Thread.Sleep(1000);<br/>    Console.WriteLine("ThreadPool Thread Id: {0}" + Environment.NewLine + "Thread State: {1}" + Environment.NewLine + "Priority {2}" + Environment.NewLine + "IsBackground: {3}" +Environment.NewLine + "IsThreadPoolThread: {4}",<br/>                              Thread.CurrentThread.ManagedThreadId,<br/>                              Thread.CurrentThread.ThreadState,<br/>                              Thread.CurrentThread.Priority,<br/>                              Thread.CurrentThread.IsBackground,<br/>                              Thread.CurrentThread.IsThreadPoolThread);<br/>            <br/>}</pre>
<p>The following screenshot shows the output of running the preceding code:</p>
<div><img src="img/edce518e-f26b-4179-8b24-7f39e97f9179.png" style=""/></div>
<p>Her, we created five worked threads using the thread pool. If you uncomment <kbd>Thread.CurrentThread.Join</kbd> in the preceding code, the primary thread won't exit until all of the threads have been processed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread storage</h1>
                
            
            
                
<p>Thread-relative static fields and data slots are the two ways in which we can store data that is unique to the thread and application domain. Thread-relative static fields are defined at compile time and provide the best performance. Another benefit is that they do compile-time type checking. These fields are used when the requirement about what kind of data to be stored is clear beforehand. </p>
<p class="mce-root"/>
<p>Thread-relative static fields can be created using <kbd>ThreadStaticAttribute</kbd>.</p>
<p>There are scenarios where these storage requirements may arise at runtime. In such scenarios, we can opt for data slots. These are a bit slower than static fields. Since these are created at runtime, they store information as an object type. It is important for us to convert these objects into their respective types before using them.</p>
<p>.NET Framework allows us to create two types of data slots: named data slots and unnamed data slots. Named data slots use the <kbd>GetNamedDataSlot</kbd> method so that we can retrieve it as and when required. However, one disadvantage of <kbd>NamedDataslot</kbd> is when two threads from the same application domain use the same data slot in two different components of code and execute them at the same time. When this happens, they can corrupt each other's data.</p>
<p><kbd>ThreadLocal&lt;T&gt;</kbd> can be used to create local data storage.</p>
<p>These two ways of storing data can be referred to as <strong>thread-local storage</strong> (<strong>TLS</strong>). A couple of the benefits of managed TLS are as follows:</p>
<ul>
<li>Within an application domain, one thread cannot modify data from another thread, even when both threads use the same field or slot</li>
<li>When a thread accesses the same field or slot from multiple application domains, a separate value is maintained in each application domain</li>
</ul>
<p>Now, we will jump into an example and look at how the <kbd>ThreadStatic</kbd> attribute can be used. In the following example, a static variable is being defined and decorated with the <kbd>ThreadStatic</kbd> attribute. This ensures that each thread has its own copy of the variable. When you execute the following program, you will observe that <kbd>_intvariable</kbd> goes up to 6 for each thread:</p>
<pre>[ThreadStatic]<br/>public static int _intvariable;<br/>public static void ThreadStaticSample()<br/>{<br/>    //Start three threads<br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            _intvariable++;<br/>            Console.WriteLine($"Thread Id:{Thread.CurrentThread.ManagedThreadId}, Int field Value:{_intvariable}");<br/>        }<br/>    }).Start();<br/><br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            _intvariable++;<br/>            Console.WriteLine($"Thread Id:{Thread.CurrentThread.ManagedThreadId}, Int field Value:{_intvariable}");<br/>        }<br/>    }).Start();<br/><br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            _intvariable++;<br/>            Console.WriteLine($"Thread Id:{Thread.CurrentThread.ManagedThreadId}, Int field Value:{_intvariable}");<br/>        }<br/>    }).Start();<br/>  <br/>}<br/><br/></pre>
<p>The following screenshot shows the output of running the preceding program. Comment the <kbd>ThreadStatic</kbd> attribute and run the program againâ€”you will find that the <kbd>_intvariable</kbd> value goes up to 18 as each thread updates its value:</p>
<div><img src="img/f843c56b-b2b7-4ab2-9fd3-998b1398a21c.png" style=""/></div>
<p class="mce-root"/>
<p>Let's see how we can use <kbd>ThreadLocal&lt;T&gt;</kbd> to create local storage:</p>
<pre> public static ThreadLocal&lt;string&gt; _threadstring = new ThreadLocal&lt;string&gt;(() =&gt; {<br/>    return "Thread " + Thread.CurrentThread.ManagedThreadId; });<br/>public static void ThreadLocalSample()<br/>{<br/>    <br/>    //Start three threads<br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            Console.WriteLine($"First Thread string :{_threadstring}");<br/>        }<br/>    }).Start();<br/><br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            Console.WriteLine($"Second Thread string :{_threadstring}");<br/>        }<br/>    }).Start();<br/><br/>    new Thread(() =&gt;<br/>    {<br/>        for (int i = 0; i &lt;= 5; i++)<br/>        {<br/>            Console.WriteLine($"Third Thread string :{_threadstring}");<br/>        }<br/>    }).Start();<br/><br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/8d01b785-5fbc-4c3a-a685-ca0dcaeb507e.png" style=""/></div>
<p>Now that we've understood how to manage threads, let's look at how to synchronize data in multithreading.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronizing data in multithreading</h1>
                
            
            
                
<p>Multiple threads can invoke the methods or properties of an object, which can make the state of an object invalid. It is possible to make conflicting changes regarding two or more threads on the same object. This makes it important to synchronize these calls, which will allow us to avoid such issues. When the members of a class are protected from conflicting changes, they are known to be <strong>thread-safe</strong>.</p>
<p>The CLR provides multiple ways in which we can synchronize access to the object instance and static members:</p>
<ul>
<li>Synchronize code regions</li>
<li>Manual synchronization</li>
<li>Synchronize context</li>
<li>Thread-safe collection</li>
</ul>
<p>By default, there is no synchronization for objects, which means any thread can access methods and properties at any time.</p>
<p class="mce-root"/>
<p>Synchronizing code regions allows us to synchronize blocks of code, methods, and static methods. However, synchronizing static fields is not supported. Synchronizing is possible if we use a <kbd>Monitor</kbd> class or a keyword. C# supports the <kbd>lock</kbd> keyword, which can be used to mark blocks of code for synchronization.</p>
<p>When applied, the threads attempt to acquire the lock while executing the code. If another thread has already been acquired by the lock on this block, then the thread blocks until the lock is available. The lock is released when the thread has executed the code block or exits in any other way.</p>
<p><kbd>MethodImplAttribute</kbd> and <kbd>MethodImplOptions.Synchronized</kbd> give us the same results as using <kbd>Monitor</kbd> or keywords to lock the code block.</p>
<p>Let's look at an example to understand lock statements with tasks. We will learn more about tasks in the upcoming sections.</p>
<p>For the purpose of this example, we created an <kbd>Account</kbd> class that synchronizes its private field balance amount by locking it to an instance. This ensures that no two threads update this field at the same time:</p>
<pre> internal class BankAcc<br/>    {<br/>        private readonly object AcountBalLock = new object();<br/>        private decimal balanceamount;<br/>        public BankAcc(decimal iBal)<br/>        {<br/>            balanceamount = iBal;<br/>        }<br/>        public decimal Debit(decimal amt)<br/>        {<br/>            lock (AcountBalLock)<br/>            {<br/>                if (balanceamount &gt;= amt)<br/>                {<br/>                    Console.WriteLine($"Balance before debit :{balanceamount,5}");<br/>                    Console.WriteLine($"Amount to debit     :{amt,5}");<br/>                    balanceamount = balanceamount - amt;<br/>                    Console.WriteLine($"Balance after debit  :{balanceamount,5}");<br/>                    return amt;<br/>                }<br/>                else<br/>                {<br/>                    return 0;<br/>                }<br/>            }<br/>        }<br/>        public void Credit(decimal amt)<br/>        {<br/>            lock (AcountBalLock)<br/>            {<br/>                Console.WriteLine($"Balance before credit:{balanceamount,5}");<br/>                Console.WriteLine($"Amount to credit        :{amt,5}");<br/>                balanceamount = balanceamount + amt;<br/>                Console.WriteLine($"Balance after credit :{balanceamount,5}");<br/>            }<br/>        }<br/>    }<br/></pre>
<p>The <kbd>TestLockStatements(</kbd><kbd>)</kbd> method looks as follows:</p>
<pre>//Create methods to test this Account class<br/>public static void TestLockStatements()<br/>{<br/>    var account = new BankAcc(1000);<br/>    var tasks = new Task[2];<br/>    for (int i = 0; i &lt; tasks.Length; i++)<br/>    {<br/>        tasks[i] = Task.Run(() =&gt; UpdateAccount(account));<br/>    }<br/>    Task.WaitAll(tasks);<br/>}<br/>private static void UpdateAccount(BankAcc account)<br/>{<br/>    var rnd = new Random();<br/>    for (int i = 0; i &lt; 10; i++)<br/>    {<br/>        var amount = rnd.Next(1, 1000);<br/>        bool doCredit = rnd.NextDouble() &lt; 0.5;<br/>        if (doCredit)<br/>        {<br/>            account.Credit(amount);<br/>        }<br/>        else<br/>        {<br/>            account.Debit(amount);<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We are creating two tasks, and each task invokes <kbd>UpdateMethod</kbd>. This method loops 10 times and updates the account balance using either credit or debit methods. Because we are using the <kbd>lock(obj)</kbd> field at the instance level, the balance amount field won't be updated at the same time.</p>
<p>The following code shows the desired output:</p>
<pre>Balance before debit : 1000<br/>Amount to debit : 972<br/>Balance after debit : 28<br/>Balance before credit: 28<br/>Amount to credit : 922<br/>Balance after credit : 950<br/>Balance before credit: 950<br/>Amount to credit : 99<br/>Balance after credit : 1049<br/>Balance before debit : 1049<br/>Amount to debit : 719<br/>Balance after debit : 330<br/>Balance before credit: 330<br/>Amount to credit : 865<br/>Balance after credit : 1195<br/>Balance before debit : 1195<br/>Amount to debit : 962<br/>Balance after debit : 233<br/>Balance before credit: 233<br/>Amount to credit : 882<br/>Balance after credit : 1115<br/>Balance before credit: 1115<br/>Amount to credit : 649<br/>Balance after credit : 1764<br/>Balance before credit: 1764<br/>Amount to credit : 594<br/>Balance after credit : 2358<br/>Balance before debit : 2358<br/>Amount to debit : 696<br/>Balance after debit : 1662<br/>Balance before credit: 1662<br/>Amount to credit : 922<br/>Balance after credit : 2584<br/>Balance before credit: 2584<br/>Amount to credit : 99<br/>Balance after credit : 2683<br/>Balance before debit : 2683<br/>Amount to debit : 719<br/>Balance after debit : 1964<br/>Balance before credit: 1964<br/>Amount to credit : 865<br/>Balance after credit : 2829<br/>Balance before debit : 2829<br/>Amount to debit : 962<br/>Balance after debit : 1867<br/>Balance before credit: 1867<br/>Amount to credit : 882<br/>Balance after credit : 2749<br/>Balance before credit: 2749<br/>Amount to credit : 649<br/>Balance after credit : 3398<br/>Balance before credit: 3398<br/>Amount to credit : 594<br/>Balance after credit : 3992<br/>Balance before debit : 3992<br/>Amount to debit : 696<br/>Balance after debit : 3296<br/>Press any key to exit.</pre>
<p>Accessing shared variables across multiple threads may cause data integrity issues. Such issues can be addressed by using a synchronization primitive. These are derived by the <kbd>System.Threading.WaitHandle</kbd> class. While performing manual synchronization, a primitive can protect access to shared resources. Different synchronization primitive instances are used to protect access to a resource or some parts of code access, which allows multiple threads to access a resource concurrently.</p>
<p>You can read more about synchronization primitives at <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives" target="_blank">https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives</a>.</p>
<p>The <kbd>System.Collections.Concurrent</kbd> namespace was introduced by .NET Framework and can be used without additional synchronization in the user code. This namespace includes several collection classes that are both thread-safe and scalable. This allows multiple threads to add or remove items from these collections.</p>
<p>More information on these thread-safe collections can be found at <a href="https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index">https://docs.microsoft.com/en-us/dotnet/standard/collections/thread-safe/index</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multithreading</h1>
                
            
            
                
<p>Developers are allowed to create multiple threads within a process and manage them throughout the program's execution. This allows us to focus on the application logic instead of managing threads. However, starting with .NET Framework 4, we can create multithreaded programs using the following methods:</p>
<ul>
<li>TPL</li>
<li><strong>Parallel Language-Integrated Query</strong>(<strong>PLINQ</strong>)</li>
</ul>
<p>To understand both of these features, we need to talk about parallel programming.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Parallel programming</h1>
                
            
            
                
<p><strong>Parallel programming</strong> helps the developer take advantage of the hardware on workstations where multiple CPU cores are available. They allow multiple threads to be executed in parallel.</p>
<p>In previous versions, parallelization required low-level manipulation of threads and locks. From .NET Framework 4 onward, enhanced support for parallel programming was provided in the form of the runtime, class library types, and diagnostic tools. </p>
<p class="mce-root"/>
<p>The following diagram shows the high-level architecture of parallel programming:</p>
<div><img src="img/955ad58e-8fd8-4cce-9825-93e9914c6db6.png"/></div>
<p>In the upcoming sections, we will talk about some of the components listed in the preceding architecture diagram.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">TPL</h1>
                
            
            
                
<p>TPL makes developers more productive by creating parallel and concurrent applications. These are available as public types in the <kbd>System.Threading</kbd> and <kbd>System.Threading.Tasks</kbd> namespaces. TPL allows us to maximize code performance while focusing on program work. TPL is based on tasks, which represent a thread or thread pool. When one or more tasks are run concurrently, this is known as task parallelism. A task has a couple of benefits: being scalable and efficient, and having more programmatic control than threads.</p>
<p>Because TPL handles the partitioning of the work, scheduling, cancellation, state, and other low-level details, it can scale the degree of concurrency dynamically and use the system resources or processors that are available.</p>
<p class="mce-root"/>
<p>It is important to be aware of when to apply parallel programming, otherwise the overhead of parallelization decreases the speed of code execution. A basic understanding of threading concepts such as locks and deadlocks is important so that we can use TPL effectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data parallelism</h1>
                
            
            
                
<p>When an operation can be performed concurrently on source collection elements, it is referred to as data parallelism. In this process, the source collection is partitioned into multiple threads and executed in parallel. .NET Framework supports data parallelism via the <kbd>System.Threading.Tasks.Parallel</kbd> class. Methods such as <kbd>Parallel.For</kbd> and <kbd>Parallel.ForEach</kbd> are defined in this class. When you use these methods, the framework manages all the low-level work for us. </p>
<p>A task represents an asynchronous operation and does not return a value. These are defined in the <kbd>System.Threading.Tasks</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using tasks</h1>
                
            
            
                
<p>A task represents an operation that may or may not return a value and executes asynchronously. Since they are executed asynchronously, they are executed as worker threads from the thread pool rather than the primary thread. This allows us to use the <kbd>isCanceled</kbd> and <kbd>IsCompleted</kbd> properties to understand the state of the task. You can also make a task run synchronously, which will be executed on the main or primary thread.</p>
<p>A task can implement the <kbd>IAsyncResult</kbd> and <kbd>IDisposable</kbd> interfaces like so:</p>
<pre>public class Task : IAsyncResult, IDisposable</pre>
<p>Let's look at an example so that we can understand how we can create and initiate a task in different ways. In this example, we will use an action delegate that takes an argument of the <kbd>object</kbd> type:</p>
<pre>public static void Run()<br/>{<br/>    Action&lt;object&gt; action = (object obj) =&gt;<br/>    {<br/>        Console.WriteLine("Task={0}, Milliseconds to sleep={1}, Thread={2}",Task.CurrentId, obj,<br/>        Thread.CurrentThread.ManagedThreadId);<br/>        int value = Convert.ToInt32(obj);<br/>        Thread.Sleep(value);<br/>    };<br/><br/>    Task t1 = new Task(action, 1000);<br/>    Task t2 = Task.Factory.StartNew(action, 5000);<br/>    t2.Wait();<br/>    t1.Start();<br/>    Console.WriteLine("t1 has been started. (Main Thread={0})",<br/>                      Thread.CurrentThread.ManagedThreadId);<br/>    t1.Wait();<br/><br/>    int taskData = 4000;<br/>    Task t3 = Task.Run(() =&gt; {<br/>        Console.WriteLine("Task={0}, Milliseconds to sleep={1}, Thread={2}",<br/>                          Task.CurrentId, taskData,<br/>                           Thread.CurrentThread.ManagedThreadId);<br/>    });<br/>    t3.Wait();<br/><br/>    Task t4 = new Task(action, 3000);<br/>    t4.RunSynchronously();<br/>    t4.Wait();<br/>}</pre>
<p>Here, we create four different tasks. For the first task, we used start methods, while for the second task, we used a task <kbd>factory.startnew</kbd> method. The third task was started using the <kbd>run(Action)</kbd> method, while the fourth task was executed synchronously on the main thread using the run synchronously method. Here, tasks 1, 2, and 3 are worker threads that are using a thread pool, while task 4 is executing on the primary thread.</p>
<p>The following screenshot shows the output of running the preceding code:</p>
<div><img src="img/2796ffa5-1d98-4b42-b575-49621395d9e5.png" style=""/></div>
<p>The <kbd>Wait</kbd> method is similar to <kbd>Thread.Join</kbd>, which waits until the task completes. This is useful when synchronizing the execution of calling threads and asynchronous tasks since we can wait for one or more threads to complete. The <kbd>Wait</kbd> method also accepts certain parameters that allow us to conditionally wait for a task to complete.</p>
<p class="mce-root"/>
<p>The following table shows the different options that are available for a thread when it comes to waiting:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 32.6598%"><kbd>Wait</kbd></td>
<td style="width: 66.7216%">Waits for the task's execution to complete.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>Wait(int32)</kbd></td>
<td style="width: 66.7216%">Makes the tasks wait for a specified number of milliseconds before executing.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>Wait(Timespan)</kbd></td>
<td style="width: 66.7216%">Waits for the task's execution to complete within a specified time interval.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>Wait(CancellationToken)</kbd></td>
<td style="width: 66.7216%">Waits for the task's execution to complete. The wait is terminated if <kbd>cancellationToken</kbd> is issued before the task's execution is completed.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>Wait(Int32, CancellationToken)</kbd></td>
<td style="width: 66.7216%">Waits for the task's execution to complete. The wait terminates on timeout or when a cancellation token is issued before the task completes.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>WaitAll</kbd></td>
<td style="width: 66.7216%">Waits for all the provided tasks to complete their execution. Similar to the <kbd>Wait</kbd> method, <kbd>WaitAll</kbd> tasks multiple parameters and performs them accordingly.</td>
</tr>
<tr>
<td style="width: 32.6598%"><kbd>WaitAny</kbd></td>
<td style="width: 66.7216%">Waits for the provided task to complete its execution. Similar to the <kbd>Wait</kbd> method, <kbd>WaitAll</kbd> tasks multiple parameters and performs them accordingly.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Tasks support two other methods: <kbd>WhenAll</kbd> and <kbd>WhenAny</kbd>. Now, <kbd>WhenAll</kbd> is used to create a task that will complete its execution when all the provided tasks have been completed. Similarly, <kbd>WhenAny</kbd> creates tasks and completes when the provided task completes its execution.</p>
<p>A task can also return a value. However, reading the result of a task means waiting until its execution has completed. Without completing its execution, it isn't possible to use the result object. The following is an example of this:</p>
<pre>public static void TaskReturnSample()<br/>{<br/>    Task&lt;int&gt; t = Task.Run(() =&gt; { return 30 + 40; });<br/>    Console.WriteLine($"Result of 30+40: {t.Result}");<br/>}</pre>
<p>By executing the preceding code, you will see that the main thread waits until the task returns a value. Then, it displays a <kbd>Press any key to exit</kbd> message:</p>
<pre>Result of 30+40: 70<br/>Press any key to exit.</pre>
<p>It's also possible to add a continuation task. .NET Framework provides a keyword called <kbd>ContinueWith</kbd>, which allows you to create a new task and execute it once the previous tasks have finished executing. In the following code, we are instructing the task to continue with the result from the parent task:</p>
<pre>public static void TaskContinueWithSample()<br/>{<br/>    Task&lt;int&gt; t = Task.Run(() =&gt; <br/>        {<br/>            return 30 + 40;<br/>        }<br/>    ).ContinueWith((t1) =&gt; <br/>    {<br/>        return t1.Result * 10;<br/>    });<br/>    Console.WriteLine($"Result of two tasks: {t.Result}");<br/>}</pre>
<p>When task <kbd>t</kbd> has completed its execution, the result is used in the second task, <kbd>t1</kbd>, and the final result is displayed:</p>
<pre>Result of two tasks: 700<br/>Press any key to exit.</pre>
<p><kbd>ContinueWith</kbd> has a couple of overload methods that allow us to configure when the continuation task should execute, such as when a task is canceled or completed successfully. To make this configuration work, we will use <kbd>TaskContinuationOptions</kbd>. You can find more of the options that are available at <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions?view=netframework-4.7.2</a>.</p>
<p>The following code block shows how we can use <kbd>continuationOptions</kbd>:</p>
<pre>Task&lt;int&gt; t = Task.Run(() =&gt; <br/>{<br/>    return 30 + 40;<br/>}<br/>).ContinueWith((t1) =&gt; <br/>{<br/>    return t1.Result * 10;<br/>},TaskContinuationOptions.OnlyOnRanToCompletion);</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>TaskFactory</kbd> supports creating and scheduling tasks. It also allows us to do the following:</p>
<ul>
<li>Create a task and start it immediately using the <kbd>StartNew</kbd> method</li>
<li>Create a task that starts when any one of the tasks in an array has completed by calling the <kbd>ContinueWhenAny</kbd> method</li>
<li>Create a task that starts when all the tasks in an array have completed by calling the <kbd>ContinueWhenAll</kbd> method</li>
</ul>
<p>Further reading on <kbd>TaskFactory</kbd> can be found at <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=netframework-4.7.2</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Parallel class</h1>
                
            
            
                
<p>The <kbd>System.Threading</kbd> class has another class named <kbd>Parallel</kbd>. This class provides parallel implementations for <kbd>For</kbd> and <kbd>ForEach</kbd> loops. Their implementation is similar to the sequential loop. When you use <kbd>ParallelFor</kbd> or <kbd>ParallelForEach</kbd>, the system automatically splits the process into multiple tasks and acquires locks if required. All of this low-level work is handled by TPL.</p>
<p>A sequential loop may look as follows:</p>
<pre>foreach (var item in sourceCollection) <br/>{     <br/>    Process(item); <br/>} </pre>
<p>The same loop can be represented using <kbd>Parallel</kbd> as follows:</p>
<pre>Parallel.ForEach(sourceCollection, item =&gt; Process(item)); </pre>
<p>TPL manages the data source and creates partitions so that the loop can operate on multiple parts in parallel. Each task will be partitioned by the task scheduler as per system resources and workload. Then, if the workload becomes unbalanced, the work will be redistributed into multiple threads and processes by the task scheduler.</p>
<p>Parallel programming can increase performance when you have a lot of work to be done in parallel. If this isn't the case, it can become a costly affair. </p>
<p>It is important to understand how parallelism works in a scenario given. In the following example, we'll look at how we can use <kbd>Parallel.For</kbd> and make a time comparison between sequential and parallel loops.</p>
<p>Here, we are defining an array of integers and calculating the sum and product of each element of the array. In the main program, we invoke this method using sequential and parallel loops and calculate how much time each loop takes to complete the process:</p>
<pre>static int[] _values = Enumerable.Range(0, 1000).ToArray();<br/><br/>private static void SumAndProduct(int x)<br/>{<br/>    int sum = 0;<br/>    int product = 1;<br/>    foreach (var element in _values)<br/>    {<br/>        sum += element;<br/>        product *= element;<br/>    }<br/>}<br/><br/>public static void CallSumAndProduct()<br/>{<br/>    const int max = 10;<br/>    const int inner = 100000;<br/>    var s1 = Stopwatch.StartNew();<br/>    for (int i = 0; i &lt; max; i++)<br/>    {<br/>        Parallel.For(0, inner, SumAndProduct);<br/>    }<br/>    s1.Stop();<br/><br/>    Console.WriteLine("Elapsed time in seconds for ParallelLoop: " + s1.Elapsed.Seconds);<br/><br/>    var s2 = Stopwatch.StartNew();<br/>    for (int i = 0; i &lt; max; i++)<br/>    {<br/>        for (int z = 0; z &lt; inner; z++)<br/>        {<br/>            SumAndProduct(z);<br/>        }<br/>    }<br/>    s2.Stop();<br/>    <br/>    Console.WriteLine("Elapsed time in seconds for Sequential Loop: " + s2.Elapsed.Seconds );<br/>}</pre>
<p>In the preceding code, we executed two loops: one using a parallel loop and the other using a sequential loop. The results show the time each operation took:</p>
<div><img src="img/2683561f-3fd8-40d0-855f-e7275065851f.png" style=""/></div>
<p><kbd>System.Threading.Tasks.Parallel</kbd> comes with multiple helper classes, such as <kbd>ParallelLoopResult</kbd>, <kbd>ParallelLoopState</kbd>, and <kbd>ParallelOptions</kbd>.</p>
<p><kbd>ParallelLoopResult</kbd> provides the completion status of the parallel loop, as shown here:</p>
<pre>ParallelLoopResult result = Parallel.For(int i, ParallelLoopState loopstate) =&gt;{});</pre>
<p><kbd>ParallelLoopState</kbd> allows iterations of parallel loops to interact with other iterations. Finally, <kbd>LoopState</kbd> allows you to identify any exceptions in iterations, break from an iteration, stop an iteration, identify if any iteration has invoked break or stop, and break long-running iterations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">PLINQ</h1>
                
            
            
                
<p><strong>Language-Integrated Query</strong> (<strong>LINQ</strong>) was introduced in .NET Framework 3.5. It allows us to query in-memory collections such as <kbd>List&lt;T&gt;</kbd>. You will learn more about LINQ in <a href="75481977-f6a3-41af-ab1e-e3b112dd9aad.xhtml"/><a href="75481977-f6a3-41af-ab1e-e3b112dd9aad.xhtml">Chapter 15</a>, <em>Using LINQ Queries</em>. However, if you want to find out more sooner, more information can be found at <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/index</a>.</p>
<p>PLINQ is the parallel implementation of the LINQ pattern. They resemble LINQ queries and operate on any in-memory collections but differ in terms of execution. PLINQ uses all the available processors in the system. However, the processors are limited to 64  bits. This is achieved by partitioning the data source into smaller tasks and executing each task on separate worker threads on multiple processors. </p>
<p>Most of the standard query operators are implemented in the <kbd>System.Linq.ParallelEnumerable</kbd> class. The following table lists the various parallel execution-specific methods:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 20.3055%"><kbd>AsParallel</kbd></td>
<td style="width: 79.0835%">When you want a system to perform parallel execution on an enumerable collection, the <kbd>AsParallel</kbd> instruction can be provided to the system.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>AsSequential</kbd></td>
<td style="width: 79.0835%">Instructing the system to run sequentially can be achieved by using <kbd>AsSequential</kbd>.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>AsOrdered</kbd></td>
<td style="width: 79.0835%">To maintain the order on the result set, use <kbd>AsOrdered</kbd>.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>AsUnordered</kbd></td>
<td style="width: 79.0835%">To not maintain the order on the result set, use <kbd>AsUnordered</kbd>.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>WithCancellation</kbd></td>
<td style="width: 79.0835%">A cancellation token carries the user's request to cancel the execution. This has to be monitored so that execution can be canceled at any time.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>WithDegreeofParallelism</kbd></td>
<td style="width: 79.0835%">Controls the number of processors to be used in a parallel query.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>WithMergeOptions</kbd></td>
<td style="width: 79.0835%">Provides options so that we can merge results to the parent task/thread/result set.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>WithExecutionMode</kbd></td>
<td style="width: 79.0835%">Forces the runtime to use either parallel or sequential modes.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>ForAll</kbd></td>
<td style="width: 79.0835%">Allows results to be processed in parallel by not merging to the parent thread.</td>
</tr>
<tr>
<td style="width: 20.3055%"><kbd>Aggregate</kbd></td>
<td style="width: 79.0835%">
<p class="mce-root">A unique PLINQ overload to enable intermediate aggregation over thread-local partitions. Also allows us to merge the final aggregation to combine the results of all partitions.</p>
</td>
</tr>
</tbody>
</table>
<p>Let's try to use some of these methods so that we can understand them in more detail. The <kbd>AsParallel</kbd> extension method binds query operators such as <kbd>where</kbd> and <kbd>select</kbd> to the <kbd>parallelEnumerable</kbd> implementation. By simply specifying <kbd>AsParallel</kbd>, we tell the compiler to execute the query in parallel:</p>
<pre>public static void PrintEvenNumbers()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    var pResult = numbers.AsParallel().Where(i =&gt; i % 2 == 0).ToArray();<br/><br/>    foreach (int e in pResult)<br/>    {<br/>        Console.WriteLine(e);<br/>    }<br/><br/>}</pre>
<p>When executed, the preceding code block identifies all even numbers and prints them on the screen:</p>
<div><img src="img/ac50e5c7-f5b7-4416-9ae0-d113a7fa112a.png" style=""/></div>
<p>As you can see, the even numbers weren't printed in order. One thing to remember regarding parallel processing is that it does not guarantee any particular order. Try executing the code block multiple times and observe the output. It will differ each time since it is based on the number of processors that are available at the time of execution. </p>
<p>By using the <kbd>AsOrdered</kbd> operator, the code block accepts a range of numbers between 1 and 20. However, using <kbd>AsOrdered</kbd> will order the numbers:</p>
<pre>public static void PrintEvenNumbersOrdered()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    var pResult = numbers.AsParallel().AsOrdered()<br/>        .Where(i =&gt; i % 2 == 0).ToArray();<br/><br/>    foreach (int e in pResult)<br/>    {<br/>        Console.WriteLine(e);<br/>    }<br/><br/>}</pre>
<p>This example shows how we can maintain the order of the result set when using <kbd>Parallel</kbd>:</p>
<pre>2<br/>4<br/>6<br/>8<br/>10<br/>12<br/>14<br/>16<br/>18<br/>20<br/>Press any key to exit.</pre>
<p>When you execute a code block using PLINQ, the runtime analyzes whether it is safe to parallelize the query. If it is, it partitions the query into tasks and then runs them concurrently. If it isn't safe to parallelize the query, it executes the query in a sequential pattern. In terms of performance, using a sequential algorithm is better than using a parallel algorithm, so by default, PLINQ selects the sequential algorithm. Using <kbd>ExecutionMode</kbd> will allow us to instruct PLINQ to select the parallel algorithm.</p>
<p>The following code block shows how we can use <kbd>ExecutionMode</kbd><strong>:</strong></p>
<pre>public static void PrintEvenNumbersExecutionMode()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    var pResult = numbers.AsParallel().WithExecutionMode(ParallelExecutionMode.ForceParallelism)<br/>        .Where(i =&gt; i % 2 == 0).ToArray();<br/><br/>    foreach (int e in pResult)<br/>    {<br/>        Console.WriteLine(e);<br/>    }<br/>}</pre>
<p>As we mentioned previously, PLINQ uses all the processors by default. However, by using the <kbd>WihtDegreeofParallelism</kbd> method, we can control the number of processors to be used:</p>
<pre>public static void PrintEvenNumbersDegreeOfParallel()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    var pResult = numbers.AsParallel().WithDegreeOfParallelism(3)<br/>        .Where(i =&gt; i % 2 == 0).ToArray();<br/><br/>    foreach (int e in pResult)<br/>    {<br/>        Console.WriteLine(e);<br/>    }<br/><br/>}</pre>
<p>Execute the preceding code block by changing the number of processors and observe the output. In the first scenario, we left the system to use the available cores/processors, but in the second one, we instructed the system to use three cores. You will see that the difference in performance is based on your system's configuration.</p>
<p>PLINQ also comes with a method called <kbd>AsSequential</kbd>. This is used to instruct PLINQ to execute queries sequentially until <kbd>AsParallel</kbd> is called.</p>
<p><kbd>forEach</kbd> can be used to iterate through all the results of a PLINQ query and merges the output from each task to the parent thread. In the preceding examples, we used <kbd>forEach</kbd> to display even numbers.</p>
<p><kbd>forEach</kbd> can be used to preserve the order of the PLINQ query results. So, when order preservation is not required and we want to achieve faster query execution, we can use the <kbd>ForAll</kbd> method. <kbd>ForAll</kbd> does not perform the final merge step; instead, it parallelizes the processing of results. The following code block is using <kbd>ForAll</kbd> to print output to the screen:</p>
<pre>public static void PrintEvenNumbersForAll()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    var pResult = numbers.AsParallel().Where(i =&gt; i % 2 == 0);<br/><br/>    pResult.ForAll(e =&gt; Console.WriteLine(e));<br/>}</pre>
<p>In this scenario, the I/O is being used by multiple tasks, so the numbers will appear in a random order:</p>
<div><img src="img/5d0ec129-6fe0-48d5-a435-dd2e500666d9.png" style=""/></div>
<p>When PLINQ executes in multiple threads, as the code runs, the application logic may fail in one or more threads. PLINQ uses the <kbd>Aggregate</kbd> exception to encapsulate all the exceptions that are thrown by a query and sends them back to the calling thread. When doing this, you need to have one <kbd>try..catch</kbd> block on the calling thread. When you get the results from the query, the developer can traverse through all the exceptions encapsulated in <kbd>AggregatedException</kbd>:</p>
<pre>public static void PrintEvenNumbersExceptions()<br/>{<br/>    var numbers = Enumerable.Range(1, 20);<br/>    try<br/>    {<br/>        var pResult = numbers.AsParallel().Where(i =&gt; IsDivisibleBy2(i));<br/><br/>        pResult.ForAll(e =&gt; Console.WriteLine(e));<br/>    }<br/>    catch (AggregateException ex)<br/>    {<br/>        Console.WriteLine("There were {0} exceptions", ex.InnerExceptions.Count);<br/>        foreach (Exception e in ex.InnerExceptions)<br/>        {<br/>            Console.WriteLine("Exception Type: {0} and Exception Message: {1}", e.GetType().Name,e.Message);<br/>        }<br/>    }<br/>}<br/><br/>private static bool IsDivisibleBy2(int num)<br/>{<br/>    if (num % 3 == 0) throw new ArgumentException(string.Format("The number {0} is divisible by 3", num));<br/>   return num % 2 == 0;<br/>}</pre>
<p>The preceding code block is writing all the details from an exception that was thrown in a PLINQ. Here, we are traversing and showcasing all six exceptions:</p>
<div><img src="img/a0f88c43-4592-4dbc-9f2e-836dd9016e98.png" style=""/></div>
<p>You can loop through the <kbd>InnerExceptions</kbd> property and take necessary actions. We will look at inner exceptions in more detail in <a href="7c2b2a82-6a5c-4c96-a877-04d8a6e26ef0.xhtml">Chapter 7</a>, <em>Implementing Exception Handling</em>. However, in this case, when a PLINQ is executed, instead of terminating the execution on an exception, it will run through all the iterations and provide the final results.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Asynchronous programming with async and await</h1>
                
            
            
                
<p><strong>Asynchronous programming</strong> can help you enhance the responsiveness and performance of an application. In a traditional approach, it is difficult to write and maintain asynchronous code. However, C# 5 introduced two new keywords that simplify asynchronous programming: <kbd>async</kbd> and <kbd>await</kbd>. When encountered, the C# compiler does all the difficult work for you. It resembles synchronous code. <kbd>Task</kbd> and <kbd>Task&lt;T&gt;</kbd> are at the core of asynchronous programming.</p>
<p>Any I/O-bound or CPU-bound code can utilize asynchronous programming. In the case of IO-bound code, when you want to return a task from an <kbd>async</kbd> method, we use the <kbd>await</kbd> operation, whereas in CPU-bound code we wait for the operation that started a background thread using <kbd>Task.Run</kbd>.</p>
<p>When the <kbd>await</kbd> keyword is used, it returns control to the calling methods, thus allowing the UI to be responsive. </p>
<p>Internally, when the compiler encounters the <kbd>async</kbd> keyword, it splits the method into tasks, and each task is marked with the <kbd>await</kbd> keyword. The <kbd>await</kbd> keyword generates code that will check whether the asynchronous operation has already completed; that is, the C# compiler transforms the code into a state machine that keeps track of the metadata related to each task/thread so that it can resume execution when the background task has finished executing:</p>
<pre>private readonly HttpClient _httpClient = new HttpClient();<br/><br/>public async Task&lt;int&gt; GetDotNetCountAsync()<br/>{<br/>    var html = await _httpClient.GetStringAsync("https://dotnetfoundation.org");<br/>    <br/>    return Regex.Matches(html, @"\.NET").Count;<br/>}<br/><br/>public void TestAsyncMethods()<br/>{<br/>    Console.WriteLine("Invoking GetDotNetCountAsync method");<br/>    int count = GetDotNetCountAsync().Result;<br/>    Console.WriteLine($"Number of times .NET keyword displayed is {count}");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code block, we are trying to find how many times a specific word has been used on a website. The output of the previous code is as follows:</p>
<pre>Invoking GetDotNetCountAsync method<br/>Number of times .NET keyword displayed is 22<br/>Press any key to exit.</pre>
<p>Here, we used the <kbd>async</kbd> keyword on the <kbd>GetDotnetCountAsync</kbd> method. Although the method is executed synchronously, the <kbd>await</kbd> keyword allows us to return to the calling method and wait until the <kbd>async</kbd> method has finished executing, which is when it returns the result.</p>
<p>It is important to understand that an <kbd>async</kbd> method body should always have an <kbd>await</kbd>, otherwise this method will never yield. No error is raised by the compiler either.</p>
<p>When writing asynchronous methods, you should always use <kbd>async</kbd> as the suffix. Note that <kbd>async</kbd> must be used for event handlers. This is the only method that allows <kbd>async</kbd> events handlers to work as events do not have return types.</p>
<p>You can read more about the <strong>Task-Based Asynchronous Pattern </strong>(<strong>TAP</strong>) from MSDN at <a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap" target="_blank">https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at threads, their properties, how we can use parameterized threads, and the difference between foreground and background threads with detailed examples. We also learned about thread states and how threads store and share data across multiple threads. This is where we discussed different synchronization methods. We focused on parallel programming, tasks and asynchronous programming using tasks, how to use parallel classes, and PLINQ.</p>
<p>In the next chapter, we will explore exception handling in C#. Exception handling helps us deal with any unexpected or exceptional situations that occur during program execution. Exception handling uses the <kbd>try</kbd>, <kbd>catch</kbd>, and <kbd>finally</kbd> blocks. These help developers try out actions that may or may not succeed, handle failures if they occur, and clean up unwanted resources, respectively.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>By default, the main method of your code block runs as which of the following?
<ol>
<li>Worker thread</li>
<li>Primary thread</li>
<li>Background thread</li>
<li>None of the above</li>
</ol>
</li>
<li>What action needs to be performed to move a thread to the run state when suspended?
<ol>
<li>Interrupt</li>
<li>Resume</li>
<li>Abort</li>
<li>Suspended</li>
</ol>
</li>
<li>What is the correct keyword to use while working on synchronization code regions?
<ol>
<li>Lock</li>
<li>Release</li>
<li>Getlock</li>
<li>Unlock</li>
</ol>
</li>
<li>A task may or may not return a value.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
<li> When working with PLINQ, the results are returned in order.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Answers</h1>
                
            
            
                
<ol>
<li><strong>Primary thread</strong></li>
<li><strong>Resume</strong></li>
<li><strong>Lock</strong></li>
<li><strong>True</strong></li>
<li><strong>False</strong></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>In this chapter, we talked about many features that .NET Framework offers that we can use in our applications. However, we didn't cover this topic in detail. Therefore, it may be useful for you to go through a couple of MSDN articles so that you can understand more about these concepts. Take a look at the following links:</p>
<ul>
<li>More on application domains can be found at <a href="https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads">https://docs.microsoft.com/en-us/dotnet/framework/app-domains/application-domains#application-domains-and-threads</a>.</li>
<li>More on threads and processes can be found at <a href="https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads" target="_blank">https://docs.microsoft.com/en-us/windows/desktop/procthread/processes-and-threads</a>.</li>
<li>The following documentation on parallel programming will help you understand some of the topics that we didn't cover in this chapter: <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming" target="_blank">https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/for-further-reading-parallel-programming</a>.</li>
<li>One of the concepts that you'll need to understand while working with tasks is task schedulers: <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2">https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskscheduler?view=netframework-4.7.2</a>.</li>
<li>The following article about async provides more information about all the moving pieces that are used when asynchronous operations are performed: <a href="https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth" target="_blank">https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth</a>.</li>
</ul>


            

            
        
    </body></html>