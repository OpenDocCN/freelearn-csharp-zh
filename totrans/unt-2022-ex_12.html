<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer138" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-161"><a id="_idTextAnchor169" class="pcalibre1 pcalibre calibre6"/>9</h1>
<h1 id="_idParaDest-162" class="calibre5"><a id="_idTextAnchor170" class="pcalibre1 pcalibre calibre6"/>Completing the Adventure Game</h1>
<p class="calibre3">In <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 8</em></span></a>, we started by creating a flexible health system that can be added to any object to give it health, take damage, and heal. The system is extensible, meaning the things that can deal with damage and apply healing can be anything without the need to modify the <strong class="source-inline">HealthSystem</strong> class because we used interfaces to implement the behavior (not concrete class types). With objects now able to take damage, we continued by updating <strong class="source-inline">Player</strong> and enemy objects to use health – so, we have the semblance of a real game in <span>the making.</span></p>
<p class="calibre3">We continued by creating a wave spawner that instantiates new enemies on a fixed time interval and integrates with the existing patrol behavior. This allows us to add more complex enemy behavior, which adds new challenges to <span>the game.</span></p>
<p class="calibre3">Finally, we further explored composition by refactoring some of our reusable components to explore a different approach to destroying the heal pickup object. The importance of good programming practices and interfaces to build flexible and extensible systems was highlighted <span>through examples.</span></p>
<p class="calibre3">In this chapter, we’ll complete the adventure game by creating a simple quest system for collecting key pieces in the level that are required for solving an entryway security puzzle lock on the habitat station located on the planet’s surface. We will also introduce a new global event system for keeping our code loosely coupled. The event system will efficiently manage communication between various quest system components throughout the code base, so we’ll tackle <span>that first.</span></p>
<p class="calibre3">In this chapter, we’re going to cover the following <span>main topics:</span></p>
<ul class="calibre17">
<li class="calibre15">Creating an event system in C# to tie things <span>together loosely</span></li>
<li class="calibre15">Creating a quest system for a collecting <span>keys mission</span></li>
<li class="calibre15">Solving the key puzzle and winning <span>the game</span></li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to create a quest system that is integrated across different classes while being loosely coupled (that is, reducing dependency by not having external (concrete) class references) and scalable via the use of a new reusable global event system we’ll also create. You’ll also be able to integrate and customize a puzzle system for <span>your use.</span></p>
<h1 id="_idParaDest-163" class="calibre5"><a id="_idTextAnchor171" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter while using the same artwork that was created for the project in this book, download the assets from the GitHub link provided in <span>this section.</span></p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop. Alternatively, you’ll need a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and <span>Affinity Photo).</span></p>
<p class="calibre3"><a id="_idTextAnchor172" class="pcalibre1 pcalibre calibre6"/>You can download the complete project from GitHub <span>at </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example</span></a><span>.</span></p>
<h1 id="_idParaDest-164" class="calibre5"><a id="_idTextAnchor173" class="pcalibre1 pcalibre calibre6"/>Creating an event system in C# to tie things together loosely</h1>
<p class="calibre3">We won’t need a UML <a id="_idIndexMarker866" class="pcalibre1 pcalibre calibre6"/>diagram here as the design is quite simple. We’ll use a <strong class="source-inline">Dictionary</strong> collection (a special kind of C# collection) to hold the name of an event that we’ll assign the event’s callback handlers. The added callback handlers will all be invoked when the event is triggered. Although I say this is simple, I didn’t introduce it earlier because a few programming concepts still needed to be <span>covered first.</span></p>
<h2 id="_idParaDest-165" class="calibre8"><a id="_idTextAnchor174" class="pcalibre1 pcalibre calibre6"/>The new event system</h2>
<p class="calibre3">Since a UML diagram <a id="_idIndexMarker867" class="pcalibre1 pcalibre calibre6"/>won’t illustrate the functionality of <strong class="source-inline">EventSystem</strong> very well in this case, I’ve decided to create the following diagram as an introduction to the implementation (see <span><em class="italic">Figure 9</em></span><span><em class="italic">.1</em></span><span>):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer121">
<img alt="Figure 9.1 – EventSystem diagram" src="image/B18347_09_1.jpg" class="calibre94"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – EventSystem diagram</p>
<p class="calibre3">Before looking at the following code, do a quick mental exercise to see if you can visualize what the code should look like from <span>this diagram.</span></p>
<p class="calibre3">Given this diagram, here is the class template that makes up the basis for our new event system, minus<a id="_idIndexMarker868" class="pcalibre1 pcalibre calibre6"/> some details we haven’t covered yet; is it similar to what you <span>anticipated seeing?</span></p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.Events;
using System;
using System.Collections.Generic;
public class EventSystem : MonoBehaviour
{
    private Dictionary&lt;string, Delegate&gt; _events
        = new();
    public void AddListener&lt;T&gt;(
        string eventName, UnityAction&lt;T&gt; listener)
    {
        // UNDONE: Subscribe handler to event name.
    }
    public void RemoveListener&lt;T&gt;(
        string eventName, UnityAction&lt;T&gt; listener)
    {
        // UNDONE: Unsubscribe handler from event name.
    }
    public void TriggerEvent&lt;T&gt;(string eventName, T arg)
    {
        // UNDONE: Invoke handlers for event name.
    }
}</pre> <p class="calibre3">You didn’t necessarily know what the <strong class="source-inline">Dictionary</strong> declaration would be – we haven’t covered it yet – but <a id="_idIndexMarker869" class="pcalibre1 pcalibre calibre6"/>you at least knew that we needed a declaration for <span>it, right?</span></p>
<p class="calibre3">We have a few additional things to unpack here and introduce some new C# items, including <strong class="source-inline">Dictionary</strong>, <strong class="source-inline">Delegate</strong>, and generic types (as you’ve probably noticed, <strong class="source-inline">&lt;T&gt;</strong> and <strong class="source-inline">T</strong> sprinkled throughout <span>the code):</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">Dictionary&lt;string, Delegate&gt;</strong>: A C# <strong class="source-inline">Dictionary</strong> is a collection type that contains a list of <strong class="bold">keys</strong> and <strong class="bold">values</strong>. This differs from a C# <strong class="source-inline">List</strong>, a collection type that contains a single list of <span>a type.</span><p class="calibre3">Let’s put this into some game development terms… a C# <strong class="source-inline">Dictionary</strong> is kind of like a magic bag where you can store lots of items and find anything you want, so long as it has a unique name. You can keep track of all the cool stuff your player will need on their adventure, keeping your game organized <span>and awesome!</span></p><ul class="calibre22"><li class="calibre15"><strong class="bold">Key</strong>: From our declaration, the first type is a <strong class="source-inline">string</strong> type, which indicates the key type for the item in the dictionary. We’ll set the key to identify the specific event by name, and the event handler methods will be <em class="italic">added </em><span><em class="italic">to it</em></span><span>.</span></li><li class="calibre15"><strong class="bold">Value</strong>: From our declaration, the second type is a <strong class="source-inline">Delegate</strong> type and is the value being stored for the specific key item. We’ll set the value to a delegate type, such as <strong class="source-inline">UnityAction</strong>, that can have method handlers added to it (note that here, <strong class="source-inline">delegate</strong> is the base type for <strong class="source-inline">UnityAction</strong>). The event can be triggered later by the event’s name, invoking all the assigned event handler <span>methods. Simples!</span></li><li class="calibre15"><strong class="bold">new()</strong>: Note that when we declare our <strong class="source-inline">Dictionary</strong>, we can assign a new empty dictionary by specifying just the <strong class="source-inline">new</strong> keyword. This is new for C# in Unity 2022.2 since previously, you’d have to specifically restate <strong class="source-inline">Dictionary</strong> and the types for <em class="italic">key</em> and <em class="italic">value</em> again here – but you’d still have to do this for serialized variables assignable in the <span><strong class="bold">Inspector</strong></span><span> view!</span></li></ul></li>
</ul>
<p class="callout-heading">Dictionary (C#)</p>
<p class="callout"><strong class="source-inline1">Dictionary</strong> represents a collection of keys and values. It has similar properties and methods compared<a id="_idIndexMarker870" class="pcalibre1 pcalibre calibre6"/> to a <strong class="bold">List</strong> collection type. For additional reading, go <span>to </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-8.0</span></a><span>.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">AddListener()</strong>: We’ll <a id="_idIndexMarker871" class="pcalibre1 pcalibre calibre6"/>call this method when we add an event to <strong class="source-inline">EventSystem</strong>. The method signature has the <span>following parameters:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">&lt;T&gt;</strong>: In C#, there is a programming concept <a id="_idIndexMarker872" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">generic</strong>, where <strong class="source-inline">T</strong> represents <em class="italic">any type</em> as a generic type parameter. This allows you to define a method, class, parameter, or something else that can work with any type specified by the calling code, such as <strong class="source-inline">string</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">Vector3</strong>, <strong class="source-inline">GameObject</strong>, and so on. This allows reuse across different parts of the code without the need to use specific types and repeat the same code to support those types. It may sound a bit complicated this early on, but I hope it is understandable through the <span>preceding example.</span></li><li class="calibre15">Our use case for a generic type is to implement an event delegate that can pass in any type as an argument. This will become clearer as we work through the rest <span>of </span><span><strong class="source-inline">EventSystem</strong></span><span>.</span></li><li class="calibre15"><strong class="source-inline">eventName</strong>: A <strong class="source-inline">string</strong> type that uniquely identifies the event that’s been <em class="italic">registered</em> with <strong class="source-inline">EventSystem</strong>. It’s how we add additional listeners to a specific event and how we know what event <span>to trigger.</span></li><li class="calibre15"><strong class="source-inline">listener</strong>: <strong class="source-inline">UnityAction&lt;T&gt;</strong>, which is the event delegate. <strong class="source-inline">UnityAction</strong> should be familiar since it was first introduced in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, as an event listener that was used to update the UI. The difference here is that we are adding a generic parameter of the <strong class="source-inline">T</strong> type, which means the handler method can pass a single argument of any type <span>when invoked.</span></li></ul></li>
<li class="calibre15"><strong class="source-inline">RemoveListener()</strong>: This is used when removing an event from <strong class="source-inline">EventSystem</strong>. The<a id="_idIndexMarker873" class="pcalibre1 pcalibre calibre6"/> method signature is the same as that for <strong class="source-inline">AddListener()</strong>, so we don’t need to repeat ourselves here. However, there will be one glaringly obvious difference: we’ll be removing a method handler instead of <span>adding one.</span></li>
<li class="calibre15"><strong class="source-inline">TriggerEvent()</strong>: We’ll call this method when we want to invoke the specific event for which method handlers were added as listeners (via <strong class="source-inline">AddListeners()</strong>, of course). The method signature has the <span>following parameters:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">eventName</strong>: Again, this is the event name string we’ll specify for invoking the method handlers (that is, the <span>added listeners).</span></li><li class="calibre15"><strong class="source-inline">T arg</strong>: The parameter value we’ll pass into the invoked methods that will be handled so that they can receive and process any required data. Again, being a generic type, <strong class="source-inline">T</strong>, we’ll be able to pass in an argument of any type (<span>nice, right?).</span></li></ul></li>
</ul>
<p class="calibre3">In the preceding code, I said <em class="italic">event name</em>, but we won’t do something as silly as using string literals for the event names throughout the code base. Instead, let’s create an <strong class="source-inline">EventConstants</strong> class that we’ll use for the event names. This would be similar to how we added a <strong class="source-inline">Tags</strong> class when referencing tags assigned to our objects in the game through code (for <span>example, </span><span><strong class="source-inline">Player</strong></span><span>).</span></p>
<p class="calibre3">Let’s define our first event name constant by creating the following <strong class="source-inline">EventConstants</strong> class, saved in the <span><strong class="source-inline">Assets/Scripts/Systems</strong></span><span> folder:</span></p>
<pre class="source-code">
public class EventConstants
{
    public const string MyFirstEvent = "MyFirstEvent";
}</pre> <p class="calibre3">The event name will be the <em class="italic">constant</em> (figuratively and literally) that loosely ties things together, so we don’t require concrete class references between classes that would observe and respond to events. Now, we can independently test our classes – via <strong class="bold">unit testing</strong> – without<a id="_idIndexMarker874" class="pcalibre1 pcalibre calibre6"/> ensuring references to other classes exist – for example, <strong class="source-inline">Player</strong> doesn’t need to specify a reference to <strong class="source-inline">UIManager</strong>, <strong class="source-inline">Enemy</strong>, and so on. We can also move a class to a new project without worrying about bringing in <span>unnecessary classes.</span></p>
<p class="calibre3">Now that we’ve <a id="_idIndexMarker875" class="pcalibre1 pcalibre calibre6"/>learned about the event system template, as well as how we’ll specify events, let’s dig into the specifics of the implemented methods: <strong class="source-inline">AddListener()</strong>, <strong class="source-inline">RemoveListener()</strong>, <span>and </span><span><strong class="source-inline">TriggerEvent()</strong></span><span>.</span></p>
<h3 class="calibre10">Event management methods</h3>
<p class="calibre3">First, let’s look at<a id="_idIndexMarker876" class="pcalibre1 pcalibre calibre6"/> the <strong class="source-inline">AddListener()</strong> method. To recap, <strong class="source-inline">AddListener()</strong> is responsible for adding an event to the dictionary of events if it doesn’t already exist (that is, registering the event) and adding the listener to the event’s handler method <strong class="source-inline">delegate</strong>, <span>like so:</span></p>
<pre class="source-code">
    public void AddListener&lt;T&gt;(string eventName,
        UnityAction&lt;T&gt; listener)
    {
        if (!_events.ContainsKey(eventName))
            _events.Add(eventName, null);
        _events[eventName] = (UnityAction&lt;T&gt;)_events[eventName]
            + listener;
    }</pre> <p class="calibre3">Let’s break down the <span>code here:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">ContainsKey()</strong>: The very first thing we’ll need to do when adding an event to our dictionary of events is to see if we’ve already registered one of the same event names (pretty logical, right?). A C# <strong class="source-inline">Dictionary</strong> provides several methods here – similar to a C# <strong class="source-inline">List</strong> in many ways – for achieving this base functionality that we <span>can leverage.</span><p class="calibre3">Specifically, we use <strong class="source-inline">ContainsKey()</strong> and pass in <strong class="source-inline">eventName</strong>. This will return a Boolean value of <strong class="source-inline">true</strong> if the key already exists in the dictionary and <strong class="source-inline">false</strong> if not, so we can use an <strong class="source-inline">if</strong> statement to evaluate and take the <span>proper action.</span></p></li>
<li class="calibre15"><strong class="source-inline">Add()</strong>: Working <a id="_idIndexMarker877" class="pcalibre1 pcalibre calibre6"/>with the result returned from <strong class="source-inline">ContainsKey()</strong>, we’ll go ahead and add the event – using the event name as the key – to the dictionary using the <strong class="source-inline">Add()</strong> method (again, similar to <span>C# </span><span><strong class="source-inline">List</strong></span><span>).</span><p class="calibre3">Note that for the value parameter – as in <strong class="source-inline">Add(key, value)</strong> – we’re specifying <strong class="source-inline">null</strong> for the delegate. That’s simply because we’ll assign the listener to the delegate in the following line, where it doesn’t matter whether this event was <span>just added.</span></p></li>
<li class="calibre15"><strong class="source-inline">_events[eventName]</strong>: We can get the value for a specific event from the <strong class="source-inline">_events</strong> dictionary by simply specifying the key in square braces (this is similar to how we’d return the value of an array by specifying the index (<strong class="source-inline">int</strong>) in <span>square braces).</span></li>
<li class="calibre15"><strong class="source-inline">(UnityAction&lt;T&gt;)</strong>: Placing a type in parenthesis before another type is called casting in C#. Since <strong class="source-inline">_events[eventName]</strong> is a <strong class="source-inline">Delegate</strong> type, and <strong class="source-inline">UnityAction</strong> has delegate as its base type, we can operate on the event dictionary value as <strong class="source-inline">UnityAction</strong> via a type conversion by casting it (an explicit conversion). Here, again, <strong class="source-inline">&lt;T&gt;</strong> indicates we will use a generic for <span>a parameter.</span></li>
</ul>
<p class="callout-heading">Casting (C#)</p>
<p class="callout">C# is a strongly typed language (or statically typed) at compile time, so once a variable is declared, it cannot be declared again as a different type. To overcome this, should you need to copy a value into a variable of another type, C# provides various type conversion operations, and casting is one <span>of them.</span></p>
<p class="callout">Here’s some additional <span>reading: </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions</span></a><span>.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">+ listener</strong>: <strong class="source-inline">UnityAction</strong> allows you to add additional listeners; using the <strong class="source-inline">+</strong> (add) operator will enable us to do <span>just that.</span><p class="calibre3">Note that just the <strong class="source-inline">+</strong> operator is the correct syntax to add a listener to a delegate that may be <strong class="source-inline">null</strong> or already has listeners, unlike previously, all the way back in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 3</em></span></a>, where we used the <strong class="source-inline">+=</strong> operator to add an event handler method when subscribing <span>to events.</span></p></li>
</ul>
<p class="calibre3">Now, let’s look at<a id="_idIndexMarker878" class="pcalibre1 pcalibre calibre6"/> the opposite. For <strong class="source-inline">RemoveListener()</strong>, we want to remove an event listener when it’s no longer needed – especially when an object is destroyed – so that we don’t try invoking an invalid handler method reference. This is generally just good practice – for some listener types, not doing so can cause <span>memory leaks:</span></p>
<pre class="source-code">
    public void RemoveListener&lt;T&gt;(string eventName,
        UnityAction&lt;T&gt; listener)
    {
        if (_events.ContainsKey(eventName))
            _events[eventName] =
                (UnityAction&lt;T&gt;)_events[eventName] - listener;
    }</pre> <p class="calibre3">We don’t need to break down the code here again because it’s essentially the same as <strong class="source-inline">AddListener()</strong>. The primary differences are <span>as follows:</span></p>
<ul class="calibre17">
<li class="calibre15">We don’t need to add the event in case it doesn’t exist; we only care if it does exist so that we can remove a listening <span>handler method</span></li>
<li class="calibre15">In place of the <strong class="source-inline">+</strong> operator, we use the <strong class="source-inline">-</strong> operator to remove the specified listener <span>handler method</span></li>
</ul>
<p class="calibre3">Lastly, we have the <strong class="source-inline">TriggerEvent()</strong> method. The naming of these methods has been self-explanatory so far, so it should be no surprise what’s next. However, we are doing something different here to retrieve the dictionary’s value for the <strong class="source-inline">eventName</strong> key that’s been<a id="_idIndexMarker879" class="pcalibre1 pcalibre calibre6"/> provided to invoke the added <span>handler methods:</span></p>
<pre class="source-code">
    public void TriggerEvent&lt;T&gt;(string eventName, T arg)
    {
        if (_events.TryGetValue(eventName, out Delegate del))
            (del as UnityAction&lt;T&gt;)?.Invoke(arg);
    }</pre> <p class="calibre3">Here is how <span>things work:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">_events.TryGetValue()</strong>: You may find this syntax familiar since we’ve already used <strong class="source-inline">TryGetComponent()</strong> a few times. Very simply, we try to get the value for the specified <strong class="source-inline">eventName</strong> key, and if it exists, we return the value as an <strong class="source-inline">out</strong> parameter called <strong class="source-inline">del</strong>. The <strong class="source-inline">if</strong> evaluation will short-circuit if it’s not found, so <strong class="source-inline">Invoke()</strong> will only be called if a value <span>is returned.</span></li>
<li class="calibre15"><strong class="source-inline">(del as UnityAction&lt;T&gt;)</strong>: We introduce the <strong class="source-inline">as</strong> operator keyword here. Similar to how we used <strong class="source-inline">()</strong> to cast to another type, we can also use <strong class="source-inline">as</strong> for type conversion. Specifically, <strong class="source-inline">as</strong> is a good choice when working with a nullable type, which we want to do here because we’re also using the null-conditional operator (<strong class="source-inline">?.</strong>) so that we won’t erroneously try and call <strong class="source-inline">Invoke()</strong> on a <span>null delegate.</span></li>
</ul>
<p class="callout-heading">The as operator (C#)</p>
<p class="callout">The <strong class="source-inline1">as</strong> operator <a id="_idIndexMarker880" class="pcalibre1 pcalibre calibre6"/>converts objects to a different type but returns <strong class="source-inline1">null</strong> if the conversion fails instead of throwing an exception like other type conversion <span>techniques would.</span></p>
<p class="callout">Here’s some additional <span>reading: </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator</span></a><span>.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">Invoke(arg)</strong>: This is how we tie back into the generic parameter specified by <strong class="source-inline">T</strong> in the <strong class="source-inline">UnityAction&lt;T&gt;</strong> declaration for our listener delegate. The last part, bringing it full circle, will be the method signature for the handler method receiving the argument. This should all make sense when we get to the <em class="italic">Creating a quest system for a collecting keys mission</em> section, when we put the event system through its <span>paces. Promise!</span></li>
</ul>
<p class="calibre3">Next, so that we don’t overlook an essential detail for how we will access the event system from our <a id="_idIndexMarker881" class="pcalibre1 pcalibre calibre6"/>classes that need to work with events, let’s make the event system a Singleton – an <span>actual Singleton!</span></p>
<h3 class="calibre10">Enforcing a Singleton instance</h3>
<p class="calibre3">Our <strong class="source-inline">EventSystem</strong> will <a id="_idIndexMarker882" class="pcalibre1 pcalibre calibre6"/>be a <strong class="bold">Singleton</strong> instance so that it can be accessed from anywhere in <a id="_idIndexMarker883" class="pcalibre1 pcalibre calibre6"/>our code. Still, we haven’t implemented a full Singleton pattern yet where only a single instance is guaranteed to exist. We’ll sort this out by enforcing the pattern and destroying any <span>want-to-be duplicates.</span></p>
<p class="calibre3">We saw a rudimentary implementation back in <a href="B18347_03.xhtml#_idTextAnchor058" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 3</em></span></a>, where we just set the instance to a static variable without even attempting to seek and destroy additional instances being introduced (bad us). Here we go. Add the following <strong class="source-inline">Instance</strong> public static variable declaration and the new <strong class="source-inline">Awake()</strong> <span>method code:</span></p>
<pre class="source-code">
public class EventSystem : MonoBehaviour
{
    public static EventSystem Instance { get; private set; }
    …
    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
        DontDestroyOnLoad(gameObject);
    }
    …</pre> <p class="calibre3">The magic <a id="_idIndexMarker884" class="pcalibre1 pcalibre calibre6"/>happens in the <strong class="source-inline">Awake()</strong> method, where<a id="_idIndexMarker885" class="pcalibre1 pcalibre calibre6"/> we previously just <span>did this:</span></p>
<pre class="source-code">
private void Awake() =&gt; Instance = this;</pre> <p class="calibre3">We can now check if our static <strong class="source-inline">Instance</strong> has been assigned yet; if not, assign it. However, if <strong class="source-inline">Instance</strong> was already assigned, a want-to-be duplicate will be added to our <strong class="bold">Scene Hierarchy</strong>. Let’s destroy it <span>right away!</span></p>
<p class="calibre3">Our <strong class="source-inline">EventManager</strong> will need to hang around all the time to respond to registering and triggering events at any time, and from any class, throughout the life of our game, so we’ll need a way to keep <span>it persistent.</span></p>
<p class="calibre3">Sometimes, the coding process feels like a game: find something, destroy that, keep this. So, if you’re <a id="_idIndexMarker886" class="pcalibre1 pcalibre calibre6"/>not having fun, you’re doing <span>something wrong!</span></p>
<p class="callout-heading">EventSystem | Complete code</p>
<p class="callout">To view the complete<a id="_idIndexMarker887" class="pcalibre1 pcalibre calibre6"/> code for the <strong class="source-inline1">EventSystem</strong> class and all the event-related code in this chapter, visit this book’s GitHub <span>repository: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/</span></a><span>.</span></p>
<h3 class="calibre10">Singleton persistence</h3>
<p class="calibre3">Unity provides a<a id="_idIndexMarker888" class="pcalibre1 pcalibre calibre6"/> way to keep particular objects persistent, no matter the current scene, survive loading new scenes, and more, and that is by using <strong class="source-inline">DontDestroyOnLoad</strong>. Simply calling it and passing the <strong class="source-inline">GameObject</strong> object you want to persist as the target parameter is all that’s needed. In our case, in <strong class="source-inline">Awake()</strong>, we’re passing in <strong class="source-inline">gameObject</strong>, which represents the current object the component (script) is <span>attached to.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">DontDestroyOnLoad</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Object.DontDestroyOnLoad.xhtml</span></a><span>.</span></p>
<h2 id="_idParaDest-166" class="calibre8"><a id="_idTextAnchor175" class="pcalibre1 pcalibre calibre6"/>Systems GameObject</h2>
<p class="calibre3">Objects <a id="_idIndexMarker889" class="pcalibre1 pcalibre calibre6"/>specified as <strong class="source-inline">DontDestroyOnLoad</strong> must be in the root of the <strong class="bold">Scene Hierarchy</strong>, so we’ll create a new GameObject in our game’s level scene and name it <em class="italic">Systems</em>, then add the <strong class="source-inline">EventSystem</strong> component. I would place this at the very top of the scene hierarchy to maintain some visible order of dependency for things – it’s entirely up to you how you choose to organize things here. Also, remember that you can add empty objects with the sole purpose of having organizational headers (don’t forget to set the tag to <strong class="source-inline">EditorOnly</strong>), as seen in the <strong class="source-inline">Systems</strong> object referenced in <span><em class="italic">Figure 9</em></span><span><em class="italic">.2</em></span><span>:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer122">
<img alt="Figure 9.2 – Systems root GameObject" src="image/B18347_09_2.jpg" class="calibre95"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Systems root GameObject</p>
<p class="calibre3">In this section, we learned how to create a global event system that allows our classes to remain loosely coupled because we don’t require type references of one class in another to respond to triggered actions. If the <strong class="source-inline">EventSystem</strong> component’s usage is still unclear, don’t<a id="_idIndexMarker890" class="pcalibre1 pcalibre calibre6"/> fret – in the next section, we’ll cover an example straight away by creating a simple quest system based <span>on it.</span></p>
<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor176" class="pcalibre1 pcalibre calibre6"/>Creating a quest system for a collecting keys mission</h1>
<p class="calibre3">Now that we have<a id="_idIndexMarker891" class="pcalibre1 pcalibre calibre6"/> our super decoupled global event <a id="_idIndexMarker892" class="pcalibre1 pcalibre calibre6"/>system, we’ll immediately put it to good use. Referring again to our GDD, we know that the player, at some point, has to collect some key pieces to solve a puzzle so that they <span>can advance:</span></p>
<table class="no-table-style" id="table001-5">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">What is the secondary game mechanic for the </strong><span><strong class="bold">adventure game?</strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3">The player will search the environment for hidden parts of a key. The pieces will need to be combined correctly as input to gain access to the entryway of the <span>habitat station.</span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 9.1 – GDD quest reference</p>
<p class="calibre3">A typical game system that can support “collecting a certain number of items” is a quest system. A possibly more simplified approach, but also a system-based approach to solving this problem, could be a basic inventory system. A quest system, however, will offer additional opportunities to provide a more complete example – especially for implementing the <span>event system.</span></p>
<p class="calibre3">Let’s have a quick look at what the player will be searching for during their quest and interacting with to regain entry to the habitat station constructed on the planet. The Kryk’zylx technology is a mystery to us, but suffice it to say, they like a good challenge when securing their bases. Both the key pieces that the evil plant entity has scattered and the entryway security puzzle lock with the missing pieces can be seen in the <span>following figure:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer123">
<img alt="Figure 9.3 – Keys and security puzzle art" src="image/B18347_09_3.jpg" class="calibre96"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Keys and security puzzle art</p>
<p class="calibre3">Our mission now<a id="_idIndexMarker893" class="pcalibre1 pcalibre calibre6"/> is <a id="_idIndexMarker894" class="pcalibre1 pcalibre calibre6"/>to code the quest system and flesh out the game mechanics required to implement it. So, let’s <span>get started!</span></p>
<h2 id="_idParaDest-168" class="calibre8"><a id="_idTextAnchor177" class="pcalibre1 pcalibre calibre6"/>The quest system</h2>
<p class="calibre3">I’ll provide the <a id="_idIndexMarker895" class="pcalibre1 pcalibre calibre6"/>code template for a <strong class="source-inline">QuestSystem</strong> class, similar to how the event system was introduced. However, I’ll give the full implementation this time because you’ll find it shares a similar design to <strong class="source-inline">EventSystem</strong>. I also won’t provide a diagram this time. I’m going to save it as a challenge for you to create one on your own at the end of <span>this section.</span></p>
<p class="calibre3">Create a new script named <strong class="source-inline">QuestSystem</strong> in the <strong class="source-inline">Assets/Scripts/Systems</strong> folder with the <span>following code:</span></p>
<pre class="source-code">
using UnityEngine;
using System.Collections.Generic;
public class QuestSystem : MonoBehaviour
{
    private Dictionary&lt;string, bool&gt; _quests = new();
    public void StartQuest(string questName)
    {
        if (!_quests.ContainsKey(questName))
            _quests.Add(questName, false);
    }
    public void CompleteQuest(string questName)
    {
        if (_quests.ContainsKey(questName))
            _quests[questName] = true;
    }
}</pre> <p class="calibre3">Okay, no, you’re<a id="_idIndexMarker896" class="pcalibre1 pcalibre calibre6"/> not experiencing déjà vu. The basic concept for the <strong class="source-inline">QuestSystem</strong> code is a similar pattern to <strong class="source-inline">EventSystem</strong>. At its core, there’s also a <span>C# </span><span><strong class="source-inline">Dictionary</strong></span><span>.</span></p>
<p class="calibre3">Here’s <span>the breakdown:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">Dictionary&lt;string, bool&gt;</strong>: The declaration for the <strong class="source-inline">_quests</strong> dictionary will hold a <strong class="source-inline">string</strong> key to identify the quest’s name (similar to the event name), and the value for the entry will be of the <strong class="source-inline">bool</strong> type as an indication of whether the quest has been completed (that is, <strong class="source-inline">true</strong> <span>equals completed).</span></li>
<li class="calibre15"><strong class="source-inline">StartQuest()</strong>: Starting a quest means adding it to the dictionary if it’s not already added. Quests will be identified by a unique <strong class="source-inline">questName</strong> that’s passed in as the only argument. Simple. <span>As. That.</span></li>
<li class="calibre15"><strong class="source-inline">CompleteQuest()</strong>: As stated earlier, we’re going to use the <strong class="source-inline">_quest</strong> value as the quest completion indicator, so if the specified quest exists in the dictionary, then we’ll assign <strong class="source-inline">true</strong> for its value (<strong class="source-inline">bool</strong> has a default value of <strong class="source-inline">false</strong>, which is why we didn’t need to assign <span>this anywhere).</span></li>
</ul>
<p class="calibre3">We’ll be repeating ourselves a bit here again with how <strong class="source-inline">QuestSystem</strong> will be accessed when required since we’ll be using a Singleton pattern again. Primarily, however, we will decouple<a id="_idIndexMarker897" class="pcalibre1 pcalibre calibre6"/> references to <strong class="source-inline">QuestSystem</strong> whenever possible by going through the global event system (that is, no tightly <span>coupled objects).</span></p>
<p class="calibre3">Add the following declarations for the public static <strong class="source-inline">Instance</strong> property and the <em class="italic">Singleton management code</em> to the <strong class="source-inline">Awake()</strong> method, <span>like so:</span></p>
<pre class="source-code">
    public static QuestSystem Instance { get; private set; }
    private void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
        DontDestroyOnLoad(gameObject);
    }</pre> <p class="calibre3">Using the Singleton pattern solves a big problem for obtaining references to our core systems, but it also comes with some disadvantages compared to more complex patterns (for example, service locator patterns). We’re going to address one of these shortcomings now before <span>proceeding further.</span></p>
<p class="calibre3">We have a potential problem with our systems because we require the <strong class="source-inline">EventSystem</strong> instance to be available to every other system when the game starts – being the core system loosely<a id="_idIndexMarker898" class="pcalibre1 pcalibre calibre6"/> coupling everything together and playing nice. With that being the case, we must ensure it gets <span>initialized first.</span></p>
<h2 id="_idParaDest-169" class="calibre8"><a id="_idTextAnchor178" class="pcalibre1 pcalibre calibre6"/>Script Execution Order</h2>
<p class="calibre3">To set the execution <a id="_idIndexMarker899" class="pcalibre1 pcalibre calibre6"/>order for which script event functions are run (for example, the <strong class="source-inline">Awake()</strong> message event), Unity provides a <strong class="bold">Script Execution Order</strong> assignment in <strong class="bold">Project Settings</strong>. Quite simply, you can set a lower-ordered number for scripts you want to be initialized first and specifically before others that would rely on it <span>being initialized.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Script Execution Order <span>settings: </span><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/Manual/class-MonoManager.xhtml</span></a><span>.</span></p>
<p class="calibre3">For our usage here, we require <strong class="source-inline">EventSystem</strong> to be run <span>before </span><span><strong class="source-inline">QuestSystem</strong></span><span>.</span></p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Edit</strong> | <strong class="bold">Project Settings…</strong> | <strong class="bold">Script </strong><span><strong class="bold">Execution Order</strong></span><span>.</span></li>
<li class="calibre15">If they’re not already in the list, add these two scripts to the list using the little plus (<strong class="bold">+</strong>) button at the <span>bottom right.</span></li>
<li class="calibre15">Then, click and drag them into the <span>position indicated:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer124">
<img alt="Figure 9.4 – Script Execution Order in Project Settings" src="image/B18347_09_4.jpg" class="calibre97"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Script Execution Order in Project Settings</p>
<ol class="calibre14">
<li value="4" class="calibre15">Click <strong class="bold">Apply</strong> when<a id="_idIndexMarker900" class="pcalibre1 pcalibre calibre6"/> <span>you’re finished.</span></li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Unity also provides a code solution for specifying the execution order of scripts using an attribute. The attribute is <strong class="source-inline1">[DefaultExecutionOrder(int)]</strong>, and you can decorate the class declaration and set the <span>order value.</span></p>
<p class="callout">For example, adding this attribute to the <strong class="source-inline1">QuestSystem</strong> class declaration would look <span>like this:</span></p>
<pre class="source-code">
[DefaultExecutionOrder(-500)]
public class QuestSystem : MonoBehaviour
{ …</pre> <p class="calibre3">And speaking of execution, make sure to add the <strong class="source-inline">QuestSystem</strong> component to the <strong class="bold">Systems</strong> GameObject in the<a id="_idIndexMarker901" class="pcalibre1 pcalibre calibre6"/> scene (as a sibling <span>of </span><span><strong class="source-inline">EventSystem</strong></span><span>).</span></p>
<p class="calibre3">Now, what’s a quest system without <span>any quests?!</span></p>
<h2 id="_idParaDest-170" class="calibre8"><a id="_idTextAnchor179" class="pcalibre1 pcalibre calibre6"/>The quest</h2>
<p class="calibre3">Your mission, should <a id="_idIndexMarker902" class="pcalibre1 pcalibre calibre6"/>you choose to accept it, will be to find and collect the missing pieces that are required to solve the habitat entryway security puzzle lock. The quest object representing the actual quest with its requirements is arguably the essential part of any quest system. As you saw in the <em class="italic">Script Execution Order</em> section, keeping a list of the active quests is quite simple – we add a quest to a list and set a variable to <strong class="source-inline">true</strong> when it’s <span>completed. Easy-peasy.</span></p>
<p class="calibre3">The next part of the quest system we’ll cover will be the quest code. Before we even get started, however, we will ensure that any quest we define will have a unique identifier that is easily assignable (even in the <span><strong class="bold">Inspector</strong></span><span> view).</span></p>
<h3 class="calibre10">Name consistency</h3>
<p class="calibre3">The problem we’ll <a id="_idIndexMarker903" class="pcalibre1 pcalibre calibre6"/>need to solve now is how to guarantee consistency for quest names without using magic strings, reference the quest names from different parts of the code, and have them selectable in the <span><strong class="bold">Inspector</strong></span><span> view.</span></p>
<p class="calibre3">We saw how to use <strong class="source-inline">enum</strong> when the <a id="_idIndexMarker904" class="pcalibre1 pcalibre calibre6"/>simple <strong class="bold">FSM</strong> was introduced in <a href="B18347_07.xhtml#_idTextAnchor130" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 7</em></span></a>. Well, we’re going to use <strong class="source-inline">enum</strong> similarly now, but instead of states for an FSM, we’re going to use it for unique quest name identifiers; again, as a reminder, we’re not going to rely on string literals! This is similar to how we’ve used string constants before (for example, event names and tags), but being an <strong class="source-inline">enum</strong> type over a constant means we have some added benefit, including when it comes to selecting from a list of available quests in the <span><strong class="bold">Inspector</strong></span><span> view!</span></p>
<p class="calibre3">Create a new script named <em class="italic">QuestNames</em> in the <strong class="source-inline">Assets/Scripts/Quests</strong> folder. Replace all of the default script template code with the <span>following code:</span></p>
<pre class="source-code">
public enum QuestNames
{
    // Quest name, unique ID.
    CollectKeysQuest = 10
}</pre> <p class="calibre3">This is where we’ll define any new quest we add to the game. We’ve populated the <strong class="source-inline">CollectKeysQuest</strong> name and given it a unique ID of <strong class="source-inline">10</strong> (this is any arbitrary number that’s not already being used) – be sure to follow this pattern, assigning the name and ID, when adding additional <span>quest names.</span></p>
<p class="calibre3">We’ll see how the<a id="_idIndexMarker905" class="pcalibre1 pcalibre calibre6"/> quest names will be declared and referenced as we proceed with our coding mission to complete this <span>quest system!</span></p>
<h3 class="calibre10">Quest base class</h3>
<p class="calibre3">Yup, that’s right, another<a id="_idIndexMarker906" class="pcalibre1 pcalibre calibre6"/> base class means we will use more OOP design here! And since we covered this already in <a href="B18347_02.xhtml#_idTextAnchor041" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 2</em></span></a>, it’s barely an inconvenience for you to bang this out, right? Our specific quests will then derive from the new quest base class we’ll write next, providing a template for consistency in <span>implementing quests.</span></p>
<p class="calibre3">We’ve already defined the quest names. A quest name will need to be a part of every quest, so let’s start by setting up the base class for our quests <span>with that.</span></p>
<p class="calibre3">Create a new script named <strong class="source-inline">QuestBase</strong> in the <span><strong class="source-inline">Assets/Scripts/Quests</strong></span><span> folder:</span></p>
<pre class="source-code">
using UnityEngine;
public abstract class QuestBase : MonoBehaviour
{
    public QuestNames QuestName =&gt; _questName;
    [SerializeField]
    private QuestNames _questName;
    …</pre> <p class="calibre3">The first thing to note is that the <strong class="source-inline">QuestBase</strong> class is declared as <strong class="source-inline">public abstract class</strong>. This means we won’t be able to use this class directly – we cannot add an abstract class to a <strong class="source-inline">GameObject</strong> object in the <strong class="bold">Scene Hierarchy</strong>, even with it being a <strong class="bold">MonoBehaviour</strong> type. Instead, we will have to create a new class that inherits from <strong class="source-inline">QuestBase</strong> (that is, this is only the <span><em class="italic">base template</em></span><span>).</span></p>
<p class="calibre3">Second, we can see the declaration for <strong class="source-inline">QuestName</strong>, which uses the <strong class="source-inline">QuestNames</strong> <strong class="source-inline">enum</strong> type we previously wrote. We have encapsulated a <strong class="source-inline">private _questName</strong> variable and decorated it with the <strong class="source-inline">[SerializeField]</strong> attribute so that it can be assigned in the <strong class="bold">Inspector</strong> view. Spoiler alert: the following screenshot shows the dropdown field the <strong class="source-inline">enum</strong> type draws in the <span><strong class="bold">Inspector</strong></span><span> view:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer125">
<img alt="Figure 9.5 – The Quest Name Inspector view assignment dropdown" src="image/B18347_09_5.jpg" class="calibre98"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The Quest Name Inspector view assignment dropdown</p>
<p class="calibre3">The <strong class="source-inline">_questName</strong> value is made available to other classes via the <strong class="source-inline">public QuestName</strong> property – the expression body (<strong class="source-inline">=&gt;</strong>) declares the property as a getter only (as in, you won’t be able to assign <span>a value).</span></p>
<p class="calibre3">So far, so good. Still, this<a id="_idIndexMarker907" class="pcalibre1 pcalibre calibre6"/> was a bit of a review since nothing we’ve covered here is new. The same goes for the first two methods we’ll declare for the <strong class="source-inline">QuestBase</strong> abstract class. We’ll use <strong class="source-inline">virtual</strong> methods for both <strong class="source-inline">StartQuest()</strong> and <strong class="source-inline">QuestCompleted()</strong> because the inheriting class may need to override the provided <span>base functionality:</span></p>
<pre class="source-code">
    …
    public virtual void StartQuest()
        =&gt; QuestSystem.Instance.StartQuest(QuestName.ToString());
    protected virtual void QuestCompleted(string questName)
        =&gt; Debug.Log($"Quest '{questName}' completed!");
    …</pre> <p class="calibre3">The code may be self-explanatory at this point, but it always helps to explain. Let’s break <span>it down:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">public virtual void StartQuest()</strong>: This method has a <strong class="source-inline">public</strong> accessor because it is intended to be called from an external class to trigger the start of the quest. We call the quest system’s <strong class="source-inline">StartQuest()</strong> method (via its Singleton instance) and pass the unique quest identifier (that is, the <strong class="source-inline">enum</strong>-based quest name) to add it to the active quests <strong class="source-inline">Dictionary</strong> for <span>later reference.</span><p class="calibre3">We use <strong class="source-inline">virtual</strong> in the method signature in case the inheriting class would need to do more than start <span>the quest.</span></p></li>
<li class="calibre15"><strong class="source-inline">protected virtual QuestCompleted()</strong>: This method has a <strong class="source-inline">protected</strong> accessor, so it can only be called within the class and by derived classes – not an external class because the logic to determine quest completion should be evaluated on the specific quest’s requirements and not some <span>external factors.</span><p class="calibre3">Again, we use <strong class="source-inline">virtual</strong> in the method signature in case the inheriting class would need to do something else (such as implementing different logic or behavior for different types of quests, such as side quests). For now, we’re simply logging a message to the console that the quest <span>was completed.</span></p></li>
</ul>
<p class="calibre3">Now for the fun part! We’ll <a id="_idIndexMarker908" class="pcalibre1 pcalibre calibre6"/>be leaning on the event system to implement the following function: listening for when the quest has been completed. This is why we didn’t declare the <strong class="source-inline">QuestCompleted()</strong> method as <strong class="source-inline">public</strong> – <strong class="source-inline">QuestCompleted()</strong> is the handler method that’s passed into the event system as <span>the listener:</span></p>
<pre class="source-code">
    …
    private void OnEnable() =&gt; AddListeners();
    private void OnDisable() =&gt; RemoveListeners();
    protected virtual void AddListeners()
        =&gt; EventSystem.Instance.AddListener&lt;string&gt;(
            EventConstants.OnQuestCompleted, QuestCompleted);
    protected virtual void RemoveListeners()
        =&gt; EventSystem.Instance.RemoveListener&lt;string&gt;(
            EventConstants.OnQuestCompleted, QuestCompleted);
}</pre> <p class="calibre3">Here are just a few points in need <span>of explanation:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">OnEnable()</strong>, <strong class="source-inline">OnDisable()</strong>: We add and remove the event system listeners for the base class, respectively. <strong class="source-inline">AddListeners()</strong> and <strong class="source-inline">RemoveListeners()</strong> can be overridden in the inheriting class if additional listeners need to be added for the <span>specific quest.</span></li>
<li class="calibre15"><strong class="source-inline">AddListeners()</strong>: Here, we add a listener to the event system for quest completion. We’ll use a string argument to pass the quest’s name as the parameter to the <span>handler method.</span></li>
<li class="calibre15"><strong class="source-inline">RemoveListeners()</strong>: We just need to remove the listener added in <strong class="source-inline">AddListeners()</strong> – remember, removing event listeners is always <span>good practice!</span><p class="calibre3">Note that even though it doesn’t make sense that simply removing a listener would require an argument for passing a parameter, we still need it because the delegate definition must match the method signature of the handler method that was added as <span>the listener.</span></p></li>
</ul>
<p class="calibre3">As the last step, add the string constant for <strong class="source-inline">EventConstants.OnQuestCompleted</strong> to the <strong class="source-inline">EventConstants</strong> script. Or, in your IDE, <em class="italic">OnQuestCompleted</em> should have that red squiggly line indicating the definition was not found. Go ahead and use your IDE’s refactoring tools to generate the variable (but ensure<a id="_idIndexMarker909" class="pcalibre1 pcalibre calibre6"/> it is consistent with the other event <span>name constants).</span></p>
<p class="calibre3">With that, <strong class="source-inline">QuestBase</strong> has been completed! Now, prepare to make a specific quest class derived from the <span>base class.</span></p>
<h3 class="calibre10">Collect keys quest</h3>
<p class="calibre3">We call the missing<a id="_idIndexMarker910" class="pcalibre1 pcalibre calibre6"/> security puzzle key pieces that need to be <a id="_idIndexMarker911" class="pcalibre1 pcalibre calibre6"/>collected <em class="italic">keys</em>, and three will be required to complete our quest. These are simple requirements for a simple quest, but we still need a way to not only explicitly declare the requirement but evaluate and communicate <span>completion, too.</span></p>
<p class="calibre3">We’ll start by creating a new script called <strong class="source-inline">CollectKeysQuest</strong> in the <strong class="source-inline">Assets/Scripts/Quests</strong> folder and inherit from <strong class="source-inline">QuestBase</strong> instead <span>of </span><span><strong class="source-inline">MonoBehaviour</strong></span><span>:</span></p>
<pre class="source-code">
using UnityEngine;
public class CollectKeysQuest : QuestBase
{
    [SerializeField] private int _numKeysRequired = 3;
    private int _keysCollected = 0;
    …</pre> <p class="calibre3">We also declare the number of keys required to be collected to complete this quest. <strong class="source-inline">_numKeysRequired</strong> will be <strong class="source-inline">private</strong> so that no other class has access to it, but we’ll use the <strong class="source-inline">[SerializeField]</strong> attribute to set this value in the <strong class="bold">Inspector</strong> view (although we’ll set a default value <span>of </span><span><strong class="source-inline">3</strong></span><span>).</span></p>
<p class="calibre3"><strong class="source-inline">_keysCollected</strong> will keep track of the number of keys the player has collected (<strong class="source-inline">private</strong> – it’s no one else’s business), and we’ll increment that value via the event system (<span>so handy):</span></p>
<pre class="source-code">
    …
    protected override void AddListeners()
    {
        base.AddListeners();
        EventSystem.Instance.AddListener&lt;bool&gt;(
            EventConstants.OnKeyCollected, KeyCollected);
    }
    protected override void RemoveListeners()
    {
        base.RemoveListeners();
        EventSystem.Instance.RemoveListener&lt;bool&gt;(
            EventConstants.OnKeyCollected, KeyCollected);
    }
    private void KeyCollected(bool arg0)
    {
        _keysCollected++;
        // UNDONE: Evaluate quest completion.
    }
}</pre> <p class="calibre3">Okay, it is a familiar pattern, but let’s clarify <span>it still:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">override AddListeners()</strong>: For this specific quest, we need to listen for when the player<a id="_idIndexMarker912" class="pcalibre1 pcalibre calibre6"/> has collected a key. Using the event<a id="_idIndexMarker913" class="pcalibre1 pcalibre calibre6"/> system, we don’t need to know anything about the <strong class="source-inline">Player</strong> object or even the script implemented to collect the key; we observe that a key was collected and handled with the <strong class="source-inline">KeyCollected()</strong> method. We use the <strong class="source-inline">override</strong> keyword here because we need more functionality than the base class <span>alone provides:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">base.AddListeners()</strong>: Speaking of what the base class provides, we still need it! We can still ensure the base class methods that are overridden by using the <strong class="source-inline">base</strong> keyword – for accessing base class members within the <span>derived class.</span></li></ul></li>
<li class="calibre15"><strong class="source-inline">override RemoveListeners()</strong>: You got it – maintaining good practice removing what listeners <span>were added:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">base.RemoveListeners()</strong>: The same as <span>for </span><span><strong class="source-inline">base.AddListeners()</strong></span></li></ul></li>
<li class="calibre15"><strong class="source-inline">KeyCollected()</strong>: I promise we won’t have a breadcrumb trail of UNDONE tokens to follow again! But, for now, we’ll just increment the <strong class="source-inline">_keysCollected</strong> variable when the <strong class="source-inline">OnKeyCollected</strong> event <span>is triggered:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">bool arg0</strong>: Our <strong class="source-inline">EventSystem</strong> requires us to pass an argument with the handler event. We don’t need to pass any parameters for the key collected event, but we must still declare something! A bool value being the smallest type, I feel, is the least evil we can <span>do here.</span></li><li class="calibre15"><strong class="source-inline">EventConstants.OnKeyCollected</strong>: Be sure to add it to <strong class="source-inline">EventCostants</strong> to resolve the missing <span>definition error.</span></li></ul></li>
</ul>
<p class="calibre3">Excellent – we have a quest! Now, if only we could be given the quest! We don’t have snarky NPCs in our game standing on street corners, just giving out quests to any weary traveler passing<a id="_idIndexMarker914" class="pcalibre1 pcalibre calibre6"/> through, so we’ll leverage some reusable components <a id="_idIndexMarker915" class="pcalibre1 pcalibre calibre6"/>we already have to trigger the start of <span>our quest.</span></p>
<h4 class="calibre29">Quest giver GameObject</h4>
<p class="calibre3">We don’t need a new<a id="_idIndexMarker916" class="pcalibre1 pcalibre calibre6"/> script for giving the quest to the player; we just need to start <em class="italic">Collect Keys Quest</em>. We can easily do that by creating a trigger volume in the environment, using our ever-so-useful and reusable <strong class="source-inline">TriggerEvent</strong> component, and simply calling the publicly declared <strong class="source-inline">StartQuest()</strong> method on a <span><strong class="source-inline">CollectKeysQuest</strong></span><span> component.</span></p>
<p class="calibre3">Here’s what it’ll look like in the <strong class="bold">Scene</strong> view and <span><strong class="bold">Inspector</strong></span><span> view:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer126">
<img alt="Figure 9.6 – Quest giver object in the scene" src="image/B18347_09_6.jpg" class="calibre99"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Quest giver object in the scene</p>
<p class="calibre3">Have a go at constructing the object and components that make up the <em class="italic">quest giver</em> object and place it in the level near where the <span>player starts.</span></p>
<p class="calibre3">Did you manage to <a id="_idIndexMarker917" class="pcalibre1 pcalibre calibre6"/>assemble it successfully? Let’s review <span>the steps:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new GameObject in the scene and name it <strong class="source-inline">Quest Giver – Keys Quest</strong>, then position it in the level near where the player starts (refer to <span><em class="italic">Figure 9</em></span><em class="italic">.6</em> for <span>an example).</span></li>
<li class="calibre15">(<em class="italic">A</em>) Add the <strong class="source-inline">CollectKeysQuest</strong> script to the new object. <em class="italic">Collect Keys Quest</em> should be selected in the <strong class="bold">Quest Name</strong> dropdown since it’s our only quest, and set the number of keys required <span>to three.</span></li>
<li class="calibre15">(<em class="italic">B</em>) Add a <strong class="source-inline">BoxCollider2D</strong> component next (use the <strong class="bold">Add Component</strong> button) and be sure to set <strong class="bold">Is Trigger</strong> to <strong class="source-inline">true</strong> because we don’t want the player to interact with this GameObject physically; we only want to use it as a trigger volume. Adjust the collider’s size to guarantee the player will collide <span>with it.</span></li>
<li class="calibre15">(<em class="italic">C</em>) Add a <strong class="source-inline">TriggeredEvent</strong> component and wire up the methods that are called when <strong class="source-inline">OnTriggered()</strong> <span>is invoked.</span></li>
<li class="calibre15">Click the little plus (<strong class="bold">+</strong>) button and add <span>two events:</span><ol class="calibre42"><li class="upper-roman">Drag the <strong class="source-inline">CollectKeysQuest</strong> component to the first event field and select the <strong class="source-inline">CollectKeysQuest.StartQuest()</strong> method from the <span>drop-down list.</span></li><li class="upper-roman">Drag <strong class="source-inline">BoxCollider2D</strong> to the second event field, select <strong class="source-inline">BoxCollider2D.enabled</strong> from the dropdown, and leave the checkbox unticked (that is, set <strong class="bold">Enabled</strong> to <strong class="source-inline">false</strong>; this will disable the collider and prevent triggering <em class="italic">start the quest</em> <span>additional times).</span></li><li class="upper-roman">Ensure only the player can trigger the quest start by ticking <span>off </span><span><strong class="source-inline">IsTriggeredByPlayer</strong></span><span>.</span></li></ol></li>
<li class="calibre15">As the final step, save the <strong class="bold">Quest Giver</strong> object as a <strong class="source-inline">Prefab</strong> object in the <strong class="source-inline">Assets/Prefabs</strong> folder (by dragging it from the hierarchy into the <strong class="bold">Project</strong> window). That way, we can quickly drop a quest giver into the <span>level later.</span></li>
</ol>
<p class="calibre3">Quest accepted! You <a id="_idIndexMarker918" class="pcalibre1 pcalibre calibre6"/>wouldn’t start a quest that was impossible to complete, would you? Now, let’s see how we complete <em class="italic">Collect </em><span><em class="italic">Keys Quest</em></span><span>.</span></p>
<h4 class="calibre29">Quest completion</h4>
<p class="calibre3">We’ve defined a <a id="_idIndexMarker919" class="pcalibre1 pcalibre calibre6"/>specific quest, we’ve given the quest to the player, and now we must progress on the quest to complete it. Progress is made when we collect keys in the game level (you know, kind of like the collection game we completed as the first project in <span>this book).</span></p>
<p class="calibre3">In the <strong class="source-inline">CollectKeysQuest</strong> class, as you know, the <strong class="source-inline">KeyCollected()</strong> method is called when the <strong class="source-inline">OnKeyCollected</strong> event is triggered. We left it at only incrementing the variable, keeping track of the number of keys collected. Let’s finish it up by evaluating whether the quest requirements have been satisfied to complete <span>the quest.</span></p>
<p class="calibre3">Complete the <strong class="source-inline">KeyCollected</strong> method by adding the <strong class="source-inline">if</strong> block, <span>like so:</span></p>
<pre class="source-code">
    private void KeyCollected(int keyId)
    {
        _keysCollected++;
        if (_keysCollected &gt;= _numKeysRequired)
        {
            QuestSystem.Instance.CompleteQuest(
                QuestName.ToString());
            EventSystem.Instance.TriggerEvent(
                EventConstants.OnQuestCompleted, QuestName);
        }
    }</pre> <p class="calibre3">A very simple <strong class="source-inline">if</strong> statement checks whether the incremented <strong class="source-inline">_keysCollected</strong> variable is greater than or equal to (<strong class="source-inline">&gt;=</strong>) the number of keys required to complete the quest, as defined by the <strong class="source-inline">_numKeysRequired</strong> variable (set in the <strong class="bold">Inspector</strong> view). If the statement evaluates to true, <strong class="source-inline">then</strong> we’ll do <span>the following:</span></p>
<ul class="calibre17">
<li class="calibre15">Call <strong class="source-inline">CompleteQuest()</strong> on the <strong class="source-inline">QuestSystem</strong> Singleton instance and pass in the quest name as the parameter. We need to use <strong class="source-inline">ToString()</strong> on the <strong class="source-inline">QuestName</strong> variable because it is an <strong class="source-inline">enum</strong> value, and internally, it is stored as an <strong class="source-inline">int</strong> type; we need a <strong class="source-inline">string</strong> type as <span>the argument.</span></li>
<li class="calibre15">Trigger the <strong class="source-inline">OnQuestCompleted</strong> event via the <strong class="source-inline">EventSystem</strong> Singleton instance <a id="_idIndexMarker920" class="pcalibre1 pcalibre calibre6"/>and, again, pass in <strong class="source-inline">QuestName</strong> as a parameter. This is also a <span><strong class="source-inline">string</strong></span><span> type.</span></li>
</ul>
<p class="calibre3">The <em class="italic">UNDONE token quest</em> is <span>complete. Yay!</span></p>
<h4 class="calibre29">Quest event constants added</h4>
<p class="calibre3">We need to add <a id="_idIndexMarker921" class="pcalibre1 pcalibre calibre6"/>some event name constants to support what we just added for the quest system and <em class="italic">Collect Keys Quest</em>. As a recap, here’s what the <strong class="source-inline">EventConstants</strong> script should look like now. I have added some comments for some quick organization to keep <span>things tidy:</span></p>
<pre class="source-code">
public class EventConstants
{
    public const string OnMyEvent = "OnMyEvent";
    // QuestSystem events.
    public const string OnQuestCompleted = "OnQuestCompleted";
    // Quests' events.
    public const string OnKeyCollected = "OnKeyCollected";
}</pre> <p class="calibre3">Our quest system has come together nicely, but we’re still missing one final bit of functionality, and that is being able to know whether or not a quest that was started (that is, added to <a id="_idIndexMarker922" class="pcalibre1 pcalibre calibre6"/>the <strong class="source-inline">_quests</strong> dictionary) has been completed (that is, the requirements of the quest mission have been satisfied, and <strong class="source-inline">CompleteQuest()</strong> <span>was called).</span></p>
<h3 class="calibre10">Quest status</h3>
<p class="calibre3">To know the quest’s <a id="_idIndexMarker923" class="pcalibre1 pcalibre calibre6"/>status, go ahead and add the following <strong class="source-inline">IsQuestComplete()</strong> method to the <span><strong class="source-inline">QuestSystem</strong></span><span> class:</span></p>
<pre class="source-code">
    public bool IsQuestComplete(string questName)
    {
        if (_quests.TryGetValue(questName, out bool status))
            return status;
        return false;
    }</pre> <p class="calibre3">You should recognize a familiar pattern here with <strong class="source-inline">TryGetValue()</strong> (as a method available in <strong class="source-inline">Dictionary</strong>) – we’ve covered a similar pattern with <strong class="source-inline">TryGetComponent()</strong> several times. <strong class="source-inline">TryGetValue()</strong> will return <strong class="source-inline">true</strong> if the value exists in the <strong class="source-inline">_quests</strong> dictionary. Then, set the returned value to the <strong class="source-inline">out</strong> variable, <strong class="source-inline">status</strong>, for immediate consumption by the following <strong class="source-inline">if</strong> block code. This is extremely convenient, and, as I’ve espoused, I’m a big fan of this pattern (even going so far as to replicate this pattern in <span>my code).</span></p>
<p class="calibre3">We’ll continue with short-circuiting the method by immediately returning the quest’s <strong class="source-inline">status</strong> from the <strong class="source-inline">TryGetValue()</strong> call. Otherwise, we return <strong class="source-inline">false</strong>, indicating a default condition of the quest not being complete due to it not even existing in <span>the dictionary.</span></p>
<p class="calibre3">Now that we can <a id="_idIndexMarker924" class="pcalibre1 pcalibre calibre6"/>query the status of a specific quest from our <strong class="source-inline">QuestSystem</strong> Singleton instance, we can create a reusable component to use in our game to <span>respond accordingly.</span></p>
<h3 class="calibre10">Quest completed component</h3>
<p class="calibre3">We’ll need something <a id="_idIndexMarker925" class="pcalibre1 pcalibre calibre6"/>to check for quest completion when the player gets to the habitat entryway. This will allow us to show the security puzzle lock if the quest has been completed or provide some other action <span>if not.</span></p>
<p class="calibre3">Create a new script named <strong class="source-inline">QuestHasCompleted</strong> in the <span><strong class="source-inline">Assets/Scripts/Quests</strong></span><span> folder:</span></p>
<pre class="source-code">
using UnityEngine;
using UnityEngine.Events;
public class QuestHasCompleted : MonoBehaviour
{
    public QuestNames QuestName;
    public UnityEvent OnQuestComplete;
    public UnityEvent OnQuestIncomplete;
    public void CheckQuestComplete()
    {
        if (QuestSystem.Instance.
            IsQuestComplete(QuestName.ToString()))
        {
            OnQuestComplete?.Invoke();
            return;
        }
        OnQuestIncomplete?.Invoke();
    }
}</pre> <p class="calibre3">This isn’t anything we haven’t seen before. The <strong class="source-inline">QuestName</strong> field will allow us to specify which quest we want to know the completion status for in the <strong class="bold">Inspector</strong> view. The <strong class="source-inline">UnityEvent</strong> fields will enable us to set actions for complete and incomplete <span>statuses. Simples.</span></p>
<p class="calibre3">Here’s how an object<a id="_idIndexMarker926" class="pcalibre1 pcalibre calibre6"/> based on this new component will look in the <span><strong class="bold">Inspector</strong></span><span> view:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer127">
<img alt="Figure 9.7 – Puzzle trigger object setup" src="image/B18347_09_7.jpg" class="calibre100"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Puzzle trigger object setup</p>
<p class="calibre3">Let’s create this <em class="italic">puzzle trigger</em> object now and wire it up so that when the player enters the trigger volume, and if <em class="italic">Collect Keys Quest</em> has been completed, it will disable <strong class="source-inline">PlayerInput</strong> (ensuring the player can no longer move) and show <strong class="bold">Puzzle</strong> (solving the entryway security<a id="_idIndexMarker927" class="pcalibre1 pcalibre calibre6"/> puzzle lock is the player’s goal for <span>this level).</span></p>
<p class="calibre3">Here’s how we construct a <em class="italic">Has the quest been </em><span><em class="italic">completed?</em></span><span> object:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new empty GameObject in the <strong class="bold">Hierarchy</strong> We’ll name this <strong class="source-inline">Puzzle Trigger</strong> because we want to show the puzzle when the player reaches the <span>habitat entryway.</span></li>
<li class="calibre15">(<em class="italic">A</em>) Add a <strong class="source-inline">QuestHasCompleted</strong> component and select <strong class="bold">Collect Keys Quest</strong> from the dropdown of available <span>quest names.</span></li>
<li class="calibre15">Assign the following events for <strong class="source-inline">OnQuestComplete()</strong> (click the plus (<strong class="bold">+</strong>) button to add a <span>new one):</span><ol class="calibre42"><li class="upper-roman">Assign <strong class="bold">Player</strong> from the root of the <strong class="bold">Scene Hierarchy</strong>, select <strong class="source-inline">PlayerInput.enabled</strong> from the dropdown, and leave the checkbox unticked. Disabling <strong class="source-inline">PlayerInput</strong> in this way will mean no input will be processed to enact with the player – we don’t want the player character to move any longer because it would now be time to solve <span>the puzzle.</span></li><li class="upper-roman">The following assignment is for our future selves; we’ll use a reference to the <strong class="bold">Key Puzzle</strong> object and make it active (display it) so that the player can work on solving it – <strong class="bold">Key Puzzle</strong> will be added in the last section of this chapter, so we’ll revisit this <span>assignment then.</span></li></ol></li>
<li class="calibre15">(<em class="italic">B</em>) Add a <strong class="source-inline">TriggeredEvent</strong> component and assign the <strong class="source-inline">QuestHasCompleted</strong> component to the <strong class="source-inline">OnTriggered</strong> event, then select <strong class="source-inline">QuestHasCompleted.CheckQuestComplete()</strong> from the dropdown. Ensure <strong class="bold">IsTriggeredByPlayer</strong> <span>is ticked.</span></li>
<li class="calibre15">Don’t forget to add a <strong class="source-inline">BoxCollider2D</strong> component and set <strong class="bold">Is Trigger</strong> to <strong class="source-inline">true</strong>; the size will be adjusted accordingly concerning the habitat entryway so that the player will interact with it when <span>reaching it.</span></li>
</ol>
<p class="calibre3">For placement, if you haven’t taken the liberty of adding the habitat entryway to your level yet, now’s the <a id="_idIndexMarker928" class="pcalibre1 pcalibre calibre6"/>time! We haven’t explored every nuance of your level design while bringing everything together – naturally, you’ve been doing your level <span>design homework:</span></p>
<ol class="calibre14">
<li class="calibre15">Place the habitat entryway sprite <em class="italic">entryway</em> from the <strong class="source-inline">Assets/Sprites/Object Elements</strong> folder into the environment and use the <strong class="source-inline">Background</strong> <strong class="bold">Sorting Layer</strong>. You can organize it in the <strong class="bold">Scene Hierarchy</strong> using what we previously established as the <strong class="bold">Level (Default)</strong> | <strong class="bold">In </strong><span><strong class="bold">Back</strong></span><span> structure.</span></li>
<li class="calibre15">Place the <strong class="bold">Puzzle Trigger</strong> object at the entryway and set the collider size accordingly (refer to <span><em class="italic">Figure 9</em></span><em class="italic">.7</em> for <span>an example).</span></li>
</ol>
<p class="calibre3">As we saw in the preceding code and description, the <strong class="source-inline">QuestHasCompleted</strong> component has an event that is triggered when we check the status for both complete and incomplete quest statuses. We already populated the <strong class="source-inline">OnQuestComplete()</strong> event but also have an <strong class="source-inline">OnQuestIncomplete()</strong> event. We won’t be assigning any function here for now, but imagine that we could display a dialog to our player stating that the quest’s requirements haven’t been met for them <span>to proceed.</span></p>
<p class="callout-heading">Challenge | Quest system diagram</p>
<p class="callout">Create a basic object reference diagram for the quest system while using the event system diagram in <span><em class="italic">Figure 9</em></span><em class="italic">.1</em> as a reference. Don’t be so concerned with the shapes you choose to represent each part, but do be consistent and use the same shape for the same object type. If you want to challenge yourself further, create a <span>UML diagram!</span></p>
<p class="calibre3">Everything is in<a id="_idIndexMarker929" class="pcalibre1 pcalibre calibre6"/> place for us to fully execute a quest’s life cycle. Now, we need to collect those pesky <span>key pieces!</span></p>
<h2 id="_idParaDest-171" class="calibre8"><a id="_idTextAnchor180" class="pcalibre1 pcalibre calibre6"/>Collecting keys</h2>
<p class="calibre3">We’ve tackled<a id="_idIndexMarker930" class="pcalibre1 pcalibre calibre6"/> player<a id="_idIndexMarker931" class="pcalibre1 pcalibre calibre6"/> collectible items a few different ways now, so collectible key items will be a familiar concept. The only difference is that we will now rely on <strong class="source-inline">EventSystem</strong> to trigger a <em class="italic">key collected</em> event. As we already know, the <strong class="source-inline">CollectKeysQuest</strong> quest is listening for <strong class="source-inline">OnKeyCollected</strong> being invoked, so this is where we’ll implement <span>triggering it.</span></p>
<p class="calibre3">As you could probably also guess, we’re going to use a <strong class="source-inline">Prefab</strong> object for the puzzle piece keys (via <strong class="bold">Prefab Variant</strong>). So, that will require a component to implement the key <span>collection behavior.</span></p>
<h3 class="calibre10">KeyItem component</h3>
<p class="calibre3">First, let’s prepare<a id="_idIndexMarker932" class="pcalibre1 pcalibre calibre6"/> the artwork we’ll use to make the collectible key pieces. For a visual reference, here’s what we’ll be working with for creating the key pieces and a placeholder security puzzle lock on the habitat entryway door (if it makes you nervous, try disregarding the encroaching plant <span>entity’s vines):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer128">
<img alt="Figure 9.8 – Key variants and entryway security puzzle lock" src="image/B18347_09_8.jpg" class="calibre101"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Key variants and entryway security puzzle lock</p>
<p class="callout-heading">Art assets</p>
<p class="callout">To follow along while using the same artwork that was created for this project, download the assets from this book’s GitHub <span>repository: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/Art-Assets</span></a><span>.</span></p>
<p class="calibre3">Import the art assets <a id="_idIndexMarker933" class="pcalibre1 pcalibre calibre6"/>for the security puzzle lock, the puzzle placeholder image, and the individual key pieces into <strong class="source-inline">Assets/Sprites/Puzzle</strong>. For the provided key pieces artwork, I’ve set the following properties for the desired size <span>and placement:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Pixels Per </strong><span><strong class="bold">Unit</strong></span><span>: </span><span><strong class="source-inline">500</strong></span></li>
<li class="calibre15"><strong class="bold">Pivot</strong>: <strong class="bold">Custom</strong>, then adjust the <strong class="source-inline">X</strong> and <strong class="source-inline">Y</strong> values so that the pivot is located in the center of <span>the art:</span></li>
</ul>
<div class="calibre2">
<div class="img---figure" id="_idContainer129">
<img alt="Figure 9.9 – Key pieces art – import settings" src="image/B18347_09_9.jpg" class="calibre102"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Key pieces art – import settings</p>
<p class="calibre3">Now, let’s write the code for the collectible key item so that we’ll be ready to assemble the Prefabs for each <span>key piece.</span></p>
<p class="calibre3">Create a new script <a id="_idIndexMarker934" class="pcalibre1 pcalibre calibre6"/>named <strong class="source-inline">KeyItem</strong> in the <strong class="source-inline">Assets/Scripts</strong> folder with the <span>following code:</span></p>
<pre class="source-code">
using UnityEngine;
[RequireComponent (typeof(Collider2D))]
public class KeyItem : MonoBehaviour
{
    private void OnTriggerEnter2D(Collider2D collision)
    {
        if (collision.CompareTag(Tags.Player))
        {
            EventSystem.Instance.TriggerEvent(
                EventConstants.OnKeyCollected, false);
            Destroy(gameObject);
        }
    }
}</pre> <p class="calibre3">Finally, yes – there is where we specifically trigger the <span><strong class="source-inline">OnKeyCollected</strong></span><span> event!</span></p>
<p class="calibre3">This script for collecting items may be even more straightforward than the ones that came before it. We use <strong class="source-inline">OnTriggerEnter2D()</strong> to detect when the player enters the trigger volume. Does this mean we need a collider component as a sibling on the GameObject to which we attach the <strong class="source-inline">KeyItem</strong> script? Yes, that’s right – we need a <strong class="source-inline">Collider2D</strong> object with <strong class="bold">Is Trigger</strong> enabled. When we assemble our key Prefabs, you’ll see we’ll use <strong class="source-inline">CircleCollider2D</strong>, keeping it nice <span>and efficient.</span></p>
<p class="calibre3">Also, note that we’re comparing the tag of the collision object – using our <strong class="source-inline">Tags.Player</strong> constant – to ensure that only the player interacts with the <span>trigger volume.</span></p>
<p class="calibre3">Let’s give the event system <strong class="source-inline">TriggerEvent()</strong> call some additional attention because our event system requires a second parameter to be passed in as an event argument. We have to pass <span>in </span><span><em class="italic">something</em></span><span>.</span></p>
<p class="calibre3">As explained when the handler method was introduced, a bool value is the smallest data type in C# (1 byte); we’ll pass in <strong class="source-inline">false</strong> as the type’s value – we can also take the liberty of this meaning, “<em class="italic">True or false, will I pass an argument value for this event? False.</em>” We don’t even need to specify the <strong class="source-inline">bool</strong> type – as in <strong class="source-inline">TriggerEvent&lt;bool&gt;()</strong> – because the type can be inferred from the <span>argument’s value.</span></p>
<p class="calibre3">Lastly, we’ll destroy the key piece object because we collected it and no longer need it in the level. We’re just using <strong class="source-inline">Destroy(gameObject)</strong> directly here for brevity. Still, for consistency, if <a id="_idIndexMarker935" class="pcalibre1 pcalibre calibre6"/>you’d like, you should be able to hook up the reusable <strong class="source-inline">Destroyer</strong> component for yourself by now (<span>challenge accepted?).</span></p>
<p class="calibre3">Now, it’s time to construct the collectible key <span>item Prefab!</span></p>
<h3 class="calibre10">KeyItem Prefab and variants</h3>
<p class="calibre3">Creating Prefabs for<a id="_idIndexMarker936" class="pcalibre1 pcalibre calibre6"/> reusable items in our project is second nature by now. Let’s breeze through the steps to create a new collectible key <a id="_idIndexMarker937" class="pcalibre1 pcalibre calibre6"/>item <strong class="bold">Prefab</strong>; then, we’ll make <strong class="bold">variants</strong> that have all three <a id="_idIndexMarker938" class="pcalibre1 pcalibre calibre6"/>key pieces and their <span>individual artwork:</span></p>
<ol class="calibre14">
<li class="calibre15">Drag the <strong class="source-inline">key1</strong> Sprite (which we previously imported) from the <strong class="source-inline">Assets/Sprites/Puzzle</strong> folder in the <strong class="bold">Project</strong> window into the <span><strong class="bold">Scene Hierarchy</strong></span><span>.</span></li>
<li class="calibre15">Double-click it to focus on it in the <strong class="bold">Scene</strong> view (it should be positioned at <strong class="source-inline">(0, 0, 0)</strong> if not, <strong class="bold">Reset</strong> the <strong class="bold">Transform</strong> option in the <strong class="bold">Inspector</strong> view so that it is – we don’t want any offsets being saved in <span>the Prefab).</span></li>
<li class="calibre15">Rename <strong class="source-inline">key1</strong> to simply <strong class="source-inline">key</strong> (while selected at the top of the <strong class="bold">Inspector</strong> view, click it a second time, or use the <em class="italic">F2</em>/<em class="italic">Enter</em> key) – this will make sense later when we create the additional <span>key variants.</span></li>
<li class="calibre15">Right-click on it and select <strong class="bold">Create Empty Parent</strong>, then rename <span>it </span><span><strong class="source-inline">Key1</strong></span><span>.</span></li>
<li class="calibre15">Add a <strong class="source-inline">CircleCollider2D</strong> sibling component to the <strong class="source-inline">Key1</strong> object and enable <strong class="bold">Is Trigger</strong>. Set the <strong class="bold">Radius</strong> value so that its hitbox is slightly larger than the puzzle piece Sprite (refer to <span><em class="italic">Figure 9</em></span><span><em class="italic">.10</em></span><span>).</span></li>
<li class="calibre15">Add the <strong class="source-inline">KeyItem</strong> script to the parent <strong class="source-inline">Key1</strong> object – there’s nothing to configure; all the behavior is handled <span>in code.</span></li>
<li class="calibre15">Drag <strong class="source-inline">Key1</strong> from the <strong class="bold">Hierarchy</strong> to the <strong class="source-inline">Assets/Prefabs</strong> folder in the <strong class="bold">Project</strong> window to make it <span>a Prefab.</span></li>
</ol>
<p class="calibre3">Now, to create the additional key piece Prefabs as Prefab variants, follow <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">Select <strong class="source-inline">Key1</strong> in the <strong class="bold">Hierarchy</strong> and press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em> twice to make two duplicates <span>of it.</span></li>
<li class="calibre15">Rename the duplicates <strong class="source-inline">Key2</strong> and <span><strong class="source-inline">Key3</strong></span><span>, respectively.</span></li>
<li class="calibre15">For <strong class="source-inline">Key2</strong>, on the child key object, change the <strong class="source-inline">SpriteRenderer</strong> <strong class="bold">Sprite</strong> field to <strong class="source-inline">key2</strong>. Then, do the same for <strong class="source-inline">Key3</strong>, and set the <strong class="bold">Sprite</strong> field <span>to </span><span><strong class="source-inline">key3</strong></span><span>.</span></li>
<li class="calibre15">Drag <strong class="source-inline">Key2</strong> from the <strong class="bold">Hierarchy</strong> into the <strong class="source-inline">Assets/Prefabs</strong> folder. Then, in the <strong class="bold">Create Prefab for Variant?</strong> dialog, click the <strong class="bold">Prefab Variant</strong> button (we’ll share all the same configurations as the <strong class="source-inline">Key1</strong> Prefab but override the <strong class="bold">Sprite</strong> field for the key piece variants). Then, do the same <span>for </span><span><strong class="source-inline">Key3</strong></span><span>.</span></li>
</ol>
<p class="callout-heading">Tip | Prefab Edit Mode | Variants</p>
<p class="callout">Note that when opening <strong class="bold">Prefab Variant</strong> in <strong class="bold">Prefab Edit Mode</strong>, all overrides are indicated by a blue indicator along the left edge of the <span><strong class="bold">Inspector</strong></span><span> view.</span></p>
<p class="calibre3">Here are the key <a id="_idIndexMarker939" class="pcalibre1 pcalibre calibre6"/>Prefabs and variants we <span>just created:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer130">
<img alt="Figure 9.10 – KeyItem pieces Prefabs" src="image/B18347_09_10.jpg" class="calibre103"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.10 – KeyItem pieces Prefabs</p>
<p class="calibre3">The player can now collect the key pieces to complete the quest, but how should we place them in the level? First things first, delete the <strong class="source-inline">Key1</strong>, <strong class="source-inline">Key2</strong>, and <strong class="source-inline">Key3</strong> objects from the scene; we’re going to spawn <span>them in.</span></p>
<p class="callout-heading">QuestSystem | Complete code</p>
<p class="callout">To view the complete code for the <strong class="source-inline1">QuestSystem</strong> class and all the quest-related code in this chapter, visit <a id="_idIndexMarker940" class="pcalibre1 pcalibre calibre6"/>this book’s GitHub <span>repository: </span><a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/" class="pcalibre1 pcalibre calibre6"><span>https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch9/</span></a><span>.</span></p>
<h3 class="calibre10">Key instantiator – Randomness</h3>
<p class="calibre3">Let’s explore an <a id="_idIndexMarker941" class="pcalibre1 pcalibre calibre6"/>easy way to implement some basic random instantiation of objects so that the game is different every time it’s played – addressing replayability is good for <span>player engagement!</span></p>
<p class="callout-heading">Randomness in game design</p>
<p class="callout">You’ll come across <a id="_idIndexMarker942" class="pcalibre1 pcalibre calibre6"/>the topic of randomness in games in your game development journey – and not just for card games! The role of randomness in game design is appropriate for this entire chapter – heck, this entire book! So, keeping that in mind, this will be one of the most basic examples of how you can add randomness to a simple mechanic with effective results. In the level design, we will instantiate the three keys at random locations identified by a larger number of <span>spawn points.</span></p>
<p class="calibre3">The structure of the code will be to take an array of <strong class="source-inline">KeyItem</strong> (objects) (that is, the key pieces) and an array of <strong class="source-inline">Transform</strong> (positions) (that is, points placed throughout the level) as input and then output (that is, instantiate) the objects in order at the next randomly selected spawn point (being sure not to reuse any of the <span>spawn points).</span></p>
<p class="calibre3">Did you visualize what the code could look like? Let’s see. Let’s walk through creating the code for <span>each part.</span></p>
<p class="calibre3">Start by creating a new script named <strong class="source-inline">KeyInstantiator</strong> in the <span><strong class="source-inline">Assets/Scripts</strong></span><span> folder.</span></p>
<p class="calibre3">We’ll declare the arrays that hold the key objects and the spawn <span>points first:</span></p>
<pre class="source-code">
using UnityEngine;
using System.Collections.Generic;
public class KeyInstantiator : MonoBehaviour
{
    [SerializeField] private KeyItem[] _keyPrefabs;
    [SerializeField] private Transform[] _spawnPoints;
    …</pre> <p class="calibre3">Here, we declared <span>two arrays:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">KeyItem[] _keyPrefabs</strong>: This has been serialized so that it can be assigned in the <strong class="bold">Inspector</strong> view; we’ll assign the objects to be instantiated (the key puzzle piece Prefabs). We are declaring the type as <strong class="source-inline">KeyItem</strong> instead of a more generic <strong class="source-inline">GameObject</strong> because of the <span>following reasons:</span><ul class="calibre22"><li class="calibre15">We only want Prefabs that include the <strong class="source-inline">KeyItem</strong> component to be assignable to <span>the array.</span></li><li class="calibre15">While referencing an item in the collection, we will consume the item as the <strong class="source-inline">KeyItem</strong> type and avoid making a <span><strong class="source-inline">GetComponent&lt;KeyItem&gt;()</strong></span><span> call.</span></li></ul></li>
<li class="calibre15"><strong class="source-inline">Transform[] _spawnPoints</strong>; This has been serialized so that it can be assigned in the <strong class="bold">Inspector</strong> view; we’ll assign the GameObjects that are placed throughout the level where key pieces can potentially spawn. With game design in mind, be sure<a id="_idIndexMarker943" class="pcalibre1 pcalibre calibre6"/> to place more than three in a level so that we’re not just randomizing what key piece appears at the same three positions – your limit will be the design or your level (and I’d be sure to place one of them where you happen to have several infected <span>robots patrolling).</span></li>
</ul>
<p class="callout-heading">Array (C#)</p>
<p class="callout">An array is a type that’s declared with opposing square braces (<strong class="source-inline1">[]</strong>) and represents a collection of items of that type. Items in the array are addressed by their index value, which starts at zero (for example, <strong class="source-inline1">_spawnPoints[0]</strong> is the first <strong class="source-inline1">Transform</strong> stored in <span>the collection).</span></p>
<p class="callout">Here’s some additional <span>reading: </span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/" class="pcalibre1 pcalibre calibre6"><span>https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/</span></a><span>.</span></p>
<p class="calibre3">Next, we’ll add a <strong class="source-inline">List</strong> type to work with the currently available spawn points from the <strong class="source-inline">_spawnPoints</strong> array. Why are we doing this? We already have an <strong class="source-inline">array</strong> type, and now a <strong class="source-inline">List</strong> type? Yes. Arrays in C# are not easy to work with if we want to resize them (that is, remove an item), but a <strong class="source-inline">List</strong> <span>type is.</span></p>
<p class="calibre3">Declare the following <strong class="source-inline">List</strong> type and add the <strong class="source-inline">Start()</strong> method with the spawn <span>points assignment:</span></p>
<pre class="source-code">
    private List&lt;Transform&gt; _availablePoints;
    private void Start()
    {
        _availablePoints = new List&lt;Transform&gt;(_spawnPoints);
        …</pre> <p class="calibre3">We declared a <strong class="source-inline">List</strong> type<a id="_idIndexMarker944" class="pcalibre1 pcalibre calibre6"/> and initialized it in <strong class="source-inline">Start()</strong> with the <span><strong class="source-inline">_spawnPoints</strong></span><span> value:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">List&lt;Transform&gt; _availablePoints</strong>: This is the <strong class="source-inline">private</strong> member variable because we’ll just work with the points inside the class. We’ll use this to determine the points available to instantiate <span>a key.</span></li>
<li class="calibre15"><strong class="source-inline">Start()</strong>: We’ll scatter the key pieces throughout the level when the game starts… so we’ll use the <strong class="source-inline">MonoBehaviour</strong>-provided Unity message event <strong class="source-inline">Start()</strong> for <span>that, yeah.</span></li>
</ul>
<p class="calibre3">Now comes the fun part – random position instantiation! Add the following <strong class="source-inline">foreach</strong> loop to the <strong class="source-inline">Start()</strong> <span>method’s implementation:</span></p>
<pre class="source-code">
        foreach (var item in _keyPrefabs)
        {
            var randomIndex = Random.Range(
                0, _availablePoints.Count);
            Instantiate(item,
                _availablePoints[randomIndex].position,
                Quaternion.identity);
            _availablePoints.RemoveAt(randomIndex);
        }
    }
}</pre> <p class="calibre3">Okay, let’s do a breakdown of this <span>final section:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">foreach (var item in _keyPrefabs)</strong>: We’re using <strong class="source-inline">foreach</strong> to iterate the available <strong class="source-inline">KeyItem</strong> Prefabs assigned in the <strong class="bold">Inspector</strong> view (all three of our key <span>Prefab/variant pieces).</span></li>
<li class="calibre15"><strong class="source-inline">Random.Range(0, _availablePoints.Count)</strong>: A bit of magic? No, this is <a id="_idIndexMarker945" class="pcalibre1 pcalibre calibre6"/>Unity’s <strong class="bold">Random Number Generator</strong> (<strong class="bold">RNG</strong>) hard at work returning a random number in a range that is inclusive of the first number and exclusive of the second <a id="_idIndexMarker946" class="pcalibre1 pcalibre calibre6"/>number (only valid when using <strong class="source-inline">int</strong> values, however, like in our use case; otherwise, it’s inclusive of the second number when using <strong class="source-inline">float</strong> values). We don’t want to use the <strong class="source-inline">Count</strong> value because array indexes are zero-based (so we’d have to specify <strong class="source-inline">Count - </strong><span><strong class="source-inline">1</strong></span><span> otherwise):</span><p class="calibre3">Note that we obtain <strong class="source-inline">_availablePoints.Count</strong> every iteration. That’s because, only two lines below, we’re removing the randomly selected point from <strong class="source-inline">List</strong> by the <strong class="source-inline">randomIndex</strong> value that’s returned, so it’s not <span>used again.</span></p></li>
</ul>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span><strong class="source-inline1">Random.Range()</strong></span><span>: </span><a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Random.Range.xhtml</span></a><span>.</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">Instantiate()</strong>: We spawn the current <strong class="source-inline">item</strong> in the array into the scene at the randomly selected spawn point position, <strong class="source-inline">randomIndex</strong>, with zero rotation (that <span>is, </span><span><strong class="source-inline">Quaternion.Identity</strong></span><span>).</span></li>
<li class="calibre15"><strong class="source-inline">RemoveAt(ramdomIndex)</strong>: A C# <strong class="source-inline">List</strong> type provides a remove method that not only deletes an item from the collection but also resizes it. Hence, the <strong class="source-inline">Count</strong> property reflects the number of items <span>that remain.</span></li>
</ul>
<p class="calibre3">It sounds like a lot when breaking it down like this, but it’s a short and sweet random <span>placement script.</span></p>
<p class="calibre3">The last step is, of <a id="_idIndexMarker947" class="pcalibre1 pcalibre calibre6"/>course, setting the instantiator up in our scene so that the key pieces can be placed in the <span>game level.</span></p>
<h4 class="calibre29">Instantiator scene object setup</h4>
<p class="calibre3">Here’s what we’ll do to<a id="_idIndexMarker948" class="pcalibre1 pcalibre calibre6"/> set up the new <strong class="source-inline">KeyInstantiator</strong> script on an object in our scene so that our keys are randomly spawned for the player <span>to find:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a <strong class="bold">Key Instantiator</strong> object as a child of <strong class="bold">GameManager</strong>. To that, add the <span><strong class="source-inline">KeyInstantiator</strong></span><span> component.</span></li>
<li class="calibre15">In the <strong class="bold">Inspector</strong> view, drag the key Prefabs from the <strong class="source-inline">Assets/Prefabs</strong> folder in the <strong class="bold">Project</strong> window to the <span><strong class="bold">KeyPrefabs</strong></span><span> field.</span></li>
<li class="calibre15">Then, after placing – more than three! – GameObjects in the level that represent the possible spawn position of a key piece, select them in the <strong class="bold">Hierarchy</strong> and drag them to the <strong class="bold">SpawnPoints</strong> field in the <strong class="bold">Inspector</strong> view (don’t forget that you can lock the <strong class="bold">Inspector</strong> window so that it doesn’t change when you’re selecting the objects you want <span>to assign).</span></li>
</ol>
<p class="calibre3"><span><em class="italic">Figure 9</em></span><em class="italic">.11</em> shows the result of the <span>preceding steps:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer131">
<img alt="Figure 9.11 – Key instantiator object setup" src="image/B18347_09_11.jpg" class="calibre104"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Key instantiator object setup</p>
<p class="calibre3">You may have noticed the pink diamonds in the preceding figure. I’ve assigned a pink diamond icon (assignable at the top of the <strong class="bold">Inspector</strong> view) to the key spawn point objects so that they are easy to find in the <strong class="bold">Scene</strong> view while I’m working on the level design. I’ve also <a id="_idIndexMarker949" class="pcalibre1 pcalibre calibre6"/>grouped the key spawn points under a <a id="_idIndexMarker950" class="pcalibre1 pcalibre calibre6"/>parent <strong class="bold">Key Spawn Points</strong> object in <span>the </span><span><strong class="bold">Hierarchy</strong></span><span>.</span></p>
<p class="calibre3">With that, we now have key pieces randomly placed in our level when the game starts. Next, we’ll sort out a drawing issue before moving on to solving the <span>key puzzle!</span></p>
<h4 class="calibre29">Instantiated Sprite drawing order</h4>
<p class="calibre3">The key pieces will be instantiated on the <strong class="source-inline">Default</strong> <strong class="bold">Sorting Layer</strong>, and the <strong class="bold">Order in Layer</strong> value will be <strong class="source-inline">0</strong> for the default values. Because we’ve set up our environment with <em class="italic">default objects</em> originating “in the center of the depth layers,” we can be confident that the instantiated pieces will not be obstructed. This can be compensated for when instantiated if needed, but this can simply be avoided if we take some care in the <span>environment layout.</span></p>
<p class="calibre3">In this section, we learned how to create a quest system, make new quests with unique properties and requirements for completion, assign a quest to the player, and query a quest’s status to advance the gameplay. We also saw how to utilize the event system to build other systems on top of <span>its foundation.</span></p>
<p class="calibre3">In the next section, we’ll<a id="_idIndexMarker951" class="pcalibre1 pcalibre calibre6"/> integrate a sliding puzzle as the habitat entryway’s security lock system, where solving it wins <span>the game.</span></p>
<h1 id="_idParaDest-172" class="calibre5"><a id="_idTextAnchor181" class="pcalibre1 pcalibre calibre6"/>Solving the key puzzle and winning the game</h1>
<p class="calibre3">We could spend a whole lot of time here designing a novel puzzle for the security lock system. Still, that falls outside the scope of this book and would not provide the learning opportunity I want to cover – that is, using third-party assets in your game. This isn’t to say that you shouldn’t strive to introduce a new and original idea in your game – any way you can differentiate your game and offer players a remarkable and unique experience is time <span>well spent!</span></p>
<p class="calibre3">We will use the well-known sliding tile puzzle for the habitat entryway’s security <span>puzzle lock.</span></p>
<h2 id="_idParaDest-173" class="calibre8"><a id="_idTextAnchor182" class="pcalibre1 pcalibre calibre6"/>Sliding tile puzzle</h2>
<p class="calibre3">I’ve only briefly <a id="_idIndexMarker952" class="pcalibre1 pcalibre calibre6"/>mentioned <a id="_idIndexMarker953" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">Unity Asset Store</strong>, but I want to bring some well-deserved attention to it now. The Unity Asset Store contains a wealth of assets that both Unity and third parties provide. You can find just about anything you would need for your games, including pre-made systems, frameworks, characters, animations, 2D and 3D art assets, music and sound effects, VFX, and more, in almost every genre and style you <span>can imagine.</span></p>
<p class="calibre3">However, integrating solutions and assets from varying vendors isn’t always trivial. This section will be dedicated to both the value of leveraging existing pre-made assets and identifying some issues you may need to work through to have them functioning in your project. You may be thinking that I’ve alluded to a level of quality for third-party assets that indicates they are not good – while that may be true in some rare cases (buyer beware, as usual), issues can arise that have nothing to do with the asset and all to do with the changes and advances in technologies that comes with newer Unity version releases. Rather than continuing in abstract terms, let’s move forward with the specific example <span>I’ll provide.</span></p>
<p class="calibre3">For reference, here is the sliding tile puzzle we’ll create with the tiles already scrambled (refer to <span><em class="italic">Figure 9</em></span><em class="italic">.3</em> for the <span>unscrambled version):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer132">
<img alt="Figure 9.12 – Sliding puzzle scrambled tiles" src="image/B18347_09_12.jpg" class="calibre105"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Sliding puzzle scrambled tiles</p>
<p class="calibre3">As mentioned previously, we’re going to leverage an existing asset from the Unity Asset Store to rapidly incorporate a sliding puzzle feature that will include everything necessary to slice an image into tiles, scramble the tiles, respond to user input for sliding the tiles, and calculate when the puzzle has been solved. If we had to develop on our own, all of these <a id="_idIndexMarker954" class="pcalibre1 pcalibre calibre6"/>requirements would take significantly more time to create, code, debug, and test. Unity Asset Store assets generally come with the benefit of dozens of developers (or hundreds in some cases) using the assets in their projects and reporting back bugs and discrepancies to the asset developer for further improvement – and you directly benefit from <span>others’ efforts.</span></p>
<p class="calibre3">Without further ado, we’ll be using a free asset <a id="_idIndexMarker955" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">Sliding Tile Puzzle Game</strong> by Hyper Luminal <span>Games (</span><a href="https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798" class="pcalibre1 pcalibre calibre6"><span>https://assetstore.unity.com/packages/templates/packs/sliding-tile-puzzle-game-41798</span></a><span>):</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer133">
<img alt="Figure 9.13 – Sliding Tile Puzzle Game" src="image/B18347_09_13.jpg" class="calibre106"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Sliding Tile Puzzle Game</p>
<p class="calibre3">Several steps will be required to use the asset in our Unity 2022 project due to changes in the <strong class="bold">Unity Scripting API</strong>, in <a id="_idIndexMarker956" class="pcalibre1 pcalibre calibre6"/>addition to changes required to support <strong class="bold">Universal RP</strong> (<strong class="bold">URP</strong>), the <em class="italic">render pipeline</em> we’ve based the<a id="_idIndexMarker957" class="pcalibre1 pcalibre calibre6"/> project on, since the time the asset was released (way <a id="_idIndexMarker958" class="pcalibre1 pcalibre calibre6"/>back in 2016, for <span>Unity 5).</span></p>
<p class="calibre3">Let’s get started by obtaining the asset and importing it into <span>the project.</span></p>
<h3 class="calibre10">Importing the sliding tile puzzle asset</h3>
<p class="calibre3">After going through<a id="_idIndexMarker959" class="pcalibre1 pcalibre calibre6"/> the process of purchasing an asset or clicking <strong class="bold">Add to My Assets</strong>, you have the option of using the <strong class="bold">Open in Unity</strong> button from within the Unity Asset Store. Alternatively, you may open the <strong class="bold">Package Manager</strong> window in the Unity Editor, select <strong class="bold">My Assets</strong> from the <strong class="bold">Packages</strong> dropdown, find the asset in the list, click <strong class="bold">Download</strong>, and then <span>click </span><span><strong class="bold">Import</strong></span><span>.</span></p>
<p class="calibre3">In my experience, most assets are designed to be imported into your existing project. Still, some assets are provided as <em class="italic">complete projects</em> and, therefore, cannot be imported directly into your project. The sliding tile puzzle asset requires an additional step to import into your project because it is provided as a complete project, and it’s best not to overwrite any of your current <span>project settings!</span></p>
<p class="calibre3">Let’s walk through the steps; this won’t <span>take long:</span></p>
<ol class="calibre14">
<li class="calibre15">Importing the sliding tile puzzle asset from the <strong class="bold">Asset Store</strong> page or <strong class="bold">Package Manager</strong> will produce the following <strong class="bold">Importing a complete project</strong> <span>warning dialog:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer134">
<img alt="Figure 9.14 – The Importing complete project dialog" src="image/B18347_09_14.jpg" class="calibre107"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.14 – The Importing complete project dialog</p>
<ol class="calibre14">
<li value="2" class="calibre15">Click the <strong class="bold">Switch Project</strong> button to create a temporary project the asset will be imported into. Unity <a id="_idIndexMarker960" class="pcalibre1 pcalibre calibre6"/>will automatically generate a temporary project name. We’ll delete this project when we’re finished extracting the asset from it, so <span>don’t worry.</span></li>
<li class="calibre15">When Unity has opened and everything has finished importing, the <strong class="bold">Sliding Tile Puzzle Game</strong> asset will be located in the <strong class="source-inline">Assets/HyperLuminal</strong> folder (found in the <span><strong class="bold">Project</strong></span><span> window).</span></li>
<li class="calibre15">Right-click on the <strong class="source-inline">SlidingTilePuzzle</strong> folder and select <strong class="bold">Export Package…</strong>. This will open an <strong class="bold">Exporting package</strong> dialog, where you can change what’s included in the export. We want everything, so click the <strong class="bold">Export…</strong> button in the <span>bottom-right corner.</span></li>
<li class="calibre15">When the file save window opens, enter <strong class="source-inline">SlidingTilePuzzle</strong> for the <strong class="source-inline">.unitypackage</strong> filename and pick an easily accessible folder; we will be importing from that same <span>folder shortly.</span></li>
<li class="calibre15">Close Unity. You will be prompted with a <strong class="bold">Keep Project?</strong> dialog. You can safely click the <strong class="bold">Forget</strong> button since we no longer <span>need it:</span><p class="calibre3">Note that even though you confirmed forgetting it, you may still see an erroneous project show up in Unity Hub that represents this temporary project. If so, remove it and delete the <span>project folder.</span></p></li>
<li class="calibre15">Now, back in our game’s project, let’s import the saved <strong class="source-inline">.unitypackage</strong> file by going to <strong class="bold">Assets</strong> | <strong class="bold">Import Package</strong> | <strong class="bold">Custom Package…</strong> and selecting <strong class="source-inline">SlidingTilePuzzle.unitypackage</strong> from the location we saved it <span>in earlier:</span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer135">
<img alt="Figure 9.15 – The Import Unity Package dialog" src="image/B18347_09_15.jpg" class="calibre108"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The Import Unity Package dialog</p>
<ol class="calibre14">
<li value="8" class="calibre15">All the items should <a id="_idIndexMarker961" class="pcalibre1 pcalibre calibre6"/>be marked as <strong class="bold">New</strong> unless we’ve previously imported the package. Go ahead and click <strong class="bold">Import</strong> so that we can continue integrating the <span>sliding puzzle.</span></li>
</ol>
<p class="callout-heading">Tip | Project organization</p>
<p class="callout">Asset vendors make their own choices on the location of their assets in the project folder structure, so importing many third-party assets can get a bit messy and unorganized. To maintain some level of sanity in your project files, I suggest placing all third-party assets under this <strong class="source-inline1">Assets/Third </strong><span><strong class="source-inline1">Party</strong></span><span> folder.</span></p>
<p class="callout">For example, in <span><em class="italic">Figure 9</em></span><em class="italic">.15</em>, you can see <em class="italic">SlidingTilePuzzle</em>, which we will import to the <strong class="source-inline1">Assets/HyperLuminal</strong> folder. Please create a new <strong class="source-inline1">Assets/Third Party</strong> folder and move the <strong class="source-inline1">HyperLuminal</strong> folder as a child of it. <span>Mischief managed.</span></p>
<p class="calibre3">Now, let’s update the <a id="_idIndexMarker962" class="pcalibre1 pcalibre calibre6"/>asset so that it works with our Unity 2022 <span>project requirements.</span></p>
<h3 class="calibre10">Updating the puzzle tile shader</h3>
<p class="calibre3">Our first order of business <a id="_idIndexMarker963" class="pcalibre1 pcalibre calibre6"/>is to update from the built-in legacy renderer to the URP renderer. In Unity 5, we only had the built-in renderer, so it makes sense that we’d need to convert items related to the render for <span>this asset.</span></p>
<p class="calibre3">If you were to open the <strong class="source-inline">SlidingTilePuzzle</strong> example scene in the <strong class="source-inline">Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scenes</strong> folder and enter <strong class="bold">Play Mode</strong> now, you’d get a giant pink square. Pink (or magenta) is the color Unity uses to represent a material or shader error – unless you’ve specifically made an object this color, seeing it in your <strong class="bold">Scene</strong> or <strong class="bold">Game</strong> view is generally <span>not good.</span></p>
<p class="calibre3">The asset takes a Prefab approach for the type of sliding puzzle you want to make and provides Prefabs for <strong class="source-inline">3x3</strong>, <strong class="source-inline">4x4</strong>, and <strong class="source-inline">5x5 </strong>sliding puzzles – we will make a 3x3 sliding puzzle and work with that specific <strong class="source-inline">3x3</strong> Prefab. Follow these steps to update the <span>renderer-specific issues:</span></p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="source-inline">Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs</strong> folder, duplicate the <strong class="source-inline">SlidingTile_3by3</strong> Prefab and rename <span>it </span><span><strong class="source-inline">SlidingTile_3by3_URP</strong></span><span>.</span></li>
<li class="calibre15">Double-click on <strong class="source-inline">SlidingTile_3by3_URP</strong> to enter <strong class="bold">Prefab </strong><span><strong class="bold">Edit Mode</strong></span><span>.</span></li>
<li class="calibre15">Find the <strong class="source-inline">ST_Puzzle Display</strong> component and change the <em class="italic">Puzzle Shader</em> from <strong class="source-inline">Mobile/Unlit</strong> to <strong class="source-inline">Packages/Universal RP/Shaders/2D/Sprite-Unlit-Default</strong> – you must drag this shader in from the <strong class="bold">Project</strong> window after <span>expanding </span><span><strong class="source-inline">Packages</strong></span><span>.</span></li>
<li class="calibre15">Save <span>the Prefab.</span></li>
</ol>
<p class="calibre3">We have one more update to make for the renderer issues, and that’s on the puzzle tile itself, but first, we need <a id="_idIndexMarker964" class="pcalibre1 pcalibre calibre6"/>a new <strong class="bold">Universal RP Sprite</strong> material. Follow these steps to update <span>the asset:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new <em class="italic">material</em> named <strong class="source-inline">PuzzleTile 1</strong> in the <strong class="source-inline">Assets/Materials</strong> folder and <span>select it.</span></li>
<li class="calibre15">In the <strong class="bold">Shader</strong> drop-down menu at the top of the <strong class="bold">Inspector</strong> view, select the <strong class="bold">Universal Render </strong><span><strong class="bold">Pipeline/2D/Sprite-Unlit-Default</strong></span><span> shader.</span></li>
<li class="calibre15">In the <strong class="source-inline">Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Prefabs</strong> folder, we also have the <strong class="source-inline">SlideTile</strong> Prefab. Duplicate it and rename <span>it </span><span><strong class="source-inline">SlideTile_URP</strong></span><span>.</span></li>
<li class="calibre15">Double-click<a id="_idIndexMarker965" class="pcalibre1 pcalibre calibre6"/> on <strong class="source-inline">SlideTile_URP</strong> to enter <strong class="bold">Prefab </strong><span><strong class="bold">Edit Mode</strong></span><span>.</span></li>
<li class="calibre15">Find the <strong class="source-inline">MeshRenderer</strong> component and change <strong class="bold">Material</strong> at <strong class="source-inline">Element 0</strong> to <span><strong class="source-inline">PuzzleTile 1</strong></span><span>.</span></li>
<li class="calibre15">Save <span>the Prefab.</span></li>
</ol>
<p class="calibre3">Now that the rendering issues of the <strong class="source-inline">Sliding Tile Puzzle</strong> asset have been updated, we are ready to work within our <strong class="bold">Lit 2D (</strong><span><strong class="bold">URP)</strong></span><span> scenes!</span></p>
<p class="calibre3">We only have one more issue with updating, and that’s for the interactivity – that is, being able to slide the tiles from <span>player input.</span></p>
<h3 class="calibre10">Updating the input system</h3>
<p class="calibre3">The new input system<a id="_idIndexMarker966" class="pcalibre1 pcalibre calibre6"/> is called new because… well, it’s new. Unity 5 only had the legacy <strong class="source-inline">InputManager</strong> system; of course, since we’re using the new input system in our project, we need to make some changes to support it. All the updates for the renderer were done in the editor, but now, we’ll have to change <span>some code.</span></p>
<p class="calibre3">Make the following <span>code changes:</span></p>
<ol class="calibre14">
<li class="calibre15">Find the <strong class="source-inline">ST_PuzzleTile</strong> script in the <strong class="source-inline">Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts</strong> folder and open it in <span>your IDE.</span></li>
<li class="calibre15">Add a new <strong class="source-inline">using</strong> statement at the top of the script. We’ll need this <strong class="source-inline">UnityEngine</strong> namespace to support the <span>code changes:</span><pre class="source-code">
using UnityEngine.EventSystems;</pre></li> <li class="calibre15">Add the <strong class="source-inline">IPointerClickHandler</strong> interface to the class definition to support the new input system’s <strong class="source-inline">pointer </strong><span><strong class="source-inline">click</strong></span><span> method:</span><pre class="source-code">
public class ST_PuzzleTile : MonoBehaviour, IPointerClickHandler</pre></li> <li class="calibre15">At the bottom of the script, replace <strong class="source-inline">void OnMouseDown()</strong> with <span>the following:</span><pre class="source-code">
public void OnPointerClick(PointerEventData eventData)</pre></li> <li class="calibre15">Save the script and return to the Unity Editor; <span>you’re done.</span></li>
</ol>
<p class="calibre3">Unfortunately, you can<a id="_idIndexMarker967" class="pcalibre1 pcalibre calibre6"/> no longer test the sliding puzzle using the vendor’s <strong class="source-inline">SlidingTilePuzzle</strong> example <span>scene as-is.</span></p>
<p class="calibre3">To test the updates and the final update requirements for every scene you want to use the sliding puzzle in, follow <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">Create a new scene (<strong class="bold">File</strong> | <strong class="bold">New Scene</strong> or <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">N</em>) and select the <strong class="bold">Lit 2D (URP)</strong> new <span>scene template.</span></li>
<li class="calibre15">Add a <strong class="source-inline">PhysicsRaycaster</strong> component to <span><strong class="bold">Main Camera</strong></span><span>.</span></li>
<li class="calibre15">Add <strong class="source-inline">UI Event System</strong> to the scene. Ensure you update the <strong class="source-inline">StandaloneInputModule</strong> component for the new <span>input system.</span></li>
<li class="calibre15">Add the <strong class="source-inline">SlidingTile_3by3_URP</strong> Prefab to <span>the scene.</span></li>
<li class="calibre15">Enter <strong class="bold">Play Mode</strong>. <span>Test. Enjoy.</span></li>
</ol>
<p class="calibre3">And that completes all the updates required to modernize <em class="italic">Sliding Tile Puzzle</em> for the URP render and the new input system. Not <span>too bad.</span></p>
<p class="calibre3">As you will see, the Unity Asset Store is a great resource with many talented asset publishers. It can help to save you (a lot of) time building game prototypes quickly, polishing your games, and creating vertical slices early (for seeking a publisher or investors in <span>your project).</span></p>
<p class="calibre3">We will, however, need one additional change to integrate the sliding puzzle into our gameplay. And that is adding an event for when the security puzzle lock has been solved so that we can trigger <a id="_idIndexMarker968" class="pcalibre1 pcalibre calibre6"/>an appropriate action – a logical one at this point would be granting the player access to the habitat station. <span>Open sesame!</span></p>
<h3 class="calibre10">Adding an event for completion</h3>
<p class="calibre3">We won’t be<a id="_idIndexMarker969" class="pcalibre1 pcalibre calibre6"/> covering any new ground with this task. We’ve added events in several different ways already. Our choice this time will be a <strong class="source-inline">UnityEvent</strong> event so that we can set the triggered handlers in the <span><strong class="bold">Inspector</strong></span><span> view.</span></p>
<p class="calibre3">Find the <strong class="source-inline">ST_PuzzleDisplay</strong> script in the <strong class="source-inline">Assets/Third Party/HyperLuminal/SlidingTilePuzzle/Scripts</strong> folder and open it in your IDE. Then, modify the script with the <span>following additions:</span></p>
<ol class="calibre14">
<li class="calibre15">Add a new <strong class="source-inline">using</strong> statement at the top of the script as required for declaring <span>our event:</span><pre class="source-code">
using UnityEngine.Events;</pre></li> <li class="calibre15">Add a <strong class="source-inline">public</strong> <strong class="source-inline">UnityEvent</strong> event to be triggered when the puzzle <span>is completed:</span><pre class="source-code">
public class ST_PuzzleDisplay : MonoBehaviour
{
    …
    public UnityEvent OnPuzzleComplete;</pre></li> <li class="calibre15">Modify the <strong class="source-inline">CheckForComplete()</strong> method by adding the <strong class="source-inline">OnPuzzleComplete</strong> invocation line within the <span><strong class="source-inline">if(Complete)</strong></span><span> block:</span><pre class="source-code">
public IEnumerator CheckForComplete()
{
    …
    // if we are still complete then all the tiles are correct.
    if(Complete)
    {
        Debug.Log("Puzzle Complete!");
        OnPuzzleComplete?.Invoke();
    }
    …</pre></li> </ol>
<p class="calibre3">We now have a convenient way to respond to the entryway security puzzle lock <span>being solved/completed.</span></p>
<p class="calibre3">When we set up the <strong class="source-inline">QuestHasCompleted</strong> component on the habitat entryway, we left unfinished<a id="_idIndexMarker970" class="pcalibre1 pcalibre calibre6"/> business for our future selves. We are now our future selves, so we can complete the <strong class="source-inline">OnQuestComplete</strong> event assignment and show our security puzzle lock to <span>the player.</span></p>
<h3 class="calibre10">Setting up a new puzzle prefab</h3>
<p class="calibre3">Yup, that’s right – we’ll need <a id="_idIndexMarker971" class="pcalibre1 pcalibre calibre6"/>another Prefab for the sliding puzzle lock. We’ll set that up now so that it’s shown to the player – with our image – when all three keys have been collected and they reach the <span>habitat entryway.</span></p>
<p class="calibre3">Follow these steps to create the <span>new Prefab:</span></p>
<ol class="calibre14">
<li class="calibre15">Drag the <strong class="source-inline">SlidingTile_3by3_URP</strong> Prefab into the <strong class="bold">Hierarchy</strong> (ensure its position is at (<strong class="source-inline">0, </strong><span><strong class="source-inline">0, 0</strong></span><span>)).</span></li>
<li class="calibre15">Right-click on it and select <strong class="bold">Create Empty Parent</strong>, then rename the parent object to <strong class="source-inline">Key Puzzle Lock</strong> – you’ll end up with the actual puzzle as the child (yes, this is our standard approach to Prefab structure, if you still <span>weren’t sure).</span></li>
<li class="calibre15">Find the <strong class="source-inline">key_puzzle1-complete_512</strong> image in the <strong class="source-inline">Assets/Sprites/Puzzle</strong> folder (this is one of the images we imported in the previous <em class="italic">KeyItem component</em> section) and change its import settings in the <strong class="bold">Inspector</strong> view to <span>the following:</span><ol class="calibre42"><li class="upper-roman"><strong class="bold">Texture </strong><span><strong class="bold">Type</strong></span><span>: </span><span><strong class="bold">Default</strong></span></li><li class="upper-roman"><strong class="bold">Texture </strong><span><strong class="bold">Shape</strong></span><span>: </span><span><strong class="bold">2D</strong></span></li><li class="upper-roman"><strong class="bold">Advanced</strong>: Don’t enable <span>any options</span></li><li class="upper-roman"><strong class="bold">Wrap </strong><span><strong class="bold">Mode</strong></span><span>: </span><span><strong class="bold">Clamp</strong></span></li><li class="upper-roman"><strong class="bold">Filter </strong><span><strong class="bold">Mode</strong></span><span>: </span><span><strong class="bold">Bilinear</strong></span></li><li class="upper-roman"><strong class="bold">Max </strong><span><strong class="bold">Size</strong></span><span>: </span><span><strong class="source-inline">512</strong></span></li></ol></li>
<li class="calibre15">Find the <strong class="source-inline">ST_PuzzleDisplay</strong> component <a id="_idIndexMarker972" class="pcalibre1 pcalibre calibre6"/>and assign <span>the following:</span><ol class="calibre42"><li class="upper-roman"><em class="italic">Puzzle </em><span><em class="italic">Image</em></span><span>: </span><span><strong class="source-inline">key_puzzle1-complete_512</strong></span></li><li class="upper-roman"><em class="italic">Puzzle Scale</em>: <strong class="source-inline">0.7</strong>, <span><strong class="source-inline">0.7</strong></span><span>, </span><span><strong class="source-inline">0.7</strong></span><span>:</span></li></ol></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer136">
<img alt="Figure 9.16 – Sliding puzzle configuration" src="image/B18347_09_16.jpg" class="calibre109"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Sliding puzzle configuration</p>
<ol class="calibre14">
<li value="5" class="calibre15">Now, disable the <strong class="source-inline">SlidingTile_3by3_URP</strong> object. Yes, you heard that right; we’re going to disable the object with the <strong class="source-inline">ST_PuzzleDisplay</strong> component on it because we only want the puzzle to show and do its trick when it’s triggered by the player reaching the habitat entryway with all three <span>keys collected.</span></li>
<li class="calibre15">Drag the <strong class="bold">Key Puzzle Lock</strong> object from the <strong class="bold">Hierarchy</strong> to the <strong class="source-inline">Assets/Prefabs</strong> folder to create the puzzle <span>lock Prefab.</span></li>
</ol>
<p class="calibre3">We now have our <a id="_idIndexMarker973" class="pcalibre1 pcalibre calibre6"/>customized security puzzle lock ready to go! The final setup ensures it shows in place when required at the habitat <span>entryway location.</span></p>
<h3 class="calibre10">Adding the puzzle lock to the entryway</h3>
<p class="calibre3">We already set<a id="_idIndexMarker974" class="pcalibre1 pcalibre calibre6"/> up our <strong class="bold">Puzzle Trigger</strong> at the location of the habitat entryway. Now, let’s add the security puzzle lock to its location so that it shows and is interactable in place at the entryway door. With everything already set up and ready to go, it’s a simple <span>two-step process:</span></p>
<ol class="calibre14">
<li class="calibre15">Position the <strong class="bold">Key Puzzle Lock</strong> Prefab in the level nearby, slightly above, or right at the habitat entryway door. You can reference <span><em class="italic">Figure 9</em></span><em class="italic">.12</em> for where I placed it: at the door and just above the player <span>character’s head.</span></li>
<li class="calibre15">Show the sliding puzzle from the <strong class="bold">Puzzle Trigger</strong> object’s <strong class="source-inline">QuestHasCompleted</strong> component’s <strong class="source-inline">OnQuestComplete()</strong> event by doing <span>the following:</span><ol class="calibre42"><li class="upper-roman">Add a new entry for <strong class="source-inline">OnQuestComplete()</strong> as an additional action to <strong class="source-inline">PlayerInput.enabled</strong> by clicking the little plus (<strong class="bold">+</strong>) <span>button.</span></li><li class="upper-roman">Assign the <strong class="source-inline">SlidingTile_3by3_URP</strong> child object of <strong class="bold">Key Puzzle Lock</strong>. Then, select <strong class="source-inline">GameObject</strong> | <strong class="source-inline">SetActive(bool)</strong> from the function dropdown, and tick the checkbox to <span>pass </span><span><strong class="source-inline">true</strong></span><span>.</span></li></ol></li>
</ol>
<p class="calibre3">That’s it! You can now fully test the quest life cycle, collect three keys scattered throughout the level to complete the quest, trigger an event for a completed quest, and solve an in-game<a id="_idIndexMarker975" class="pcalibre1 pcalibre calibre6"/> sliding <span>puzzle. Yay!</span></p>
<p class="calibre3">All that remains is what we need to do when beating the entryway puzzle lock – that <span>is, winning.</span></p>
<h2 id="_idParaDest-174" class="calibre8"><a id="_idTextAnchor183" class="pcalibre1 pcalibre calibre6"/>Winning</h2>
<p class="calibre3">When the security puzzle lock <a id="_idIndexMarker976" class="pcalibre1 pcalibre calibre6"/>is solved, we gain entry to the habitat station. The <strong class="source-inline">OnPuzzleComplete()</strong> <strong class="source-inline">UnityEvent</strong> event we just added to the <strong class="source-inline">Sliding Tile Puzzle Game</strong> code gets triggered, so this is our opportunity to do something for a <span>win state.</span></p>
<p class="calibre3">My game design plan, and plan for this book’s projects, is to continue gameplay within the habitat station interior in <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><span><em class="italic">Chapter 10</em></span></a>, where things will start having more depth. I don’t mean that figuratively; the project the next chapter introduces will be a 3D <strong class="bold">first-person shooter</strong> (<strong class="bold">FPS</strong>) game. For <a id="_idIndexMarker977" class="pcalibre1 pcalibre calibre6"/>now, we’ll implement a nice cinematic fade to black and <em class="italic">To be continued…</em>. But how do we solve the problem of implementing a fade-out and on-screen text sequence without figuring out a bunch of synchronized linear timing code? <span>Let’s see.</span></p>
<h2 id="_idParaDest-175" class="calibre8"><a id="_idTextAnchor184" class="pcalibre1 pcalibre calibre6"/>Timeline</h2>
<p class="calibre3"><strong class="bold">Timeline</strong> is not <a id="_idIndexMarker978" class="pcalibre1 pcalibre calibre6"/>a new <a id="_idIndexMarker979" class="pcalibre1 pcalibre calibre6"/>feature in Unity 2022. It’s been around since Unity 2017, but I feel it’s an underrated core feature that doesn’t get nearly the attention it deserves for game developers. For cinematic content creators, however, it was a game changer since Timeline allows the easy creation of linear sequences affecting almost any object in <span>the scene.</span></p>
<p class="calibre3">Timeline is based on two elements that<a id="_idIndexMarker980" class="pcalibre1 pcalibre calibre6"/> work in tandem: a <strong class="bold">Timeline</strong> file-based asset and a <strong class="bold">Playable Director</strong> component. An important thing to note is that a Timeline instance <span>is scene-based.</span></p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><span>Timeline: </span><a href="https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml" class="pcalibre1 pcalibre calibre6"><span>https://docs.unity3d.com/Packages/com.unity.timeline@1.8/manual/index.xhtml</span></a><span>.</span></p>
<p class="calibre3">We will leverage the pure power of Timeline’s simplicity to affect a set of objects linearly to knock out this ending fade-out. Let’s start by creating our <span>Timeline instance:</span></p>
<ol class="calibre14">
<li class="calibre15">First, create a location in our project to store Timeline assets. Create a new folder <span>called </span><span><strong class="source-inline">Assets/Timelines</strong></span><span>.</span></li>
<li class="calibre15">Staying within the <strong class="bold">Project</strong> window, in the folder we just created, create a new Timeline named <strong class="source-inline">Ending Timeline</strong> by right-clicking and choosing <strong class="bold">Create</strong> | <span><strong class="bold">Timeline</strong></span><span>.</span></li>
<li class="calibre15">We can now open the <strong class="bold">Timeline</strong> window by double-clicking the <strong class="bold">Ending Timeline</strong> asset in the <span><strong class="bold">Project</strong></span><span> window.</span></li>
<li class="calibre15">If you’re not used to working in a timescale of <strong class="bold">Frames</strong>, use the gear icon in the top-right corner of the <strong class="bold">Timeline</strong> window to select <strong class="bold">Seconds</strong> (as seen in <span><em class="italic">Figure 9</em></span><span><em class="italic">.17</em></span><span>).</span></li>
<li class="calibre15">Finish the Timeline creation by dragging the <strong class="bold">Ending Timeline</strong> asset into the <strong class="bold">Scene Hierarchy</strong> to make the <span>scene-based instance.</span></li>
</ol>
<p class="calibre3">We’ll use just two UI widgets to achieve the fade-out effect and title while following <span>these steps:</span></p>
<ol class="calibre14">
<li class="calibre15">In the <strong class="bold">Scene Hierarchy</strong>, select <strong class="bold">Create</strong> | <strong class="bold">UI</strong> | <strong class="bold">Panel</strong>. This will add a <strong class="source-inline">Canvas</strong> component to the root of the <strong class="bold">Hierarchy</strong>, and <strong class="bold">Panel</strong> will be parented <span>to it.</span><p class="calibre3">Just what we need! <strong class="bold">Panel</strong> will scale an <strong class="source-inline">Image</strong> component to fill the screen. We don’t need an image per se; just the default <strong class="bold">Background</strong> sprite will <span>do nicely.</span></p></li>
<li class="calibre15">Right-click <strong class="bold">Panel</strong> and select <strong class="bold">UI</strong> | <strong class="bold">Text – TextMeshPro</strong> (select <strong class="bold">Import TMP Essentials</strong> if prompted) to add a text widget parented to it, and set <span>these values:</span><ul class="calibre22"><li class="calibre15"><strong class="source-inline">RectTransform</strong>: <strong class="bold">Width</strong> = <span><strong class="source-inline">400</strong></span></li><li class="calibre15"><strong class="source-inline">TextMeshPro – Text (UI)</strong>: <strong class="bold">Text Input</strong> = <strong class="source-inline">To </strong><span><strong class="source-inline">be continued…</strong></span></li></ul></li>
</ol>
<p class="calibre3">Lastly, we’ll bring these UI widgets into Timeline to set up the sequence. Follow these steps to add the<a id="_idIndexMarker981" class="pcalibre1 pcalibre calibre6"/> widgets and define their <span>respective sequence:</span></p>
<ol class="calibre14">
<li class="calibre15">Ensure that <strong class="bold">Ending Timeline</strong> is viewable in the <strong class="bold">Timeline</strong> window. If the <strong class="bold">Timeline</strong> window is not open, you can open it from <strong class="bold">Window</strong> | <strong class="bold">Sequencing</strong> | <strong class="bold">Timeline</strong>, then click on the <strong class="bold">Endling Timeline</strong> instance in <span>the hierarchy.</span></li>
<li class="calibre15">Drag <strong class="bold">Panel</strong> into the <strong class="bold">Timeline</strong> window’s <strong class="bold">Track List</strong> section (the left-hand side column, as seen in <span><em class="italic">Figure 9</em></span><em class="italic">.17</em>). When prompted, click <strong class="bold">Add </strong><span><strong class="bold">Animation Track</strong></span><span>.</span><p class="calibre3">Record keys for the <strong class="bold">Panel</strong> <strong class="source-inline">Image</strong> <strong class="bold">Color</strong> field to animate the value from <strong class="source-inline">0</strong> (transparent) to <strong class="source-inline">255</strong> (opaque) over <span>1.5 seconds:</span></p><ol class="calibre42"><li class="upper-roman">Click the red <em class="italic">Start recording</em> circle button on the <strong class="bold">Panel (Animator)</strong> track, then set <strong class="bold">Image Color</strong> to black (RGB Hexadecimal = <strong class="source-inline">000000</strong>) with <strong class="bold">Color alpha (A)</strong> set to <strong class="source-inline">0</strong> to set the <span>first keyframe.</span></li><li class="upper-roman">Scrub <strong class="bold">Timeline Playhead</strong> to 1.5 seconds, then set <strong class="bold">Color alpha (A) </strong>to <strong class="source-inline">255</strong> to set the <span>second keyframe.</span></li><li class="upper-roman"><span>Stop recording.</span></li></ol></li>
<li class="calibre15">Drag <strong class="bold">Text (TMP)</strong> into the <strong class="bold">Track List</strong> section of the <strong class="bold">Timeline</strong> window and select <strong class="bold">Add Activation Track</strong> <span>when prompted.</span><p class="calibre3">We want the text to show a heartbeat after the fade has completed, so drag the <strong class="bold">Active</strong> clip to the right in the timeline to 1.8 seconds. The GameObject for the <strong class="bold">Text (TMP)</strong> binding will only be active within the range of the clip in the timeline and deactivated outside of it. We’re done with the <span>text. Easy-peasy.</span></p></li>
</ol>
<p class="calibre3">To preview the results <a id="_idIndexMarker982" class="pcalibre1 pcalibre calibre6"/>of the timeline sequence in the <strong class="bold">Game</strong> view, click the <strong class="bold">Play</strong> button or press <span>the spacebar:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer137">
<img alt="Figure 9.17 – Timeline ending fade out title" src="image/B18347_09_17.jpg" class="calibre110"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.17 – Timeline ending fade out title</p>
<p class="calibre3">If you enter <strong class="bold">Play Mode</strong> now, you’ll see that our ending fade-out and title will already be shown, and the title will then disappear after a few seconds. We can fix this behavior by changing the settings on the <strong class="bold">Ending Timeline</strong> instance – a <strong class="source-inline">PlayableDirector</strong> component was added to the Timeline instance when we dragged it into <span>the scene.</span></p>
<p class="calibre3">Select the <strong class="bold">Ending Timeline</strong> object in the scene and change the <strong class="source-inline">PlayableDirector</strong> component values in the <span><strong class="bold">Inspector</strong></span><span> view:</span></p>
<ul class="calibre17">
<li class="calibre15"><strong class="source-inline">PlayOnAwake</strong> = <span><strong class="source-inline">false</strong></span></li>
<li class="calibre15"><strong class="source-inline">WrapMode</strong> = <span><strong class="source-inline">Hold</strong></span></li>
</ul>
<p class="calibre3">We also want to ensure the UI widgets don’t have a visible state at design time in the editor. That way, they are not shown until we trigger the Timeline to play. Make the following changes to the UI widget values in <span>the scene:</span></p>
<ol class="calibre14">
<li class="calibre15">For the UI <strong class="bold">Panel</strong>, set the <strong class="source-inline">Image</strong> <strong class="bold">Color</strong> alpha channel value <span>to </span><span><strong class="source-inline">0</strong></span><span>.</span></li>
<li class="calibre15">For the UI <strong class="bold">Text (TMP)</strong> object, deactivate the object (untick the checkbox at the top of the <span><strong class="bold">Inspector</strong></span><span> view).</span></li>
</ol>
<p class="calibre3">Since we already recorded the color values and active state in the Timeline, we can safely set these values in the scene without affecting their <span>sequenced behavior.</span></p>
<p class="calibre3">The only thing left to do now is to activate our ending sequence when the sliding puzzle is complete. Find the <strong class="bold">Key Puzzle Lock</strong> | <strong class="source-inline">SlidingTile_3by3_URP</strong> object in the hierarchy and, on the <strong class="source-inline">ST_PuzzleDisplay</strong> component, add an action to <strong class="source-inline">OnPuzzleComplete: Runtime Only</strong>, <strong class="bold">Ending Timeline</strong> | <span><strong class="source-inline">PlayableDirector.Play()</strong></span><span>.</span></p>
<p class="calibre3">To be continued – or end of Act I, whichever you decide. Either way, this was just the equivalent of a tip-of-the-iceberg introduction to Timeline – it is an extremely powerful cutscenes, cinematics, and gameplay or audio <span>sequences tool!</span></p>
<p class="calibre3">In this section, you learned how to bring a third-party asset in from the Unity Asset Store, resolved to update the asset for use in Unity 2022, and extended the vendor-provided code with<a id="_idIndexMarker983" class="pcalibre1 pcalibre calibre6"/> our own to trigger an event. You also received an introduction to Unity’s Timeline feature and created a simple but effective cinematic fade <span>to black.</span></p>
<h1 id="_idParaDest-176" class="calibre5"><a id="_idTextAnchor185" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, you learned how to create an efficient and convenient global event system to build out a quest system with components made in a flexible, scalable, and more maintainable way than with directly coupled classes. You also learned how to create a specific quest with unique requirements needing to be met before setting the quest state as completed while also learning how to introduce randomness for collecting <span>required items.</span></p>
<p class="calibre3">We continued by learning how to import a third-party sliding puzzle asset from the Unity Asset Store and upgrade it for compatibility with Unity 2022 and the URP renderer while also extending upon the code to integrate it into our game code. We finished solving the security puzzle lock and winning the game with a cinematic Timeline sequence for fading <span>to black.</span></p>
<p class="calibre3">In the next chapter, we’ll create a 3D FPS to continue the 2D adventure game directly. We will pick up right where we left off and enter the interior habitat environment, where we will learn about gray boxing to flesh out a playable 3D-level design with <strong class="bold">ProBuilder</strong> rapidly. We’ll also leverage another asset from the Unity Asset Store – but this time one provided directly by Unity – for our FPS character controller. We’ll also look at code reuse by converting some of our existing 2D components for use <span>in 3D.</span></p>
</div>
</div></body></html>