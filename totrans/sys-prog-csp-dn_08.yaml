- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The One with the Network Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Building High-Performance* *Networking Applications*'
  prefs: []
  type: TYPE_NORMAL
- en: Software seldom lives in isolation. The same can be said, to a greater extent
    for system programs. Since these programs do not directly interact with the user,
    they rely on other software to give them input, read their output, and be told
    what to do. That “other software” often lives on the same machine, but just as
    often, that software runs elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have so far discussed how to transfer data to and from our applications
    and briefly looked at networking. This chapter focuses on that specific topic:
    networking. Be prepared to go deeply into the world of interconnected software!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals and the OSI layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the System.Net namespace (including the most used protocols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with System.Net.Sockets to have more control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous, non-blocking networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to improve networking performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking errors and time-out, and how to deal with those
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are about to break out of the box and connect to the outside world. Let’s
    go!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code samples for this chapter can be found at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already talked about the OSI model. But just as a quick refresher, the
    OSI model defines the layers that make up the system, allowing us to communicate
    with other systems. The layers span from the lowest layer, which describes the
    voltages a network adapter should be able to handle, up to the highest level,
    which describes the application that uses networking.
  prefs: []
  type: TYPE_NORMAL
- en: A walk down the OSI layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want to walk you through all the layers again, detailing what happens in each.
    To do this, I want to discuss a user using FTP to send data. **FTP**, which stands
    for **File Transfer Protocol**, is an older, hardly used technique to send data
    to remote machines or to get data from those remote machines.
  prefs: []
  type: TYPE_NORMAL
- en: FTP used to be the best way to achieve that, but the lack of security features
    made people move to other means. We will discuss some of those later, but we can
    still use FTP for our walk-down of the OSI model. It makes things a bit easier
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: An FTP client can be as simple as a console application. Actually, almost all
    FTP clients are just that. There are GUI-based clients, but they act as wrappers
    around the FTP commands.
  prefs: []
  type: TYPE_NORMAL
- en: To transfer a file, a user fires up the FTP client, specifies the server to
    connect to, and optionally passes in the credentials. Then, the user uses commands
    such as `GET` and `PUT` to transfer the file. Another command is `LS`, which is
    used to get the contents of a remote directory. We also have `MKDIR` to create
    a remote directory and other such commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us assume that the user is sitting at their machine and wants to log
    in to the remote computer. To do that, the user types `ftp username:password@127.0.0.1`
    at the command prompt. This does a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts up the command-line version of FTP
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it tells it to connect to a computer found at address 127.0.0.1 (which
    is, as you probably remember, localhost)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It supplies a username and a password that the server needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a few seconds, the client lists all files in the requested location. But
    what happens in the computer when the user presses the *Enter* key?
  prefs: []
  type: TYPE_NORMAL
- en: After starting the application, the FTP client takes over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands and data flow through the OSI levels. Let me show you what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer 7**: The application runs on OSI level 7, the application level. The
    FTP protocol in the application then sets up the connection. FTP creates two connections:
    one for control commands and one for data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` command is translated from whatever string format it was into an 8-bit
    ASCII format. If encryption is needed, that is also taken care of here. After
    all, layer 6 is all about how to present the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 5**: The session layer then takes over. This layer is where the actual
    connection to the remote machine is made. This layer keeps an eye on the connection
    to make sure it is reliable and stable. It also closes the connection when it
    is no longer needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 4**: After that, the transport layer makes sure the data containing
    the command is broken into smaller packets and sends them out in the correct order.
    FTP uses TCP, meaning layer 4 is responsible for rearranging data packets that
    are out of order when data is received. Error checking is also something that
    happens here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3**: The network layer is where the **Internet Protocol** (**IP**)
    lives. This protocol in layer 3 is responsible for finding the best route to the
    remote machine. It also handles packet forwarding and rerouting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 2**: Then, we get to the data link layer. This layer adds data to the
    packets, such as the MAC address of the next machine the data needs to get to.
    It is responsible for node-to-node communication. If you use Wi-Fi, this layer
    prepares the data to be sent over the radio waves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 1**: Finally, we reach the physical layer. This last layer is where
    the data is actually transmitted. This layer translates the data into radio signals
    if you use Wi-Fi. It deals with all the hardware issues, such as the frequencies
    used and the strength of the signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, most of this is done at the OS or BIOS level. We do not have to worry
    about frequencies when setting up a network connection. We usually deal with **layers
    7** and **6**, and sometimes **5**. We write the application (**layer 7**). We
    define the presentation (**layer 6**) if we have our own protocol. And we might
    sometimes have to worry about the actual connections, so we deal with **layer**
    **5** occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The BCL and the CLR have many classes, tools, and helpers, allowing us to focus
    on the fun without worrying about the details. But sometimes, as system programmers,
    we must worry about those details. These details can be the difference between
    a great, fast, and stable system and a mediocre one. But do not worry: we cover
    it all here in this chapter!'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do that, let us look at commonly used ways to transmit data over
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the System.Net namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chances are, if you need a way to transmit data, someone else has already figured
    out the best way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you could write all the code to transfer a file to and from a
    machine or use FTP and rely on existing software.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are many ways to transfer data. Many of those ways are so standardized
    that they are part of the BCL. You can use them without dealing with third-party
    NuGet packages. Let us discuss some of the offerings in the System.Net namespace
    and see what we can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP/HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP was the protocol that enabled millions of users to finally use the internet.
    Before HTTP, the only way to exchange data was through technically complicated
    protocols, most of which had to be controlled through the command line. When Sir
    Tim Berners-Lee published his ideas about the World Wide Web and the accompanying
    **Hypertext Transfer Protocol** (**HTTP**), people with little or no technical
    background could also use the net. Web browsers made it easy to go around and
    find information. Of course, when I say easy, I mean easier than before. In the
    early 1990s, we had no Google or Bing, so finding interesting sites was a struggle
    compared to today.
  prefs: []
  type: TYPE_NORMAL
- en: '*HTTP democratized the internet*. Before that, it was the realm of scientists
    and the military, with a few nerds sprinkled in for good measure. Yes, I was one
    of those nerds: I first used the internet through SMTP, Gopher, FTP, and Usenet
    in 1987\. HTTP and the WWW made it all so much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming for it was not that easy. However, with the current frameworks,
    getting data from an arbitrary site anywhere on the globe only takes a couple
    of lines of code. Let me show you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, we create an instance of the `HttpClient` class. This class
    is a helpful little helper: it takes away much of the complexity of the older
    `HttpWebRequest`. Although `HttpWebRequest` does offer some advantages over `HttpClient`
    (for instance, more control over the headers, the option to set time-outs, and
    the ability to use synchronous data transfers if needed), `HttpClient` is by far
    the better choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with dummy servers
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play around with HTTP and HTTPS, you need a reliable and easy-to-use
    website to connect to. The [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    URL is a great site to use in those cases. It gives you several endpoints to connect
    to, read from, and send data to. It is simple to use, and it is free. Please have
    a look at that site to see what it offers.
  prefs: []
  type: TYPE_NORMAL
- en: After declaring the URL, we call the `GetAsync` method with that URL. This asynchronous
    operation returns an instance of the `HttpResponseMessage` class. That class contains
    all we need to read the data from the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: The next call is just a shorthand for some straightforward error checking. Calling
    `EnsureSuccessStatusCode` does very little besides looking at the return code
    from the server, and it throws an error if it is not in the 200 range. As you
    probably know, HTTP requests return a numeric status code that tells you what
    the result of the call is. Everything between 200 and 299 means your call worked.
    Codes such as 404 mean the site is unreachable, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This single method makes your code much more readable than `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: If all is okay, we continue by reading the actual data. The response has several
    properties, one of which is `Content`. Other properties are the status code, the
    headers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`Content`, of type `HttpContent`, is a wrapper around `Stream` that allows
    us to read data from the server. In our case, we call `ReadAsStringAsync`, which
    takes all data the server can give us and returns that to us as a string. Of course,
    this all happens asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we display that string on the console.
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest example of using HTTP I can think of. All classes shown
    here have many more use cases, methods, and helpers that can benefit you. I suggest
    you look at the documentation of `HttpClient`, `HttpResponseMessage`, `HttpContent`,
    and the rest to see what else you can do with them. In the meantime, let’s look
    at some other protocols.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw FTP before. I used it to illustrate the flow of actions through the OSI
    model. But we never thoroughly explored what we can do with it.
  prefs: []
  type: TYPE_NORMAL
- en: FTP is an older technology. It is not in use that much anymore, but it is still
    beneficial. It is a quick, easy-to-understand technology to transfer files between
    machines and control remote file systems, regardless of the underlying operating
    system. It is fast and reliable. Most operating systems support FTP both as a
    client and as a server.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, you can enable the FTP server by going to the **Program and Features**
    section of the settings in the control panel, and there, under **Internet Information
    Services**, you can see the option to install the FTP server. Alternatively, you
    can click *Win* + *R* and then enter the optional features. See *Figure 8**.1*
    to see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Installing FTP Server on Windows](img/B20924_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Installing FTP Server on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: However, make sure you know what you are doing. One of the reasons we do not
    use FTP that much anymore is that it is not secure by default. To transfer files,
    it would be better to use something such as SFTP, which is a secure version.
  prefs: []
  type: TYPE_NORMAL
- en: But good old FTP is still your friend if you want to communicate in a secure
    environment (such as in a Kubernetes cluster) and transfer files quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you read the contents of a remote directory? Simple: use this piece
    of code!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code here is pretty straightforward. We create an instance
    of `WebRequest` and cast it to a subclass: `FtpWebRequest`. We specify what we
    want to do by setting the method to `ListDirectoryDetails`. We add some credentials
    if needed and get a stream containing the data we need. Of course, we handle exceptions
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Great! But wait… this is actually not so great.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do this in your editor, you will see warnings: `WebRequest` (and thus
    `FtpWebRequest`) has been marked obsolete. They have been superseded by the much
    better `HttpClient`. Unfortunately, that one cannot be used with FTP sites: it
    is only meant for HTTP traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: I believe Microsoft made a mistake here. But it is their framework, so they
    can do what they want. The good news is that plenty of NuGet packages can do what
    we want them to do. One is *FluentFtp*, which you can find at the [https://github.com/robinrodricks/FluentFTP](https://github.com/robinrodricks/FluentFTP)
    URL. Here, I would like to mention that I am not affiliated with this or any other
    NuGet package I mention in this book; these are just the packages I use. Of course,
    many different options are available, so just pick whatever works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Email protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTTP is the most used protocol on the public-facing internet, both in the number
    of servers handling it and in the percentage of data dealt with. But second to
    that is SMTP. **SMTP**, which stands for **Simple Mail Transfer Protocol**, is
    used for email. SMTP is just one of the protocols related to emails. Let’s look
    into each one of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SMTP**: The Simple Mail Transfer Protocol is used to send mail over the Internet.
    It is connection-oriented, meaning its primary task is to ensure a connection
    between the client sending the mail and the server processing it. It is reliable
    (meaning it can be recovered if data is lost in transit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POP3**: POP3 is the third iteration of the **Post Operation Protocol**. This
    protocol deals with the other side: SMTP ensures the mail gets delivered to the
    server, and POP3 allows the users to read their mail from the server. POP3 allows
    for offline access to email, but it can only access one mailbox at a time. If
    you want to read multiple mailboxes (or accounts, if you will), you need to set
    up more than one POP3 connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IMAP**: IMAP stands for **Internet Message Access Protocol**. This protocol
    is also meant to read mail from the server. But this protocol can read multiple
    mailboxes in one go. IMAP can access, search, manipulate, and delete your emails
    without downloading them. It can send these commands to the server in an RPC way
    (we discussed RPC extensively in [*Chapter 7*](B20924_08.xhtml#_idTextAnchor159)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MIME**: Despite not having a P at the end of the acronym, **MIME** is also
    a protocol. It is the acronym for **Multipurpose Internet Mail Extension** protocol.
    As the name suggests, it is an extension, allowing us to have attachments, multimedia,
    and non-ASCII characters in our mail messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these protocols enable us to have a functional, complete mail experience.
  prefs: []
  type: TYPE_NORMAL
- en: Sending an email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That being said, most software sends mail messages; it hardly ever reads them.
    So, let’s look at a simple sample of how to send an email in code. The sample
    code I provide consists of three parts. Let’s look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we need a message. Otherwise, why would we connect to an SMTP server?
  prefs: []
  type: TYPE_NORMAL
- en: The message is of type `MailMessage`. It needs a sender, and it can have multiple
    recipients. Those recipients can be in the `To`, `CC`, or `BCC` fields. `To`,
    `CC`, and `BCC` are all lists, so you can add multiple recipients. Of course,
    you need to supply at least the `To` recipients.
  prefs: []
  type: TYPE_NORMAL
- en: We can supply a `Subject` field. I would really encourage you to do that, of
    course. Then we have a `Body`, which contains the message we want to send.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the message, we can create an instance of the `SmtpClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: You need to have access to a real SMTP server, of course. Most internet service
    providers have them, so please look up how to connect to them in their documentation.
    You usually need a username and password to authenticate yourself. In the old
    days, there were anonymous servers, but in these days of spam, those are very
    hard to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to specify the server’s address and port (port `25` is the old port;
    port `587` is the new, secure one, and the preferred port to use), and you can
    specify whether you want to use SSL. That code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we can send the message!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have set up the client, you can send multiple messages using that same
    client instance. You do not have to worry about setting up connections. You can
    just call `Send`, and it all works.
  prefs: []
  type: TYPE_NORMAL
- en: Sending HTML messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous example works fine, but the message is kind of bland. These days,
    messages are much more colorful and pleasant to look at. The way to do that is
    to send an HTML message. You can do that by just putting HTML in the `Body` field
    and setting the `IsBodyHtml` property of `MailMessage` to true. But that is not
    the best way to do that for the following two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all clients support HTML. The readers must decipher the HTML to find the
    body text if their client does not support HTML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages only containing HTML are usually marked as spam.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to do this is to combine your beautifully crafted HTML body and
    a more down-to-earth plain text body. You can do that by using the `AlternateView`
    class. The code to create the mail message looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the regular `MailMessage` class. Most of the fields
    are the same. But we do not specify a body. Instead, we create two instances of
    the `AlternateView` class by calling the `CreateAlternateViewFromString` static
    method. That method takes the content we want to send (either HTML or plain text)
    and the encoding we use (we set it to `NULL`, so it uses the default setting for
    your machine). We do have to specify the content type. The first contains `"text/html"`
    and the second contains `"text/plain"`.
  prefs: []
  type: TYPE_NORMAL
- en: We then add both parts to the `MailMessage` instance, and we can send it.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: That covers some of the higher-level classes. It is now time to go deeper into
    the rabbit hole.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the System.Net.Sockets namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default protocols are fantastic. They take away a lot of manual work. We
    do not have to program the HTTP protocol ourselves; we can focus on the content
    instead. The same goes for SMTP, POP3, and all the other protocols out there.
    You can find a class or a NuGet package if the protocol you want to use is popular
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, sometimes you cannot find that package. Sometimes, you want to
    write your own protocol. In that case, you have to do all the hard work yourself.
    But, I have to be honest, I immensely enjoy doing that. There is something nice
    about writing my protocol, deploying it in my apps, and seeing them work together.
    And even if you do not enjoy this, there are cases where you have no choice.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that the good people who wrote the BCL have already done much
    of the underlying work.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B20924_07.xhtml#_idTextAnchor140), we encountered the `Socket`
    class when we discussed how systems can communicate. Sockets were mentioned as
    one of the options. We wrote a simple chat application that uses TCP/IP to communicate.
    TCP/IP is one of the ways sockets can connect.
  prefs: []
  type: TYPE_NORMAL
- en: In the chat sample I mentioned, we created instances of the `TcpListener` and
    `TcpClient` classes. These classes are wrappers around the more generic `Socket`
    class. They are specifically used for TCP/IP connections and handle much of the
    plumping needed to get this to work.
  prefs: []
  type: TYPE_NORMAL
- en: You can use sockets yourself, of course. That means you must do much of the
    work yourself, giving you more control over what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use sockets with TCP and UDP connections. We looked at the differences
    in [*Chapter 6*](B20924_07.xhtml#_idTextAnchor140), so we won’t compare them again
    here. However, you should use the `Socket` class if you want to use UDP: obviously,
    `TCPClient` will not work. By the way, there is also a `UdpClient` class, with
    which you can achieve the same result. However, I want you to be aware of the
    inner workings. That is why I am going with `Sockets` here.'
  prefs: []
  type: TYPE_NORMAL
- en: Steps to take when using sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with sockets, you need to take a number of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the right socket. You can use stream sockets. Stream sockets are based
    on the TCP protocol. It is a reliable, connection-oriented protocol. But you can
    also choose datagram sockets. These are based on the UDP protocol. They are connectionless,
    fire-and-forget ways of communicating. It is quick, but you have no guarantee
    the data will reach the intended recipient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you create the socket. You specify the kind of address you want to use
    (IPV4 or IPV6), the type of socket (stream or datagram), and the protocol (TCP
    or UDP).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s time to connect. You either listen to incoming connections or connect to
    a server somewhere. When you connect to a remote server, you must specify the
    IP address and the port. If you are listening, you need the port at least, and
    if you have more network connections, you might want to specify the IP address
    you are listening to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sending and receiving data. After all, that’s what we are here for, right?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you are done, you must be sure to close the connection. You do not want
    to hold on to a connection for too long: you might get in the way of other applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that is all there is to it. If I put it like this, it seems straightforward,
    doesn’t it? Well, the devil is in the details!
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to talk a bit about the IP address. The **IP** address, which stands
    for **Internet Protocol** address, is a unique number identifying a network device.
    It is unique within boundaries, but we will discuss that later. There are two
    kinds of addresses we can use: IPv4 and IPv6\. As you might have guessed, these
    acronyms are Internet Protocol version 4 and version 6, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The first publicly used version was IPv4\. IPv5 never saw the light of day,
    leaving us with two versions. It has always been the idea to replace IPv4 with
    IPv6 completely, but it seems IPv4 will stay around for a bit longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 address consists of 4 bytes, thus making it 32 bits long. This size
    means that there are about 4.3 billion unique addresses in theory. In practice,
    there are fewer since many ranges are reserved. We have already encountered one
    of them: the address is `127.0.0.1`. This is the address of the device itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although different systems can reserve different port ranges, there is a common
    understanding of what ranges we should avoid using or what ranges we can use.
    These ranges are explained like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Port 0 – 1023**: Well-known ports. These ports are used everywhere and you
    should not use them yourself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1433`, which is used by SQL Server. However, these are not as strictly assigned
    as the range `0` – `1023`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port 49152 – 65535**: This range is known as the dynamic or private range.
    They are usually used for ephemeral or short-lived communications. They are, most
    of the time, dynamically allocated by the operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just make sure the port you pick is not yet in use on your intended system!
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv6 address comprises 8 sets of 2-byte structures, making it 128 bits in
    length. You can fit substantially more addresses in that address space: there
    are about 340 undecillion unique addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Big numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with computers means you sometimes run into big numbers. This is such
    a case: an undecillion is 10 to the power of 36\. That means the number is 340,
    followed by 36 zeros. That’s a lot of addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv6 address is displayed as a sequence of 8 sets of 16-bit hexadecimal
    values. For instance, a valid address could look like this: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also an interesting address: `0000:0000:0000:0000:0000:0000:0000:0001`.
    This is the IPv6 version of 127.0.0.1\. In other words, this is localhost. However,
    it is pretty long: there are 7 sets of `0000`. With IPv6 we can omit a range of
    `0000` values with two colons. So we can shorten the address for localhost to
    ::1.'
  prefs: []
  type: TYPE_NORMAL
- en: Both in IPv4 and IPv6, we have reserved ranges. For instance, everything in
    the range `192.168.0.0` up to `192.168.255.255` is used for internal networks.
    You cannot, however, assign these addresses to devices facing the public network.
    The same goes for the addresses `10.0.0.0 to 10.255.255.255` and `172.16.0.0`
    `to 172.31.255.255`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up time with sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is time to look at how to do all this for real.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are servers out there that work as time servers. These servers have one
    purpose: wait for your connection and then respond with the current date and time.
    The way they do this is pretty interesting: they calculate the time it takes to
    send a response and adjust the time accordingly, thus making sure the answer is
    as accurate as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The method starts with a default value for the name of the server. We use [pool.ntp.org](http://pool.ntp.org)
    as our server, but there are many more out there that would do the trick. They
    all use the NTP protocol (**NTP** means **Network Time Protocol**, in case you
    were wondering). NTP is one of the oldest protocols. Systems used this protocol
    to synchronize the clocks of computers over a network as far back as the early
    80s!
  prefs: []
  type: TYPE_NORMAL
- en: 'The address we use, `pool.ntp.org`, is not a single computer but a pool of
    thousands of NTP servers, ensuring everybody can get their time. However, we can
    treat it as a single server. Oh, one word of warning: that URL is meant to be
    used by NTP clients. They use port `123`, as you can see in the code. If you use
    your browser to go to that address, you automatically use HTTP and thus port `80`
    (there is no HTTPS server at that address). This means you get to see whatever
    the maintainers of that pool want to put there. Do not use your browser to go
    to that URL; use port `123` as it is intended!'
  prefs: []
  type: TYPE_NORMAL
- en: 'A request to the NTP server needs a buffer of 48 bytes to hold the answer.
    We need to add some data in that buffer when we connect to the server, telling
    it what we want. In our case, we give it the value 0x23\. This byte consists of
    3 groups of bits, each group telling the server something about what we want.
    Look at the following table to see what these bits mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bits** | **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| 6– 7 | Leap Indicator | Indicates whether we want to take the leap seconds
    a month might have into account. 0 means no adjustment, 1 means the last minute
    of the month has 61 seconds, 2 means the last minute of the month has 59 seconds,
    and 3 means the clock is unsynchronized. |'
  prefs: []
  type: TYPE_TB
- en: '| 4-6 | Version | The version of the protocol we want to use. The latest version
    is 4. |'
  prefs: []
  type: TYPE_TB
- en: '| 0-3 | Mode | 0: Reserved1: Symmetric active2: Symmetric passive3: Client4:
    Server5: Broadcast6: NTP control message7: Reserved |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Settings for NTP servers'
  prefs: []
  type: TYPE_NORMAL
- en: We do not want to use leap adjustment. We are interested in using protocol version
    4\. And we are a client here. That means we have to do some bit-arithmetic. Working
    down from the most significant bits to the least significant bits, we get 00 for
    bits 6 and 7, 100 for bits 4, 5, and 6, and finally, 011 for bits 0 through 4\.
    If we combine this, we get 0010 0011, or 23 in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: We place that value in the first byte in the 48-byte long buffer we shall give
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: We have the name of the NTP server (`pool.ntp.org`), but we need the actual
    IP address of that machine. After all, sockets need an address and not a string
    of text. The `var addresses = Dns.GetHostEntry(ntpServer);`, I get 4 IP addresses
    back.
  prefs: []
  type: TYPE_NORMAL
- en: We take the first address we got back and construct an instance of an `IPEndPoint`
    class with that address and port `123`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can create an instance of the `Socket` class. We give it the `AddressFamily`
    `InterNetwork`, meaning we want to use IPv4 addresses. We also specify that we’ll
    use a datagram, and thus, we use UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing streams, datagrams, TCP, and UDP
  prefs: []
  type: TYPE_NORMAL
- en: You must specify what socket type and protocol type you want to use. However,
    if you use `SocketType.Stream`, you must also use `ProtocolType.TCP`. And if you
    want to use `SocketType.DGram`, you must also use `ProtocolType.UDP`. If you try
    to mix these (you want datagram over TCP, for instance), you get an exception
    during runtime. So, be careful what you choose.
  prefs: []
  type: TYPE_NORMAL
- en: We call `connect` on the socket, giving it the endpoint we created. After that,
    we send the server our 48-byte buffer containing information about `leap`, `version`,
    and `mode`. Next, we try to get an answer by calling `Receive`, using that same
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when we get the answer, we close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Once the answer is received and safely stored in our buffer, we can do some
    calculations to transform the data into something we can use in a `DateTime` structure.
    That specific piece of code we call contains conversions between different formats,
    swapping bits, and more. They have nothing to do with getting data from a server,
    so I leave it out. The sample on GitHub has that code, so please check that out
    if you want to see what that looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The code that deals with the socket was not that complicated. But there is a
    problem with this code. It is what we call **blocking code**. It blocks the entire
    thread for the duration of the call to the NTP server. Let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Async, non-blocking networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be evident by now that you must ensure that all non-instantaneous
    operations in your code are a potential performance issue. Slow operations can
    block a process from continuing. File I/O is one of the areas where this is appropriate.
    Networking is even slower than that. So, everything that we can do asynchronously
    should be implemented that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that most classes dealing with networking have asynchronous
    versions of their methods. The bad news is that for `Socket`, it is not as straightforward
    as you might have hoped. But do not worry: we will tackle this soon!'
  prefs: []
  type: TYPE_NORMAL
- en: Making asynchronous calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous sample, we used the static `Dns` class to get information about
    the address of the NTP server. We called `GetHostEntry()`, which is a synchronous
    blocking call. We can fix that quite easily: `Dns` has asynchronous versions of
    those methods. We can rewrite the call to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, the signature of the method needs to change as well. Instead of
    having this method declaration: `public DateTime GetNetworkTime(string ntpServer
    = "``pool.ntp.org")`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We change it into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public async Task<DateTime> GetNetworkTimeAsync(string ntpServer = "``pool.ntp.org")`'
  prefs: []
  type: TYPE_NORMAL
- en: We made it `async`, changed the return type to `Task<DateTime>` instead of `DateTime`,
    and renamed the method to have the `Async` postfix.
  prefs: []
  type: TYPE_NORMAL
- en: 'That was simple enough. We can do the same for the code working with `Socket`.
    This is the full method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This version takes advantage of the async/await pattern, so the calls to the
    server do not block the threads.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Networking code should always use asynchronous methods instead of synchronous
    ones. Networking is slow compared to the raw speed of the CPU and the local machine,
    so why waste time waiting on that slow trickle of data from the network adapter?
  prefs: []
  type: TYPE_NORMAL
- en: However, there are ways to improve the performance of your system when you use
    networking. Let’s look at those next.
  prefs: []
  type: TYPE_NORMAL
- en: Networking performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since networking is comparatively slow, we have to be smart about ways to improve
    the throughput of the data. We can control local networks, ensuring we have optic
    fiber and super-fast routers everywhere, but that does not solve the issues. Even
    the fastest physical network is way slower than data handled in the CPU. Of course,
    having fast hardware helps. But it only helps on our own network: we cannot control
    the hardware on other networks. We must be wise in our code to get the most out
    of our networking. Once again, it all comes down to us, the developers!'
  prefs: []
  type: TYPE_NORMAL
- en: Connection pooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A connection represents an open line between a client and a server. Let’s look
    at the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This single line of code is simple enough: this creates a connection to a server
    called `my.server.com` on port `123` and returns the open connection. Fine. We’ve
    seen that before. But let me show you what happens when you run that line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my.server.com` string into the correct IPv4 or IPv6 addresses we can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Socket` class is instantiated, allocating the memory for it and ensuring it
    is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN` is sent to the server. Basically, the client is asking, “Hey, can we
    talk?”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN` message comes in, it responds with `SYN-ACK`, acknowledging that it is
    ready to talk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SYN-ACK`, that apparently the network works fine, and that they can talk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all this has happened, the communication line is open and ready for use.
    We can start sending and receiving data.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a lot of work is involved in that simple line of code. You can
    imagine that the handshaking between the client and the server takes a lot of
    time. Network connections are expensive!
  prefs: []
  type: TYPE_NORMAL
- en: There is no getting around this. These steps need to be taken. But there is
    no reason to do them more than you need to. If you have a connection to a server,
    you might reuse it as well. We call that connection pooling. We create a pool
    of connections, and whenever something in our system needs to talk to the server,
    we return the already-created connection.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the BCL does not have a class for this. But it is not too hard
    to write one yourself. You could do it like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class called `TcpClientConnectionPool`. The signature looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three methods in that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look at what those methods do, we need to create two private fields
    in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a pool to hold objects, you need a place to store them. We
    use `ConcurrentBag<T>` here. `ConcurrentBag` is a thread-safe collection that
    has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread safe**: You can add, access, and remove objects without worrying about
    locks or other threads running amock. This class handles the details for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unordered**: There is no specific order. In our case, this is just fine.
    However, if you want to use something like FIFO, you should use a class with an
    order built in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplicates are allowed**: You can add the same object to the collection if
    you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: This class is optimized for scenarios where the same thread
    adds or removes items but performs pretty well in mixed scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `GetConnection()` method pulls an object from the pool if one is available.
    If one is not, it creates one for you. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, I throw an exception when the pool has reached the maximum
    allowed objects. You want to limit the number of `TcpClient` instances in your
    code: they take up quite a lot of memory and underlying handles, so having an
    unlimited amount of them lying around might not be the best idea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is room in the pool but no items are available, we create a new one
    and return it to the caller. The idea is that after using, the caller returns
    the object, and we store it in the collection, ready for another user to pick
    it up. We use lazy initialization here: we only create `TcpClient` when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can create all 10 instances in the constructor of this class.
    That makes the initialization of the class slower, and it uses more memory, but
    it is much faster during the object’s lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the connection user calls this method, it gets an active and open connection.
    When the user no longer needs `TcpClient`, it needs to be returned so it can be
    stored in the pool and ready for the following user. That method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do some checking when we get `TcpClient` back. For instance, I usually
    check to see whether it is still connected here. It is a bit like a library: when
    you return your items, they expect them to be pristine. We do the same here. If
    there is something wrong, we can fix it or not even add it back to the pool. I’ll
    leave that up to you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when the connection pool is disposed of, we do some cleaning up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We go through all the remaining instances of `TcpClient` in our collection,
    close them if needed, dispose of the underlying stream, and dispose of the instances
    themselves. This makes sure we leave no connection open. My mother taught me this
    at a very young age: always clean up after yourself!'
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize this part, this is how you would use this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I first create an instance of `connectionPool`. Obviously, you would not do
    that in each method call that needs a connection, but for this simple example,
    it is all right.
  prefs: []
  type: TYPE_NORMAL
- en: Then I try to get a connection by calling `GetConnection()`;
  prefs: []
  type: TYPE_NORMAL
- en: Then I get some bytes by taking the `Hello, World` string, postfixing that with
    `u8` to ensure it is UTF-8 and then converting it to a byte array.
  prefs: []
  type: TYPE_NORMAL
- en: I can use my pooled connection to send that string to the server. Finally, I
    can put the connection back in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: This sample is limited in functionality and lacks a lot of the code you would
    need before taking it into production. But I am sure it will help you get on your
    way.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing is caching our connections. But caching can help in a lot
    of other ways as well.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Caching stores data nearby so you can reuse it instead of going to the server
    each time. That sounds simple enough: it can be a huge performance booster. Getting
    an object from a memory location on your machine instead of going to a remote
    server each time sounds like a no-brainer, right? But there are some potential
    pitfalls you need to take into account. Here are the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stale data**: Data might change. For instance, our NTP sample changes every
    millisecond. That being said, you might retrieve it from the server once and then
    add the local time that’s elapsed since you got it. It will eventually run out
    of sync (NTP servers are much more precise than your local machine), but I am
    sure it will not be that big of an issue soon. But data will get stale. You have
    to take that into account if you store data locally. How often will data change?
    How important is it that I have the latest version?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory overhead**: Storing items locally on your machine takes up local memory.
    Storing large amounts of (large) objects takes up a lot of data, which might slow
    down your total application. It might even lead to out-of-memory exceptions. You
    must decide what you use frequently and what can be left on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity in cache invalidation**: If data gets stale, you have to renew
    it. That requires code to monitor the data and refresh it when needed. That code
    can get quite complicated. You might have a separate thread that monitors your
    local cache, or you might decide when something pulls that data from the cache.
    Either way, you have to write a lot of monitoring code. That might overly complicate
    your software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security concerns**: Data on your machine is not always safe. If you store
    sensitive data on the local machine, it might be susceptible to snooping, especially
    if you store that cached data on a storage medium. Be sure to handle sensitive
    data safely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Costs of cache misses**: When your application relies on getting data from
    the cache and only has it read from the remote server when you have a cache miss
    (thus, the item is not in the cache yet), you might have introduced a performance
    bottleneck. The logic of going through the cache, only to go out to the server
    if the data is not available, takes time. If the data you need is not needed that
    often, this is probably not the best case for caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inconsistent data**: Suppose your app uses data from the cache, but another
    system or part of your system uses data from the server. In that case, there might
    be discrepancies between the data. This is not only stale data, but it means that
    two systems use different data – data they expect to be the same. If that might
    be an issue, caching might be a bad idea.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching can speed up your application, but be aware of the risks involved. Before
    implementing this, you should consider the potential risks and benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Compression and serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If transferring data over the wire is slow, transmitting or requesting less
    data can help. So, compression and how you serialize data can help. In earlier
    chapters, we looked into compression and serialization, so I will not go into
    detail here. But please remember: if there is one place where it helps a lot when
    you use compression, this is the place. You can speed up network communications
    if you reduce the payload by compressing it first. And of course, choosing the
    correct serialization technique also helps.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we already looked at how to do compression, I will not show you it again
    here. You already know how to use the `GZipStream` class in the `System.IO.Compression`
    namespace (yes, that was a hint).
  prefs: []
  type: TYPE_NORMAL
- en: Keep-alive connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a `TcpClient` is not that expensive per se. Opening a connection to
    a server is expensive, however. It can help to keep connections open as long as
    you can. The `HTTPClient` class is very good at that: it is built so that you
    can leave the connection open for a long time without getting in your way. If
    you use sockets, you can do something similar. However, keeping a connection open
    when you do not need it anymore is not a good idea. If you do not need it, please
    close the connection. Otherwise, by all means, keep it open. Of course, if you
    keep a connection open, you also affect the other party. A client that clings
    to a connection also limits the server. You have to think about this a lot and
    make the right decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking errors and time-outs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When dealing with networks, there is one rule you have to keep in mind. That
    rule is: *assume that the other party is not answering* *your call*.'
  prefs: []
  type: TYPE_NORMAL
- en: Servers go down. Connections can drop. Networks are unreachable. There are a
    whole lot of issues that will (not might!) happen.
  prefs: []
  type: TYPE_NORMAL
- en: You must use defensive coding to ensure it doesn’t impact your code too much.
    Of course, if you rely on an external machine to get the data you need, and that
    machine is not available, you have a problem. But maybe you can get around it.
    Perhaps you can cache older data. Or, you can retry if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Let me help you with some strategies you can use to deal with hiccups in the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HTTPClient wisely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HTTPClient` class has some neat tricks to help you with making the use
    of it more stable. For instance, connection pooling comes free and out of the
    box in this handy class. And they built that connection pooling in a pretty clever
    way.
  prefs: []
  type: TYPE_NORMAL
- en: The general advice is to create one instance of `HTTPClient` and use that throughout
    your system. The class is smart enough to pool connections to a server. If you
    use the same `HTTPClient` to get data from another server, the class creates a
    new pool, so those connections also get pooled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, be careful what you do: do not generate connections to hundreds
    of servers if you do not need them. They still take up memory in your system.'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to make `HTTPClient` more resilient is to use a default configuration
    for your connections. I always ensure I set `DefaultRequestHeaders` so I know
    that I can handle the data coming in.
  prefs: []
  type: TYPE_NORMAL
- en: And I always make sure I have a `TimeOut` on my instance. That way, I know that
    the `HTTPClient` will not have to wait too long for data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest you use something such as a `Factory` to create your instances. I
    use one that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This static class creates an instance of `HTTPClient` for me if needed. It tells
    the handler that it needs to use `Cookies` and that I do not want a proxy on my
    connection. I also set `DefaultRequestHeaders` and asked it to accept `application/json`
    data. I also added a nice user agent so the server knows who it is talking to.
    Finally, I set the `timeout` to 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I need an `HTTPClient` instance, I can get it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first time I needed that client, it built it. But the second time and after
    that, it will pull it from the connection pool, making it a lot quicker and more
    resilient to mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: I also ensure I do not use the `GetStringAsync()` method or `GetStreamAsync()`
    directly from `HTTPClient`. I first get the `Response` (of the type `HttpResponseMessage`)
    to check whether the result is valid. As we have seen, this is what the `IsSuccessStatusCode`
    property tells us.
  prefs: []
  type: TYPE_NORMAL
- en: This way, your communications with an HTTP server will become faster and much
    more stable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing retries with Polly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But of course, things will still go wrong. The server might be busy, or the
    network might be congested. The best way to get around that is to try again, and
    then again, until either it works or you give up.
  prefs: []
  type: TYPE_NORMAL
- en: You could write that logic yourself, but you would be better off using a standard
    library. The most used library that implements this is called **Polly**.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s install that NuGet package in our application first. You can do so
    in the CLI by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done that, we can change our `HttpClientFactory` class a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add a new `private static` field to that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is our `RetryPolicy`, which we will apply to the requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `CreateInstance` method in the `HttpClientFactory` class,
    add a call to a new method: `SetupRetryPolicy`. The method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the static `Policy` class, we call the `Handle()` method. We give it the
    `HttpRequestException` type parameter. This way, the framework knows the trigger
    to start retrying. We also tell it to retry if `HttpResponseMessage.IsSuccesStatusCode`
    is set to false.
  prefs: []
  type: TYPE_NORMAL
- en: If one of those conditions arises, we tell the policy to `WaitAndRetryAsync`.
    We ask it to give it three retries after the first failure. The following parameter
    tells the `Policy` to wait for 2, 4, or 8 seconds (2 to the power of the retry
    number). So, it waits twice as long each time to give the server time to get its
    stuff in order.
  prefs: []
  type: TYPE_NORMAL
- en: We also give it a delegate that the framework will execute as soon as it starts
    to retry. In this case, we print out some messages to the console, telling it
    what failed, how long it will wait before it tries again, and how many times it
    has tried already.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in place, we can rewrite how we ask the `HTTPClient` for data. In
    the previous example, I showed you how to get the `Instance` from the factory
    and then use that instance directly. I want to move that code to `HttpClientFactory`
    as well. But the call to the server must be wrapped up in our new `Policy`. The
    method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the user of our class calling `GetAsync(url)`, we do it for them
    using this wrapper method. But we wrap up that call in `_retryPolicy.ExecuteAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the original code that uses this factory to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of calling `client.GetAsync()`, I now call `HttpClientFactory.GetAsync()`.
    The rest hasn’t changed. Well, that’s not entirely true. I also altered the URL
    a bit. I am not asking for `posts2` instead of `posts` in that URL. And that doesn’t
    exist. That should trigger our retry mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Run it and see what happens. There you go – retries done the right way!
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A similar pattern is the circuit breaker pattern. This pattern detects when
    connections are in a fault state and prevents the system from making calls to
    the server for a predefined period. If the connection raises errors, the circuit
    breaker opens and stops all communications to that server for a while. After that
    cooldown period, it opens a bit to allow another quick peek at the server. If
    it seems to work, it allows full traffic. Otherwise, it will give up and let you
    know things have gone wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The circuit breaker is also part of the Polly NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Validating network availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trying to connect to a server that doesn’t exist will result in errors. But
    what happens if your own network has an issue? In that case, it would look like
    all servers worldwide are down.
  prefs: []
  type: TYPE_NORMAL
- en: That last scenario doesn’t seem so likely, so verifying that our network is
    healthy would be nice before we blame the entire internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that it is not too hard to do so. All you need is one line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also interrogate each network adaptor in your machine like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can iterate through all network adapters and see what their status is. That
    can help us to select the suitable adapter and thus the right IP address if we
    want to be resilient against errors and failures.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one goes without saying: *the best way to solve issues is to log and monitor
    what is happening*. If you have extensive logging, you are much more likely to
    find problems if they occur. But let’s not worry about that too much for now.'
  prefs: []
  type: TYPE_NORMAL
- en: If you follow these tips and tricks, you will still face network issues. They
    are inevitable. But at least network failures will not bring your system down.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into networking. We broke out of the confines
    of the local machine and looked at all the good stuff that the BCL gives us when
    it comes to connecting to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at default protocols such as HTTP, FTP, and SMTP. We also looked at
    sockets in case the predefined protocols are not good enough, such as when you
    want to look up the current time from a time server. We dove into asynchronous
    networking and talked a lot about performance and making our networking error-proof
    and more robust.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s be honest: almost no computer these days runs on its own. Most machines
    and thus the software running on them, are somehow connected to the outside world.
    Especially the things we as system programmers are interested in are not used
    by users, but instead by other software. Some of that software lives on other
    machines. This means it is imperative you know about networking. And now you do!'
  prefs: []
  type: TYPE_NORMAL
- en: We did not talk about security and logging. Logging is something we touch on
    in [*Chapter 10*](B20924_11.xhtml#_idTextAnchor222). Security is the topic of
    [*Chapter 12*](B20924_13.xhtml#_idTextAnchor260). Yes, these topics are so important
    they deserve their own chapter.
  prefs: []
  type: TYPE_NORMAL
- en: But before we go there, let’s take a little trip to other platforms. Since systems
    programming works closely with devices, I thought it would be fun to dive into
    another device and see if we could talk to some fancy hardware. So, let’s go there
    next!
  prefs: []
  type: TYPE_NORMAL
