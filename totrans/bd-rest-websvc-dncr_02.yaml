- en: Building the Initial Framework – Laying the Foundation of the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about REST, its characteristics, and how it is
    implemented in ASP.NET Core. We will go ahead with that knowledge and set up the
    environment to develop an application in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will start building the basic framework of the app. We will understand each
    and every HTTP verb, how they work, and their implementation paradigms in ASP.NET
    Core Web API. Before all that, we will have a quick look at SOAP and how it is
    different from REST.
  prefs: []
  type: TYPE_NORMAL
- en: While we walk though the verbs, we will explore a very easy-to-use tool to analyze
    the HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: All about web services (REST and SOAP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST verbs and status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of verbs in ASP.NET Core Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples using Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP versus REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single-page application model with REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service-oriented architecture (SOA) overview with REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Object Access Protocol** (**SOAP**) is an XML-based messaging protocol
    for exchanging information among computers. SOAP relies on application layer protocols,
    most often **Hypertext Transfer Protocol** (**HTTP**) or **Simple Mail Transfer
    Protocol** (**SMTP**), for message negotiation and transmission. As we are talking
    about HTTP, which is installed and runs on every operating system, web services
    implementing SOAP can be called from any platform using any language.'
  prefs: []
  type: TYPE_NORMAL
- en: SOAP structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that a SOAP message is an XML document, but let''s have a better
    look by way of a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad718f4f-5d99-4e2e-893e-eb665dc02a08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a description of the components from the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Envelope**: Mandatory element of SOAP message structure. Defines the start
    and the end of the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header**: Optional element of the SOAP message. It contains information regarding
    the SOAP message that can be used to process the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body**: This is the main part, which contains the actual message in XML structure.
    Obviously, it is a mandatory element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fault**: If any errors occur while processing the SOAP message, an optional
    Fault element can be used to provide information about them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must be thinking who exactly told us to follow this type of structure. Well,
    there is an organization named W3 that proposes standards for particular technologies.
    They have done the same for the SOAP structure.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily find details about the SOAP envelope at [http://www.w3.org/2001/12/soap-envelope](http://www.w3.org/2001/12/soap-envelope).
    Likewise, you can see details about SOAP encoding and data types at [http://www.w3.org/2001/12/soap-encoding](http://www.w3.org/2001/12/soap-encoding).
  prefs: []
  type: TYPE_NORMAL
- en: Whatever we discuss about the structure of the SOAP message is defined by the
    W3 organization. However, this organization constantly investigates ways to optimize
    structures and bring in more robust specifications from time to time. So, we have
    to update with the latest specifications provided by them and implement them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block depicts the general structure of a SOAP message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The receiver is notified about the whole SOAP message with the indication of
    an envelope. What this means is, if the message received by the client has an
    envelope inside it, then the message is completely received and the client can
    parse and use it for further processing. Thus, the SOAP envelope plays the role
    of packaging the whole message.
  prefs: []
  type: TYPE_NORMAL
- en: Important points about SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some important points about SOAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Envelope` in every SOAP message has the root position and that is mandatory
    for all SOAP messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exactly one body element should be present inside one SOAP envelope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Header` element is an optional element. However, if that is present, then
    there should be only one `Header` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Header` must appear as the first child of the envelope, before the body
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ENV` namespace prefix and the `Envelope` element are used in order to build
    one SOAP envelope. (Refer to the following example.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `encodingStyle` attribute defines the data types used in the document. This
    gives a generalization of the data types that appear in the message. If this attribute
    appears on any SOAP element, it will apply the encoding rules to the element's
    contents and all child elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a v1.2-compliant SOAP message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: SOAP with HTTP POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Authors` mentioned in the HTTP header is actually the URL of the controller
    or program to be invoked that have a `POST` action method inside it. Everything
    is hosted at [www.packtpub.com](http://www.packtpub.com).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is an architectural style for providing standards between computer systems
    on the web, so that systems can communicate with each other easily. Services compliant
    to the REST style are often called RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about a few important constraints of a web service when it is tagged
    as RESTful.
  prefs: []
  type: TYPE_NORMAL
- en: Server and client are independent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With REST, there is no restriction or dependency between server and client.
    Both can be independent of each other. It's just the URL by which the client understands
    the service. The code for a web service on a server can be modified without caring
    about the clients that are associated with it and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of separation helps the client/server architecture to breathe freely
    without any hurdles. Therefore, designing the application and separating its core
    business logic becomes easy. What I mean by that is simple. Designing the app
    can be done using client-side technologies and the RESTful web service is invoked
    wherever there is a necessity for business-related operations in a database.
  prefs: []
  type: TYPE_NORMAL
- en: However, keeping both server and client modular and separate depends on one
    condition and that is the format of the messages they send and receive. Both of
    them should be aware of the message format to send and receive.
  prefs: []
  type: TYPE_NORMAL
- en: As the user interface is separated from the business-and data-storage-related
    operations, flexibility and scalability can be improved by simplifying the server
    components. Moreover, the separation allows each component to evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: REST endpoints are exposed by certain URLs. Different clients can connect using
    the URL, then perform the action intended and get the response back.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will build a small e-commerce web service with minimal operations,
    where a user can use a cart and make orders. These operations will be exposed
    using endpoints. As we discussed, endpoints can be easily consumed from different
    types of clients including mobile apps, web apps, server-side code, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept is very easy to understand. In a server/client architecture, the
    server needs to know which client is requesting data from it and, accordingly,
    it decides what to send and what not to send.
  prefs: []
  type: TYPE_NORMAL
- en: However, REST systems are stateless. That means the server does not need to
    know anything about the client's state and vice versa. That would eventually remove
    the overhead on the server to identify the client each time a request comes in.
  prefs: []
  type: TYPE_NORMAL
- en: But now the question is, how do the client and server interact? The answer is
    through appropriate messages. Suppose a user wants to see one order detail. It
    would simply ask the server by sending the ID of the order and the server would
    return the order details in either `.json` or `.xml` format, which can be easily
    parsed by the client. Every message has the required information for how to deal
    with that.
  prefs: []
  type: TYPE_NORMAL
- en: These constraints (along with a few other constraints such as *caching*, *layered
    system*, *uniform interface*, and *code on demand*) when implemented on a web
    service help RESTful applications achieve reliability, optimized performance,
    and scalability. The reason being that components can be managed independently,
    updated flawlessly, and reused without affecting the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at exactly how communication takes place between the server and client
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we explore the communication mechanism, let's first set up the development
    environment. We will use Visual Studio 2017 for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio and undertake our favorite step, File | New | Project, which
    opens up a dialog window with available templates, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/942c014e-419a-4f13-ad2a-952404753a71.png)'
  prefs: []
  type: TYPE_IMG
- en: Select ASP.NET Core Web Application as shown in the preceding screenshot. Don't
    forget to select .NET Core in the left-hand side panel. Everything looks cool
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's click OK and then we will land on another dialog where we can select more
    templates related to our web app. Obviously, we will click on Web API and then
    click OK.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65a05503-18af-4f76-85b3-7546b4c189b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The project is created. Beautifully, it has crafted all the necessary components
    and created an example controller for us named `ValuesController` as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/970fa804-0df1-455c-b192-a74719363e49.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, here is one interesting fact. Notice that the `ValuesController` class
    inherits the `Controller` base class. If you were familiar with Web API in ASP.NET
    before Core, you might know that the base class was `ApiController` instead. The
    reason behind this change is to have a uniformity between API and MVC structures.
    `Controller` was the base class in ASP.NET MVC. Now in ASP.NET Core, both MVC
    and Web API templates inherit the same base class. With ASP.NET Core, MVC and
    Web API are merged into one programming model.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make sure everything is working fine, let's run the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/069f0012-8421-4563-8ce5-29f9cfcbdd07.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's discuss what has just happened in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: What's cooking here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice the URL, `localhost:57571/api/values`, which sends the request to `ValuesController`
    because the route defined over the controller is `[Route("api/[controller]")]`.
    By convention, the controller name is always appended with the text *Controller*.
    Thus `api/values` hits `ValuesController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the question is, how it returns `value1` and `value2`. That is because
    we directly accessed the URL through the browser, which ultimately sent a `GET`
    request to the controller. As the controller already has a `Get` method, it got
    executed. The `Get` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method returns an array of strings, which is printed in the browser. For
    understanding, the URL format is already there above the method *(*`api/values`*)*.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s experiment with a few things now. You will get a very good insight into
    what happens behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add another method, `Get12()`, to the controller and remove the `[HttpGet]`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think the output would be? It''s interesting. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
  prefs: []
  type: TYPE_IMG
- en: That means it found two `GET` methods and it was not able to decide which one
    to execute. Note that neither of them is decorated by an attribute, such as `[HttpGet]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s plan to bring back the attribute and test what happens. However,
    we will decorate the new `Get12` method and leave the old `Get` method intact
    with the attribute commented. So, the code would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a quick look at what we did to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44d0405c-533e-4096-99f8-ab9938248849.png)'
  prefs: []
  type: TYPE_IMG
- en: Clear enough! The `Get12` method was executed and the reason for this was that
    we explicitly told it that it was the `Get` method by way of the `[HttpGet]` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'More fun can be experienced by adding an attribute to both of the methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess the output? Yes, it is the same as we saw when we had both methods
    without the attribute **AmbiguousActionException** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s have another method named `HelloWorld()` with the attribute
    along with the existing ones. Let''s remove the attributes from the other ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Perfect! Let''s see the output. It''s Hello World in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9de3bc08-6ea3-4602-aed1-01ebf59429fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following conclusions can be made from the preceding observation. Note
    that we are talking about `GET` requests with the URL `api/values`, which means
    we are talking about all nonparameterized action methods in the controller. While
    reading the following points, ignore methods with parameters or other attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: When we access a particular Web API controller without any parameters (for example,
    `api/values`), action methods with the `[HttpGet]` attribute are searched first
    from the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an attribute is not mentioned in nonparameterized methods, then the .NET
    Core runtime will get confused when selecting one action method for the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no restriction on the naming convention of the action method. As long
    as it is the only method with no `[HttpGet]` attribute or the only method with
    an `[HttpGet]` attribute, it would be perfectly executed when `GET request` comes
    to the API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request and response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have had a quick look at the demo `ValuesController`, let's examine
    exactly how the client sends the request and how it receives the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'A REST request generally consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP verb:** This denotes what kind of operation the requests want to perform
    on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header:** This element of the REST request allows the client to pass more
    information about the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URL:** The actual path to the resource that the REST request wants to operate
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body:** The body can contain extra data related to a resource to identify
    or update it. This is optional though.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are basic HTTP verbs used while requesting a REST system for
    resource interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET:** Used to retrieve a specific resource by its identity or a collection
    of resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST:** Used to create/insert a new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT:** Used to update a specific resource by its identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE:** Used to remove a specific resource by its identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to explore the request/response mechanism in REST for these verbs
    one by one. We will try to design an e-commerce application with basic operations.
    In the first phase, we will work on products, which is the core of these types
    of apps.
  prefs: []
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test the API, we can use a very easy-to-use tool named *Postman*. It can
    be downloaded from: [https://www.getpostman.com/](https://www.getpostman.com/).
    Please download and open it. We will see how to send requests through Postman
    and analyze responses we get from Web API in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I will add another controller called `ProductsController`. For now, let''s
    have a simple action method, `GET`, which will return some products. The products
    are hard-coded in the action method for now. The method will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `[Route]` attribute is provided with a well-defined template of  `"api/[Controller]"`.
    Here, the controller name is `ProductsController`. When we request using the URL
    `api/Products`, the framework will search for a controller with that route defined
    on it. The `[Controller]` placeholder is a special naming convention that will
    be replaced with the text (name of controller) `Products` at runtime. However,
    you can directly write the fully qualified template with the controller name,
    such as `[Route (api/Products)]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this `GET` method will return us three products with their details. The `Product`
    class can be designed, like the following, with a constructor to build *Product*
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are done. Let''s do a `GET request` through *Postman* to analyze the request
    and response mechanism in REST. For a `GET request`, it''s simple. Just open Postman.
    Then follow the steps mentioned in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/619271a2-f6d7-4240-a326-96f485df93d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Executing GET request in Postman
  prefs: []
  type: TYPE_NORMAL
- en: In **Step-1**, just paste the URL, which is `http://localhost:57571/api/products`
    for our example. Everything else is already set for a `GET` request. You can see
    the request type to the left of the URL box, which is `GET`. That means the current
    request will be a `GET` request. Hit the Send button as shown in **Step-2**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response is a list of products shown inside the section at the bottom.
    It''s in `.json` format. Please refer to the following screenshot, which displays
    the response of the `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17867f88-93d2-46ef-987f-2ce009fa1106.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you have had a pleasant look at how `GET` works, let's analyze what
    happens behind the scenes. The client, which is *Postman* here, sends an HTTP
    request and gets a response in return. While sending requests it also specifies
    the Request Headers, and the server, in return, sends the Response Headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP Headers enable the client and server to both send and receive additional
    information with the request and response respectively. This decides the exact
    behavior of the HTTP transaction. You can refer to the following resources to
    learn more about the headers. We will have a quick look at the headers in the
    next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Postman, you can click on Code**,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a7fe2db-4d7b-4326-90bf-a2365cae80ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on this link will open one modal that will show you the HTTP Request
    Headers sent to the server to serve the request. Check out the following screenshot
    of the modal, which clearly mentions the Request Type as `GET`, `Host` as the
    URL of the API, and then other headers such as `Cache-Control` and `Postman-Token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d077605-65eb-4f0c-b7d7-b6d2cbe02ff6.png)'
  prefs: []
  type: TYPE_IMG
- en: Want to know what the *jQuery* code snippet looks like for this `GET` call?
    It's super-easy with Postman. Click on Code on the main screen, then from the
    drop-down menu containing languages, select *jQuery*. (See the following screenshot.)
    Moreover, you can get code in different languages by selecting from the drop-down
    list. Happy copying!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a0b8cb-9885-4c77-a57e-17f420a0974a.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Response Header* is clearly shown on the main page, as shown in the following
    screenshot. Notice that there is a Status code mentioned, which is 200 OK in this
    case. So, what does this code signify?'
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c42408-1b22-4bdd-9665-6f0052afbb7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Postman Response Headers
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a server returns responses, it includes status codes. These status codes
    inform the client how the request performed on the server. As a developer, you
    do not need to know every status code (there are many of them), but you should
    know the most common ones and how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| 200 OK | Standard response for successful HTTP requests. |'
  prefs: []
  type: TYPE_TB
- en: '| 201 CREATED | Standard response for an HTTP request when an item is successfully
    created. |'
  prefs: []
  type: TYPE_TB
- en: '| 204 NO CONTENT | Standard response for successful HTTP requests, if nothing
    is returned in the response body. |'
  prefs: []
  type: TYPE_TB
- en: '| 400 BAD REQUEST | Request cannot be processed because of bad request syntax,
    excessive size, or another client error. |'
  prefs: []
  type: TYPE_TB
- en: '| 403 FORBIDDEN | Client does not have permission to access the requested resource.
    |'
  prefs: []
  type: TYPE_TB
- en: '| 404 NOT FOUND | Resource could not be found at this time. It might have been
    deleted, or does not exist yet. |'
  prefs: []
  type: TYPE_TB
- en: '| 500 INTERNAL SERVER ERROR | This response comes whenever there is a failure
    or exception happens while processing the server side codes. |'
  prefs: []
  type: TYPE_TB
- en: 'Some status codes are (by default) expected from the server for the following
    HTTP verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Returns 200 OK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Returns 201 CREATED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Returns 200 OK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Returns 204 NO CONTENT if the operation failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already saw how API returned 200 OK for the `GET` request. As we move forward
    with other verbs, we will explore the responses returned with the codes mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core HTTP attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the *Internet Engineering Task Force (IETF) RFC-7231* document
    ([https://tools.ietf.org/html/rfc7231](https://tools.ietf.org/html/rfc7231)), ASP.NET
    Core has implemented seven HTTP attributes out of the eight HTTP verbs listed.
    The only exclusion in the framework, from the list of verbs, is the HTTP TRACE
    verb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the complete list of HTTP verb attributes that are provided in
    ASP.NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpGetAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpPostAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpPutAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpDeleteAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpHeadAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpPatchAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HttpOptionsAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the verb name is attached with the attribute, it is very obvious that they
    will be used for their respective verbs. These attributes help the framework to
    understand what action method is associated with what verb. With that in mind,
    it can decide which one to execute when a request comes for the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Another important attribute for routing is also provided by the framework, named
    `RouteAttribute`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more attributes used for the parameters of action methods to
    help recognize parameters passed to the API action from different places of the
    request such as URL, Body, and so on. Following are some attributes present in
    the framework for the action parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FromServicesAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromRouteAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromQueryAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromBodyAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FromFormAttribute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: POST is used to create a resource. In our case, we will try to create a product
    using a POST request to the server. Before doing that, we will make a few changes
    to our project. You can find all related code on GitHub ([https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core](https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core)),
    so don't worry at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why wait then? Let''s write the Post method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The action method calls `CreateProductAsync` of the related service and checks
    if the operation was successful. If successful, it sends back `201`, else `500`.
    Note that to send back the correct status code, we are leveraging the `IActionResult`.
    This interface has a large set of subclasses that are accessible via the `Controller`
    class. Since we inherit from the `Controller` base class, we can easily use methods
    such as `StatusCode` to return our intended status according to the operation
    we performed on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we mentioned that on `POST` success, we should get
    201 CREATED and on failure, it should send a generalized 500 Internal Server Error
    response. That is what the code does.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another interesting thing, that is: `Created($"api/products/{product.Id}",
    product)`. This is a method inside the `Controller` class which assigns the URL
    to the location and 201 to the status code of the response. Don''t believe me!?
    Okay, let me prove it by way of *Postman*, right away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot taken from the *Postman* request screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63d0c202-8c23-4619-8af2-04c5a66798fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we passed the data for a product as JSON and after creating the
    product, the API returned us the status code as 201 Created and the URL of the
    new product created, which is api/products/1\. What that means is that when you
    run this URL as a `GET` request, you will receive the newly created product details.
    Simple, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the datatype of the passed product details is JSON, but the
    question is, who told the server that it is in that format? Well, that's the request
    header `content-type` set with value `application/json`. You can see that in the
    last screenshot. A default encoding of `charset=utf-8` is appended by *Postman*.
  prefs: []
  type: TYPE_NORMAL
- en: However, interestingly, how come *Postman* knew that we wanted the datatype
    content to be JSON? It can't set it automatically. I told it to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The option to set any type of request header is just below the URL textbox.
    Refer to the following screenshot, which shows that I have set the `content-type`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae9c588d-6399-4589-9ff3-7d9b78150004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the previously mentioned `GET` request, which returns the product details
    by ID, we can design the action method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are providing a template argument of `"{id}"` to `[HttpGet]`. This
    will make sure that one HTTP Get route such as `api/orders/1` is available—where
    the ID is a variable passed to the `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: We have a service called `ProductService` which is implementing the interface
    `IProductService` and through the constructor of the controller, the service (dependency)
    is injected, which is called *dependency injection*. With .NET Core, it's very
    easy to handle dependencies with the built-in *inversion of control container*.
    If you are not getting what I am talking about, then I would highly recommend
    going through my other book on this topic, *Dependency Injection in .NET Core *([https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20)).
  prefs: []
  type: TYPE_NORMAL
- en: PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP PUT verb is idempotent. This means that the first HTTP PUT request
    with a certain payload will impact the server and the resource. It will update
    the resource specified by ID. However, subsequent HTTP PUT requests with the same
    payload would result in the same response as the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example where we will update one product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `[HttpPut]` attribute is supplied with a template of `{id}` similar to what
    we had in `[HttpGet]`. In the case of `PUT`, it would get the ID from the URL
    and the `Product` object from the body of the request, which is specified by the `[FromBody]`
    attribute as we did in the case of `POST` in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: When the ID and the product object is tied with the arguments, the method body
    starts execution, which in turn calls the service method `UpdateProductAsync`
    with the same parameters. That method would return a Boolean based on whether
    the update was successful. If everything was successful, we would return 200 OK
    by calling the `OK()` method, otherwise a 500 Internal Server Error would be given
    if an error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you the screenshot from Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85d426a0-14ac-4d18-b9ff-b713b5490480.png)'
  prefs: []
  type: TYPE_IMG
- en: Another status code, 301 Moved Permanently, can be returned if the `PUT` request
    comes with an ID that has expired, meaning the product passed in the request body
    is not associated with the ID. To identify this condition, we need to add business
    logic accordingly, and if we can verify whether the ID is related to the product
    or not. If not, we can simply return 301 Moved Permanently with the new URL where
    the product actually exists currently.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, a `DELETE` request should delete the resource. Once the operation is
    successful, we can send a 200 OK status code by calling the `OK()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `DeleteOrderAsync` method, which is provided with the ID of the product
    to delete. Now, you can return a Boolean from that method, which will indicate
    whether the operation was successful or not. If you don't find any product for
    that ID, simply return `false`.  Then, we will decide what to return to the client
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you return `false`, `NoContent()` can be used to return status code *204*.
    If the resource is already deleted and the client is requesting the same, then
    the server will return a status code 204 No Content. That means the server is
    not able to find the requested resource as it does not exist anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the Postman screenshot. See the Status code is *200 OK* for
    a successful delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f1cd17b-a04c-43da-9af4-aa519632813f.png)'
  prefs: []
  type: TYPE_IMG
- en: SOAP versus REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are some key differences between SOAP and REST:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **SOAP** | **REST** |'
  prefs: []
  type: TYPE_TB
- en: '| It is an XML-based message protocol. | It is an architectural style. |'
  prefs: []
  type: TYPE_TB
- en: '| WSDL is used for communication between client and server.  | XML or JSON
    is used to send and receive data between client and server. |'
  prefs: []
  type: TYPE_TB
- en: '| Services are invoked by calling the RPC method. | Services expose endpoints
    via URLs. |'
  prefs: []
  type: TYPE_TB
- en: '| Response is easily readable by a human. | Response is readable in the form
    of plain XML or JSON. |'
  prefs: []
  type: TYPE_TB
- en: '| Data transfer occurs over HTTP. It leverages protocols such as SMTP, FTP,
    and so on. | REST data transfer occurs over HTTP only. |'
  prefs: []
  type: TYPE_TB
- en: '| It is difficult to call a SOAP service from JavaScript. | It is very easy
    to call a REST service from JavaScript. |'
  prefs: []
  type: TYPE_TB
- en: Single-page application model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditionally, in a web application, the client requests the server for a web
    page. Then, the server responds to the client with the requested HTML page after
    validating and authenticating the request, if necessary. The next request to the
    server might occur when a user hits some link on the page, submits a form, and
    so on. The server again processes the request and sends back the response with
    another HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Don't you think instead of getting the whole HTML page (which would be mostly
    the same look and feel as the last loaded page), we should just get the data we
    need and update the currently loaded page itself without posting back to the server?
    Yes, modern web development works in that regard. Today, we just need data from
    the server on demand using Ajax. After receiving the data, we will just update
    the UI with JavaScript or a client-side framework such as Angular.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we call a **s****ingle-page application** (**SPA**). On the first
    request to the server, the server responds with the entire page for the app. Unlike
    traditional web apps, subsequent requests won't ask for an HTML page, rather they
    will ask for data using Ajax requests where the type of content is usually JSON.
    After getting data, the browser has to update only the portion of the page that
    has changed instead of reloading the entire page again. The SPA definitely improves
    user experiences by responding quickly to user actions on the same page because
    reloading the page takes away a user's attention for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: However, implementing SPA is not so easy as we have to be sure that we are showing
    fresh data on the page whenever needed. Here, emerging technologies, such as ASP.NET
    Web API, and JavaScript frameworks, such as AngularJS and CSS3 come in handy when
    designing SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Your application can call different endpoints of the REST API to do certain
    tasks and update the UI after getting responses without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like SPA, Web API plays an important role in **service-oriented architecture**
    (**SOA**). As the name suggests, it is an architecture methodology that deals
    with separation of responsibility from a business-oriented point of view into
    independent services. Often, these independent services or components can be designed
    using RESTful Web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an e-commerce application that would have different components such
    as ordering, billing, payment processing, customer profile management, and so
    on. Each of these components has its own business logic and can be implemented
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents a pictorial view of such an application having
    independent components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caf5879a-a824-4cf6-a707-2668eeace98e.png)'
  prefs: []
  type: TYPE_IMG
- en: To make them independent, RESTful APIs can be exposed for these components,
    which can be easily consumed by any client/application including other components
    as well, as long as they satisfy the authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a pictorial representation of a monolithic or traditional application
    architecture versus SOA. It''s perfectly clear how SOA introduces reusable components
    for the same business application. Moreover, implementing them with Web API brings
    the capability to expose that to outside for consumption by any application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0c2ee14-34e7-4937-b027-18e9b449c2dd.png)'
  prefs: []
  type: TYPE_IMG
- en: SOA implementation is beyond the scope of this book because there is a lot of
    stuff about Web API we need to explore in the next chapters. Whatever we do with
    the application in this book would use one Web API, but you can separate them
    out to build a more scalable architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started with some basic knowledge of SOAP and then we moved towards REST
    gradually.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shed some light on the fundamental REST building blocks and how
    they actually work. We explored the different status codes returned by widely
    used HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: To explore the request and response cycles of Web API, you can use Postman,
    where you not only have control over what is being sent and received, but also
    the ability to get code for different languages in order to consume the API.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core attributes can be tied to controller action methods to make them
    more expressive and manageable in terms of routing and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '*Single-page applications* can be easily designed using client-side technologies
    and consuming ASP.NET Core Web APIs so that pages can be updated as soon as responses
    are received to have a smooth user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs can be plugged into the s*ervice-oriented architecture* to have a modular
    design that improves scalability. By separating different critical components
    of the whole architecture with the help of APIs, it leaves us in a better position
    to reuse the components in different applications and expose them to the world
    so that they can be consumed by anyone.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the important parts of the Web API architecture
    related to authentication.
  prefs: []
  type: TYPE_NORMAL
