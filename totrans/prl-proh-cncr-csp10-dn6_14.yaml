- en: '*Chapter 11*: Canceling Asynchronous Work'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：取消异步工作'
- en: In the previous chapters, we’ve looked at a few examples of how to cancel threads
    and tasks. This chapter will explore more of the methods available to cancel concurrent
    and parallel work with C# and .NET. The methods in this chapter will provide alternative
    ways to cancel background operations using callbacks, polling, and wait handles.
    You will gain a deeper understanding of how to safely cancel asynchronous work
    with a variety of methods using some practical scenarios.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们查看了一些如何取消线程和任务的示例。本章将探讨更多使用 C# 和 .NET 取消并发和并行工作的方法。本章中的方法将提供使用回调、轮询和等待句柄取消后台操作的替代方法。您将通过一些实际场景深入了解如何使用各种方法安全地取消异步工作。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Canceling managed threads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消托管线程
- en: Canceling parallel work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行工作
- en: Discovering patterns for thread cancellation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现线程取消的模式
- en: Handling multiple cancelation sources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个取消源
- en: By the end of this chapter, you will understand how to cancel different types
    of asynchronous and parallel tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解如何取消不同类型的异步和并行任务。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章中的示例，以下软件对 Windows 开发者来说是推荐的：
- en: Visual Studio 2022 version 17.2 or later.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022 版本 17.2 或更高版本。
- en: .NET 6.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6.
- en: To complete any WinForms or WPF samples, you will need to install the .NET desktop
    development workload for Visual Studio. These projects will only run on Windows.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完成任何 WinForms 或 WPF 示例，您需要为 Visual Studio 安装 .NET 桌面开发工作负载。这些项目只能在 Windows
    上运行。
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到，网址为 [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter11)。
- en: Canceling managed threads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消托管线程
- en: Canceling asynchronous work in .NET is based on the use of a `CancellationTokenSource`
    object manages these requests and contains a token. If you want to cancel several
    operations with the same trigger, the same token should be provided to all of
    the threads to be canceled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中取消异步工作基于使用 `CancellationTokenSource` 对象来管理这些请求并包含一个令牌。如果您想使用相同的触发器取消多个操作，应将相同的令牌提供给所有要取消的线程。
- en: A `CancellationTokenSource` instance has a `Token` property to access the `CancellationToken`
    property and pass it to one or more asynchronous operations. The request to cancel
    can only be made from the `CancellationTokenSource` object. The `CancellationToken`
    property provided to the other operations receives the signal to cancel but cannot
    initiate a cancellation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource` 实例有一个 `Token` 属性，用于访问 `CancellationToken` 属性并将它传递给一个或多个异步操作。取消请求只能从
    `CancellationTokenSource` 对象发出。提供给其他操作的 `CancellationToken` 属性接收取消信号但不能启动取消操作。'
- en: '`CancellationTokenSource` implements the `IDisposable` interface, so be sure
    to call `Dispose` when you are freeing your managed resources. A `using` statement
    or block to automatically dispose of the token source would be preferred if it
    is practical for your workflow.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource` 实现了 `IDisposable` 接口，因此在释放您的托管资源时，请务必调用 `Dispose`
    方法。如果对您的流程来说可行，使用 `using` 语句或块来自动处理令牌源会更受欢迎。'
- en: It is important to understand that cancellation is not forced on the listening
    code. The asynchronous code that receives a cancellation request must determine
    whether it can currently cancel its work. It might decide to immediately cancel,
    cancel after finishing some intermediate tasks, or finish its work and ignore
    the request. There can be valid reasons why a routine will ignore a request to
    cancel. It is possible that the work is almost complete or that canceling in the
    current state will cause some data corruption. The decision to cancel must be
    mutual between the requestor and the listener.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要，取消并不是强制施加在监听代码上。接收取消请求的异步代码必须确定它是否可以当前取消其工作。它可能决定立即取消，在完成一些中间任务后取消，或者完成其工作并忽略请求。可能有合理的理由让一个例程忽略取消请求。可能工作几乎完成，或者当前状态取消会导致某些数据损坏。取消的决定必须在请求者和监听者之间是相互的。
- en: 'Let’s look at an example of how to cooperatively cancel some work being processed
    on a background thread on the `ThreadPool` thread:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 `ThreadPool` 线程上如何协同取消一些正在处理的后台线程工作示例：
- en: In Visual Studio, create a new .NET 6 console application named `CancelThreadsConsoleApp.`
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，创建一个名为 `CancelThreadsConsoleApp` 的新 .NET 6 控制台应用程序。
- en: Add a new class named `ManagedThreadsExample`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中创建一个名为 `ManagedThreadsExample` 的新类。
- en: 'Create a method named `ProcessText` in the `ManagedThreadsExample` class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ManagedThreadsExample` 类中创建一个名为 `ProcessText` 的方法：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method appends the value of the iterator variable, `x`, to the `string`
    variable of `text` until a cancellation request is received. There is a `Thread.Sleep(500)`
    statement to allow the calling method some time to cancel the operation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将迭代变量 `x` 的值追加到 `text` 的 `string` 变量中，直到收到取消请求。有一个 `Thread.Sleep(500)` 语句，以便调用方法有足够的时间取消操作。
- en: 'Next, create a method named `CancelThread`, in `Program.cs`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `Program.cs` 中创建一个名为 `CancelThread` 的方法：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method calls `ThreadPool.QueueUserWorkItem` to queue the `ProcessText`
    method in the `ThreadPool` thread. The method also receives a cancellation token
    from `tokenSource.Token`. After waiting for five seconds, `tokenSource.Cancel`
    is called, and `ProcessText` will receive the cancellation request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法调用 `ThreadPool.QueueUserWorkItem` 将 `ProcessText` 方法排队到 `ThreadPool` 线程。该方法还从
    `tokenSource.Token` 接收一个取消令牌。等待五秒后，调用 `tokenSource.Cancel`，`ProcessText` 将收到取消请求。
- en: Notice that `tokenSource` is created in a `using` statement. This ensures that
    it will be properly disposed of when it goes out of scope.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `tokenSource` 是在 `using` 语句中创建的。这确保了当它超出作用域时，它将被正确地释放。
- en: 'Add a call to `CancelThread` to the `Main` method in `Program.cs`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的 `Main` 方法中添加对 `CancelThread` 的调用：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, run the application and observe the console output:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行应用程序并观察控制台输出：
- en: '![Figure 11.1 – Running the CancelThreadsConsoleApp project ](img/Figure_11.1_B18852.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 运行 CancelThreadsConsoleApp 项目](img/Figure_11.1_B18852.jpg)'
- en: Figure 11.1 – Running the CancelThreadsConsoleApp project
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 运行 CancelThreadsConsoleApp 项目
- en: The `for` loop should have enough time to execute 9 or 10 times before receiving
    the request to cancel. How does your output match up?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环应该在收到取消请求之前有足够的时间执行 9 或 10 次。你的输出是如何匹配的？'
- en: Now that we have covered some basics of cancellation and worked with a common
    method of using a cancellation token, let’s create some examples of how to cancel
    parallel loops and PLINQ queries.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了一些取消的基础知识，并使用了一个常见的取消令牌使用方法，让我们创建一些取消并行循环和 PLINQ 查询的示例。
- en: Canceling parallel work
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行工作
- en: In this section, we will work with some examples of canceling parallel operations.
    There are a few operations that fall into this realm. There are static parallel
    operations that are part of the `System.Threading.Tasks.Parallel` class and there
    are PLINQ operations. Both of these types use a `CancellationToken` property,
    as we used in our managed threading example in the previous section. However,
    handling the cancellation request is slightly different. Let’s look at an example
    to understand the differences.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过一些取消并行操作的示例来进行操作。有几个操作属于这个范畴。有静态并行操作，它们是 `System.Threading.Tasks.Parallel`
    类的一部分，还有 PLINQ 操作。这两种类型都使用了一个 `CancellationToken` 属性，就像我们在上一节中使用的托管线程示例一样。然而，处理取消请求的方式略有不同。让我们通过一个示例来了解这些差异。
- en: Canceling a parallel loop
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消并行循环
- en: 'In this section, we will create a sample that illustrates how to cancel a `Parallel.For`
    loop. The same method of cancellation is leveraged for the `Parallel.ForEach`
    method. Perform the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个示例，说明如何取消 `Parallel.For` 循环。相同的取消方法也用于 `Parallel.ForEach` 方法。执行以下步骤：
- en: Open the `CancelThreadsConsoleApp` project from the previous section.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一节中的 `CancelThreadsConsoleApp` 项目。
- en: 'In the `ManagedThreadsExample` class, create a new `ProcessTextParallel` method
    with the following implementation:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ManagedThreadsExample` 类中，创建一个新的 `ProcessTextParallel` 方法，其实现如下：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Essentially, the preceding code does the same thing as the `ProcessText` method
    in our last example. It appends a numeric value to the `text` variable until a
    cancellation is requested. Let’s examine the differences:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，前面的代码与我们的上一个示例中的 `ProcessText` 方法做的是同样的事情。它将一个数值追加到 `text` 变量中，直到收到取消请求。让我们看看它们之间的区别：
- en: First, we are setting `token.Value` to the `CancellationToken` property of a
    `ParallelOptions` object. These options are passed as the third parameter to the
    `Parallel.For` method.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将 `token.Value` 设置为 `ParallelOptions` 对象的 `CancellationToken` 属性。这些选项作为
    `Parallel.For` 方法的第三个参数传递。
- en: The second major difference is that we handle the cancellation request by catching
    an `OperationCanceledException` type. This exception type will be thrown when
    our other code in `Program.cs` requests a cancellation.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个主要区别是我们通过捕获 `OperationCanceledException` 类型来处理取消请求。当我们的 `Program.cs` 中的其他代码请求取消时，将抛出此异常类型。
- en: 'Next, add a method named `CancelParallelFor` to `Program.cs`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `Program.cs` 中添加一个名为 `CancelParallelFor` 的方法：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this method, the user is instructed to press a key to start the operation
    and to press the *X* key when they are ready to cancel the operation. The code
    to handle receiving `x` `KeyChar` from the console and sending a `Cancel` request
    is performed on another thread in order to keep the current thread free to call
    `ProcessTextParallel`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，用户被指示按下一个键以启动操作，并在他们准备好取消操作时按下 *X* 键。处理从控制台接收 `x` `KeyChar` 并发送 `Cancel`
    请求的代码在另一个线程上执行，以便保持当前线程可以调用 `ProcessTextParallel`。
- en: 'Finally, update the `Main` method to call `CancelParallelFor` and comment out
    the call to `CancelThread`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新 `Main` 方法以调用 `CancelParallelFor` 并注释掉对 `CancelThread` 的调用：
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now run the project. Follow the prompts to cancel the `Parallel.For` loop,
    and examine the output:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行项目。按照提示取消 `Parallel.For` 循环，并检查输出：
- en: '![Figure 11.2 – Canceling a Parallel.For loop from the console ](img/Figure_11.2_B18852.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – 从控制台取消 Parallel.For 循环](img/Figure_11.2_B18852.jpg)'
- en: Figure 11.2 – Canceling a Parallel.For loop from the console
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – 从控制台取消 Parallel.For 循环
- en: Notice how the numbers are not in sequence at all. In this case, it appears
    that the `Parallel.For` operation used two different threads. The first thread
    started at `0`, while the second thread was operating on integers starting with
    `37500`. This is the midway point of the maximum value of `75000` provided to
    the method parameter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数字根本不是按顺序排列的。在这种情况下，看起来 `Parallel.For` 操作使用了两个不同的线程。第一个线程从 `0` 开始，而第二个线程在以
    `37500` 开始的整数上操作。这是提供给方法参数的最大值 `75000` 的中点。
- en: In the next section, we will briefly examine how to cancel a PLINQ query.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍如何取消 PLINQ 查询。
- en: Canceling a PLINQ query
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消 PLINQ 查询
- en: Canceling a PLINQ query is also achieved by catching the `OperationCanceledException`
    type. However, instead of using the `ParallelOptions` object that is used with
    parallel loops, you can call `WithCancellation` as part of the query.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 取消 PLINQ 查询也可以通过捕获 `OperationCanceledException` 类型来实现。然而，与用于并行循环的 `ParallelOptions`
    对象不同，您可以在查询中调用 `WithCancellation`。
- en: 'To learn how to cancel a PLINQ query, let’s walk through an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何取消 PLINQ 查询，让我们通过一个示例来操作：
- en: 'Start this example by adding a method named `ProcessNumsPlinq`, to the `ManagedThreadsExample`
    class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向 `ManagedThreadsExample` 类中添加一个名为 `ProcessNumsPlinq` 的方法来开始这个示例：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method creates an array of 25 million integers and uses the PLINQ query
    to determine which of them are divisible by seven. The `token.Value` is passed
    to the `WithCancellation` operation in the query. When an exception is thrown
    by a cancellation request, the exception details are written to the console.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建了一个包含 2500 万个整数的数组，并使用 PLINQ 查询来确定其中哪些可以被七整除。`token.Value` 被传递到查询中的 `WithCancellation`
    操作。当取消请求抛出异常时，异常详细信息将被写入控制台。
- en: 'Next, add a method named `CancelPlinq` to `Program.cs`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `Program.cs` 中添加一个名为 `CancelPlinq` 的方法：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, the cancellation will be triggered automatically after 100 milliseconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，取消将在 100 毫秒后自动触发。
- en: 'Update the `Main` method to call `CancelPlinq`, and run the application:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Main` 方法以调用 `CancelPlinq`，并运行应用程序：
- en: '![Figure 11.3 – Canceling a PLINQ operation in the console application ](img/Figure_11.3_B18852.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 在控制台应用程序中取消 PLINQ 操作](img/Figure_11.3_B18852.jpg)'
- en: Figure 11.3 – Canceling a PLINQ operation in the console application
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 在控制台应用程序中取消 PLINQ 操作
- en: Unlike the previous examples, there is no query output to examine. You cannot
    get partial output from a PLINQ query. The `result` variable will be `null`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例不同，没有查询输出可以检查。您无法从 PLINQ 查询中获取部分输出。`result` 变量将为 `null`。
- en: In the next section, we will work with some different methods of cancellation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些不同的取消方法。
- en: Discovering patterns for thread cancellation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现线程取消的模式
- en: There are different methods of listening for cancellation requests from a thread
    or task. So far, we have seen examples of managing these requests by either handling
    the `OperationCanceledException` type or checking the value of `IsCancellationRequested`.
    The pattern of checking `IsCancellationRequested`, usually inside a loop, is called
    `ManualResetEvent` or `ManualResetEventSlim`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法来监听来自线程或任务的取消请求。到目前为止，我们已经看到了通过处理 `OperationCanceledException` 类型或检查 `IsCancellationRequested`
    的值来管理这些请求的示例。通常在循环内部检查 `IsCancellationRequested` 的模式被称为 `ManualResetEvent` 或 `ManualResetEventSlim`。
- en: Let’s start by trying another example of handling a cancellation request by
    polling.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先尝试另一个通过轮询处理取消请求的示例。
- en: Canceling with polling
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过轮询取消
- en: 'In this section, we will create another example that uses polling to cancel
    a background task. The previous example of polling was running in a background
    thread on the `ThreadPool` thread. This example will also start a `ThreadPool`
    thread, but it will leverage `Task.Run` to start the background thread. We will
    create and process a million `System.Drawing.Point` objects, finding those with
    a `Point.X` value of less than `50`. Users will have the option to cancel processing
    by pressing the *X* key:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建另一个示例，该示例使用轮询来取消后台任务。前面的轮询示例是在 `ThreadPool` 线程上的后台线程中运行的。此示例也将启动一个
    `ThreadPool` 线程，但它将利用 `Task.Run` 来启动后台线程。我们将创建和处理一百万个 `System.Drawing.Point` 对象，找到
    `Point.X` 值小于 `50` 的对象。用户可以选择通过按 *X* 键来取消处理：
- en: Start by creating a new .NET console application project named `CancellationPatterns`
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为 `CancellationPatterns` 的新 .NET 控制台应用程序项目
- en: Add a new class to the project named `PollingExample`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `PollingExample` 的新类
- en: 'Add a private static method to `PollingExample` named `GeneratePoints`. This
    will generate the number of `Point` objects that we desire with random `X` values:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `PollingExample` 类中添加一个名为 `GeneratePoints` 的私有静态方法。这将生成我们所需的具有随机 `X` 值的 `Point`
    对象数量：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Don’t forget to add a `using` statement to use the `Point` type:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记添加一个 `using` 语句来使用 `Point` 类型：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add a private static method named `FindSmallXValues` to `PollingExample`.
    This method loops through the list of points and outputs those with an `X` value
    of less than `50`. Each time through the loop, it checks the token for cancellation
    and breaks out of the loop when it occurs:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向 `PollingExample` 类中添加一个名为 `FindSmallXValues` 的私有静态方法。此方法遍历点列表，并输出 `X`
    值小于 `50` 的点。每次循环时，它会检查令牌是否被取消，并在发生取消时退出循环：
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A `Thread.SpinWait` statement is added at the end of the loop to give users
    some time to cancel the operation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的末尾添加了一个 `Thread.SpinWait` 语句，以给用户一些取消操作的时间。
- en: 'Add a public static method to `PollingExample` named `CancelWithPolling`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `PollingExample` 类中添加一个名为 `CancelWithPolling` 的公共静态方法：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding method creates the `CancellationTokenSource` object and passes
    it to `FindSmallXValues` and also `Task.Run`. If you wanted to cancel the `Task`,
    instead of breaking out of the loop when `IsCancellationRequested` becomes `true`,
    you would call `token.ThrowIfCancellationRequested`. This would throw an exception
    in the `Task`. The `CancelWithPolling` method would then require a `try`/`catch`
    block around the `Task.Run` call. It’s a best practice to use exception handling
    with all multithreaded code anyway. In this case, you would have two exception
    handlers: one to handle `OperationCanceledException` and a second to handle `AggregateException`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法创建了 `CancellationTokenSource` 对象，并将其传递给 `FindSmallXValues` 和 `Task.Run`。如果你想要取消
    `Task`，当 `IsCancellationRequested` 变为 `true` 时，不是从循环中跳出，而是调用 `token.ThrowIfCancellationRequested`。这将在
    `Task` 中抛出异常。`CancelWithPolling` 方法将需要围绕 `Task.Run` 调用添加 `try`/`catch` 块。无论如何，使用异常处理来处理所有多线程代码都是一个最佳实践。在这种情况下，你将有两个异常处理程序：一个用于处理
    `OperationCanceledException`，另一个用于处理 `AggregateException`。
- en: Additionally, the `CancelWithPolling` method has code to determine when the
    user presses the *X* key to cancel the operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`CancelWithPolling` 方法中还有代码来确定当用户按下 *X* 键取消操作时。
- en: 'Finally, open `Program.cs` and add some code to execute the sample:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开 `Program.cs` 并添加一些代码来执行示例：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now run the application, and examine the output:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序，并检查输出：
- en: '![Figure 11.4 – Running the cancellation polling example ](img/Figure_11.4_B18852.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 运行取消轮询示例](img/Figure_11.4_B18852.jpg)'
- en: Figure 11.4 – Running the cancellation polling example
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 运行取消轮询示例
- en: Depending on how long you wait before canceling, you might have a different
    number of points found by the process.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你取消等待的时间长度，你可能会找到不同数量的点。
- en: In the next section, we will learn how you can register a callback method to
    handle cancellation requests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何注册一个回调方法来处理取消请求。
- en: Canceling with callbacks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调取消
- en: 'Some code in .NET supports the registration of a callback method to cancel
    processing. One class that supports cancellation with callbacks is `System.Net.WebClient`.
    In this example, we will use `WebClient` to start downloading a file. The download
    will be canceled after three seconds. To ensure the file download is large enough
    that it has not been completed after three seconds, we will download a large lossless
    audiobook file from **Internet Archive** (https://archive.org/). We will download
    the first part of the audiobook of *The Odyssey* by Homer. This file is 471.1
    MB. You can view all of the free downloads for this book at https://archive.org/details/lp_the-odyssey_homer-anthony-quayle.
    Perform the following steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 .NET 代码支持注册一个回调方法来取消处理。支持使用回调进行取消的一个类是 `System.Net.WebClient`。在这个例子中，我们将使用
    `WebClient` 来开始下载一个文件。下载将在三秒后取消。为了确保文件下载足够大，在三个秒后尚未完成，我们将从 **Internet Archive**
    (https://archive.org/) 下载一个大型无损有声书文件。我们将下载荷马史诗《奥德赛》的第一部分。此文件大小为 471.1 MB。你可以在
    https://archive.org/details/lp_the-odyssey_homer-anthony-quayle 查看这本书的所有免费下载。执行以下步骤：
- en: Open the `CallbackExample`
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CallbackExample`
- en: 'Start by adding a method named `GetDownloadFileName` to build the path where
    the file will be downloaded. We will download it to the same folder where our
    assembly is executing:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为 `GetDownloadFileName` 的方法来构建文件下载的路径。我们将将其下载到我们的程序集执行的同一文件夹中：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, add an `async` method named `DownloadAudioAsync`. This method will handle
    the file download and cancellation. There are several exception handlers to catch
    any type of exception that the `DownloadFileTaskAsync` method might throw. In
    turn, all of them throw an `OperationCanceledException` type to be handled by
    the parent method:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `DownloadAudioAsync` 的 `async` 方法。此方法将处理文件下载和取消操作。有几个异常处理程序来捕获 `DownloadFileTaskAsync`
    方法可能抛出的任何类型的异常。反过来，它们都会抛出一个 `OperationCanceledException` 类型的异常，由父方法处理：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a `using` statement for the `WebClient` type:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `WebClient` 类型添加一个 `using` 语句：
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now add a public `async` method named `CancelWithCallback`. This method calls
    `DownloadAudioAsync`, waits for three seconds, and calls `Cancel` on the `CancellationTokenSource`
    object. Awaiting the task in a `try` block means we can handle the `OperationCanceledException`
    type directly. If you used `task.Wait` instead, you would have to catch `AggregateException`
    and check whether one of the `InnerException` objects is an `OperationCanceledException`
    type:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个名为 `CancelWithCallback` 的公共 `async` 方法。此方法调用 `DownloadAudioAsync`，等待三秒钟，然后在
    `CancellationTokenSource` 对象上调用 `Cancel`。在 `try` 块中等待任务意味着我们可以直接处理 `OperationCanceledException`
    类型。如果你使用了 `task.Wait`，你将不得不捕获 `AggregateException` 并检查是否有一个 `InnerException` 对象是
    `OperationCanceledException` 类型：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this step, it might be necessary to adjust the number of seconds in the `tokenSource.Token.WaitHandle.WaitOne`
    call. The timing can vary based on your computer’s download speed and processing
    speed. Try adjusting the value if you do not see a `Download canceled` message
    in the console output.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，可能需要调整 `tokenSource.Token.WaitHandle.WaitOne` 调用中的秒数。时间可能会根据你的计算机的下载速度和处理速度而变化。如果你在控制台输出中没有看到
    `Download canceled` 消息，请尝试调整此值。
- en: 'Finally, comment out the existing code in `Program.cs`, and add the following
    code to call the `CallbackExample` class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，注释掉 `Program.cs` 中的现有代码，并添加以下代码来调用 `CallbackExample` 类：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now run the application, and examine the output:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序，并检查输出：
- en: '![Figure 11.5 – Canceling a download with CancellationToken and a callback
    ](img/Figure_11.5_B18852.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 使用 CancellationToken 和回调取消下载](img/Figure_11.5_B18852.jpg)'
- en: Figure 11.5 – Canceling a download with CancellationToken and a callback
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 使用 CancellationToken 和回调取消下载
- en: You can verify that the download started and did not complete by looking in
    the folder where your assembly was running. You should see a file named **audio.flac**
    with a file size of **0 KB**. You can safely delete this file as it could cause
    exceptions if you try to download it again.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看你的程序集运行所在的文件夹来验证下载已经开始但未完成。你应该会看到一个名为 **audio.flac** 的文件，文件大小为 **0 KB**。你可以安全地删除此文件，因为它如果在尝试再次下载时可能会引发异常。
- en: Now that we have seen how to cancel a background task with a callback method,
    let’s wrap up this section by working through an example with wait handles.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用回调方法取消后台任务，让我们通过一个使用等待句柄的例子来结束本节。
- en: Canceling with wait handles
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用等待句柄取消操作
- en: In this section, we will use `ManualResetEventSlim` to cancel a background task
    that would not otherwise be responsive to user input. This object has `Set` and
    `Reset` events to start/resume or pause an operation. When operations have not
    yet started or have been paused, calling `ManualResetEventSlim.Wait` will cause
    the operation to pause on that statement until another thread calls `Set` to start
    or resume processing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `ManualResetEventSlim` 来取消一个原本不会对用户输入做出响应的后台任务。此对象有 `Set` 和 `Reset`
    事件来启动/恢复或暂停操作。当操作尚未开始或已暂停时，调用 `ManualResetEventSlim.Wait` 将导致操作在该语句上暂停，直到另一个线程调用
    `Set` 以启动或恢复处理。
- en: 'This example will iterate over 100,000 integers and output to the console for
    each even number. This process can be started, paused, resumed, or canceled thanks
    to the `ManualResetEventSlim` object and `CancellationToken`. Let’s try this example
    in our project:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将遍历 100,000 个整数，并将每个偶数输出到控制台。由于 `ManualResetEventSlim` 对象和 `CancellationToken`
    的存在，此过程可以启动、暂停、恢复或取消。让我们在我们的项目中尝试此示例：
- en: Start by adding a `WaitHandleExample` class to the **CancellationPatterns**
    project.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先向 **CancellationPatterns** 项目中添加一个名为 `WaitHandleExample` 的类。
- en: 'Add a private variable named `resetEvent` to the new class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类中添加一个名为 `resetEvent` 的私有变量：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a private static method named `ProcessNumbers` to the class. This method
    iterates over the numbers and only continues processing when `resetEvent.Wait`
    allows it to proceed:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个名为 `ProcessNumbers` 的私有静态方法。此方法遍历数字，并且只有在 `resetEvent.Wait` 允许它继续时才继续处理：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add a public static async method named `CancelWithResetEvent` to the
    class. This method creates the list of numbers to process, calls `ProcessNumbers`
    within a `Task.Run` call, and uses a `while` loop to listen for user input:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向类中添加一个名为 `CancelWithResetEvent` 的公共静态异步方法。此方法创建要处理的数字列表，在 `Task.Run` 调用中调用
    `ProcessNumbers`，并使用 `while` 循环来监听用户输入：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, update `Program.cs` to contain the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新 `Program.cs` 以包含以下代码：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the program to test it. Follow the console prompts to start, pause, resume,
    and cancel the process:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序进行测试。遵循控制台提示以启动、暂停、恢复和取消过程：
- en: '![Figure 11.6 – Testing the CancelWithResetEvent method in the console ](img/Figure_11.6_B18852.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 在控制台中测试 CancelWithResetEvent 方法](img/Figure_11.6_B18852.jpg)'
- en: Figure 11.6 – Testing the CancelWithResetEvent method in the console
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 在控制台中测试 CancelWithResetEvent 方法
- en: You should see in the console output that several event numbers have been found
    before the operation is canceled. The amount of processing completed could vary
    based on your computer’s processors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台输出中看到在操作取消之前已经找到了几个事件编号。完成处理的数量可能因你的计算机处理器而异。
- en: In the next section, we will wrap up cancellation by learning how to handle
    cancellation requests from multiple sources.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过学习如何处理来自多个来源的取消请求来总结取消。
- en: Handling multiple cancellation sources
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个取消来源
- en: Background tasks can leverage `CancellationTokenSource` to receive cancellation
    requests from as many sources as necessary. The static `CancellationTokenSource.CreateLinkedTokenSource`
    method accepts an array of `CancellationToken` objects to create a new `CancellationTokenSource`
    object that will notify us of cancellation if any of the source tokens receives
    a request to cancel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 后台任务可以利用 `CancellationTokenSource` 从所需的所有来源接收取消请求。静态 `CancellationTokenSource.CreateLinkedTokenSource`
    方法接受一个 `CancellationToken` 对象数组来创建一个新的 `CancellationTokenSource` 对象，如果任何源令牌收到取消请求，它将通知我们。
- en: 'Let’s look at a quick example of how to implement this in our **CancellationPatterns**
    project:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的 **CancellationPatterns** 项目中实现这个快速示例：
- en: 'First, open the `PollingExample` class. We are going to create an overload
    of the `CancelWithPolling` method that accepts a `CancellationTokenSource` parameter.
    The two overloads of `CancelWithPolling` will look like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `PollingExample` 类。我们将创建一个接受 `CancellationTokenSource` 参数的 `CancelWithPolling`
    方法的重载。`CancelWithPolling` 的两个重载将看起来像这样：
- en: '[PRE22]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, add a new class named `MultipleTokensExample`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `MultipleTokensExample` 的新类。
- en: 'Create a method named `CancelWithMultipleTokens` in the `MultipleTokensExample`
    class. This method accepts `parentToken` as a parameter, creates its own `tokenSource`,
    and then combines them into a `combinedSource` object to pass to the `CancelWithPolling`
    method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MultipleTokensExample` 类中创建一个名为 `CancelWithMultipleTokens` 的方法。此方法接受 `parentToken`
    作为参数，创建自己的 `tokenSource`，然后将它们组合成一个 `combinedSource` 对象以传递给 `CancelWithPolling`
    方法：
- en: '[PRE23]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’re calling `tokenSource.Cancel`, but if `Cancel` is invoked on any of the
    three `CancellationTokenSource` objects, the processing in `CancellWithPolling`
    will receive a cancellation request.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `tokenSource.Cancel`，但如果在三个 `CancellationTokenSource` 对象中的任何一个上调用 `Cancel`，`CancellWithPolling`
    中的处理将接收到一个取消请求。
- en: 'Add some code to `Program.cs` to call `CancelWithMultipleTokens`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加一些代码来调用 `CancelWithMultipleTokens`：
- en: '[PRE24]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the program, and you should see an output similar to what you saw in the
    subsection *Canceling with polling* of the section *Discovering patterns for thread
    cancellation*.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，你应该会看到一个类似于在 *发现线程取消模式* 部分的 *使用轮询取消* 子部分中看到的结果。
- en: Try changing which `CancellationTokenSource` object is used to invoke `Cancel`.
    The output should remain the same regardlesss of the source of the cancellation
    request.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改用于调用 `Cancel` 的 `CancellationTokenSource` 对象。无论取消请求的来源如何，输出都应该保持不变。
- en: A background `Task` will also end if you throw an exception within the `Task`.
    This has a similar effect of ending the background processing, but `TaskStatus`
    will be `Faulted` instead of `Canceled`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `Task` 中抛出异常，后台 `Task` 也会结束。这具有结束后台处理的效果，但 `TaskStatus` 将是 `Faulted` 而不是
    `Canceled`。
- en: This completes our review of cancellation requests from multiple sources and
    our tour of canceling tasks and threads with C# and .NET. Let’s review what we
    have learned in this chapter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对来自多个来源的取消请求的回顾，以及使用 C# 和 .NET 取消任务和线程的游览。让我们回顾一下本章学到的内容。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned a number of new ways to cancel background threads
    and tasks. It is important to provide your users with a method of canceling long-running
    tasks or automatically canceling them when users or the operating system closes
    or suspends your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了许多取消后台线程和任务的新方法。为用户提供一种取消长时间运行任务或当用户或操作系统关闭或挂起您的应用程序时自动取消它们的方法是很重要的。
- en: After working through the examples in this chapter, you now understand how to
    use polling, callbacks, and wait handles to cooperatively cancel background tasks.
    Additionally, you learned how to handle cancellation requests from more than one
    source.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章的示例后，你现在理解了如何使用轮询、回调和等待句柄来协同取消后台任务。此外，你还学习了如何处理来自多个来源的取消请求。
- en: In the next chapter, we will look at how .NET developers can unit test code
    that employs multithreaded constructs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨.NET开发者如何对使用多线程结构的代码进行单元测试。
- en: Questions
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which property of a `CancellationToken` object indicates whether a cancellation
    request has been made?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CancellationToken`对象的哪个属性指示是否已发出取消请求？'
- en: Which data type provides a `CancellationToken` object?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种数据类型提供了`CancellationToken`对象？
- en: What exception type is thrown when `ThrowIfCancellationRequested` is invoked?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`ThrowIfCancellationRequested`时，会抛出哪种异常类型？
- en: What cancellation pattern is used by the `WebClient` object in .NET?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中的`WebClient`对象使用了哪种取消模式？
- en: Which .NET type can pause or resume operations with a `CancellationToken` object?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种.NET类型可以使用`CancellationToken`对象暂停或恢复操作？
- en: Which reset event is used to pause processing?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个重置事件用于暂停处理？
- en: Which static method in `CancellationTokenSource` can combine multiple `CancellationToken`
    objects into a single source?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`中的哪个静态方法可以将多个`CancellationToken`对象组合成一个单一来源？'
