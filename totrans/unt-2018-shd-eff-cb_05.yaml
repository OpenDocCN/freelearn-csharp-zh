- en: Physically-Based Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Introduced in Unity 5, PBR is a shading model that seeks to render graphics
    in a way that acts in a similar manner to how light works in the real world. Previous
    chapters have repeatedly mentioned it without revealing too much about it. If
    you want to understand not only how PBR works, but how to make the most out of
    it, this is the chapter you should read. In this chapter, you will learn the following
    recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the metallic setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding transparency to PBR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating mirrors and reflective surfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baking lights in your scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the lighting models encountered in [Chapter 4](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, were very primitive descriptions of how light
    behaves. The most important aspect during their making was *efficiency*. Real-time
    shading is expensive, and techniques such as Lambertian or BlinnPhong are a compromise
    between computational cost and realism.
  prefs: []
  type: TYPE_NORMAL
- en: Having a more powerful GPU has allowed us to write progressively more sophisticated
    lighting models and rendering engines, with the aim of simulating how light actually
    behaves. This is, in a nutshell, the philosophy behind PBR. As the name suggests,
    it tries to get as close as possible to the physics behind the processes that
    give a unique look at each material. Despite this, the term PBR has been widely
    used in marketing campaigns and is more of a synonym for **state-of-the-art rendering**
    rather than a well-defined technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity implements PBR in two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is a completely new lighting model (called Standard). Surface Shaders
    allow developers to specify the physical properties of a material, but they do
    not impose actual physical constraints on them. PBR fills this by gap using a
    lighting model that enforces principles of physics such as **energy conservation**
    (an object cannot reflect more light than the amount it receives), **microsurface
    scattering** (rough surfaces reflect light more erratically compared to smooth
    ones), **Fresnel reflectance** (specular reflections appear at grazing angles),
    and **surface occlusion** (the darkening of corners and other geometries that
    are hard to light). All these aspects, and many others, are used to calculate
    the standard lighting model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second aspect that makes PBR so realistic is called **Global Illumination**
    (**GI**) and is the simulation of physically-based light transport. It means that
    objects are not drawn in the scene as if they were separate entities. They all
    contribute to the final rendering as light can reflect on them before hitting
    something else. This aspect is not captured in the shaders themselves, but is
    an essential part of how the rendering engine works. Unfortunately, accurately
    simulating how light rays actually bounce over surfaces in real time is beyond
    the capabilities of modern GPUs. Unity makes some clever optimizations that allow
    us to retain visual fidelity without sacrificing performance. Some of the most
    advanced techniques (such as reflections), however, require user input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these aspects will be covered in this chapter. It is important to remember
    that PBR and GI do not automatically guarantee that your game will be photorealistic.
    Achieving photorealism is a very challenging task and, like every art, it requires
    great expertise and exceptional skills.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the metallic setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides three different types of PBR shaders; they are referred to in
    the drop-down menu of the material's Inspector tab as Standard, Standard (Roughness
    Setup), and Standard (Specular setup). The main difference is that Standard and
    Standard (Roughness Setup) expose the Metallic property, but Standard contains
    a Smoothness property while the second replaces Smoothness with Roughness**.** Standard
    (Specular setup) contains Smoothness, but replaces the Metallic property with Specular.
    Smoothness and Roughness are opposites of each other, so a `1` Smoothness means `0`
    Roughness and vice versa. You can generally get the same result no matter which
    shader you use, so it mostly comes down to personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'These setups represent different ways in which you can initialize PBR materials.
    One of the concepts that has driven PBR is the ability to provide meaningful,
    physically-related properties that artists and developers can tweak and play with.
    The properties of some materials are easier to represent, indicating how *metallic*
    they are. For others, it is more important to specify how they reflect lights
    directly through its **specularity**. This recipe will show you how to use the
    **metallic** **setup** effectively. It''s important to remember that the metallic
    workflow is not just for metallic materials; it is a way of defining how materials
    will look according to how metallic or non-metallic their surface is. Despite
    being presented as two different types of shaders, both Metallic and Specular
    setups are generally equally expressive. As shown in the Unity documentation at
    [http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html](http://docs.unity3d.com/Manual/StandardShaderMetallicVsSpecular.html) and
    mentioned earlier, the same materials can usually be recreated with both setups
    (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will use the Standard Shader, so there is no need to create a new
    one. The steps to start the recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material (`MetallicMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From its Inspector, make sure that Standard is selected from its Shader drop-down
    menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will also need a textured 3D model. Our basic character we''ve been using
    previously will work perfectly. Drag and drop it into the scene. Afterward, drag
    and drop the `MetallicMat` material onto each of the parts of the character. Also,
    assign the texture for the material to the Albedo property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main textures that need to be configured in the Standard Shader:
    Albedo and Metallic. To use the metallic workflow effectively, we need to initialize
    these maps correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: The Albedo map should be initialized with the unlit texture of the 3D model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create the Metallic map, start by duplicating the file for your Albedo map.
    You can do this by selecting the map from the Project tab and pressing *Ctrl + D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use white (`#ffffff`) to color the regions of the map that correspond to materials
    that are made of pure metal. Use black (`#000000`) for all the other colors. Shades
    of grey should be used for dusty, weathered, or worn-out metal surfaces, rust,
    scratched paint, and so on. As a matter of fact, Unity uses only the red channel
    to store the metallic value; the green and blue ones are ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the alpha channel of the image to provide information about the Smoothness
    of the material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example of a Metallic map opened in Photoshop
  prefs: []
  type: TYPE_NORMAL
- en: 'For our simple character, the belt and the little ends of the hoodie are the
    only parts we need to be metallic. I''ve also made the opacity around 55% for
    the main character, with the belt having a higher opacity of 80%:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the Metallic map to the material. The Metallic slider will disappear
    as these two properties are now controlled by the map. You may use the Smoothness
    slider to provide a modifier on the map you''ve provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metals are known for the conducting of electricity; light is in the form of
    electromagnetic waves, meaning that almost all metals behave in a similar way
    compared to non-conductors (often referred as **insulators**). Conductors tend
    to reflect most photons (70-100%), resulting in high reflectance. The remaining
    light is absorbed, rather than diffused, suggesting that conductors have a very
    dark diffuse component. Insulators, conversely, have a low reflectance (4%); the
    rest of the light is scattered on the surface, contributing to their diffused
    looks.
  prefs: []
  type: TYPE_NORMAL
- en: In the Standard Shader, purely metallic materials have dark diffuse components,
    and the color of their specular reflections is determined by the Albedo map. Conversely,
    the diffuse component of purely non-metallic materials is determined by the Albedo
    map; the color of their specular highlights is determined by the color of the
    incoming light. Following these principles allows the metallic workflow to combine
    the Albedo and specular into the Albedo map, enforcing physically-accurate behaviors.
    This also allows for saving more space, resulting in a significant speed increase
    at the expenses of reduced control over the look of your materials.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the metallic setup, you can refer to these links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calibration chart**: How to calibrate a metallic material ([http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png](http://blogs.unity3d.com/wp-content/uploads/2014/11/UnityMetallicChart.png))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Material chart**: How to initialize the Standard Shader parameters for common
    materials ([http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html](http://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quixel MEGASCANS**: A vast library of materials, including textures and PBR
    parameters ([https://megascans.se/](https://megascans.se/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PBR Texture Conversion**: How traditional shaders can be converted to PBR
    shaders ([http://www.marmoset.co/toolbag/learn/pbr-conversion](http://www.marmoset.co/toolbag/learn/pbr-conversion))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Substance Designer**: A node-based software to work with PBR ([https://www.allegorithmic.com/products/substance-designer](https://www.allegorithmic.com/products/substance-designer))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Theory of** **Physically-Based Rendering**: A complete guide about PBR
    ([https://www.allegorithmic.com/pbr-guide](https://www.allegorithmic.com/pbr-guide))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding transparency to PBR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transparency is such an important aspect in games that the Standard Shader supports
    three different ways of doing it. This recipe is useful if you need to have realistic
    materials with transparent or semi-transparent properties. Glasses, bottles, windows,
    and crystals are good candidates for PBR transparent shaders. This is because
    you can still have all the realism introduced by PBR with the addition of a transparent
    or translucent effect. If you need transparency for something different, such
    as UI elements or pixel art, there are more efficient alternatives that are explored
    in the *Creating a transparent material* recipe in [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08),
    *Surface Shaders and Texture Mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have a transparent standard material, changing the alpha channel
    of its Albedo color property is not enough. Unless you properly set its Rendering
    Mode, your material will not appear transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will use the Standard Shader, so there is no need to create a new
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material (`TransparencyMat`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the Shader property is set to either Standard or Standard (Specular
    setup) from the material's Inspector tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the newly created material to the 3D object that you want to be transparent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Shader provides three different types of transparencies. Despite
    being very similar, they have subtle differences and fit in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Semi-transparent materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some materials such as clear plastics, crystal, and glass are semi-transparent.
    This means that they both require all the realistic effects of PBR (such as specular
    highlights and Fresnel refraction and reflection), but allow the geometry behind an
    object with the material attached to be seen. If this is what you need, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the material's Inspector tab, set Rendering Mode to Transparent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The amount of transparency is determined by the alpha channel of the Albedo
    color or the Albedo map (if any). If you click on the box to the right of the
    Albedo section, you''ll bring up a Color menu. Adjusting the A channel will make
    the item more visible or less visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting the A channel to `44` provides the following effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the Unity calibration scene with four different
    highly polished plastic spheres. From left to right, their transparency is increasing.
    The last sphere is fully transparent, but retains all the added effects of PBR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Unity Calibration Scene can be downloaded for free from the Asset Store
    at [https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422).
  prefs: []
  type: TYPE_NORMAL
- en: The Transparent rendering mode is perfect for windows, bottles, gems, and headsets.
  prefs: []
  type: TYPE_NORMAL
- en: You should notice that many transparent materials don't usually project shadows.
    On top of this, the Metallic and Smoothness properties of a material can interfere
    with the transparency effect. A mirror-like surface can have the alpha set to
    zero, but if it reflects all the incoming light, it won't appear transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Fading objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you want an object to fully disappear with a fading effect. In this
    case, specular reflections and Fresnel refraction and reflection should disappear
    as well. When a fading object is fully transparent, it should also be invisible.
    To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the material's Inspector tab, set Rendering Mode to Fade.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As before, use the alpha channel of the Albedo color or map to determine the
    final transparency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows four fading spheres. It is clear from the screenshot
    that the PBR effects fade with the sphere as well. As you can see in the following
    image, the last one on the right is almost invisible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This rendering mode works best for non-realistic objects, such as holograms,
    laser rays, faux lights, ghosts, and particle effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solid geometries with holes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the materials encountered in a game are solid, meaning that they don''t
    allow light to pass through them. At the same time, many objects have a very complex
    (yet flat) geometry. Modeling leaves and grass with 3D objects is often overkilled.
    A more efficient approach is to use a quad (rectangle) with a leaf texture. While
    the leaf itself is solid, the rest of the texture should be fully transparent.
    If this is what you want, then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the material's Inspector tab, set Rendering Mode to Cutout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Alpha Cutoff slider to determine the cutoff threshold. All the pixels
    in the Albedo map with an alpha value equal to or less than Alpha Cutoff will
    be hidden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following image, taken from the *Unity Official Tutorials* on PBR ([https://www.youtube.com/watch?v=fD_ho_ofY6A](https://www.youtube.com/watch?v=fD_ho_ofY6A)),
    shows you how the effect of the Cutout rendering mode can be used to create a
    hole in the geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's worth noticing that Cutout does not allow the back of the geometry to be
    seen. In the previous example, you could not see the inner volume of the sphere.
    If you require such an effect, you need to create your own shader and make sure
    that the back geometry is not culled.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, some of the examples in this recipe have been created
    using the Unity Shader Calibration Scene, which is freely available in the Asset
    Store at [https://www.assetstore.unity3d.com/en/#!/content/25422](https://www.assetstore.unity3d.com/en/#!/content/25422).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Albedo and Transparency can be found at
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html](http://docs.unity3d.com/Manual/StandardShaderMaterialParameterAlbedoColor.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating mirrors and reflective surfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specular materials reflect lights when objects are viewed from certain angles.
    Unfortunately, even the Fresnel reflection, which is one of the most accurate
    models, does not correctly reflect lights from nearby objects. The lighting models
    examined in the previous chapters took into account only light sources, but ignored
    light that is reflected from other surfaces. With what you've learned about shaders
    so far, making a mirror is simply not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Global illumination makes this possible by providing PBR shaders with information
    about their surroundings. This allows objects to have not just specular highlights,
    but also real reflections, which depend on the other objects around them. Real-time
    reflections are very costly and require manual setting up and tweaking in order
    to work. When done properly, they can be used to create mirror-like surfaces,
    as seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe will not feature any new shader. Quite the opposite; most of the
    work is done directly in the editor. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a quad (GameObject | 3D Object | Quad), which will serve as a mirror.
    I've rotated it to -65 in the Y axis to make it easy to see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material (`MirrorMat`) and attach it to the mirror.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the quad in a scene with other objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new reflection probe from GameObject | Light | Reflection Probe and
    place it in front of the quad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the preceding steps have been followed correctly, you should have a quad
    in the middle of your scene, close to a reflection probe. In order to make it
    in a mirror, some changes need to be made:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the shader of the material to Standard and its Rendering Mode to Opaque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change its Metallic and Smoothness properties to one. You should see the material
    reflecting the sky more clearly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the reflection probe and change its Size and Probe Origin until it is
    in front of the quad and it encloses all the objects that you want to reflect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make the item more clear under the Cubemap capture settings, change the Resolution
    to `2048`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, change its Type to Realtime and the Refresh Mode to Every frame. Also,
    make sure that Culling Mask is set to Everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your reflection probe should be configured, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using these settings, you should see something similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You may notice that the bunny seems larger in the reflection rather than what's
    beside it. If your probe is used for a real mirror, you should check the Box Projection
    flag (in this example, setting the box size to `1`, `1`, `1` does a pretty good
    job of looking like a mirror). If it is used for other reflective surfaces, such
    as shiny pieces of metal or glass tables, you can uncheck it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a shader wants information about its surroundings, it is usually provided
    in a structure called **cube** **maps**. They have been briefly mentioned in [Chapter
    2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating Your First
    Shader*, as one of the shader property types, among `Color`, `2D`, `Float`, and
    `Vector`. Loosely speaking, cube maps are the 3D equivalent of 2D textures; they
    represent a 360-degree view of the world, as seen from a center point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity previews cube maps with a spherical projection, as seen in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When cube maps are attached with a camera, they are referred to as **skyboxes**,
    as they are used to provide a way to reflect the sky. They can be used to reflect
    geometries that are not in the actual scene, such as nebulae, clouds, and stars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why they are called cube maps is because of the way they are created:
    a cube map is made up of six different textures, each one attached to the face
    of a cube. You can create a cube map manually or delegate it to a **reflection
    probe**. You can imagine a reflection probe as a collection of six cameras, creating
    a 360-degree mapping of the surrounding area. This also gives you an idea as to
    why probes are so expensive. By creating one in our scene, we allow Unity to know
    which objects are around the mirror. If you need more reflective surfaces, you
    can add multiple probes. You need no further action for the reflection probes
    to work. The Standard Shaders will use them automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: You should notice that when they are set to Realtime, they render their cube
    map at the beginning of every frame. There is a trick to make this faster; if
    you know that part of the geometry that you want to reflect does not move, you
    can bake the reflection. This means that Unity can calculate the reflection before
    starting the game, allowing more precise (and computationally expensive) calculations.
    In order to do this, your reflection probe must be set to Baked and will work
    only for objects that are flagged as Static. Static objects cannot move or change,
    which makes them perfect for terrain, buildings, and props. Every time a static
    object is moved, Unity will regenerate the cube maps for its baked reflection
    probes. This might take a few minutes to several hours.
  prefs: []
  type: TYPE_NORMAL
- en: You can mix Realtime and Baked probes to increase the realism of your game.
    Baked probes will provide very high-quality reflections, environmental reflections,
    while the real-time ones can be used to move objects such as cars or mirrors.
    The *Baking lights in your scene* section will explain in detail how light baking
    works.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are interested in learning more about reflection probes, you should
    check these links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity manual about the Reflection Probe: [http://docs.unity3d.com/Manual/class-ReflectionProbe.html](http://docs.unity3d.com/Manual/class-ReflectionProbe.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box projection and other advanced Reflection Probe settings: [https://docs.unity3d.com/Manual/AdvancedRefProbe.html](https://docs.unity3d.com/Manual/AdvancedRefProbe.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baking lights in your scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering lighting is a very expensive process. Even with state-of-the-art GPUs,
    accurately calculating the **light transport** (which is how light bounces between
    surfaces) can take hours. In order to make this process feasible for games, real-time
    rendering is essential. Modern engines compromise between realism and efficiency;
    most of the computation is done beforehand in a process called **light baking**.
    This recipe will explain how light baking works and how you can get the most out
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Light baking requires you to have a scene ready. It should have geometries and,
    obviously, lights. For this recipe, we will rely on Unity's standard features
    so there is no need to create additional shaders or materials. We will be reusing
    the map that we used previously in [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08), *Post
    Processing Stack*. For better control, you might want to access the Lighting window.
    If you don't see it, select Window | Lighting | Settings from the menu and dock
    it where it is more convenient for you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Light baking requires some manual configuration. There are three essential,
    yet independent, steps that you need to take.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the static geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These steps must be followed for the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify all the objects in your scene that do not change position, size, and
    material. Possible candidates are buildings, walls, terrain, props, trees, and
    others. In our case, it will be all of the objects aside from the `FPSController`
    and its children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select these objects and check the Static box from the Inspector tab, as shown
    in the following screenshot. If any of the selected objects have children, Unity
    will ask if you want them to be considered static as well. If they meet the requirements
    (fixed position, size, and material), select Yes, change children in the pop-up
    box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If a light qualifies as a static object but illuminates non-static geometry,
    make sure that its Baking property is set to Mixed. If it will affect only static
    objects, set it to Baked.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the light probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are objects in your game that will move, such as the main character,
    enemies, and the other **non-playable characters** (**NPCs**). If they enter a
    static region that is illuminated, you might want to surround it with light probes.
    To do this, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, navigate to GameObject | Light | Light Probe Group. A new object
    called Light Probe Group will appear in Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once selected, eight interconnected spheres will appear. Click and move them
    around the scene so that they enclose the static region in which your characters
    can enter. The following screenshot shows an example of how light probes can be
    used to enclose the volume of a static office space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our example, it would just be the center area the player is able to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select the moving objects that will enter the light probe region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From their Inspector, expand their **renderer component** (usually Mesh Renderer)
    and make sure that Light Probes is not set to Off checked (see the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Deciding where and when to use light probes is a critical problem; more information
    about this can be found in the *How it works... *section for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Baking the lights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To bake the lights, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, select the lights you''d like to bake. Confirm from the Inspector tab
    that the Mode is set to Baked in the Light component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To finally bake the lights, open the Lighting window by going to Window | Lighting
    | Settings. Once there, select the Global Maps tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Auto Generate checkbox is enabled, Unity will automatically execute the
    baking process in the background. If not, click on Generate Lighting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Light baking can take several hours even for a relatively small scene. If you
    are constantly moving static objects or lights, Unity will restart the process
    from scratch, causing a severe slowdown in the editor. You can uncheck the Auto checkbox
    from the Lighting | Lightmaps | Settings tab to prevent this so that you can decide
    when to start the process manually.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most complicated part of rendering is the light transport. During this phase,
    the GPU calculates how the rays of light bounce between objects. If an object
    and its lights don't move, this calculation can be done only once as it will never
    change during the game. Flagging an object as Static is how to tell Unity that
    such an optimization can be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loosely speaking, light baking refers to the process of calculating the global
    illumination of a static object and saving it in what is called a **lightmap**.
    Once baking is completed, lightmaps can be seen in the Global Maps tab of the
    Lighting window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Light baking comes at a great expense: memory. Every static surface is, in
    fact, retextured so that it already includes its lighting condition. Let''s imagine
    that you have a forest of trees, all sharing the same texture. Once they are made
    static, each tree will have its very own texture. Light baking not only increases
    the size of your game, but can take a lot of texture memory if used indiscriminately.'
  prefs: []
  type: TYPE_NORMAL
- en: The second aspect introduced in this recipe is **light probing**. Light baking
    produces extremely high-quality results for static geometries, but does not work
    on moving objects. If your character is entering a static region, it can look
    somehow *detached* from the environment. Its shading will not match the surroundings,
    resulting in an aesthetically unpleasant result. Other objects, such as **skinned
    mesh renderers**, will not receive global illumination even if made static. Baking
    lights in real-time is not possible, although light probes offer an effective
    alternative. Every light probe samples the global illumination at a specific point
    in space. A light probe group can sample several points in space, allowing the
    interpolation of global illumination within a specific volume. This allows us
    to cast a better light on moving objects, even despite the fact that global illumination
    has been calculated only for a few points. It is important to remember that light
    probes need to enclose a volume in order to work. It is best to place light probes
    in regions where there is a sudden change in light conditions. Similar to lightmaps,
    probes consume memory and should be placed wisely; remember that they exist only
    for non-static geometry. Since there are no visible objects in the demoscene,
    this was done purely for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Even while using light probes, there are a few aspects that Unity's global illumination
    cannot capture. Non-static objects, for instance, cannot reflect light on other
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can read more about light probes at [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html).
  prefs: []
  type: TYPE_NORMAL
