<html><head></head><body>
<div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.2.1">Dictionaries and Sets</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter focuses on data structures related to dictionaries and sets. </span><span class="koboSpan" id="kobo.3.2">Applying these data structures makes it possible </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">to map keys to values and perform fast lookup</span></strong><span class="koboSpan" id="kobo.5.1">, as well as </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">to make various operations on sets</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">To simplify your understanding of dictionaries and sets, this chapter contains illustrations and code snippets, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">detailed descriptions.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">First, you will learn about both non-generic and generic versions of a </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">dictionary</span></strong><span class="koboSpan" id="kobo.11.1">, which is a collection of pairs, each consisting of a key and a value. </span><span class="koboSpan" id="kobo.11.2">Then, a </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">sorted variant</span></strong><span class="koboSpan" id="kobo.13.1"> of a dictionary will be presented. </span><span class="koboSpan" id="kobo.13.2">The remaining part of this chapter will show you how to use </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">hash sets</span></strong><span class="koboSpan" id="kobo.15.1">, together with a </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">“sorted” set</span></strong><span class="koboSpan" id="kobo.17.1"> variant. </span><span class="koboSpan" id="kobo.17.2">Is it possible to have a “sorted” set? </span><span class="koboSpan" id="kobo.17.3">You’ll learn more later in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">In this chapter, the following topics will </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">be covered:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Hash tables</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Dictionaries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Sorted dictionaries</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Hash sets</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">“</span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">Sorted” sets</span></span><a id="_idTextAnchor197"/></li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.27.1">Hash tables</span></h1>
<p><span class="koboSpan" id="kobo.28.1">Let’s start with the first</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.29.1"> data structure, which is a </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">hash table</span></strong><span class="koboSpan" id="kobo.31.1">, also known as </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.32.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">hash map</span></strong><span class="koboSpan" id="kobo.34.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">It allows you to </span></strong><strong class="bold"><span class="koboSpan" id="kobo.36.1">map</span></strong><strong class="bold"><span class="koboSpan" id="kobo.37.1"> keys to particular values</span></strong><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">One of the most important assumptions of the hash table is the possibility of </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">a very fast lookup for a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.40.1">value</span></strong><strong class="bold"><span class="koboSpan" id="kobo.41.1"> based on the </span></strong><strong class="bold"><span class="koboSpan" id="kobo.42.1">key</span></strong><span class="koboSpan" id="kobo.43.1">, which should be the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">O(1)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1"> operation.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.46.1">Imagine a hash table or a dictionary</span></p>
<p class="callout"><span class="koboSpan" id="kobo.47.1">If you want to better imagine a hash table or a dictionary, it would be worth thinking about a collection containing a lot of data, where it is crucial to quickly check whether the dictionary contains a specific key, as well as quickly retrieve the value assigned to a given key. </span><span class="koboSpan" id="kobo.47.2">So, think about a system that allows you to determine which country a specific IP address comes from. </span><span class="koboSpan" id="kobo.47.3">As you know, there are many possible IP addresses, and your system must quickly obtain information from which country the user’s request comes to select the default language version of the application. </span><span class="koboSpan" id="kobo.47.4">This is how a hash table and dictionary work! </span><span class="koboSpan" id="kobo.47.5">You use an IP address as a key (for example, 50.50.50.50) and a country code as a value (for example, PL). </span><span class="koboSpan" id="kobo.47.6">Thus, you can quickly find out from which country the user came to you, without manually browsing the entire collection. </span><span class="koboSpan" id="kobo.47.7">I come to you from Poland, which I cordially invite you to visit! </span><span class="koboSpan" id="kobo.47.8">It contains mountains, sea, lakes, and cities with a rich history. </span><span class="koboSpan" id="kobo.47.9">All this is waiting here </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">for you!</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">To achieve a very fast lookup, a </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">hash function</span></strong><span class="koboSpan" id="kobo.51.1"> is used. </span><span class="koboSpan" id="kobo.51.2">It takes the key to generate an index of a bucket, where the </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.52.1">value can be found. </span><span class="koboSpan" id="kobo.52.2">For this reason, if you need to find a value of the key, you do not need to iterate through all the items in the collection since you can just use the hash</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.53.1"> function to easily locate a proper bucket and get the value. </span><span class="koboSpan" id="kobo.53.2">As you can see, the role of the hash function is critical and ideally, it should generate a unique result for all keys. </span><span class="koboSpan" id="kobo.53.3">However, the same result may be generated for different keys. </span><span class="koboSpan" id="kobo.53.4">Such a</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.54.1"> situation is called a </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">hash collision</span></strong><span class="koboSpan" id="kobo.56.1"> and should be </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">dealt with.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">A way of mapping keys to particular values is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 6.1 – Illustration of mapping keys to particular values" src="image/B18069_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 6.1 – Illustration of mapping keys to particular values</span></p>
<p><span class="koboSpan" id="kobo.62.1">Due to the great performance of hash tables, they are frequently used in many real-world applications, such as for </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">associative arrays</span></strong><span class="koboSpan" id="kobo.64.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">database indices</span></strong><span class="koboSpan" id="kobo.66.1">, and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.67.1">cache systems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">The topic of implementing hash tables from scratch seems to be quite difficult, especially when it comes to using the hash function, handling hash collisions, as well as assigning particular keys to buckets. </span><span class="koboSpan" id="kobo.69.2">Fortunately, a suitable implementation is available while developing </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.70.1">applications in the C# language, and its usage is </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">very simple.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.72.1">Non-generic and generic versions</span></p>
<p class="callout"><span class="koboSpan" id="kobo.73.1">There are two variants of the hash table-related </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.74.1">classes, namely non-generic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">Hashtable</span></strong><span class="koboSpan" id="kobo.76.1">) and generic (</span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">Dictionary</span></strong><span class="koboSpan" id="kobo.78.1">). </span><span class="koboSpan" id="kobo.78.2">The first will be described in this section, while the other </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.79.1">will be described in the following section. </span><span class="koboSpan" id="kobo.79.2">If you can use the strongly typed generic version, I strongly recommend </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">using it.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Let’s take a look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Hashtable</span></strong><span class="koboSpan" id="kobo.83.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">System.Collections</span></strong><span class="koboSpan" id="kobo.85.1"> namespace. </span><span class="koboSpan" id="kobo.85.2">As mentioned previously, it stores a collection of pairs, where each contains a key and a value. </span><span class="koboSpan" id="kobo.85.3">A pair is represented by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">DictionaryEntry</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Here’s some example code that uses the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Hashtable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
using System.Collections;
</span><strong class="bold"><span class="koboSpan" id="kobo.92.1">Hashtable</span></strong><span class="koboSpan" id="kobo.93.1"> hashtable = new()
{
    { "Key #1", "Value #1" },
    { "Key #2", "Value #2" }
};
hashtable.</span><strong class="bold"><span class="koboSpan" id="kobo.94.1">Add</span></strong><span class="koboSpan" id="kobo.95.1">("Key #3", "Value #3");
hashtable</span><strong class="bold"><span class="koboSpan" id="kobo.96.1">["Key #4"]</span></strong><span class="koboSpan" id="kobo.97.1"> = "Value #4";</span></pre> <p><span class="koboSpan" id="kobo.98.1">As shown here, you can add items to a hash table in a few ways, namely by specifying keys and values while creating a new instance (such as for </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Key #1</span></strong><span class="koboSpan" id="kobo.100.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Key #2</span></strong><span class="koboSpan" id="kobo.102.1">), by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Add</span></strong><span class="koboSpan" id="kobo.104.1"> method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Key #3</span></strong><span class="koboSpan" id="kobo.106.1">) or by using the indexer (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Key #4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">When you use the indexer to set a value for an already existing key, the value of this element is updated. </span><span class="koboSpan" id="kobo.109.2">A different behavior occurs while using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Add</span></strong><span class="koboSpan" id="kobo.111.1"> method because it throws an exception when an item with the same key already exists in the collection. </span><span class="koboSpan" id="kobo.111.2">You can handle this situation by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">try-catch</span></strong><span class="koboSpan" id="kobo.113.1"> statement, but there is a much better approach to check whether </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.114.1">such an entry already exists – using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.116.1"> method. </span><span class="koboSpan" id="kobo.116.2">This will be shown a </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">bit later.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">It is worth mentioning that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">null</span></strong><span class="koboSpan" id="kobo.120.1"> value is incorrect for the key of an element, but it is acceptable as a value of </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">an element.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">You can easily gain access to a particular element using the indexer. </span><span class="koboSpan" id="kobo.122.2">As the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Hashtable</span></strong><span class="koboSpan" id="kobo.124.1"> class is a non-generic variant of hash table-related classes, you need to cast the returned result to the proper type (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">string</span></strong><span class="koboSpan" id="kobo.126.1">), as </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
string value = </span><strong class="bold"><span class="koboSpan" id="kobo.129.1">(string)hashtable["Key #1"]!</span></strong><span class="koboSpan" id="kobo.130.1">;</span></pre> <p><span class="koboSpan" id="kobo.131.1">If you want to get all the entries from the hash table, you can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">foreach</span></strong><span class="koboSpan" id="kobo.133.1"> loop to iterate through all pairs stored in the collection, as </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">presented here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.135.1">foreach (DictionaryEntry entry in hashtable)</span></strong><span class="koboSpan" id="kobo.136.1">
{
    Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">entry.Key</span></strong><span class="koboSpan" id="kobo.138.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">entry.Value</span></strong><span class="koboSpan" id="kobo.140.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.141.1">The variable that’s used in the loop is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">DictionaryEntry</span></strong><span class="koboSpan" id="kobo.143.1"> type. </span><span class="koboSpan" id="kobo.143.2">Therefore, you can use its </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Key</span></strong><span class="koboSpan" id="kobo.145.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Value</span></strong><span class="koboSpan" id="kobo.147.1"> properties to access the key and the </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">value, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">Hashtable</span></strong><span class="koboSpan" id="kobo.151.1"> class is equipped with a few properties, such as those for getting the number of stored elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">Count</span></strong><span class="koboSpan" id="kobo.153.1">), as well as returning the collection of keys and values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Keys</span></strong><span class="koboSpan" id="kobo.155.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">Values</span></strong><span class="koboSpan" id="kobo.157.1">). </span><span class="koboSpan" id="kobo.157.2">You can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">following methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Add</span></strong><span class="koboSpan" id="kobo.160.1">, which adds a </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">new element</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Remove</span></strong><span class="koboSpan" id="kobo.163.1">, which removes </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">an element</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Clear</span></strong><span class="koboSpan" id="kobo.166.1">, which removes </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">all elements</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.169.1">, which checks whether the collection contains a </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">given key</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">ContainsValue</span></strong><span class="koboSpan" id="kobo.172.1">, which checks whether the collection contains a </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">given value</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.174.1">What about performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.175.1">A hash table is an efficient data structure. </span><span class="koboSpan" id="kobo.175.2">Retrieving a value by a key, checking whether the collection contains a given key, and removing an item by a key are the </span><em class="italic"><span class="koboSpan" id="kobo.176.1">O(1)</span></em><span class="koboSpan" id="kobo.177.1"> operations. </span><span class="koboSpan" id="kobo.177.2">As for addition, if the capacity does not need to be increased, it is the </span><em class="italic"><span class="koboSpan" id="kobo.178.1">O(1)</span></em><span class="koboSpan" id="kobo.179.1"> operation as well. </span><span class="koboSpan" id="kobo.179.2">Otherwise, it</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.180.1"> is the </span><em class="italic"><span class="koboSpan" id="kobo.181.1">O(n)</span></em><span class="koboSpan" id="kobo.182.1"> operation, where </span><em class="italic"><span class="koboSpan" id="kobo.183.1">n</span></em><span class="koboSpan" id="kobo.184.1"> is the number </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">of items.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">With this short introduction, let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">an example.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.188.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.189.1">You can find content regarding a hash table at </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable"><span class="koboSpan" id="kobo.190.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.hashtable</span></a><span class="koboSpan" id="kobo.191.1">. </span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.192.1">Example – phone book</span></h2>
<p><span class="koboSpan" id="kobo.193.1">As an example, let’s say you create an application for a phone book. </span><span class="koboSpan" id="kobo.193.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Hashtable</span></strong><span class="koboSpan" id="kobo.195.1"> class is used to store entries where</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.196.1"> the person’s name is a key and the phone number is a value, as </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.198.1">NAME ---&gt; PHONE</span></strong><span class="koboSpan" id="kobo.199.1">
Marcin -&gt; 101-202-303
John ---&gt; 202-303-404
Aline --&gt; 303-404-505</span></pre> <p><span class="koboSpan" id="kobo.200.1">This program demonstrates how to add elements to the collection, get the number of stored items, iterate through all of them, check whether an element with a given key exists, as well as how to get a value based on </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">the key.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">First, let’s create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Hashtable</span></strong><span class="koboSpan" id="kobo.204.1"> class, as well as initialize it with some entries, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
Hashtable phoneBook = new()
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">{ "Marcin", "101-202-303" },</span></strong><span class="koboSpan" id="kobo.208.1">
    { "John", "202-303-404" }
};
phoneBook</span><strong class="bold"><span class="koboSpan" id="kobo.209.1">["Aline"]</span></strong><span class="koboSpan" id="kobo.210.1"> = "303-404-505";</span></pre> <p><span class="koboSpan" id="kobo.211.1">You can check whether</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.212.1"> there are no elements in the collection using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Count</span></strong><span class="koboSpan" id="kobo.214.1"> property and comparing its value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">0</span></strong><span class="koboSpan" id="kobo.216.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
Console.WriteLine("Phone numbers:");
if (phoneBook.</span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Count</span></strong><span class="koboSpan" id="kobo.220.1"> == 0)
{
    Console.WriteLine("Empty list.");
}</span></pre> <p><span class="koboSpan" id="kobo.221.1">Then, you can iterate through all </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">the pairs:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.223.1">foreach</span></strong><span class="koboSpan" id="kobo.224.1"> (DictionaryEntry entry in phoneBook)
{
    Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.225.1">entry.Key</span></strong><span class="koboSpan" id="kobo.226.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.227.1">entry.Value</span></strong><span class="koboSpan" id="kobo.228.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.229.1">Finally, let’s see how we can check whether a specific key exists in the collection, as well as how to get its value. </span><span class="koboSpan" id="kobo.229.2">The first task can be accomplished just by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.231.1"> method, which returns a value indicating whether a suitable element exists (</span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">true</span></strong><span class="koboSpan" id="kobo.233.1">) or not (</span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">false</span></strong><span class="koboSpan" id="kobo.235.1">). </span><span class="koboSpan" id="kobo.235.2">To get a value, you can use the indexer. </span><span class="koboSpan" id="kobo.235.3">Please keep in mind that you must cast the returned value to a suitable type, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">string</span></strong><span class="koboSpan" id="kobo.237.1"> in this example. </span><span class="koboSpan" id="kobo.237.2">This requirement is caused by the non-generic version of the hash table-related class. </span><span class="koboSpan" id="kobo.237.3">This code is </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
Console.Write("\nSearch by name: ");
string name = Console.ReadLine() ?? </span><span class="koboSpan" id="kobo.239.2">string.Empty;
if (phoneBook.</span><strong class="bold"><span class="koboSpan" id="kobo.240.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.241.1">(name))
{
    string number = </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">(string)phoneBook[name]!</span></strong><span class="koboSpan" id="kobo.243.1">;
    Console.WriteLine($"Phone number: {number}");
}
else
{
    Console.WriteLine("Does not exist.");
}</span></pre> <p><span class="koboSpan" id="kobo.244.1">Your first program using the hash table is ready! </span><span class="koboSpan" id="kobo.244.2">After launching it, you should receive a result similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.246.1">
Phone numbers:
Marcin: 101-202-303
Aline: 303-404-505
John: 202-303-404
Search by name: Aline
Phone number: 303-404-505</span></pre> <p><span class="koboSpan" id="kobo.247.1">It is worth noting that</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.248.1"> the order of the pairs stored using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Hashtable</span></strong><span class="koboSpan" id="kobo.250.1"> class is not consistent with the order of their addition or keys. </span><span class="koboSpan" id="kobo.250.2">For this reason, if you need to present the sorted results, you need to sort the elements on your own or use another data structure, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.252.1">, which is described later in </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.254.1">Now, let’s take a look at one of the most common classes used while developing in C#, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Dictionary</span></strong><span class="koboSpan" id="kobo.256.1">, which is a generic version of hash </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">table-rela</span><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.258.1">t</span><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.259.1">ed classes.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.260.1">Dictionaries</span></h1>
<p><span class="koboSpan" id="kobo.261.1">In the previous section, you learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Hashtable</span></strong><span class="koboSpan" id="kobo.263.1"> class, a non-generic variant of the hash table-related classes. </span><span class="koboSpan" id="kobo.263.2">However, it has a significant limitation, because it does not allow you to specify a type of a </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.264.1">key and a value. </span><span class="koboSpan" id="kobo.264.2">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Key</span></strong><span class="koboSpan" id="kobo.266.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Value</span></strong><span class="koboSpan" id="kobo.268.1"> properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">DictionaryEntry</span></strong><span class="koboSpan" id="kobo.270.1"> class are of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">object</span></strong><span class="koboSpan" id="kobo.272.1"> type. </span><span class="koboSpan" id="kobo.272.2">Therefore, you need to perform boxing and unboxing operations, even if all the keys and values are of the same type. </span><span class="koboSpan" id="kobo.272.3">If you want to benefit from the </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">strongly typed variant</span></strong><span class="koboSpan" id="kobo.274.1">, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Dictionary</span></strong><span class="koboSpan" id="kobo.276.1"> generic class, which is the main subject of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">First of all, you should specify two types, namely a type of a key and a value, while creating an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Dictionary</span></strong><span class="koboSpan" id="kobo.280.1"> class. </span><span class="koboSpan" id="kobo.280.2">Moreover, it is possible to define the initial content of the dictionary using the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">following code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.282.1">Dictionary&lt;string, string&gt;</span></strong><span class="koboSpan" id="kobo.283.1"> dictionary = new()
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">{ "Key #1", "Value #1" }</span></strong><span class="koboSpan" id="kobo.285.1">,
    { "Key #2", "Value #2" }
};</span></pre> <p><span class="koboSpan" id="kobo.286.1">In the preceding code, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Dictionary</span></strong><span class="koboSpan" id="kobo.288.1"> class is created. </span><span class="koboSpan" id="kobo.288.2">It stores </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">string</span></strong><span class="koboSpan" id="kobo.290.1">-based keys and values. </span><span class="koboSpan" id="kobo.290.2">Here, two entries exist in the dictionary, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Key #1</span></strong><span class="koboSpan" id="kobo.292.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Key #2</span></strong><span class="koboSpan" id="kobo.294.1">. </span><span class="koboSpan" id="kobo.294.2">Their values are </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Value #1</span></strong><span class="koboSpan" id="kobo.296.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Value #2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Hashtable</span></strong><span class="koboSpan" id="kobo.301.1"> class, you can also use the indexer to get access to a particular element within the collection, as shown in the following line </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">of code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
string value = dictionary</span><strong class="bold"><span class="koboSpan" id="kobo.304.1">["Key #1"]</span></strong><span class="koboSpan" id="kobo.305.1">;</span></pre> <p><span class="koboSpan" id="kobo.306.1">It is worth noting that casting to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">string</span></strong><span class="koboSpan" id="kobo.308.1"> type is unnecessary because </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Dictionary</span></strong><span class="koboSpan" id="kobo.310.1"> is the strongly</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.311.1"> typed version of the hash table-related classes. </span><span class="koboSpan" id="kobo.311.2">Therefore, the returned value already has the proper type. </span><span class="koboSpan" id="kobo.311.3">If an element with the given key does not exist in the collection, </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">KeyNotFoundException</span></strong><span class="koboSpan" id="kobo.313.1"> is thrown. </span><span class="koboSpan" id="kobo.313.2">To avoid problems, you can either check whether the element exists (by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.315.1">) or use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">TryGetValue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">You can add a new element or update a value of the existing one using </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">the indexer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
dictionary</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">["Key #3"]</span></strong><span class="koboSpan" id="kobo.322.1"> = "Value #3";</span></pre> <p><span class="koboSpan" id="kobo.323.1">Similar to the non-generic variant, </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">key</span></strong><span class="koboSpan" id="kobo.325.1"> cannot be equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">null</span></strong><span class="koboSpan" id="kobo.327.1">, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">value</span></strong><span class="koboSpan" id="kobo.329.1"> can be if it is allowed by the type of values stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the collection.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.331.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.332.1">You can find content regarding a dictionary </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2"><span class="No-Break"><span class="koboSpan" id="kobo.334.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">Dictionary</span></strong><span class="koboSpan" id="kobo.338.1"> class is equipped with a </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">few properties:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Count</span></strong><span class="koboSpan" id="kobo.341.1">, which gets the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">stored elements</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">Keys</span></strong><span class="koboSpan" id="kobo.344.1">, which returns the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">of keys</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Values</span></strong><span class="koboSpan" id="kobo.347.1">, which returns the collection </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">of values</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.349.1">You can also use some </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">available methods:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">Add</span></strong><span class="koboSpan" id="kobo.352.1">, which adds a new element to </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">the dictionary</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Remove</span></strong><span class="koboSpan" id="kobo.355.1">, which removes an element from </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the dictionary</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">Clear</span></strong><span class="koboSpan" id="kobo.358.1">, which removes all the elements from </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">the dictionary</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.361.1">, which checks whether the dictionary contains </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">a key</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">ContainsValue</span></strong><span class="koboSpan" id="kobo.364.1">, which checks whether the dictionary contains a </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">given value</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.367.1">, which tries to get a value for a given key from </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">the dictionary</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.369.1">As you can see, many properties and methods are almost the same as in the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">Hashtable</span></strong><span class="koboSpan" id="kobo.371.1"> class. </span><span class="koboSpan" id="kobo.371.2">The </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.372.1">consistency of naming allows you to easily use various classes without the necessity of learning everything </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">from scratch.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.374.1">What about performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.375.1">You should remember that the performance of getting a value of an element (using an indexer or </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.377.1">), updating an existing one (using an indexer), and checking whether the given key exists in the dictionary (</span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.379.1">) approaches the </span><em class="italic"><span class="koboSpan" id="kobo.380.1">O(1)</span></em><span class="koboSpan" id="kobo.381.1"> operation. </span><span class="koboSpan" id="kobo.381.2">However, the process of checking whether the collection contains a given value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">ContainsValue</span></strong><span class="koboSpan" id="kobo.383.1">) is the </span><em class="italic"><span class="koboSpan" id="kobo.384.1">O(n)</span></em><span class="koboSpan" id="kobo.385.1"> operation and requires you to search the entire collection for the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">particular value.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">If you want to iterate through all pairs stored in the collection, you can use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">foreach</span></strong><span class="koboSpan" id="kobo.389.1"> loop. </span><span class="koboSpan" id="kobo.389.2">However, the variable that’s used in the loop is an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">KeyValuePair</span></strong><span class="koboSpan" id="kobo.391.1"> generic class with </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">Key</span></strong><span class="koboSpan" id="kobo.393.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Value</span></strong><span class="koboSpan" id="kobo.395.1"> properties, allowing you to access the key and the value. </span><span class="koboSpan" id="kobo.395.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">foreach</span></strong><span class="koboSpan" id="kobo.397.1"> loop is shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">code snippet:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.399.1">foreach</span></strong><span class="koboSpan" id="kobo.400.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.401.1">KeyValuePair&lt;string, string&gt; pair</span></strong><span class="koboSpan" id="kobo.402.1"> in dictionary)
{
    Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.403.1">pair.Key</span></strong><span class="koboSpan" id="kobo.404.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.405.1">pair.Value</span></strong><span class="koboSpan" id="kobo.406.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.407.1">Here, you can also apply what you’ve learned about value tuples and the deconstruct operation. </span><span class="koboSpan" id="kobo.407.2">Thus, the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">foreach</span></strong><span class="koboSpan" id="kobo.409.1"> loop can be simplified, as </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
foreach (</span><strong class="bold"><span class="koboSpan" id="kobo.412.1">(string k, string v)</span></strong><span class="koboSpan" id="kobo.413.1"> in dictionary)
{
    Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.414.1">k</span></strong><span class="koboSpan" id="kobo.415.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.416.1">v</span></strong><span class="koboSpan" id="kobo.417.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.418.1">As you can see, the C# language is being equipped with more and more useful features that make your code shorter, simpler, and </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.419.1">easier to understand. </span><span class="koboSpan" id="kobo.419.2">You should keep an eye on the updates to the language. </span><span class="koboSpan" id="kobo.419.3">Good work, C# team – I am looking forward </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">to more!</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">Thread-safe version</span></p>
<p class="callout"><span class="koboSpan" id="kobo.422.1">Do you remember a thread-safe queue-related class from the previous chapter? </span><span class="koboSpan" id="kobo.422.2">If so, the situation looks quite similar in the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Dictionary</span></strong><span class="koboSpan" id="kobo.424.1"> because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ConcurrentDictionary</span></strong><span class="koboSpan" id="kobo.426.1"> class (from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">System.Collections.Concurrent</span></strong><span class="koboSpan" id="kobo.428.1"> namespace) </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">is available.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">With this short introduction, let’s start coding! </span><span class="koboSpan" id="kobo.430.2">In the following sections, you will find two real-world examples that </span><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.431.1">use dictionaries fo</span><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.432.1">r </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">storing data.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.434.1">Example – product location</span></h2>
<p><span class="koboSpan" id="kobo.435.1">The first example we’ll look at is an </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.436.1">application that helps employees of a shop to find a product’s location. </span><span class="koboSpan" id="kobo.436.2">Let’s imagine that each employee has a phone with your application on it, which is used to scan a barcode of the product, and the application tells them that the product should be located in area </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">A1</span></strong><span class="koboSpan" id="kobo.438.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">C9</span></strong><span class="koboSpan" id="kobo.440.1">. </span><span class="koboSpan" id="kobo.440.2">Sounds interesting, </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">doesn’t it?</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">As the number of products in the shop is often very high, it is necessary to find results very quickly. </span><span class="koboSpan" id="kobo.442.2">For this reason, the data of products, together with their locations, is stored in the hash table, using the generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">Dictionary</span></strong><span class="koboSpan" id="kobo.444.1"> class. </span><span class="koboSpan" id="kobo.444.2">The key is the barcode (</span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">string</span></strong><span class="koboSpan" id="kobo.446.1">), while the value is the area code (also </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">string</span></strong><span class="koboSpan" id="kobo.448.1">), as </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.450.1">BARCODE -------&gt; AREA</span></strong><span class="koboSpan" id="kobo.451.1">
5901020304050 -&gt; A1
5910203040506 -&gt; B5
5920304050607 -&gt; C9</span></pre> <p><span class="koboSpan" id="kobo.452.1">First, you create a new collection and add </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">some data:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.454.1">Dictionary&lt;string, string&gt;</span></strong><span class="koboSpan" id="kobo.455.1"> products = new()
{
    { "5901020304050", "A1" },
    { "5910203040506", "B5" },
    { "5920304050607", "C9" }
};
products["5930405060708"] = "D7";</span></pre> <p><span class="koboSpan" id="kobo.456.1">The code shows two ways of adding elements to the collection, namely by passing their data while creating a new instance</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.457.1"> of the class and by using the indexer. </span><span class="koboSpan" id="kobo.457.2">A third solution also exists and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Add</span></strong><span class="koboSpan" id="kobo.459.1"> method, as shown in the following part of </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.461.1">
string key = "5940506070809";
if (!products.</span><strong class="bold"><span class="koboSpan" id="kobo.462.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.463.1">(key))
{
    products.</span><strong class="bold"><span class="koboSpan" id="kobo.464.1">Add</span></strong><span class="koboSpan" id="kobo.465.1">(key, "A3");
}</span></pre> <p><span class="koboSpan" id="kobo.466.1">Another solution uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">TryAdd</span></strong><span class="koboSpan" id="kobo.468.1"> method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
if (!products.</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">TryAdd</span></strong><span class="koboSpan" id="kobo.472.1">(key, "B4"))
{
    Console.WriteLine("Cannot add.");
}</span></pre> <p><span class="koboSpan" id="kobo.473.1">In the following part of the code, you present data of all the products that are available in the system. </span><span class="koboSpan" id="kobo.473.2">To do so, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">foreach</span></strong><span class="koboSpan" id="kobo.475.1"> loop. </span><span class="koboSpan" id="kobo.475.2">Before that, you check whether there are any elements in the dictionary. </span><span class="koboSpan" id="kobo.475.3">If not, the proper message is presented to the user. </span><span class="koboSpan" id="kobo.475.4">Otherwise, keys and values from all pairs are presented in </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">the console:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
Console.WriteLine("All products:");
if (products.</span><strong class="bold"><span class="koboSpan" id="kobo.478.1">Count</span></strong><span class="koboSpan" id="kobo.479.1"> == 0) { Console.WriteLine("Empty."); }
</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">foreach</span></strong><span class="koboSpan" id="kobo.481.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">(string k, string v)</span></strong><span class="koboSpan" id="kobo.483.1"> in products)
{
    Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.484.1">k</span></strong><span class="koboSpan" id="kobo.485.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.486.1">v</span></strong><span class="koboSpan" id="kobo.487.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.488.1">Now, let’s take a look at the part of the code that makes it possible to find the location of the product by its barcode. </span><span class="koboSpan" id="kobo.488.2">To do so, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.490.1"> to check whether the element exists. </span><span class="koboSpan" id="kobo.490.2">If so, a message with the target location is presented in the console. </span><span class="koboSpan" id="kobo.490.3">Otherwise, other information is</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.491.1"> shown. </span><span class="koboSpan" id="kobo.491.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">presented here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.493.1">
Console.Write("\nSearch by barcode: ");
string barcode = Console.ReadLine() ?? </span><span class="koboSpan" id="kobo.493.2">string.Empty;
if (products.</span><strong class="bold"><span class="koboSpan" id="kobo.494.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.495.1">(barcode, </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">out string? </span><span class="koboSpan" id="kobo.496.2">location</span></strong><span class="koboSpan" id="kobo.497.1">))
{
    Console.WriteLine($"The product is in: {</span><strong class="bold"><span class="koboSpan" id="kobo.498.1">location</span></strong><span class="koboSpan" id="kobo.499.1">}.");
}
else
{
    Console.WriteLine("The product does not exist.");
}</span></pre> <p><span class="koboSpan" id="kobo.500.1">When you run the program, you see a list of all the products in the shop and the program asks you to enter the barcode. </span><span class="koboSpan" id="kobo.500.2">After typing it, you receive a message containing the area code. </span><span class="koboSpan" id="kobo.500.3">The result that’s shown in the console should be similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.502.1">
Cannot add.
</span><span class="koboSpan" id="kobo.502.2">All products:
5901020304050: A1
5910203040506: B5
5920304050607: C9
5930405060708: D7
5940506070809: A3
Search by barcode: 5901020304050
The product is in: A1.</span></pre> <p><span class="koboSpan" id="kobo.503.1">You’ve just completed the first </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.504.1">example! </span><span class="koboSpan" id="kobo.504.2">Let’s proc</span><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.505.1">e</span><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.506.1">ed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">next one.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.508.1">Example – user details</span></h2>
<p><span class="koboSpan" id="kobo.509.1">This second example shows you</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.510.1"> how to store more complex data in the dictionary. </span><span class="koboSpan" id="kobo.510.2">In this scenario, you’ll create an application that shows details of a user based on their identifier, as </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.512.1">ID   -&gt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.513.1">  FIRST NAME | LAST NAME | PHONE NUMBER</span></strong><span class="koboSpan" id="kobo.514.1">
100  -&gt;  Marcin     | Jamro     | 101-202-303
210  -&gt;  John       | Smith     | 202-303-404
303  -&gt;  Aline      | Weather   | 303-404-505</span></pre> <p><span class="koboSpan" id="kobo.515.1">The program starts with the data of three users. </span><span class="koboSpan" id="kobo.515.2">You should be able to enter an identifier and see details of the found user. </span><span class="koboSpan" id="kobo.515.3">Of course, the situation of the non-existence of a given user should be handled by presenting the proper information in </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">First, let’s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">Employee</span></strong><span class="koboSpan" id="kobo.519.1"> record, which stores data of an employee, namely first name, last name, and phone number. </span><span class="koboSpan" id="kobo.519.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
public record </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Employee</span></strong><span class="koboSpan" id="kobo.523.1">(string FirstName, string LastName,
    string PhoneNumber);</span></pre> <p><span class="koboSpan" id="kobo.524.1">Then, create a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">Dictionary</span></strong><span class="koboSpan" id="kobo.526.1"> class and add data </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">to it:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.528.1">Dictionary&lt;int, Employee&gt;</span></strong><span class="koboSpan" id="kobo.529.1"> employees = new()
{
    { 100, new Employee("Marcin", "Jamro", "101-202-303") },
    { 210, new Employee("John", "Smith", "202-303-404") },
    { 303, new Employee("Aline", "Weather", "303-404-505") }
};</span></pre> <p><span class="koboSpan" id="kobo.530.1">The most interesting operations are performed in the following </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">do-while</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.533.1">
do
{
    Console.Write("Enter the identifier: ");
    string idString = Console.ReadLine() ?? </span><span class="koboSpan" id="kobo.533.2">string.Empty;
    if (!int.TryParse(idString, out int id)) { break; }
    if (employees.</span><strong class="bold"><span class="koboSpan" id="kobo.534.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.535.1">(id, </span><strong class="bold"><span class="koboSpan" id="kobo.536.1">out Employee? </span><span class="koboSpan" id="kobo.536.2">Employee</span></strong><span class="koboSpan" id="kobo.537.1">))
    {
        Console.WriteLine(
            "Full name: {0} {1}\nPhone number: {2}\n",
            </span><strong class="bold"><span class="koboSpan" id="kobo.538.1">employee.FirstName</span></strong><span class="koboSpan" id="kobo.539.1">,
            </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">employee.LastName</span></strong><span class="koboSpan" id="kobo.541.1">,
            </span><strong class="bold"><span class="koboSpan" id="kobo.542.1">employee.PhoneNumber</span></strong><span class="koboSpan" id="kobo.543.1">);
    }
    else { Console.WriteLine("Does not exist.\n"); }
}
while (true);</span></pre> <p><span class="koboSpan" id="kobo.544.1">First, the user is asked to enter an identifier of the employee, which is then parsed to the integer value. </span><span class="koboSpan" id="kobo.544.2">The loop is </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.545.1">stopped when the provided identifier cannot be parsed to the integer value. </span><span class="koboSpan" id="kobo.545.2">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.547.1"> method is used to try to get details of the user. </span><span class="koboSpan" id="kobo.547.2">If the user is found (</span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.549.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">true</span></strong><span class="koboSpan" id="kobo.551.1">), the details are presented in the console. </span><span class="koboSpan" id="kobo.551.2">Otherwise, an error message </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">is shown.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">When you run the application and enter some data, you will receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.555.1">
Enter the identifier: 100
Full name: Marcin Jamro
Phone number: 101-202-303
Enter the identifier: 101
Does not exist.</span></pre> <p><span class="koboSpan" id="kobo.556.1">That’s all! </span><span class="koboSpan" id="kobo.556.2">You’ve completed two examples showing how to use dictionaries while developing applications in the</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.557.1"> C# language. </span><span class="koboSpan" id="kobo.557.2">Do you remember that another kind of dictionary was already mentioned, namely a sorted dictionary? </span><span class="koboSpan" id="kobo.557.3">Are you interested in finding out what it is and how you can use it in your programs? </span><span class="koboSpan" id="kobo.557.4">If so, move o</span><a id="_idTextAnchor209"/><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.558.1">n to the </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">next section.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.560.1">Sorted dictionaries</span></h1>
<p><span class="koboSpan" id="kobo.561.1">Both non-generic and generic variants of the hash table-related classes do not keep the order of the elements. </span><span class="koboSpan" id="kobo.561.2">For this reason, if you need to present data from the collection sorted by keys, you need to sort</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.562.1"> them before presenting them. </span><span class="koboSpan" id="kobo.562.2">However, you can use another data structure, known as a </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">sorted dictionary</span></strong><span class="koboSpan" id="kobo.564.1">, to solve this problem and </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">keep keys sorted all the time</span></strong><span class="koboSpan" id="kobo.566.1">. </span><span class="koboSpan" id="kobo.566.2">Therefore, you can easily get the sorted collection </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">if necessary.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.568.1">Imagine a sorted dictionary</span></p>
<p class="callout"><span class="koboSpan" id="kobo.569.1">If you want to better imagine a sorted dictionary, remember the times from a dozen or so years ago, when the internet was not as popular and widespread as it is today, and at home there was a book on your shelf that allowed you to learn the meaning of a word in another language. </span><span class="koboSpan" id="kobo.569.2">How does it work? </span><span class="koboSpan" id="kobo.569.3">Let’s assume that you have a Polish-English dictionary, thanks to which you can find out how to translate a specific word from Polish to English, such as </span><em class="italic"><span class="koboSpan" id="kobo.570.1">cześć</span></em><span class="koboSpan" id="kobo.571.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.572.1">hello</span></em><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">You open this book and look for words that start with the letter </span><em class="italic"><span class="koboSpan" id="kobo.574.1">c</span></em><span class="koboSpan" id="kobo.575.1">. </span><span class="koboSpan" id="kobo.575.2">Found! </span><span class="koboSpan" id="kobo.575.3">Now, you are browsing through words starting with </span><em class="italic"><span class="koboSpan" id="kobo.576.1">c</span></em><span class="koboSpan" id="kobo.577.1"> to find the one you are interested in, namely </span><em class="italic"><span class="koboSpan" id="kobo.578.1">cześć</span></em><span class="koboSpan" id="kobo.579.1">. </span><span class="koboSpan" id="kobo.579.2">Fortunately, it’s not that complicated because all the words are listed in the dictionary in alphabetical order. </span><span class="koboSpan" id="kobo.579.3">And that’s how a sorted dictionary works! </span><span class="koboSpan" id="kobo.579.4">You can easily view all the items in the dictionary in alphabetical order. </span><span class="koboSpan" id="kobo.579.5">You can also quickly check if the dictionary contains a specific key and what its value is. </span><span class="koboSpan" id="kobo.579.6">Today, you just enter a foreign word in a search engine and you instantly know what it means in your language, as well as in probably any other language in the world. </span><span class="koboSpan" id="kobo.579.7">You like this kind of technological progress, </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">don’t you?</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">The sorted dictionary is implemented as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.583.1"> generic class, available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">System.Collections.Generic</span></strong><span class="koboSpan" id="kobo.585.1"> namespace. </span><span class="koboSpan" id="kobo.585.2">You can specify types for keys and values while creating a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.587.1">. </span><span class="koboSpan" id="kobo.587.2">An item key cannot be equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">null</span></strong><span class="koboSpan" id="kobo.589.1">, but its value can be if it is allowed by the type of values stored in the collection. </span><span class="koboSpan" id="kobo.589.2">Moreover, the </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.590.1">class contains similar properties and methods </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Dictionary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.594.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.595.1">You can find content regarding a sorted dictionary </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2"><span class="No-Break"><span class="koboSpan" id="kobo.597.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sorteddictionary-2</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.598.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1"> The exemplary application is </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.601.1">SortedDictionary&lt;string, string&gt;</span></strong><span class="koboSpan" id="kobo.602.1"> dictionary = new()
{
    { "Key #1", "Value #1" },
    { "Key #2", "Value #2" }
};
dictionary.</span><strong class="bold"><span class="koboSpan" id="kobo.603.1">Add</span></strong><span class="koboSpan" id="kobo.604.1">("Key #3", "Value #3");
dictionary</span><strong class="bold"><span class="koboSpan" id="kobo.605.1">["Key #4"]</span></strong><span class="koboSpan" id="kobo.606.1"> = "Value #4";
string value = dictionary</span><strong class="bold"><span class="koboSpan" id="kobo.607.1">["Key #1"]</span></strong><span class="koboSpan" id="kobo.608.1">;
dictionary.</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.610.1">("Key #2", out string? </span><span class="koboSpan" id="kobo.610.2">result);</span></pre> <p><span class="koboSpan" id="kobo.611.1">The class is equipped with various properties, such as getting the number of stored elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">Count</span></strong><span class="koboSpan" id="kobo.613.1">), as well as returning the collection of keys and values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">Keys</span></strong><span class="koboSpan" id="kobo.615.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">Values</span></strong><span class="koboSpan" id="kobo.617.1">, respectively). </span><span class="koboSpan" id="kobo.617.2">Moreover, you can use the available methods, which include </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Add</span></strong><span class="koboSpan" id="kobo.620.1">, which adds a </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">new element</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">Remove</span></strong><span class="koboSpan" id="kobo.623.1">, which removes </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">an item</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Clear</span></strong><span class="koboSpan" id="kobo.626.1">, which removes </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">all elements</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">ContainsKey</span></strong><span class="koboSpan" id="kobo.629.1">, which checks whether the collection contains a </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">particular key</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">ContainsValue</span></strong><span class="koboSpan" id="kobo.632.1">, which checks whether the collection contains a </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">given value</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">TryGetValue</span></strong><span class="koboSpan" id="kobo.635.1">, which tries to get a value for a </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">given key</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.637.1">If you want to iterate through all the pairs stored in the collection, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">foreach</span></strong><span class="koboSpan" id="kobo.639.1"> loop. </span><span class="koboSpan" id="kobo.639.2">The variable that’s used in the loop is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">KeyValuePair</span></strong><span class="koboSpan" id="kobo.641.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">Key</span></strong><span class="koboSpan" id="kobo.643.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Value</span></strong><span class="koboSpan" id="kobo.645.1"> properties, allowing you to access the key and </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">the value.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.647.1">What about performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.648.1">Despite the automatic sorting advantages, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.650.1"> class has some performance drawbacks compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">Dictionary</span></strong><span class="koboSpan" id="kobo.652.1"> because retrieval, insertion, and removal are the </span><em class="italic"><span class="koboSpan" id="kobo.653.1">O(log n)</span></em><span class="koboSpan" id="kobo.654.1"> operations, where </span><em class="italic"><span class="koboSpan" id="kobo.655.1">n</span></em><span class="koboSpan" id="kobo.656.1"> is the number of elements in the collection, instead </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">of </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.658.1">O(1)</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.660.1">Moreover, </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.662.1"> is quite similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">SortedList</span></strong><span class="koboSpan" id="kobo.664.1">, as described in </span><a href="B18069_03.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.665.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.666.1">, </span><em class="italic"><span class="koboSpan" id="kobo.667.1">Arrays and Sorting</span></em><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">However, it differs in memory-related and performance-related results. </span><span class="koboSpan" id="kobo.668.3">The retrieval for both these classes is the </span><em class="italic"><span class="koboSpan" id="kobo.669.1">O(log n)</span></em><span class="koboSpan" id="kobo.670.1"> operation, but insertion and removal for unsorted data is </span><em class="italic"><span class="koboSpan" id="kobo.671.1">O(log n)</span></em><span class="koboSpan" id="kobo.672.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.674.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.675.1">O(n)</span></em><span class="koboSpan" id="kobo.676.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">SortedList</span></strong><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">Of course, more memory is necessary for </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.680.1"> than for </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">SortedList</span></strong><span class="koboSpan" id="kobo.682.1">. </span><span class="koboSpan" id="kobo.682.2">As you can see, choosing a proper data structure is not an easy task and you should think carefully about the scenarios in which data structures are used and take into account both the pros </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">and cons.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">With this short introduction, let’s see </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.685.1">the s</span><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.686.1">or</span><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.687.1">ted dictionary </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">in action.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.689.1">Example – encyclopedia</span></h2>
<p><span class="koboSpan" id="kobo.690.1">As an example, let’s create a simple</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.691.1"> encyclopedia where you can add entries and show their full content. </span><span class="koboSpan" id="kobo.691.2">The encyclopedia can contain millions of entries, so it is crucial to provide its users with the possibility of browsing entries in the correct order, alphabetically by keys, as well as finding entries quickly. </span><span class="koboSpan" id="kobo.691.3">For this reason, the sorted dictionary is a </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">good choice.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">The concept of the encyclopedia is </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.695.1">NAME     -&gt; EXPLANATION</span></strong><span class="koboSpan" id="kobo.696.1">
Lancut   -&gt; A city located near Rzeszow, with a castle.
</span><span class="koboSpan" id="kobo.696.2">Rzeszow  -&gt; A capital of the Subcarpathian voivodeship.
</span><span class="koboSpan" id="kobo.696.3">Warszawa -&gt; A capital city of Poland.
</span><span class="koboSpan" id="kobo.696.4">Zakopane -&gt; A city located in Tatra mountains in Poland.</span></pre> <p><span class="koboSpan" id="kobo.697.1">When the program is launched, it presents a simple menu with two options, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">[A]dd</span></strong><span class="koboSpan" id="kobo.699.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">[L]ist</span></strong><span class="koboSpan" id="kobo.701.1">. </span><span class="koboSpan" id="kobo.701.2">After pressing </span><em class="italic"><span class="koboSpan" id="kobo.702.1">A</span></em><span class="koboSpan" id="kobo.703.1">, the application asks you to enter the key and explanation for the entry. </span><span class="koboSpan" id="kobo.703.2">If the provided data is correct, a new entry is added to the encyclopedia. </span><span class="koboSpan" id="kobo.703.3">If the user presses </span><em class="italic"><span class="koboSpan" id="kobo.704.1">L</span></em><span class="koboSpan" id="kobo.705.1">, data of all entries, sorted by keys, is presented in the console. </span><span class="koboSpan" id="kobo.705.2">When any other key is</span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.706.1"> pressed, additional confirmation is shown and, if confirmed, the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">program exits.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
Console.WriteLine("Welcome to your encyclopedia!\n");
</span><strong class="bold"><span class="koboSpan" id="kobo.711.1">SortedDictionary&lt;string, string&gt;</span></strong><span class="koboSpan" id="kobo.712.1"> definitions = [];
do
{
    Console.WriteLine("\nChoose option ([A]dd, [L]ist): ");
    ConsoleKeyInfo keyInfo = Console.ReadKey(true);
    if (keyInfo.Key == ConsoleKey.A)
    {
        Console.Write("Enter the key: ");
        string key = Console.ReadLine() ?? </span><span class="koboSpan" id="kobo.712.2">string.Empty;
        Console.Write("Enter the explanation: ");
        string explanation = Console.ReadLine()
            ?? </span><span class="koboSpan" id="kobo.712.3">string.Empty;
        </span><strong class="bold"><span class="koboSpan" id="kobo.713.1">definitions[key] = explanation;</span></strong><span class="koboSpan" id="kobo.714.1">
    }
    else if (keyInfo.Key == ConsoleKey.L)
    {
        </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">foreach ((string k, string e) in definitions)</span></strong><span class="koboSpan" id="kobo.716.1">
        {
            Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.717.1">k</span></strong><span class="koboSpan" id="kobo.718.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.719.1">e</span></strong><span class="koboSpan" id="kobo.720.1">}");
        }
    }
    else
    {
        Console.WriteLine("Do you want to exit? </span><span class="koboSpan" id="kobo.720.2">Y or N.");
        if (Console.ReadKey().Key == ConsoleKey.Y)
        {
            break;
        }
    }
}
while (true);</span></pre> <p><span class="koboSpan" id="kobo.721.1">First, a new instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.723.1"> class is created, which represents a collection of pairs with </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">string</span></strong><span class="koboSpan" id="kobo.725.1">-based keys and </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">string</span></strong><span class="koboSpan" id="kobo.727.1">-based values. </span><span class="koboSpan" id="kobo.727.2">Then, the infinite </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">do-while</span></strong><span class="koboSpan" id="kobo.729.1"> loop is used. </span><span class="koboSpan" id="kobo.729.2">Within it, the program waits until the user presses any key. </span><span class="koboSpan" id="kobo.729.3">If it is the </span><em class="italic"><span class="koboSpan" id="kobo.730.1">A</span></em><span class="koboSpan" id="kobo.731.1"> key, a key and an explanation of the entry are obtained from the values entered by the user. </span><span class="koboSpan" id="kobo.731.2">Then, a new entry is added to the dictionary using the indexer. </span><span class="koboSpan" id="kobo.731.3">Thus, if the entry with the same key </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.732.1">already exists, it will be updated. </span><span class="koboSpan" id="kobo.732.2">In the case of pressing the </span><em class="italic"><span class="koboSpan" id="kobo.733.1">L</span></em><span class="koboSpan" id="kobo.734.1"> key, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">foreach</span></strong><span class="koboSpan" id="kobo.736.1"> loop is used to show all entered entries. </span><span class="koboSpan" id="kobo.736.2">When any other key is pressed, another question is presented to the user and the program waits for confirmation. </span><span class="koboSpan" id="kobo.736.3">If the user presses </span><em class="italic"><span class="koboSpan" id="kobo.737.1">Y</span></em><span class="koboSpan" id="kobo.738.1">, you break out of </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">the loop.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">When you run the program, you can enter a few entries, as well as present them. </span><span class="koboSpan" id="kobo.740.2">The result from the console can be similar to what’s shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">following block:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.742.1">
Welcome to your encyclopedia!
</span><span class="koboSpan" id="kobo.742.2">Choose option ([A]dd, [L]ist):
Enter the key: Zakopane
Enter the explanation: A city located in Tatra mountains in Poland.
</span><span class="koboSpan" id="kobo.742.3">Choose option ([A]dd, [L]ist):
Enter the key: Rzeszow
Enter the explanation: A capital of the Subcarpathian voivodeship.
</span><span class="koboSpan" id="kobo.742.4">Choose option ([A]dd, [L]ist):
Rzeszow: A capital of the Subcarpathian voivodeship.
</span><span class="koboSpan" id="kobo.742.5">Zakopane: A city located in Tatra mountains in Poland.
</span><span class="koboSpan" id="kobo.742.6">Choose option ([A]dd, [L]ist):
Do you want to exit? </span><span class="koboSpan" id="kobo.742.7">Y or N.</span></pre> <p><span class="koboSpan" id="kobo.743.1">So far, you’ve learned about three dictionary-related classes, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">Hashtable</span></strong><span class="koboSpan" id="kobo.745.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">Dictionary</span></strong><span class="koboSpan" id="kobo.747.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.749.1">. </span><span class="koboSpan" id="kobo.749.2">To make understanding them easier, a few examples were presented, together with </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">detailed explanations.</span></span></p>
<p><span class="koboSpan" id="kobo.751.1">However, do you know that </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.752.1">some other data structures sto</span><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.753.1">re just keys, without values? </span><span class="koboSpan" id="kobo.753.2">You will learn about th</span><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.754.1">ese in the </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">next sections.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.756.1">Hash sets</span></h1>
<p><span class="koboSpan" id="kobo.757.1">In many algorithms, it is necessary to perform </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.758.1">operations on sets with various data. </span><span class="koboSpan" id="kobo.758.2">However, what</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.759.1"> is a </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">set</span></strong><span class="koboSpan" id="kobo.761.1">? </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">A set is a collection of distinct objects without duplicated elements and without a particular order.</span></strong><span class="koboSpan" id="kobo.763.1"> Therefore, you can only get to know whether a given element is in the set or not. </span><span class="koboSpan" id="kobo.763.2">These sets are strictly connected with mathematical models and operations, such as union, intersection, subtraction, and symmetric difference. </span><span class="koboSpan" id="kobo.763.3">A set can store various data, such as integer or string values. </span><span class="koboSpan" id="kobo.763.4">Of course, you can also create a set with instances of a user-defined class or record, as well as add and remove elements from the set at </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">any time.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.765.1">Imagine a hash set</span></p>
<p class="callout"><span class="koboSpan" id="kobo.766.1">If you want to better visualize a hash set, think for a moment about the game of chance, which is popular in many countries and involves selecting a few numbers that are then drawn from among many available ones. </span><span class="koboSpan" id="kobo.766.2">Depending on how many numbers you got from those drawn, you receive a prize. </span><span class="koboSpan" id="kobo.766.3">Of course, the chance of matching all the drawn numbers is very, very small. </span><span class="koboSpan" id="kobo.766.4">Now, you may be wondering where these collections are here. </span><span class="koboSpan" id="kobo.766.5">I’m in a hurry to answer this! </span><span class="koboSpan" id="kobo.766.6">There are three sets here, namely a set of all available numbers, a set of randomly drawn numbers, and a set of numbers selected by you. </span><span class="koboSpan" id="kobo.766.7">Each set cannot contain any </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.767.1">duplicates. </span><span class="koboSpan" id="kobo.767.2">Of course, both the set of randomly drawn numbers and the set of numbers you choose are subsets of the set of all available numbers. </span><span class="koboSpan" id="kobo.767.3">How can you check how many numbers you have chosen correctly? </span><span class="koboSpan" id="kobo.767.4">It is very easy! </span><span class="koboSpan" id="kobo.767.5">Just perform the “intersection” operation on two sets, namely the set of randomly selected numbers and the set of numbers you selected, to obtain the result set. </span><span class="koboSpan" id="kobo.767.6">Now, all you have to do is keep your fingers crossed that the number of elements in this result set matches the number of elements in the set of drawn numbers. </span><span class="koboSpan" id="kobo.767.7">If that happens, then... </span><span class="koboSpan" id="kobo.767.8">you may become very rich because you matched all the drawn numbers. </span><span class="koboSpan" id="kobo.767.9">If </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">so, congratulations!</span></span></p>
<p><span class="koboSpan" id="kobo.769.1">Two exemplary sets are presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.771.1"><img alt="Figure 6.2 – Illustration of sets with integer and string values" src="image/B18069_06_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.772.1">Figure 6.2 – Illustration of sets with integer and string values</span></p>
<p><span class="koboSpan" id="kobo.773.1">Before seeing sets in action, it is a good idea to remind you of some basic operations that can be performed on two sets, named </span><strong class="bold"><span class="koboSpan" id="kobo.774.1">A</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.775.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.776.1">B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.779.1">union</span></strong><span class="koboSpan" id="kobo.780.1"> (shown on the </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.781.1">left of the</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.782.1"> following figure as </span><strong class="bold"><span class="koboSpan" id="kobo.783.1">A</span></strong><strong class="bold"><span class="koboSpan" id="kobo.784.1">∪</span></strong><strong class="bold"><span class="koboSpan" id="kobo.785.1">B</span></strong><span class="koboSpan" id="kobo.786.1">) is </span><strong class="bold"><span class="koboSpan" id="kobo.787.1">a set with all elements that </span></strong><strong class="bold"><a id="_idIndexMarker582"/></strong><strong class="bold"><span class="koboSpan" id="kobo.788.1">belong to A or B</span></strong><span class="koboSpan" id="kobo.789.1">. </span><span class="koboSpan" id="kobo.789.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.790.1">intersection</span></strong><span class="koboSpan" id="kobo.791.1"> (presented on the right as </span><strong class="bold"><span class="koboSpan" id="kobo.792.1">A</span></strong><strong class="bold"><span class="koboSpan" id="kobo.793.1">∩</span></strong><strong class="bold"><span class="koboSpan" id="kobo.794.1">B</span></strong><span class="koboSpan" id="kobo.795.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.796.1">contains only the elements that belong to both A </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.797.1">and B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.799.1"><img alt="Figure 6.3 – Illustration of set union and intersection" src="image/B18069_06_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.800.1">Figure 6.3 – Illustration of set union and intersection</span></p>
<p><span class="koboSpan" id="kobo.801.1">Another common operation is set </span><strong class="bold"><span class="koboSpan" id="kobo.802.1">subtraction</span></strong><span class="koboSpan" id="kobo.803.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.804.1">The result set of A \ B contains elements that are the members of A and not the members of B</span></strong><span class="koboSpan" id="kobo.805.1">. </span><span class="koboSpan" id="kobo.805.2">In the following figure, two examples are </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.806.1">shown, namely </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">A \ B</span></strong><span class="koboSpan" id="kobo.808.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">B \ </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.810.1">A</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.812.1"><img alt="Figure 6.4 – Illustration of set subtraction" src="image/B18069_06_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.813.1">Figure 6.4 – Illustration of set subtraction</span></p>
<p><span class="koboSpan" id="kobo.814.1">While performing various operations on sets, it is also worth mentioning the </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">symmetric difference</span></strong><span class="koboSpan" id="kobo.816.1">, shown in </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.817.1">the following </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.818.1">figure as </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">A ∆ B</span></strong><span class="koboSpan" id="kobo.820.1">. </span><span class="koboSpan" id="kobo.820.2">The final set can be interpreted as a union of two sets, namely (</span><strong class="bold"><span class="koboSpan" id="kobo.821.1">A \ B</span></strong><span class="koboSpan" id="kobo.822.1">) and (</span><strong class="bold"><span class="koboSpan" id="kobo.823.1">B \ A</span></strong><span class="koboSpan" id="kobo.824.1">). </span><span class="koboSpan" id="kobo.824.2">Therefore, </span><strong class="bold"><span class="koboSpan" id="kobo.825.1">it contains elements that belong to only one set, either A or B</span></strong><span class="koboSpan" id="kobo.826.1">. </span><span class="koboSpan" id="kobo.826.2">The elements that belong to both sets are excluded from </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">the result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.828.1"><img alt="Figure 6.5 – Illustration of set symmetric difference and the relationships between sets" src="image/B18069_06_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.829.1">Figure 6.5 – Illustration of set symmetric difference and the relationships between sets</span></p>
<p><span class="koboSpan" id="kobo.830.1">Another important topic is the </span><strong class="bold"><span class="koboSpan" id="kobo.831.1">relationship</span></strong><span class="koboSpan" id="kobo.832.1"> between sets. </span><strong class="bold"><span class="koboSpan" id="kobo.833.1">If every element of B belongs to A, this means that B is a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.834.1">subset</span></strong><strong class="bold"><span class="koboSpan" id="kobo.835.1"> of A</span></strong><span class="koboSpan" id="kobo.836.1">. </span><span class="koboSpan" id="kobo.836.2">This is shown in the preceding diagram, on the right. </span><span class="koboSpan" id="kobo.836.3">At the same time, </span><strong class="bold"><span class="koboSpan" id="kobo.837.1">A is a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.838.1">superset</span></strong><strong class="bold"><span class="koboSpan" id="kobo.839.1"> of B</span></strong><span class="koboSpan" id="kobo.840.1">. </span><span class="koboSpan" id="kobo.840.2">Moreover, </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">if B is a subset of A, but B is not equal to A, B is a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.842.1">proper subset</span></strong><strong class="bold"><span class="koboSpan" id="kobo.843.1"> of A</span></strong><span class="koboSpan" id="kobo.844.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">A is a </span></strong><strong class="bold"><span class="koboSpan" id="kobo.846.1">proper superset</span></strong><strong class="bold"> </strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.847.1">of B</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">While developing various kinds of applications in the C# language, you can benefit from high-performance operations provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">HashSet</span></strong><span class="koboSpan" id="kobo.851.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">System.Collections.Generic</span></strong><span class="koboSpan" id="kobo.853.1"> namespace. </span><span class="koboSpan" id="kobo.853.2">The class contains a few properties, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">Count</span></strong><span class="koboSpan" id="kobo.855.1">, which returns the number of elements in </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">the set.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.857.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.858.1">You can find content regarding a hash set </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1"><span class="No-Break"><span class="koboSpan" id="kobo.860.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.861.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">Moreover, you can use many methods to perform operations of sets. </span><span class="koboSpan" id="kobo.862.2">The first group of methods makes it possible to modify the current set (on which the method is called) to create the union (</span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">UnionWith</span></strong><span class="koboSpan" id="kobo.864.1">), the </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.865.1">intersection (</span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.867.1">), the subtraction (</span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">ExceptWith</span></strong><span class="koboSpan" id="kobo.869.1">), and the symmetric difference (</span><strong class="source-inline"><span class="koboSpan" id="kobo.870.1">SymmetricExceptWith</span></strong><span class="koboSpan" id="kobo.871.1">) with the set passed as </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">the parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.873.1">You can also check the relationship between two sets, such as checking whether the current set (on which the method is called) is a subset (</span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">IsSubsetOf</span></strong><span class="koboSpan" id="kobo.875.1">), a superset (</span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">IsSupersetOf</span></strong><span class="koboSpan" id="kobo.877.1">), a proper subset (</span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">IsProperSubsetOf</span></strong><span class="koboSpan" id="kobo.879.1">) or a proper superset (</span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">IsProperSupersetOf</span></strong><span class="koboSpan" id="kobo.881.1">) of the set passed as </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">the parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.883.1">Furthermore, you can verify whether two sets contain the same elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">SetEquals</span></strong><span class="koboSpan" id="kobo.885.1">) or whether two sets have at least one common </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">element (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Overlaps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.889.1">Apart from these operations, you can add a new element to the set (</span><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">Add</span></strong><span class="koboSpan" id="kobo.891.1">), remove a particular element (</span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">Remove</span></strong><span class="koboSpan" id="kobo.893.1">), remove all elements (</span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">Clear</span></strong><span class="koboSpan" id="kobo.895.1">), and check whether the given element exists in the </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">set (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">Contains</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">).</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.899.1">What about performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.900.1">Hash sets make it possible to perform a quick lookup for a given item. </span><span class="koboSpan" id="kobo.900.2">Thus, checking whether the set contains an item and removing an item are </span><em class="italic"><span class="koboSpan" id="kobo.901.1">O(1)</span></em><span class="koboSpan" id="kobo.902.1"> operations. </span><span class="koboSpan" id="kobo.902.2">As for addition, it is an </span><em class="italic"><span class="koboSpan" id="kobo.903.1">O(1)</span></em><span class="koboSpan" id="kobo.904.1"> operation if it does not need to increase the internal array. </span><span class="koboSpan" id="kobo.904.2">If resizing is necessary, it turns out to be the </span><em class="italic"><span class="koboSpan" id="kobo.905.1">O(n)</span></em><span class="koboSpan" id="kobo.906.1"> operation, where </span><em class="italic"><span class="koboSpan" id="kobo.907.1">n</span></em><span class="koboSpan" id="kobo.908.1"> is the number </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">of items.</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">With this introduction, try to put what you’ve learned into practice. </span><span class="koboSpan" id="kobo.910.2">Now, let’s proceed to two examples that show how you can ap</span><a id="_idTextAnchor218"/><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.911.1">ply hash sets in </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">your applications.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.913.1">Example – coupons</span></h2>
<p><span class="koboSpan" id="kobo.914.1">The first example represents a system that checks whether a one-time coupon has already been used. </span><span class="koboSpan" id="kobo.914.2">If so, a suitable </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.915.1">message is presented to the user. </span><span class="koboSpan" id="kobo.915.2">Otherwise, the system informs the user that the coupon is valid. </span><span class="koboSpan" id="kobo.915.3">It is then marked as used and cannot be used again. </span><span class="koboSpan" id="kobo.915.4">Due to the high number of coupons, it is necessary to choose a data structure that allows you to quickly check whether an element exists in a collection. </span><span class="koboSpan" id="kobo.915.5">For this reason, a hash set has been chosen as a data structure for storing identifiers of </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">used coupons.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">Let’s take a look at </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the code:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.919.1">HashSet&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.920.1"> usedCoupons = [];
do
{
    Console.Write("Enter the number: ");
    string number = Console.ReadLine() ?? </span><span class="koboSpan" id="kobo.920.2">string.Empty;
    if (!int.TryParse(number, out int coupon)) { break; }
    if (usedCoupons.</span><strong class="bold"><span class="koboSpan" id="kobo.921.1">Contains</span></strong><span class="koboSpan" id="kobo.922.1">(coupon))
    {
        Console.WriteLine("Already used.");
    }
    else
    {
        usedCoupons.</span><strong class="bold"><span class="koboSpan" id="kobo.923.1">Add</span></strong><span class="koboSpan" id="kobo.924.1">(coupon);
        Console.WriteLine("Thank you!");
    }
}
while (true);</span></pre> <p><span class="koboSpan" id="kobo.925.1">First, a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">HashSet</span></strong><span class="koboSpan" id="kobo.927.1"> that stores integer values is created. </span><span class="koboSpan" id="kobo.927.2">Then, the majority of operations are performed within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">do-while</span></strong><span class="koboSpan" id="kobo.929.1"> loop. </span><span class="koboSpan" id="kobo.929.2">Here, the program waits until the user enters the coupon identifier. </span><span class="koboSpan" id="kobo.929.3">If it cannot be parsed to the integer value, you break out of the loop. </span><span class="koboSpan" id="kobo.929.4">Otherwise, you check whether the set already contains the coupon identifier (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">Contains</span></strong><span class="koboSpan" id="kobo.931.1"> method). </span><span class="koboSpan" id="kobo.931.2">If so, the suitable information is presented in the console. </span><span class="koboSpan" id="kobo.931.3">If it does not exist, you add it to the collection of used coupons (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.932.1">Add</span></strong><span class="koboSpan" id="kobo.933.1"> method) and inform the user about </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">the result.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">When you break out of the loop, you just need to show the complete list of identifiers of the used coupons. </span><span class="koboSpan" id="kobo.935.2">You can do so</span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.936.1"> using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">foreach</span></strong><span class="koboSpan" id="kobo.938.1"> loop, iterating over the set, and writing its elements in the console, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
Console.WriteLine("\nUsed coupons:");
</span><strong class="bold"><span class="koboSpan" id="kobo.941.1">foreach</span></strong><span class="koboSpan" id="kobo.942.1"> (int coupon in usedCoupons)
{
    Console.WriteLine(coupon);
}</span></pre> <p><span class="koboSpan" id="kobo.943.1">Now, you can launch the application, enter some data, and see how </span><span class="No-Break"><span class="koboSpan" id="kobo.944.1">it works:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.945.1">
Enter the number: 100
Thank you!
</span><span class="koboSpan" id="kobo.945.2">Enter the number: 101
Thank you! </span><span class="koboSpan" id="kobo.945.3">(...)
Enter the number: 101
Already used.
</span><span class="koboSpan" id="kobo.945.4">Enter the number:
Used coupons:
100
101
500
345</span></pre> <p><span class="koboSpan" id="kobo.946.1">This is the end of the first example. </span><span class="koboSpan" id="kobo.946.2">Let’s proceed to the next one, where you will see a more </span><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.947.1">c</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.948.1">omplex solution that uses a </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">hash set.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.950.1">Example – swimming pools</span></h2>
<p><span class="koboSpan" id="kobo.951.1">This example presents the system for a SPA center with four swimming pools, namely recreation, competition, thermal, and for kids. </span><span class="koboSpan" id="kobo.951.2">Each visitor receives a special wristband that allows them to enter all the </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.952.1">pools. </span><span class="koboSpan" id="kobo.952.2">However, it is necessary to scan the wristband upon each user entering any pool. </span><span class="koboSpan" id="kobo.952.3">Your program uses such data to create </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">various statistics.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">A hash set has been chosen as a data structure for storing unique numbers of wristbands that are scanned at the entrance to each swimming pool. </span><span class="koboSpan" id="kobo.954.2">Four sets are used, one per pool. </span><span class="koboSpan" id="kobo.954.3">Moreover, they are grouped in the dictionary to simplify and shorten the code, as well as make future modifications easier. </span><span class="koboSpan" id="kobo.954.4">To simplify testing the application, the initial data is set randomly. </span><span class="koboSpan" id="kobo.954.5">Then, you create statistics, namely the number of visitors by pool type, the most popular pool, the number of people who visited at least one pool, as well as the number of people who visited all </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">the pools.</span></span></p>
<p><span class="koboSpan" id="kobo.956.1">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">PoolTypeEnum</span></strong><span class="koboSpan" id="kobo.958.1"> enumeration, which represents possible types of </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">swimming pools:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.960.1">
enum </span><strong class="bold"><span class="koboSpan" id="kobo.961.1">PoolTypeEnum</span></strong><span class="koboSpan" id="kobo.962.1">
{
    Recreation,
    Competition,
    Thermal,
    Kids
};</span></pre> <p><span class="koboSpan" id="kobo.963.1">Then, open </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">Program.cs</span></strong><span class="koboSpan" id="kobo.965.1"> and add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">random</span></strong><span class="koboSpan" id="kobo.967.1"> variable. </span><span class="koboSpan" id="kobo.967.2">This will be used to fill the hash set with some random values. </span><span class="koboSpan" id="kobo.967.3">The line of code is </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.969.1">
Random random = new();</span></pre> <p><span class="koboSpan" id="kobo.970.1">In the next part of the code, you create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">Dictionary</span></strong><span class="koboSpan" id="kobo.972.1">. </span><span class="koboSpan" id="kobo.972.2">This contains four entries. </span><span class="koboSpan" id="kobo.972.3">Each key is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">PoolTypeEnum</span></strong><span class="koboSpan" id="kobo.974.1"> type and each value is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">HashSet&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.976.1"> type – that is, a set with integer values. </span><span class="koboSpan" id="kobo.976.2">The code is </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">shown here:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.978.1">Dictionary&lt;PoolTypeEnum, HashSet&lt;int&gt;&gt;</span></strong><span class="koboSpan" id="kobo.979.1"> tickets = new()
{
    { PoolTypeEnum.Recreation, new() },
    { PoolTypeEnum.Competition, new() },
    { PoolTypeEnum.Thermal, new() },
    { PoolTypeEnum.Kids, new() }
};</span></pre> <p><span class="koboSpan" id="kobo.980.1">After that, you fill the</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.981.1"> sets with random values, as </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.983.1">
for (int i = 1; i &lt; 100; i++)
{
    </span><strong class="bold"><span class="koboSpan" id="kobo.984.1">foreach ((PoolTypeEnum p, HashSet&lt;int&gt; t) in tickets)</span></strong><span class="koboSpan" id="kobo.985.1">
    {
        if (random.Next(2) == 1) { </span><strong class="bold"><span class="koboSpan" id="kobo.986.1">t.Add(i);</span></strong><span class="koboSpan" id="kobo.987.1"> }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.988.1">To do so, you use two loops, namely </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">for</span></strong><span class="koboSpan" id="kobo.990.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">foreach</span></strong><span class="koboSpan" id="kobo.992.1">. </span><span class="koboSpan" id="kobo.992.2">The first iterates </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">100</span></strong><span class="koboSpan" id="kobo.994.1"> times and simulates </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">100</span></strong><span class="koboSpan" id="kobo.996.1"> wristbands. </span><span class="koboSpan" id="kobo.996.2">Within it, there is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">foreach</span></strong><span class="koboSpan" id="kobo.998.1"> loop, which iterates through all available pool types. </span><span class="koboSpan" id="kobo.998.2">For each of them, you randomly check whether a visitor entered a particular swimming pool. </span><span class="koboSpan" id="kobo.998.3">If so, the identifier is added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">proper set.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">The remaining code is related to generating various statistics. </span><span class="koboSpan" id="kobo.1000.2">First, let’s present the number of visitors by pool type. </span><span class="koboSpan" id="kobo.1000.3">Such a task is very easy because you just need to iterate through the dictionary, as well as write the pool type and the number of elements in the set (using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">Count</span></strong><span class="koboSpan" id="kobo.1002.1"> property), as </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
Console.WriteLine("Number of visitors by a pool type:");
</span><strong class="bold"><span class="koboSpan" id="kobo.1005.1">foreach ((PoolTypeEnum p, HashSet&lt;int&gt; t) in tickets)</span></strong><span class="koboSpan" id="kobo.1006.1">
{
    Console.WriteLine($"- {</span><strong class="bold"><span class="koboSpan" id="kobo.1007.1">p</span></strong><span class="koboSpan" id="kobo.1008.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.1009.1">t.Count</span></strong><span class="koboSpan" id="kobo.1010.1">}");
}</span></pre> <p><span class="koboSpan" id="kobo.1011.1">The next part finds the swimming pool with the maximum number of visitors. </span><span class="koboSpan" id="kobo.1011.2">This is done using a few extension methods, namely to order the results by the number of elements in the set, in descending order (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">OrderByDescending</span></strong><span class="koboSpan" id="kobo.1013.1">), to choose only a pool type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">Select</span></strong><span class="koboSpan" id="kobo.1015.1">), and to take only the first element (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1017.1">). </span><span class="koboSpan" id="kobo.1017.2">Then, you just present the result. </span><span class="koboSpan" id="kobo.1017.3">The </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.1018.1">code for doing this is </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1020.1">
PoolTypeEnum maxVisitors = tickets
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1021.1">OrderByDescending</span></strong><span class="koboSpan" id="kobo.1022.1">(t =&gt; t.Value.Count)
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">Select</span></strong><span class="koboSpan" id="kobo.1024.1">(t =&gt; t.Key)
    .</span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">FirstOrDefault</span></strong><span class="koboSpan" id="kobo.1026.1">();
Console.WriteLine($"{maxVisitors} - the most popular.");</span></pre> <p><span class="koboSpan" id="kobo.1027.1">Next, you want to get the number of people who visited at least one pool. </span><span class="koboSpan" id="kobo.1027.2">You perform this task by creating a union of all sets and getting the count of the final set. </span><span class="koboSpan" id="kobo.1027.3">First, you create a new set and fill it with identifiers regarding the recreation swimming pool. </span><span class="koboSpan" id="kobo.1027.4">In the following lines of code, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">UnionWith</span></strong><span class="koboSpan" id="kobo.1029.1"> method to create a union with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">three sets:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1031.1">HashSet&lt;int&gt; any = new(tickets[PoolTypeEnum.Recreation]);</span></strong><span class="koboSpan" id="kobo.1032.1">
any.</span><strong class="bold"><span class="koboSpan" id="kobo.1033.1">UnionWith</span></strong><span class="koboSpan" id="kobo.1034.1">(tickets[PoolTypeEnum.Competition]);
any.</span><strong class="bold"><span class="koboSpan" id="kobo.1035.1">UnionWith</span></strong><span class="koboSpan" id="kobo.1036.1">(tickets[PoolTypeEnum.Thermal]);
any.</span><strong class="bold"><span class="koboSpan" id="kobo.1037.1">UnionWith</span></strong><span class="koboSpan" id="kobo.1038.1">(tickets[PoolTypeEnum.Kids]);
Console.WriteLine($"{any.</span><strong class="bold"><span class="koboSpan" id="kobo.1039.1">Count</span></strong><span class="koboSpan" id="kobo.1040.1">} people visited
    at least one pool.");</span></pre> <p><span class="koboSpan" id="kobo.1041.1">The last statistic is the number of people who visited all pools during one visit to the SPA center. </span><span class="koboSpan" id="kobo.1041.2">You just need to create the intersection of all sets and get the count of the final set. </span><span class="koboSpan" id="kobo.1041.3">To do so, you create a new set and fill it with identifiers regarding the recreation swimming pool. </span><span class="koboSpan" id="kobo.1041.4">Then, you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.1043.1"> method to create an intersection with the following three sets. </span><span class="koboSpan" id="kobo.1043.2">Finally, you get the number of elements in the set using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">Count</span></strong><span class="koboSpan" id="kobo.1045.1"> property and present the results, </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1047.1">HashSet&lt;int&gt; all = new(tickets[PoolTypeEnum.Recreation]);</span></strong><span class="koboSpan" id="kobo.1048.1">
all.</span><strong class="bold"><span class="koboSpan" id="kobo.1049.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.1050.1">(tickets[PoolTypeEnum.Competition]);
all.</span><strong class="bold"><span class="koboSpan" id="kobo.1051.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.1052.1">(tickets[PoolTypeEnum.Thermal]);
all.</span><strong class="bold"><span class="koboSpan" id="kobo.1053.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.1054.1">(tickets[PoolTypeEnum.Kids]);
Console.WriteLine($"{all.</span><strong class="bold"><span class="koboSpan" id="kobo.1055.1">Count</span></strong><span class="koboSpan" id="kobo.1056.1">} people visited all pools.");</span></pre> <p><span class="koboSpan" id="kobo.1057.1">That’s all! </span><span class="koboSpan" id="kobo.1057.2">When you run the application, you may receive the </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1059.1">
Number of visitors by a pool type:
- Recreation: 60
- Competition: 40
- Thermal: 47
- Kids: 45
Recreation - the most popular.
</span><span class="koboSpan" id="kobo.1059.2">91 people visited at least one pool.
</span><span class="koboSpan" id="kobo.1059.3">10 people visited all pools.</span></pre> <p><span class="koboSpan" id="kobo.1060.1">You’ve just completed two</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.1061.1"> examples regarding hash sets. </span><span class="koboSpan" id="kobo.1061.2">It’s a good idea to try to modify the code and add new features on your own to learn more about this data structure. </span><span class="koboSpan" id="kobo.1061.3">In the n</span><a id="_idTextAnchor224"/><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.1062.1">ext section, we’ll look at “</span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">sorted” sets.</span></span></p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.1064.1">“Sorted” sets</span></h1>
<p><span class="koboSpan" id="kobo.1065.1">The previously described </span><strong class="source-inline"><span class="koboSpan" id="kobo.1066.1">HashSet</span></strong><span class="koboSpan" id="kobo.1067.1"> class can be understood as a dictionary that stores only keys, without values. </span><span class="koboSpan" id="kobo.1067.2">So, if there is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">SortedDictionary</span></strong><span class="koboSpan" id="kobo.1069.1"> class, maybe there is also the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">SortedSet</span></strong><span class="koboSpan" id="kobo.1071.1"> class? </span><span class="koboSpan" id="kobo.1071.2">There is! </span><span class="koboSpan" id="kobo.1071.3">However, can a set be “sorted”? </span><span class="koboSpan" id="kobo.1071.4">Why is “sorted” written with quotation marks? </span><span class="koboSpan" id="kobo.1071.5">The</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.1072.1"> answer turns out to be very simple. </span><span class="koboSpan" id="kobo.1072.2">By definition, a set stores a collection of distinct objects without duplicated elements and without a particular order. </span><span class="koboSpan" id="kobo.1072.3">If a set does not support order, how can it be “sorted”? </span><span class="koboSpan" id="kobo.1072.4">For this reason, </span><strong class="bold"><span class="koboSpan" id="kobo.1073.1">a “sorted” set can be understood as a combination of </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1074.1">HashSet</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1075.1"> and </span></strong><strong class="bold"><span class="koboSpan" id="kobo.1076.1">SortedList</span></strong><strong class="bold"><span class="koboSpan" id="kobo.1077.1">, not a </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1078.1">set itself.</span></strong></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1079.1">Imagine a “sorted” set</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1080.1">If you want to better imagine a “sorted” set, recall the previous example related to the game of chance. </span><span class="koboSpan" id="kobo.1080.2">To facilitate manual comparison of results, both the set of randomly drawn numbers and the set of numbers selected by you can be “sorted” and shown in ascending order. </span><span class="koboSpan" id="kobo.1080.3">This is where a “sorted” set comes in handy. </span><span class="koboSpan" id="kobo.1080.4">It’s very simple and clear, don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">you think?</span></span></p>
<p><span class="koboSpan" id="kobo.1082.1">A “sorted” set can be used if you want to have a </span><strong class="bold"><span class="koboSpan" id="kobo.1083.1">sorted collection of distinct objects without duplicated elements</span></strong><span class="koboSpan" id="kobo.1084.1">. </span><span class="koboSpan" id="kobo.1084.2">The suitable class is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">SortedSet</span></strong><span class="koboSpan" id="kobo.1086.1"> and is available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">System.Collections.Generic</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1"> namespace.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1089.1">Where can you find more information?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1090.1">You can find content regarding a "sorted" set </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">at </span></span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1"><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedset-1</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1094.1">It has a set of methods, similar to those already described in the case of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">HashSet</span></strong><span class="koboSpan" id="kobo.1096.1"> class, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">UnionWith</span></strong><span class="koboSpan" id="kobo.1098.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">IntersectWith</span></strong><span class="koboSpan" id="kobo.1100.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">ExceptWith</span></strong><span class="koboSpan" id="kobo.1102.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">SymmetricExceptWith</span></strong><span class="koboSpan" id="kobo.1104.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">Overlaps</span></strong><span class="koboSpan" id="kobo.1106.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">IsSubsetOf</span></strong><span class="koboSpan" id="kobo.1108.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">IsSupersetOf</span></strong><span class="koboSpan" id="kobo.1110.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">IsProperSubsetOf</span></strong><span class="koboSpan" id="kobo.1112.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">IsProperSupersetOf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1116.1">It contains additional properties</span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.1117.1"> for returning the minimum and maximum values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">Min</span></strong><span class="koboSpan" id="kobo.1119.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1120.1">Max</span></strong><span class="koboSpan" id="kobo.1121.1">, respectively). </span><span class="koboSpan" id="kobo.1121.2">It is also worth mentioning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">GetViewBetween</span></strong><span class="koboSpan" id="kobo.1123.1"> method since it returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">SortedSet</span></strong><span class="koboSpan" id="kobo.1125.1"> instance with values from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">given range.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1127.1">What about performance?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1128.1">The “sorted” set is an interesting data structure in terms of its performance. </span><span class="koboSpan" id="kobo.1128.2">It is a kind of a trade-off between functionalities and performance. </span><span class="koboSpan" id="kobo.1128.3">Thus, checking whether the collection contains an item as well as removing any item from the collection are </span><em class="italic"><span class="koboSpan" id="kobo.1129.1">O(log n)</span></em><span class="koboSpan" id="kobo.1130.1"> operations. </span><span class="koboSpan" id="kobo.1130.2">For this reason, you should expect worse performance results compared to the data structures </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">described earlier.</span></span></p>
<p><span class="koboSpan" id="kobo.1132.1">Let’s proceed to a simple exampl</span><a id="_idTextAnchor227"/><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.1133.1">e to see how to use a “sorted” set </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">in code.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.1135.1">Example – removing duplicates</span></h2>
<p><span class="koboSpan" id="kobo.1136.1">As an example, you will create a </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.1137.1">simple application that removes duplicates from the list of names. </span><span class="koboSpan" id="kobo.1137.2">Of course, the comparison of names should be case-insensitive, so it is not allowed to have both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">Marcin</span></strong><span class="koboSpan" id="kobo.1139.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">marcin</span></strong><span class="koboSpan" id="kobo.1141.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1">same collection.</span></span></p>
<p><span class="koboSpan" id="kobo.1143.1">To do this, we can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1145.1">
List&lt;string&gt; names =
[
    "Marcin", "Mary", "James", "Albert", "Lily",
    "Emily", "marcin", "James", "Jane"
];
</span><strong class="bold"><span class="koboSpan" id="kobo.1146.1">SortedSet&lt;string&gt; sorted = new(</span></strong><span class="koboSpan" id="kobo.1147.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1148.1">names,</span></strong><span class="koboSpan" id="kobo.1149.1">
    </span><strong class="bold"><span class="koboSpan" id="kobo.1150.1">Comparer&lt;string&gt;.Create((a, b) =&gt;</span></strong><span class="koboSpan" id="kobo.1151.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.1152.1">a.ToLower().CompareTo(b.ToLower())));</span></strong><span class="koboSpan" id="kobo.1153.1">
foreach (string name in sorted)
{
    Console.WriteLine(name);
}</span></pre> <p><span class="koboSpan" id="kobo.1154.1">First, a list of names is created and initialized with nine elements, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">Marcin</span></strong><span class="koboSpan" id="kobo.1156.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">marcin</span></strong><span class="koboSpan" id="kobo.1158.1">. </span><span class="koboSpan" id="kobo.1158.2">Then, a new instance</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.1159.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">SortedSet</span></strong><span class="koboSpan" id="kobo.1161.1"> class is created and two parameters are passed to the constructor, namely the list of names and the case-insensitive comparer. </span><span class="koboSpan" id="kobo.1161.2">Finally, the collection is iterated through so that you can write names in </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">the console.</span></span></p>
<p><span class="koboSpan" id="kobo.1163.1">When you run the application, you’ll see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">following result:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1165.1">
Albert
Emily
James
Jane
Lily
Marcin
Mary</span></pre> <p><span class="koboSpan" id="kobo.1166.1">Do you know that you can use another variant of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">SortedSet</span></strong><span class="koboSpan" id="kobo.1168.1"> constructor and pass only the first parameter, namely the list, without the comparer? </span><span class="koboSpan" id="kobo.1168.2">In such a case, the default comparer will be </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.1169.1">used and will </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">be case-sensitive.</span></span></p>
<p><span class="koboSpan" id="kobo.1171.1">Congratulations – you’ve just co</span><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.1172.1">m</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1173.1">pleted the last example shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">this chapter!</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1175.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1176.1">This chapter focused on hash tables, dictionaries, and sets. </span><span class="koboSpan" id="kobo.1176.2">All of these collections are interesting data structures that can be used in various scenarios during the development of many applications. </span><span class="koboSpan" id="kobo.1176.3">By presenting such collections with detailed descriptions, performance explanations, and examples, you saw that choosing a proper data structure is not a trivial task and requires analyzing </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">performance-related topics.</span></span></p>
<p><span class="koboSpan" id="kobo.1178.1">First, you learned how to use two variants of a </span><strong class="bold"><span class="koboSpan" id="kobo.1179.1">hash table</span></strong><span class="koboSpan" id="kobo.1180.1">, namely non-generic and generic. </span><span class="koboSpan" id="kobo.1180.2">The huge advantage of these is a very fast lookup for a value based on the key, which is the close </span><em class="italic"><span class="koboSpan" id="kobo.1181.1">O(1)</span></em><span class="koboSpan" id="kobo.1182.1"> operation. </span><span class="koboSpan" id="kobo.1182.2">To achieve this goal, the hash function is used. </span><span class="koboSpan" id="kobo.1182.3">Moreover, the </span><strong class="bold"><span class="koboSpan" id="kobo.1183.1">sorted dictionary</span></strong><span class="koboSpan" id="kobo.1184.1"> was introduced as an interesting solution to solve the problem of unsorted items in the collection and to keep keys sorted all </span><span class="No-Break"><span class="koboSpan" id="kobo.1185.1">the time.</span></span></p>
<p><span class="koboSpan" id="kobo.1186.1">Afterward, the high-performance solution to </span><strong class="bold"><span class="koboSpan" id="kobo.1187.1">set operations</span></strong><span class="koboSpan" id="kobo.1188.1"> was presented. </span><span class="koboSpan" id="kobo.1188.2">A set can be understood as a collection of distinct objects without duplicated elements and without a particular order. </span><span class="koboSpan" id="kobo.1188.3">The class that was shown makes it possible to perform various operations on sets, such as union, intersection, subtraction, and symmetric difference. </span><span class="koboSpan" id="kobo.1188.4">Then, the concept of the </span><strong class="bold"><span class="koboSpan" id="kobo.1189.1">“sorted” set</span></strong><span class="koboSpan" id="kobo.1190.1"> was introduced as a sorted collection of distinct objects without </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">duplicated elements.</span></span></p>
<p><span class="koboSpan" id="kobo.1192.1">Do you want to dive deeper into the topic of data structures and algorithms while developing applications in the C# language? </span><span class="koboSpan" id="kobo.1192.2">If so, proceed to the next chapter, where </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">trees</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1194.1">are presented.</span></span></p>
</div>
</body></html>