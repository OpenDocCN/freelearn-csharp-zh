<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-180"><a id="_idTextAnchor181"/>8</h1>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor182"/>The One with the  Network Navigation</h1>
			<p><em class="italic">Building High-Performance </em><em class="italic">Networking Applications</em></p>
			<p>Software seldom lives in isolation. The same can be said, to a greater extent for system programs. Since these programs do not directly interact with the user, they rely on other software to give them input, read their output, and be told what to do. That “other software” often lives on the same machine, but just as often, that software runs elsewhere.</p>
			<p>We have so far discussed how to transfer data to and from our applications and briefly looked at networking. This chapter focuses on that specific topic: networking. Be prepared to go deeply into the world of interconnected software!</p>
			<p>In this chapter, we will go through the following topics:</p>
			<ul>
				<li>The fundamentals and the OSI layers</li>
				<li>Exploring the System.Net namespace (including the most used protocols)</li>
				<li>Working with System.Net.Sockets to have more control</li>
				<li>Asynchronous, non-blocking networking</li>
				<li>How to improve networking performance</li>
				<li>Networking errors and time-out, and how to deal with those</li>
			</ul>
			<p>We are about to break out of the box and connect to the outside world. Let’s go!</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor183"/>Technical requirements</h1>
			<p>All of the code samples for this chapter can be found at <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter08</a>.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>The fundamentals</h1>
			<p>We have already talked about the OSI model. But just as a quick refresher, the OSI model defines the layers that make up the system, allowing us to communicate with other systems. The layers span from the lowest layer, which describes the voltages a network adapter should be able to handle, up to the highest level, which describes the application that uses networking.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>A walk down the OSI layers</h2>
			<p>I want to<a id="_idIndexMarker586"/> walk you through all the layers again, detailing what happens in each. To do this, I want to discuss a user using FTP to send <a id="_idIndexMarker587"/>data. <strong class="bold">FTP</strong>, which stands for <strong class="bold">File Transfer Protocol</strong>, is an older, hardly used technique to send data to remote machines or to get data from those remote machines.</p>
			<p>FTP used to be the best way to achieve that, but the lack of security features made people move to other means. We will discuss some of those later, but we can still use FTP for our walk-down of the OSI model. It makes things a bit easier to understand.</p>
			<p>An FTP client can be as simple as a console application. Actually, almost all FTP clients are just that. There are GUI-based clients, but they act as wrappers around the FTP commands.</p>
			<p>To transfer a file, a user fires up the FTP client, specifies the server to connect to, and optionally passes in the credentials. Then, the user uses commands such as <code>GET</code> and <code>PUT</code> to transfer the file. Another command is <code>LS</code>, which is used to get the contents of a remote directory. We also have <code>MKDIR</code> to create a remote directory and other such commands.</p>
			<p>So, let us assume that the user is sitting at their machine and wants to log in to the remote computer. To do that, the user types <code>ftp username:password@127.0.0.1</code> at the command prompt. This does a few things:</p>
			<ol>
				<li>It starts up the command-line version of FTP</li>
				<li>Then it tells it to connect to a computer found at address 127.0.0.1 (which is, as you probably remember, localhost)</li>
				<li>It supplies a username and a password that the server needs.</li>
			</ol>
			<p>After a few<a id="_idIndexMarker588"/> seconds, the client lists all files in the requested location. But what happens in the computer when the user presses the <em class="italic">Enter</em> key?</p>
			<p>After starting the application, the FTP client takes over.</p>
			<p>The commands and data flow through the OSI levels. Let me show you what happens:</p>
			<ul>
				<li><strong class="bold">Layer 7</strong>: The application runs on OSI level 7, the application level. The FTP protocol in the application then sets up the connection. FTP creates two connections: one for control commands and one for data transfer.</li>
				<li><code>open</code> command is translated from whatever string format it was into an 8-bit ASCII format. If encryption is needed, that is also taken care of here. After all, layer 6 is all about how to present the data.</li>
				<li><strong class="bold">Layer 5</strong>: The session layer then takes over. This layer is where the actual connection to the remote machine is made. This layer keeps an eye on the connection to make sure it is reliable and stable. It also closes the connection when it is no longer needed.</li>
				<li><strong class="bold">Layer 4</strong>: After that, the transport layer makes sure the data containing the command is broken into smaller packets and sends them out in the correct order. FTP uses TCP, meaning layer 4 is responsible for rearranging data packets that are out of order when data is received. Error checking is also something that happens here.</li>
				<li><strong class="bold">Layer 3</strong>: The network layer is where the <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) lives. This protocol in layer 3 is responsible for finding the best route to the remote machine. It also handles packet forwarding and rerouting.</li>
				<li><strong class="bold">Layer 2</strong>: Then, we <a id="_idIndexMarker589"/>get to the data link layer. This layer adds data to the packets, such as the MAC address of the next machine the data needs to get to. It is responsible for node-to-node communication. If you use Wi-Fi, this layer prepares the data to be sent over the radio waves.</li>
				<li><strong class="bold">Layer 1</strong>: Finally, we reach the physical layer. This last layer is where the data is actually transmitted. This layer translates the data into radio signals if you use Wi-Fi. It deals with all the hardware issues, such as the frequencies used and the strength of the signal.</li>
			</ul>
			<p>Luckily, most of this is done at the OS or BIOS level. We do not have to worry about frequencies when setting up a network connection. We usually deal with <strong class="bold">layers 7</strong> and <strong class="bold">6</strong>, and sometimes <strong class="bold">5</strong>. We write the application (<strong class="bold">layer 7</strong>). We define the presentation (<strong class="bold">layer 6</strong>) if we have our own protocol. And we might sometimes have to worry about the actual connections, so we deal with <strong class="bold">layer </strong><strong class="bold">5</strong> occasionally.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The BCL and the CLR have many classes, tools, and helpers, allowing us to focus on the fun without worrying about the details. But sometimes, as system programmers, we must worry about those details. These details can be the difference between a great, fast, and stable system and a mediocre one. But do not worry: we cover it all here in this chapter!</p>
			<p>Before we can do that, let us look at commonly used ways to transmit data over a network.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Exploring the System.Net namespace</h1>
			<p>Chances are, if you <a id="_idIndexMarker590"/>need a way to transmit data, someone else has already figured out the best way to do this.</p>
			<p>For instance, you could write all the code to transfer a file to and from a machine or use FTP and rely on existing software.</p>
			<p>In fact, there are<a id="_idIndexMarker591"/> many ways to transfer data. Many of those ways are so standardized that they are part of the BCL. You can use them without dealing with third-party NuGet packages. Let us discuss some of the offerings in the System.Net namespace and see what we can do with them.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>Understanding HTTP/HTTPS</h2>
			<p>HTTP was <a id="_idIndexMarker592"/>the protocol that enabled millions of users to finally use the internet. Before HTTP, the only way to exchange data was through technically complicated protocols, most of which had to be controlled through the command line. When Sir Tim Berners-Lee published his ideas about the World Wide Web and the <a id="_idIndexMarker593"/>accompanying <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), people with little or no technical background could also use the net. Web browsers made it easy to go around and find information. Of course, when I say easy, I mean easier than before. In the early 1990s, we had no Google or Bing, so finding interesting sites was a struggle compared to today.</p>
			<p><em class="italic">HTTP democratized the internet</em>. Before that, it was the realm of scientists and the military, with a few nerds sprinkled in for good measure. Yes, I was one of those nerds: I first used the internet through SMTP, Gopher, FTP, and Usenet in 1987. HTTP and the WWW made it all so much easier.</p>
			<p>Programming for it was not that easy. However, with the current frameworks, getting data from an arbitrary site anywhere on the globe only takes a couple of lines of code. Let me show you:</p>
			<pre class="source-code">
using var client = new HttpClient();
try
{
    string url =
        "https://jsonplaceholder.typicode.com/posts";
    HttpResponseMessage response =
        await client.GetAsync(url);
    response.EnsureSuccessStatusCode();
    string responseBody =
        await response.Content.ReadAsStringAsync();
    responseBody.Dump(ConsoleColor.Cyan);
}
catch(HttpRequestException ex)
{
    ex.Message.Dump(ConsoleColor.Red);
}</pre>			<p>In the <a id="_idIndexMarker594"/>first line, we<a id="_idIndexMarker595"/> create an instance of the <code>HttpClient</code> class. This class is a helpful little helper: it takes away much of the complexity of the older <code>HttpWebRequest</code>. Although <code>HttpWebRequest</code> does offer some advantages over <code>HttpClient</code> (for instance, more control over the headers, the option to set time-outs, and the ability to use synchronous data transfers if needed), <code>HttpClient</code> is by far the better choice.</p>
			<p class="callout-heading">Testing with dummy servers</p>
			<p class="callout">If you want to play around with HTTP and HTTPS, you need a reliable and easy-to-use website to connect to. The <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> URL is a great site to use in those cases. It gives you several endpoints to connect to, read from, and send data to. It is simple to use, and it is free. Please have a look at that site to see what it offers.</p>
			<p>After declaring the URL, we call the <code>GetAsync</code> method with that URL. This asynchronous operation returns an instance of the <code>HttpResponseMessage</code> class. That class contains all we need to read the data from the remote server.</p>
			<p>The next call is just a shorthand for some straightforward error checking. Calling <code>EnsureSuccessStatusCode</code> does very little besides looking at the return code from the server, and it throws an error if it is not in the 200 range. As you probably know, HTTP requests return a numeric status code that tells you what the result of the call is. Everything between 200 and 299 means your call worked. Codes such as 404 mean the site is unreachable, and so on.</p>
			<p>This single method makes your code much more readable than <code>if</code> statements.</p>
			<p>If all is okay, we continue by reading the actual data. The response has several properties, one of which is <code>Content</code>. Other properties are the status code, the headers, and so on.</p>
			<p><code>Content</code>, of type <code>HttpContent</code>, is a wrapper around <code>Stream</code> that allows us to read data from the<a id="_idIndexMarker596"/> server. In our case, we call <code>ReadAsStringAsync</code>, which takes all data the server can give us and returns that to us as a string. Of course, this all happens asynchronously.</p>
			<p>Finally, we display that string on the console.</p>
			<p>This is the <a id="_idIndexMarker597"/>simplest example of using HTTP I can think of. All classes shown here have many more use cases, methods, and helpers that can benefit you. I suggest you look at the documentation of <code>HttpClient</code>, <code>HttpResponseMessage</code>, <code>HttpContent</code>, and the rest to see what else you can do with them. In the meantime, let’s look at some other protocols.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor188"/>FTP</h2>
			<p>We saw <a id="_idIndexMarker598"/>FTP before. I used it to illustrate the flow of actions through the OSI model. But we never thoroughly explored what we can do with it.</p>
			<p>FTP is an older <a id="_idIndexMarker599"/>technology. It is not in use that much anymore, but it is still beneficial. It is a quick, easy-to-understand technology to transfer files between machines and control remote file systems, regardless of the underlying operating system. It is fast and reliable. Most operating systems support FTP both as a client and as a server.</p>
			<p>In Windows, you can enable the FTP server by going to the <strong class="bold">Program and Features</strong> section of the settings in the control panel, and there, under <strong class="bold">Internet Information Services</strong>, you can see the option to install the FTP server. Alternatively, you can click <em class="italic">Win</em> + <em class="italic">R</em> and then enter the optional features. See <em class="italic">Figure 8</em><em class="italic">.1</em> to see what it looks like.</p>
			<div><div><img alt="Figure 8.1: Installing FTP Server on Windows" src="img/B20924_09_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Installing FTP Server on Windows</p>
			<p>However, make<a id="_idIndexMarker600"/> sure you know what you are doing. One of the<a id="_idIndexMarker601"/> reasons we do not use FTP that much anymore is that it is not secure by default. To transfer files, it would be better to use something such as SFTP, which is a secure version.</p>
			<p>But good old FTP is still your friend if you want to communicate in a secure environment (such as in a Kubernetes cluster) and transfer files quickly and easily.</p>
			<p>So, how do you read the contents of a remote directory? Simple: use this piece of code!</p>
			<pre class="source-code">
public static void FetchDirectoryContents(string ftpUrl, string username, string password)
{
    var request = (FtpWebRequest) WebRequest.Create(ftpUrl);
    request.Method = WebRequestMethods.Ftp.ListDirectoryDetails;
    request.Credentials = new NetworkCredential(username, password);
    try
    {
        using (var response = (FtpWebResponse) request.GetResponse())
        {
            using (var streamReader = new StreamReader(response.GetResponseStream()))
            {
                var line = string.Empty;
                while ((line = streamReader.ReadLine()) != null)                   Console.WriteLine(line);
            }
            $"Directory List Complete, status {response.               StatusDescription}".Dump(ConsoleColor.Cyan);
        }
    }
    catch (WebException ex)
    {
        var status = ((FtpWebResponse) ex.Response).StatusDescription;
        $"Error: {status}".Dump(ConsoleColor.Red);
    }
}</pre>			<p>As you can see, the code here is pretty straightforward. We create an instance of <code>WebRequest</code> and cast it to a subclass: <code>FtpWebRequest</code>. We specify what we want to do by setting the method to <code>ListDirectoryDetails</code>. We add some credentials if needed and <a id="_idIndexMarker602"/>get a stream containing the data we need. Of course, we handle exceptions as well.</p>
			<p>Great! But wait… this is actually not so great.</p>
			<p>If you do this in your <a id="_idIndexMarker603"/>editor, you will see warnings: <code>WebRequest</code> (and thus <code>FtpWebRequest</code>) has been marked obsolete. They have been superseded by the much better <code>HttpClient</code>. Unfortunately, that one cannot be used with FTP sites: it is only meant for HTTP traffic.</p>
			<p>I believe Microsoft made a mistake here. But it is their framework, so they can do what they want. The good news is that plenty of NuGet packages can do what we want them to do. One is <em class="italic">FluentFtp</em>, which you can find at the <a href="https://github.com/robinrodricks/FluentFTP">https://github.com/robinrodricks/FluentFTP</a> URL. Here, I would like to mention that I am not affiliated with this or any other NuGet package I mention in this book; these are just the packages I use. Of course, many different options are available, so just pick whatever works for you.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>Email protocols</h2>
			<p>HTTP is<a id="_idIndexMarker604"/> the most used protocol on the public-facing internet, both in the number of servers handling it and in the percentage of data dealt with. But second to <a id="_idIndexMarker605"/>that is SMTP. <strong class="bold">SMTP</strong>, which stands for <strong class="bold">Simple Mail Transfer Protocol</strong>, is used <a id="_idIndexMarker606"/>for email. SMTP is just one of the protocols related to emails. Let’s look into each one of those:</p>
			<ul>
				<li><strong class="bold">SMTP</strong>: The Simple Mail Transfer Protocol is <a id="_idIndexMarker607"/>used to send mail over the Internet. It is connection-oriented, meaning its primary task is to ensure a connection between the client sending the mail and the server processing it. It is reliable (meaning it can be recovered if data is lost in transit).</li>
				<li><strong class="bold">POP3</strong>: POP3 is<a id="_idIndexMarker608"/> the third iteration of the <strong class="bold">Post Operation Protocol</strong>. This<a id="_idIndexMarker609"/> protocol deals with the other side: SMTP ensures the mail gets delivered to the server, and POP3 allows the users to read their mail from the server. POP3 allows for offline access to email, but<a id="_idIndexMarker610"/> it can only access one mailbox at a time. If you want to read multiple mailboxes (or accounts, if you will), you need to set up more than one POP3 connection.</li>
				<li><strong class="bold">IMAP</strong>: IMAP<a id="_idIndexMarker611"/> stands for <strong class="bold">Internet Message Access Protocol</strong>. This<a id="_idIndexMarker612"/> protocol is also meant to read mail from the server. But this protocol can read multiple mailboxes in one go. IMAP can access, search, manipulate, and delete your emails without downloading them. It can send these commands to the server in an RPC way (we discussed RPC extensively in <a href="B20924_08.xhtml#_idTextAnchor159"><em class="italic">Chapter 7</em></a>).</li>
				<li><strong class="bold">MIME</strong>: Despite <a id="_idIndexMarker613"/>not having a P at the end of the acronym, <strong class="bold">MIME</strong> is also a protocol. It is<a id="_idIndexMarker614"/> the acronym for <strong class="bold">Multipurpose Internet Mail Extension</strong> protocol. As the name suggests, it is an extension, allowing us to have attachments, multimedia, and non-ASCII characters in our mail messages.</li>
			</ul>
			<p>All these protocols enable us to have a functional, complete mail experience.</p>
			<h3>Sending an email</h3>
			<p>That<a id="_idIndexMarker615"/> being said, most software sends mail messages; it hardly ever reads them. So, let’s look at a simple sample of how to send an email in code. The sample code I provide consists of three parts. Let’s look at them:</p>
			<pre class="source-code">
using System.Net.Mail;
// Create the mail message
MailMessage mail = new MailMessage();
mail.From = new MailAddress("dennis@vroegop.org");
mail.To.Add("dearreader@thisbook.com");
mail.Subject = "Hi there System Programmer!";
mail.Body =
    "This is a test email from the System Programming
      book.";</pre>			<p>Obviously, we need a message. Otherwise, why would we connect to an SMTP server?</p>
			<p>The message is of type <code>MailMessage</code>. It needs a sender, and it can have multiple recipients. Those recipients can be in the <code>To</code>, <code>CC</code>, or <code>BCC</code> fields. <code>To</code>, <code>CC</code>, and <code>BCC</code> are all lists, so you can add multiple recipients. Of course, you need to supply at least the <code>To</code> recipients.</p>
			<p>We can<a id="_idIndexMarker616"/> supply a <code>Subject</code> field. I would really encourage you to do that, of course. Then we have a <code>Body</code>, which contains the message we want to send.</p>
			<p>Once we have the message, we can create an instance of the <code>SmtpClient</code> class.</p>
			<p>You need to have access to a real SMTP server, of course. Most internet service providers have them, so please look up how to connect to them in their documentation. You usually need a username and password to authenticate yourself. In the old days,  there were anonymous servers, but in these days of spam, those are very hard to find.</p>
			<p>We have to specify the server’s address and port (port <code>25</code> is the old port; port <code>587</code> is the new, secure one, and the preferred port to use), and you can specify whether you want to use SSL. That code looks like this:</p>
			<pre class="source-code">
// Set up the connection to the SMTP server
// And no, this is NOT a valid SMTP server. Use your own :)
SmtpClient client =
    new SmtpClient("smtp.vroegop.org");
client.Port = 587;
client.EnableSsl = true;
client.Credentials =
    new System.Net.NetworkCredential(
        "dennis@vroegop.org",
        "MySuperSecretPassword");</pre>			<p>And finally, we can send the message!</p>
			<pre class="source-code">
// Send the email!
client.Send(mail);</pre>			<p>Once you have <a id="_idIndexMarker617"/>set up the client, you can send multiple messages using that same client instance. You do not have to worry about setting up connections. You can just call <code>Send</code>, and it all works.</p>
			<h3>Sending HTML messages</h3>
			<p>The <a id="_idIndexMarker618"/>previous example works fine, but the message is kind of bland. These days, messages are much more colorful and pleasant to look at. The way to do that is to send an HTML message. You can do that by just putting HTML in the <code>Body</code> field and setting the <code>IsBodyHtml</code> property of <code>MailMessage</code> to true. But that is not the best way to do that for the following two reasons:</p>
			<ul>
				<li>Not all clients support HTML. The readers must decipher the HTML to find the body text if their client does not support HTML.</li>
				<li>Messages only containing HTML are usually marked as spam.</li>
			</ul>
			<p>The best way to do this is to combine your beautifully crafted HTML body and a more down-to-earth plain text body. You can do that by using the <code>AlternateView</code> class. The code to create the mail message looks like this:</p>
			<pre class="source-code">
var multipartMail = new MailMessage();
multipartMail.From = new MailAddress("dennis@vroegop.org");
multipartMail.To.Add("dearreader@thisbook.com");
multipartMail.Subject = "Hi there System Programmer!";
var htmlBody = "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hi there System Programmer!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;";
var htmlView =
    AlternateView.CreateAlternateViewFromString(
        htmlBody,
        null,
        "text/html");
var plainView =
    AlternateView.CreateAlternateViewFromString(
        "This is a test email from the System Programming book.",
        null,
        "text/plain");
multipartMail.AlternateViews.Add(plainView);
multipartMail.AlternateViews.Add(htmlView);</pre>			<p>We<a id="_idIndexMarker619"/> create an instance of the regular <code>MailMessage</code> class. Most of the fields are the same. But we do not specify a body. Instead, we create two instances of the <code>AlternateView</code> class by calling the <code>CreateAlternateViewFromString</code> static method. That method takes the content we want to send (either HTML or plain text) and the encoding we use (we set it to <code>NULL</code>, so it uses the default setting for your machine). We do have to specify the content type. The first contains <code>"text/html"</code>  and the second contains <code>"text/plain"</code>.</p>
			<p>We then add both parts to the <code>MailMessage</code> instance, and we can send it.</p>
			<p>The rest of the code stays the same.</p>
			<p>That covers some of the higher-level classes. It is now time to go deeper into the rabbit hole.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor190"/>Working with the System.Net.Sockets namespace</h1>
			<p>The <a id="_idIndexMarker620"/>default protocols are fantastic. They take away a lot of manual work. We do not have to program the HTTP protocol ourselves; we can focus on the content instead. The same goes for SMTP, POP3, and all the other protocols out there. You can find a class or a NuGet package if the protocol you want to use is popular enough.</p>
			<p>But of course, sometimes you cannot find that package. Sometimes, you want to write your own protocol. In that case, you have to do all the hard work yourself. But, I have to be honest, I immensely enjoy doing that. There is something nice about writing my protocol, deploying it in my apps, and seeing them work together. And even if you do not enjoy this, there are cases where you have no choice.</p>
			<p>The good news<a id="_idIndexMarker621"/> is that the good people who wrote the BCL have already done much of the underlying work.</p>
			<p>In <a href="B20924_07.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, we encountered the <code>Socket</code> class when we discussed how systems can communicate. Sockets were mentioned as one of the options. We wrote a simple chat application that uses TCP/IP to communicate. TCP/IP is one of the ways sockets can connect.</p>
			<p>In the chat sample I mentioned, we created instances of the <code>TcpListener</code> and <code>TcpClient</code> classes. These classes are wrappers around the more generic <code>Socket</code> class. They are specifically used for TCP/IP connections and handle much of the plumping needed to get this to work.</p>
			<p>You can use sockets yourself, of course. That means you must do much of the work yourself, giving you more control over what happens.</p>
			<p>You can use sockets with TCP and UDP connections. We looked at the differences in <a href="B20924_07.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, so we won’t compare them again here. However, you should use the <code>Socket</code> class if you want to use UDP: obviously, <code>TCPClient</code> will not work. By the way, there is also a <code>UdpClient</code> class, with which you can achieve the same result. However, I want you to be aware of the inner workings. That is why I am going with <code>Sockets</code> here.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>Steps to take when using sockets</h2>
			<p>When <a id="_idIndexMarker622"/>working with sockets, you need to take a number of steps:</p>
			<ol>
				<li>Choose the right socket. You can use stream sockets. Stream sockets are based on the TCP protocol. It is a reliable, connection-oriented protocol. But you can also choose datagram sockets. These are based on the UDP protocol. They are connectionless, fire-and-forget ways of communicating. It is quick, but you have no guarantee the data will reach the intended recipient.</li>
				<li>Then, you create the socket. You specify the kind of address you want to use (IPV4 or IPV6), the type of socket (stream or datagram), and the protocol (TCP or UDP).</li>
				<li>It’s time<a id="_idIndexMarker623"/> to connect. You either listen to incoming connections or connect to a server somewhere. When you connect to a remote server, you must specify the IP address and the port. If you are listening, you need the port at least, and if you have more network connections, you might want to specify the IP address you are listening to.</li>
				<li>Sending and receiving data. After all, that’s what we are here for, right?</li>
				<li>When you are done, you must be sure to close the connection. You do not want to hold on to a connection for too long: you might get in the way of other applications.</li>
			</ol>
			<p>And that is all there is to it. If I put it like this, it seems straightforward, doesn’t it? Well, the devil is in the details!</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>IPv4 and IPv6</h2>
			<p>We need to talk a <a id="_idIndexMarker624"/>bit about the IP address. The <strong class="bold">IP</strong> address, which stands for <strong class="bold">Internet Protocol</strong> address, is a unique number identifying a network device. It is unique within boundaries, but we will discuss that later. There are two kinds of addresses we can use: IPv4 and IPv6. As you might have guessed, these acronyms are Internet Protocol version 4 and version 6, respectively.</p>
			<p>The first publicly used version was IPv4. IPv5 never saw the light of day, leaving us with two versions. It has always been the idea to replace IPv4 with IPv6 completely, but it seems IPv4 will stay around for a bit longer.</p>
			<p>An IPv4 address consists of 4 bytes, thus making it 32 bits long. This size means that there are about 4.3 billion unique addresses in theory. In practice, there are fewer since many ranges are reserved. We have already encountered one of them: the address is <code>127.0.0.1</code>. This is the address of the device itself.</p>
			<p>Although different <a id="_idIndexMarker625"/>systems can reserve different port ranges, there is a common understanding of what ranges we should avoid using or what ranges we can use. These ranges are explained like this:</p>
			<ul>
				<li><strong class="bold">Port 0 – 1023</strong>: Well-known ports. These ports are used everywhere and you should not use them yourself.</li>
				<li><code>1433</code>, which is used by SQL Server. However, these are not as strictly assigned as the range <code>0</code> – <code>1023</code>.</li>
				<li><strong class="bold">Port 49152 – 65535</strong>: This range is known as the dynamic or private range. They are usually used for ephemeral or short-lived communications. They are, most of the time, dynamically allocated by the operating system.</li>
			</ul>
			<p>Just make sure the port you pick is not yet in use on your intended system!</p>
			<p>An IPv6 address comprises 8 sets of 2-byte structures, making it 128 bits in length. You can fit substantially more addresses in that address space: there are about 340 undecillion unique addresses.</p>
			<p class="callout-heading">Big numbers</p>
			<p class="callout">Working with computers means you sometimes run into big numbers. This is such a case: an undecillion is 10 to the power of 36. That means the number is 340, followed by 36 zeros. That’s a lot of addresses.</p>
			<p>The IPv6 address is displayed as a sequence of 8 sets of 16-bit hexadecimal values. For instance, a valid address could look like this: <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code>.</p>
			<p>This is also an interesting address: <code>0000:0000:0000:0000:0000:0000:0000:0001</code>. This is the IPv6 version of 127.0.0.1. In other words, this is localhost. However, it is pretty long: there are 7 sets of <code>0000</code>. With IPv6 we can omit a range of <code>0000</code> values with two colons. So we can shorten the address for localhost to ::1.</p>
			<p>Both in IPv4 and IPv6, we have reserved ranges. For instance, everything in the range <code>192.168.0.0</code> up to <code>192.168.255.255</code> is used for internal networks. You cannot, however, assign these addresses to devices facing the public network. The same goes for the addresses <code>10.0.0.0 to 10.255.255.255</code> and <code>172.16.0.0 </code><code>to 172.31.255.255</code>.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor193"/>Looking up time with sockets</h2>
			<p>It is time to look at how to do all this for real.</p>
			<p>There <a id="_idIndexMarker626"/>are servers out there that work as time servers. These servers have one purpose: wait for your connection and then respond with the current date and time. The way they do this is pretty interesting: they calculate the time it takes to send a response and adjust the time accordingly, thus making sure the answer is as accurate as possible.</p>
			<p>Let’s look at some code:</p>
			<pre class="source-code">
public DateTime GetNetworkTime(string ntpServer = "pool.ntp.org")
{
    // NTP message size - 16 bytes (RFC 2030)
    var ntpData = new byte[48];
    // Setting the Leap Indicator, Version Number and Mode values
    ntpData[0] = 0x23; // LI, Version, Mode
    var addresses = Dns.GetHostEntry(ntpServer);
    var ipEndPoint = new IPEndPoint(addresses.AddressList[0], 123);       // NTP uses port 123
    using (var socket = new Socket(AddressFamily.InterNetwork,       SocketType.Dgram, ProtocolType.Udp))
    {
        socket.Connect(ipEndPoint);
        socket.Send(ntpData);
        socket.Receive(ntpData);
        socket.Close();
    }
    return ConvertNtpTimeToDateTime(ntpData);
}</pre>			<p>The <a id="_idIndexMarker627"/>method starts with a default value for the name of the server. We use <a href="http://pool.ntp.org">pool.ntp.org</a> as our server, but there are many more out there that would do the trick. They all use the NTP protocol (<strong class="bold">NTP</strong> means <strong class="bold">Network Time Protocol</strong>, in <a id="_idIndexMarker628"/>case you were wondering). NTP is one of the oldest protocols. Systems used this protocol to synchronize the clocks of computers over a network as far back as the early 80s!</p>
			<p>The address we use, <code>pool.ntp.org</code>, is not a single computer but a pool of thousands of NTP servers, ensuring everybody can get their time. However, we can treat it as a single server. Oh, one word of warning: that URL is meant to be used by NTP clients. They use port <code>123</code>, as you can see in the code. If you use your browser to go to that address, you automatically use HTTP and thus port <code>80</code> (there is no HTTPS server at that address). This means you get to see whatever the maintainers of that pool want to put there. Do not use your browser to go to that URL; use port <code>123</code> as it is intended!</p>
			<p>A request to the NTP server needs a buffer of 48 bytes to hold the answer. We need to add some data in that buffer when we connect to the server, telling it what we want. In our case, we give it the value 0x23. This byte consists of 3 groups of bits, each group telling the server something about what we want. Look at the following table to see what these bits mean:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-8">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Bits</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>6– 7</p>
						</td>
						<td class="No-Table-Style">
							<p>Leap Indicator</p>
						</td>
						<td class="No-Table-Style">
							<p>Indicates whether we want to take the leap seconds a month might have into account. 0 means no adjustment, 1 means the last minute of the month has 61 seconds, 2 means the last minute of the month has 59 seconds, and 3 means the clock is unsynchronized.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>4-6</p>
						</td>
						<td class="No-Table-Style">
							<p>Version</p>
						</td>
						<td class="No-Table-Style">
							<p>The version of the protocol we want to use. The latest version is 4.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>0-3</p>
						</td>
						<td class="No-Table-Style">
							<p>Mode</p>
						</td>
						<td class="No-Table-Style">
							<p>0: Reserved</p>
							<p>1: Symmetric active</p>
							<p>2: Symmetric passive</p>
							<p>3: Client</p>
							<p>4: Server</p>
							<p>5: Broadcast</p>
							<p>6: NTP control message</p>
							<p>7: Reserved</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1: Settings for NTP servers</p>
			<p>We do not <a id="_idIndexMarker629"/>want to use leap adjustment. We are interested in using protocol version 4. And we are a client here. That means we have to do some bit-arithmetic. Working down from the most significant bits to the least significant bits, we get 00 for bits 6 and 7, 100 for bits 4, 5, and 6, and finally, 011 for bits 0 through 4. If we combine this, we get 0010 0011, or 23 in decimal.</p>
			<p>We place that value in the first byte in the 48-byte long buffer we shall give to the server.</p>
			<p>We have the name of the NTP server (<code>pool.ntp.org</code>), but we need the actual IP address of that machine. After all, sockets need an address and not a string of text. The <code>var addresses = Dns.GetHostEntry(ntpServer);</code>, I get 4 IP addresses back.</p>
			<p>We take the first address we got back and construct an instance of an <code>IPEndPoint</code> class with that address and port <code>123</code>.</p>
			<p>Then, we can create an instance of the <code>Socket</code> class. We give it the <code>AddressFamily</code> <code>InterNetwork</code>, meaning we want to use IPv4 addresses. We also specify that we’ll use a datagram, and thus, we use UDP.</p>
			<p class="callout-heading">Mixing streams, datagrams, TCP, and UDP</p>
			<p class="callout">You must specify what socket type and protocol type you want to use. However, if you use <code>SocketType.Stream</code>, you must also use <code>ProtocolType.TCP</code>. And if you want to use <code>SocketType.DGram</code>, you must also use <code>ProtocolType.UDP</code>. If you try to mix these (you want datagram over TCP, for instance), you get an exception during runtime. So, be careful what you choose.</p>
			<p>We call <code>connect</code> on <a id="_idIndexMarker631"/>the socket, giving it the endpoint we created. After that, we send the server our 48-byte buffer containing information about <code>leap</code>, <code>version</code>, and <code>mode</code>. Next, we try to get an answer by calling <code>Receive</code>, using that same buffer.</p>
			<p>Of course, when we get the answer, we close the connection.</p>
			<p>Once the answer is received and safely stored in our buffer, we can do some calculations to transform the data into something we can use in a <code>DateTime</code> structure. That specific piece of code we call contains conversions between different formats, swapping bits, and more. They have nothing to do with getting data from a server, so I leave it out. The sample on GitHub has that code, so please check that out if you want to see what that looks like.</p>
			<p>The code that deals with the socket was not that complicated. But there is a problem with this code. It is what we call <strong class="bold">blocking code</strong>. It <a id="_idIndexMarker632"/>blocks the entire thread for the duration of the call to the NTP server. Let’s fix that.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor194"/>Async, non-blocking networking</h1>
			<p>It should be evident by now <a id="_idIndexMarker633"/>that you must ensure that all non-instantaneous operations in your code are a potential performance issue. Slow operations can <a id="_idIndexMarker634"/>block a process from continuing. File I/O is one of the areas where this is appropriate. Networking is even slower than that. So, everything that we can do asynchronously should be implemented that way.</p>
			<p>The good news is that most classes dealing with networking have asynchronous versions of their methods. The bad news is that for <code>Socket</code>, it is not as straightforward as you might have hoped. But do not worry: we will tackle this soon!</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Making asynchronous calls</h2>
			<p>In the<a id="_idIndexMarker635"/> previous sample, we used the static <code>Dns</code> class to get information about the address of the NTP server. We called <code>GetHostEntry()</code>, which is a synchronous blocking call. We can fix that quite easily: <code>Dns</code> has asynchronous versions of those methods. We can rewrite the call to look like this:</p>
			<pre class="source-code">
var addresses = await Dns.GetHostEntryAsync(ntpServer);</pre>			<p>Of course, the signature of the method needs to change as well. Instead of having this method declaration: <code>public DateTime GetNetworkTime(string ntpServer = "</code><code>pool.ntp.org")</code>.</p>
			<p>We change it into this:</p>
			<p><code>public async Task&lt;DateTime&gt; GetNetworkTimeAsync(string ntpServer = "</code><code>pool.ntp.org")</code></p>
			<p>We made it <code>async</code>, changed the return type to <code>Task&lt;DateTime&gt;</code> instead of <code>DateTime</code>, and renamed the method to have the <code>Async</code> postfix.</p>
			<p>That was simple enough. We can do the same for the code working with <code>Socket</code>. This is the full method:</p>
			<pre class="source-code">
public async Task&lt;DateTime&gt; GetNetworkTimeAsync(string ntpServer = "pool.ntp.org")
{
    // NTP message size - 16 bytes (RFC 2030)
    var ntpData = new byte[48];
    // Setting the Leap Indicator, Version Number, and Mode values
    ntpData[0] = 0x23; // LI, Version, Mode
    var addresses = await Dns.GetHostEntryAsync(ntpServer);
    var ipEndPoint = new IPEndPoint(addresses.AddressList[0], 123);       // NTP uses port 123
    using (var socket = new Socket(
               AddressFamily.InterNetwork,
               SocketType.Dgram,
               ProtocolType.Udp))
    {
        await socket.ConnectAsync(ipEndPoint);
        await socket.SendAsync(
            new ArraySegment&lt;byte&gt;(ntpData),
            SocketFlags.None);
        await socket.ReceiveAsync(
            new ArraySegment&lt;byte&gt;(ntpData),
            SocketFlags.None);
    }
    return ConvertNtpTimeToDateTime(ntpData);
}</pre>			<p>This version<a id="_idIndexMarker636"/> takes advantage of the async/await pattern, so the calls to the server do not block the threads.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Networking code should always use asynchronous methods instead of synchronous ones. Networking is slow compared to the raw speed of the CPU and the local machine, so why waste time waiting on that slow trickle of data from the network adapter?</p>
			<p>However, there are ways to improve the performance of your system when you use networking. Let’s look at those next.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor196"/>Networking performance</h1>
			<p>Since networking<a id="_idIndexMarker637"/> is comparatively slow, we have to be smart about ways to improve the throughput of the data. We can control local networks, ensuring we have optic fiber and super-fast routers everywhere, but that does not solve the issues. Even the fastest physical network is way slower than data handled in the CPU. Of course, having fast hardware helps. But it only helps on our own network: we cannot control the hardware on other networks. We must be wise in our code to get the most out of our networking. Once again, it all comes down to us, the developers!</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Connection pooling</h2>
			<p>A connection represents <a id="_idIndexMarker638"/>an open line between a client and a server. Let’s look at the following line of code:</p>
			<pre class="source-code">
var client = new TcpClient("my.server.com", 123);</pre>			<p>This single line of code is simple enough: this creates a connection to a server called <code>my.server.com</code> on port <code>123</code> and returns the open connection. Fine. We’ve seen that before. But let me show you what happens when you run that line of code:</p>
			<ul>
				<li><code>my.server.com</code> string into the correct IPv4 or IPv6 addresses we can use.</li>
				<li><code>Socket</code> class is instantiated, allocating the memory for it and ensuring it is available.</li>
				<li><code>SYN</code> is sent to the server. Basically, the client is asking, “Hey, can we talk?”</li><li class="upper-roman"><code>SYN</code> message comes in, it responds with <code>SYN-ACK</code>, acknowledging that it is ready to talk.</li><li class="upper-roman"><code>SYN-ACK</code>, that apparently the network works fine, and that they can talk.</li></ol></li>
			</ul>
			<p>When all this <a id="_idIndexMarker639"/>has happened, the communication line is open and ready for use. We can start sending and receiving data.</p>
			<p>As you can see, a lot of work is involved in that simple line of code. You can imagine that the handshaking between the client and the server takes a lot of time. Network connections are expensive!</p>
			<p>There is no getting around this. These steps need to be taken. But there is no reason to do them more than you need to. If you have a connection to a server, you might reuse it as well. We call that connection pooling. We create a pool of connections, and whenever something in our system needs to talk to the server, we return the already-created connection.</p>
			<p>Unfortunately, the BCL does not have a class for this. But it is not too hard to write one yourself. You could do it like this.</p>
			<p>We create a class called <code>TcpClientConnectionPool</code>. The signature looks like this:</p>
			<pre class="source-code">
internal class TcpClientConnectionPool : IAsyncDisposable{}</pre>			<p>We have three methods in that class:</p>
			<pre class="source-code">
public TcpClient? GetConnection(){}
public void ReturnConnection(TcpClient? client) {}
public async ValueTask DisposeAsync(){}</pre>			<p>Before we look at what those methods do, we need to create two private fields in the class:</p>
			<pre class="source-code">
private readonly ConcurrentBag&lt;TcpClient?&gt; _availableConnections = new();
private readonly int _maxPoolSize = 10; // Example pool size</pre>			<p>When you create a pool to hold objects, you need a place to store them. We use <code>ConcurrentBag&lt;T&gt;</code> here. <code>ConcurrentBag</code> is a thread-safe collection that has the following characteristics:</p>
			<ul>
				<li><strong class="bold">Thread safe</strong>: You can add, access, and remove objects without worrying about locks or other threads running amock. This class handles the details for you.</li>
				<li><strong class="bold">Unordered</strong>: There is no specific order. In our case, this is just fine. However, if you want to use something like FIFO, you should use a class with an order built in.</li>
				<li><strong class="bold">Duplicates are allowed</strong>: You can add the same object to the collection if you want.</li>
				<li><strong class="bold">Performance</strong>: This class is optimized for scenarios where the same thread adds or removes items but performs pretty well in mixed scenarios.</li>
			</ul>
			<p>The <code>GetConnection()</code> method<a id="_idIndexMarker640"/> pulls an object from the pool if one is available. If one is not, it creates one for you. Here it is:</p>
			<pre class="source-code">
public TcpClient? GetConnection()
{
    if (_availableConnections.TryTake(out TcpClient? client))
        return client;
    if (_availableConnections.Count &lt; _maxPoolSize)
    {
        // Create a new connection if the pool is not full
        client = new TcpClient("my.server.com", 443);
    }
    else
    {
        // Pool is full; wait for an available connection or throw an         // exception
        // This strategy depends on your specific requirements
        throw new Exception("Connection pool limit reached.");
    }
    return client;
}</pre>			<p>In this<a id="_idIndexMarker641"/> example, I throw an exception when the pool has reached the maximum allowed objects. You want to limit the number of <code>TcpClient</code> instances in your code: they take up quite a lot of memory and underlying handles, so having an unlimited amount of them lying around might not be the best idea.</p>
			<p>If there is room in the pool but no items are available, we create a new one and return it to the caller. The idea is that after using, the caller returns the object, and we store it in the collection, ready for another user to pick it up. We use lazy initialization here: we only create <code>TcpClient</code> when needed.</p>
			<p>If you want, you can create all 10 instances in the constructor of this class. That makes the initialization of the class slower, and it uses more memory, but it is much faster during the object’s lifetime.</p>
			<p>When the connection user calls this method, it gets an active and open connection. When the user no longer needs <code>TcpClient</code>, it needs to be returned so it can be stored in the pool and ready for the following user. That method looks like this:</p>
			<pre class="source-code">
public void ReturnConnection(TcpClient? client)
{
    // Check the state of the connection to ensure it's still valid
    if (client is { Connected: true })
    {
        _availableConnections.Add(client);
    }
    else
    {
        // Optionally, handle the case where the connection is no         // longer valid
        // e.g., reconnect or simply discard this connection
    }
}</pre>			<p>We can <a id="_idIndexMarker642"/>do some checking when we get <code>TcpClient</code> back. For instance, I usually check to see whether it is still connected here. It is a bit like a library: when you return your items, they expect them to be pristine. We do the same here. If there is something wrong, we can fix it or not even add it back to the pool. I’ll leave that up to you.</p>
			<p>Finally, when the connection pool is disposed of, we do some cleaning up:</p>
			<pre class="source-code">
public async ValueTask DisposeAsync()
{
    foreach (var client in _availableConnections)
    {
        if (client is { Connected: true })
        {
            await client.GetStream().DisposeAsync();
        }
        client?.Close();
        client?.Dispose();
    }
}</pre>			<p>We go through all the remaining instances of <code>TcpClient</code> in our collection, close them if needed, dispose of the underlying stream, and dispose of the instances themselves. This makes <a id="_idIndexMarker643"/>sure we leave no connection open. My mother taught me this at a very young age: always clean up after yourself!</p>
			<p>To finalize this part, this is how you would use this class:</p>
			<pre class="source-code">
await using var connectionPool = new TcpClientConnectionPool();
TcpClient? myConnection = connectionPool.GetConnection();
try
{
    var myBuffer = "Hello, World!"u8.ToArray();
    // Use the connection
    await myConnection.Client.SendAsync(myBuffer);
}
finally
{
    connectionPool.ReturnConnection(myConnection);
}</pre>			<p>I first create an instance of <code>connectionPool</code>. Obviously, you would not do that in each method call that needs a connection, but for this simple example, it is all right.</p>
			<p>Then I try to get a connection by calling <code>GetConnection()</code>;</p>
			<p>Then I get some bytes by taking the <code>Hello, World</code> string, postfixing that with <code>u8</code> to ensure it is UTF-8 and then converting it to a byte array.</p>
			<p>I can use my pooled connection to send that string to the server. Finally, I can put the connection back in the pool.</p>
			<p>This sample is limited in functionality and lacks a lot of the code you would need before taking it into <a id="_idIndexMarker644"/>production. But I am sure it will help you get on your way.</p>
			<p>What we are doing is caching our connections. But caching can help in a lot of other ways as well.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>Caching</h2>
			<p>Caching<a id="_idIndexMarker645"/> stores data nearby so you can reuse it instead of going to the server each time. That sounds simple enough: it can be a huge performance booster. Getting an object from a memory location on your machine instead of going to a remote server each time sounds like a no-brainer, right? But there are some potential pitfalls you need to take into account. Here are the most important ones:</p>
			<ul>
				<li><strong class="bold">Stale data</strong>: Data might change. For instance, our NTP sample changes every millisecond. That being said, you might retrieve it from the server once and then add the local time that’s elapsed since you got it. It will eventually run out of sync (NTP servers are much more precise than your local machine), but I am sure it will not be that big of an issue soon. But data will get stale. You have to take that into account if you store data locally. How often will data change? How important is it that I have the latest version?</li>
				<li><strong class="bold">Memory overhead</strong>: Storing items locally on your machine takes up local memory. Storing large amounts of (large) objects takes up a lot of data, which might slow down your total application. It might even lead to out-of-memory exceptions. You must decide what you use frequently and what can be left on the server.</li>
				<li><strong class="bold">Complexity in cache invalidation</strong>: If data gets stale, you have to renew it. That requires code to monitor the data and refresh it when needed. That code can get quite complicated. You might have a separate thread that monitors your local cache, or you might decide when something pulls that data from the cache. Either way, you have to write a lot of monitoring code. That might overly complicate your software.</li>
				<li><strong class="bold">Security concerns</strong>: Data on your machine is not always safe. If you store sensitive data on the local machine, it might be susceptible to snooping, especially if you store that cached data on a storage medium. Be sure to handle sensitive data safely.</li>
				<li><strong class="bold">Costs of cache misses</strong>: When your application relies on getting data from the cache and <a id="_idIndexMarker646"/>only has it read from the remote server when you have a cache miss (thus, the item is not in the cache yet), you might have introduced a performance bottleneck. The logic of going through the cache, only to go out to the server if the data is not available, takes time. If the data you need is not needed that often, this is probably not the best case for caching.</li>
				<li><strong class="bold">Inconsistent data</strong>: Suppose your app uses data from the cache, but another system or part of your system uses data from the server. In that case, there might be discrepancies between the data. This is not only stale data, but it means that two systems use different data – data they expect to be the same. If that might be an issue, caching might be a bad idea.</li>
			</ul>
			<p>Caching can speed up your application, but be aware of the risks involved. Before implementing this, you should consider the potential risks and benefits.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Compression and serialization</h2>
			<p>If transferring<a id="_idIndexMarker647"/> data over the wire is slow, transmitting or requesting less data can help. So, compression and how you serialize data can help. In earlier chapters, we looked into compression and serialization, so I will not go into detail <a id="_idIndexMarker648"/>here. But please remember: if there is one place where it helps a lot when you use compression, this is the place. You can speed up network communications if you reduce the payload by compressing it first. And of course, choosing the correct serialization technique also helps.</p>
			<p>Since we already looked at how to do compression, I will not show you it again here. You already know how to use the <code>GZipStream</code> class in the <code>System.IO.Compression</code> namespace (yes, that was a hint).</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Keep-alive connections</h2>
			<p>Creating a <code>TcpClient</code> is not <a id="_idIndexMarker649"/>that expensive per se. Opening a connection to a server is expensive, however. It can help to keep connections open as long as you can. The <code>HTTPClient</code> class is very good at that: it is built so that you can leave the connection open for a long time without getting in your way. If you use sockets, you can do something similar. However, keeping a connection open when you do not need it anymore is not a good idea. If you do not need it, please close the connection. Otherwise, by all means, keep it open. Of course, if you keep a connection open, you also affect the other party. A client that clings to a connection also limits the server. You have to think about this a lot and make the right decisions.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Networking errors and time-outs</h1>
			<p>When<a id="_idIndexMarker650"/> dealing with networks, there is one rule you have to keep in mind. That rule is: <em class="italic">assume that the other party is not answering </em><em class="italic">your call</em>.</p>
			<p>Servers go down. Connections can drop. Networks are unreachable. There are a whole lot of issues that will (not might!) happen.</p>
			<p>You must use defensive coding to ensure it doesn’t impact your code too much. Of course, if you rely on an external machine to get the data you need, and that machine is not available, you have a problem. But maybe you can get around it. Perhaps you can cache older data. Or, you can retry if something goes wrong.</p>
			<p>Let me help you with some strategies you can use to deal with hiccups in the network.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Using the HTTPClient wisely</h2>
			<p>The <code>HTTPClient</code> class has <a id="_idIndexMarker651"/>some neat tricks<a id="_idIndexMarker652"/> to help you with making the use of it more stable. For instance, connection pooling comes free and out of the box in this handy class. And they built that connection pooling in a pretty clever way.</p>
			<p>The general advice is to create one instance of <code>HTTPClient</code> and use that throughout your system. The class is smart enough to pool connections to a server. If you use the same <code>HTTPClient</code> to get data from another server, the class creates a new pool, so those connections also get pooled.</p>
			<p>Of course, be<a id="_idIndexMarker653"/> careful what you do: do not generate connections to hundreds of servers if you do not need them. They still take up memory in your system.</p>
			<p>Another<a id="_idIndexMarker654"/> way to make <code>HTTPClient</code> more resilient is to use a default configuration for your connections. I always ensure I set <code>DefaultRequestHeaders</code> so I know that I can handle the data coming in.</p>
			<p>And I always make sure I have a <code>TimeOut</code> on my instance. That way, I know that the <code>HTTPClient</code> will not have to wait too long for data from the server.</p>
			<p>I suggest you use something such as a <code>Factory</code> to create your instances. I use one that looks like this:</p>
			<pre class="source-code">
internal static class HttpClientFactory
{
    private static HttpClient? _instance;
    public static HttpClient? Instance
    {
        get
        {
            if (_instance == null) CreateInstance();
            return _instance;
        }
    }
    private static void CreateInstance()
    {
        var handler = new HttpClientHandler()
        {
            UseCookies = true,
            CookieContainer = new CookieContainer(),
            UseProxy = false
        };
        _instance = new HttpClient(handler);
        _instance.DefaultRequestHeaders.Clear();
        _instance.DefaultRequestHeaders.Accept.Add(new           MediaTypeWithQualityHeaderValue("application/json"));
        _instance.DefaultRequestHeaders.Add("User-Agent",           "SystemProgrammersApp");
        _instance.Timeout = TimeSpan.FromSeconds(5);
    }
}</pre>			<p>This static<a id="_idIndexMarker655"/> class creates an instance of <code>HTTPClient</code> for me if needed. It tells the handler that it needs to use <code>Cookies</code> and that I do not want <a id="_idIndexMarker656"/>a proxy on my connection. I also set <code>DefaultRequestHeaders</code> and asked it to accept <code>application/json</code> data. I also added a nice user agent so the server knows who it is talking to. Finally, I set the <code>timeout</code> to 5 seconds.</p>
			<p>If I need an <code>HTTPClient</code> instance, I can get it like this:</p>
			<pre class="source-code">
var client = HttpClientFactory.Instance;
var response = await client.GetAsync(
       "https://jsonplaceholder.typicode.com/posts");
if (response.IsSuccessStatusCode)
{
    string content = await response.Content.ReadAsStringAsync();
    $"Received: {content}".Dump(ConsoleColor.Yellow);
}</pre>			<p>The first time I needed that client, it built it. But the second time and after that, it will pull it <a id="_idIndexMarker657"/>from the connection pool, making it a lot quicker and more resilient to mistakes.</p>
			<p>I also ensure<a id="_idIndexMarker658"/> I do not use the <code>GetStringAsync()</code> method or <code>GetStreamAsync()</code> directly from <code>HTTPClient</code>. I first get the <code>Response</code> (of the type <code>HttpResponseMessage</code>) to check whether the result is valid. As we have seen, this is what the <code>IsSuccessStatusCode</code> property tells us.</p>
			<p>This way, your communications with an HTTP server will become faster and much more stable.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/>Implementing retries with Polly</h2>
			<p>But <a id="_idIndexMarker659"/>of course, things will still go wrong. The server might be busy, or the network might be congested. The best way to get around that is to try again, and then again, until either it works or you give up.</p>
			<p>You could write that logic yourself, but you would be better off using a standard library. The most used library that <a id="_idIndexMarker660"/>implements this is called <strong class="bold">Polly</strong>.</p>
			<p>So, let’s install<a id="_idIndexMarker661"/> that NuGet package in our application first. You can do so in the CLI by using this command:</p>
			<pre class="console">
Install-Package Polly</pre>			<p>Once you have done that, we can change our <code>HttpClientFactory</code> class a bit.</p>
			<p>First, add a new <code>private static</code> field to that class:</p>
			<pre class="source-code">
private static AsyncRetryPolicy&lt;HttpResponseMessage&gt; _retryPolicy;</pre>			<p>This is our <code>RetryPolicy</code>, which we will apply to the requests.</p>
			<p>At the end of the <code>CreateInstance</code> method in the <code>HttpClientFactory</code> class, add a call to a new method: <code>SetupRetryPolicy</code>. The method looks like this:</p>
			<pre class="source-code">
private static void SetupRetryPolicy()
{
    _retryPolicy = Policy
        .Handle&lt;HttpRequestException&gt;()
        .OrResult&lt;HttpResponseMessage&gt;(r =&gt; !r.IsSuccessStatusCode)
        .WaitAndRetryAsync(
            3,
            retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(2,               retryAttempt)),
            (outcome, timeSpan, retryCount, context) =&gt;
            {
                $"Request failed with
                 {outcome.Result.StatusCode}.".Dump(ConsoleColor.Red);
                $"Waiting {timeSpan} before next
                 retry.".Dump(ConsoleColor.Red);
                $"Retry attempt
                 {retryCount}.".Dump(ConsoleColor.Red);
            });
}</pre>			<p>In the <a id="_idIndexMarker662"/>static <code>Policy</code> class, we call the <code>Handle()</code> method. We give it the <code>HttpRequestException</code> type<a id="_idIndexMarker663"/> parameter. This way, the framework knows the trigger to start retrying. We also tell it to retry if <code>HttpResponseMessage.IsSuccesStatusCode</code> is set to false.</p>
			<p>If one of those conditions arises, we tell the policy to <code>WaitAndRetryAsync</code>. We ask it to give it three retries after the first failure. The following parameter tells the <code>Policy</code> to wait for 2, 4, or 8 seconds (2 to the power of the retry number). So, it waits twice as long each time to give the server time to get its stuff in order.</p>
			<p>We also give it a delegate that the framework will execute as soon as it starts to retry. In this case, we print out some messages to the console, telling it what failed, how long it will wait before it tries again, and how many times it has tried already.</p>
			<p>With that <a id="_idIndexMarker664"/>in place, we can rewrite how we ask the <code>HTTPClient</code> for data. In the previous example, I showed you how to get the <code>Instance</code> from the factory and then use that instance directly. I want to move that code to <code>HttpClientFactory</code> as well. But the call to the server must be wrapped up in our new <code>Policy</code>. The method looks like this:</p>
			<pre class="source-code">
public static async Task&lt;HttpResponseMessage&gt; GetAsync(string url)
{
    return await _retryPolicy.ExecuteAsync(
        () =&gt; _instance.GetAsync(url));
}</pre>			<p>Instead of the user of our class calling <code>GetAsync(url)</code>, we do it for them using this wrapper method. But we wrap up that call in <code>_retryPolicy.ExecuteAsync()</code>.</p>
			<p>Change the original code that uses this factory to look like this:</p>
			<pre class="source-code">
var client = HttpClientFactory.Instance;
var response = await HttpClientFactory.GetAsync(
       "https://jsonplaceholder.typicode.com/posts2");
if (response.IsSuccessStatusCode)
{
    string content = await response.Content.ReadAsStringAsync();
    $"Received: {content}".Dump(ConsoleColor.Yellow);
}</pre>			<p>Instead of calling <code>client.GetAsync()</code>, I now call <code>HttpClientFactory.GetAsync()</code>. The rest hasn’t changed. Well, that’s not entirely true. I also altered the URL a bit. I am not asking for <code>posts2</code> instead of <code>posts</code> in that URL. And that doesn’t exist. That should trigger our retry mechanism.</p>
			<p>Run it and see what happens. There you go – retries done the right way!</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>The circuit breaker pattern</h2>
			<p>A <a id="_idIndexMarker665"/>similar pattern is the circuit <a id="_idIndexMarker666"/>breaker pattern. This pattern detects when connections are in a fault state and prevents the system from making calls to the server for a predefined period. If the connection raises errors, the circuit breaker opens and stops all communications to that server for a while. After that cooldown period, it opens a bit to allow another quick peek at the server. If it seems to work, it allows full traffic. Otherwise, it will give up and let you know things have gone wrong.</p>
			<p>The circuit breaker is also part of the Polly NuGet package.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor205"/>Validating network availability</h2>
			<p>Trying to<a id="_idIndexMarker667"/> connect to a server that doesn’t exist will result in errors. But what happens if your own network has an issue? In that case, it would look like all servers worldwide are down.</p>
			<p>That last scenario doesn’t seem so likely, so verifying that our network is healthy would be nice before we blame the entire internet.</p>
			<p>It turns out that it is not too hard to do so. All you need is one line of code:</p>
			<pre class="source-code">
bool isHealthy =     System.Net.NetworkInformation.NetworkInterface.GetIsNetworkAvailable();</pre>			<p>That’s all there is to it.</p>
			<p>You can also interrogate each network adaptor in your machine like this:</p>
			<pre class="source-code">
foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
{
    $"Name: {ni.Name}".Dump(ConsoleColor.DarkYellow);
    $"Type:{ni.NetworkInterfaceType}".Dump(ConsoleColor.DarkYellow);
    $"Status: {ni.OperationalStatus}".Dump(ConsoleColor.DarkYellow);
}</pre>			<p>We can<a id="_idIndexMarker668"/> iterate through all network adapters and see what their status is. That can help us to select the suitable adapter and thus the right IP address if we want to be resilient against errors and failures.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Monitoring and logging</h2>
			<p>This one goes <a id="_idIndexMarker669"/>without saying: <em class="italic">the best way to solve issues is to log and monitor what is happening</em>. If you have extensive logging, you are much more likely to find problems if they occur. But let’s not worry about that too much for now.</p>
			<p>If you follow these tips and tricks, you will still face network issues. They are inevitable. But at least network failures will not bring your system down.</p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor207"/>Next steps</h1>
			<p>In this chapter, we took a deep dive into networking. We broke out of the confines of the local machine and looked at all the good stuff that the BCL gives us when it comes to connecting to the outside world.</p>
			<p>We looked at default protocols such as HTTP, FTP, and SMTP. We also looked at sockets in case the predefined protocols are not good enough, such as when you want to look up the current time from a time server. We dove into asynchronous networking and talked a lot about performance and making our networking error-proof and more robust.</p>
			<p>Let’s be honest: almost no computer these days runs on its own. Most machines and thus the software running on them, are somehow connected to the outside world. Especially the things we as system programmers are interested in are not used by users, but instead by other software. Some of that software lives on other machines. This means it is imperative you know about networking. And now you do!</p>
			<p>We did not talk about security and logging. Logging is something we touch on in <a href="B20924_11.xhtml#_idTextAnchor222"><em class="italic">Chapter 10</em></a>. Security is the topic of <a href="B20924_13.xhtml#_idTextAnchor260"><em class="italic">Chapter 12</em></a>. Yes, these topics are so important they deserve their own chapter.</p>
			<p>But before we go there, let’s take a little trip to other platforms. Since systems programming works closely with devices, I thought it would be fun to dive into another device and see if we could talk to some fancy hardware. So, let’s go there next!</p>
		</div>
	</body></html>