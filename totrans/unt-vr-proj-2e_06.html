<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">World Space UI</h1>
                </header>
            
            <article>
                
<p class="calibre3">In the previous chapter, we discovered how to interact with game objects in the world space scene. Not only can these objects can be balls and toys, or tools and weapons, but they can be buttons you interact with and other user interface widgets. Furthermore, Unity includes a user interface canvas system for building menus and other UI.</p>
<p class="calibre3"><strong class="calibre5">Graphical user interface</strong> (<strong class="calibre5">GUI</strong>) or just UI, usually refers to on-screen two-dimensional graphics, which overlay the main gameplay and present information to the user with status messages, gauges, and input controls such as menus, buttons, sliders, and so on.</p>
<p class="calibre3">In Unity, UI elements always reside on a <strong class="calibre5">canvas</strong>. The Unity manual describes the <kbd class="calibre13">canvas</kbd> component as follows:</p>
<div class="packtquote">The <kbd class="calibre26">canvas</kbd> component represents the abstract space in which the UI is laid out and rendered. All UI elements must be children of a <kbd class="calibre26">GameObject</kbd> that has a <kbd class="calibre26">canvas</kbd> component attached.</div>
<p class="calibre3">In conventional video games, UI objects are usually rendered in a <strong class="calibre5">screen space</strong> canvas as an overlay. The screen space UI is analogous to a piece of cardboard pasted on your TV or monitor, overlaying the game action behind it.</p>
<p class="calibre3">However, that doesn't work in VR. If you attempt to use screen space for UI in virtual reality, you'll run into issues. Since there are two stereographic cameras, you need separate views for each eye. While conventional games may co-opt the edges of the screen for UI, <em class="calibre14">virtual reality has no screen edges</em>!</p>
<p class="calibre3">Instead, in VR, we use various approaches that place the user interface elements in <strong class="calibre5">World Space</strong> rather than screen space. In this chapter, I characterize a number of these types. We'll define these types in detail and show you examples of them throughout this chapter:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Visor heads-up display</strong>: In a visor <strong class="calibre1">heads-up display</strong> (<strong class="calibre1">HUD</strong>), the user interface canvas appears at the same spot in front of your eyes regardless of your head movement</li>
<li class="calibre12"><strong class="calibre1">Reticle cursors</strong>: Similar to visor HUD, a crosshair or a pointer cursor is used to choose things in the scene</li>
<li class="calibre12"><strong class="calibre1">Windshield HUD</strong>: This is a pop-up panel floating in 3D space like a windshield in a cockpit</li>
<li class="calibre12"><strong class="calibre1">Game element UI</strong>: The canvas is in the scene as a part of the gameplay, like a scoreboard in a stadium</li>
<li class="calibre12"><strong class="calibre1">Info bubble</strong>: This is a UI message that is attached to objects in the scene, like a thought bubble hovering over a character's head</li>
<li class="calibre12"><strong class="calibre1">In-game dashboard</strong>: This is a control panel that is a part of the gameplay, usually at waist or desk height</li>
<li class="calibre12"><strong class="calibre1">Wrist-based menu palette</strong>: With two-handed input controllers, one hand can hold a menu palette while the other makes selections and uses the selected tool</li>
</ul>
<p class="calibre3">The differences in these UI techniques basically comes down to where and when you display the canvas and how the user interacts with it. In this chapter, we're going to try each of these in turn. Along the way, we'll also continue to explore user input with head movement and gestures as well as button clicks.</p>
<div class="packttip">Note that some of the exercises in this chapter use the scene completed in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre20"><span>Chapter 4</span></a>, <em class="calibre2">Gaze-Based Control</em>, but are separate and not directly required by the other chapters in this book. If you decide to skip any of it or not save your work, that's OK.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Studying VR design principles</h1>
                </header>
            
            <article>
                
<p class="calibre3">Before we get into the implementation details, I would like to introduce the topic of designing 3D user interfaces and VR experiences. A lot of work has been done over the past few decades, and more so in the past few years.</p>
<p class="calibre3"><span class="calibre6">With consumer VR devices so readily available, and powerful development tools like Unity, it's not surprising there are many people inventing and trying new things, innovating continuously, and producing really excellent VR experiences. You are probably one of them. But the context of today's VR is not a vacuum. There is a history of research and development that feeds into present-day work.  The book <em class="calibre14">3D User Interfaces: Theory and Practice</em> (Bowman et al), for example, is a </span>classic academic survey of 3D user interaction for consumer, industrial, and scientific applications and research. Originally published in 2004, the second edition was published in 2017 (LaViola et al) and is an up-to-date review of academic theory and practical principles. </p>
<p class="calibre3">Current writings for VR design are more accessible. An easy to read but practical introduction to VR user experience design is the Medium article <em class="calibre14">Get started with VR: user experience design</em> (<a href="https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18" class="calibre10">https://medium.com/vrinflux-dot-com/get-started-with-vr-user-experience-design-974486cf9d18</a>) by Adrienne Hunter, co-creator of the popular VR physics package, NewtonVR. She identifies some important core principles, including It's like theatre in the round, drawing attention with to objects, lighting, and audio cues, and designing space for height and accessibility.</p>
<p class="calibre3">Another great article is <em class="calibre14"><span class="calibre6">Practical VR: A Design Cheat Sheet</span></em> (<a href="https://virtualrealitypop.com/practical-vr-ce80427e8e9d" class="calibre10">https://virtualrealitypop.com/practical-vr-ce80427e8e9d</a>). This is intended to be a living primer with VR design guidelines, process, tools and other resources the author intends to maintain and update.</p>
<p class="calibre3">One of my favorite studies of design for VR is the <em class="calibre14">VR Interface Design Pre-Visualization Methods</em> produced by Mike Algers as a grad student in 2015. His inspiring video at <a href="https://vimeo.com/141330081" class="calibre10">https://vimeo.com/141330081</a> presents an easily digestible thesis of design principles, especially for seated VR experiences, based on established ergonomics of workspaces and visual perception.<span class="calibre6"> We'll use some of these ideas in this chapter. Algers also explores button design for VR, mockup workflows, and concepts for VR operating system design. (Algers presently works in the Google VR development group.)</span></p>
<p class="calibre3">In his thesis, Algers establishes a set of comfort zones radially around the user's first-person location, as shown:</p>
<div class="mce-root1"><img src="assets/1367a872-18be-41e7-bed9-9af40d410cbe.png" class="calibre49"/></div>
<p class="calibre3">Anything closer than <span class="calibre6">0.5 m</span> is too close for comfort; you might have to cross your eyes just to focus and follow objects at that range. Beyond <span class="calibre6">20 m</span> is too far way to have meaningful interactions, and is also too far for depth perception with parallax. Your <span class="calibre6">Peripheral Zones</span> (<span class="calibre6">77</span>–<span class="calibre6">102</span> degrees) should not contain primary content and interactions but can have secondary ones. Behind you he calls the <span class="calibre6">Curiosity Zone</span>, you'd need to stretch (or swivel your chair or turn around) to see what's going on there so it'd better be important yet not imperative. The <span class="calibre6">Main Content Zone</span> is your normal workspace. Then, accounting for arm reach (forward, up, and down) and other normal human movement in a workspace, Algers defines the optimal virtual work zone for seated VR experience as shown:</p>
<div class="mce-root1"><img src="assets/f360026f-0430-439e-b914-449282c0f156.png" class="calibre50"/></div>
<p class="calibre3">For standing and room-scale VR, the workspace is different. When standing, it may be much easier (and expected) to be able to turn around to access things all around you. With room-scale, you can walk around (and jump, duck, and crawl, for that matter). Alex Schwartz and Devin Reimer of Owlchemy Labs (since acquired by Google), in <span class="calibre6">their talk at Oculus Connect 2 ( <a href="https://www.youtube.com/watch?v=hjc7AJwZ4DI" class="calibre10">https://www.youtube.com/watch?v=hjc7AJwZ4DI</a>), </span>discuss the challenges of designing standing VR experiences for their popular Job Simulator, including accommodation for real-world ergonomics and varied height experiences. </p>
<p class="calibre3">Some other great resources on designing for virtual reality include:</p>
<ul class="calibre11">
<li class="calibre12">Oculus's series of articles on VR design best practices, including on user input (<a href="https://developer.oculus.com/design/latest/concepts/bp-userinput/" class="calibre10">https://developer.oculus.com/design/latest/concepts/bp-userinput/</a>) which includes recommendations on movement, button mapping, menus, and using your hands in VR. </li>
<li class="calibre12">Leap Motion (we do not cover its hand-recognition technology in this book) has some great writings on VR design, which can be found at <a href="https://developer.leapmotion.com/explorations" class="calibre10">https://developer.leapmotion.com/explorations</a>, including very good articles on interactive design (<a href="http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/" class="calibre10">http://blog.leapmotion.com/building-blocks-deep-dive-leap-motion-interactive-design/</a>) and user Interface Design (<a href="http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/" class="calibre10">http://blog.leapmotion.com/beyond-flatland-user-interface-design-vr/</a>).</li>
<li class="calibre12">Google has produced a number of seminal examples, including <em class="calibre2">Daydream Labs: Lessons Learned from VR Prototyping - Google I/O 2016</em> (<a href="https://www.youtube.com/watch?v=lGUmTQgbiAY" class="calibre10">https://www.youtube.com/watch?v=lGUmTQgbiAY</a>) and Daydream Elements (<a href="https://developers.google.com/vr/elements/overview" class="calibre10">https://developers.google.com/vr/elements/overview</a>).</li>
</ul>
<p class="calibre3">Of course, this just scratches the surface; more is being published every day. Google it. A curated, living list of resources on user Interface Design and user experience in virtual reality can be found at The UX of VR site (<a href="https://www.uxofvr.com/" class="calibre10">https://www.uxofvr.com/</a>).</p>
<p class="calibre3">Have fun reading and watching videos. Meanwhile, let's get back to work. It's time to implement some VR UI ourselves.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A reusable default canvas</h1>
                </header>
            
            <article>
                
<p class="calibre3">Unity's UI canvas provides lots of options and parameters to accommodate the kinds of graphical layout flexibility that we have come to expect not only in games but also from web and mobile apps. With this flexibility comes additional complexity. To make our examples in this chapter easier, we'll first build a reusable prefab canvas that has our preferred default settings.</p>
<p class="calibre3">Create a new canvas and change its <span class="calibre6">Render Mode</span> to <span class="calibre6">world space</span> as follows:</p>
<ol class="calibre15">
<li class="calibre12">Navigate to <span>GameObject</span> | <span>UI</span> | <span>Canvas</span></li>
<li class="calibre12">Rename the canvas as <kbd class="calibre13">DefaultCanvas</kbd></li>
<li class="calibre12">Set <span>Render Mode</span> to <span>W</span><span>orld Space</span></li>
</ol>
<p class="calibre3">The <span class="calibre6">Rect Transform</span> component defines the grid system on the canvas itself, like the lines on a piece of graph paper. It is used for the placement of UI elements on the canvas. Set it to a convenient <kbd class="calibre13">640 x 480</kbd>, with a <kbd class="calibre13">0.75</kbd> aspect ratio. The <kbd class="calibre13">Rect Transform</kbd> component's width and height are different from the world space size of the canvas in our scene. Let's configure the <kbd class="calibre13">Rect Transform</kbd> component using the following steps:</p>
<ol class="calibre15">
<li class="calibre12">In <kbd class="calibre13">Rect Transform</kbd>, set the <span>Width</span> to <kbd class="calibre13">640</kbd> and the <span>Height</span> to <kbd class="calibre13">480</kbd>.</li>
</ol>
<p class="calibre3"> </p>
<ol start="2" class="calibre15">
<li class="calibre12">In <span>Scale</span>, set <span>X</span>, <span>Y</span>, <span>Z</span> to (<kbd class="calibre13">0.00135</kbd>, <kbd class="calibre13">0.00135</kbd>, <kbd class="calibre13">0.00135</kbd>). This is the size for one of our pixels in world space units.</li>
<li class="calibre12">Now, position the canvas centered on the ground plane one unit above<br class="title-page-name"/>
(<kbd class="calibre13">0.325</kbd> is half of <kbd class="calibre13">0.75</kbd>). In <span>Rect Transform</span>, set <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">1.325</kbd>, <kbd class="calibre13">0</kbd>).</li>
</ol>
<p class="calibre3">Next, we will add an empty <kbd class="calibre13">Image</kbd> element (with a white background) to help us visualize the otherwise transparent canvas and provide an opaque background for the canvas when we need one (we can also use a <kbd class="calibre13">Panel</kbd> UI element):</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">DefaultCanvas</kbd> selected, navigate to <span>GameObject</span> | <span>UI</span> | <span>Image</span> (ensure that it's created as a child of <kbd class="calibre13">DefaultCanvas</kbd>; if not, move it under <kbd class="calibre13">DefaultCanvas</kbd>).</li>
<li class="calibre12">With the <span>Image</span> selected, on the upper left of its <span>Rect Transform</span> pane, there is an <span>anchor presets</span> button (shown in the following screenshot). Selecting it opens the <span>anchor presets</span> dialog box. Press and hold the <em class="calibre2"><span>Alt</span></em> key to see the <span>stretch</span> and <span>position</span> options and choose the one in the bottom-right corner (<span>stretch</span>-<span>stretch</span>). Now, the (blank) image is stretched to fill the canvas:</li>
</ol>
<div class="mce-root1"><img src="assets/30581c97-e971-45aa-b2c7-659a16919233.png" class="calibre24"/></div>
<ol start="3" class="calibre15">
<li class="calibre12">Double-check your <span>Image</span> settings based on the default properties for the <kbd class="calibre13">Image</kbd> child of the <kbd class="calibre13">DefaultCanvas</kbd> as shown in the following screenshot:</li>
</ol>
<div class="mce-root1"><img src="assets/a4dd46fa-cc81-4550-975d-d633cb720423.png" class="calibre51"/></div>
<p class="calibre3">Add a <kbd class="calibre13">Text</kbd> element with useful default settings, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">DefaultCanvas</kbd> selected, navigate to <span>GameObject</span> | <span>UI</span> | <span>Text</span> (ensure that it's created as a child of <kbd class="calibre13">DefaultCanvas</kbd> (if not, move it under <kbd class="calibre13">DefaultCanvas</kbd>). The words <kbd class="calibre13">New Text</kbd> should appear on the canvas.</li>
<li class="calibre12">With the <span>Text</span> selected, set <span>Alignment</span> to <span>Center Align</span> and <span>Middle Align</span> and set <span>Vertical Overflow</span> to <span>Overflow</span>. Set the <span>Scale</span> to (<kbd class="calibre13">4</kbd>, <kbd class="calibre13">4</kbd>, <kbd class="calibre13">4</kbd>).</li>
<li class="calibre12">Set its <span>anchor presets</span> button to (<span>stretch</span> - <span>stretch</span>) using the widget on the upper left of its <span>Rect Transform</span> pane.</li>
<li class="calibre12">Double-check your <span>Text</span> settings based on the default properties for the <kbd class="calibre13">Text</kbd> child of the <kbd class="calibre13">DefaultCanvas</kbd> as shown in the following screenshot:</li>
</ol>
<div class="mce-root1"><img src="assets/557031b9-4219-4617-b50e-58112722f0fc.png" class="calibre52"/></div>
<p class="calibre3">Increase the pixel resolution to give cleaner text fonts by keeping <kbd class="calibre13">DefaultCanvas</kbd> selected and setting the <span class="calibre6">Canvas Scaler</span> | <span class="calibre6">Dynamic Pixels Per Unit</span> to <kbd class="calibre13">10</kbd>.</p>
<p class="calibre3">Finally, save your work as a prefab asset that you can reuse throughout the chapter in the following manner:</p>
<ol class="calibre15">
<li class="calibre12">If necessary, in <span>Project Assets</span>, create a new folder named <kbd class="calibre13">Prefabs</kbd>.</li>
<li class="calibre12">Drag the <kbd class="calibre13">DefaultCanvas</kbd> object into the <kbd class="calibre13">Project Assets/Prefabs</kbd> folder to create a prefab.</li>
<li class="calibre12">Delete the <kbd class="calibre13">DefaultCanvas</kbd> instance in the <span>Hierarchy</span> panel now.</li>
</ol>
<p class="calibre3">OK, glad we got that out of the way! Now we can use the <kbd class="calibre13">DefaultCanvas</kbd> prefab with different VR user interfaces.</p>
<div class="packttip">A canvas has a <kbd class="calibre26">Rect Transform</kbd> component, which defines the grid system on the canvas itself, like the lines on a piece of graph paper. It is used for the placement of UI elements on the canvas. This is different from the size and position of a canvas object in world space.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Visor HUD</h1>
                </header>
            
            <article>
                
<p class="calibre3">A heads-up display, or HUD, is a floating canvas in your field of view that overlays the gameplay scene. In VR vernacular, there are two variations of HUDs. I'll call these variations the <em class="calibre14">visor HUD</em> and the <em class="calibre14">windshield HUD</em>. This section looks at the first one.</p>
<p class="calibre3">In visor HUD, the UI canvas is attached to the camera. It doesn't appear to respond to your head movement. When you move your head, it appears to be <em class="calibre14">stuck to your face</em>. Let's look at a nicer way of visualizing it. Suppose you're wearing a helmet with a visor, and the UI appears projected onto the surface of that visor. There may be contexts where this is OK in virtual reality, but it is likely to break the sense of immersion. So, it should generally only be used either when the visor is a part of the gameplay, or if the intent is to take you out of the scene, such as the utility menus for the hardware or the system.</p>
<p class="calibre3">Let's make a visor HUD with a welcome message as follows, and see for ourselves how it feels:</p>
<ol class="calibre15">
<li class="calibre12">In the <span>Hierarchy</span> panel, unfold the <kbd class="calibre13">MeMyselfEye</kbd> object and then drill down to the <kbd class="calibre13">Main Camera</kbd> object (for OpenVR that might be  <kbd class="calibre13">[CameraRig]/Camera (head)</kbd>; for Daydream, it may be  <kbd class="calibre13">Player/Main Camera/</kbd>).</li>
</ol>
<p class="calibre3"> </p>
<ol start="2" class="calibre15">
<li class="calibre12">From the <span>Project</span> panel, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab onto the camera object so that it becomes a child of it.</li>
<li class="calibre12">In the <span>Hierarchy</span> panel, with the canvas selected, rename the canvas to <kbd class="calibre13">VisorCanvas</kbd>.</li>
<li class="calibre12">In the <span>Inspector</span> panel for the canvas, change the <kbd class="calibre13">Rect Transform</kbd> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>).</li>
<li class="calibre12">Unfold <kbd class="calibre13">VisorCanvas</kbd> and select the child <kbd class="calibre13">Text</kbd> object.</li>
<li class="calibre12">In the <span>Inspector</span> panel, change the text from <span>Default Text</span> to <span>Welcome! My reality is your reality</span>. (You can enter line breaks in the input text area.)</li>
<li class="calibre12">Change the text color to something bright, such as green.</li>
<li class="calibre12">Disable the <kbd class="calibre13">Image</kbd> object so that only the text shows by unchecking its <span>Enable</span> checkbox in <span>Inspector</span>.</li>
<li class="calibre12">Save the scene, and try it in VR.</li>
</ol>
<p class="calibre3">Here's a capture of the Rift screen with the <kbd class="calibre13">VisorCanvas</kbd>:</p>
<div class="mce-root1"><img src="assets/512268e3-f19f-45ff-b3d6-ecd174a0e94a.png" class="calibre53"/></div>
<p class="calibre3">In VR, when you move your head around, the text follows along as if it's attached to a visor in front of your face.</p>
<div class="packttip">A visor HUD canvas and reticle cursor canvas are set as a child object of the camera.</div>
<p class="calibre3">Now, go ahead and either disable <kbd class="calibre13">VisorCanvas</kbd> or just delete it (in the <span class="calibre6">Hierarchy</span> panel, right-click on it and click on <span class="calibre6">Delete</span>) because we're going to display the welcome message in a different way in a later section. Next, we'll look at a different application of this technique.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The reticle cursor</h1>
                </header>
            
            <article>
                
<p class="calibre3">A variant of the visor HUD that is essential in first-person shooter games is a <em class="calibre14">reticle</em> or crosshair cursor. The analogy here is that you're looking through a gun-sight or an eyepiece (rather than a visor) and your head movement is moving in unison with the gun or turret itself. You can do this with a regular game object (for example, Quad + texture image), but this chapter is about UI. So, let's use our canvas, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Find your <span>Main Camera</span> object in the <span>Hierarchy</span> panel as we did previously.</li>
<li class="calibre12">From the <span>Project</span> panel, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab onto the camera object so that it becomes a child of the camera. Name it <kbd class="calibre13">ReticleCursor</kbd>.</li>
<li class="calibre12">Set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1</kbd>).</li>
<li class="calibre12">Delete its child objects: <kbd class="calibre13">Image</kbd> and <kbd class="calibre13">Text</kbd>. This will <em class="calibre2">break</em> the prefab association; that's OK.</li>
<li class="calibre12">Add a raw image child by selecting it from the main menu bar, navigating through <span>GameObject</span> | <span>UI</span> | <span>Raw Image</span> and making sure that it's a child of <kbd class="calibre13">ReticleCursor</kbd>.</li>
<li class="calibre12">In the <span>Raw Image</span> panel's <span>Rect Transform</span>, set <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>) and the <span>Width</span> and <span>Height</span> to (<kbd class="calibre13">22</kbd>, <kbd class="calibre13">22</kbd>). Then, choose a noticeable <span>Color</span> such as red in the <span>Raw Image</span> (<span>Script</span>) properties.</li>
<li class="calibre12">Save the scene and try it in VR.</li>
</ol>
<p class="calibre3">If you'd like a nicer-looking reticle, in the <span class="calibre6">Raw Image</span> (<span class="calibre6">Script</span>) properties, populate the <span class="calibre6">Texture</span> field with a cursor image. For example, click on the tiny <em class="calibre14">circle</em> icon on the far right of the <span class="calibre6">Texture</span> field. This opens the <span class="calibre6">Select Texture</span> dialog. Find and select a suitable one, such as the <kbd class="calibre13">Crosshair</kbd> image. (A copy of <kbd class="calibre13">Crosshair.gif</kbd> is included with this book.) Just be sure to change the <span class="calibre6">Width</span> and <span class="calibre6">Height</span> to the size of your image (<kbd class="calibre13">Crosshair.gif</kbd> is 22 x 22 in size) and ensure that the <span class="calibre6">Anchor</span> is set to <span class="calibre6">middle-center</span>.</p>
<p class="calibre3">We set the canvas position <span class="calibre6">Pos Z</span> to <kbd class="calibre13">1.0</kbd> so that the reticle floats in front of you at a 1-meter distance. A fixed distance cursor is fine in many UI situations, like when you're picking something from a flat canvas that is also at a fixed distance from you.</p>
<p class="calibre3">However, this is world space. If another object is between you and the reticle, the reticle will be obfuscated.</p>
<p class="calibre3">Also, if you look at something much farther away, you'll refocus your eyes and have trouble viewing the cursor at the same time. To emphasize this problem, try moving the cursor closer. For example, if you change the <span class="calibre6">Pos Z</span> of the <kbd class="calibre13">ReticleCursor</kbd> to <kbd class="calibre13">0.5</kbd> or less, you might have to go cross-eyed to see it! To compensate for these issues, we can ray cast and move the cursor to the actual distance of the object that you're looking at, resizing the cursor accordingly so that it appears to stay the same size. Here's a cheap version of this idea:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">ReticleCursor</kbd> selected, click on <span>Add Component</span> | <span>New Script</span>, name it <kbd class="calibre13">CursorPositioner</kbd> and click on <span>Create</span> and <span>Add</span>.</li>
<li class="calibre12">Open the script in MonoDevelop by double-clicking on the name.</li>
</ol>
<p class="calibre3">Here's the <kbd class="calibre13">CursorPositioner.cs</kbd> script:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.EventSystems; 
using System.Collections; 
 
public class CursorPositioner : MonoBehaviour { 
  private float defaultPosZ; 
 
  void Start () { 
    defaultPosZ = transform.localPosition.z; 
  } 
 
  void Update () { 
    Transform camera = Camera.main.transform; 
    Ray ray = new Ray (camera.position, camera.rotation * <br class="title-page-name"/>       Vector3.forward); 
    RaycastHit hit; 
    if (Physics.Raycast (ray, out hit)) { 
      if (hit.distance &lt;= defaultPosZ) { 
        transform.localPosition = new Vector3(0, 0, hit.distance); 
      } else { 
        transform.localPosition = new Vector3(0, 0, defaultPosZ); 
      } 
    } 
  } 
} </pre>
<p class="calibre3">The <span class="calibre6">Rect Transform</span> component's <span class="calibre6">Pos Z</span> is found in the script in <kbd class="calibre13">transform.localPosition</kbd>. This script changes it to <kbd class="calibre13">hit.distance</kbd> if it's less than the given <span class="calibre6">Pos Z</span>. Now, you can also move the reticle to a more comfortable distance, such as <span class="calibre6">Pos Z</span> = <kbd class="calibre13">2</kbd>.</p>
<div class="packtinfobox">An excellent tutorial by <kbd class="calibre26">@eVRydayVR</kbd> shows how to implement both distance and size compensated world space reticles. You can visit <a href="https://www.youtube.com/watch?v=LLKYbwNnKDg" class="calibre20">https://www.youtube.com/watch?v=LLKYbwNnKDg</a>, which is a video titled Oculus Rift DK2 - Unity Tutorial: Reticle.</div>
<p class="calibre3">We just implemented our own cursor reticle, but many VR SDKs now also provide cursors. For example, in Google VR, the <kbd class="calibre13">GvrReticlePointer.cs</kbd> script is a more thorough implementation. Another example, the Oculus OVR package, includes a <kbd class="calibre13">Cursor_Timer</kbd> prefab you can use as a Loading... indicator cursor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The windshield HUD</h1>
                </header>
            
            <article>
                
<p class="calibre3">The term <em class="calibre14">heads-up display</em>, or HUD, originates from its use in aircrafts, where a pilot is able to view information with their head positioned in such a way that they are looking forward rather down at their instrument panels. Owing to this usage, I'll refer it as <em class="calibre14">windshield HUD</em>. Like visor HUD, the information panel overlays the gameplay, but it isn't attached to your head. Instead, you can think of it as being attached to your seat while you are in a cockpit or at the dentist.</p>
<div class="packttip">A visor HUD is like the UI canvas—it is attached to your head. A windshield HUD is like it's attached to a glass dome around you.</div>
<p class="calibre3">Let's create a simple windshield HUD by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">From the <span>Project</span> panel, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab onto the <kbd class="calibre13">MeMyselfEye</kbd> object in the <span>Hierarchy</span> panel so that it becomes an immediate child of <kbd class="calibre13">MeMyselfEye</kbd> (not under the camera this time).</li>
<li class="calibre12">Rename it to <kbd class="calibre13">WindshieldCanvas</kbd>.</li>
<li class="calibre12">With <kbd class="calibre13">WindshieldCanvas</kbd> selected, set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">1.4</kbd>, <kbd class="calibre13">1</kbd>).</li>
</ol>
<ol start="4" class="calibre15">
<li class="calibre12">Now, we'll set the <span>Text</span> component. With <span>Text</span> under <kbd class="calibre13">WindshieldCanvas</kbd> selected, change the text to <span>Welcome! My reality is your reality</span>. Also, change the color to something bright, such as green.</li>
<li class="calibre12">This time, we'll make the panel translucent. Select the image from <span>Image</span> under <kbd class="calibre13">WindshieldCanvas</kbd> and select its color swatch. Then in the <span>Color</span> dialog, modify the <kbd class="calibre13">Alpha ("A")</kbd> channel from <kbd class="calibre13">255</kbd> to about <kbd class="calibre13">115</kbd>.</li>
</ol>
<p class="calibre3">That's pretty straightforward. When you view it in VR, the canvas starts out just in front of you, but as you look around, its position seems to remain stationary and relative to the other objects in the scene, as shown in the following screenshot:</p>
<div class="mce-root1"><img src="assets/88d319a4-a884-45a7-9cfa-910a8123244b.png" class="calibre54"/></div>
<p class="calibre3">As we'll see in the next chapter, <a href="f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml" target="_blank" class="calibre10"><span>Chapter 7</span></a>, <em class="calibre14">Locomotion and Comfort</em>, when a first-person character moves through the scene, the HUD canvas will stay in front of you, at the same relative position to your body object, <kbd class="calibre13">MeMyselfEye</kbd>. You can try it now in the editor:</p>
<ol class="calibre15">
<li class="calibre12">
<p class="calibre3">Select <kbd class="calibre13">MeMyselfEye</kbd> in <span class="calibre6">Hierarchy</span>.</p>
</li>
<li class="calibre12">Press <span>Play</span>.</li>
</ol>
<ol start="3" class="calibre15">
<li class="calibre12">Then in the <span>Scene</span> window, using the <span>Move gizmo</span>, move the <kbd class="calibre13">MeMyselfEye</kbd> position. In VR, you'll see the HUD follows along like it's part of your body or a spaceship's cockpit.</li>
</ol>
<div class="packtinfobox">You might have realized that it's possible for objects in the scene to obfuscate the HUD panel since they're all occupying the same world space. If you need to prevent this, you have to ensure that the canvas is always rendered last so that it appears in front of any other objects regardless of its position in 3D space. In a conventional monoscopic game, you can do this by adding a second camera for the UI and changing its render priority. In stereoscopic VR, you have to accomplish this differently, possibly by writing a custom shader for your UI object or doing per-layer occlusion culling. This is an advanced topic; see the <em class="calibre2">World Space canvas on top of everything</em>? <span>discussion thread</span> for details: <a href="https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html" class="calibre20">https://answers.unity.com/questions/878667/world-space-canvas-on-top-of-everything.html</a>.</div>
<p class="calibre3">A variant of this HUD is to turn the canvas so that it's always facing you, while its position in 3D space is fixed. See the <em class="calibre14">Info bubble</em> section of this chapter to learn how to code this.</p>
<p class="calibre3">For kicks, let's write a script that removes the welcome message canvas after 15 seconds, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">WindshieldCanvas</kbd> selected, click on <span>Add Component</span> | <span>New Script</span>, name the script as <kbd class="calibre13">DestroyTimeout</kbd>, and click on <span>Create</span> and <span>Add</span>.</li>
<li class="calibre12">Open the script in MonoDevelop.</li>
</ol>
<p class="calibre3">Here's the <kbd class="calibre13">DestroyTimeout.cs</kbd> script:</p>
<pre class="calibre18">using UnityEngine; 
 
public class DestroyTimeout : MonoBehaviour <br class="title-page-name"/>{ 
  public float timer = 15f; 
 
  void Start () <br class="title-page-name"/>  { 
    Destroy (gameObject, timer); 
  } 
} </pre>
<p class="calibre3">The <kbd class="calibre13">WindshieldCanvas</kbd> will disappear after the timer runs out when the game starts up.</p>
<div class="packttip">A windshield HUD canvas is set as a child object of the first-person avatar, a sibling object of the camera.</div>
<p class="calibre3">In this example, we start to move further towards a first-person experience. Imagine sitting in a car or the cockpit of an aircraft. The HUD is projected on the windshield in front of you, but you're free to move your head to look around. In the scene's <span class="calibre6">Hierarchy</span> panel, there's a first-person object (<kbd class="calibre13">MeMyselfEye</kbd>) that contains the camera rig, possibly your avatar body, and the other furnishings surrounding you. When the vehicle moves in the game, the entire cockpit moves in unison, including the camera rig and the windshield. We'll work with this more later in this chapter and <a href="77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml" target="_blank" class="calibre10"><span>Chapter 7</span></a>, <em class="calibre14">Playing with Physics and Fire</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The game element UI</h1>
                </header>
            
            <article>
                
<p class="calibre3">When Ethan gets killed in the Diorama scene from <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>, the score value in the <kbd class="calibre13">GameController</kbd> object's <kbd class="calibre13">KillTarget</kbd> script is updated, but we don't show the current score to the player (set up in that chapter). We'll do this now, adding a scoreboard into the scene at the top-left corner of the backdrop <kbd class="calibre13">PhotoPlane</kbd> image:</p>
<ol class="calibre15">
<li class="calibre12">From the <span>Project</span> panel, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab directly into the <span>Scene</span> view</li>
<li class="calibre12">Rename it <kbd class="calibre13">ScoreBoard</kbd></li>
<li class="calibre12">With <kbd class="calibre13">ScoreBoard</kbd> selected, set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">-2.8</kbd>, <kbd class="calibre13">7</kbd>, <kbd class="calibre13">4.9</kbd>) and the <span>Width</span> and <span>Height</span> to (<kbd class="calibre13">3000</kbd>, <kbd class="calibre13">480</kbd>)</li>
<li class="calibre12">With <span>Text</span> under <kbd class="calibre13">ScoreBoard</kbd> selected, set the <span>Font Size</span> to <kbd class="calibre13">100</kbd> and choose a noticeable color such as red for the <span>Text</span></li>
<li class="calibre12">Enter the <span>Score: 0</span> sample string for <span>Text</span></li>
<li class="calibre12">Disable <span>Image</span> under <kbd class="calibre13">ScoreBoard</kbd> by unchecking the <span>Enable</span> check box or deleting it</li>
</ol>
<p class="calibre3">We have added another canvas to the scene, sized and placed it where we want, and formatted the text for display. It should look like this:</p>
<div class="mce-root1"><img src="assets/21c97363-120f-4523-86bb-e4315d89b258.png" class="calibre55"/></div>
<p class="calibre3">Now, we need to update the <kbd class="calibre13">KillTarget.cs</kbd> script, as follows:</p>
<ul class="calibre11">
<li class="calibre12">We may be using the UnityEngine UI classes:</li>
</ul>
<pre class="calibre44">using UnityEngine.UI; </pre>
<ul class="calibre11">
<li class="calibre12">Add a public variable for <kbd class="calibre13">scoreText</kbd>:</li>
</ul>
<pre class="calibre44">  public Text scoreText; </pre>
<ul class="calibre11">
<li class="calibre12">Add a line to <kbd class="calibre13">Start()</kbd> to initialize the score text:</li>
</ul>
<pre class="calibre44">scoreText.text = "Score: 0"; </pre>
<ul class="calibre11">
<li class="calibre12">And add a line to <kbd class="calibre13">Update()</kbd> to change the score text when the score changes:</li>
</ul>
<pre class="calibre44">score += 1; 
scoreText.text = "Score: " + score; </pre>
<p class="calibre3">After saving the script file, go back into the Unity editor, select <kbd class="calibre13">GameController</kbd> in the <span class="calibre6">Hierarchy</span> panel, and then drag and drop the <span class="calibre6">Text</span> object under <kbd class="calibre13">ScoreBoard</kbd> from <span class="calibre6">Hierarchy</span> onto the <span class="calibre6">Score Text</span> field in <span class="calibre6">Kill Target</span> (<span class="calibre6">Script</span>).</p>
<p class="calibre3">Run the scene in VR. Each time you kill Ethan (by staring at him), your score will be updated on the <kbd class="calibre13">ScoreBoard</kbd> on the upper left of <kbd class="calibre13">PhotoPlane</kbd>.</p>
<div class="packttip">A game element UI canvas is a part of the scene like any other game object.</div>
<p class="calibre3">This was an example of using an object that's a part of the scene for information display. Our example is pretty simplistic. You might want to make a nicer modeled scoreboard, like the one you'd see in a stadium or something. The point is, it's a part of the scene and to see the message you might have to actually turn your head and, well, look at it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using TextMeshPro</h1>
                </header>
            
            <article>
                
<p class="calibre3">To make a billboard glow like a neon sign, you can use TextMesh Pro which presently comes included free with Unity. For instance:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">ScoreBoard</kbd> selected in Hierarchy, create a new <kbd class="calibre13">TextMesh</kbd> text element (right-click <span>UI</span> | <span>TextMeshPro - Text</span>).</li>
<li class="calibre12">This replaces our standard UI text element, so disable the <kbd class="calibre13">Text</kbd> object.</li>
<li class="calibre12">On the TMP text, set its <span>Font Asset</span> to <span>Bangers SDF.</span></li>
<li class="calibre12">For its <span>Material Preset</span>, use <span>Bangers SDF Glow.</span></li>
<li class="calibre12">Scroll to <span>Glow</span> settings to adjust the colors and other settings as you desire.</li>
</ol>
<p class="calibre3">You can even write a script that cyclically modifies the glow settings to make a flashing, glowing sign!</p>
<p class="calibre3">If you choose to try this, be sure to update the GameController's <kbd class="calibre13">KillTarget</kbd> script to use the TMP object rather than the UI one. <kbd class="calibre13">Modify KillTarget.cs</kbd> as follows:</p>
<p class="calibre3">We may be using the UnityEngine TextMesh Pro classes:</p>
<pre class="calibre18">using TMP; </pre>
<p class="calibre3">Replace the data type of the <kbd class="calibre13">scoreText</kbd> variable with <kbd class="calibre13">TMP_Text</kbd>:</p>
<pre class="calibre18">  public TMP_Text scoreText; </pre>
<p class="calibre3">Drag the TMP text item onto the slot in the Inspector. The rest of the script is unchanged since <kbd class="calibre13">TMP_Text</kbd> has a <kbd class="calibre13">text</kbd> property just as the UI text one has. </p>
<div class="packtinfobox"><strong class="calibre1">TextMesh Pro</strong> is a great tool for text formatting and layout in Unity. It is a replacement for Unity's UI Text, with added advanced text rendering, custom shaders, typographic controls such as paragraph spacing and kerning, and a lot more. It was a third-party plugin and is now included free with Unity. Documentation can be found here: <a href="http://digitalnativestudios.com/textmeshpro/docs/" class="calibre20">http://digitalnativestudios.com/textmeshpro/docs/.</a></div>
<p class="calibre3">Here is a screenshot of the scoreboard text using a glow effect with TextMesh Pro and its Inspector settings:</p>
<div class="mce-root1"><img src="assets/47a19eb5-82ed-4e7b-8838-cb785582e14e.png" class="calibre24"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Info bubble</h1>
                </header>
            
            <article>
                
<p class="calibre3">In a comic book, when a character says something, it's shown in a <em class="calibre14">speech bubble</em>. In many online social VR worlds, participants are represented by avatars and, hovering above someone's avatar, their name is displayed. I'll call this type of user interface an <em class="calibre14">info bubble</em>.</p>
<p class="calibre3">Info bubbles are located in world space at a specific 3D position, but the canvas should always be facing the camera. We can ensure this with a script.</p>
<p class="calibre3">In this example, we'll display the <span class="calibre6">X</span>, <span class="calibre6">Z</span> location of the <kbd class="calibre13">WalkTarget</kbd> object (set up in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>), controlled by the <kbd class="calibre13">LookMoveTo.cs</kbd> script. To add the info bubble, perform the following steps:</p>
<ol class="calibre15">
<li class="calibre12">From the <span>Project</span> window, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab directly into the <span>Hierarchy</span> window so that it's a child of <kbd class="calibre13">WalkTarget</kbd>.</li>
<li class="calibre12">Rename it to <kbd class="calibre13">InfoBubble</kbd>.</li>
<li class="calibre12">With <kbd class="calibre13">InfoBubble</kbd> selected, set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.2</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">With <span>Text</span> under <kbd class="calibre13">InfoBubble</kbd> selected, set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>) and <span>Right</span> and <span>Bottom</span> to <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>.</li>
<li class="calibre12">With <span>Image</span> under <kbd class="calibre13">InfoBubble</kbd> selected, set <span>Scale</span> to (<kbd class="calibre13">0.7</kbd>, <kbd class="calibre13">0.2</kbd>, <kbd class="calibre13">1</kbd>).</li>
<li class="calibre12">Enter the <kbd class="calibre13">X:00.00</kbd>, <kbd class="calibre13">Z:00.00</kbd> sample string for <span>Text</span>.</li>
</ol>
<p class="calibre3">Verify that the canvas and text look roughly the right size and position and adjust the text as you please. (In my scene, there's a cube at the origin so I temporarily disable it to see the WalkTarget also at the origin.)</p>
<p class="calibre3">Now, we will modify the <kbd class="calibre13">LookMoveTo.cs</kbd> script to show the current <kbd class="calibre13">WalkTarget</kbd> <span class="calibre6">X</span>, <span class="calibre6">Z</span> position. Open the script in the MonoDevelop editor and add the following code:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.UI; 
 
public class LookMoveTo : MonoBehaviour <br class="title-page-name"/>{ 
  public GameObject ground; 
  public Transform infoBubble; 
 
  private Text infoText; 
 
  void Start () <br class="title-page-name"/>  { 
    if (infoBubble != null) <br class="title-page-name"/>    { 
      infoText = infoBubble.Find ("Text").GetComponent&lt;Text&gt; (); 
    } 
  } 
 
  void Update () <br class="title-page-name"/>  { 
    Transform camera = Camera.main.transform; 
    Ray ray; 
    RaycastHit[] hits; 
    GameObject hitObject; 
 
    ray = new Ray (camera.position, camera.rotation * Vector3.forward); 
    hits = Physics.RaycastAll (ray); 
    for (int i=0; i &lt; hits.Length; i++) <br class="title-page-name"/>    { 
      RaycastHit hit = hits [i]; 
      hitObject = hit.collider.gameObject; 
      if (hitObject == ground) <br class="title-page-name"/>      { 
        if (infoBubble != null) <br class="title-page-name"/>        { 
          infoText.text = "X: " + hit.point.x.ToString("F2") + <br class="title-page-name"/>                          "Z: " + hit.point.z.ToString("F2"); 
 
          infoBubble.LookAt(camera.position); 
          infoBubble.Rotate (0, 180f, 0); 
        } 
        transform.position = hit.point; 
      } 
    } 
  }
} </pre>
<p class="calibre3">The line <kbd class="calibre13">using UnityEngine.UI;</kbd> states that this script will need access to the Unity UI API. We defined a <kbd class="calibre13">public Transform infoBubble</kbd> variable, which will be set to the <kbd class="calibre13">WalkTarget/InfoBubble</kbd> object. We also defined a <kbd class="calibre13">private Text infoText</kbd> variable, which gets set to the <kbd class="calibre13">InfoBubble</kbd> object's <span class="calibre6">Text</span> object. The script assumes that the given <kbd class="calibre13">InfoBubble</kbd> has a child <span class="calibre6">Text</span> UI object.</p>
<p class="calibre3">Unfortunately, the overuse of the word <em class="calibre14">text</em> can be confusing. The <kbd class="calibre13">infoText</kbd> <em class="calibre14">text</em> object has a <em class="calibre14">text</em> component, which has a <em class="calibre14">text</em> string property! You can see what I mean in Unity editor. If you examine the Inspector panel while <kbd class="calibre13">InfoBubble/Text</kbd> is selected, you'll see that it contains a <span class="calibre6">Text</span> (<span class="calibre6">Script</span>) component, which has a <span class="calibre6">Text</span> field. This <span class="calibre6">Text</span> field is where we write our messages. So in <kbd class="calibre13">Setup()</kbd>, we find the <kbd class="calibre13">WalkTarget/InfoBubble/Text</kbd> object, assigning the <span class="calibre6">Text</span> object to <kbd class="calibre13">infoText</kbd>, and then in <kbd class="calibre13">Update()</kbd>, we set the string value of <kbd class="calibre13">infoText.text</kbd> so that the score is shown on the bubble canvas.</p>
<p class="calibre3">Also, in <kbd class="calibre13">Update()</kbd>, we transformed the <kbd class="calibre13">infoBubble</kbd> canvas so that it's always facing us using <kbd class="calibre13">infoBubble.LookAt()</kbd> and passing it the camera position. The result of <kbd class="calibre13">LookAt()</kbd> has the canvas facing away from us. So, we also need to rotate it around the <em class="calibre14">y </em>axis by 180 degrees.</p>
<p class="calibre3">Save the script and drag the <kbd class="calibre13">InfoBubble</kbd> object from <span class="calibre6">Hierarchy</span> onto the <span class="calibre6">Info Bubble</span> slot in the <span class="calibre6">Look Move To</span> (<span class="calibre6">Script</span>) component. If you don't assign the <kbd class="calibre13">InfoBubble</kbd> canvas, the script will still run because we test for <kbd class="calibre13">null</kbd> objects before we reference them.</p>
<div class="packttip">An info bubble UI canvas is attached to other game objects, moving when they move and always facing the camera (like a billboard).</div>
<p class="calibre3">Run the scene in VR and you'll see that <kbd class="calibre13">WalkTarget</kbd> has a little info bubble telling us about its <span class="calibre6">X</span>, <span class="calibre6">Z</span> position.</p>
<div class="packtinfobox">Extra challenge: Want to try something else? Implement a health meter bar for Ethan. Use the <kbd class="calibre26">countDown</kbd> variable in the <kbd class="calibre26">KillTarget</kbd> script to determine his percentage of health and to display a health meter (horizontal bar) above his head when it's not at 100 percent.</div>
<p class="calibre3">Info bubbles are useful when you need to display UI messages that belong to specific objects in the scene and may move in concert with the objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An in-game dashboard with input events</h1>
                </header>
            
            <article>
                
<p class="calibre3">An in-game dashboard or control panel is a UI display that is integrated into the game itself. A typical scenario is an automobile or a spaceship, where you are seated in a cockpit. At waist level (desk level) is a panel with a set of controls, gauges, information displays, and so on. Dashboards generally feel more natural in a seated VR experience.</p>
<p class="calibre3">A few pages back, we discussed windshield HUDs. Dashboards are pretty much the same thing. One difference is that the dashboard may be more obviously part of the level environment and not simply an auxiliary information display or a menu.</p>
<p class="calibre3">In fact, dashboards can be a very effective mechanism to control VR motion sickness. Researchers have found that when a VR user has a better sense of being grounded and has a consistent <em class="calibre14">horizon line</em> in view, he's much less likely to experience nausea while moving around a virtual space. In contrast, being a floating one-dimensional eyeball with no sense of self or grounding is asking for trouble! (See the <em class="calibre14">Oculus Best Practices</em> for this, and other great tips, by visiting <a href="https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/" class="calibre10"><span>https://developer.oculus.com/documentation/intro-vr/latest/concepts/bp_intro/</span></a>).</p>
<p class="calibre3">In this example, we'll make a simple dashboard with Start/Stop buttons. For now, the buttons will operate a water hose in the scene to help fend off the zombies. (<em class="calibre14">Why not?</em>) Like other examples in this chapter, this project uses the scene created in <a href="b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml" target="_blank" class="calibre10">Chapter 4</a>, <em class="calibre14">Gaze-Based Control</em>.</p>
<p class="calibre3">This project is a bit more complicated than you might expect. However, if you've ever had to build anything in Minecraft, you know that even the simple things may require assembling multiple parts. Here's what we will do:</p>
<ul class="calibre11">
<li class="calibre12">Create a dashboard canvas with two functional buttons—Start and Stop</li>
<li class="calibre12">Add a water hose to the scene and wire it to the buttons</li>
<li class="calibre12">Write a simple version of the script that activates the buttons</li>
<li class="calibre12">Highlight a button by looking at it</li>
<li class="calibre12">Improve the script to activate the button only if it's highlighted</li>
</ul>
<p class="calibre3">So let's get to it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a dashboard with buttons</h1>
                </header>
            
            <article>
                
<p class="calibre3">First, let's create a dashboard with a Start and a Stop button, as follows:</p>
<ol class="calibre15">
<li class="calibre12">From the <span>Project</span> window, drag the <kbd class="calibre13">DefaultCanvas</kbd> prefab onto the <kbd class="calibre13">MeMyselfEye</kbd> object in the <span>Hierarchy</span> panel so that it becomes a child.</li>
<li class="calibre12">Rename it to <kbd class="calibre13">Dashboard</kbd>.</li>
<li class="calibre12">With <kbd class="calibre13">Dashboard</kbd> selected, set the <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>, <kbd class="calibre13">0.6</kbd>, <kbd class="calibre13">0.6</kbd>) and its <span>Rotation</span> to (<kbd class="calibre13">60</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">0</kbd>). Feel free to adjust the position for preferred comfort zone and your specific VR device camera rig.</li>
<li class="calibre12">Disable or delete the <span>Text</span> child object of <kbd class="calibre13">Dashboard</kbd>.</li>
</ol>
<p class="calibre3">This places the dashboard 1 m below your eyes and a little out in front.</p>
<p class="calibre3">For a <em class="calibre14">work-in-progress</em> look, if you'd like, I've included an image sketch of a vehicle dashboard that you can use, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Import the <kbd class="calibre13">DashboardSketch.png</kbd> file into your <span>Project</span> (such as the <kbd class="calibre13">Assets/Textures</kbd> folder).</li>
<li class="calibre12">Add a new <span>GameObject</span> | <span>UI</span> | <span>Raw Image</span> as a child of <kbd class="calibre13">Dashboard</kbd>.</li>
<li class="calibre12">Drag the <kbd class="calibre13">DashboardSketch</kbd> texture from the <span>Project</span> panel onto the <span>Texture</span> field of the <span>Raw Image</span> component.</li>
<li class="calibre12">Set its <span>Rect Transform</span> component's <span>Pos X</span>, <span>Pos Y</span>, <span>Pos Z</span> to (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>), <span>Width</span> to <kbd class="calibre13">140</kbd>, and <span>Height</span> to <kbd class="calibre13">105</kbd>.</li>
<li class="calibre12">It should be <span>Anchored</span> at <span>middle</span>-<span>center</span> (<kbd class="calibre13">0.5</kbd>,<kbd class="calibre13">0.5</kbd>) in <span>X</span>, <span>Y</span>, and <span>Pivot</span>, with <span>Rotation</span> (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Set <span>Scale</span> to (<kbd class="calibre13">4.5</kbd>,<kbd class="calibre13">4.5</kbd>,<kbd class="calibre13">4.5</kbd>).</li>
</ol>
<p class="calibre3">Next, we will add the Start and Stop buttons. They can go anywhere you'd like on the canvas, but the sketch has two nice spaces predefined for them:</p>
<ol class="calibre15">
<li class="calibre12">Add a new <span>GameObject</span> | <span>UI</span> | <span>Button</span> as a new child of <kbd class="calibre13">Dashboard</kbd>. Name it <kbd class="calibre13">StartButton</kbd>.</li>
<li class="calibre12">Set its <span>Rect Transform</span> component's <span>X</span>, <span>Y</span>, <span>Z</span> to (<kbd class="calibre13">-48</kbd>, <kbd class="calibre13">117</kbd>, <kbd class="calibre13">0</kbd>), the <span>Width </span>and <span>Height</span> to (<kbd class="calibre13">60</kbd>, <kbd class="calibre13">60</kbd>), and <span>Anchored</span> to <span>center</span>-<span>middle</span> (<kbd class="calibre13">0.5</kbd>). No <span>Rotation</span> and <span>Scale</span> of <kbd class="calibre13">1</kbd>.</li>
<li class="calibre12">In the button's <span>Image (Script)</span> component pane, for <span>Source Image</span>, click on the tiny circle on the far right to open the <span>Select Sprite</span> picker and choose <kbd class="calibre13">ButtonAcceleratorUpSprite</kbd> (which you may have imported into the <kbd class="calibre13">Assets/Standard Assets/CrossPlatformInput/Sprites</kbd> folder).</li>
<li class="calibre12">In the button's <span>Button (Script)</span> component pane, for the <span>Normal Color</span>, I used RGB (<kbd class="calibre13">89</kbd>,<kbd class="calibre13">154</kbd>,<kbd class="calibre13">43</kbd>) and set <span>Highlighted Color</span> to (<kbd class="calibre13">105</kbd>, <kbd class="calibre13">255</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Similarly, create another button named <kbd class="calibre13">StopButton</kbd> with the <span>Rect Transform</span> component's <span>X</span>, <span>Y</span>, <span>Z</span> (<kbd class="calibre13">52</kbd>, <kbd class="calibre13">118</kbd>, <kbd class="calibre13">0</kbd>) and set the <span>Width</span> and<span> </span><span>Height</span> to (<kbd class="calibre13">60</kbd>, <kbd class="calibre13">60</kbd>). For <span>Source Image</span>, select <kbd class="calibre13">ButtonBrakeOverSprite</kbd>, then choose the <span>Normal Color</span> (<kbd class="calibre13">236</kbd>, <kbd class="calibre13">141</kbd>, <kbd class="calibre13">141</kbd>) and <span>Highlighted Color</span> (<kbd class="calibre13">235</kbd>, <kbd class="calibre13">45</kbd>, <kbd class="calibre13">0</kbd>).</li>
</ol>
<p class="calibre3">The result should look like this:</p>
<div class="mce-root1"><img src="assets/f7764fc8-bada-442a-8b09-1a9c2bd69425.png" class="calibre56"/></div>
<p class="calibre3">One last thing. If you're using the <kbd class="calibre13">ReticleCursor</kbd> that was created earlier in this chapter with the <kbd class="calibre13">CursorPositioner.cs</kbd> script, we want the dashboard itself to have a collider for the script. We can achieve this by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">Dashboard</kbd> selected, right-click for options, and navigate to<br class="title-page-name"/>
<span>3D Object</span> | <span>Plane</span>.</li>
<li class="calibre12">Set its <span>Position</span> to (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>), <span>Rotation</span> to (<kbd class="calibre13">270</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>), and <span>Scale</span> to (<kbd class="calibre13">64</kbd>,<kbd class="calibre13">1</kbd>,<kbd class="calibre13">48</kbd>).</li>
<li class="calibre12">Disable its <span>Mesh Renderer</span> (but leave its <span>Mesh Collider</span> enabled).</li>
</ol>
<p class="calibre3">Now the dashboard has a plane child that isn't rendered, but its collider will be detected when <kbd class="calibre13">CursorPositioner</kbd> does its ray cast. We do this to see your gaze on this dashboard panel rather than the ground below even when not looking directly at a button.</p>
<p class="calibre3">Having a single toggle button with pressed and released states might be better than separate <span class="calibre6">Start</span> and <span class="calibre6">Stop</span> buttons. When you're done with this chapter, go ahead and figure out how to do it!</p>
<p class="calibre3">We just created a world space canvas that should appear in VR at waist or desk level. We decorated it with a dashboard sketch and added two UI buttons. Now, we'll wire up the buttons to specific events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linking the water hose to the buttons</h1>
                </header>
            
            <article>
                
<p class="calibre3">Let's first give the buttons something to do, such as the action of turning on a water hose. If we aim it strategically, it might even fend off rogue zombies. Coincidentally, the Unity <span class="calibre6">Particle Systems</span> under <span class="calibre6">Standard Assets</span> which we imported earlier has a water hose that we can use. Add it to the scene as follows:</p>
<ol class="calibre15">
<li class="calibre12">If you haven't done so already, import the <span>Particle Systems</span> standard asset from the main menu bar by navigating to <span>Assets</span> | <span>Import Package</span> | <span>ParticleSystems</span>.</li>
<li class="calibre12">In the <span>Project</span> window, find the <kbd class="calibre13">Assets/Standard Assets/Particle Systems/Prefabs/Hose</kbd> prefab and drag it into the <span>Hierarchy</span> window.</li>
<li class="calibre12">Set its <span>Transform</span> component's <span>X</span>, <span>Y</span>, <span>Z</span> to (<kbd class="calibre13">-3</kbd>, <kbd class="calibre13">0</kbd>, <kbd class="calibre13">1.5</kbd>) and <span>Rotation</span> to (<kbd class="calibre13">340</kbd>, <kbd class="calibre13">87</kbd>, <kbd class="calibre13">0</kbd>).</li>
<li class="calibre12">Ensure that <span>Hose</span> is enabled (check its <span>Enable</span> checkbox).</li>
<li class="calibre12">Unfold the <span>Hose</span> in <span>Hierarchy</span> so that you can see its child <span>WaterShower</span> particle system. Select it.</li>
<li class="calibre12">In <span>Inspector</span>, in the <span>Particle System</span> properties pane, look for <span>Play On Awake</span> and uncheck it.</li>
</ol>
<p class="calibre3">Note that the <span class="calibre6">Hose</span> object in <span class="calibre6">Hierarchy</span> has a <kbd class="calibre13">WaterShower</kbd> child object. This is the actual particle system that we will control with the buttons. It should start as <em class="calibre14">off</em>.</p>
<p class="calibre3">The <span class="calibre6">Hose</span> prefab itself comes with mouse-driven script that we don't want to use,<br class="calibre7"/>
so disable it as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <span>Hose</span> selected, disable (uncheck) its <span>Hose</span> (<span>Script</span>).</li>
<li class="calibre12">Also, disable (uncheck) the <span>Simple Mouse Rotator</span> (<span>Script</span>) component.</li>
</ol>
<p class="calibre3">Now we will wire up <kbd class="calibre13">StartButton</kbd> to the <span class="calibre6">WaterShower</span> particle system by telling the buttons to listen for the <kbd class="calibre13">OnClick()</kbd> events, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Unfold the <span>Hose</span> in <span>Hierarchy</span> so that you can see its child <span>WaterShower</span> particle system.</li>
<li class="calibre12">In <span>Hierarchy</span>, select <kbd class="calibre13">StartButton</kbd> (under <kbd class="calibre13">MeMyselfEye/Dashboard</kbd>).</li>
<li class="calibre12">Note that <span>in the </span><span>Inspector,</span> the <span>On Click()</span> pane of the <kbd class="calibre13">Button</kbd> component is empty. Click on the <em class="calibre2">Plus</em> (<span>+</span>) icon on the lower right of that pane to reveal a new field labeled <span>None</span> (<span>Object</span>).</li>
<li class="calibre12">Drag the <span>WaterShower</span> particle system from <span>Hierarchy</span> onto the <span>None (Object)</span> field.</li>
<li class="calibre12">Its function selector, the default value, is <span>No Function</span>. Change it to <span>ParticleSystem</span> | <span>Play()</span>.</li>
</ol>
<p class="calibre3">OK. The steps are similar for the <kbd class="calibre13">StopButton</kbd>, as follows:</p>
<ol class="calibre15">
<li class="calibre12">In <span>Hierarchy</span>, select <kbd class="calibre13">StopButton</kbd>.</li>
<li class="calibre12">Click on the <em class="calibre2">Plus</em> (<span>+</span>) icon on the lower right of it's <span>On Click()</span> pane.</li>
<li class="calibre12">Drag the <span>WaterShower</span> from <span>Hierarchy</span> onto the <span>None</span> (<span>Object</span>) field.</li>
<li class="calibre12">Its function selector, the default value, is <span>No Function</span>. Change it to <span>ParticleSystem</span> | <span>Stop()</span>.</li>
</ol>
<p class="calibre3">The Start and Stop buttons <em class="calibre14">listen for</em> <kbd class="calibre13">OnClick()</kbd> <em class="calibre14">events</em>, and when one comes, it will<br class="calibre7"/>
call the <span class="calibre6">WaterShower</span> particle system's <kbd class="calibre13">Play()</kbd> and <kbd class="calibre13">Stop()</kbd> functions respectively. To make it work, we need to press the buttons.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Activating buttons from the script</h1>
                </header>
            
            <article>
                
<p class="calibre3">Before we give the user a way to press the buttons, let's see how we can do this from a script. Create a new script on <kbd class="calibre13">GameController</kbd>, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">GameController</kbd> selected in Hierarchy, press <span>Add Component</span> | <span>New Script</span> to create a script named <kbd class="calibre13">ButtonExecuteTest</kbd>.</li>
<li class="calibre12">Open the script in MonoDevelop.</li>
</ol>
<p class="calibre3">In the following script, we turn the hose on and off in five-second intervals, as follows:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.UI; 
 
public class ButtonExecuteTest : MonoBehaviour <br class="title-page-name"/>{ 
  public Button startButton;<br class="title-page-name"/>  public Button stopButton;<br class="title-page-name"/> 
  private bool isOn = false; 
  private float timer = 5.0f; 
  
  void Update () <br class="title-page-name"/>  { 
    timer -= Time.deltaTime; 
    if (timer &lt; 0.0f) <br class="title-page-name"/>    { 
      isOn = !isOn; 
      timer = 5.0f; 
 
      if (isOn) <br class="title-page-name"/>      { 
        stopButton.onClick.Invoke(); 
      } else <br class="title-page-name"/>      { 
        startButton.onClick.Invoke(); 
      } 
    } 
  } 
} </pre>
<p class="calibre3">The script manages a Boolean <kbd class="calibre13">isOn</kbd> value, which says if the hose is on or off. And it has a timer which counts down from 5 seconds on each update. We use the <kbd class="calibre13">private</kbd> keyword for variables that are only used within this script, whereas the <kbd class="calibre13">public</kbd> ones can be viewed and modified via the Unity editor and other scripts. For <kbd class="calibre13">startButton</kbd> and <kbd class="calibre13">stopButton</kbd>,  you'll drag and drop them in the Unity editor.</p>
<p class="calibre3">In this script, we use the <kbd class="calibre13">UnityEngine.UI</kbd>. As we saw in the previous chapter, <em class="calibre14">Events</em> are a way for different components to talk to one another. When an event occurs, such as a button press, a function in another script may get called. In our case, we're going to trigger an event corresponding to the start button press, and another corresponding to the stop button press, as we set up in the Inspector.</p>
<p class="calibre3">Save the script and click on <span class="calibre6">Play</span>. The hose should turn on and off every five seconds.</p>
<p class="calibre3">Now that we have tested the event system connection between the button clicks and the hose, we can disable this script before moving on to the next one:</p>
<ol class="calibre15">
<li class="calibre12">With<span> </span><kbd class="calibre13">GameController</kbd><span> </span>selected,</li>
<li class="calibre12">Disable the<span> </span><kbd class="calibre13">ButtonExecuteTest</kbd><span> </span>component by unchecking its<span> </span><span>Enable</span><span> </span>checkbox, or remove the component.</li>
</ol>
<div class="packttip">Breaking down a complex feature into bite-sized pieces and testing them separately is an excellent implementation strategy.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Look to highlight a button</h1>
                </header>
            
            <article>
                
<p class="calibre3">Meanwhile, let's detect when the user is looking at a button and highlight it. Although <span class="calibre6">Button</span> is a Unity UI object, it needs to be detected with a ray cast. There may be other ways to accomplish this, as discussed later in this chapter, but here we will add a game object sphere to each button and cast a ray to detect it. First, add the spheres by performing the following steps:</p>
<ol class="calibre15">
<li class="calibre12">In the <span>Hierarchy</span> panel, select <kbd class="calibre13">StartButton</kbd> (under <kbd class="calibre13">MeMyselfEye/Dashboard</kbd>), right-click for options, and navigate to <span>3D Object</span> | <span>Sphere</span>.</li>
<li class="calibre12">Set its <span>Transform</span> component's <span>Scale</span> to (<kbd class="calibre13">52</kbd>, <kbd class="calibre13">52</kbd>, <kbd class="calibre13">52</kbd>) so that it fits the<br class="title-page-name"/>
button size.</li>
<li class="calibre12">Disable the sphere's <span>Mesh Renderer</span> <span>by unchecking the</span> <span>Mesh Renderer</span> <span>checkbox.</span></li>
</ol>
<p class="calibre3">Also, repeat these steps for <kbd class="calibre13">StopButton</kbd>. A shortcut is to duplicate the sphere, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Right-click the Sphere and choose <span>Duplicate</span>.</li>
<li class="calibre12">Drag the duplicated item (<kbd class="calibre13">Sphere (1)</kbd>) into <kbd class="calibre13">StopButton</kbd>.</li>
<li class="calibre12">Reset it <span>Position</span> to (<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>,<kbd class="calibre13">0</kbd>).</li>
</ol>
<p class="calibre3">Now, create a new script on <kbd class="calibre13">StartButton</kbd>, as follows:</p>
<ol class="calibre15">
<li class="calibre12">With <kbd class="calibre13">StartButton</kbd> <span>selected, navigate to</span> <span>Add Component</span> | <span>New Script</span> <span>to create a script named</span> <kbd class="calibre13">RespondToGaze</kbd><span>.</span></li>
<li class="calibre12">Open the script for editing.</li>
</ol>
<p class="calibre3">In the following <kbd class="calibre13">RespondToGaze.cs</kbd> script, we tell the button to become highlighted when you look at it, using the child Sphere object's collider:</p>
<pre class="calibre18">using UnityEngine; 
using UnityEngine.UI; 
 
public class RespondtoGaze : MonoBehaviour <br class="title-page-name"/>{ <br class="title-page-name"/>  public bool highlight = true;<br class="title-page-name"/>  private Button button; <br class="title-page-name"/>  private bool isSelected;<br class="title-page-name"/><br class="title-page-name"/>  void Start ()<br class="title-page-name"/>  {<br class="title-page-name"/>    button = GetComponent&lt;Button&gt;();<br class="title-page-name"/>  }
 
  void Update () <br class="title-page-name"/>  { <br class="title-page-name"/>    isSelected = false;<br class="title-page-name"/>    Transform camera = Camera.main.transform; 
    Ray ray = new Ray(camera.position, camera.rotation * Vector3.forward); 
    RaycastHit hit; 
    if (Physics.Raycast (ray, out hit) &amp;&amp;<br class="title-page-name"/>        (hit.transform.parent != null) &amp;&amp;<br class="title-page-name"/>        (hit.transform.parent.gameObject == gameObject) <br class="title-page-name"/>    { 
      isSelected = true;
    } 

    if (isSelected)<br class="title-page-name"/>    {<br class="title-page-name"/>      if (highlight)<br class="title-page-name"/>        button.Select();<br class="title-page-name"/>    }<br class="title-page-name"/>    else {<br class="title-page-name"/>      UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(null);<br class="title-page-name"/>    }
  } 
}</pre>
<p class="calibre3">In this script, on each update, we cast a ray from the camera. If it hits this button's sphere collider, then the hit object's parent should be this button. So (after checking that the hit object has a parent), we compare the parent gameObject to this button's gameObject.</p>
<p class="calibre3">If the gaze has selected this button, we trigger the button's <span class="calibre6">Select</span> to make it highlight. The highlighting is done within Unity's <kbd class="calibre13">EventSystem</kbd>. While the EventSystem has all this implemented for mouse clicks and screen touches, we have to manually tell the button it's been selected by calling <kbd class="calibre13">button.Select()</kbd>.</p>
<p class="calibre3">Unhighlighting the button is not so obvious. The EventSystem maintains a currently selected object across your runtime scene. We clear it by passing null to <kbd class="calibre13">SetSelectedGameObject()</kbd>.</p>
<p class="calibre3">Save the script and <em class="calibre14">Play</em>. When you gaze at a button, it should highlight, and when you gaze away from it, it should remove the highlight.</p>
<p class="calibre3">This is also an example of a reusable component script. We just wrote and tested it for the StartButton. We can use the same script for the StopButton:</p>
<ol class="calibre15">
<li class="calibre12">Select the <span>StopButton</span> from the <span>Hierarchy</span>.</li>
<li class="calibre12">Drag the <span>RespondToGaze</span> script from the <span>Project Assets</span> onto the button, or</li>
<li class="calibre12">Select <span>Add Component</span> | <span>Scripts</span> | <span>RespondToGaze</span>.</li>
</ol>
<p class="calibre3">Test the project one more time. Both buttons should highlight when you gaze at them.</p>
<div class="packtinfobox">If you are using  Google VR for Cardboard or Daydream, you can include the <kbd class="calibre26">GvrEventSystem</kbd> prefab in your scene. Then this <kbd class="calibre26">RespondToGaze</kbd> script becomes unnecessary and redundant. The <kbd class="calibre26">Daydream</kbd> component already supports gaze-based select, highlight, and clicking with the input controller. But <span>I encourage you to follow along with this project nonetheless to experience how this functionality can be implemented. If so, temporarily disable <kbd class="calibre26">GvrEventSystem</kbd> in your scene.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looking and then clicking to select</h1>
                </header>
            
            <article>
                
<p class="calibre3">To be a functional dashboard, the buttons should operate when they're clicked. In <a href="21722631-9544-4b1e-a888-877d34b0fff7.xhtml" target="_blank" class="calibre10">Chapter 5</a>, <em class="calibre14">Handy Interactables</em>, we explored the Unity Input system, including the <kbd class="calibre13">"Fire1"</kbd> event and other hand controller buttons. You may want to review that now. And choose which code snippet you want to use, if not the basic <kbd class="calibre13">Input.GetButtonDown("Fire1")</kbd>.</p>
<p class="calibre3">The changes to make to the <kbd class="calibre13">RespondToGaze.cs</kbd> script are pretty simple. At top of the class, add the following public variables:</p>
<pre class="calibre18">public bool clicker = true;<br class="title-page-name"/>public string inputButton = "Fire1";</pre>
<p class="calibre3"><span class="calibre6"> At the bottom of </span><kbd class="calibre13">Update()</kbd><span class="calibre6">, make the following changes:</span></p>
<pre class="calibre18">  ... <br class="title-page-name"/>  if (isSelected)<br class="title-page-name"/>  {<br class="title-page-name"/>    if (highlight)<br class="title-page-name"/>        button.Select();<br class="title-page-name"/>    if (clicker &amp;&amp; InputGetButtonDown("Fire1"))<br class="title-page-name"/>        button.onClick.Invoke();<br class="title-page-name"/>  }</pre>
<p class="calibre3">When the controller <kbd class="calibre13">"Fire1"</kbd> button is pressed, it will trigger a click of the UI button.</p>
<p class="calibre3">The component gives you the option to enable highlights and/or clicking with the input controller. You can also choose the logical input button that will trigger the click events.</p>
<p class="calibre3">We now have an in-game dashboard with buttons that respond to user input, which controls the behavior of an object (water hose) in the scene.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looking and starting to select</h1>
                </header>
            
            <article>
                
<p class="calibre3">Instead of using a clicker, we can use a time-based selection to click on the button. To make this work, we'll keep a countdown timer while staring at a button, much like the one that we used to kill Ethan in the previous chapter.</p>
<p class="calibre3">Change the<span class="calibre6"> </span><kbd class="calibre13">RespondToGaze.cs</kbd><span class="calibre6"> </span>script.<span class="calibre6"> </span>At top of the class, add the following variables:</p>
<pre class="calibre18">public bool timedClick = true;<br class="title-page-name"/>public float delay = 2.0f;<br class="title-page-name"/><br class="title-page-name"/>private float timer = 0f;</pre>
<p class="calibre3"><span class="calibre6">In </span><kbd class="calibre13">Update()</kbd><span class="calibre6">, make the following changes:</span></p>
<pre class="calibre18">... <br class="title-page-name"/>  if (isSelected)<br class="title-page-name"/>  {<br class="title-page-name"/>    if (highlight)<br class="title-page-name"/>        button.Select();<br class="title-page-name"/>    if (clicker &amp;&amp; Input.GetButtonDown("Fire1"))<br class="title-page-name"/>        button.onClick.Invoke();<br class="title-page-name"/>    if (timedClick) <br class="title-page-name"/>    {<br class="title-page-name"/>      timer += Time.deltaTime;<br class="title-page-name"/>      if (timer &gt;= delay)<br class="title-page-name"/>        button.onClick.Invoke();<br class="title-page-name"/>  }<br class="title-page-name"/>  else {<br class="title-page-name"/>    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(null);<br class="title-page-name"/>    timer = 0f;<br class="title-page-name"/>  }</pre>
<p class="calibre3">Now, not only will a button click get involved on <kbd class="calibre13">Input.GetButtonDown</kbd>, but also if you gaze at the button long enough (when <kbd class="calibre13">timedClick</kbd> is <kbd class="calibre13">true</kbd>). We begin a timer when the button is selected (highlighted) and count up. When the timer expires the click event is invoked. If the button is deselected before then, the timer is reset to zero.</p>
<p class="calibre3"><em class="calibre14">Does it work for you? Woohoo!</em></p>
<p class="calibre3">So this was a relatively complex project. The goal was to create a dashboard with buttons that turn a hose on and off. We broke it down into discrete steps, added the objects and components a step at a time, and tested each step to make sure that it worked as expected before moving on. If you tried to implement this all at once or blew through it without testing, things can (and will) go wrong, and it'll be much harder to figure out where the problem cropped up.</p>
<div class="packtinfobox">Extra challenge: This feature can be further enhanced for different purposes. For example, it can be used to give the user the information that the countdown is running, perhaps by animating a spinner cursor. Also, further feedback can be given when the click event is executed. For example, the Button UI object has a Transition option called Animation that might be helpful. Also, consider audio cues.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pointing and clicking with VR components</h1>
                </header>
            
            <article>
                
<p class="calibre3">As we have seen, while Unity provides UI elements such as canvas text, buttons, and other controls that are specially tuned for conventional screen space UI and mobile app, using them in World Space and tying them together with VR user input can get pretty involved. World space interactions assume some physics, colliders, and ray casts to detect interaction events.</p>
<p class="calibre3">Fortunately, VR device-specific toolkits may provide components that take care of some of this work already. As we saw in previous chapters, device manufacturers provide toolkits built atop their Unity SDK with convenient scripts, prefabs, and demo scenes that illustrate how to use them.</p>
<p class="calibre3">In this case, we're looking for components that let you design scenes using Unity UI elements on a canvas, take advantage of all their EventSystem interactivity goodness, use world space 3D models, and input controllers or laster pointers. For example, consider these: </p>
<ul class="calibre11">
<li class="calibre12">Oculus Rift and GearVR: OVRInputModule; see <a href="https://developer.oculus.com/blog/unitys-ui-system-in-vr/" class="calibre10">https://developer.oculus.com/blog/unitys-ui-system-in-vr/</a></li>
<li class="calibre12">SteamVR: Steam InteractionSystem; see the <kbd class="calibre13">/Assets/SteamVR/InteractionSystem/</kbd> folder after installing the SteamVR package</li>
<li class="calibre12">Daydream: </li>
<li class="calibre12">VRTK open source toolkit: <a href="https://github.com/thestonefox/VRTK" class="calibre10">https://github.com/thestonefox/VRTK</a></li>
</ul>
<p class="calibre3">Lastly, you might consider purchasing a package from the Unity Asset Store. The Curved UI package ($25), for example, lets you make VR-ready curved canvases and supports Vive, Oculus Touch, Daydream controllers, and gaze input, as depicted:</p>
<div class="mce-root1"><img src="assets/12341f9a-bccd-4c4e-a2cd-9176aa8aecb2.png" class="calibre57"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Unity UI and SteamVR</h1>
                </header>
            
            <article>
                
<p class="calibre3">We introduced the SteamVR InteractionSystem in Chapter 5, <em class="calibre14">Handy Interactables</em>. It is intended as an example of how to use the SteamVR SDK but includes some very useful components and demo scenes. Using the Interaction System, it's very easy to convert your Dashboard into a control panel you can operate directly with your positionally tracked hand controllers.</p>
<p class="calibre3">The Interaction System includes its own <kbd class="calibre13">Player</kbd> camera rig which replaces the default <kbd class="calibre13">[CameraRig]</kbd> we have been using. It includes a VRCamera, two hands (Hand1 and Hand2), and other useful objects.</p>
<ol class="calibre15">
<li class="calibre12">Locate the <kbd class="calibre13">Assets/SteamVR/InteractionSystem/Core/Prefabs</kbd> folder in the <span>Project</span> window</li>
<li class="calibre12">Drag the <kbd class="calibre13">Player</kbd> prefab as a child of <kbd class="calibre13">MyMyselfEye</kbd> into your scene <span>Hierarchy</span></li>
<li class="calibre12">Delete or disable the <kbd class="calibre13">[CameraRig]</kbd> object</li>
</ol>
<p class="calibre3">To make the <kbd class="calibre13">StartButton</kbd> and <kbd class="calibre13">StopButton</kbd> interactable, add the <kbd class="calibre13">Interactable</kbd> component. Also add the UI <kbd class="calibre13">Element</kbd> component to handle <span class="calibre6">OnHandClick</span> events, as follows:</p>
<ol class="calibre15">
<li class="calibre12">Select the <kbd class="calibre13">StartButton</kbd> object in <span>Hierarchy</span> (child of <kbd class="calibre13">Dashboard</kbd>).</li>
<li class="calibre12">In <span>Inspector</span>, select <span>Add Component</span> | <span>Scripts</span> | <span>Valve.VR.InteractionSystem</span> | <span>Interactable</span> (tip: use the <span>Search</span> field for "Interactable").</li>
<li class="calibre12">Select <span>Add Component</span> | <span>Scripts</span> | <span>Valve.VR.InteractionSystem | UI Element</span>.</li>
<li class="calibre12">In <span>Inspector</span> on the <span>UI Element</span> component, press the "+" to add an <span>On Hand Click</span> handler.</li>
<li class="calibre12">Drag the <kbd class="calibre13">WaterShower</kbd> particle system (child of <kbd class="calibre13">Hose</kbd> object) from <span>Hierarchy</span> onto the <span>GameObject</span> field, like we did for the standard <span>Button OnClick</span> event.</li>
<li class="calibre12">Select the <span>ParticleSystem</span> | <span>Play()</span> function.</li>
<li class="calibre12">Optionally, disable the <kbd class="calibre13">RespondToGaze</kbd> component.</li>
</ol>
<p class="calibre3">Similarly, repeat these steps for the <kbd class="calibre13">StopButton</kbd>, but choose function <span class="calibre6">ParticleSystem</span> | <span class="calibre6">Stop()</span>.</p>
<p class="calibre3">You may also need to move the <kbd class="calibre13">Dashboard</kbd> closer to yourself so the buttons are within comfortable reach when you're in VR. When you press <span class="calibre6">Play</span> you can now reach to touch a button; it highlights. Pull the trigger to press it, as shown in the screenshot, and it turns on the hose:</p>
<div class="mce-root1"><img src="assets/29dd7a02-8acd-461d-bc37-21feaf308d48.png" class="calibre58"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Unity UI and Daydream</h1>
                </header>
            
            <article>
                
<p class="calibre3">Let's now take a look at how to do this on a mobile VR device using Google Daydream. In this case, we won't actually reach out and press the button but use the 3DOF hand controller laser pointer. The solution is as simple as replacing the <kbd class="calibre13">GvrReticlePointer</kbd> (if you had been using it) with a <kbd class="calibre13">GvrControllerPointer</kbd>.</p>
<ol class="calibre15">
<li class="calibre12">Under your MeMyselfEye <kbd class="calibre13">GVR Camera Rig/ Player / Main Camera /</kbd>, if there is a GvrReticlePointer, disable it.</li>
<li class="calibre12">Locate the GvrControllerPointer in the <kbd class="calibre13">GoogleVR/Prefabs/Controller/</kbd> folder.</li>
<li class="calibre12">Drag the prefab under Player (as a sibling of Main Camera).</li>
</ol>
<p class="calibre3">Then set up the Dashboard canvas to accept raycasts:</p>
<ol class="calibre15">
<li class="calibre12">Select the Dashboard object in Hierarchy.</li>
<li class="calibre12">Add the GvrPointerGraphicRaycaster component.</li>
</ol>
<p class="calibre3">Press Play. You can now use the Daydream controller to press the buttons. </p>
<p class="calibre3">Explore the component options for the GvrControllerPointer, its child Laser object, and other Gvr object provided with the package. There's some pretty interesting and useful configurations available, including settings for laser color, end color, and max distance. There's even a checkbox to Draw Debug Rays in the Editor Scene window during Play mode.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a wrist-based menu palette</h1>
                </header>
            
            <article>
                
<p class="calibre3">Some VR applications, designed for two-handed setups such as Oculus Rift, HTC Vive, and Windows MR, give you a virtual menu palette attached to one wrist while the other hand selects buttons or items from it. Let's see how that is done. <em class="calibre14">This scenario will assume you have a two hand controller VR system.</em> We'll describe it using the SteamVR camera rig, involving attaching the controls to your left hand and selecting them with your right.</p>
<p class="calibre3">Converting our dashboard control panel into a wrist palette is not too difficult. We just need to scale it appropriately and attach it to the hand controller.</p>
<p class="calibre3">Given you've built the scene up to the point described in the previous <em class="calibre14">Using Unity UI and SteamVR </em>section, including the SteamVR <kbd class="calibre13">Player</kbd> rig (instead of <kbd class="calibre13">[CameraRig]</kbd>), we'll duplicate and repurpose the <kbd class="calibre13">Dashboard</kbd> to use it on your left wrist:</p>
<ol class="calibre15">
<li class="calibre12">In Hierarchy, right-click the Dashboard and Duplicate.</li>
<li class="calibre12">Rename the new one to "Palette".</li>
<li class="calibre12">Disable the old Dashboard.</li>
<li class="calibre12">Drag the Palette as a child of the Player/Hand1 object.</li>
</ol>
<p class="calibre3">Now we'll modify the Palette graphics as follows. Feel free to change for what works for you:</p>
<ol class="calibre15">
<li class="calibre12">On the Palette itself, set its Pos X,Y,Z to (0, 0.1, -0.1); Rotation to (90, -150, -115); Scale (X,Y,Z) to 0.0005; </li>
<li class="calibre12">Unfold the Palette and disable or delete the Raw Image object.</li>
<li class="calibre12">Enable the Image child object (if it's missing, create a new Image with Anchor Presets to stretch-stretch).</li>
<li class="calibre12">Set the Image Scale (X,Y,Z) to 0.5.</li>
<li class="calibre12">Set the Image Color Alpha to 75 so it's translucent. </li>
<li class="calibre12">Enable the Text child object. Set its Rect Transform Top to 100, Font Size to 18, and Text to "Hose".</li>
<li class="calibre12">Move the StartButton Pos Y to 0.</li>
<li class="calibre12">Move the StopButton Pos Y to 0.</li>
</ol>
<p class="calibre3">That's it! All of the click wiring we set up for the Dashboard works without change. Shown here is a screenshot of using the Palette attached to the left-hand controller, and selecting the start button on it with the right-hand controller:</p>
<div class="mce-root1"><img src="assets/453a125e-8442-4dd8-9ef4-8d35a931515e.png" class="calibre59"/></div>
<p class="calibre3">Naturally, the palette can be extended with other buttons and input controls. If you had multiple panels arranged as the sides of cube (like the TiltBrush menu), you could use the thumb pad to scroll or rotate between the various menus.  And that's how it's done.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="calibre3">In Unity, user interfaces that are based on a canvas object and the event system include buttons, text, images, sliders, and input fields, which can be assembled and wired to objects in the scene.</p>
<p class="calibre3">In this chapter, we took a close look at various world space UI techniques and how they can be used in virtual reality projects. We considered ways in which UI for VR differs from UI for conventional video games and desktop applications. Also, we implemented over a half-dozen of them, demonstrating how each can be constructed, coded, and used in your own projects. Our C# scripting got a little more advanced, probing deeper into the Unity Engine API and modular coding techniques.</p>
<p class="calibre3">You now have a broader vocabulary to approach UI in your VR projects. Some of the examples in this chapter can be directly applicable in your own work. However, not all need to be home-grown. VR UI tools are increasingly being provided in VR headset SDKs, open source VR middleware projects, and third-party Unity Assets Store packages.</p>
<p class="calibre3">In the next chapter, we will add a first-person character controller to our scene. We'll learn about avatars and methods to control navigation in VR so that we can comfortably move around inside the virtual world. Also, we'll learn about managing one of the negative aspects of virtual reality experiences—VR motion sickness.</p>


            </article>

            
        </section>
    </body></html>