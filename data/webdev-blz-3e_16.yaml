- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Going Deeper into WebAssembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解 WebAssembly
- en: In this chapter, we will go deeper into technologies that are only relevant
    for Blazor **WebAssembly**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨仅与 Blazor **WebAssembly** 相关的技术。
- en: Most things in Blazor can be applied to Blazor Server and Blazor WebAssembly.
    Still, since Blazor WebAssembly runs inside the web browser, we can do some things
    to optimize the code and use other libraries that we can’t use server-side.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 中的大多数内容都可以应用于 Blazor Server 和 Blazor WebAssembly。然而，由于 Blazor WebAssembly
    在浏览器中运行，我们可以做一些事情来优化代码并使用其他我们无法在服务器端使用的库。
- en: We will also look at some common problems and how to solve them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨一些常见问题及其解决方法。
- en: 'In this chapter, we will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Exploring the WebAssembly template
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 WebAssembly 模板
- en: .NET WebAssembly build tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET WebAssembly 构建工具
- en: AOT compilation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AOT 编译
- en: WebAssembly **Single Instruction, Multiple Data** (**SIMD**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly **单指令多数据**（**SIMD**）
- en: Trimming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Lazy loading
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载
- en: Progressive web apps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式网络应用
- en: Native dependencies
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生依赖
- en: Common problems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题
- en: Some parts of this chapter are a great opportunity to follow along, while other
    parts are for reference so that you can find the right information when you need
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些部分是很好的跟随学习机会，而其他部分则是供参考的，以便你在需要时能够找到正确的信息。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is a reference chapter and is not connected with the book’s other
    chapters. You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个参考章节，并且与本书的其他章节没有关联。您可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter16)
    找到本章结果的源代码。
- en: Exploring the WebAssembly template
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 WebAssembly 模板
- en: 'The WebAssembly template looks slightly different from the templates we looked
    at in *Chapter 2*, Creating Your First Blazor App. In the Blazor Web App template,
    our entry point is the `app.razor` file. It contains the HTML tags we need to
    get started. The WebAssembly template had an `Index.html` file. Let’s create a
    project so we can take a look:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 模板看起来与我们在 *第 2 章* 中看到的模板略有不同，即创建您的第一个 Blazor 应用。在 Blazor Web App
    模板中，我们的入口点是 `app.razor` 文件。它包含我们开始所需的 HTML 标签。WebAssembly 模板有一个 `Index.html` 文件。让我们创建一个项目，以便我们可以查看：
- en: Create a new project and use the `Blazor WebAssembly Standalone App` template.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并使用 `Blazor WebAssembly Standalone App` 模板。
- en: Name the project `BlazorWebAssembly`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 `BlazorWebAssembly`。
- en: Leave the defaults as is and press **Create**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持默认设置并按 **创建**。
- en: First, in the `wwwroot` folder, we have a `Index.html` that has all the CSS,
    JavaScript, and so on. This is the same content as the `App.razor` file in the
    Blazor Web App template. We have an `app.razor` file in the WebAssembly project
    as well, but that contains the same things as the `Routes.razor` file. So it is
    a bit confusing if we work with both templates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `wwwroot` 文件夹中，我们有一个包含所有 CSS、JavaScript 等内容的 `Index.html` 文件。这与 Blazor
    Web App 模板中的 `App.razor` 文件内容相同。WebAssembly 项目中也有一个 `app.razor` 文件，但它包含的内容与 `Routes.razor`
    文件相同。因此，如果我们同时使用这两个模板，可能会有些令人困惑。
- en: 'Let’s take a look at each file but only focus on the things that are specific
    to WebAssembly. In `Index.html`, we have some interesting code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看每个文件，但只关注特定于 WebAssembly 的内容。在 `Index.html` 中，我们有以下有趣的代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a `div`, and the content is a progress bar showing the WebAssembly
    loading progress. In the `css/app.css` file, we have this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `div`，内容是一个显示 WebAssembly 加载进度的进度条。在 `css/app.css` 文件中，我们有以下内容：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are just some of the CSS classes for the loading progress, but what is
    interesting is that Blazor will give us two CSS values, `--blazor-load-percentage-text`
    and `--blazor-load-percentage`. This gives us some indication of how much time
    is left when loading our WebAssembly app. This is a great way to customize our
    progress indicator. The content of the `div` will be replaced by the WebAssembly
    app once it has loaded.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是加载进度的一些 CSS 类，但有趣的是，Blazor 将给我们两个 CSS 值，`--blazor-load-percentage-text`
    和 `--blazor-load-percentage`。这为我们提供了关于加载我们的 WebAssembly 应用剩余时间的指示。这是一种自定义我们的进度指示器的好方法。一旦加载完成，`div`
    的内容将被 WebAssembly 应用替换。
- en: 'If we take a look at `Program.cs`, it contains a bit more now when we are running
    WebAssembly standalone:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Program.cs` 文件，当运行独立的 WebAssembly 时，它包含的内容会更多一些：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we set up our WebAssembly project and tell .NET that we want to render
    the `app.razor` component in the `HTML` tag with the `id` app. We also tell .NET
    to render the `HeadOutlet` as the last child of the `head` tag.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置我们的 WebAssembly 项目，并告诉 .NET 我们想在 `HTML` 标签中使用 `id` app 渲染 `app.razor`
    组件。我们还告诉 .NET 将 `HeadOutlet` 作为 `head` 标签的最后一个子元素渲染。
- en: Run the project and explore it for a bit. The components inside of the project
    are the same as the ones we have already looked at in *Chapter 4*, *Understanding
    Basic Blazor Components*, so there is nothing new going on there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并探索一下。项目中的组件与我们已经在 *第 4 章* 中查看过的相同，即 *理解基本 Blazor 组件*，所以那里没有新的内容。
- en: When we start the project the first time, it takes a couple of seconds to load
    our app. This is when everything is downloaded and started. The next time our
    users visit our site, much of the files will be cached and we won’t need to download
    them again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动项目时，加载我们的应用程序需要几秒钟。这是所有内容下载并启动的时候。下次我们的用户访问我们的网站时，大部分文件将被缓存，我们不需要再次下载它们。
- en: .NET WebAssembly build tools
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET WebAssembly 构建工具
- en: When it comes to the more “advanced” scenarios, we need additional tooling installed.
    There are two ways of installing the tools.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到更“高级”的场景时，我们需要安装额外的工具。有两种安装工具的方法。
- en: 'We can select the **.NET WebAssembly Build Tools** option when installing Visual
    Studio (or add them using the Visual Studio installer) or run the following command
    in a command prompt (as administrator):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Visual Studio（或使用 Visual Studio 安装程序添加）时，我们可以选择**.NET WebAssembly 构建工具**选项，或者在命令提示符（以管理员身份）中运行以下命令：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The .NET WebAssembly build tools are based on **Emscripten**, a compiler toolchain
    for the web platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: .NET WebAssembly 构建工具基于 **Emscripten**，这是一个用于 Web 平台的编译工具链。
- en: AOT compilation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOT 编译
- en: By default, the only thing that is running as WebAssembly in a Blazor WebAssembly
    app is the runtime. Everything else is ordinary .NET assemblies running on the
    browser using a .NET **Intermediate Language** (**IL**) interpreter implemented
    in WebAssembly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Blazor WebAssembly 应用程序中，作为 WebAssembly 运行的只有运行时。其他所有内容都是普通的 .NET 程序集，通过浏览器使用
    WebAssembly 实现的 .NET **中间语言**（**IL**）解释器运行。
- en: I was not too fond of that when I started playing around with Blazor; it felt
    wasteful to run everything using IL instead of something the browser would understand
    natively. Then, I thought the browser was running the same code as I would on
    the server. The same code in the browser! That is pretty amazing!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始尝试 Blazor 时，我对这一点并不太喜欢；使用 IL 而不是浏览器能够原生理解的代码运行一切感觉是浪费的。然后，我认为浏览器正在运行与我服务器上相同的代码。浏览器中的相同代码！这真是太令人惊讶了！
- en: 'However, we have the option to compile directly to WebAssembly; this is called
    **ahead-of-time** (**AOT**) compilation. It has a downside: the app download size
    will increase, but it will run and load faster.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有直接编译到 WebAssembly 的选项；这被称为**即时编译**（**AOT**）。它有一个缺点：应用程序的下载大小会增加，但它的运行和加载速度会更快。
- en: An AOT-compiled app is generally twice the size of an IL-compiled app. AOT will
    take the .NET code and compile that directly into WebAssembly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 编译的应用程序通常比 IL 编译的应用程序大两倍。AOT 会将 .NET 代码直接编译成 WebAssembly。
- en: AOT does not trim managed assemblies, and more code is needed to represent high-level
    .NET IL instructions when using native WebAssembly. That is why the size is much
    larger, and it is also less compressible over HTTP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 不会修剪托管程序集，当使用原生 WebAssembly 时，需要更多的代码来表示高级 .NET IL 指令。这就是为什么其大小要大得多，并且它也难以通过
    HTTP 压缩。
- en: AOT is not for everyone; most apps running without AOT will work fine. However,
    for CPU-intensive apps, there is a lot to gain by using AOT.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 并非适用于所有人；大多数不使用 AOT 运行的应用程序都能正常工作。然而，对于计算密集型应用程序，使用 AOT 可以获得很多好处。
- en: My ZX Spectrum emulator is one of those apps; it runs many iterations per second,
    and the performance gain by running AOT for these apps is remarkable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 ZX Spectrum 模拟器就是这样一款应用程序；它每秒运行多次迭代，对于这些应用程序使用 AOT 的性能提升是显著的。
- en: 'To compile our Blazor WebAssembly project using AOT, we add the following property
    in the `csproj` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 AOT 编译我们的 Blazor WebAssembly 项目，我们在 `csproj` 文件中添加以下属性：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: AOT compilation is only performed when the app is published. It can take a long
    time to compile (seven minutes for the ZX Spectrum emulator), so it is pretty
    nice that we don’t have to wait for that every time we compile our application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AOT 编译仅在应用程序发布时执行。编译可能需要很长时间（ZX Spectrum 模拟器需要七分钟），所以每次编译应用程序时不必等待这一点是非常好的。
- en: However, running in release mode may be a problem, so if you want to do a quick
    test in release mode, temporarily disable the preceding setting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在发布模式下运行可能会出现问题，所以如果您想在发布模式下快速测试，请暂时禁用前面的设置。
- en: Don’t forget to enable it again; I have some experience in that area.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记再次启用它；我在这个领域有一些经验。
- en: WebAssembly Single Instruction, Multiple Data (SIMD)
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly单指令多数据（SIMD）
- en: One of the new features in .NET7 is SIMD, a type of parallel processing recently
    added to WebAssembly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: .NET7中的一个新特性是SIMD，这是一种最近添加到WebAssembly的并行处理类型。
- en: SIMD is a type of computer architecture that allows a CPU to perform the same
    operation on multiple data points simultaneously, improving the performance of
    certain kinds of tasks. SIMD instructions are often used to perform vector arithmetic,
    in which a single instruction is applied to multiple elements of a vector simultaneously.
    SIMD can be beneficial for tasks such as image and video processing, where large
    amounts of data need to be processed quickly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD是一种计算机架构，允许CPU同时对多个数据点执行相同的操作，从而提高某些类型任务的性能。SIMD指令通常用于执行向量运算，其中单个指令同时应用于向量的多个元素。SIMD对于图像和视频处理等需要快速处理大量数据的任务可能有益。
- en: 'SIMD is enabled by default. To disable SIMD, we need to disable it in the project
    file like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SIMD默认启用。要禁用SIMD，我们需要在项目文件中将其禁用，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We need to use AOT compilation for SIMD to work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SIMD工作，我们需要使用AOT编译。
- en: This is beyond the scope of this book, but I wanted to mention it in case this
    is what you need for your project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这超出了本书的范围，但我想要提到它，以防这符合您的项目需求。
- en: Trimming
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剪枝
- en: By default, when publishing a Blazor WebAssembly app, trimming will be performed.
    It will remove unnecessary things and, by doing so, reduce the size of the app.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，发布Blazor WebAssembly应用程序时，会执行剪枝。这将删除不必要的文件，并通过这样做，减小应用程序的大小。
- en: If our application uses reflection, the trimmer may have problems identifying
    what can and cannot be removed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序使用反射，剪枝器可能难以确定可以删除和不能删除的内容。
- en: 'For most applications, the trimming is automatic and will work. To read more
    about trimming options, you can look here: [https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序，剪枝是自动的，并且会正常工作。要了解更多关于剪枝选项的信息，您可以查看这里：[https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options?pivots=dotnet-8-0)。
- en: Lazy loading
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟加载
- en: When working with Blazor WebAssembly, one of the challenges is download size.
    Even though it’s not a big problem, in my opinion, we can do some things to handle
    the download and loading time. We will get back to this in the *Common problems*
    section later in this chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Blazor WebAssembly时，一个挑战是下载大小。尽管这并不是一个大问题，在我看来，我们可以做一些事情来处理下载和加载时间。我们将在本章后面的*常见问题*部分回到这个问题。
- en: When navigating to a Blazor WebAssembly application, all the DLLs for our application
    and the DLLs from .NET Framework are downloaded. It takes a bit of time to get
    everything started up. We can load some DLLs when needed by using **lazy loading**
    to solve this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当导航到Blazor WebAssembly应用程序时，会下载我们应用程序和来自.NET Framework的所有DLL。启动一切需要一些时间。我们可以通过使用**延迟加载**来按需加载一些DLL，以解决这个问题。
- en: Let’s say that our application is massive where it has a reporting part. Reporting
    is perhaps not used every day and not used by everyone, and it would make sense
    to remove that part from the initial download and only load it when we need to.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序很大，其中有一个报告部分。报告可能不是每天都会使用，也不是每个人都会使用，因此从初始下载中删除该部分并在需要时加载它是有意义的。
- en: 'To make that happen, the part we want to lazy load must be in a separate project/DLL.
    In the `csproj` file of the Blazor WebAssembly client project, add a reference
    to the DLL by adding the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们想要延迟加载的部分必须在一个单独的项目/DLL中。在Blazor WebAssembly客户端项目的`csproj`文件中，通过添加以下代码来添加对DLL的引用：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `LazyAssemblyLoader` service will make a JS interop call to download the
    assembly and load it into the runtime.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`LazyAssemblyLoader`服务将进行JS互操作调用以下载程序集并将其加载到运行时。'
- en: 'We make sure to download the necessary assemblies/DLLs in the router (`App.razor`)
    so we make sure they are downloaded before we navigate to the component that is
    using them:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保在路由器（`App.razor`）中下载必要的程序集/DLL，这样我们就可以确保在导航到使用它们的组件之前下载它们：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We need to inject `LazyAssemblyLoader`; it is registered as a singleton by default
    in a Blazor WebAssembly project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注入 `LazyAssemblyLoader`；在 Blazor WebAssembly 项目中，它默认注册为单例。
- en: You need to set up an `OnNavigateAsync` event, and in that method, check the
    path and make sure to load the assemblies we need.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要设置一个 `OnNavigateAsync` 事件，并在该方法中检查路径，确保加载所需的程序集。
- en: 'This event can also be used for routable components by doing something similar
    to this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件也可以通过执行类似以下操作来用于可路由组件：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This makes it possible not to load the admin interface for the users who don’t
    have access to it, for example. We can of course trigger the downloading of additional
    assemblies when it makes sense to do so (and not wait for a user to hit a specific
    part of the application and then download the assemblies).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对于没有访问权限的用户不加载管理界面成为可能，例如。当然，当有需要时，我们可以触发下载额外的程序集（而不是等待用户点击应用程序的特定部分然后下载程序集）。
- en: Progressive web apps
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进式 Web 应用
- en: Both Blazor Server and Blazor WebAssembly can create **Progressive Web Apps**
    (**PWAs**), but it is much more common for Blazor WebAssembly. PWAs make it possible
    to download our web app and run it as an app on our phone or computer. They will
    make it possible to add nice-looking icons and launch our website in a web browser
    without a URL input field, so it will feel more like an app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 服务器和 Blazor WebAssembly 都可以创建 **渐进式 Web 应用**（**PWA**），但 Blazor WebAssembly
    更常见。PWA 使得我们可以下载我们的 Web 应用并将其作为手机或计算机上的应用程序运行。它们将使我们能够添加漂亮的图标，并在没有 URL 输入字段的情况下在网页浏览器中启动我们的网站，这样它就会更像一个应用程序。
- en: When creating our project, we select **Progressive Web App**. By doing that,
    we will get some configuration and JavaScript to set everything up.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目时，我们选择 **渐进式 Web 应用**。通过这样做，我们将获得一些配置和 JavaScript 来设置一切。
- en: 'PWAs are beyond the scope of this book, but there are great resources to get
    us started. You can find more information here: [https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 超出了本书的范围，但有一些很好的资源可以帮助我们入门。您可以在以下链接中找到更多信息：[https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/blazor/progressive-web-app?view=aspnetcore-8.0&tabs=visual-studio)。
- en: Native dependencies
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生依赖项
- en: Since we are running WebAssembly, we can use WebAssembly assemblies written
    in other languages in our project. This means that we can use any native dependencies
    right inside our project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在运行 WebAssembly，我们可以在项目中使用用其他语言编写的 WebAssembly 程序集。这意味着我们可以在项目中直接使用任何原生依赖项。
- en: One way is to add C files right into our project. In the `Chapter16` folder
    in the repository, you will find an example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将 C 文件直接添加到我们的项目中。在存储库中的 `Chapter16` 文件夹中，你可以找到一个示例。
- en: 'I have added a file called `Test.c` with the following content:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个名为 `Test.c` 的文件，内容如下：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the project file, I have added a reference to that file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件中，我添加了对该文件的引用：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In `Home.razor`, I have added the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Home.razor` 文件中，我添加了以下代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In our C# project, we now have a C file that we can call from our Blazor project.
    It is compiled into WebAssembly, and then we can reference that WebAssembly file
    (which happens automatically). We can take this even further by using a library
    that is using a C++ library. Skia is an open-source graphics engine written in
    C++.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 C# 项目中，我们现在有一个可以从 Blazor 项目中调用的 C 文件。它被编译成 WebAssembly，然后我们可以引用那个 WebAssembly
    文件（这会自动发生）。我们可以通过使用一个使用 C++ 库的库来更进一步。Skia 是一个用 C++ 编写的开源图形引擎。
- en: 'Read more here: [https://github.com/mono/SkiaSharp](https://github.com/mono/SkiaSharp).
    We can add that library to a Blazor WebAssembly app by adding the NuGet package
    `SkiaSharp.Views.Blazor`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅：[https://github.com/mono/SkiaSharp](https://github.com/mono/SkiaSharp)。我们可以通过添加
    NuGet 包 `SkiaSharp.Views.Blazor` 将该库添加到 Blazor WebAssembly 应用程序中。
- en: In the `Chapter16` folder in the repository, you can explore a project called
    `SkiaSharpDemo`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中的 `Chapter16` 文件夹中，您可以探索一个名为 `SkiaSharpDemo` 的项目。
- en: 'In the `Home.razor` file, I have added the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Home.razor` 文件中，我添加了以下代码：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The page will draw `"Raccoons are awesome"` on the canvas.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将在画布上绘制 `"Raccoons are awesome"`。
- en: In this case, we are using a C# library that is using a C++ library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用一个使用 C++ 库的 C# 库。
- en: We can even refer to libraries that have already been built with Emscripten
    directly by adding **object files** (`.o`), **archive files** (`.a`), **bitcode**
    (`.bc`), and **standalone WebAssembly modules** (`.wasm`). If we find a library
    written in another language, we could compile that to WebAssembly and then use
    it from our Blazor application. This opens up so many doors!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以直接通过添加 **对象文件**（`.o`）、**归档文件**（`.a`）、**位码**（`.bc`）和**独立 WebAssembly 模块**（`.wasm`）来引用已经使用
    Emscripten 构建的库。如果我们找到一个用另一种语言编写的库，我们可以将其编译成 WebAssembly，然后从我们的 Blazor 应用程序中使用它。这打开了无数的大门！
- en: Next, we will look at some common problems I have encountered.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些我遇到的一些常见问题。
- en: Common problems
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Let’s dive into this one right from the start.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一开始就深入探讨这个问题。
- en: The most common comments regarding Blazor WebAssembly are download size and
    load time. A small project is around 1 MB in size, but I believe the problem is
    the loading time and not the download size/time since everything is cached and,
    in most parts of the world, we have access to high-speed internet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Blazor WebAssembly 最常见的评论是下载大小和加载时间。一个小项目的大小大约是 1 MB，但我相信问题是加载时间，而不是下载大小/时间，因为所有内容都已缓存，而且在世界上的大多数地方，我们都能访问高速互联网。
- en: There are a couple of solutions to this problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决这个问题的方法。
- en: Progress indicators
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进度指示器
- en: When it comes to **User Experience** (**UX**), we can give the users a perceived
    sense of speed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到**用户体验**（**UX**）时，我们可以给用户一种感知速度的感觉。
- en: The default Blazor WebAssembly template has a loading progress indicator, which
    gives the users something to look at instead of a blank page. It is built so that
    it is easy to customize using CSS variables. We can use the `--blazor-load-percentage`
    and `--blazor-load-percentage-text` variables to customize and create our progress
    bar.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Blazor WebAssembly 模板有一个加载进度指示器，它给用户一些可以看的东西，而不是一个空白页面。它被构建得很容易使用 CSS 变量进行自定义。我们可以使用
    `--blazor-load-percentage` 和 `--blazor-load-percentage-text` 变量来自定义并创建我们的进度条。
- en: It doesn’t even have to indicate what is happening; Dragons Mania Legends has
    comments like “Sewing mini Vikings,” which is obviously not what is going on.
    So depending on the application we are building, showing something is more important
    than showing nothing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至不需要指示正在发生什么；Dragons Mania Legends 有像“缝纫迷你维京人”这样的评论，这显然不是正在发生的事情。所以根据我们正在构建的应用程序，显示某些内容比显示无内容更重要。
- en: Prerendering on the server
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端预渲染
- en: In previous versions of Blazor, we had to do some magic ourselves to make prerendering
    work. But with the new Blazor Web App template, we get this out of the box. Up
    until now, we have talked about features in Blazor WebAssembly using the Blazor
    WebAssembly Standalone template; in this section, we are using the Blazor Web
    App template. The better solution is to run it as `InteractiveAuto`; that way,
    we get the power of fast loading on the server, and then get WebAssembly without
    the wait.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blazor 的早期版本中，我们必须自己做一些魔法才能使预渲染工作。但有了新的 Blazor Web App 模板，我们就可以直接获得这个功能。到目前为止，我们一直在使用
    Blazor WebAssembly Standalone 模板讨论 Blazor WebAssembly 的功能；在本节中，我们使用的是 Blazor Web
    App 模板。更好的解决方案是将其作为 `InteractiveAuto` 运行；这样，我们就可以获得服务器快速加载的能力，然后无需等待即可获得 WebAssembly。
- en: This is a great and simple way to add SEO to our site.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单而有效的方法，可以为我们的网站添加 SEO。
- en: 'There is one problem: it will load data when rendering on the server, and then
    again when the WebAssembly loads.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题：在服务器上渲染时，它将加载数据，然后在 WebAssembly 加载时再次加载。
- en: There is a way to work around that, which we will take a look at next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以绕过这个问题，我们将在下一节中探讨。
- en: Preloading and persisting the state
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预加载和持久化状态
- en: We don’t want our component to call the database twice if we can avoid it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以避免，我们不希望我们的组件调用数据库两次。
- en: If you run the `BlazorPrerender` example and go to the **Weather** page, you
    should be able to see it load twice since the data is random and generated every
    time we request it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `BlazorPrerender` 示例并转到 **天气** 页面，你应该能够看到它加载两次，因为数据是随机的，每次我们请求它时都会生成。
- en: This is the same behavior you see when using `InteractiveServer, InteractiveWebAssembly,
    and InteractiveAuto`. The page first gets rendered on the server. Then, SignalR
    or WebAssembly gets hooked up and loads the page again.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用 `InteractiveServer`、`InteractiveWebAssembly` 和 `InteractiveAuto` 时看到的行为。页面首先在服务器上渲染。然后，SignalR
    或 WebAssembly 被连接并再次加载页面。
- en: The source for this example is the `BlazorPrerender` project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码是 `BlazorPrerender` 项目。
- en: We used this technique when we passed information about the logged-in user to
    WebAssembly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过 WebAssembly 传递有关登录用户的信息时，我们使用了这种技术。
- en: In previous versions of Blazor, we had to add a component called `persist-component-state`,
    but this component is added by default in .NET 8\. This component will render
    the saved state of the component when it renders on the server, and, when SignalR
    or WebAssembly takes over, the state is already there.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blazor的早期版本中，我们必须添加一个名为`persist-component-state`的组件，但在.NET 8中，这个组件默认添加了。这个组件将在服务器上渲染时渲染组件的保存状态，并且当SignalR或WebAssembly接管时，状态已经存在。
- en: 'In the Client project and in the component where we want to have the persistence
    (`Weather.razor` in the sample), we inject a `PersistanceComponentState` and also
    make the component implement `Idisposable`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端项目和我们要持久化的组件中（例如示例中的`Weather.razor`），我们注入一个`PersistanceComponentState`，并使组件实现`Idisposable`：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We add a `PersistingComponentStateSubscription` component, which saves the
    data to the application state:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`PersistingComponentStateSubscription`组件，该组件将数据保存到应用程序状态中：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `OnInitializedAsync`, we register to listen to run code when the component
    wants to persist the data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnInitializedAsync`中，我们注册监听组件想要持久化数据时运行的代码：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we load the data, we make sure first to check the application state. If
    the data is not available, we can continue and make an `HTTP` request:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载数据时，我们首先确保检查应用程序状态。如果数据不可用，我们可以继续并发出一个`HTTP`请求：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It refers to a method that will persist the data in the application state:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它指的是一个将数据持久化到应用程序状态的方法：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The server will first render the content, and when the server is done, it will
    respond with the whole page, including a `Base64`-encoded JSON string with data
    that looks something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将首先渲染内容，当服务器完成时，它将响应整个页面，包括一个`Base64`编码的JSON字符串，数据看起来像这样：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since everything we put into the application state is stored as JSON, it is
    important not to include any sensitive data that we were not thinking of displaying.
    This is, of course, true for all calls since we are sending data with JSON.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将所有放入应用程序状态的内容都存储为JSON，因此非常重要，不要包含任何我们没有考虑显示的敏感数据。当然，这对于所有调用都是正确的，因为我们正在使用JSON发送数据。
- en: We can also use `PersistentComponentState` on `InteractiveServer, InteractiveWebAssembly,
    and` `InteractiveAuto`. I usually turn off prerendering on my websites, but this
    is great to use if your site needs SEO, for example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`InteractiveServer`、`InteractiveWebAssembly`和`InteractiveAuto`上使用`PersistentComponentState`。我通常在我的网站上关闭预渲染，但如果你的网站需要SEO，这会非常棒。
- en: Now, we know a couple of common problems and how to solve them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们了解了一些常见问题和它们的解决方法。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at some of the Blazor WebAssembly-specific things
    in Blazor. For the most part, we can reuse components in both Blazor Server and
    Blazor WebAssembly, and we can speed up WebAssembly by using what we learned in
    this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Blazor WebAssembly中的一些特定内容。大部分情况下，我们可以在Blazor Server和Blazor WebAssembly中重用组件，并且我们可以通过使用本章学到的知识来加速WebAssembly。
- en: We also looked at native dependencies, opening up the possibilities to reuse
    other libraries and mixing languages. If our application doesn’t need to support
    both scenarios, we can use WebAssembly to the fullest.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了原生依赖项，这为重用其他库和混合语言打开了可能性。如果我们不需要支持这两种场景，我们可以充分利用WebAssembly。
- en: In the next chapter, we will examine *source generators*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨*源生成器*。
