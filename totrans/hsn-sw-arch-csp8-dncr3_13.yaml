- en: Understanding the Different Domains in Software Solutions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件解决方案中的不同领域
- en: 'This chapter is dedicated to a modern software development technique called
    **domain-driven design** (**DDD**), which was first proposed by Eric Evans. While
    DDD has existed for more than 15 years, it reached a great success in the last
    few years because of its ability to cope with two important problems:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于一种现代软件开发技术，称为**领域驱动设计（DDD**），它最初由Eric Evans提出。虽然DDD已经存在了15多年，但由于其解决两个重要问题的能力，它在过去几年取得了巨大的成功：
- en: Modeling complex systems where no single expert has in-depth knowledge of the
    whole domain. This knowledge is split among several people.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有单个专家对整个领域有深入知识的情况下建模复杂系统。这种知识被分散在几个人之间。
- en: Facing big projects with several development teams. There are many reasons why
    a project is split among several teams, with the most common being the team's
    size and all of its members having different skills and/or different locations.
    In fact, experience has proven that teams of more than 6-8 people are not efficacious
    and clearly different skills and locations prevent a tight interaction from occurring. Team
    splitting prevents tight interaction from happening for all the people involved
    in the project.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面对由多个开发团队组成的大型项目。一个项目被分成几个团队的原因有很多，最常见的是团队规模以及所有成员拥有不同的技能和/或不同的地点。事实上，经验证明，超过6-8人的团队效率不高，而且不同的技能和地点显然会阻止紧密的互动。团队划分阻止了项目所有相关人员之间的紧密互动。
- en: 'In turn, the importance of the two aforementioned problems grew more in the
    last few years for the following reasons:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，上述两个问题的重要性在过去几年中增长，原因如下：
- en: Software systems always took up a lot of space inside every organization and
    became more and more complex and geographically distributed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件系统始终占据每个组织内部的大量空间，并且变得越来越复杂和地理上分散。
- en: At the same time, the need for frequent updates increased so that these complex
    software systems could be adapted, as per the needs of a quickly changing market.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，频繁更新的需求增加，以便这些复杂的软件系统能够根据快速变化的市场需求进行适应。
- en: The preceding problems led to the conception of more sophisticated CI/CD cycles
    and the adoption of complex distributed architectures that may leverage reliability,
    high throughput, quick updates, and the capability to evolve legacy subsystems
    gradually. Yes – we are speaking of the microservices and container-based architectures
    we analyzed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前述问题导致了更复杂的CI/CD周期的构想和采用复杂的分布式架构，这些架构可能利用可靠性、高吞吐量、快速更新以及逐步演进旧子系统的能力。是的——我们正在谈论的是我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”中分析过的基于微服务和容器架构。
- en: In this scenario, it's common to implement complex software systems with associated
    fast CI/CD cycles that always require more people to evolve and maintain them.
    In turn, this created the requirement of developing technologies that were adequate
    for high-complexity domains and for the cooperation of several loosely coupled
    development teams.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，通常需要实现具有相关快速CI/CD周期的复杂软件系统，这些系统始终需要更多的人来演进和维护。反过来，这导致了开发适合高复杂度领域和多个松散耦合开发团队协作的技术需求。
- en: 'In this chapter, we will analyze the basic principles, advantages, and common
    patterns related to DDD, as well as how to use them in our solutions. More specifically,
    we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析与领域驱动设计（DDD）相关的基本原则、优势和常见模式，以及如何在我们的解决方案中使用它们。更具体地说，我们将涵盖以下主题：
- en: What are software domains?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件领域是什么？
- en: Understanding domain-driven design
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解领域驱动设计
- en: Using SOLID principles to map your domains
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOLID原则映射您的领域
- en: Use case – understanding the domains of the use case
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例场景 - 理解用例的应用领域
- en: Let's get started.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2017 or 2019 free Community Edition or better
    with all the database tools installed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2017或2019免费社区版或更高版本，并安装所有数据库工具。
- en: All the code snippets in this chapter can be found in the GitHub repository
    associated with this book, [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)[.](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码片段都可以在本书相关的GitHub仓库中找到，[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)[。](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)
- en: What are software domains?
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件领域是什么？
- en: As we discussed in [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml),
    *Functional and Nonfunctional Requirements*, and [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml),
    *Documenting the Requirements with Azure DevOps*, the transfer of knowledge from
    domain experts to the development team plays a fundamental role in software design.
    Developers try to communicate with experts and describe their solutions in a language
    that domain experts and stakeholders can understand. However, often, the same
    word has a different meaning in various parts of an organization, and what appear
    to be the same conceptual entities have completely different shapes in different
    contexts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第2章](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml)“功能和非功能需求”和[第3章](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml)“使用Azure
    DevOps记录需求”中讨论的，从领域专家到开发团队的知识转移在软件设计中起着根本的作用。开发者试图与专家沟通，并使用领域专家和利益相关者能够理解的语言来描述他们的解决方案。然而，在组织的各个部分，同一个词可能有不同的含义，而在不同的上下文中，看似相同的概念实体可能有完全不同的形态。
- en: For instance, in our WWTravelClub use case, the order-payment and packages-handling
    subsystems use completely different models for customers. Order-payment characterizes a
    customer by their payment methods and currency, bank accounts, and credit cards,
    while package-handling is more concerned with the locations and packages that
    have been visited and/or purchased in the past, the user's preferences, and their
    geographical location. Moreover, while order-payment refers to various concepts
    with a language that we may roughly define as a *bank language*, packages-handling uses
    a language that is typical of travel agencies/operators.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的WWTravelClub用例中，订单支付和包裹处理子系统对客户使用完全不同的模型。订单支付通过支付方式、货币、银行账户和信用卡来表征客户，而包裹处理则更关注过去访问和/或购买过的位置和包裹、用户的偏好以及他们的地理位置。此外，虽然订单支付使用我们可能粗略定义为“银行语言”的语言来指代各种概念，但包裹处理则使用典型的旅行社/运营商语言。
- en: 'The classical way to cope with these discrepancies is to use a unique abstract
    entity called **customer**, which projects into two different views – the order-payment
    view and the packages-handling view. Each projection operation takes some operations
    and some properties from the **customer** abstract entity and changes their names.
    Since domain experts only give us the projected views, our main task as system
    designers is to create a conceptual model that can explain all the views. The
    following diagram shows how different views are handled:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应对这些差异的经典方式是使用一个独特的抽象实体称为**客户**，它映射到两个不同的视图——订单支付视图和包裹处理视图。每个投影操作都从**客户**抽象实体中提取一些操作和属性，并更改它们的名称。由于领域专家只给我们提供投影视图，我们作为系统设计者的主要任务是创建一个可以解释所有视图的概念模型。以下图表显示了如何处理不同的视图：
- en: '![](img/68ac81ab-ebad-4a37-921f-c8e3bf813822.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68ac81ab-ebad-4a37-921f-c8e3bf813822.png)'
- en: The main advantage of the classic approach is that we have a unique and coherent
    representation of the data of the domain. If this conceptual model is built successfully,
    all the operations will have a formal definition and purpose and the whole abstraction
    will be a rationalization of the way the whole organization *should* work, possibly
    highlighting and correcting errors and simplifying some procedures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经典方法的主要优势是我们有一个独特且一致的数据表示。如果这个概念模型构建成功，所有操作都将有一个正式的定义和目的，整个抽象将是整个组织*应该*工作方式的合理化，可能突出和纠正错误，并简化一些程序。
- en: However, what are the downsides of this approach? First of all, the way work
    is organized may have an excessive impact on the preexisting organization that
    may prevent it from operating correctly for a certain amount of time since the
    constraint of using a unique coherent model doesn't offer enough options to mitigate
    this impact. Errors must be removed, duplication must be removed, and everything
    must be perfectly coherent so that there is a minimum irreducible impact that
    we can't mitigate since the only way to mitigate it would be to renounce the overall
    coherence.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的缺点是什么？首先，工作组织的这种方式可能会对现有的组织产生过度的影响，可能阻止它在一定时间内正确运行，因为使用唯一连贯模型的约束没有提供足够的选项来减轻这种影响。必须消除错误，必须消除重复，并且一切必须完美连贯，以便有一个最小的不可减轻的影响，因为我们减轻影响的唯一方式就是放弃整体连贯性。
- en: 'This minimum impact can be acceptable in a small organization, when the software
    is destined for a small part of the overall organization, or when the software
    automatizes a small enough percentage of the data flow. However, as the software
    becomes the backbone of a whole geographically distributed organization, sharp
    changes become more unacceptable and unfeasible. Moreover, as the complexity of
    the software system grows, several other issues appear, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在小型组织、软件旨在服务于整体组织的小部分，或者软件自动化的数据流百分比足够小的情况下，这种最小影响是可以接受的。然而，随着软件成为整个地理分布组织的骨干，剧烈的变化变得更加难以接受和不可行。此外，随着软件系统复杂性的增加，还会出现其他几个问题，如下所示：
- en: Arriving at a uniquely coherent view of data becomes more difficult since we
    can't face complexity by breaking these tasks into smaller loosely coupled tasks.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不能通过将这些任务分解成更小的松散耦合任务来面对复杂性，因此形成唯一连贯的数据视图变得更加困难。
- en: As complexity grows, there is a need for frequents system changes, but it is
    quite difficult to update and maintain a unique global model. Moreover, bugs/errors
    that are introduced by changes in small subparts of the system may propagate to
    the whole organization through the uniquely shared model.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着复杂性的增加，需要频繁的系统变更，但更新和维护一个独特的全局模型相当困难。此外，由于系统小部分变更引入的bug/错误可能会通过唯一共享的模型传播到整个组织。
- en: System modeling must be split among several teams and only loosely coupled tasks
    can be faced with separate teams.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统建模必须由几个团队分担，并且只能面对由单独团队处理的松散耦合任务。
- en: The need to move to a microservice-based architecture makes the bottleneck of
    a unique database more unacceptable.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要转向基于微服务架构，这使得唯一数据库的瓶颈更加难以接受。
- en: As the system grows, we need to communicate with more domain experts, each speaking
    a different language and each with a different view of that data model. Thus,
    we need to translate our unique model's properties and operations to/from more
    languages to be able to communicate with them.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着系统的增长，我们需要与更多的领域专家沟通，每位专家都说不同的语言，并且对数据模型有不同的看法。因此，我们需要将我们独特模型的属性和操作翻译成/从更多语言，以便与他们沟通。
- en: As the system grows, it becomes more inefficient to deal with records with several
    hundreds/thousands of fields. Such inefficiencies originate in database engines
    that inefficiently handle big records with several fields (memory fragmentation,
    problems with too many related indices, and so on). However, the main inefficiencies
    take place in ORMs and business layers that are forced to handle these big records
    in their update operations. In fact, while query operations usually require just
    a few fields that have been retrieved from the storage engine, updates and business
    processing involve the whole entity.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着系统的增长，处理具有数百/数千个字段的记录变得更加低效。这种低效源于数据库引擎在处理具有多个字段的较大记录时效率低下（内存碎片化、太多相关索引的问题等）。然而，主要的不效率发生在ORM和业务层，它们被迫在更新操作中处理这些大记录。事实上，虽然查询操作通常只需要从存储引擎检索的几个字段，但更新和业务处理涉及整个实体。
- en: As the traffic in the data storage subsystem grows, we need read and update/write
    parallelism in all the data operations. As we discussed in [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml),
    *How to Choose Your Data Storage in the Cloud*, while read parallelism is easily
    achieved with data replication, write parallelism requires sharding, and it is
    difficult to shard a uniquely monolithic and tightly connected data model.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着数据存储子系统流量的增长，我们需要在所有数据操作中实现读取和更新/写入并行性。正如我们在[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)“如何在云中选择您的数据存储”中讨论的那样，虽然读取并行性可以通过数据复制轻松实现，但写入并行性需要分片，而将一个独特且紧密连接的数据模型分片是困难的。
- en: These issues are the reason for DDD's success in the last few years since they
    were characterized by more complex software systems that became the backbone of
    entire organizations. DDD's basic principles will be discussed in detail in the
    next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是领域驱动设计在过去几年中取得成功的原因，因为它们代表了更复杂的软件系统，这些系统成为了整个组织的支柱。下一节将详细讨论DDD的基本原则。
- en: Understanding domain-driven design
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解领域驱动设计
- en: Domain-driven design is about the construction of a unique domain model and
    keeps all the views as separate models. Thus, the whole application domain is
    split into smaller domains, each with a separate model. These separate domains
    are called **Bounded Contexts**. Each domain is characterized by the language
    spoken by the experts and used to name all the domain concepts and operations.
    Thus, each domain defines a common language used by both the expert and the development
    team called **Ubiquitous Language**. Translations are not needed anymore, and
    if the development team uses interfaces as a base for its code, the domain expert
    is able to understand and validate them since all the operations and properties
    are expressed in the same language that's used by the expert.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计是关于构建一个独特的领域模型，并保持所有视图作为独立的模型。因此，整个应用程序领域被分割成更小的领域，每个领域都有一个独立的模型。这些独立的领域被称为**边界上下文**。每个领域以其专家所使用的语言为特征，并用于命名所有领域概念和操作。因此，每个领域定义了一种由专家和开发团队共同使用的通用语言，称为**通用语言**。不再需要翻译，如果开发团队以接口作为其代码的基础，领域专家能够理解和验证它们，因为所有操作和属性都是使用专家使用的相同语言表达的。
- en: 'Here, we''re getting rid of a cumbersome unique abstract model, but now we
    have several separated models that we need to relate somehow. DDD proposes that
    it will handle all of these separated models, that is, all the Bounded Contexts,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在摒弃一个繁琐的唯一抽象模型，但现在我们有了几个需要以某种方式关联的独立模型。DDD提出将处理所有这些独立模型，即所有边界上下文，如下所示：
- en: We need to add Bounded Context boundaries whenever the meaning of the language
    terms change. For instance, in the WWTravelClub use case, order-payment and packages-handling
    belong to different Bounded Contexts because they give a different meaning to
    the word **customer**.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当语言术语的含义发生变化时，我们需要添加边界上下文的边界。例如，在WWTravelClub用例中，订单支付和套餐处理属于不同的边界上下文，因为它们对单词**客户**赋予了不同的含义。
- en: We need to explicitly represent relations among bounded contexts. Different
    development teams may work on different bounded contexts, but each team must have
    a clear picture of the relationship between the Bounded Context it is working
    on and all the other models. For this reason, such relationships are represented
    in a unique document that's shared with every team.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要明确表示边界上下文之间的关系。不同的开发团队可能在不同边界上下文中工作，但每个团队都必须对其正在工作的边界上下文与其他所有模型之间的关系有一个清晰的了解。为此，这种关系在一份独特的文档中表示，并与每个团队共享。
- en: We need to keep all the bounded contexts aligned with continuous integration.
    Meetings are organized and simplified system prototypes are built in order to
    verify that all the Bounded Contexts are evolving coherently, that is, that all
    the Bounded Contexts can be integrated into the desired application behavior.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保所有边界上下文与持续集成保持一致。会议被组织和简化系统原型被构建，以验证所有边界上下文是否协调一致地发展，也就是说，所有边界上下文都可以集成到期望的应用程序行为中。
- en: 'The following diagram shows how the WWTravelClub example that we discussed
    in the previous section changes with the adoption of DDD:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了我们在上一节中讨论的WWTravelClub示例在采用领域驱动设计（DDD）后的变化：
- en: '![](img/f7b60e75-1f5b-4d4f-88cd-fb420114cd19.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7b60e75-1f5b-4d4f-88cd-fb420114cd19.png)'
- en: There is a relationship between the customer entities of both Bounded Contexts,
    while the Purchase entity of the packages-handling Bounded Context is related
    to the payments. Identifying entities that map to each other in the various Bounded
    Contexts is the first step of formally defining the interfaces that represent
    all the possible communications among the contexts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 两个边界上下文的客户实体之间存在关系，而包裹处理边界上下文的购买实体与支付相关。识别映射到各个边界上下文中彼此对应的实体是正式定义表示所有上下文之间可能通信的接口的第一步。
- en: For instance, from the preceding diagram, we know that payments are done after
    purchases, and so we can deduce that the payment-orders Bounded Context must have
    an operation to create a payment for a specific customer. In this domain, new
    customers are created if they don't already exist. The payment creation operation
    is triggered immediately after purchase. Since several more operations are triggered
    after an item is purchased, we can implement all the communication related to
    a purchase event with the Publisher/Subscriber pattern we explained in [Chapter
    9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and .NET Core
    Implementation*. These are known as **domain events** in DDD. Using events to
    implement communications between Bounded Contexts is very common since it helps
    keep Bounded Contexts loosely coupled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从前面的图中，我们知道支付是在购买之后进行的，因此我们可以推断出支付订单边界上下文必须有一个为特定客户创建支付的操作。在这个领域，如果新客户不存在，则会创建新客户。支付创建操作在购买后立即触发。由于在购买商品后还会触发更多操作，我们可以使用我们在第9章中解释的发布/订阅模式来实现与购买事件相关的所有通信，该模式称为*设计模式和.NET
    Core实现*。这些在领域驱动设计中被称为**领域事件**。使用事件来实现边界上下文之间的通信非常常见，因为它有助于保持边界上下文松散耦合。
- en: Once an instance of either an event or an operation that's been defined in the
    Bounded Context's interface crosses the context boundary, it is immediately translated
    into the Ubiquitous Language of the receiving context. It is important that this
    translation is performed before the input data starts interacting with the other
    domain entities to avoid the Ubiquitous Language of the other domain becoming
    contaminated by extra-context terms.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在边界上下文接口中定义的事件或操作的实例跨越了上下文边界，它就会立即被翻译成接收上下文的通用语言。在输入数据开始与其他领域实体交互之前执行这种翻译非常重要，以避免其他领域的通用语言被额外的上下文术语污染。
- en: Each Bounded Context implementation must contain a Data Model Layer completely
    expressed in terms of the Bounded Context Ubiquitous Language (class and interface
    names and property and method names), with no contamination from other Bounded
    Contexts Ubiquitous Languages, and without contamination from programming technical
    stuff. This is necessary to ensure good communication with domain experts and
    to ensure that domain rules are translated correctly into code so that they can
    be easily validated by domain experts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边界上下文实现都必须包含一个数据模型层，该层完全用边界上下文通用语言（类和接口名称以及属性和方法名称）表达，没有任何其他边界上下文通用语言的污染，也没有编程技术内容的污染。这是确保与领域专家良好沟通并确保将领域规则正确翻译成代码，以便领域专家可以轻松验证的必要条件。
- en: When there is a strong mismatch between the communication language and the target
    Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded
    Context boundary. The only purpose of this anti-corruption layer is to perform
    a language translation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当通信语言与目标通用语言之间存在强烈不匹配时，会在接收边界上下文边界处添加一个反腐败层。这个反腐败层的唯一目的是执行语言翻译。
- en: 'The document that contains a representation of all the Bounded Contexts, along
    with the Bounded Context''s mutual relationships and interface definitions, is
    called a **Context Mapping**. The relationships among contexts contain organizational constraints
    that specify the kind of cooperation that''s required among the team that works
    on the different Bounded Contexts. Such relationships don''t constrain the Bounded
    Context interfaces but do affect the way they may evolve during the software CI/CD
    cycle. They represent patterns of team cooperation. The most common patterns are
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有Bounded Context表示、Bounded Context之间的相互关系和接口定义的文档称为**上下文映射**。上下文之间的关系包含组织约束，指定了在不同Bounded
    Context上工作的团队之间所需的那种合作类型。这些关系不约束Bounded Context接口，但会影响它们在软件CI/CD周期中可能的发展方式。它们代表了团队合作模式。最常见的模式如下：
- en: '**Partner**: This is the original pattern suggested by Eric Evans. The idea
    is that the two teams have a mutual dependency on each other for delivery. In
    other terms, they decide together and, if needed, change the Bounded Context''s
    mutual communication specifications during the software CI/CD cycle.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合作伙伴**：这是Eric Evans最初提出的模式。其想法是两个团队在交付上相互依赖。换句话说，他们共同决定，如果需要，在软件CI/CD周期中更改Bounded
    Context的相互通信规范。'
- en: '**Customer/supplier development teams**: In this case, a team acts as a customer
    and the other acts as a supplier. Both teams define the interface of the customer
    side of the Bounded Context and some automated acceptance tests to validate it.
    After that, the supplier can work independently. This pattern works when the customer''s
    Bounded Context is the only active part that invokes the interface methods that
    are exposed by the other Bounded Context. This is adequate for the interaction
    between the order-payments and the packages-handling contexts, where order-payments
    acts as a supplier since its functions are subordinate to the needs of packages-handling.
    When this pattern can be applied, it decouples the two Bounded Contexts completely.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户/供应商开发团队**：在这种情况下，一个团队充当客户，另一个团队充当供应商。两个团队定义Bounded Context的客户端接口以及一些自动化验收测试来验证它。之后，供应商可以独立工作。当客户的Bounded
    Context是唯一活跃的部分，调用其他Bounded Context暴露的接口方法时，这种模式是有效的。对于订单-支付和包裹处理之间的交互，订单-支付作为供应商，因为其功能从属于包裹处理的需求。当这种模式可以应用时，它将两个Bounded
    Context完全解耦。'
- en: '**Conformist**: This is similar to the customer/supplier, but in this case,
    the customer side accepts an interface that''s been imposed by the supplier side
    with no negotiation stage. This pattern offers no advantages to the other patterns,
    but sometimes we are forced into the situation depicted by the pattern since either
    the supplier''s Bounded Context is implemented in a preexisting product that can''t
    be configured/modified too much or because it is a legacy subsystem that we don''t
    want to modify.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵从者**：这与客户/供应商类似，但在这个情况下，客户端接受由供应商端强加的接口，没有协商阶段。这种模式对其他模式没有提供任何优势，但有时我们被迫处于模式所描述的情况，因为供应商的Bounded
    Context是在一个无法过多配置/修改的现有产品中实现的，或者因为它是一个我们不希望修改的遗留子系统。'
- en: It is worth pointing out that the separation in Bounded Contexts is only efficacious
    if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction
    of complexity that's obtained by breaking a whole system into subparts would be
    overcome by the complexity of the coordination and communication processes. However,
    if Bounded Contexts are defined with the *language criterion*, that is, Bounded
    Context boundaries are added whenever the *Ubiquitous Language* changes, this
    should actually be the case. In fact, different languages may arise just as a
    result of a loose interaction between organization subparts since the more subparts
    there are for an organization to interact with, the more they end up using a common
    language.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，Bounded Context的分离只有在结果Bounded Context是松散耦合的情况下才是有效的；否则，通过将整个系统分解为子部分而获得的复杂性降低将被协调和通信过程的复杂性所克服。然而，如果Bounded
    Context是以**语言标准**定义的，即每当**通用语言**发生变化时，就添加Bounded Context边界，那么这实际上应该是这种情况。事实上，不同的语言可能只是由于组织子部分之间松散交互的结果而产生的，因为一个组织要与之互动的子部分越多，它们最终使用的共同语言就越多。
- en: 'Moreover, all human organizations can grow by evolving into loosely coupled
    subparts for the same reason complex software systems may be implemented just
    for the cooperation of loosely coupled submodules: this is the only way humans
    are able to cope with complexity. From this, we can conclude that complex organizations/artificial
    systems can always be decomposed into loosely coupled subparts. We just need to
    understand *how*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有人类组织都可以通过演变成松散耦合的子部分来增长，这与复杂软件系统可能仅为了松散耦合子模块的合作而实现的原因相同：这是人类能够应对复杂性的唯一方式。由此，我们可以得出结论，复杂组织/人工系统总是可以被分解成松散耦合的子部分。我们只需要理解*如何*。
- en: Beyond the basic principles we've mentioned so far, DDD furnishes a few basic
    primitives to describe each Bounded Context, as well as some implementation patterns.
    While Bounded Context primitives are an integral part of DDD, these patterns are
    just useful heuristics we can use in our implementation, so their usage in some
    or in all Bounded Contexts is not obligatory once we opt for DDD adoption.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们之前提到的基本原理之外，DDD 提供了一些基本原语来描述每个边界上下文，以及一些实现模式。虽然边界上下文原语是 DDD 的一个组成部分，但这些模式只是我们在实现中可以使用的有用启发式方法，因此一旦我们选择采用
    DDD，在某些或所有边界上下文中使用这些模式并不是强制性的。
- en: In the next section, we will describe primitives and patterns.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述原语和模式。
- en: Entities and value objects
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和价值对象
- en: DDD entities represent domain objects that have a well-defined identity, as
    well as all the operations that are defined on them. They don't differ too much
    from the entities of other, more classical approaches. Also, DDD entities are
    the starting point of the storage layer design. The main difference is that DDD
    stresses their object-oriented nature more, while other approaches use them mainly
    as *records* whose properties can be written/updated without too many constraints.
    DDD, on the other hand, forces strong SOLID principles on them to ensure that
    only certain information is encapsulated inside of them and that only certain
    information is accessible from outside of them, which operations are allowed on
    them, and which business-level validation criteria apply to them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 实体代表具有明确定义的标识以及在其上定义的所有操作的领域对象。它们与其他更经典方法中的实体差别不大。此外，DDD 实体是存储层设计的起点。主要区别在于，DDD
    更强调它们的面向对象特性，而其他方法主要将它们用作*记录*，其属性可以在没有太多约束的情况下写入/更新。另一方面，DDD 强制实施强 SOLID 原则，以确保只有某些信息被封装在其中，并且只有某些信息可以从外部访问，哪些操作允许在它们上执行，以及哪些业务级别的验证标准适用于它们。
- en: In other words, DDD entities are richer than the entities of record-based approaches.
    In other approaches, operations that manipulate entities are defined outside of
    them in classes that represent business and/or domain operations. In DDD, these
    operations are moved to the entity definitions as their class methods. The reason
    for this is that they offer better modularity and keep related chunks of software
    in the same place so that they can be maintained and tested easily.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，DDD 实体比基于记录的方法中的实体更丰富。在其他方法中，操作实体是在代表业务和/或领域操作的类外部定义的。在 DDD 中，这些操作被移动到实体定义中，作为它们的类方法。这样做的原因是它们提供了更好的模块化，并将相关的软件块保持在同一位置，以便可以轻松维护和测试。
- en: 'For the same reason, business validation rules are moved inside of DDD entities.
    DDD entity validation rules are business-level rules, so they must not be confused
    with database integrity rules or with user-input validation rules. They contribute
    to the way entities represent domain objects by encoding the constraints the represented
    objects must obey. In .NET Core, business validation can be carried out with one
    of the following techniques listed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，业务验证规则被移动到 DDD 实体内部。DDD 实体验证规则是业务级别的规则，因此它们不能与数据库完整性规则或用户输入验证规则混淆。它们通过编码所表示对象必须遵守的约束，有助于实体以某种方式表示领域对象。在
    .NET Core 中，可以使用以下列出的技术之一执行业务验证：
- en: Calling the validation methods in all the class methods that modify the entity
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改实体的所有类方法中调用验证方法
- en: Hooking the validation methods to all the property setters
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将验证方法连接到所有属性设置器
- en: Decorating the class and/or its properties with a custom validation attribute
    and then invoking the `TryValidateObject` static method of the `System.ComponentModel.DataAnnotations.Validator`
    class on the entity each time it is modified
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用自定义验证属性装饰类及其属性，然后在每次修改实体时调用`System.ComponentModel.DataAnnotations.Validator`类的`TryValidateObject`静态方法
- en: Once detected, validation errors must be handled somehow, that is, the current
    operation must be aborted and the error must be reported to an appropriate error
    handler. The simplest way to handle validation errors is by throwing an exception.
    This way, both purposes are easily achieved and we can choose where to intercept
    and handle them. Unfortunately, as we discussed in the *Performance issues that
    need to be considered while programming in C#* section of [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml), *Functional
    and Nonfunctional Requirements*, exceptions imply big performance penalties, so,
    often, different options are considered. Handling errors in the normal flow of
    control would break modularity by spreading the code that's needed to handle the
    error all over the stack of methods that caused the error, with a never-ending set
    of conditions all over that code. Therefore, more sophisticated options are needed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到验证错误，就必须以某种方式处理，也就是说，必须中止当前操作，并将错误报告给适当的错误处理器。处理验证错误的最简单方法是通过抛出异常。这样，两个目的都很容易实现，我们可以选择在哪里拦截和处理它们。不幸的是，正如我们在第2章“在C#编程时需要考虑的性能问题”部分中讨论的那样，异常意味着巨大的性能损失，因此，通常需要考虑不同的选项。在正常流程控制中处理错误会破坏模块化，因为需要处理错误的代码会散布到导致错误的各个方法栈中，并且代码中会有一个不断变化的条件集。因此，需要更复杂的选择。
- en: A good alternative to exceptions is to notify the error handler of any errors
    that are defined in the Dependency Injection engine. Being scoped, the same service
    instance is returned while each request is being processed so that the handler
    that controls the execution of the whole call stack can inspect possible errors
    when the flow of control returns to it and can handle them appropriately. Unfortunately,
    this sophisticated technique can't abort the operation's execution immediately
    or return it to the controlling handler. Therefore, the developer is forced to
    add adequate control conditions to prevent the continuation of the operation.
    This is why exceptions are recommended for this scenario, notwithstanding their
    performance issues.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的一个好替代方案是通知错误处理器在依赖注入引擎中定义的任何错误。由于作用域，在处理每个请求时都会返回相同的服务实例，这样控制整个调用栈执行的处理器就可以在控制流返回时检查可能出现的错误，并适当地处理它们。不幸的是，这种复杂的技巧不能立即中止操作执行或将其返回给控制处理器。因此，开发者被迫添加适当的控制条件来防止操作继续进行。这就是为什么尽管存在性能问题，但仍然建议在这种情况下使用异常。
- en: Business-level validation must not be confused with input validation, which
    will be discussed in more detail in [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml),
    *Presenting ASP.NET Core MVC*, since the two types of validation have different
    and complementary purposes. While business-level validation rules encode domain
    rules, input validation enforces the format of every single input (string length,
    email and URL correct formats, and so on), ensures that all the necessary input
    has been provided, enforces the execution of the chosen user-machine interaction
    protocols, and provides fast and immediate feedback that drives the user to interact
    with the system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 业务级验证不应与输入验证混淆，输入验证将在第13章“展示ASP.NET Core MVC”中更详细地讨论，因为这两种类型的验证有不同的和补充的目的。虽然业务级验证规则编码了领域规则，但输入验证强制执行每个单个输入的格式（字符串长度、电子邮件和URL的正确格式等），确保提供了所有必要的输入，强制执行所选的用户-机器交互协议，并提供快速和即时的反馈，引导用户与系统交互。
- en: 'Since DDD entities must have a well-defined identity, they must have properties
    that act as primary keys. It is common to override the `Object.Equal` method of
    all the DDD entities in such a way that two objects are considered equal whenever
    they have the same primary keys. This is easily achieved by letting all the entities
    inherit from an abstract `Entity` class, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DDD实体必须有一个明确定义的身份，它们必须具有作为主键的属性。通常，会覆盖所有DDD实体的`Object.Equal`方法，使得当两个对象具有相同的主键时，它们被认为是相等的。这可以通过让所有实体继承自一个抽象的`Entity`类来实现，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is worth pointing out that, once we've redefined the `Object.Equal` method
    in the `Entity` class, we can also override with the `==` and `!=` operators.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一旦我们在`Entity`类中重新定义了`Object.Equal`方法，我们也可以通过`==`和`!=`运算符来覆盖它们。
- en: The `IsTransient` predicate returns `true` whenever the entity has been recently
    created and hasn't been recorded in the permanent storage, so its primary key
    is still undefined.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsTransient`谓词在实体最近被创建且尚未记录在持久存储中时返回`true`，因此其主键尚未定义。'
- en: In .NET, it is good practice that, whenever you override the `Object.Equal`
    method of a class, you also override its `Object.GetHashCode` method so that class
    instances can be efficiently stored in data structures such as dictionaries and
    sets. That's why the Entity class overrides it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，当覆盖一个类的`Object.Equal`方法时，也覆盖其`Object.GetHashCode`方法是一个好的实践，以便类实例可以有效地存储在字典和集合等数据结构中。这就是为什么Entity类覆盖了它。
- en: It is also worth implementing an `IEntity<K>` interface that defines all the
    properties/methods of `Entity<K>`. This interface is useful whenever we need to
    hide data classes behind interfaces.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，实现一个定义了`Entity<K>`的所有属性/方法的`IEntity<K>`接口。当我们需要在接口后面隐藏数据类时，这个接口非常有用。
- en: Value objects, on the other hand, represent complex types that can't be encoded
    with numbers or strings. Therefore, they have no identity and no principal keys.
    They have no operations defined on them and are immutable; that is, once they've
    been created, all their fields can be read but cannot be modified. For this reason,
    they are usually encoded with classes whose properties have protected/private
    setters. Two value objects are considered equal when all their independent properties
    are equal (some properties are not independent since they just show data that's
    been encoded by other properties in a different way, as is the case for the ticks
    of `DateTime` and its representation of the date and time fields).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，值对象代表无法用数字或字符串编码的复杂类型。因此，它们没有标识符和主键。它们上没有定义操作，且是不可变的；也就是说，一旦它们被创建，所有字段都可以读取但不能修改。因此，它们通常使用具有受保护的/私有设置器的类进行编码。当所有独立的属性都相等时，两个值对象被认为是相等的（有些属性不是独立的，因为它们只是以不同的方式显示其他属性编码的数据，例如`DateTime`的ticks及其日期和时间字段的表示）。
- en: Typical value objects include costs represented as a number and a currency symbol,
    locations represented as longitude and latitude, addresses, contact information,
    and so on. When the interface of the storage engine is Entity Framework, which
    we analyzed in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# - Entity Framework Core*, and [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml),
    *How to Choose Your Data Storage in the Cloud*, value objects are connected with
    the entity that uses them through the `OwnsMany` and `OwnsOne` relationships.
    In fact, such relationships also accept classes with no principal keys defined
    on them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的值对象包括以数字和货币符号表示的成本、以经纬度表示的位置、地址、联系信息等。当存储引擎的接口是Entity Framework，正如我们在第6章[8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml]“C#中的数据交互
    - Entity Framework Core”和第7章[77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml]“如何在云中选择您的数据存储”中分析的那样，值对象通过`OwnsMany`和`OwnsOne`关系与使用它们的实体连接。实际上，这样的关系也接受没有定义主键的类。
- en: When the storage engine is a NoSQL database, value objects are stored inside
    the record of the entities that use them. On the other hand, in the case of relational
    databases, they can either be implemented with separated tables whose principal
    keys are handled automatically by Entity Framework and are hidden from the developer
    (no property is declared as a principal key) or, in the case of `OwnsOne`, they
    are flattened and added to the table associated with the entity that uses them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储引擎是NoSQL数据库时，值对象存储在使用它们的实体的记录中。另一方面，在关系型数据库的情况下，它们可以与分离的表实现，这些表的主键由Entity
    Framework自动处理，并对开发者隐藏（没有属性被声明为主键）或者，在`OwnsOne`的情况下，它们被扁平化并添加到使用它们的实体关联的表中。
- en: Using SOLID principles to map your domains
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOLID原则映射您的领域
- en: 'In the following subsections, we will describe some of the patterns that are
    commonly used with DDD. Some of them can be adopted in all projects, while others
    can only be used for certain Bounded Contexts. The general idea is that the business
    layer is split into two layers:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将描述一些与DDD（领域驱动设计）常用的一些模式。其中一些可以在所有项目中采用，而另一些则只能用于特定的边界上下文。总体思路是将业务层分为两层：
- en: Application layer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: Domain layer
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层
- en: 'Here, the domain layer is based on the Ubiquitous Language and manipulates
    DDD entities and value objects. DDD entities and value objects are defined in
    this domain layer. The whole business layer communicates with the data layer that''s
    implemented with Entity Framework through interfaces that are defined in the domain
    layer but are implemented in the data layer. Data that''s passed/returned by these
    interface methods are known as DDD entities (the representation of queries and
    their results). The domain layer has no direct reference to the library that implements
    the data layer, but the connection between domain layer interfaces and their data
    layer implementations is performed in the dependency injection engine of the application
    layer. From this, we can understand the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，领域层基于通用语言，并操纵DDD实体和值对象。DDD实体和值对象在领域层中定义。整个业务层通过在领域层定义但在数据层实现的接口与使用Entity
    Framework实现的数据层进行通信。这些接口方法传递/返回的数据被称为DDD实体（查询及其结果的表示）。领域层没有直接引用实现数据层的库，但领域层接口与其数据层实现之间的连接是在应用层的依赖注入引擎中完成的。从这一点我们可以理解以下内容：
- en: The data layer has a reference to the domain layer since it must implement its
    interfaces and must create DDD entities and value objects that are defined in
    the domain layer.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据层必须实现领域层的接口，并必须创建领域层中定义的DDD实体和值对象，因此它引用了领域层。
- en: The application layer has references to the domain and data layers, but references
    to the data layer types only appear in the dependency engine, where they are associated
    with the respective interfaces that were defined in the domain layer.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层引用领域层和数据层，但数据层类型的引用仅出现在依赖引擎中，在那里它们与在领域层中定义的相应接口相关联。
- en: Thus, the domain layer contains the representation of the domain objects, the
    methods to use on them, validation constraints, and its relationship with various
    entities. To increase modularity and decoupling, communication among entities
    is usually encoded with events, that is, with a publisher/subscriber pattern.
    This means entity updates can trigger events that have been hooked to business
    operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，领域层包含领域对象的表示、在其上使用的函数、验证约束以及与各种实体的关系。为了增加模块化和解耦，实体之间的通信通常使用事件编码，即使用发布/订阅模式。这意味着实体更新可以触发连接到业务操作的事件。
- en: This layered architecture allows us to change the whole data layer without affecting
    the domain layer, which only depends on the domain specifications and language
    and doesn't depend on the technical details of how the data is handled.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层架构允许我们更改整个数据层，而不会影响领域层，领域层只依赖于领域规范和语言，不依赖于处理数据的技术细节。
- en: The application layer contains the definitions of all the operations that may
    potentially affect several entities and the definitions of all the queries that
    are needed by the applications. Both business operations and queries use the interfaces
    defined in the domain layer to interact with the data layer. However, while business
    operations manipulate and exchange entities with these interfaces, queries send
    query specifications and receive generic DTOs from them. Business operations are
    invoked either by other layers (typically the presentation layer) or by communication
    with the application layer. Business operations may also be hooked to events that
    are triggered when entities are modified by other operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层包含所有可能影响多个实体的操作定义以及所有应用程序所需的查询定义。业务操作和查询都使用领域层定义的接口与数据层交互。然而，虽然业务操作通过这些接口操纵和交换实体，但查询则向它们发送查询规范并从它们接收通用的DTO（数据传输对象）。业务操作可以通过其他层（通常是表示层）或与应用层的通信来调用。业务操作还可以连接到由其他操作修改实体时触发的事件。
- en: Thus, the application layer operates on the interfaces defined in the domain
    layer instead of interacting directly with their data layer implementations, which
    means that the application layer is decoupled from the data layer. More specifically,
    data layer objects are only mentioned in the dependency injection engine definitions.
    All the other application layer components refer to the interfaces that are defined
    in the domain layers, and the dependency injection engine injects the appropriate
    implementations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用层在领域层定义的接口上操作，而不是直接与它们的数据层实现交互，这意味着应用层与数据层解耦。更具体地说，数据层对象仅在依赖注入引擎定义中提及。所有其他应用层组件都引用在领域层中定义的接口，依赖注入引擎注入适当的实现。
- en: 'The application layer communicates with other application components through
    one or more of the following patterns:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过以下一个或多个模式与其他应用程序组件进行通信：
- en: It exposes business operations and queries on a communication endpoint, such
    as an HTTP Web API (see [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*). In this case, the presentation
    layer may connect to this endpoint or to other endpoints that, in turn, take information
    from this and other endpoints. Application components that collect information
    from several endpoints and expose them in a unique endpoint are called gateways.
    They may be either custom or general-purpose, such as Ocelot.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在通信端点（如HTTP Web API）上暴露业务操作和查询（见[第12章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)，*使用.NET
    Core应用服务架构*）。在这种情况下，表示层可能连接到这个端点或连接到其他端点，这些端点反过来又从这些端点和其他端点获取信息。从多个端点收集信息并在唯一端点暴露这些信息的应用程序组件被称为网关。它们可以是定制的，也可以是通用目的的，例如Ocelot。
- en: It is referenced as a library by an application that directly implements the
    presentation layer, such as an ASP.NET Core MVC Web application.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被直接实现表示层的应用程序（如ASP.NET Core MVC Web应用程序）作为库引用。
- en: It doesn't expose all the information through endpoints and communicates some
    of the data it processes/creates to other application components that, in turn,
    expose endpoints.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是通过端点暴露所有信息，而是将其处理/创建的一些数据通信给其他应用程序组件，这些组件反过来又暴露端点。
- en: Before we describe these patterns, we need to understand the concept of aggregates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述这些模式之前，我们需要理解聚合的概念。
- en: Aggregates
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: So far, we have talked about entities as the *units* that are processed by a
    DDD-based business layer. However, several entities can be manipulated and made
    into single entities. An example of this is a purchase order and all of its items.
    In fact, it makes absolutely no sense to process a single order item independently
    of the order it belongs to. This happens because order-items are actually subparts
    of an order, not independent entities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了实体作为基于DDD的业务层处理的*单元*。然而，几个实体可以被操作并合并成单个实体。一个例子是采购订单及其所有项目。实际上，独立于所属订单处理单个订单项是完全没有意义的。这是因为订单项实际上是订单的子部分，而不是独立的实体。
- en: There is no transaction that may affect a single order-item without it affecting
    the order that the item is in. Imagine that two different people in the same company
    are trying to increase the total quantity of cement but one increases the quantity
    of type-1 cement (item 1) while the other increases the quantity of type-2 cement
    (item 2). If each item is processed as an independent entity, both quantities
    will be increased, which could cause an incoherent purchase order since the total
    quantity of cement would be increased twice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何交易可以单独影响一个订单项而不影响该订单项所在的订单。想象一下，同一家公司的两个不同的人都在尝试增加水泥的总数量，但一个人增加了1型水泥（项目1）的数量，而另一个人增加了2型水泥（项目2）的数量。如果每个项目都被当作一个独立的实体来处理，那么这两个数量都会增加，这可能会导致一个不连贯的采购订单，因为水泥的总数量会被增加两次。
- en: 'On the other hand, if the whole order, along with all its order-items, is loaded
    and saved with every single transaction by both people, one of the two will overwrite
    the changes of the other one, so whoever makes the final change will have their
    requirements set. In a web application, it isn''t possible to lock the purchase
    order for the whole time the user sees and modifies it, so an optimistic concurrency
    policy is used. For instance, it is enough to add a version number to each purchase
    order and to do the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果整个订单及其所有订单项在每次交易中都被两个人加载和保存，那么其中一个人将覆盖另一个人的更改，因此最终做出更改的人将满足他们的需求。在Web应用程序中，不可能在整个用户查看和修改订单的过程中锁定整个采购订单，因此使用乐观并发策略。例如，只需为每个采购订单添加一个版本号，并执行以下操作：
- en: Read the order without opening any transaction.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不打开任何事务的情况下读取订单。
- en: Before saving the modified order, we open a transaction and perform a second
    read.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存修改后的订单之前，我们打开一个事务并执行第二次读取。
- en: If the version number of the newly retrieved order differs from the one of the
    order that was modified by the user, the operation is aborted because someone
    else modified the order that was shown to the user immediately after the first
    read. In this case, the user is informed of the problem and the newly retrieved
    order is shown to the user once more.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新检索到的订单的版本号与用户修改的订单的版本号不同，则操作将被中止，因为有人在第一次读取后立即修改了显示给用户的订单。在这种情况下，用户会被告知问题，并且新检索到的订单将再次显示给用户。
- en: If the version number is unchanged, we increase the version number, proceed
    with the save, and commit the transaction.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果版本号没有更改，我们增加版本号，继续保存，并提交事务。
- en: A purchase order, along with all its subparts (its order-items), is called an
    **aggregate**, while the order entity is called the root of the aggregate. Aggregates
    always have roots since they are hierarchies of entities connected by *subparts* relations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个采购订单及其所有子部分（其订单项）被称为**聚合**，而订单实体被称为聚合的根。由于聚合是由通过**子部分**关系连接的实体层次结构，因此它们总是有根。
- en: Since each aggregate represents a single complex entity, all the operations
    on it must be exposed by a unique interface. Therefore, the aggregate root usually
    represents the whole aggregate, and all the operations on the aggregate are defined
    as methods of the root entity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个聚合代表一个单独的复杂实体，因此对其进行的所有操作都必须通过一个唯一的接口来暴露。因此，聚合根通常代表整个聚合，对聚合的所有操作都定义为根实体的方法。
- en: When the *aggregate* pattern is used, the units of information that are transferred
    between the business layer and the data layer are called *aggregates*, queries,
    and query results. Thus, aggregates replace single entities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用**聚合**模式时，在业务层和数据层之间传输的信息单元被称为**聚合**、查询和查询结果。因此，聚合取代了单个实体。
- en: What about the WWTravelClub location and packages entities we looked at in [Chapter
    6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data in C# -
    Entity Framework Core*, and [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*? Are packages part of the unique aggregates
    that are rooted in their associated locations? No! In fact, locations are rarely
    updated and changes that are made to a package have no influence on its location
    and on the other packages associated with the same location.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在第6章[交互式数据C# - Entity Framework Core](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)和第7章[如何在云中选择您的数据存储](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)中看到的WWTravelClub位置和包实体怎么办？包是根植于它们相关位置的唯一聚合的一部分吗？不！实际上，位置很少更新，对包所做的更改不会影响其位置以及与同一位置相关联的其他包。
- en: The repository and Unit of Work patterns
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库模式和单元工作模式
- en: The repository pattern is how we implement the interface between the domain
    data layer. Interfaces that are implemented by repositories are defined in the
    domain layer, while their implementations are defined in the data layer. The peculiarity
    of this way of implementing the interface with the data layer is its entity-centric
    nature, meaning that there should be a different repository for each root aggregate.
    Each repository contains all the save/creation operations that were performed
    on the associated aggregate, as well as all the query operations that were performed
    on the entities that compose the aggregate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式是我们实现领域数据层之间接口的方式。由存储库实现的接口在领域层中定义，而它们的实现则在数据层中定义。这种实现数据层接口的独特之处在于其实体中心性质，意味着每个根聚合应该有一个不同的存储库。每个存储库包含对相关聚合执行的所有保存/创建操作，以及所有对构成聚合的实体执行的查询操作。
- en: Since there are also transactions that can span several aggregates, usually,
    the repository pattern is applied with the *Unit of Work* pattern. The Unit of
    Work pattern states that each data layer interface (in our case, each repository)
    contains a reference to a *Unit of Work* interface that represents the identity
    of the current transaction. This means that several repositories with the same *Unit
    of Work* reference belong to the same transaction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于也存在跨越多个聚合的事务，通常情况下，会应用*工作单元*模式与存储库模式结合。*工作单元*模式指出，每个数据层接口（在我们的案例中，每个存储库）都包含一个对*工作单元*接口的引用，该接口代表当前事务的标识。这意味着具有相同*工作单元*引用的多个存储库属于同一事务。
- en: 'Both patterns can be implemented by defining some seed interfaces:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式都可以通过定义一些种子接口来实现：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the repository interfaces inherit from `IRepository<T>` and bind `T` to
    the aggregate root they are associated with, while *Unity of Work* simply implements `IUnitOfWork`.
    When using Entity Framework, `IUnitOfWork` is usually implemented with `DBContext`,
    which means that `SaveEntitiesAsync()` can perform other operations and then call
    the `DBContext` `SaveChangeAsync` method so that all the pending changes are saved
    with a single transaction. If a wider transaction that starts when some data is
    retrieved from the storage engine is needed, it must be started and committed/aborted
    by the application layer handler that takes care of the whole operation. `IRepository<T>`
    inherits from an empty `IRepisotory` interface to help automatic repository discovery.
    The GitHub repository associated with this book contains a `RepositoryExtensions`
    class whose `AddAllRepositories` `IServiceCollection` extension method automatically
    discovers all the repository implementations contained in an assembly and adds
    them to the dependency injection engine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所有存储库接口都继承自`IRepository<T>`并将`T`绑定到它们关联的聚合根，而*工作单元*仅实现`IUnitOfWork`。当使用Entity
    Framework时，`IUnitOfWork`通常由`DBContext`实现，这意味着`SaveEntitiesAsync()`可以执行其他操作，然后调用`DBContext`的`SaveChangeAsync`方法，以便将所有挂起的更改通过单个事务保存。如果需要从存储引擎检索数据时启动的更广泛的交易，它必须由负责整个操作的应用程序层处理程序启动和提交/回滚。`IRepository<T>`从空的`IRepisotory`接口继承，以帮助自动存储库发现。与本书相关的GitHub存储库包含一个`RepositoryExtensions`类，其`AddAllRepositories`
    `IServiceCollection`扩展方法可以自动发现一个程序集中包含的所有存储库实现，并将它们添加到依赖注入引擎中。
- en: 'The following is a diagram of the data layer/domain layer/data layer architecture
    based on the repository and Unity of Work patterns:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是基于存储库和Unity of Work模式的存储层/领域层/数据层架构图：
- en: '![](img/6e4ba8d3-66e0-4aa9-8975-e6f64347fdb8.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e4ba8d3-66e0-4aa9-8975-e6f64347fdb8.png)'
- en: The main advantage of avoiding direct references to repository implementations
    is that the various modules can be tested easily if we mock these interfaces.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接引用存储库实现的优点在于，如果我们对这些接口进行模拟，则可以轻松地对各个模块进行测试。
- en: DDD entities and Entity Framework Core
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD实体和Entity Framework Core
- en: DDD requires entities to be defined in a way that is different from the way
    we defined entities in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*. In fact, Entity Framework
    entities are record-like lists of public properties with almost no methods, while
    DDD entities should have methods that encode domain logic, more sophisticated
    validation logic, and read-only properties. While further validation logic and
    methods can be added without breaking Entity Framework's operations, adding read-only
    properties that must not be mapped to database properties can create problems
    that must be handled adequately. Preventing properties from being mapped to the
    database is quite easy – all we need to do is decorate them with the `NotMapped`
    attribute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: DDD 要求实体以与我们在[第 6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中定义实体的方式不同。实际上，Entity
    Framework 实体是具有几乎无方法的公共属性记录列表，而 DDD 实体应该具有编码领域逻辑、更复杂的验证逻辑和只读属性的方法。虽然可以添加进一步的验证逻辑和方法而不会破坏
    Entity Framework 的操作，但添加必须映射到数据库属性之外的只读属性可能会产生必须妥善处理的问题。防止属性映射到数据库相当简单——我们只需要用
    `NotMapped` 属性装饰它们即可。
- en: 'The issues that read-only properties have are a little bit more complex and
    can be solved in three fundamental ways:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性存在的问题稍微复杂一些，可以通过三种基本方式解决：
- en: Define the DDD entities as different classes and copy data to/from them when
    entities are returned/passed to repository methods. This is the easiest solution
    but it requires that you write some code so that you can convert the entities
    between the two formats. DDD entities are defined in the domain layer, while the
    EF entities continue being defined in the data layer.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 DDD 实体定义为不同的类，并在实体返回/传递到存储库方法时在它们之间复制数据。这是最简单的解决方案，但需要您编写一些代码以在两种格式之间转换实体。DDD
    实体在领域层定义，而 EF 实体继续在数据层定义。
- en: 'Let Entity Framework Core map fields to class private fields so that you can
    decide on how to expose them to properties by writing custom getters and/or setters.
    This can be done in the configuration code of the entity, as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让 Entity Framework Core 将字段映射到类私有字段，这样您就可以通过编写自定义获取器和/或设置器来决定如何将它们公开为属性。这可以在实体的配置代码中完成，如下所示：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main disadvantage of this approach is that the field is provided as a string,
    which prevents any compile-time checks and also prevents automatic refactoring,
    thereby creating possible sources of bugs and maintainability issues. Moreover,
    we can't use data annotations to configure the property since the whole configuration
    must be performed with the fluent interface of the `OnModelCreating` `DBContext`
    method. In this case, entity definitions must be moved from the domain layer as
    prescribed by DDD.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是字段以字符串的形式提供，这阻止了任何编译时检查，也阻止了自动重构，从而可能成为错误和维护问题的来源。此外，由于整个配置必须使用 `OnModelCreating`
    `DBContext` 方法的流畅接口执行，因此我们无法使用数据注释来配置属性。在这种情况下，实体定义必须按照 DDD 的规定从领域层移动。
- en: Hide the Entity Framework class with all its public properties behind an interface
    that, when needed, only exposes property getters. The interface is defined in
    the domain layer, while the entity continues being defined in the data layer.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包含所有公共属性的 Entity Framework 类隐藏在接口后面，该接口在需要时仅暴露属性获取器。接口在领域层定义，而实体继续在数据层定义。
- en: In this case, the repository must expose a `Create` method that returns an implementation
    of the interface; otherwise, the higher layers won't be able to create new instances
    that can be added to the storage engine since interfaces can't be created with
    `new`.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，存储库必须公开一个 `Create` 方法，该方法返回接口的实现；否则，高层无法创建新的实例并将其添加到存储引擎中，因为接口不能使用 `new`
    创建。
- en: 'For instance, suppose that we would like to define a DDD interface called `IDestination`
    for the `Destination` class defined in the *Defining DB Entities* subsection of
    [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data
    in C# – Entity Framework Core*, and suppose we would like to expose the `Id`,
    `Name`, and `Country` properties as read-only since once a destination is created
    they can''t be modified anymore. Here, it is enough to let `Destination` implement `IDestination`
    and to define `Id`, `Name`, and `Country` as read-only in `IDestination`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要为[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中“定义数据库实体”小节中定义的`Destination`类定义一个DDD接口，称为`IDestination`，并且假设我们希望将`Id`、`Name`和`Country`属性公开为只读，因为一旦目的地创建后，它们就不能再修改。在这里，让`Destination`实现`IDestination`并在`IDestination`中将`Id`、`Name`和`Country`定义为只读就足够了：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we've discussed the basic patterns of DDD and how to adapt the Entity
    Framework for the needs of DDD, we can discuss more advanced DDD patterns. In
    the next subsection, we will introduce the CQRS pattern.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了DDD的基本模式和如何为DDD的需求适配Entity Framework，我们可以讨论更高级的DDD模式。在下一个小节中，我们将介绍CQRS模式。
- en: Command Query Responsibility Segregation (CQRS) pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询责任分离（Command Query Responsibility Segregation，CQRS）模式
- en: 'In its more general form, the usage of this pattern is quite easy: use different
    structures to store and query data. Here, the requirements regarding how to store
    and update data differ from the requirements of queries. In the case of DDD, the
    unit of storage is the *aggregate*, so additions, deletions, and updation involve
    aggregates, while queries usually involve more or less complicated transformations
    of properties that have been taken from several aggregates.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在其更一般的形式中，该模式的用法相当简单：使用不同的结构来存储和查询数据。在这里，关于如何存储和更新数据的要求与查询的要求不同。在DDD的情况下，存储的单位是*聚合*，因此增加、删除和更新涉及聚合，而查询通常涉及从几个聚合中提取的属性的更多或更少的复杂转换。
- en: Moreover, usually, we don't perform business operations on query results – we
    just use them to compute other data (averages, sums, and so on). Therefore, while
    updates require entities with full object-oriented semantics (methods, validation
    rules, encapsulated information, and so on), query results just need sets of property/values
    pairs, so DTOs with only public properties and no methods work well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常我们不会在查询结果上执行业务操作——我们只是使用它们来计算其他数据（平均值、总和等）。因此，虽然更新需要具有完整面向对象语义（方法、验证规则、封装信息等）的实体，但查询结果只需要属性/值对的集合，因此只有公共属性而没有方法的DTOs工作得很好。
- en: 'In its more common form, the pattern can be depicted as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在其更常见的形式中，该模式可以描述如下：
- en: '![](img/c535aa97-526c-4dff-8fe5-4fe14d85f1fb.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c535aa97-526c-4dff-8fe5-4fe14d85f1fb.png)'
- en: 'The main takeaway from this is that the extraction of query results don''t
    need to pass through the construction of entities and aggregates, but the fields
    shown in the query must be extracted from the storage engine and projected into
    ad hoc DTOs. If queries are implemented with LINQ, we need to use the `Select`
    clause to project the necessary properties into DTOs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以得出的主要结论是，查询结果的提取不需要通过实体的构建和聚合的构建，但查询中显示的字段必须从存储引擎中提取并投影到临时的DTOs中。如果查询是用LINQ实现的，我们需要使用`Select`子句将必要的属性投影到DTOs中：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, in more complex situations, the CQRS may be implemented in a stronger
    form. Namely, we can use different Bounded Contexts to store preprocessed query
    results. This approach is common when queries involve data stored in different
    Bounded Contexts that's handled by different distributed microservices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更复杂的情况下，CQRS可能以更强的形式实现。具体来说，我们可以使用不同的边界上下文来存储预处理后的查询结果。这种方法在涉及由不同分布式微服务处理的不同边界上下文中存储的数据的查询中很常见。
- en: In fact, the other option would be an aggregator microservice that queries all
    the necessary microservices in order to assemble each query result. However, recursive
    calls to other microservices to build an answer may result in unacceptable response
    times. Moreover, factoring out some preprocessing ensures better usage of the
    available resources. This pattern is implemented by sending changes caused by
    Bounded Context updates to all the microservices that need them for computing
    their preprocessed query results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，另一个选择是一个聚合器微服务，它会查询所有必要的微服务以组装每个查询结果。然而，对其他微服务的递归调用以构建答案可能会导致不可接受的响应时间。此外，将一些预处理提取出来可以确保更好地利用可用资源。这种模式通过将由边界上下文更新引起的更改发送到所有需要它们来计算其预处理的查询结果的微服务来实现。
- en: The usage of this stronger form of the CQRS pattern transforms usual local database
    transactions into complex time-consuming distributed transactions since a failure
    in a single query preprocessor microservice should invalidate the whole transaction.
    As we explained in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, implementing distributed
    transactions is usually unacceptable for performance reasons, so the common solution
    is to renounce to immediate overall coherent database and to accept that the overall
    database will eventually be coherent after each update. Transient failures can
    be solved with the retry policies that we analyzed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, while permanent failures
    are handled by performing corrective actions on the already committed local transactions
    instead of pretending to implement an overall globally distributed transaction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更强大的CQRS模式的使用将通常的本地数据库事务转换为复杂且耗时的分布式事务，因为单个查询预处理器微服务中的失败应该使整个事务无效。正如我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中解释的，*将微服务架构应用于您的企业应用*，由于性能原因，通常不接受实现分布式事务，因此常见的解决方案是放弃立即的整体一致数据库，并接受整体数据库将在每次更新后最终一致。瞬态故障可以通过我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中分析的重试策略来解决，*将微服务架构应用于您的企业应用*，而永久性故障则通过在已提交的本地事务上执行纠正操作来处理，而不是假装实现一个全局分布式的整体事务。
- en: As we discussed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, communication between
    microservices is often implemented with the publisher/subscriber pattern to improve
    microservice separation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中讨论的，*将微服务架构应用于您的企业应用*，微服务之间的通信通常使用发布/订阅模式来实现以改善微服务分离。
- en: 'At this point, you may be asking the following question:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会有以下疑问：
- en: '"Why do we need to keep the original data once we have all the preprocessed
    query results? We will never use them to answer queries!"'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '"为什么我们一旦有了所有预处理的查询结果，还需要保留原始数据？我们永远不会用它们来回答查询！"'
- en: 'Some of the answers to this are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的一些答案如下：
- en: They are the source of `truth` that we may need to recover from failures.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是我们可能需要从失败中恢复的`真理`的来源。
- en: We need them to compute new preprocessed results when we add new queries.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们添加新的查询时，我们需要它们来计算新的预处理结果。
- en: We need them to process new updates. In fact, processing updates usually requires
    that some of the data is retrieved from the database, possibly shown to the user,
    and then modified. For instance, to modify an item in an existing purchase order,
    we need the whole order so that we can show it to the user and compute the changes
    so that we can forward it to other microservices. Moreover, whenever we modify
    or add data to the storage engine, we must verify the coherence of the overall
    database (unique key constraints, foreign key constraints, and so on).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要它们来处理新的更新。实际上，处理更新通常需要从数据库中检索一些数据，可能显示给用户，然后进行修改。例如，要修改现有采购订单中的项目，我们需要整个订单，以便我们可以将其显示给用户并计算更改，以便我们可以将其转发给其他微服务。此外，无论何时我们修改或向存储引擎添加数据，都必须验证整个数据库的一致性（唯一键约束、外键约束等）。
- en: In the next section, we will describe a common pattern that's used for handling
    operations that span several aggregates or several Bounded Contexts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述一个用于处理跨越多个聚合或多个边界上下文的操作的常见模式。
- en: Command handlers and domain events
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令处理器和领域事件
- en: 'To keep aggregates separated, usually, interactions with other aggregates and
    other Bounded Contexts is done through events. It is good practice to store all
    the events when they are computed during each aggregate process instead of processing
    them immediately in order to avoid them interfering with the ongoing computation.
    This is easily achieved by adding the following code to the abstract Entity class
    defined in the *Entities and value objects* subsection of this chapter, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持聚合分离，通常，与其他聚合和其他边界上下文之间的交互是通过事件完成的。在计算每个聚合过程期间存储所有事件，而不是立即处理它们，以避免它们干扰正在进行的计算，这是一种良好的实践。这可以通过向本章
    *实体和价值对象* 小节中定义的抽象实体类添加以下代码轻松实现，如下所示：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `IEventNotification` is an empty interface that's used to mark classes
    as events.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`IEventNotification` 是一个空接口，用于标记类作为事件。
- en: Event processing is usually performed immediately before changes are stored
    in the storage engine. Accordingly, a good place to perform event processing is
    in the `SaveEntitiesAsync()` method of each `IUnitOfWork` implementation (see
    the *The repository and Unit of Work patterns* subsection).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理通常在更改存储在存储引擎之前立即执行。因此，在 `IUnitOfWork` 实现的 `SaveEntitiesAsync()` 方法中执行事件处理是一个好地方（见
    *存储库和单元工作模式* 小节）。
- en: 'Subscriptions to an event, `T`, can be provided as an implementation of the `IEventHandler<T>`
    interface:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对事件 `T` 的订阅可以提供为 `IEventHandler<T>` 接口的一个实现：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Analogously, business operations can be described by the `command` object,
    which contains all the input data of the operation, while the code that implements
    the actual operation can be provided through the implementation of an `ICommandHandler<T>`
    interface:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，业务操作可以通过包含操作所有输入数据的 `command` 对象来描述，而实现实际操作的代码可以通过 `ICommandHandler<T>`
    接口的实现来提供：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `ICommand` is an empty interface that's used to mark classes as commands. `ICommandHandler<T>`
    and `IEventHandler<T>` are examples of the command pattern we described in [Chapter
    9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and .NET Core
    Implementation*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ICommand` 是一个空接口，用于标记类作为命令。`ICommandHandler<T>` 和 `IEventHandler<T>` 是我们在
    [第 9 章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml) 中描述的命令模式的示例，*设计模式和 .NET Core
    实现*。
- en: Each `ICommandHandler<T>` can be registered in the dependency injection engine
    so that classes that need to execute a command, `T`, can use `ICommandHandler<T>`
    in their constructor. This way, we decouple the abstract definition of a command
    (command class) from the way it is executed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `ICommandHandler<T>` 都可以在依赖注入引擎中注册，以便需要执行命令 `T` 的类可以在它们的构造函数中使用 `ICommandHandler<T>`。这样，我们就将命令（命令类）的抽象定义与其执行方式解耦。
- en: 'The same construction can''t be applied to events, `T`, and their `IEventHandler<T>` because
    when an event is triggered, we need to retrieve several `IEventHandler<T>` and
    not just one. We need to do this since each event may have several subscriptions.
    However, a few lines of code can easily solve this difficulty. First, we need
    to define a class that hosts all the handlers for a given event type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的构造不能应用于事件 `T` 和它们的 `IEventHandler<T>`，因为当一个事件被触发时，我们需要检索几个 `IEventHandler<T>`
    而不是只有一个。我们需要这样做，因为每个事件可能有多个订阅。然而，几行代码就可以轻松解决这个问题。首先，我们需要定义一个类，它托管给定事件类型的所有处理器：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The idea is that each class that needs to trigger event `T` requires an `EventTrigger<T>` and
    then passes the event to be triggered to its `Trigger` method, which, in turn,
    invokes all the handlers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是每个需要触发事件 `T` 的类都需要一个 `EventTrigger<T>`，然后将要触发的事件传递给它的 `Trigger` 方法，该方法反过来调用所有处理器。
- en: 'Then, we need to register `EventTrigger<T>` in the dependency injection engine.
    A good idea is to define the dependency injection extensions that we can invoke
    to declare each event, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在依赖注入引擎中注册 `EventTrigger<T>`。一个不错的方法是定义依赖注入扩展，我们可以调用它来声明每个事件，如下所示：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `AddEventHandler` extension must automatically produce a DI definition
    for `EventTrigger<T>` and must process all the handlers that are declared with
    `AddEventHandler` for each type, `T`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `AddEventHandler` 扩展必须自动生成 `EventTrigger<T>` 的 DI 定义，并且必须处理每个类型 `T` 使用 `AddEventHandler`
    声明的所有处理器。
- en: 'The following extension class does this for us:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下扩展类为我们做了这件事：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `H` types of all the handlers associated with each event, `T`, are recorded
    in a list contained in an entry of a dictionary indexed by the `T` type of the
    event. Then, each `H` is recorded in the dependency injection engine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个事件 `T` 相关的所有处理程序的 `H` 类型记录在字典条目中，该字典条目由事件的 `T` 类型索引。然后，每个 `H` 都记录在依赖注入引擎中。
- en: The first time an entry for an event, `T`, is added, the corresponding dictionary
    entry is created (a `List<Type>`) and the corresponding `EventTrigger<T>` is added
    to the dependency injection engine. The `EventTrigger<T>` instance is created
    by a function that's passed to `AddSingleton<EventTrigger<T>>`, which uses the
    dictionary entry for `T` to get all the handler types. Then, all the handler types
    are used to retrieve the instances for the dependency injection engine with `p.GetService(type)`.
    We can use this operation since all the handler types were registered in the dependency
    injection engine. Finally, the list of all the handlers is used to create the
    required instance of `EventTrigger<T>`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次添加事件 `T` 的条目时，会创建相应的字典条目（一个 `List<Type>`）并将相应的 `EventTrigger<T>` 添加到依赖注入引擎中。`EventTrigger<T>`
    实例是通过传递给 `AddSingleton<EventTrigger<T>>` 的函数创建的，该函数使用 `T` 的字典条目来获取所有处理程序类型。然后，使用所有处理程序类型通过
    `p.GetService(type)` 从依赖注入引擎中检索它们的实例。我们可以使用这个操作，因为所有处理程序类型都已注册在依赖注入引擎中。最后，使用所有处理程序列表创建所需的
    `EventTrigger<T>` 实例。
- en: When the program starts up, all the `ICommandHandler<T>` and `IEventHandler<T>`
    implementations can be retrieved with reflection and registered automatically.
    To help with automatic discovery, they inherit from `ICommandHandler` and `IEventHandler`,
    which are both empty interfaces. The `EventDIExtensions` class, which is available
    in this book's GitHub repository, contains methods for the automatic discovery
    and registration of command handlers and event handlers. The GitHub repository
    also contains an `IEventMediator` interface and its `EventMediator` interface,
    whose `TriggerEvents(IEnumerable<IEventNotification> events)` method retrieves
    all the handlers associated with the events it receives in its argument from the
    dependency injection engine and executes them. It is enough to have `IEventMediator`
    injected into a class so that it can trigger events. `EventDIExtensions` also
    contains an extension method that discovers all the queries that implement the
    empty `IQuery` interface and adds them to the dependency injection engine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，所有 `ICommandHandler<T>` 和 `IEventHandler<T>` 的实现都可以通过反射自动检索并注册。为了帮助自动发现，它们继承自
    `ICommandHandler` 和 `IEventHandler`，这两个接口都是空的。本书的 GitHub 仓库中提供的 `EventDIExtensions`
    类包含用于自动发现和注册命令处理程序和事件处理程序的方法。GitHub 仓库还包含一个 `IEventMediator` 接口及其 `EventMediator`
    接口，其 `TriggerEvents(IEnumerable<IEventNotification> events)` 方法从依赖注入引擎中检索其参数中接收到的所有与事件关联的处理程序并执行它们。只要将
    `IEventMediator` 注入到类中，就可以触发事件。`EventDIExtensions` 还包含一个扩展方法，用于发现实现空 `IQuery`
    接口的查询，并将它们添加到依赖注入引擎中。
- en: A more sophisticated implementation is given by the `MediatR` NuGet package.
    The previous subsection is dedicated to an extreme implementation of the CQRS
    pattern.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更为复杂的实现由 `MediatR` NuGet 包提供。前一小节专门介绍了一种极端的 CQRS 模式实现。
- en: Event sourcing
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: 'Event sourcing is an extreme implementation of the stronger form of CQRS. It
    is useful when the original Bounded Context isn''t used at all to retrieve information
    and just as a *source of truth* is used for new queries and for recovering from
    failures. In this case, instead of updating data, we simply add events that describe
    the operation that was performed: *deleted record Id 15*, changed the name to
    *John in Id 21*, and so on. These events are immediately sent to all the dependent
    Bounded Contexts, and in the case of failures and/or the addition of new queries,
    all we have to do is to reprocess some of them.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是 CQRS 强化形式的一种极端实现。当原始的边界上下文根本不用于检索信息，而仅作为 *真相来源* 用于新的查询和从故障中恢复时，它非常有用。在这种情况下，我们不是更新数据，而是简单地添加描述已执行操作的
    *事件*：*删除记录 ID 15*，将名称更改为 *ID 21 中的 John*，等等。这些事件立即发送到所有依赖的边界上下文，在出现故障和/或添加新查询的情况下，我们只需重新处理其中的一些即可。
- en: While all of the techniques we've described up until now can be used in every
    type of project if minor modifications are made, event sourcing requires a deep
    analysis to be performed before it can be adopted since, in several cases, it
    may create bigger problems than the ones it can solve. To get an idea of the problems
    it may cause when it's misused, imagine that we apply it to purchase orders that
    have been modified and validated by several users before being approved. Since
    purchase orders need to be retrieved before they're updated/validated, the purchase
    order's Bounded Context isn't used just as a *source of truth*, so event sourcing
    should not be applied to it. If this isn't the case, then we can apply event sourcing
    to it, in which case our code would be forced to rebuild the whole order from
    the recorded events each time the order is updated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前描述的所有技术都可以在所有类型的项目中使用，只要进行一些小的修改，但事件溯源需要在采用之前进行深入分析，因为，在几种情况下，它可能比它能解决的问题造成更大的问题。为了了解它误用时可能引起的问题，想象一下我们将它应用于已经由多个用户修改和验证但尚未批准的采购订单。由于采购订单需要在更新/验证之前检索，因此采购订单的边界上下文不仅仅被用作*真相来源*，所以不应将其应用于事件溯源。如果不是这种情况，那么我们可以将其应用于事件溯源，在这种情况下，我们的代码将被迫在每次更新订单时从记录的事件中重建整个订单。
- en: An example of its usage is the revenue logging system we described at the end
    of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*. Single revenues are recorded with
    event sourcing and then sent to the microservice we described in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, which, in turn, uses
    them to preprocess future queries, that is, to compute daily revenues.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它的一个使用示例是我们描述在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”末尾的收入日志系统。单个收入通过事件溯源记录，然后发送到我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”中描述的微服务，该微服务反过来使用它们来预处理未来的查询，即计算每日收入。
- en: In the next section, we will learn how DDD can be applied to this book's WWTravelClub
    use case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将DDD应用于本书的WWTravelClub用例。
- en: Use case – understanding the domains of the use case
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 – 理解用例的领域
- en: 'From the requirements listed in the *Case study – WWTravelClub* section of
    [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, and for the analysis in the *Use case – where do I
    store data?* section of [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*, we know that the WWTravelClub system
    is composed of the following parts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)，“理解软件架构的重要性”中*案例研究 – WWTravelClub*部分列出的需求和[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)，“如何在云中选择您的数据存储”中*用例
    – 我在哪里存储数据？*部分的分析中，我们知道WWTravelClub系统由以下部分组成：
- en: Information about the available destinations and packages. We implemented the
    first prototype of this subsystem's data layer in [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用目的地和套餐的信息。我们在[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)，“如何在云中选择您的数据存储”中实现了该子系统数据层的第一个原型。
- en: Reservation/purchase orders subsystem.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订/购买订单子系统。
- en: Communication with the experts/reviews subsystem.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专家/审查子系统的通信。
- en: Payment subsystem. We briefly analyzed the features of this subsystem and its
    relationship with the reservation purchase subsystem at the beginning of the *Domain-driven
    design* section of this chapter.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付子系统。我们在本章*领域驱动设计*部分的开始简要分析了该子系统的功能和它与预订购买子系统的关系。
- en: User accounts subsystem.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户账户子系统。
- en: Statistics reporting subsystem.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计报告子系统。
- en: 'Do the preceding subsystems represent different *Bounded Contexts*? Can some
    subsystems be split into different Bounded Contexts? The answers to these questions
    are given by *the languages* that are spoken in each subsystem:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的子系统代表不同的*边界上下文*吗？某些子系统可以被拆分为不同的边界上下文吗？这些问题的答案由每个子系统使用的*语言*提供：
- en: The language that's spoken in subsystem 1 is the language of *travel agencies*.
    There is no concept of a customer; just of locations, packages, and their features.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统1使用的语言是*旅行社*的语言。没有客户的概念；只有地点、套餐及其特性。
- en: The language that's spoken in subsystem 2 is common to all service purchases,
    such as the available resources, reservations, and purchase orders. This is a
    separate Bounded Context.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统2中使用的语言对所有服务购买都是通用的，例如可用的资源、预订和采购订单。这是一个独立的边界上下文。
- en: 'The language that''s spoken in subsystem 3 has a lot in common with subsystem
    1''s language. However, there are also typical *social media* concepts, such as
    rating, chats, post sharing, media sharing, and so on. This subsystem can be split
    into two parts: a social media subsystem that has a new bounded context and an
    *available information* subsystem that is part of the Bounded Context of subsystem
    1.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统3中使用的语言与子系统1的语言有很多相似之处。然而，也存在典型的*社交媒体*概念，如评分、聊天、帖子分享、媒体分享等。这个子系统可以分为两部分：一个具有新边界上下文的社交媒体子系统和一个属于子系统1边界上下文的*可用信息*子系统。
- en: As we pointed out in the *Domain-driven design* section, in subsystem 4, we
    speak the language of *banking*. This subsystem communicates with the reservation
    purchase subsystem and executes tasks that are needed to carry out a purchase.
    From these observations, we can see that it is a different Bounded Context and
    has a customer/supplier relationship with the purchase/reservation system.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在*领域驱动设计*部分所指出的，在子系统4中，我们使用*银行*的语言。这个子系统与预订/采购子系统进行通信并执行执行购买所需的任务。从这些观察结果中，我们可以看出它是一个不同的边界上下文，并且与购买/预订系统有客户/供应商关系。
- en: Subsystem 5 is definitely a separate Bounded Context (as in almost all web applications).
    It has a relationship with all the Bounded Contexts that either have a concept
    of a user or a concept of a customer because the concept of user accounts always
    maps to these concepts. But how? Simple—the currently logged-in user is assumed
    to be the social media user of the social media Bounded Context, the customer
    of the reservation/purchase Bounded Context, and the payer of the payment Bounded
    Context.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统5肯定是一个独立的边界上下文（就像几乎所有网络应用一样）。它与所有具有用户或客户概念的边界上下文都有关系，因为用户账户的概念总是映射到这些概念上。但这是如何实现的呢？简单——当前登录的用户被认为是社交媒体边界上下文的社会媒体用户、预订/采购边界上下文的客户以及支付边界上下文的付款人。
- en: The query-only subsystem, that is, 6, speaks the language of analytics and statistics
    and differs a lot from the languages that are spoken in the other subsystems.
    However, it has a connection with almost all the Bounded Contexts since it takes
    all its input from them. The preceding constraints force us to adopt CQRS in its
    strong form, thereby considering it a query-only separated Bounded Context. We
    implemented a part of it in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, by using a microservice
    that conforms to a strong form of CQRS.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询仅子系统，即6，使用分析和统计的语言，与其他子系统中使用的语言有很大不同。然而，它几乎与所有边界上下文都有联系，因为它从它们那里获取所有输入。前面的约束迫使我们采用强形式的CQRS，因此将其视为一个查询仅分离的边界上下文。我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，*将微服务架构应用于您的企业应用*中实现了一部分，使用了一个符合强形式CQRS的微服务。
- en: In conclusion, each of the listed subsystems defines a different Bounded Context,
    but part of the *communication with the experts/reviews subsystem* must be included
    in the *Information about available destinations and packages* Bounded Context.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，列出的每个子系统定义了一个不同的边界上下文，但部分与*专家/审查子系统*的通信必须包含在*关于可用目的地和套餐的信息*边界上下文中。
- en: As the analysis continues and a prototype is implemented, some Bounded Contexts
    may split and some others may be added, but it is fundamental to immediately start
    modeling the system and to immediately start analyzing the relations among the
    Bounded Contexts with the partial information we have since this will drive further
    investigations and will help us define the communication protocols and Ubiquitous
    Languages that are needed so that we can interact with the domain experts.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分析的继续和原型的实现，一些边界上下文可能会分裂，而另一些边界上下文可能会被添加，但立即开始建模系统并立即开始分析我们拥有的部分信息之间的边界上下文关系是基本的，因为这将推动进一步的调查，并帮助我们定义所需的通信协议和通用语言，以便我们可以与领域专家互动。
- en: 'The following is a basic first sketch of the domain map:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该领域映射的基本初步草图：
- en: '![](img/070f378b-16a3-47ff-bfd1-dd1a800fade6.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/070f378b-16a3-47ff-bfd1-dd1a800fade6.png)'
- en: For simplicity, we've omitted the **Statistics reporting** Bounded Context.
    Here, we're assuming that the **User accounts** and **Social** Bounded Contexts
    have a *conformist* relationship with all the other Bounded Contexts that communicate
    with them because they are implemented with already existing software, so all
    the other components must adapt to them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们省略了**统计报告**边界上下文。在这里，我们假设**用户账户**和**社交**边界上下文与所有与之通信的其他边界上下文具有**一致**的关系，因为它们使用现有的软件实现，所以所有其他组件都必须适应它们。
- en: As we mentioned previously, the relationship between **Reservation** and **Payments** is
    *customer/supplier* because *Payments* furnishes services that are used to execute
    the tasks of *Reservation*. All the other relationships are classed as *Partners*.
    The various concepts of customer/user that most Bounded Contexts have are coordinated
    by the **User accounts** authorization token, which indirectly takes care of mapping
    these concepts between all the Bounded Contexts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，**预订**和**支付**之间的关系是**客户/供应商**，因为**支付**提供用于执行**预订**任务的服务。所有其他关系都被归类为**合作伙伴**。大多数边界上下文都有的客户/用户的各种概念由**用户账户**授权令牌协调，它间接地负责在所有边界上下文之间映射这些概念。
- en: The *Packages/location* subsystem not only communicates the packages information
    that's needed for carrying out a reservation/purchase – it also takes care of
    informing pending purchase orders of possible price changes. Finally, we can see
    that social interactions are started from an existing review or location, thereby
    creating communication with the *Package/locations* Bounded Context.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**包裹/位置**子系统不仅传达了执行预订/购买所需的包裹信息，而且还负责通知待处理的购买订单可能的价格变化。最后，我们可以看到社交互动是从现有的评论或位置开始的，从而与**包裹/位置**边界上下文建立通信。'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the main reasons for the adoption of domain-driven
    design and why and how it faces the needs of the market. Here, we described how
    to identify domains and how to coordinate the teams that work on different domains
    of the same application with domain maps. Then, we analyzed the way DDD represents
    data with entities, value objects and aggregates, furnishing advice, and code
    snippets so that we could implement them in practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了采用领域驱动设计的主要原因以及它如何满足市场需求。在这里，我们描述了如何识别领域以及如何使用领域图来协调同一应用程序中不同领域的工作团队。然后，我们分析了DDD如何通过实体、值对象和聚合来表示数据，并提供建议和代码片段，以便我们可以在实践中实现它们。
- en: We also covered some typical patterns that are used with DDD, that is, the repository
    and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then,
    we learned how to implement them in practice. We also showed you how to implement
    domain events and the command pattern with decoupled handling so that we can add
    furnishing code snippets to real-world projects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些与领域驱动设计（DDD）一起使用的典型模式，即存储库和单元工作模式、领域事件模式、CQRS和事件溯源。然后，我们学习了如何在实践中实现它们。我们还展示了如何使用解耦处理来实现领域事件和命令模式，以便我们可以将填充代码片段添加到现实世界的项目中。
- en: Finally, we used the principles of DDD in practice to define domains and to
    create the first sketch of a domain map for this book's WWTravelClub use case.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们利用DDD的原则在实践上定义领域，并为本书的WWTravelClub用例创建了领域图的第一个草图。
- en: In the next chapter, you will learn how to maximize code reuse in your projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在项目中最大化代码重用。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What furnishes the main hints so that we can discover domain boundaries?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么提供了主要的提示，以便我们可以发现领域边界？
- en: What is the main tool that's used for coordinating the development of a separate
    Bounded Context?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于协调独立边界上下文开发的主体工具是什么？
- en: Is it true that each entry that composes an aggregate communicates with the
    remainder of the system with its own methods?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成聚合的每个条目是否确实使用其自己的方法与系统的其余部分进行通信？
- en: Why is there a single aggregate root?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么只有一个聚合根？
- en: How many repositories can manage an aggregate?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多少个存储库可以管理一个聚合？
- en: How does a repository interact with the application layer?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储库如何与应用程序层交互？
- en: Why is the Unit of Work pattern needed?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要单元工作模式？
- en: What are the reasons for the light form of CQRS? What about the reasons for
    its strongest form?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CQRS轻量级形式的原因是什么？它的最强形式的原因又是什么？
- en: What is the main tool that allows us to couple commands/domain events with their
    handlers?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要允许我们将命令/领域事件与其处理程序耦合的工具是什么？
- en: Is it true that event sourcing can be used to implement any Bounded Context?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件源是否可以用来实现任何有界上下文？
- en: Further reading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More resources on domain-driven design can be found here: [https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于领域驱动设计的资源可以在这里找到：[https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)
- en: A detailed discussion of CQRS design principles can be found here: [http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于CQRS设计原则的详细讨论可以在这里找到：[http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)
- en: More information on MediatR can be found on MediatR's GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于MediatR的信息可以在MediatR的GitHub仓库中找到：[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
- en: A good description of event sourcing, along with an example of it, can be seen
    in the following blog post by Martin Fowler: [https://martinfowler.com/eaaDev/EventSourcing.html ](https://martinfowler.com/eaaDev/EventSourcing.html)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在马丁·福勒的以下博客文章中找到对事件源的一个良好描述及其示例：[https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)
