- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Topics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: In this chapter, we will examine a few advanced topics not covered elsewhere
    in the book. This includes Implementing an Advanced API using a more complex data
    structure, Storage Tables, and the very exciting new (at the time of this writing)
    Aspire feature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些在本书其他地方没有涵盖的高级主题。这包括使用更复杂的数据结构实现高级API、存储表以及当时非常激动人心的新（在撰写本文时）Aspire功能。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Implementing an advanced API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现高级API
- en: Updating the database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库
- en: Supporting implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持实现
- en: Creating Azure Storage Tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Azure存储表
- en: Aspire dashboard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aspire仪表板
- en: Adding Aspire to existing projects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Aspire添加到现有项目中
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要以下内容：
- en: Visual Studio.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio。
- en: The **Azure.Data.Tables** NuGet package.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure.Data.Tables** NuGet包。'
- en: An Azure account (you can get a free starter account at [https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)
    ).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure账户（您可以在[https://azure.microsoft.com/en-us/](https://azure.microsoft.com/en-us/)
    获取免费入门账户）。
- en: Aspire comes with Visual Studio 2022 (version 17.10 or higher) and requires
    . NET 8.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Aspire随Visual Studio 2022（版本17.10或更高）一起提供，并需要.NET 8。
- en: You will need to install Docker Desktop (which is free and can be obtained at
    [https://www.docker.com/Products/docker-desktop/](https://www.docker.com/Products/docker-desktop/)
    ).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要安装Docker Desktop（它是免费的，可以在[https://www.docker.com/Products/docker-desktop/](https://www.docker.com/Products/docker-desktop/)
    获取）。
- en: 'The code files for this chapter can be found in the GitHub repository here:
    [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub存储库中找到：[https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter08)
- en: Implementing an advanced API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高级API
- en: Until now, we’ve been working with a very simple database, and implementing
    pretty straightforward APIs. From time to time, however, your client will ask
    for something more difficult or complex. Let’s take a look at one such requirement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个非常简单的数据库，并实现相当直接的API。然而，有时您的客户会要求更复杂或更困难的事情。让我们看看这样一个要求。
- en: 'The client has asked for the ability to see a car with all its options. We’ll
    provide that in JSON for easy display on the web, phone, and so on. The JSON will
    look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 客户要求能够看到带有所有选项的汽车。我们将以JSON格式提供，以便在网页、手机等设备上轻松显示。JSON将如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To implement this, we’ll need to add a table to the database: **Options** .'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要在数据库中添加一个表：**选项**。
- en: Updating the database
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新数据库
- en: 'We need to track various features (options) the user may select, such as a
    sunroof, the winter package, and so on. To do this, we will create a new table,
    **Options** , which will have four columns:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要跟踪用户可能选择的各个功能（选项），例如天窗、冬季套餐等。为此，我们将创建一个新的表，**选项**，它将包含四个列：
- en: '**car_id** : The ID of the car to which this option will be added'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**car_id**：添加此选项的汽车的ID'
- en: '**option_id** : The ID of the option'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**option_id**：选项的ID'
- en: '**option_name** : The name of the feature'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**option_name**：功能的名称'
- en: '**option_price** : The MSRP for this feature'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**option_price**：此功能的MSRP'
- en: 'Here is a sample of the **Options** table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是**选项**表的示例：
- en: '![Figure 8.1 – Sample rows from the Options table](img/B21998_08_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 选项表的示例行](img/B21998_08_01.jpg)'
- en: Figure 8.1 – Sample rows from the Options table
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 选项表的示例行
- en: You’ll want to create at least 10 rows using arbitrary values. Note that there
    is no table with the option names and values. This is a simple mostly non-relational
    database, though you are free to add such tables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要使用任意值创建10行。请注意，没有包含选项名称和值的表。这是一个简单的、主要非关系型数据库，尽管您可以自由地添加此类表。
- en: 'With this table, we can create our one relationship; that is between the **car**
    table and the **Options** table. Add **car_id** to the **car** table, and create
    our **Select** statement with a join to the options table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个表，我们可以创建我们的一个关系；即**汽车**表和**选项**表之间的关系。将**car_id**添加到**汽车**表中，并创建我们的**选择**语句，与选项表进行连接：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result looks like the **car** table, but has the options for each car appended
    to the end, as shown in *Figure 8* *.2* :'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来像**汽车**表，但每个汽车的选项都附加在末尾，如图*图8.2*所示：
- en: '![Figure 8.2 – Joined tables](img/B21998_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 连接的表](img/B21998_08_02.jpg)'
- en: Figure 8.2 – Joined tables
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 连接的表
- en: Note that your table will look a bit different as I’ve cut out the middle to
    make it fit the page.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我为了适应页面而剪掉了中间部分，所以你的表格看起来会有些不同。
- en: You can see that the option values are appended to the **car** rows. This is
    just what we need.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到选项值被附加到 **car** 行上。这正是我们所需要的。
- en: For most applications, this would be sufficient, however, our client has asked
    for the JSON structure shown in the code under the *Implementing an advanced*
    *API* heading.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序来说，这已经足够了，然而，我们的客户要求实现高级 *API* 下的代码中显示的 JSON 结构。
- en: This will be a bit tricky.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有点棘手。
- en: Creating the classes
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建类
- en: 'We need a class to represent the entire row, with the car and the options together.
    Each instance of the class will represent one full row in the table, as shown
    in *Figure 8* *.2* . Let’s call that class **carFlat** :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要一个类来表示整个行，包括汽车和选项。每个类的实例将代表表格中的一行，如图 *图 8* *.2* 所示。让我们称这个类为 **carFlat**
    :'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that **CarFlat** inherits from **Car** , picking up all the properties
    of **Car** and adding the properties of **Options** (along with **car_id** ).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 **CarFlat** 继承自 **Car** ，继承了 **Car** 的所有属性，并添加了 **Options** 的属性（以及 **car_id**
    ）。
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In my programming, I typically use Pascal case (initial cap) for properties.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的编程中，我通常使用帕斯卡大小写（首字母大写）来表示属性。
- en: Now, we need a class to represent the row without the options (representing
    the car) but each car will have a collection of options. Let’s call that class
    **carDto** as it will be our **data transfer object** ( **DTO** ) for the car.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个类来表示没有选项的行（代表汽车），但每辆汽车都将有一组选项。让我们称这个类为 **carDto**，因为它将是我们的汽车 **数据传输对象**
    ( **DTO** )。
- en: We will be passing options around, so let’s create an **OptionsDto** class as
    well.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递选项，因此让我们创建一个 **OptionsDto** 类。
- en: 'Here’s what they look like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来是这样的：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The important thing to note here is that **CarDto** has a property that is
    the list of all this car’s options; notice that the final property is a list of
    **OptionsDtos** . Let’s look at that class now:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是 **CarDto** 有一个属性是所有这些汽车选项的列表；注意最后一个属性是一个 **OptionsDtos** 的列表。现在让我们看看这个类：
- en: 'Here is **OptionsDto** :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '这是 **OptionsDto** :'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice the capitalization and absence of underscores in the DTO.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 DTO 中的大小写和下划线的缺失。
- en: We need a way to link the DTO to the **Car** object. That is what profiles are
    for.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法将 DTO 连接到 **Car** 对象。这正是个人资料的作用。
- en: The profile
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 个人资料
- en: We’ll need a profile to map the various classes to one another. The DTO is used
    to transfer the object (hence the name) but it must be mapped to the original
    object. Thus, we want to map **Car.Dto** to the **Car** class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个个人资料来将不同的类映射到彼此。DTO 用于传输对象（因此得名），但它必须映射到原始对象。因此，我们希望将 **Car.Dto** 映射到
    **Car** 类。
- en: This is the trickiest part, and mapping is what makes this all work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最难的部分，映射是使这一切工作起来的关键。
- en: 'The first map is pretty straightforward, mapping the **Car** to **CarDto**
    :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '第一张映射相当直接，将 **Car** 映射到 **CarDto** :'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We start by identifying the types in the map, and then for each member, we map
    using Lambda expressions. Note the last line, **.ReerseMap** – this saves us the
    trouble of re-writing the entire map going the other way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在地图中识别类型，然后对每个成员使用 Lambda 表达式进行映射。注意最后一行，**.ReverseMap** – 这避免了我们需要重新编写整个映射过程。
- en: 'Next comes the heart of the program, mapping **CarFlat** to **CarDto** and
    mapping **OptionsDto** to **CarFlat** :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来是程序的精髓，将 **CarFlat** 映射到 **CarDto**，并将 **OptionsDto** 映射到 **CarFlat** :'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The magic is performed by AutoMapper. If you have not installed AutoMapper yet,
    this is a good time to do so. AutoMapper will make this job infinitely easier.
    AutoMapper simplifies the mapping process between different object models, reducing
    the need for manual transformations. All we need to do is tell AutoMapper to map
    from one class to another, as shown next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由 AutoMapper 完成的魔法。如果你还没有安装 AutoMapper，现在是安装的好时机。AutoMapper 将使这项工作变得无限简单。AutoMapper
    简化了不同对象模型之间的映射过程，减少了手动转换的需求。我们只需要告诉 AutoMapper 从一个类映射到另一个类，如下所示。
- en: Supporting implementation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持实现
- en: 'With the profile written, we’ll go back to the controller. Here, we’re going
    to map **CarDto** to the car. Notice the next to last line of this code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料编写完成后，我们将回到控制器。在这里，我们将映射 **CarDto** 到汽车。注意这段代码的倒数第二行：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Nothing new or special here, but note that at the bottom of the method, we use
    a mapper to turn our car into a DTO, which is what we return to the client application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新或特别的东西，但请注意，在方法底部，我们使用映射器将我们的汽车转换为DTO，这是我们返回给客户端应用程序的内容。
- en: 'The only logic in **CarService** is to ensure we have a valid car ID:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**CarService**中的唯一逻辑是确保我们有有效的汽车ID：'
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This brings us to the repository:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了存储库：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The method is surprisingly simple. We set up and execute the query. Notice
    that we are using **QueryAsync** and **ToList** as if we were getting all the
    cars. Actually, what we are getting is a list of the options for a single car,
    as shown in the next listing:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方法出奇地简单。我们设置并执行查询。请注意，我们正在使用**QueryAsync**和**ToList**，就像我们正在获取所有汽车一样。实际上，我们得到的是单个汽车的选项列表，如下一节所示：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Beautiful! This should look familiar, as it is what we specified at the beginning
    of the chapter. Each car has its options as a sub-set in the JSON. This will make
    it much easier to display the cars with their options (e.g., on a web page). Tuck
    this in your pocket; you don’t use it often, but when you need to make this kind
    of display, the technique is powerful but not obvious.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 真棒！这应该看起来很熟悉，因为它就是我们在本章开头指定的。每辆车的选项作为JSON中的子集存在。这将使显示带有选项的汽车（例如，在网页上）变得容易得多。把它放在口袋里；你不会经常用到它，但当你需要做这种显示时，这项技术强大但并不明显。
- en: In this next section, we will introduce Azure Storage Tables, a powerful yet
    simple way to store data.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Azure存储表，这是一种强大而简单的数据存储方式。
- en: Azure Storage Tables
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure存储表
- en: '**Storage Tables** are a great way to persist relatively simple data structures.
    Creating and using storage tables is quick and easy.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储表**是持久化相对简单数据结构的好方法。创建和使用存储表既快又简单。'
- en: Azure offers a number of ways to store your data. The most popular are SQL Server,
    Cosmos, and storage tables. Storage tables are the most limited, but they are
    also the simplest generally speaking, and the fastest to create. They are very
    popular for keeping track of simple information. For example, you might use storage
    tables to record each time you send a message or each time something anomalous
    happens. For these examples, you would enter one row per incident, as described
    in the following section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Azure提供了多种存储数据的方式。最受欢迎的是SQL Server、Cosmos和存储表。存储表通常是最有限的，但就一般而言，它们也是最简单的，并且创建速度最快。它们非常适合跟踪简单信息。例如，你可能使用存储表来记录每次发送消息或每次发生异常的情况。对于这些示例，你将按以下章节所述，为每个事件输入一行。
- en: Exploring the essentials
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索基本要素
- en: Storage tables are not inherently relational. While you can index, it isn’t
    simple, and it isn’t particularly powerful. The reason behind all this is to keep
    storage tables simple. This makes them ideal for keeping lists, logging, creating
    progress entries, and so forth.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 存储表本身不是关系型的。虽然你可以进行索引，但这并不简单，也不特别强大。这一切背后的原因是为了保持存储表简单。这使得它们非常适合用于存储列表、记录日志、创建进度条目等。
- en: 'We will create a storage table that tracks exceptions thrown during the execution
    of our program. The table we create will look like this on Azure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个存储表，用于跟踪程序执行过程中抛出的异常。我们在Azure上创建的表将看起来像这样：
- en: '![Figure 8.3 – The left portion of a storage table](img/B21998_08_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 存储表的左侧部分](img/B21998_08_03.jpg)'
- en: Figure 8.3 – The left portion of a storage table
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 存储表的左侧部分
- en: Due to space concerns, I’m not showing the entire table here. There are columns
    for the exception type, the time of the exception, the message, and so forth.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，我这里没有展示整个表。表中包含异常类型、异常时间、消息等列。
- en: 'To keep things as simple as possible, and to focus 100% on Table Storage, we’ll
    create a console application that simply throws exceptions and stores them in
    the table. To get started, follow these steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能保持简单，并专注于100%的表存储，我们将创建一个控制台应用程序，该程序简单地抛出异常并将它们存储在表中。要开始，请按照以下步骤操作：
- en: Create a new project and select **Console App** , as shown in *Figure 8* *.4*
    .
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并选择**控制台应用程序**，如图*图8* *.4* 所示。
- en: '![Figure 8.4 – Selecting console app](img/B21998_08_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 选择控制台应用程序](img/B21998_08_04.jpg)'
- en: Figure 8.4 – Selecting console app
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 选择控制台应用程序
- en: 'Click **Next** and fill in your project name (I used **TableStorageConsoleApp**
    ), its location on your local disk, and the name of the solution (typically the
    same as your project). Click **Next** and select **.NET 8** (or later) and, most
    important, check **Do not use top-level statements** , as shown in the following
    figure:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**并填写你的项目名称（我使用了**TableStorageConsoleApp**），它在本地磁盘上的位置以及解决方案的名称（通常是项目名称相同）。点击**下一步**并选择**.NET
    8**（或更高版本），最重要的是，检查**不要使用顶级语句**，如图所示：
- en: '![Figure 8.5 – Additional information](img/B21998_08_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 其他信息](img/B21998_08_05.jpg)'
- en: Figure 8.5 – Additional information
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 其他信息
- en: Click **Create** and your console app will be created, complete with a main
    entry point and a single line of code, writing the canonical “Hello, World” greeting.
    You can delete that line.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**，你的控制台应用程序将被创建，包括一个主入口点和一行代码，写入标准的“Hello, World”问候语。你可以删除那行代码。
- en: 'To keep things simple, we’ll have **Main** call **ThrowException** , a method
    we’ll write that will throw a random exception every two seconds. Thus, **Main**
    is very simple:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将让**Main**调用**ThrowException**，这是一个我们将编写的每两秒抛出一个随机异常的方法。因此，**Main**非常简单：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see that **ThrowException** is enclosed in a forever loop and will continue
    until you close the program. Putting in a more sophisticated way to stop it is,
    as they say, left as an exercise for the reader.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到**ThrowException**被包含在一个无限循环中，并且会一直持续到你关闭程序为止。用更复杂的方式停止它，正如他们所说，留作读者的练习。
- en: 'The job of **ThrowException** is, as said earlier, to throw exceptions randomly.
    For this, I need nothing more than a **random** generator and a **switch** statement.
    We begin by enclosing the random generation of exceptions within a try statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**ThrowException**的工作，正如之前所说，是随机抛出异常。为此，我需要的只是一个**随机**生成器和**switch**语句。我们首先在try语句中包含随机生成异常：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With that, we can catch each exception and write it to our table:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以捕获每个异常并将其写入我们的表：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There’s quite a bit to see here. We begin by creating **TableModel** . We’ll
    create that data structure in just a moment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多东西可以看。我们首先创建**TableModel**。我们将在稍后创建这个数据结构。
- en: Within that model, we’ll have **PartitionKey** and **RowKey** . These are critical
    to **TableStorage** . Together, they make the unique identifier for each row in
    the table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在该模型中，我们将有**PartitionKey**和**RowKey**。这些对于**TableStorage**至关重要。它们共同构成了表中每行的唯一标识符。
- en: All of the entries with the same **PartitionKey** are clustered, and in that
    cluster are all their **RowKeys** . This makes retrieval infinitely faster. Rather
    than having to scan through all the **RowKeys** , retrieval can be achieved by
    jumping to the right **PartitionKey** and searching from there.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有相同**PartitionKey**的条目都聚集在一起，在那个集群中包含了所有的**RowKeys**。这使得检索变得无限快。而不是必须扫描所有的**RowKeys**，可以通过跳转到正确的**PartitionKey**并从那里搜索来实现检索。
- en: We also store the exception’s message and the current time as a timestamp.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还存储异常的消息和当前时间作为时间戳。
- en: '**TableServiceClient** is supplied by the NuGet package (see requirements at
    the beginning of this chapter). The address you’ll initialize with is supplied
    by Azure as shown later in this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**TableServiceClient**由NuGet包提供（参见本章开头的需求）。你将初始化的地址将在本章后面的部分由Azure提供。'
- en: We then call **UpsertEntityAsync** , passing in the entity we created earlier,
    and go to sleep for two seconds (the amount of time you sleep is entirely up to
    you).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用**UpsertEntityAsync**，传入我们之前创建的实体，然后休眠两秒钟（你休眠的时间完全取决于你）。
- en: Please note that you will need your own **AccountKey** and preferably your own
    **accountName** .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你需要自己的**AccountKey**，最好是自己的**accountName**。
- en: TableModel
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TableModel
- en: 'I promised earlier to show you the **TableModel** . It is quite simple, just
    enough to capture the essential information:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前承诺要向你展示**TableModel**。它相当简单，只足够捕获必要的信息：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that **ETag** must be in every table model. This is used for optimistic
    concurrency during updates. We won’t be doing updates and don’t care about this
    except that it must be there.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**ETag**必须在每个表模型中。这在更新时用于乐观并发。我们不会进行更新，所以我们不关心这一点，除了它必须存在。
- en: StorageTableService
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: StorageTableService
- en: 'The heart of the application is **StorageTableService** . Here is where **UpsertEntityAsync**
    lives, which does the work of interacting with our table:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的核心是**StorageTableService**。这里是**UpsertEntityAsync**所在的地方，它负责与我们的表进行交互：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To get started, we declare two member variables at the top of the class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们在类的顶部声明两个成员变量：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the second member is of type **Task<Response<TableItem>** . Both
    **Response** and **TableItem** are supplied by the Azure NuGet package. The constructor
    takes **TableServiceClient** (also supplied in the same NuGet package).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二个成员是 **Task<Response<TableItem>>** 类型。**Response** 和 **TableItem** 都由 Azure
    NuGet 包提供。构造函数接受 **TableServiceClient**（也由同一 NuGet 包提供）。
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is here that we create the table if it doesn’t exist and name it **ExceptionsTable**
    (feel free to name yours whatever you like).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表不存在，我们在这里创建它，并将其命名为 **ExceptionsTable**（你可以随意命名你的表）。
- en: All the **Upsert** method needs to do is call **tableCreationTask** and wait
    to get back **Response<TableItem>** . With that in hand, it is ready to call **GetTableClient**
    on **TableServiceClient** , passing in the name of the table. Finally, we call
    **UpsertEntityAsync** on the table passing in **TableModel** .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 **Upsert** 方法需要做的就是调用 **tableCreationTask** 并等待返回 **Response<TableItem>**。有了这个，它就可以在
    **TableServiceClient** 上调用 **GetTableClient**，传入表的名称。最后，我们在表上调用 **UpsertEntityAsync**，传入
    **TableModel**。
- en: Please make sure you understand the previous paragraph as it is the heart of
    working with **StorageTables** .
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保你理解上一段内容，因为它是与 **StorageTables** 一起工作的核心。
- en: Populating the table in Azure
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Azure 中填充表
- en: With what we’ve written, populating the table in Azure is automatic. Run the
    program; your output should look something like *Figure 8* *.6* .
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们编写的代码，在 Azure 中填充表是自动的。运行程序；你的输出应该看起来像 *图 8.6*。
- en: '![Figure 8.6 – Generated exceptions](img/B21998_08_06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 生成的异常](img/B21998_08_06.jpg)'
- en: Figure 8.6 – Generated exceptions
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 生成的异常
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need an Azure account for this part. As noted earlier, you can get a
    free starter account at the link provided.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这部分创建一个 Azure 账户。如前所述，你可以在提供的链接中获取一个免费的入门账户。
- en: 'Now, let’s go to Azure and see what we’ve got:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到 Azure 看看我们有什么：
- en: 'Log in to your account and click on **Home** and then on **Storage browser**
    , as shown in the following figure:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的账户，点击 **Home**，然后点击 **存储浏览器**，如图所示：
- en: '![Figure 8.7 – Storage browser](img/B21998_08_07.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 存储浏览器](img/B21998_08_07.jpg)'
- en: Figure 8.7 – Storage browser
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 存储浏览器
- en: From there, click on your **TableStorage** account. That will bring up a dashboard.
    Click on **Tables** , as shown in *Figure 8* *.8* .
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，点击你的 **TableStorage** 账户。这将显示一个仪表板。点击 **Tables**，如图 8.8 所示。
- en: '![Figure 8.8 – Selecting tables](img/B21998_08_08.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 选择表格](img/B21998_08_08.jpg)'
- en: Figure 8.8 – Selecting tables
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 选择表格
- en: You should be brought to a page where your tables should be listed as links.
    Click on the table we created. The entries that match what we saw in the application
    will pop up, as shown (in part) in *Figure 8* *.9* .
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该会被带到一页，你的表应该作为链接列出。点击我们创建的表。与我们看到的应用程序中匹配的条目将弹出，如图 8.9（部分）所示。
- en: '![Figure 8.9 – The table on Azure](img/B21998_08_09.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – Azure 上的表](img/B21998_08_09.jpg)'
- en: Figure 8.9 – The table on Azure
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – Azure 上的表
- en: Notice that the entries are not in the order in which they were created. Rather,
    they are clustered by **PartitionKey** , as described earlier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，条目不是按照它们创建的顺序排列的。相反，它们是按照前面描述的 **PartitionKey** 进行分组的。
- en: Shockingly, that’s all there is to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，就是这样。
- en: Introducing Microsoft Aspire
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Microsoft Aspire
- en: Microsoft has introduced Aspire, which it describes as *opinionated, cloud ready
    stack for building observable, Production-ready, distributed applications.* Say
    what?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 微软推出了 Aspire，它将其描述为 *opinionated, cloud ready stack for building observable,
    Production-ready, distributed applications.* 说的是什么？
- en: In this case, *opinionated* means that there are conventions and templates to
    make life easier. With this and all things, you can customize, but the more you
    follow the conventions, the easier it is to write, and perhaps more important,
    to read your code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*opinionated* 意味着有一些约定和模板可以使生活更轻松。有了这个和所有其他事情，你可以自定义，但遵循约定越多，编写代码就越容易，也许更重要的是，阅读代码也更容易。
- en: '*Cloud-ready stack* indicates that you will be working locally but on code
    that can easily be moved to the cloud (read Azure). *Production-ready* indicates
    that what you build will be non-trivial and ready to roll out, and *distributed*
    means that you will be creating micro-services hosted in containers, in our case,
    Docker.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cloud-ready stack* 指的是你将在本地工作，但代码可以轻松地移动到云端（即 Azure）。*Production-ready* 指的是你构建的内容将非平凡，并准备好部署，而
    *distributed* 意味着你将创建托管在容器中的微服务，在我们的例子中，是 Docker。'
- en: Aspire provides you with a number of services that you could write yourself,
    but no longer have to. Instead, you get fully tested code *automagically* that
    provides, among other things, storage, messaging, and web services, and that can
    also provide interoperability with databases, caching, and more.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Aspire为您提供了一些您可以自己编写的服务，但不再需要。相反，您将获得自动测试的完整代码，它提供了存储、消息传递和Web服务等功能，还可以提供与数据库、缓存等更多功能的互操作性。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can use Aspire with Visual Studio Code or even the .NET CLI, but we’ll stick
    with Visual Studio.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Aspire与Visual Studio Code或.NET CLI一起使用，但我们将坚持使用Visual Studio。
- en: Sample program
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例程序
- en: 'Aspire is very powerful, but it can be tricky to get all the pieces in place.
    We *could* write our own sample program, but that would be silly since Microsoft
    supplies one that you can create with just a few keystrokes in Visual Studio.
    To get started, follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Aspire功能非常强大，但将所有部件放在一起可能会有些棘手。我们*可以*编写自己的示例程序，但那会很愚蠢，因为Microsoft提供了一个只需在Visual
    Studio中按几个键就能创建的程序。要开始，请按照以下步骤操作：
- en: 'Create a new project and select **.NET Aspire Starter Application** . Be sure
    to choose the one for C#, as shown in *Figure 8* *.10* :'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目并选择**.NET Aspire Starter Application**。请确保选择C#版本，如图8.10所示：
- en: '![Figure 8.10 - Choosing Aspire](img/B21998_08_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 - 选择Aspire](img/B21998_08_10.jpg)'
- en: Figure 8.10 - Choosing Aspire
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 选择Aspire
- en: Enter a project name (I’ll use **AspirePackt** ) and leave the rest of the values
    as their defaults.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称（我将使用**AspirePackt**）并保留其余值为其默认值。
- en: 'On the next page, make sure you select **.NET 8** and **Use Redis for caching**
    , and while you always should create unit tests, we’ll skip that for now (in a
    “real” application, you want those unit tests), as shown in *Figure 8* *.11* :'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上，确保您选择了**.NET 8**和**使用Redis进行缓存**，尽管您始终应该创建单元测试，但现在我们将跳过这一步（在“真实”应用程序中，您希望有这些单元测试），如图8.11所示：
- en: '![Figure 8.11 – Selecting the frameworks](img/B21998_08_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 选择框架](img/B21998_08_11.jpg)'
- en: Figure 8.11 – Selecting the frameworks
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 选择框架
- en: 'Here’s what we’re going to see: a sample weather app that supports caching.
    It will get the weather through an API, using random, demonstration values.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要看到的：一个支持缓存的示例天气应用程序。它将通过API获取天气，使用随机演示值。
- en: Start the app up and the first thing that will happen is that the .NET Aspire
    dashboard will open in your browser, as partly shown in *Figure 8* *.12* .
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序后，首先发生的事情是.NET Aspire仪表板将在您的浏览器中打开，部分如图8.12所示。
- en: '![Figure 8.12 – Aspire dashboard](img/B21998_08_12.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – Aspire仪表板](img/B21998_08_12.jpg)'
- en: Figure 8.12 – Aspire dashboard
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – Aspire仪表板
- en: This was all created for you in the sample program, which also created a Blazor
    application that will be used to display the data retrieved by the API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是在示例程序中为您创建的，该程序还创建了一个Blazor应用程序，该应用程序将用于显示通过API检索到的数据。
- en: 'Notice that the third line’s project in *Figure 8* *.13* is **webfrontend**
    . Click on the URL and you are brought to the iconic **Hello, world!** page. On
    the left are three buttons, as shown in the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图8.13中的第三行项目是**webfrontend**。点击URL，您将被带到标志性的**Hello, world!**页面。在左侧有三个按钮，如图下所示：
- en: '![Figure 8.13 – The running application](img/B21998_08_13.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 运行中的应用程序](img/B21998_08_13.jpg)'
- en: Figure 8.13 – The running application
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 运行中的应用程序
- en: Now click on the **Weather** option and *voilà* ! The API is hit, and the weather
    data is displayed, as shown in *Figure 8* *.14* .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击**天气**选项，*voilà*！API被调用，并显示天气数据，如图8.14所示。
- en: '![Figure 8.14 – The displayed weather from the API](img/B21998_08_14.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – API显示的天气](img/B21998_08_14.jpg)'
- en: Figure 8.14 – The displayed weather from the API
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – API显示的天气
- en: If you refresh the screen a few times, you’ll see that it is instantly responsive
    as it is using the cache. After about 10 seconds, it will generate new data.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刷新屏幕几次，您会看到它立即响应，因为它正在使用缓存。大约10秒后，它将生成新的数据。
- en: Exploring the Aspire dashboard
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Aspire仪表板
- en: Going back to *Figure 8* *.12* , we see a number of useful features. Click on
    **Resources** , for example, to see a list of information for all the .NET projects
    in your application. These include the app state, endpoints, and environment variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到图8.12，我们可以看到许多有用的功能。例如，点击**资源**，可以看到应用程序中所有.NET项目的信息列表。这些包括应用程序状态、端点和环境变量。
- en: '**Console** displays (surprise!) the console output from each project.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台**显示（惊喜！）每个项目的控制台输出。'
- en: The **Structured** option displays logs as tables. You can filter and search
    (either free-form or filtered). You can expand the details for each entry by clicking
    on the **View** button on the far right.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化** 选项将日志显示为表格。您可以进行过滤和搜索（无论是自由格式还是过滤）。您可以通过单击最右侧的 **查看** 按钮来展开每个条目的详细信息。'
- en: The **Traces** button displays the request paths throughout your application.
    Locate a request for **Weather** and select **View** . The dashboard will display
    the request in stages.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪** 按钮显示应用程序中的请求路径。定位到 **天气** 的请求并选择 **查看**。仪表板将按阶段显示请求。'
- en: Click on **ApiService | View** and you’ll see the time it took to hit the API.
    Click on **View** on the right and the resources are displayed in detail. Scroll
    down to see more details.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单击 **ApiService | 查看**，您将看到击中 API 所需的时间。单击右侧的 **查看**，将详细显示资源。向下滚动以查看更多详细信息。
- en: Finally, the **Metrics** button will display instruments and meters, as they
    are available for your application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**指标** 按钮将显示仪表和计量器，因为它们适用于您的应用程序。
- en: What have you learned, Dorothy?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么，多萝西？
- en: As you can see, the sample application consists of a number of projects. The
    first, perhaps most essential is the app host, which acts as the orchestrator.
    It will automatically set **IsAspireHost** in the project file to true.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，示例应用程序由多个项目组成。第一个，也许是最重要的，是应用程序宿主，它充当协调器。它将自动将项目文件中的 **IsAspireHost** 设置为
    true。
- en: Pour through the **Program.cs** file and you’ll see what you’d expect as an
    API developer, along with Aspire in **APIService** (and a couple of things added
    for Blazor).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读 **Program.cs** 文件，您将看到作为 API 开发人员所期望的内容，包括在 **APIService**（以及为 Blazor 添加的一些内容）中的
    Aspire。
- en: Note that the first line creates **DistributedApplication** using Docker.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一行使用 Docker 创建了 **DistributedApplication**。
- en: A critical line in this file is **AspirePackt.ApiService** , which configures
    the service discovery and communication among the projects in your solution. The
    name ( **apiservice** ) identifies the project and is used by projects that want
    to communicate with it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的一个关键行是 **AspirePackt.ApiService**，它配置了解决方案中项目之间的服务发现和通信。名称（**apiservice**）标识了项目，并被希望与其通信的项目使用。
- en: Another important and universal project is **ServiceDefaults** , which is a
    shared project that manages configurations so that they can be used across projects.
    This allows the application to have all the services share service discovery,
    telemetry, and more.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要且通用的项目是 **ServiceDefaults**，它是一个共享项目，用于管理配置，以便它们可以在项目之间使用。这使得应用程序能够让所有服务共享服务发现、遥测等。
- en: Adding Aspire to an existing app
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Aspire 添加到现有应用程序
- en: We all love green-field projects, but the reality is that most of the time we’re
    working with existing code. Aspire would not be very interesting if it only worked
    from scratch, but fortunately, you can add Aspire to existing applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都喜欢绿地项目，但现实是，我们大多数时候都在处理现有代码。如果 Aspire 只能从头开始工作，那么它将不会很有趣，但幸运的是，您可以将 Aspire
    添加到现有应用程序中。
- en: 'We could add Aspire to our car application, but once again, Microsoft assists,
    providing a reasonably complex application for us to work with. To get started,
    clone their application by using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Aspire 添加到我们的汽车应用程序中，但又一次，Microsoft 提供了合理的复杂应用程序供我们使用。要开始，请使用以下命令克隆他们的应用程序：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This sample consists of three projects:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例由三个项目组成：
- en: Data Entities is a class library that defines the **Product** class
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据实体是一个类库，它定义了 **产品** 类。
- en: '**Products** is a web API that returns a list of all the Products in the store’s
    catalog'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品** 是一个返回商店目录中所有产品列表的 Web API。'
- en: '**Store** is a Blazor web app that displays the products on a website'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**商店** 是一个 Blazor Web 应用程序，它在一个网站上显示产品。'
- en: Note that we will not be focusing on Blazor. We will use it only as far as it
    is part of this example
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不会专注于 Blazor。我们只会将其作为本例的一部分使用。
- en: Getting oriented with our new project
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉我们的新项目
- en: 'Let’s take a look at what the new project (out of the box) looks like. To do
    so, follow these steps to create our “existing” project that we will add Aspire
    to:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新项目（开箱即用）的样子。为此，请按照以下步骤创建我们的“现有”项目，我们将向其中添加 Aspire：
- en: Open [eShopLite.sln](http://eShopLite.sln) . Right-click on the solution and
    select **Configure** **Startup Projects** .
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [eShopLite.sln](http://eShopLite.sln) 。右键单击解决方案并选择 **配置** **启动项目**。
- en: 'Choose multiple startup projects and in the **Action** column, select **S**
    **tart** for **Products and Store** , as shown in the following figure:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择多个启动项目，并在**操作**列中，选择**启动**为**产品和存储**，如下面的图所示：
- en: '![Figure 8.15 – Setting the startup projects](img/B21998_08_15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 设置启动项目](img/B21998_08_15.jpg)'
- en: Figure 8.15 – Setting the startup projects
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 设置启动项目
- en: Fire it up by pressing *F5* and note that two browser pages open. One page has
    the raw JSON and the second page is a simple browser application that lets you
    view that data (click on **Products** ), as shown in part in *Figure 8* *.15*
    .
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*F5*启动它，并注意两个浏览器页面打开了。一个页面有原始 JSON，第二个页面是一个简单的浏览器应用程序，允许你查看这些数据（点击**产品**），如图
    8.15 部分所示。
- en: '![Figure 8.16 – The raw JSON](img/B21998_08_16.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 原始 JSON](img/B21998_08_16.jpg)'
- en: Figure 8.16 – The raw JSON
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 原始 JSON
- en: 'At the top of the JSON is a checkbox for pretty print. That will take this
    raw JSON and make it more readable, as shown in the following figure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 的顶部有一个用于格式化的复选框。这将使原始 JSON 更易于阅读，如下面的图所示：
- en: '![Figure 8.17 – Pretty print](img/B21998_08_17.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 格式化输出](img/B21998_08_17.jpg)'
- en: Figure 8.17 – Pretty print
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 格式化输出
- en: 'Blazor will give you a web-based view of that same data, as shown in *Figure
    8* *.18* :'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 将为你提供相同数据的基于 Web 的视图，如图 8.18 所示：
- en: '![Figure 8.18 – The browser display of the products](img/B21998_08_18.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – 产品在浏览器中的显示](img/B21998_08_18.jpg)'
- en: Figure 8.18 – The browser display of the products
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 产品在浏览器中的显示
- en: Now that we have a working application, let’s refactor it to add Aspire. We’ll
    do that next.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的应用程序，让我们重构它以添加 Aspire。我们将在下一节这样做。
- en: Adding Aspire
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Aspire
- en: 'Now that we have a working API solution, let’s add Aspire. To do so, follow
    these steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的 API 解决方案，让我们添加 Aspire。为此，请按照以下步骤操作：
- en: Right-click on one of the projects (I’ll use **Store** ) and select **Add**
    | **.Net Aspire Orchestrator Support** . That brings up the dialog box.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击其中一个项目（我将使用**存储**），然后选择**添加** | **.Net Aspire Orchestrator Support**。这将弹出对话框。
- en: 'Click **OK** and two new projects are added to your solution:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**，你的解决方案中会添加两个新项目：
- en: '**eShopLiteAppHost**'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eShopLiteAppHost**'
- en: '**eShopLite.ServiceDefaults**'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eShopLite.ServiceDefaults**'
- en: Spend a few minutes exploring these projects. The first, **eShopLiteAppHost**
    , is an orchestrator project whose job is to connect (and configure) the various
    projects and services of your application. It is automatically set as the startup
    project. **eShopServiceDefaults** holds configurations that will be used across
    projects, especially service discovery and telemetry (more about these shortly).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟探索这些项目。第一个，**eShopLiteAppHost**，是一个编排器项目，其任务是连接（并配置）你的应用程序的各种项目和服务。它自动设置为启动项目。**eShopServiceDefaults**包含将在项目间使用的配置，特别是服务发现和遥测（稍后将详细介绍）。
- en: 'Next, open **Program.cs** in **AppHost** , where you will see this code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**AppHost**中打开**Program.cs**，你将看到以下代码：
- en: '[PRE19]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This registers the store project in the orchestrator. We now need to register
    the **Products** project.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在编排器中注册存储项目。我们现在需要注册**产品**项目。
- en: Right-click on it and select **Add** | **.NET Aspire Orchestrator Support**
    . You’ll get a dialog saying the orchestrator already exists; just click **OK**
    .
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击它，然后选择**添加** | **.NET Aspire Orchestrator Support**。你会得到一个对话框说编排器已经存在；只需点击**确定**。
- en: 'Go back to **AppHost** / **Program.cs** and you can see that another line has
    been added, as you might expect:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**AppHost** / **Program.cs**，你可以看到已经添加了另一行，正如你所预期的：
- en: '[PRE20]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now comes the fun part. **Store** needs to be able to find **Products** ’ backend
    address. Rather than doing this by hand, we turn that responsibility over to the
    orchestrator.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候享受乐趣了。**存储**需要能够找到**产品**的后端地址。我们不是手动这样做，而是将这个责任转交给编排器。
- en: Discovery
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现
- en: 'While both projects are registered with the orchestrator, **Store** needs to
    be able to discover the **Products** ’ backend address. To enable discovery, return
    to **Program.cs** and add a reference to the **Products** project. Your **program.cs**
    file should now look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个项目都已注册到编排器，但**存储**需要能够发现**产品**的后端地址。为了启用发现，返回到**Program.cs**并添加对**产品**项目的引用。你的**program.cs**文件现在应该看起来像这样：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to deploy this application, you’ll need to call **WithExternalHttpEndpoints**
    to make sure it is public to the outside world.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想部署这个应用程序，你需要调用**WithExternalHttpEndpoints**来确保它对外部世界是公开的。
- en: 'Almost done. We need to update **appsettings.json** in the **Store** project:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎完成了。我们需要更新**Store**项目中的**appsettings.json**文件：
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The addresses for both endpoints now use the **Products** name. Note that these
    names are used to discover the address of the **Products** project.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 两个端点的地址现在都使用**产品**名称。请注意，这些名称用于发现**产品**项目的地址。
- en: Press *F5* to run it. You’ve added Aspire, with all its features and dashboard,
    to your existing API project.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 按*F5*键运行它。你已经将Aspire及其所有功能和仪表板添加到了现有的API项目中。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about three very powerful, advanced techniques.
    First, we looked at creating more complex APIs that return hierarchical data.
    We did this by adding and presenting options for each car type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了三种非常强大、高级的技术。首先，我们研究了创建更复杂的API，这些API返回层次化数据。我们通过为每种车型添加和展示选项来实现这一点。
- en: Next, we looked at Azure Storage Tables, a lightweight way to store data on
    Azure, side-stepping the complexity of Entity Framework and Cosmos.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了Azure存储表，这是一种在Azure上存储数据的轻量级方式，绕过了Entity Framework和Cosmos的复杂性。
- en: Finally, we went on to look at Microsoft’s Aspire dashboard, a very powerful
    and useful tool for working with APIs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转向查看微软的Aspire仪表板，这是一个用于处理API的非常强大且有用的工具。
- en: In the next chapter, we’ll look at the critical issue of authentication and
    authorization, without which you cannot create an enterprise API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨认证和授权这一关键问题，没有这些，你无法创建企业级API。
- en: You try it
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: 'Creating an Aspire dashboard is pretty straightforward out of the box, but
    creating hierarchical data is not. To take on a challenge, create a program that
    displays a few states and with them their principal cities. The result might look
    something like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Aspire仪表板开箱即用非常简单，但创建层次化数据则不然。为了接受挑战，创建一个显示几个州及其首府的程序。结果可能看起来像这样：
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Feel free to make up the longitude and latitude, or look it up online. You’ll
    want at least two to three cities and two to three states. Once you have your
    structure, save it as a flat file in an Azure Storage Table.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随意设定经纬度，或者在网上查找。你需要至少两个到三个城市和两个到三个州。一旦你有你的结构，将其保存为平面文件在Azure存储表中。
