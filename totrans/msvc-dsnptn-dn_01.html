<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Introduction to Microservices – the Big Picture</h1>
<p>Microservices are being featured in every avenue of software development. Microservices are a software development style that has been touted to increase development speed and efficiency while improving software scalability and delivery. This development technique is not unique to any stack and has become extremely popular in Java, .NET, and JavaScript (Node JS) development. While the use of microservices is seen as a pattern, there are several subpatterns that are employed to ensure that the code base is as effective as possible.</p>
<p>This chapter is the first of this 15-chapter book, which will cover design patterns used in microservices. We will be focusing on implementing them using the .NET Core development stack, and you will learn how code can be written and deployed. You will learn about design and coding patterns, third-party tools and environments, and best practices for handling certain scenarios in application development with microservices.</p>
<p>In this chapter, we are going to cover the following topics:</p>
<ul>
<li>A deep dive into microservices and its key elements</li>
<li>Assessing the business need for microservices</li>
<li>Determining the feasibility of implementing microservices</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>A deep dive into microservices and its key elements</h1>
<p>Traditionally, in <a id="_idIndexMarker000"/>software<a id="_idIndexMarker001"/> development, applications have developed as a single unit or <em class="italic">monolith</em>. All of the components are tightly coupled, and a change to one component threatens to have rippling effects throughout the code base and functionality. This makes long-term maintenance a major concern and can hinder developers from rolling out updates quickly.</p>
<p>Microservices will have you assess that monolith, break it into smaller and more perceivable applications. Each application will relate to a subsection of the larger project, which is a called <em class="italic">domain</em>. We will then develop and maintain the code base per application as independent units. Typically, microservices are developed as APIs and may or may not interact with each other to complete operations being carried by users through a unifying user interface. Typically, the microservice architecture comprises a suite of small independent services, which communicate via <strong class="bold">HTTP</strong> (<strong class="bold">REST APIs</strong>) or <strong class="bold">gRPC</strong> (<strong class="bold">Google Remote Procedure Call</strong>). The <a id="_idIndexMarker002"/>general notion is that each microservice<a id="_idIndexMarker003"/> is <a id="_idIndexMarker004"/>autonomous, has a limited scope, and aids in a collectively loosely coupled application.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Building a monolith</h2>
<p>Let’s imagine <a id="_idIndexMarker005"/>that we need to build a health facility management web application. We need to manage customer information, book appointments, generate invoices, and deliver test results to customers. If we were to itemize all the steps needed to build such an application, key development and scoping activities would include the following:</p>
<ol>
<li>Model the application, and scope the requirements for our customer onboarding, user profiles, and basic documents.</li>
<li>Scope the requirements surrounding the process of booking an appointment with a particular doctor. Doctors have schedules and specialties, so we have to present the booking slots accordingly.</li>
<li>Create a process flow for when a match is found between a customer and a doctor. Once a match is found, we need to do the following:<ol><li>Book the doctor’s calendar slot</li><li>Generate an invoice</li><li>Potentially collect a payment for the visit</li><li>Send email notifications to the customer, doctor, and other relevant personnel</li></ol></li>
<li>Model a database (probably relational) to store all this information.</li>
<li>Create user interfaces for each screen that both customers and the medical staff will use.</li>
</ol>
<p>All of this is developed as one application, with one frontend talking to one backend, one database, and one deployment environment. Additionally, we might throw in a few third-party API integrations for payment and email services. This can be load balanced and hosted across multiple servers to mitigate against downtime and increase responsiveness:</p>
<div><div><img alt="Figure 1.1 – Application building" src="img/Figure_1.1_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Application building</p>
<p>However, this<a id="_idIndexMarker006"/> monolithic architecture introduces a few challenges:</p>
<ul>
<li>Attempts to extend functionality might have ripple effects through multiple modules and introduce new database and security needs.</li>
</ul>
<p><em class="italic">Potential solution</em>: Perform thorough unit and integration testing.</p>
<ul>
<li>The development team runs the risk of becoming very dependent on a particular stack, making it more difficult to keep the code base modern.</li>
</ul>
<p><em class="italic">Potential solution</em>: Implement proper versioning strategies and increment them as the technology changes.</p>
<ul>
<li>As the code base expands, it becomes more difficult to account for all of the moving parts.</li>
</ul>
<p><em class="italic">Potential solution</em>: Use <a id="_idIndexMarker007"/>clean architectural methods to keep the code base loosely coupled and modular.</p>
<p>The reality is that we can overcome some of these challenges with certain architectural decisions. This all-in-one architecture has been the de facto standard, and frankly, it works. This project<a id="_idIndexMarker008"/> architecture is simple, easy enough to scope and develop, and is supported by most, if not all, development stacks and databases. We have been building them for so long that perhaps we have become oblivious to the real challenges that prevail as we try to extend and maintain them in the long term.</p>
<p><em class="italic">Figure 1.2</em> shows the typical architecture of a monolithic application:</p>
<div><div><img alt="Figure 1.2 – One user interface is served by an API or code library with business logic and is serviced by one database" src="img/Figure_1.2_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – One user interface is served by an API or code library with business logic and is serviced by one database</p>
<p>Now that we have <a id="_idIndexMarker009"/>explored the monolithic approach and its potential flaws, let us review a similar application built using microservices.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Building microservices</h2>
<p>Now, let us<a id="_idIndexMarker010"/> take the same application and conceptualize how it could be architected using microservices. During the design phase, we seek to identify the specific functionalities for each tranche of the application. This is where we identify our domains and subdomains; then, we begin to scope standalone services for each. For example, one domain could be customer management. This service will solely handle the user account and demographic information. Additionally, we could scope bookings and appointments, document management, and finally, payments. This then brings another issue to the foreground: we have dependencies between these three subdomains when we need service independence instead. Using <em class="italic">domain-driven design</em>, we then scope out where there are dependencies and identify where we might need to duplicate certain entities. For instance, a customer needs representation in the booking and appointments database as well as payments. This duplication is required if we are using separate databases per service (which is strongly encouraged).</p>
<p>The microservices require us to properly scope the flow of operations <a id="_idIndexMarker011"/>that involve multiple services playing a part. For instance, when making a booking, we need to do the following:</p>
<ol>
<li value="6">Retrieve the customer making the booking.</li>
<li>Ensure that the preferred time slot is available.</li>
<li>If available, generate an invoice.</li>
<li>Collect the payment.</li>
<li>Confirm the appointment.</li>
</ol>
<p>That process alone has some back-and-forth processing between the services. Properly orchestrating these <em class="italic">service conversations</em> is very critical to having a seamless system and adequately replacing a monolithic approach. Therefore, we introduce various design patterns and approaches to implementing our code and infrastructure. Even though we break potentially complex operations and workflows into smaller and more perceivable chunks, we end up in the same position where the application needs to carry out a specific operation and carry out the original requirements as a whole.</p>
<p><em class="italic">Figure 1.3</em> shows the typical architecture of a microservices application:</p>
<div><div><img alt="Figure 1.3 – Each microservice is standalone and unifies in a single user interface for user interactions" src="img/Figure_1.3_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Each microservice is standalone and unifies in a single user interface for user interactions</p>
<p>Now that you are <a id="_idIndexMarker012"/>familiar with the differences between the monolithic and microservices approaches, we can explore the pros and cons of using the microservices design pattern.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Assessing the business need for microservices</h1>
<p>As we have seen<a id="_idIndexMarker013"/> so far, microservices are not easy to author, and they come with many cross-cutting concerns and challenges. It is always important to ask yourself <em class="italic">Why?</em> and <em class="italic">Do I really need it?</em> before implementing any design patterns.</p>
<p>At a high level, some benefits of this approach are listed as follows:</p>
<ul>
<li>Scalability</li>
<li>Availability</li>
<li>Development speed</li>
<li>Improved data storage</li>
<li>Monitoring</li>
<li>Deployment</li>
</ul>
<p>In the following sections, we will dive into the details of each.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Scalability</h2>
<p>In the monolithic <a id="_idIndexMarker014"/>approach, you scale all or nothing. In microservices, it is easier to scale individual parts of the application and address specific performance gaps as they arise. If a vaccine becomes widely available and customers are encouraged to book an appointment online, then we are sure to experience a large load during the first few weeks. Our customer microservice might not be too affected by that, but we will need to scale our booking and appointments and payments services.</p>
<p>We can scale horizontally, which means that we can allocate more CPU and RAM when the load increases. Alternatively, we can scale vertically by spawning more instances of the service to be load balanced. The better method is relative to the service’s needs. Using the right hosting platforms and infrastructure allows us to automate this process.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Availability</h2>
<p>Availability means the <a id="_idIndexMarker015"/>probability of a system being operational at a given time. This metric goes hand in hand with the ability to scale, but it also addresses the reliability of the underlying code base and hosting platform. The code base plays a big part in that, so we want to avoid, as much as possible, a single point of failure. A single point of failure affects the entire system if it fails at any point. For example, we will be <a id="_idIndexMarker016"/>exploring the <em class="italic">gateway pattern</em>, where we will aggregate all services behind one point of entry. For our distributed services to remain available, this gateway must be always online.</p>
<p>This can be achieved by having vertical instances that balance the load and distribute the expected <a id="_idIndexMarker017"/>responsiveness of the gateway and, by extension, the underlying services.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Development speed</h2>
<p>Given that the <a id="_idIndexMarker018"/>application has been broken into domains, developers can focus their efforts on ensuring that their set of features is being developed efficiently. This also contributes to how quickly features can be added, tested, and deployed. It will now become a practical approach to have one team per subdomain. Additionally, it becomes much easier to scope the requirements for a domain and focus on fewer functional requirements for a piece of work. Each team can now be independent and own the service from development to deployment.</p>
<p>This allows <em class="italic">Agile and DevOps</em> methodologies to be easier to implement, and it is easier to scope resource requirements per team. Of course, we have seen that services will still need to communicate, so we will still have to orchestrate the integration between the teams. So, while each team is independent, they will still need to make their code and documentation available and easy enough to access. Version control also becomes important since the services will be updated over time, but this must be a managed process.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Improved data storage</h2>
<p>Our monolithic <a id="_idIndexMarker019"/>application uses one database for the entire application. There are situations where you might end up using one database for multiple microservices, but this is generally discouraged, and <a id="_idIndexMarker020"/>a <em class="italic">database-per-service</em> approach is preferred. Services must be autonomous and independently developed, deployed, and scaled. This is best accomplished if each service has its own data storage. It makes even more sense when you consider that the type of data being stored might influence the type of data storage that is used. Each service might require a different type of data store, ranging from relational database <a id="_idIndexMarker021"/>storage such as <strong class="bold">Microsoft SQL Server</strong> to document-based database storage such as <strong class="bold">Azure Cosmos DB</strong>. We <a id="_idIndexMarker022"/>want to ensure that changes to a data store will only affect the associated microservice.</p>
<p>Of course, this will bring its own challenges where data will need to be synchronized across the services. In the monolith, we could wrap all steps inside one transaction, which might lead to performance issues for potentially long-running processes. With microservices, we face the challenge of orchestrating distributed transactions, which also introduces performance risks and threatens the immediate consistency of our data. At this point, we must turn to the<a id="_idIndexMarker023"/> concept of <em class="italic">eventual consistency</em>. This means that a service publishes an event when its data changes and subscribing services use that event as a signal to update their own data. This approach is made possible through event-sourcing patterns. We accept the risk that, for a period, data might be inconsistent across subdomains. Message<a id="_idIndexMarker024"/> queue <a id="_idIndexMarker025"/>systems<a id="_idIndexMarker026"/> such as <strong class="bold">Kafka</strong>, <strong class="bold">RabbitMQ</strong>, and <strong class="bold">Azure Service Bus</strong> are<a id="_idIndexMarker027"/> generally used to accomplish this.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Monitoring</h2>
<p>One of the most important <a id="_idIndexMarker028"/>aspects of a distributed system is monitoring. This allows us to proactively ensure uptime and mitigate against failures. We need to be able to view the health of our service instances. We also begin to think about how we can centralize logs and performance metrics in a unified manner, sparing us the task of going to each environment manually. Tools <a id="_idIndexMarker029"/>such<a id="_idIndexMarker030"/> as <strong class="bold">Kibana</strong>, <strong class="bold">Grafana</strong>, or <strong class="bold">Splunk</strong> allow us to<a id="_idIndexMarker031"/> create a rich dashboard and visualize all sorts of information about our services.</p>
<p>One very important bit of information is a <em class="italic">health check</em>. Sometimes, a microservice instance can be running but is failing to handle requests. For example, it might have run out of database connections. With health checks, we can see a quick snapshot of the service’s health and have that data point returned to the dashboard.</p>
<p>Logging is also a crucial tool for monitoring and troubleshooting. Typically, each microservice would write its own logs to files in its environment. From these logs, we can see information about errors, warnings, information, and debug messages. However, this is not efficient for a distributed system. At this point, we use a log aggregator. This gives us a central area to search and analyze the logs from the dashboards. There are a few log aggregators you<a id="_idIndexMarker032"/> can <a id="_idIndexMarker033"/>choose from such as <strong class="bold">LogStash</strong>, <strong class="bold">Splunk</strong>, or <strong class="bold">PaperTrail</strong>.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Deployment</h2>
<p>Each microservice <a id="_idIndexMarker034"/>needs to be independently deployable and scalable. This includes all the security, data storage, and additional assets that our services use. They must all live on physical or virtual servers, whether on-premises or in the cloud. Ideally, each physical server will have its own memory, network, processing, and storage. A virtual infrastructure might have the same physical server with the appropriate resource allocations per service. Here, the idea is that each microservice instance is isolated from the other and will not compete for resources.</p>
<p>Now, each microservice will need its own set of packages and supporting libraries. This then becomes another challenge when provisioning different machines (physical or virtual) and their operating systems. We then seek to simplify this by packaging each microservice as a container image and deploying it as a container. The container will then encapsulate the details of the technology used to build a service and provide all the CPU, memory, and microservice dependencies needed for operation. This makes the microservice easy to move between testing and production environments and provides environment consistency.</p>
<p><strong class="bold">Docker</strong> is the <a id="_idIndexMarker035"/>go-to container management system and works hand in hand with container orchestration services. Orchestration becomes necessary to run multiple containers across multiple machines. We need to start the correct containers at the correct time, handle storage considerations, and address potential container failures. All of these tasks are not practical to handle manually, so we enlist the services of <strong class="bold">Kubernetes</strong>, <strong class="bold">Docker Swarm</strong>, and <strong class="bold">Marathon</strong> to automate these tasks. It is best to have all<a id="_idIndexMarker036"/> the <a id="_idIndexMarker037"/>deployment <a id="_idIndexMarker038"/>steps automated and be as cost-effective as possible.</p>
<p>Then, we look to implement an integrated pipeline that can handle the continuous delivery of our services, with as minimal effort as possible, while maintaining the highest level of consistency possible.</p>
<p>We have explored quite a bit in this section. We reviewed why we might consider using a microservices approach in our development efforts. Also, we investigated some of the most used technologies for this approach. Now, let us turn our attention to justifying our use of microservices.</p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Determining the feasibility of implementing microservices</h1>
<p>As we explore<a id="_idIndexMarker039"/> the microservices approach, we see where it does address certain things, while introducing a few more concerns. The microservices approach is certainly not a savior for your architectural challenges, and it introduces quite a few complexities. These concerns and complexities are generally addressed using design patterns, and using these patterns can save time and energy.</p>
<p>Throughout this book, we will explore the most common problems we face and look at the design pattern concepts that help us to address these concerns. These patterns can be categorized as follows.</p>
<p>Let us explore what each <a id="_idIndexMarker040"/>pattern entails:</p>
<ul>
<li><strong class="bold">Integration patterns</strong>: We have <a id="_idIndexMarker041"/>already discussed that microservices will need to communicate. Integration patterns serve to bring consistency to how we accomplish this. Integration patterns govern the technology and techniques that we use to accomplish cross-service communications.</li>
<li><strong class="bold">Database and storage design patterns</strong>: We know that we are in for a challenge <a id="_idIndexMarker042"/>when it comes to managing data across our <a id="_idIndexMarker043"/>distributed services. Giving each service its own database seems easy until we need to ensure that data is kept consistent across the different data stores. There are certain patterns that are pivotal to us maintaining a level of confidence in what we see after each operation.</li>
<li><strong class="bold">Resiliency, security, and infrastructure patterns</strong>: These patterns seek to bring<a id="_idIndexMarker044"/> calm <a id="_idIndexMarker045"/>and <a id="_idIndexMarker046"/>comfort to a brewing storm. With all the moving parts that we have identified, it is important to ensure that as many things as possible are automated and consistent in the deployment. Additionally, we want to ensure that security is adequately balanced between the system needs and a good user experience. These patterns help us to ensure that our systems are always performing at peak efficiency.</li>
</ul>
<p>Next, let us discuss using .NET Core as our development stack for microservices.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Microservices and .NET Core</h2>
<p>This book<a id="_idIndexMarker047"/> addresses implementing <a id="_idIndexMarker048"/>microservices and design patterns using .NET Core. We have mentioned that this architectural style is platform agnostic and has been implemented using several frameworks. Comparably, however, ASP.NET Core makes microservices development very easy and offers many benefits, including cloud integrations, rapid development, and cross-platform support:</p>
<ul>
<li><code>dotnet new webapi</code> on your computer. If you prefer the fully powered Visual Studio IDE, then you might be limited to Windows and macOS. You will have all the tools you need to be successful regardless of the operating system.</li>
<li><strong class="bold">Stability</strong>: At the time of writing this book, the latest stable version is <em class="italic">.NET 7</em>, with standard term support. The .NET development team is always pushing the envelope and ensuring that reverse compatibility is maintained with each major version release. This makes updating to the next version much less difficult, and you need not worry about too many breaking changes all at once.</li>
<li><strong class="bold">Containerization and scaling</strong>: ASP.NET Core applications can easily be mounted on a <em class="italic">Docker</em> container, and while this is not necessarily new, we can all appreciate a guaranteed render speed and quality. We can also leverage Kubernetes and easily scale our microservices using all the features of K8s.</li>
</ul>
<p>.NET development<a id="_idIndexMarker051"/> has come a long way, and<a id="_idIndexMarker052"/> these are exciting times to push the boundaries of what we can build, using their tools and services.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Summary</h1>
<p>By now, I hope you have a better idea of what microservices are, why you may or may not end up using this architectural style, and the importance of using design patterns. In each of the chapters of this book, we will explore how to use design patterns to develop a <em class="italic">solid</em> and reliable system based on microservices, using .NET Core and various supporting technologies.</p>
<p>We will remain realistic and explore the pros and cons of each of our design decisions and explore how various technologies play integral parts in helping us to tie it all together.</p>
<p>In this chapter, we explored the differences between designing a monolith and microservices, assessed the feasibility of building microservices, and explored why .NET Core is an excellent choice for building microservices</p>
<p>In the next chapter, we will look at implementing the <strong class="bold">Aggregator Pattern</strong> in our microservices application.</p>
</div>
</body></html>