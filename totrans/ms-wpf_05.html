<html><head></head><body>
        

                            
                    <h1 class="header-title">Using the Right Controls for the Job</h1>
                
            
            
                
<p>In this chapter, we'll first consider the existing controls that <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) offers us and look at how we can use them to create the layouts that we require. We'll investigate the many ways that we can modify these controls to avoid the need to create new controls.</p>
<p>We'll examine the various levels of functionality that are built into the existing controls and then discover how to best declare our own controls when required. We'll take an in-depth look at the various options that we have and determine when it's best to use each one. Let's jump straight in and take a look at the various layout controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Investigating the built-in controls</h1>
                
            
            
                
<p>There is a wide range of controls included in .NET Framework. They cover most common scenarios and it is rare that we will need to create our own controls in a typical form-based application. All of the UI controls tend to have their functionality built up from a large number of common base classes.</p>
<p>All controls will share the same core-level base classes that provide the core-level functionalities and then a number of derived framework-level classes that provide the functionality that is associated with the WPF Framework, such as data binding, styling, and templating. Let's take a look at an example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Inheriting framework abilities</h1>
                
            
            
                
<p>As with the base classes in our application framework, the built-in WPF controls also have an inheritance hierarchy, with each successive base class offering some additional functionality. Let's look at the <kbd>Button</kbd> class as an example. Here is the inheritance hierarchy of the <kbd>Button</kbd> control:</p>
<pre>System.Object 
  System.Windows.Threading.DispatcherObject 
    System.Windows.DependencyObject 
      System.Windows.Media.Visual 
        System.Windows.UIElement 
          System.Windows.FrameworkElement 
            System.Windows.Controls.Control 
              System.Windows.Controls.ContentControl 
                System.Windows.Controls.Primitives.ButtonBase 
                  System.Windows.Controls.Button </pre>
<p>As with every object in .NET Framework, we start with the <kbd>Object</kbd> class, which provides low-level services to all classes. These include object comparison, finalization, and the ability to output a customizable <kbd>string</kbd> representation of each object.</p>
<p>Next is the <kbd>DispatcherObject</kbd> class, which provides each object with thread affinity and associates them with a <kbd>Dispatcher</kbd> object. The <kbd>Dispatcher</kbd> class manages a prioritized queue of work items for individual threads. Only the thread that the associated <kbd>Dispatcher</kbd> object was created on can access each <kbd>DispatcherObject</kbd> directly and this enables derived classes to enforce thread safety.</p>
<p>After the <kbd>DispatcherObject</kbd> class, we have the <kbd>DependencyObject</kbd> class, which enables all derived classes to use the WPF property system and declare Dependency Properties. The <kbd>GetValue</kbd> and <kbd>SetValue</kbd> methods that we call to access and set their values are also provided by the <kbd>DependencyObject</kbd> class.</p>
<p>Next up is the <kbd>Visual</kbd> class, which has the primary role of providing rendering support. All elements that are displayed in the UI will extend the <kbd>Visual</kbd> class. In addition to rendering each object, it also calculates their bounding box and provides support for hit testing, clipping, and transformations.</p>
<p>Extending the <kbd>Visual</kbd> class is the <kbd>UIElement</kbd> class, which provides a number of core services to all of its derived classes. These include the event and user input systems and the ability to determine the element's layout appearance and rendering behavior.</p>
<p>Following on from that is the <kbd>FrameworkElement</kbd> class, which provides the first framework-level members, building upon the foundation of the core-level classes that it extends. It is the <kbd>FrameworkElement</kbd> class that enables data binding through the <kbd>DataContext</kbd> property and styling through the <kbd>Style</kbd> property.</p>
<p>It also provides events that relate to an object's lifetime, an upgrade of the core-level layout system to a full layout system and improved support for animations, among other things. This is typically the lowest-level class that we might want to extend if we were creating our own basic elements, as it enables derived classes to partake in the majority of the WPF UI capabilities.</p>
<p>The <kbd>Control</kbd> class extends the <kbd>FrameworkElement</kbd> class and is the base class for most of the WPF UI elements. It provides appearance templating through the use of its <kbd>ControlTemplate</kbd> functionality and a host of appearance-related properties. These include coloring properties, such as <kbd>Background</kbd>, <kbd>Foreground</kbd>, and <kbd>BorderBrush</kbd>, along with alignment and typeface properties.</p>
<p>Extending the <kbd>Control</kbd> class is the <kbd>ContentControl</kbd> class, which enables controls to have one object of any CLR type as its content. This means that we can either set data objects or UI elements as the content, although we may need to provide a <kbd>DataTemplate</kbd> for the data objects if they are of a custom type.</p>
<p>The final class in the long line of parent classes that the <kbd>Button</kbd> class extends is the <kbd>ButtonBase</kbd> class. In fact, this is the base class for all buttons in WPF and it adds useful functionality for buttons. This includes automatically converting certain keyboard events to mouse events, so that users can interact with the buttons without using a mouse.</p>
<p>The <kbd>Button</kbd> class itself adds little to its inherited members with only three related <kbd>bool</kbd> properties; two that specify whether a button is the default button and one that specifies whether the button is a cancel button. We'll see an example of this shortly. It has an additional two protected overridden methods that get called when the button is clicked or when an automation peer is created for it.</p>
<p>While WPF enables us to modify existing controls to such a degree that we rarely need to create our own, it is important to be aware of this inheritance hierarchy so that we can extend the appropriate and most lightweight base class that fulfills our requirements when we need to.</p>
<p> </p>
<p>For example, if we wanted to create our own custom button, it would typically make more sense to extend the <kbd>ButtonBase</kbd> class, rather than the <kbd>Button</kbd> class, and if we wanted to create a totally unique control, we could extend the <kbd>FrameworkElement</kbd> class. Now that we have a good understanding of the make-up of the available controls, let's see how they are displayed by the WPF layout system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Laying it on the line</h1>
                
            
            
                
<p>In WPF, the layout system is responsible for attaining the sizes of each element to be displayed, positioning them on screen, and then drawing them. As controls can be contained within other controls, the layout system works recursively, with each child control's overall position being determined by the position of its parent panel control.</p>
<p>The layout system first measures each child in each panel in what is known as a measure pass. During this pass, each panel calls the <kbd>Measure</kbd> method of each child element and they specify how much space they would ideally like to have; this determines the <kbd>UIElement.DesiredSize</kbd> property value. Note that this is not necessarily how much space they will be given.</p>
<p>After the measure pass comes the arrange pass, when each panel calls the <kbd>Arrange</kbd> method of each child element. During this pass, the panels generate the bounding boxes of each of their child elements, dependent upon their <kbd>DesiredSize</kbd> values. The layout system will adjust these sizes to add any required margins or additional adjustments that may be needed.</p>
<p>It returns a value to the input parameter of the panels' <kbd>ArrangeOverride</kbd> method and each panel performs its own specific layout behavior before returning the possibly adjusted value. The layout system performs any remaining required adjustments before returning execution to the panel and completing the layout process.</p>
<p>We need to be careful when developing our applications to ensure that we do not unnecessarily trigger additional passes of the layout system, as this can lead to poor performance. This can occur when adding or removing items in a collection, applying transforms on the elements, or by calling the <kbd>UIElement.UpdateLayout</kbd> method, which forces a new layout pass.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Containing controls</h1>
                
            
            
                
<p>The existing controls can mostly be split into two main categories: those that provide layout support for other controls and those that make up the visible UI, and are arranged in it by the first category of controls. The first category of controls are of course panels and they provide a variety of ways to arrange their child controls in the UI.</p>
<p>Some provide resizing capabilities, while others don't, and some are more efficient than others, so it's important to use the right panel for the job at hand. Additionally, different panels offer different layout behaviors, so it is good to know what the available panels are and what they each offer us in terms of layout.</p>
<p>All panels extend the abstract <kbd>Panel</kbd> class, and that extends the <kbd>FrameworkElement</kbd> class so it has all of the members and functionality of that class. However, it doesn't extend the <kbd>Control</kbd> class and so it cannot inherit its properties. It therefore adds its own <kbd>Background</kbd> property to enable users to color the gaps between the panel's various items.</p>
<p>The <kbd>Panel</kbd> class also provides a <kbd>Children</kbd> property that represents the items in each panel, although we do not typically interact with this property unless creating a custom panel. Instead, we can populate this collection by simply declaring our child elements directly within the panel element in XAML.</p>
<p>We are able to do this because the <kbd>Panel</kbd> class specifies the <kbd>Children</kbd> property in a <kbd>ContentPropertyAttribute</kbd> attribute in its class definition. While the <kbd>Content</kbd> property of a <kbd>ContentControl</kbd> normally enables us to add a single item of content, we are able to add multiple items into panels because their <kbd>Children</kbd> property, which is set as the content, is a collection.</p>
<p>Another <kbd>Panel</kbd> class property that we might need to use is the <kbd>IsItemsHost</kbd> property, which specifies whether a panel is to be used as a container for the items of an <kbd>ItemsControl</kbd> element, or not. The default value is <kbd>false</kbd>, so it makes no sense to explicitly set this property to <kbd>false</kbd>. In fact, it is only ever required in a very particular situation.</p>
<p>That situation is when we are replacing the default panel of an <kbd>ItemsControl</kbd>, or one of its derived classes, such as a <kbd>ListBox</kbd>, in a <kbd>ControlTemplate</kbd>. By setting this property to <kbd>true</kbd> on a panel element in a <kbd>ControlTemplate</kbd>, we are telling WPF to place the generated collection elements in the panel. Let's see a quick example of this:</p>
<pre>&lt;ItemsControl ItemsSource="{Binding Users}"&gt; 
  &lt;ItemsControl.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type ItemsControl}"&gt; 
      &lt;StackPanel Orientation="Horizontal" IsItemsHost="True" /&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/ItemsControl.Template&gt; 
&lt;/ItemsControl&gt; </pre>
<p>In this simple example, we are replacing the default internal items panel of the <kbd>ItemsControl</kbd> element with a horizontal <kbd>StackPanel</kbd>. Note that this is a permanent replacement and no one can make further changes to this without providing a new <kbd>ControlTemplate</kbd>. There is however a far easier way to achieve the same result and we saw an example of this in <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>:</p>
<pre>&lt;ItemsControl ItemsSource="{Binding Users}"&gt; 
  &lt;ItemsControl.ItemsPanel&gt; 
    &lt;ItemsPanelTemplate&gt; 
      &lt;StackPanel Orientation="Horizontal" /&gt; 
    &lt;/ItemsPanelTemplate&gt; 
  &lt;/ItemsControl.ItemsPanel&gt; 
&lt;/ItemsControl&gt; </pre>
<p>In this alternative example, we simply provide a new <kbd>ItemsPanelTemplate</kbd> for the <kbd>ItemsControl</kbd> through its <kbd>ItemsPanel</kbd> property. Using this code, the internal panel can still be easily changed without the need to provide a new <kbd>ControlTemplate</kbd> and so when we don't want other users to be able to swap out the inner panel, we use the first method, otherwise, we use this method.</p>
<p>The <kbd>Panel</kbd> class also declares a <kbd>ZIndex</kbd> Attached Property, which can be used by child elements to specify a layered order within the panel. Child elements with higher values will appear above, or in front of, elements with lower values, although this property is ignored in panels that do not overlap their children. We'll see an example of this in the next section, so let's now focus on the panels that derive from the <kbd>Panel</kbd> class and what they offer us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Canvas</h1>
                
            
            
                
<p>The <kbd>Canvas</kbd> class enables us to explicitly position child elements using combinations of the <kbd>Canvas.Top</kbd>, <kbd>Canvas.Left</kbd>, <kbd>Canvas.Bottom</kbd>, and <kbd>Canvas.Right</kbd> Attached Properties. This is vaguely similar to the old Windows Forms system of control placement.</p>
<p>However, when using WPF, we don't typically layout UI controls in a <kbd>Canvas</kbd>. Instead, we tend to use them more for displaying shapes, constructing graphs, showing animations, or drawing applications. Take the following example:</p>
<pre>&lt;Canvas Width="256" Height="109" Background="Black"&gt; 
  &lt;Canvas.Resources&gt; 
    &lt;Style TargetType="{x:Type Ellipse}"&gt; 
      &lt;Setter Property="Width" Value="50" /&gt; 
      &lt;Setter Property="Height" Value="50" /&gt; 
      &lt;Setter Property="Stroke" Value="Black" /&gt; 
      &lt;Setter Property="StrokeThickness" Value="3" /&gt; 
    &lt;/Style&gt; 
  &lt;/Canvas.Resources&gt; 
  &lt;Canvas Canvas.Left="3" Canvas.Top="3" Background="Orange" 
    Width="123.5" Height="50"&gt; 
    &lt;Ellipse Canvas.Top="25" Canvas.Left="25" Fill="Cyan" /&gt; 
  &lt;/Canvas&gt; 
  &lt;Canvas Canvas.Left="129.5" Canvas.Top="3" Background="Orange"  
    Width="123.5" Height="50" Panel.ZIndex="1" /&gt; 
  &lt;Canvas Canvas.Left="3" Canvas.Top="56" Background="Red" Width="250"  
    Height="50" ClipToBounds="True"&gt; 
    &lt;Ellipse Canvas.Top="-25" Canvas.Left="175" Fill="Lime" /&gt; 
  &lt;/Canvas&gt; 
  &lt;Ellipse Canvas.Top="29.5" Canvas.Left="103" Fill="Yellow" /&gt; 
&lt;/Canvas&gt; </pre>
<p>This example demonstrates a number of important points, so let's first see the visual output of this code before discussing it:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-2007 image-border" src="img/148bd854-f1c2-43ad-b3e0-a4f4a759ddcc.png" style="width:26.50em;height:16.75em;"/></p>
<p>The top-left rectangle is the output from one canvas, and the top-right and bottom ones are from two other canvas instances. They are all contained within a parent canvas element with a black background. The three inner canvases are spaced to give the effect that they each have a border. They have been declared in the order of top-left, top-right, bottom, and the last element to be declared is, the middle circle.</p>
<p class="mce-root"/>
<p>The left circle is being drawn in the top-left canvas and we can see where it is overlapping the canvas' apparent bottom border, which shows that it is not being clipped by its parent canvas. However, it is being clipped by the lower canvas element and this demonstrates that UI elements that are declared later will be displayed over the top of earlier declared elements.</p>
<p>Nevertheless, the second canvas to be declared is clipping the middle circle, which was the last declared element. This demonstrates that setting the <kbd>Panel.ZIndex</kbd> property on an element to any positive number will position that element above all others that have not explicitly set this property. The default value for this property is zero, so an element that has this property set to <kbd>1</kbd> will be rendered on top of all elements that have not explicitly set a value for it.</p>
<p>The next element to be declared is the bottom rectangle and the right circle is declared within it. Now, as this element is declared after the top canvases, you might expect that the right circle would overlap the upper-right canvas. While this would normally be the case, this won't happen with our example for two reasons.</p>
<p>The first, as we've just found out, is because the upper-right panel has a higher <kbd>ZIndex</kbd> property value than the lower panel and the second reason is because we have set the <kbd>UIElement.ClipToBounds</kbd> property to <kbd>true</kbd>, which is used by the <kbd>Canvas</kbd> panel to determine whether it should clip the visual content of any children that may lie outside the bounds of the panel.</p>
<p>This is commonly used with animations, to enable a visual to be hidden out of the panel bounds and then slid into view in reaction to some event. We can tell that the right circle has been clipped by its parent panel because we can see its apparent top border, which is outside its bounds.</p>
<p>The last element to be declared is the middle circle and we can see that, apart from the overlapping canvas element with the higher <kbd>ZIndex</kbd> property value, it overlaps all of the other elements. Note that the <kbd>Canvas</kbd> panel does not perform any kind of resizing on its children, so it is not typically used for generating form type UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">DockPanel</h1>
                
            
            
                
<p>The <kbd>DockPanel</kbd> class is primarily used in the top levels of the control hierarchy to lay out the top-level controls. It provides us with the ability to dock controls to various parts of the screen, for example, a menu docked at the top, a context menu on the left, a status bar at the bottom and our main View content control in the remainder of the screen:</p>
<div><img class="alignnone size-full wp-image-2008 image-border" src="img/fbf9e32a-b2b5-436c-b14b-db966f715504.png" style="width:30.17em;height:22.25em;"/></div>
<p>This layout shown in the preceding diagram can be easily achieved with just the following XAML:</p>
<pre>&lt;DockPanel&gt; 
  &lt;DockPanel.Resources&gt; 
    &lt;Style TargetType="{x:Type TextBlock}"&gt; 
      &lt;Setter Property="HorizontalAlignment" Value="Center" /&gt; 
      &lt;Setter Property="VerticalAlignment" Value="Center" /&gt; 
      &lt;Setter Property="FontSize" Value="14" /&gt; 
    &lt;/Style&gt; 
    &lt;Style TargetType="{x:Type Border}"&gt; 
      &lt;Setter Property="BorderBrush" Value="Black" /&gt; 
      &lt;Setter Property="BorderThickness" Value="1" /&gt; 
    &lt;/Style&gt; 
  &lt;/DockPanel.Resources&gt; 
  &lt;Border Padding="0,3" DockPanel.Dock="Top"&gt; 
    &lt;TextBlock Text="Menu Bar" /&gt; 
  &lt;/Border&gt; 
  &lt;Border Padding="0,3" DockPanel.Dock="Bottom"&gt; 
    &lt;TextBlock Text="Status Bar" /&gt; 
  &lt;/Border&gt; 
  &lt;Border Width="100" DockPanel.Dock="Left"&gt; 
    &lt;TextBlock Text="Context Menu" TextWrapping="Wrap" /&gt; 
  &lt;/Border&gt; 
  &lt;Border&gt; 
    &lt;TextBlock Text="View" /&gt; 
  &lt;/Border&gt; 
&lt;/DockPanel&gt; </pre>
<p>We specify where we want each element within the panel to be docked using the <kbd>DockPanel.Dock</kbd> Attached Property. We can specify the left, right, top, and bottom of the panel. The remaining space is normally filled by the last child that does not explicitly set one of the <kbd>Dock</kbd> property. However, if that is not the behavior that we want, then we can set the <kbd>LastChildFill</kbd> property to <kbd>false</kbd>.</p>
<p>The <kbd>DockPanel</kbd> will automatically resize itself to fit its content unless its dimensions are specified, either explicitly using the <kbd>Width</kbd> and <kbd>Height</kbd> properties, or implicitly by a parent panel. If it and its children both have dimensions specified for them, there is a chance that certain children will not be provided with enough space and not be displayed correctly, as the last child is the only child that can be resized by the <kbd>DockPanel</kbd>. It should also be noted that this panel does not overlap its child elements.</p>
<p>Also note that the order that the children are declared in will affect the space and position that they are each provided with. For example, if we wanted the menu bar to fill the top of the screen, the context menu to take the remaining left side, and the View and the status bar to take the remaining space, we could just declare the context menu before the status bar:</p>
<pre>  ...
  &lt;Border Padding="0,3" DockPanel.Dock="Top"&gt; 
    &lt;TextBlock Text="Menu Bar" /&gt; 
  &lt;/Border&gt; 
  &lt;Border Width="100" DockPanel.Dock="Left"&gt; 
    &lt;TextBlock Text="Context Menu" TextWrapping="Wrap" /&gt; 
  &lt;/Border&gt; 
  &lt;Border Padding="0,3" DockPanel.Dock="Bottom"&gt; 
    &lt;TextBlock Text="Status Bar" /&gt; 
  &lt;/Border&gt; 
  &lt;Border&gt; 
    &lt;TextBlock Text="View" /&gt; 
  &lt;/Border&gt; 
  ...</pre>
<p>This slight change would result in the following layout:</p>
<div><img class="alignnone size-full wp-image-2009 image-border" src="img/65d77aca-c368-4445-b302-cf68b18f9422.png" style="width:30.17em;height:22.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Grid</h1>
                
            
            
                
<p>The <kbd>Grid</kbd> panel is by far the most commonly used when it comes to laying out typical UI controls. It is the most versatile and enables us to perform a number of tricks to end up with the layout that we require. It offers a flexible row- and column-based layout system that we can use to build UIs with a fluid layout. Fluid layouts are able to react and change size when users resize their application windows.</p>
<p>The <kbd>Grid</kbd> is one of the few panels that can resize all of its child elements depending on the space available, which makes it one of the most performance-intensive panels. Therefore, if we don't need the functionality that it provides, we should use a more performant panel, such as a <kbd>Canvas</kbd> or <kbd>StackPanel</kbd>.</p>
<p>The children of a <kbd>Grid</kbd> panel can each set their <kbd>Margin</kbd> property to be laid out using absolute coordinates, in a similar fashion to the <kbd>Canvas</kbd> panel. However, this should be avoided wherever possible, because that will break the fluidity of our UI. Instead, we typically define our desired layout using the grid's <kbd>RowDefinitions</kbd> and <kbd>ColumnDefinitions</kbd> collections and the <kbd>Grid.Row</kbd> and <kbd>Grid.Column</kbd> Attached Properties.</p>
<p>While we can again hard code exact widths and heights for our rows and columns, we usually try to avoid doing so for the same reason. Instead, we generally take advantage of the grid's sizing behavior and declare our rows and columns, predominantly using one of two values.</p>
<p>The first is the <kbd>Auto</kbd> value, which takes its size from its content and the second is the default <kbd>*</kbd> star-sized value, which takes all of the remaining space. Typically, we set all columns or rows to <kbd>Auto</kbd> except the one(s) that contain(s) the most important data, which is/are set to <kbd>*</kbd>.</p>
<p>Note that if we have more than one star-sized column, then the space is normally divided equally between them. However, if we need unequal divisions of the remaining space, then we can specify a multiplier number with the asterisk, which will multiply the proportion of space that that row or column will be provided with. Let's see an example to help to clarify this:</p>
<pre>&lt;Grid TextElement.FontSize="14" Width="300" Margin="10"&gt; 
  &lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="2.5*" /&gt; 
    &lt;ColumnDefinition /&gt; 
    &lt;ColumnDefinition /&gt; 
  &lt;/Grid.ColumnDefinitions&gt; 
  &lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition /&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
  &lt;/Grid.RowDefinitions&gt; 
  &lt;TextBlock Grid.ColumnSpan="3" HorizontalAlignment="Center" 
    VerticalAlignment="Center" Text="Are you sure you want to continue?" 
    Margin="40" /&gt; <br/>  &lt;Button Grid.Row="1" Grid.Column="1" Content="OK" IsDefault="True"<br/> Height="26" Margin="0,0,2.5,0" /&gt;<br/> &lt;Button Grid.Row="1" Grid.Column="2" Content="Cancel" IsCancel="True"<br/> Height="26" Margin="2.5,0,0,0" /&gt;
&lt;/Grid&gt; </pre>
<p>This example demonstrates a number of points, so let's see the rendered output before continuing:</p>
<div><img class="alignnone size-full wp-image-2010 image-border" src="img/f16dcf8f-ac1f-47ae-bcf6-3995e5ee2e35.png" style="width:27.58em;height:14.75em;"/></div>
<p>Here, we have a very basic confirmation dialog control. It is formed with a <kbd>Grid</kbd> panel with three columns and two rows. Note that a single star-sizing is used as the default width and height values for the <kbd>ColumnDefinition</kbd> and <kbd>RowDefinition</kbd> elements respectively; we do not need to explicitly set them and can simply declare empty elements. Also note that star-sizing will only work when the <kbd>Grid</kbd> panel has some size set on it, as we have done here.</p>
<p>Therefore, in our example, the second and third columns and the first row will use star-sizing and take all of the remaining space. The first column also uses star-sizing, however, it specifies a multiplier value of <kbd>2.5</kbd>. As such, it will be provided with two and a half times the amount of space that the other two columns will each have.</p>
<p>Note that this first column is only used to push the buttons in the other two columns to the correct position. While the <kbd>TextBlock</kbd> element is declared in the first column, it does not only reside in that column, because it has also specified the <kbd>Grid.ColumnSpan</kbd> Attached Property, which allows it to spread out across multiple columns. The <kbd>Grid.RowSpan</kbd> Attached Property does the same for rows.</p>
<p>The <kbd>Grid.Row</kbd> and <kbd>Grid.Column</kbd> Attached Properties are used by each element to specify which cell they should be rendered in. However, the default value for these properties is zero and so, when we want to declare an element within the first column or row of the panel, we can omit the setting of these properties, as has been done for the <kbd>TextBlock</kbd> in our example.</p>
<p>The OK button has been declared in the second row and column and sets the <kbd>IsDefault</kbd> key to <kbd>true</kbd>, which enables users to invoke it by pressing the <em>Enter</em> key on their keyboards. It is also responsible for the blue border on the button and we can use this property to style the default button differently in our own templates. The Cancel button sits next to it in the third column and sets the <kbd>IsCancel</kbd> property to <kbd>true</kbd>, which enables the users to select it by pressing the <em>Esc</em> key on their keyboards.</p>
<p>Note that we could have set the lower <kbd>RowDefinition.Height</kbd> property to <kbd>26</kbd> instead of setting that on each button explicitly and the end result would have been the same, as the <kbd>Auto</kbd> value would be calculated from their height anyway. Also, note that the <kbd>Margin</kbd> property has been set on a few elements here for spacing purposes only, rather than for absolute positioning purposes.</p>
<p>There are two other useful properties declared by the <kbd>Grid</kbd> class. The first is the <kbd>ShowGridLines</kbd> property, which as you can imagine, shows the borders of the rows and columns in the panel when set to <kbd>true</kbd>. While not really required for simple layouts as in the previous example, this can be useful while developing more complicated layouts. However, due to its poor performance, this feature should never be utilized in production XAML:</p>
<pre>&lt;Grid TextElement.FontSize="14" Width="300" Margin="10" <br/>  ShowGridLines="True"&gt; 
  ... 
&lt;/Grid&gt; </pre>
<p>Let's see what this looks like with visible grid lines now:</p>
<div><img src="img/d94f6a2d-482e-4cbe-94c1-4fc62ba50a95.png" style="width:34.83em;height:19.08em;"/></div>
<p>The other useful property is the <kbd>IsSharedSizeScope</kbd> Attached Property, which enables us to share sizing information between two or more <kbd>Grid</kbd> panels. We can achieve this by setting this property to <kbd>true</kbd> on a parent panel and then specifying the <kbd>SharedSizeGroup</kbd> property on the relevant <kbd>ColumnDefinition</kbd> and/or <kbd>RowDefinition</kbd> elements of the inner <kbd>Grid</kbd> panels.</p>
<p>There are a few conditions that we need to adhere to in order to get this to work and the first relates to scope. The <kbd>IsSharedSizeScope</kbd> property needs to be set on a parent element, but if that parent element is within a resource template and the definition elements that specify the <kbd>SharedSizeGroup</kbd> property are outside that template then it will not work. It will, however, work in the opposite direction.</p>
<p>The other point to be aware of is that star-sizing is not respected when sharing sizing information. In these cases, the star values of any definition elements will be read as <kbd>Auto</kbd>, so we do not typically set the <kbd>SharedSizeGroup</kbd> property on our star-sized column. However, if we set it on the other columns, then we will be left with our desired layout. Let's see an example of this:</p>
<pre>&lt;Grid TextElement.FontSize="14" Margin="10" IsSharedSizeScope="True"&gt; 
  &lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
    &lt;RowDefinition /&gt; 
  &lt;/Grid.RowDefinitions&gt; 
  &lt;Grid TextElement.FontWeight="SemiBold" Margin="0,0,0,3" 
    ShowGridLines="True"&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
      &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Name" /&gt; 
      &lt;ColumnDefinition /&gt; 
      &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Age" /&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;TextBlock Text="Name" /&gt; 
    &lt;TextBlock Grid.Column="1" Text="Comments" Margin="10,0" /&gt; 
    &lt;TextBlock Grid.Column="2" Text="Age" /&gt; 
  &lt;/Grid&gt; 
  &lt;Separator Grid.Row="1" /&gt; 
  &lt;ItemsControl Grid.Row="2" ItemsSource="{Binding Users}"&gt; 
    &lt;ItemsControl.ItemTemplate&gt; 
      &lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
        &lt;Grid ShowGridLines="True"&gt; 
          &lt;Grid.ColumnDefinitions&gt; 
            &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Name" /&gt; 
            &lt;ColumnDefinition /&gt; 
            &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Age" /&gt; 
          &lt;/Grid.ColumnDefinitions&gt; 
          &lt;TextBlock Text="{Binding Name}" /&gt; 
          &lt;TextBlock Grid.Column="1" Text="Star-sized column takes all
            remaining space" Margin="10,0" /&gt;          
          &lt;TextBlock Grid.Column="2" Text="{Binding Age}" /&gt; 
        &lt;/Grid&gt; 
      &lt;/DataTemplate&gt; 
    &lt;/ItemsControl.ItemTemplate&gt; 
  &lt;/ItemsControl&gt; 
&lt;/Grid&gt; </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In this example, we have an <kbd>ItemsControl</kbd> that is data bound to a slightly edited version of our <kbd>Users</kbd> collection from our earlier examples. Previously, all of the user names were of a similar length, so one has been edited to demonstrate this point more clearly. The <kbd>ShowGridLines</kbd> property has also been set to <kbd>true</kbd> on the inner panels for the same reason.</p>
<p>In the example, we first set the <kbd>IsSharedSizeScope</kbd> Attached Property to <kbd>true</kbd> on the parent <kbd>Grid</kbd> panel and then apply the <kbd>SharedSizeGroup</kbd> property to the definitions of the inner <kbd>Grid</kbd> controls, which are declared inside the outer panel and within the <kbd>DataTemplate</kbd> element. Let's see the rendered output of this code before continuing:</p>
<div><img class="alignnone size-full wp-image-2012 image-border" src="img/677c3f7e-4a2b-4ee1-9b0b-3552f222bb37.png" style="width:30.00em;height:8.50em;"/></div>
<p>Note that we have provided the same number of columns and group names for the columns inside and outside of the <kbd>DataTemplate</kbd> element, which is essential for this functionality to work. Also note that we have not set the <kbd>SharedSizeGroup</kbd> property on the middle column, which is star-sized.</p>
<p>Grouping just the other two columns will have the same visual effect as grouping all three, but without losing the star-sizing on the middle column. However, let's see what would happen if we also set the <kbd>SharedSizeGroup</kbd> property on the middle column definitions:</p>
<pre>&lt;ColumnDefinition SharedSizeGroup="Comments" /&gt; </pre>
<p>As expected, we have lost the star-sizing on our middle column and the remaining space has now been applied to the last column:</p>
<div><img class="alignnone size-full wp-image-2013 image-border" src="img/298fd5a8-a489-4fbd-b0bb-0d200dc2a841.png" style="width:29.17em;height:8.25em;"/></div>
<p>The <kbd>Grid</kbd> panel within the template will be rendered for each item in the collection and so this will actually result in several panels, each with the same group names and therefore, also column spacing. It is important that we set the <kbd>IsSharedSizeScope</kbd> property to <kbd>true</kbd> on the <kbd>Grid</kbd> panel that is the common parent to all of the inner panels that we wish to share sizing information between.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">StackPanel</h1>
                
            
            
                
<p>The <kbd>StackPanel</kbd> is one of the WPF panels that only provides limited resizing abilities to its child items. It will automatically set the <kbd>HorizontalAlignment</kbd> and <kbd>VerticalAlignment</kbd> properties of each of its children to <kbd>Stretch</kbd>, as long as they don't have explicit sizes specified. In these cases alone, the child elements will be stretched to fit the size of the containing panel. This can be easily demonstrated as follows:</p>
<pre>&lt;Border Background="Black" Padding="5"&gt; 
  &lt;Border.Resources&gt; 
    &lt;Style TargetType="{x:Type TextBlock}"&gt; 
      &lt;Setter Property="Padding" Value="5" /&gt; 
      &lt;Setter Property="Background" Value="Yellow" /&gt; 
      &lt;Setter Property="TextAlignment" Value="Center" /&gt; 
    &lt;/Style&gt; 
  &lt;/Border.Resources&gt; 
  &lt;StackPanel TextElement.FontSize="14"&gt; 
    &lt;TextBlock Text="Stretched Horizontally" /&gt; 
    &lt;TextBlock Text="With Margin" Margin="20" /&gt; 
    &lt;TextBlock Text="Centered Horizontally" 
      HorizontalAlignment="Center" /&gt; 
    &lt;Border BorderBrush="Cyan" BorderThickness="1" Margin="0,5,0,0"
      Padding="5" SnapsToDevicePixels="True"&gt; 
      &lt;StackPanel Orientation="Horizontal"&gt; 
        &lt;TextBlock Text="Stretched Vertically" /&gt; 
        &lt;TextBlock Text="With Margin" Margin="20" /&gt; 
        &lt;TextBlock Text="Centered Vertically" 
          VerticalAlignment="Center" /&gt; 
      &lt;/StackPanel&gt; 
    &lt;/Border&gt; 
  &lt;/StackPanel&gt; 
&lt;/Border&gt; </pre>
<p>This panel literally lays each child element out one after the other, vertically by default, or horizontally when its <kbd>Orientation</kbd> property is set to <kbd>Horizontal</kbd>. Our example uses both orientations, so let's take a quick look at its output before continuing:</p>
<div><img class="alignnone size-full wp-image-2014 image-border" src="img/512a4b8a-dba9-4cd1-8768-ffd0c4515acd.png" style="width:28.75em;height:25.00em;"/></div>
<p>Our whole example is wrapped in a <kbd>Border</kbd> element with a black background. In its <kbd>Resources</kbd> section, we declared a few style properties for the <kbd>TextBlock</kbd> elements in our example. Inside the border, we declare our first <kbd>StackPanel</kbd> control, with its default vertical orientation. In this first panel, we have three <kbd>TextBlock</kbd> elements and another <kbd>StackPanel</kbd> wrapped in a border.</p>
<p>The first <kbd>TextBlock</kbd> element is automatically stretched to fit the width of the panel. The second adds a margin, but would otherwise also be stretched across the width of the panel. The third, however, has its <kbd>HorizontalAlignment</kbd> property explicitly set to <kbd>Center</kbd> and so it is not stretched to fit by the panel.</p>
<p>The inner panel has three <kbd>TextBlock</kbd> elements declared inside it and has its <kbd>Orientation</kbd> property set to <kbd>Horizontal</kbd>. Its children are therefore laid out horizontally. Its border is colored, so that it is easier to see its bounds. Note the use of the <kbd>SnapsToDevicePixels</kbd> property set on it.</p>
<p>As WPF uses device-independent pixel settings, thin straight lines can sometimes lie across individual pixel boundaries and appear anti-aliased. Setting this property to <kbd>true</kbd> will force the element to be rendered exactly in line with the physical pixels, using device-specific pixel settings and forming a clearer, sharper line.</p>
<p>The first <kbd>TextBlock</kbd> element in the lower panel is automatically stretched to fit the height of the panel. As with the elements in the upper panel, the second adds a margin, but would otherwise also be stretched across the height of the panel. The third, however, has its <kbd>VerticalAlignment</kbd> property explicitly set to <kbd>Center</kbd> and so it is not stretched vertically to fit by the panel.</p>
<p>As a side note, we have used the hexadecimal entity to add a new line in some of our text strings. This could also have been achieved using the <kbd>TextBlock.TextWrapping</kbd> property and hard coding a <kbd>Width</kbd> for each element, but this way is obviously far simpler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">UniformGrid</h1>
                
            
            
                
<p>The <kbd>UniformGrid</kbd> panel is a lightweight panel that provides a simple way to create a grid of items, where each item is of the same size. We can set its <kbd>Row</kbd> and <kbd>Column</kbd> properties to specify how many rows and columns we want our grid to have. If we do not set one or both of these properties, the panel will implicitly set them for us, depending upon the available space it has and the size of its children.</p>
<p>It also provides us with a <kbd>FirstColumn</kbd> property that will affect the column that the first child item will be rendered in. For example, if we set this property to <kbd>2</kbd> then the first child will be rendered in the third column. This is perfect for a calendar control, so let's take a look at how we might create the following output using the <kbd>UniformGrid</kbd>:</p>
<div><img class="alignnone size-full wp-image-2015 image-border" src="img/b28f00fa-c5ca-42b4-8dce-38c6edd9f46c.png" style="width:22.25em;height:17.92em;"/></div>
<p>As you can see, a calendar control often needs to have blank spaces in the first few columns and so the <kbd>FirstColumn</kbd> property achieves this requirement simply. Let's see the XAML that defines this calendar example:</p>
<pre>&lt;StackPanel TextElement.FontSize="14" Background="White"&gt; 
  &lt;UniformGrid Columns="7" Rows="1"&gt; 
    &lt;UniformGrid.Resources&gt; 
      &lt;Style TargetType="{x:Type TextBlock}"&gt; 
        &lt;Setter Property="Height" Value="35" /&gt; 
        &lt;Setter Property="HorizontalAlignment" Value="Center" /&gt; 
        &lt;Setter Property="Padding" Value="0,5,0,0" /&gt; 
      &lt;/Style&gt; 
    &lt;/UniformGrid.Resources&gt; 
    &lt;TextBlock Text="Mon" /&gt; 
    &lt;TextBlock Text="Tue" /&gt; 
    &lt;TextBlock Text="Wed" /&gt; 
    &lt;TextBlock Text="Thu" /&gt; 
    &lt;TextBlock Text="Fri" /&gt; 
    &lt;TextBlock Text="Sat" /&gt; 
    &lt;TextBlock Text="Sun" /&gt; 
  &lt;/UniformGrid&gt; 
  &lt;ItemsControl ItemsSource="{Binding Days}" Background="Black"<br/>    Padding="0,0,1,1"&gt; 
    &lt;ItemsControl.ItemsPanel&gt; 
      &lt;ItemsPanelTemplate&gt; 
        &lt;UniformGrid Columns="7" FirstColumn="2" /&gt; 
      &lt;/ItemsPanelTemplate&gt; 
    &lt;/ItemsControl.ItemsPanel&gt; 
    &lt;ItemsControl.ItemTemplate&gt; 
      &lt;DataTemplate&gt; 
        &lt;Border BorderBrush="Black" BorderThickness="1,1,0,0" 
          Background="White"&gt; 
          &lt;TextBlock Text="{Binding}" Height="35" 
            HorizontalAlignment="Center" Padding="0,7.5,0,0" /&gt; 
        &lt;/Border&gt; 
      &lt;/DataTemplate&gt; 
    &lt;/ItemsControl.ItemTemplate&gt; 
  &lt;/ItemsControl&gt; 
&lt;/StackPanel&gt; </pre>
<p>We start with a <kbd>StackPanel</kbd> that is used to stack one <kbd>UniformGrid</kbd> panel directly above an <kbd>ItemsControl</kbd> that uses another one as its <kbd>ItemsPanel</kbd> and specifies a font size to use within the control. The top <kbd>UniformGrid</kbd> panel declares a single row of seven columns and some basic <kbd>TextBlock</kbd> styles. It has seven child <kbd>TextBlock</kbd> items that output the names of the days in a week.</p>
<p>The <kbd>ItemsControl</kbd> element has its <kbd>Background</kbd> property set to <kbd>Black</kbd> to black out days not in the current month, and its <kbd>Padding</kbd> set to make the background appear like a border to the right and bottom of the calendar. The top and left borders come from the individual cells in the <kbd>UniformGrid</kbd> panel. The <kbd>ItemsControl.ItemsSource</kbd> property is data bound to a <kbd>Days</kbd> property in our View Model, so let's take a look at that now:</p>
<pre>private List&lt;int&gt; days = Enumerable.Range(1, 31).ToList(); 
 
... 
 
public List&lt;int&gt; Days 
{ 
  get { return days; } 
  set { days = value; NotifyPropertyChanged(); } 
} </pre>
<p>Note the use of the <kbd>Enumerable.Range</kbd> method to populate the collection. It provides a simple way to generate a contiguous sequence of integers from the supplied start and length input parameters. As a LINQ method, it is implemented using deferred execution and the actual values are not generated until actually accessed.</p>
<p>The second <kbd>UniformGrid</kbd> panel, which is set as the <kbd>ItemsControl.ItemsPanel</kbd>, only specifies that it should have seven columns, but leaves the number of rows to be calculated from the number of data bound items. Note also that we have hard coded a value of <kbd>2</kbd> to the <kbd>FirstColumn</kbd> property, although in a proper control, we would typically data bind the value for the relevant month to it instead.</p>
<p>Finally, we use a <kbd>DataTemplate</kbd> to define what each day on the calendar should look like. Note that we do not need to specify a value for its <kbd>DataType</kbd> property in this example, because we are data binding to the whole data source object, which in this case is just an integer. Let's now move on to investigate the <kbd>WrapPanel</kbd> panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WrapPanel</h1>
                
            
            
                
<p>The <kbd>WrapPanel</kbd> panel is similar to <kbd>StackPanel</kbd>, except that it will stack its children in both directions by default. It starts by laying out the child items horizontally and when it runs out of space on the first row, it automatically wraps the next item onto a new row and continues to lay out the remaining controls. It repeats this process using as many rows as are required, until all of the items are rendered.</p>
<p>However, it also provides an <kbd>Orientation</kbd> property like <kbd>StackPanel</kbd>, and this will affect its layout behavior. If the <kbd>Orientation</kbd> property is changed from the default value of <kbd>Horizontal</kbd> to <kbd>Vertical</kbd>, then the panel's child items will be laid out vertically, from top to bottom until there is no more room in the first column. The items will then wrap to the next column and will continue in this way until all of the items have been rendered.</p>
<p>This panel also declares <kbd>ItemHeight</kbd> and <kbd>ItemWidth</kbd> properties that enable it to restrict items' dimensions and to produce a layout behavior similar to the <kbd>UniformGrid</kbd> panel. Note that the values will not actually resize each child item, but merely restrict the available space that they are provided with in the panel. Let's see an example of this:</p>
<pre>&lt;WrapPanel ItemHeight="50" Width="150" TextElement.FontSize="14"&gt; 
  &lt;WrapPanel.Resources&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Width" Value="50" /&gt; 
    &lt;/Style&gt; 
  &lt;/WrapPanel.Resources&gt; 
  &lt;Button Content="7" /&gt; 
  &lt;Button Content="8" /&gt; 
  &lt;Button Content="9" /&gt; 
  &lt;Button Content="4" /&gt; 
  &lt;Button Content="5" /&gt; 
  &lt;Button Content="6" /&gt; 
  &lt;Button Content="1" /&gt; 
  &lt;Button Content="2" /&gt; 
  &lt;Button Content="3" /&gt; 
  &lt;Button Content="0" Width="100" /&gt; 
  &lt;Button Content="." /&gt; 
&lt;/WrapPanel&gt; </pre>
<p>Note that while similar to the output of a <kbd>UniformGrid</kbd> panel, the output of this example could not actually be achieved with that panel, because one of the child items is a different size to the others. Let's see the visual output of this example:</p>
<div><img src="img/06ed28c9-6ec6-4af6-bf07-b1c918a2d724.png" style="width:9.42em;height:12.58em;"/></div>
<p>We first declare the <kbd>WrapPanel</kbd> and specify that each child should only be provided with a height of <kbd>50</kbd> pixels, while the panel itself should be <kbd>150</kbd> pixels wide. In the <kbd>Resources</kbd> section, we set the width of each button to be <kbd>50</kbd> pixels wide, therefore enabling three buttons to sit next to each other on each row, before wrapping items to the next row.</p>
<p>Next, we simply define the eleven buttons that make up the panel's children, specifying that the zero button should be twice as wide as the others. Note that this would not have worked if we had set the <kbd>ItemWidth</kbd> property to <kbd>50</kbd> pixels, along with the <kbd>ItemHeight</kbd> property. In that case, we would have seen half of the zero button, with the other half covered by the period button and a blank space where the period button currently is.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Providing custom layout behavior</h1>
                
            
            
                
<p>When the layout behavior of the built-in panels do not meet our requirements, we can easily define a new panel with custom layout behavior. All we need to do is to declare a class that extends the <kbd>Panel</kbd> class and to override its <kbd>MeasureOverride</kbd> and <kbd>ArrangeOverride</kbd> methods.</p>
<p>In the <kbd>MeasureOverride</kbd> method, we simply call the <kbd>Measure</kbd> method on each child item from the <kbd>Children</kbd> collection, passing in a <kbd>Size</kbd> element set to <kbd>double.PositiveInfinity</kbd>. This is equivalent to saying "set your <kbd>DesriredSize</kbd> property as if you had all of the space that you could possibly need" to each child item.</p>
<p>In the <kbd>ArrangeOverride</kbd> method, we use the newly determined <kbd>DesriredSize</kbd> property value of each child item to calculate its required position and call its <kbd>Arrange</kbd> method to render it in that position. Let's look at an example of a custom panel that positions its items equally around the circumference of a circle:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.Views.Panels 
{ 
  public class CircumferencePanel : Panel 
  { 
    public Thickness Padding { get; set; } 
 
    protected override Size MeasureOverride(Size availableSize) 
    { 
      foreach (UIElement element in Children) 
      { 
        element.Measure(
          new Size(double.PositiveInfinity, double.PositiveInfinity)); 
      } 
      return availableSize; 
    } 
 
    protected override Size ArrangeOverride(Size finalSize) 
    { 
      if (Children.Count == 0) return finalSize; 
      double currentAngle = 90 * (Math.PI / 180); 
      double radiansPerElement = 
        (360 / Children.Count) * (Math.PI / 180.0);
      double radiusX = finalSize.Width / 2.0 - Padding.Left; 
      double radiusY = finalSize.Height / 2.0 - Padding.Top; 
      foreach (UIElement element in Children) 
      { 
        Point childPoint = new Point(Math.Cos(currentAngle) * radiusX,
          -Math.Sin(currentAngle) * radiusY); 
        Point centeredChildPoint = new Point(childPoint.X + 
          finalSize.Width / 2 - element.DesiredSize.Width / 2, childPoint.Y
          + finalSize.Height / 2 - element.DesiredSize.Height / 2);
        Rect boundingBox = 
          new Rect(centeredChildPoint, element.DesiredSize); 
        element.Arrange(boundingBox); 
        currentAngle -= radiansPerElement; 
      } 
      return finalSize; 
    } 
  } 
} </pre>
<p>In our <kbd>CircumferencePanel</kbd> class, we first declare our own <kbd>Padding</kbd> property of type <kbd>Thickness</kbd>, which will be used to enable the users of the panel to lengthen or shorten the radius of the circle and therefore, adjust the position of the rendered items within the panel. The <kbd>MeasureOverride</kbd> method is a simple affair, as previously explained.</p>
<p>In the <kbd>ArrangeOverride</kbd> method, we calculate the relevant angles to position the child items with, depending upon how many of them there are. We take the value of our <kbd>Padding</kbd> property into consideration when calculating the <em>X</em> and <em>Y</em> radiuses, so that users of our custom panel will be better able to control the position of the rendered items.</p>
<p>For each child item in the panel's <kbd>Children</kbd> collection, we first calculate the point on the circle where it should be displayed. We then offset that value using the value of the element's <kbd>DesiredSize</kbd> property, so that the bounding box of each item is centered on that point.</p>
<p>We then create the element's bounding box using a <kbd>Rect</kbd> element, with the offset point and the element's <kbd>DesiredSize</kbd> property, and pass that to its <kbd>Arrange</kbd> method to render it. After each element is rendered, the current angle is changed for the next item. Remember that we can utilize this panel by adding a XAML namespace for the <kbd>Panels</kbd> CLR namespace and setting the <kbd>ItemsPanel</kbd> property of an <kbd>ItemsControl</kbd> or one of its derived classes:</p>
<pre><br/><br/>...<br/><br/>&lt;ItemsControl ItemsSource="{Binding Hours}" TextElement.FontSize="24"<br/>  Width="200" Height="200"&gt;<br/>  &lt;ItemsControl.ItemsPanel&gt;<br/>    &lt;ItemsPanelTemplate&gt;<br/>      &lt;Panels:CircumferencePanel Padding="20" /&gt;<br/>    &lt;/ItemsPanelTemplate&gt;<br/>  &lt;/ItemsControl.ItemsPanel&gt;<br/>&lt;/ItemsControl&gt;</pre>
<p>Given some suitable data, we could use this panel to display the numbers on a clock control, for example. Let's see the <kbd>Hours</kbd> property that the <kbd>ItemsSource</kbd> property of our example <kbd>ItemsControl</kbd> is data bound to:</p>
<pre>private List&lt;int&gt; hours = new List&lt;int&gt;() { 12 }; 
 
public List&lt;int&gt; Hours 
{ 
  get { return hours; } 
  set { hours = value; NotifyPropertyChanged(); } 
}

...

hours.AddRange(Enumerable.Range(1, 11)); </pre>
<p>As the hour numerals must start with 12 and then go back to 1, we declare the collection with the 12 element initially. At some later stage, possibly during construction, we then add the remaining numbers to the collection and this is what it looks like when using our new panel:</p>
<div><img class="alignnone size-full wp-image-2017 image-border" src="img/a2731651-1436-4647-b644-24033721c070.png" style="width:12.08em;height:13.75em;"/></div>
<p>This concludes our coverage of the main panels that are available in WPF. While we don't have the space to have an in-depth look at every other WPF control, we'll find tips and tricks for a number of them throughout this book. Instead, let's now focus on a few essential controls and what they can do for us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Content controls</h1>
                
            
            
                
<p>While this control is not often used directly, one use for it is to render a single data item according to a particular template. In fact, we often use a <kbd>ContentControl</kbd> to display our View Models and use a <kbd>DataTemplate</kbd> object that renders the associated View. Alternatively, we might use some form of <kbd>ItemsControl</kbd> to display a group of items and a <kbd>ContentControl</kbd> to display the selected item.</p>
<p>As we found out earlier, when looking at the inheritance hierarchy of the <kbd>Button</kbd> control, the <kbd>ContentControl</kbd> class extends the <kbd>Control</kbd> class and adds the ability for derived classes to contain any single CLR object. Note that if we need to specify more than a single object of content, we can use a single panel object that contains further objects:</p>
<pre>&lt;Button Width="80" Height="30" TextElement.FontSize="14"&gt; 
  &lt;StackPanel Orientation="Horizontal"&gt; 
    &lt;Rectangle Fill="Cyan" Stroke="Black" StrokeThickness="1" Width="16" 
      Height="16" /&gt; 
    &lt;TextBlock Text="Cyan" Margin="5,0,0,0" /&gt; 
  &lt;/StackPanel&gt; 
&lt;/Button&gt;</pre>
<div><img class="alignnone size-full wp-image-2018 image-border" src="img/238a62c4-8115-4466-b502-e4d5c6066fb6.png" style="width:11.67em;height:7.50em;"/></div>
<p>We can specify this content through the use of the <kbd>Content</kbd> property. However, the <kbd>ContentControl</kbd> class specifies the <kbd>Content</kbd> property in a <kbd>ContentPropertyAttribute</kbd> attribute in its class definition and this enables us to set the content by simply declaring the child element directly within the control in the XAML. This attribute is used by the XAML processor when it processes XAML child elements.</p>
<p>If the content is of type <kbd>string</kbd>, then we can use the <kbd>ContentStringFormat</kbd> property to specify a particular format for it. Otherwise, we can use the <kbd>ContentTemplate</kbd> property to specify a <kbd>DataTemplate</kbd> to use while rendering the content. Alternatively, the <kbd>ContentTemplateSelector</kbd> property is of type <kbd>DataTemplateSelector</kbd> and also enables us to select a <kbd>DataTemplate</kbd>, but based upon some custom condition that we may have. All derived classes have access to these properties in order to shape the output of their content.</p>
<p>However, this control is also able to display many primitive types without us having to specify a custom template. Let's move on to the next section now, where we'll find out exactly how it manages to accomplish this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Presenting content</h1>
                
            
            
                
<p>In WPF, there is a special element that is essential but often little understood. The <kbd>ContentPresenter</kbd> class basically presents content, as its name suggests. It is actually used internally within <kbd>ContentControl</kbd> objects to present their content.</p>
<p>That is its sole job and it should not be used for other purposes. The only time that we should declare these elements is within a <kbd>ControlTemplate</kbd> of a <kbd>ContentControl</kbd> element or one of its many derived classes. In these cases, we declare them where we want the actual content to appear.</p>
<p>Note that specifying the <kbd>TargetType</kbd> property on a <kbd>ControlTemplate</kbd> when using a <kbd>ContentPresenter</kbd> will result in its <kbd>Content</kbd> property being implicitly data bound to the <kbd>Content</kbd> property of the relevant <kbd>ContentControl</kbd> element. We are however free to data bind it explicitly to whatever we like:</p>
<pre>&lt;ControlTemplate x:Key="ButtonTemplate" TargetType="{x:Type Button}"&gt; 
  &lt;ContentPresenter Content="{TemplateBinding ToolTip}" /&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>The <kbd>ContentTemplate</kbd> and <kbd>ContentTemplateSelector</kbd> properties both mirror those of the <kbd>ContentControl</kbd> class and also enable us to select a <kbd>DataTemplate</kbd> based upon a custom condition. Like the <kbd>Content</kbd> property, both of these properties will also be implicitly data bound to the properties of the same names in the templated parent if the <kbd>TargetType</kbd> property of the <kbd>ControlTemplate</kbd> has been set.</p>
<p>This usually saves us from having to explicitly data bind these properties, although there are a few controls where the names of the relevant properties do not match up. In these cases, we can use the <kbd>ContentSource</kbd> property as a shortcut to data bind the <kbd>Content</kbd>, <kbd>ContentTemplate</kbd>, and <kbd>ContentTemplateSelector</kbd> properties.</p>
<p>If we set this property to <kbd>Header</kbd>, for example, the Framework will look for a property named <kbd>Header</kbd> on the <kbd>ContentControl</kbd> object to implicitly data bind to the <kbd>Content</kbd> property of the presenter. Likewise, it will look for properties named <kbd>HeaderTemplate</kbd> and <kbd>HeaderTemplateSelector</kbd> to implicitly data bind to the <kbd>ContentTemplate</kbd> and <kbd>ContentTemplateSelector</kbd> properties.</p>
<p>This is primarily used in a <kbd>ControlTemplate</kbd> for a <kbd>HeaderedContentControl</kbd> element or one of its derived classes:</p>
<pre>&lt;ControlTemplate x:Key="TabItemTemplate" TargetType="{x:Type TabItem}"&gt; 
  &lt;StackPanel&gt; 
    &lt;ContentPresenter ContentSource="Header" /&gt; 
    &lt;ContentPresenter ContentSource="Content" /&gt; 
  &lt;/StackPanel&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>There are specific rules that determine what the <kbd>ContentPresenter</kbd> will display. If the <kbd>ContentTemplate</kbd> or <kbd>ContentTemplateSelector</kbd> property is set, then the data object specified by the <kbd>Content</kbd> property will have the resulting data template applied to it. Likewise, if a data template of the relevant type is found within the scope of the <kbd>ContentPresenter</kbd> element, it will be applied.</p>
<p>If the content object is a UI element, or one is returned from a type converter, then the element is displayed directly. If the object is a <kbd>string</kbd>, or a <kbd>string</kbd> is returned from a type converter, then it will be set as the <kbd>Text</kbd> property of a <kbd>TextBlock</kbd> control and that will be displayed. Likewise, all other objects simply have the <kbd>ToString</kbd> method called on them and then this output is rendered in a standard <kbd>TextBlock</kbd> at runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Items controls</h1>
                
            
            
                
<p>We've already seen a fair number of examples of the <kbd>ItemsControl</kbd> class, but we'll now take a closer look at this control. In the simplest terms, an <kbd>ItemsControl</kbd> class contains a variable number of <kbd>ContentPresenter</kbd> elements and enables us to display a collection of items. It is the base class for most common collection controls, such as the <kbd>ListBox</kbd>, <kbd>ComboBox</kbd>, and <kbd>TreeView</kbd> controls.</p>
<p>Each of these derived classes adds a specific look and set of capabilities, such as a border and the notion of a selected item. If we do not require these additional features and simply want to display a number of items, then we should just use the <kbd>ItemsControl</kbd>, because it is more efficient than its derived classes.</p>
<p>When using the <strong>Model-View-ViewModel</strong> (<strong>MVVM</strong>) pattern, we typically data bind a collection that implements the <kbd>IEnumerable</kbd> interface from our View Model to the <kbd>ItemsControl.ItemsSource</kbd> property. However, there is also an <kbd>Items</kbd> property that will reflect the items in the data bound collection.</p>
<p>To clarify this further, either property can be used to populate the collection of items to display. However, only one can be used at a time, so if you have data bound a collection to the <kbd>ItemsSource</kbd> property, then you cannot add items using the <kbd>Items</kbd> property. In this case, the <kbd>Items</kbd> collection will become read-only.</p>
<p>If we need to display a collection of items that don't implement the <kbd>IEnumerable</kbd> interface, then we will need to add them using the <kbd>Items</kbd> property. Note that the <kbd>Items</kbd> property is implicitly used when items are declared as the content of an <kbd>ItemsControl</kbd> element in XAML. However, when using MVVM, we generally use the <kbd>ItemsSource</kbd> property.</p>
<p>When displaying items in an <kbd>ItemsControl</kbd>, each item in the collection will implicitly be wrapped in a <kbd>ContentPresenter</kbd> container element. The type of container element will depend upon the type of collection control used. For example, a <kbd>ComboBox</kbd> would wrap its items in <kbd>ComboBoxItem</kbd> elements.</p>
<p>The <kbd>ItemContainerStyle</kbd> and <kbd>ItemContainerStyleSelector</kbd> properties enable us to provide a style for these container items. We must ensure that the styles that we provide are targeted to the correct type of container control. For example, if we were using a <kbd>ListBox</kbd>, then we would need to provide a style targeting the <kbd>ListBoxItem</kbd> type, as in the following example.</p>
<p>Note that we can explicitly declare these container items, although there is little point in doing so, as it will otherwise be done for us. Furthermore, when using MVVM, we do not typically work with UI elements, preferring to work with data objects in the View Models and data bind to the <kbd>ItemsSource</kbd> property instead.</p>
<p>As we have already seen, the <kbd>ItemsControl</kbd> class has an <kbd>ItemsPanel</kbd> property of type <kbd>ItemsPanelTemplate</kbd> that enables us to change the type of panel that the collection control uses to layout its items. When we want to customize the template of an <kbd>ItemsControl</kbd>, we have two choices regarding how we render the control's child items:</p>
<pre>&lt;ControlTemplate x:Key="Template1" TargetType="{x:Type ItemsControl}"&gt; 
  &lt;StackPanel Orientation="Horizontal" IsItemsHost="True" /&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>We already saw an example of the preceding method in the previous section. In this way, we specify the actual items panel itself and set the <kbd>IsItemsHost</kbd> property to <kbd>true</kbd> on it to indicate that it is indeed to be used as the control's items panel. Using the alternative method, we need to declare an <kbd>ItemsPresenter</kbd> element, which specifies where the actual items panel will be rendered. Note that this element will be replaced by the actual items panel being used at runtime:</p>
<pre>&lt;ControlTemplate x:Key="Template2" TargetType="{x:Type ItemsControl}"&gt; 
  &lt;ItemsPresenter /&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>As with the <kbd>ContentControl</kbd> class, the <kbd>ItemsControl</kbd> class also provides properties that enable us to shape its data items. The <kbd>ItemTemplate</kbd> and <kbd>ItemTemplateSelector</kbd> properties let us apply a data template for each item. However, if we just need a simple textual output, there are alternative methods where we can avoid the need to define a data template at all.</p>
<p>We can use the <kbd>DisplayMemberPath</kbd> property to specify the name of the property from the object to display the value. Alternatively, we can set the <kbd>ItemStringFormat</kbd> property to format the output as a <kbd>string</kbd>, or as we saw earlier, just provide some meaningful output from the class' <kbd>ToString</kbd> method of the data object.</p>
<p>Another interesting property is the <kbd>AlternationCount</kbd> property, which enables us to style alternating containers differently. We can set it to any number and the alternating sequence will repeat after that many items have been rendered. As a simple example, let's use a <kbd>ListBox</kbd> because the <kbd>ListBoxItem</kbd> controls that will be wrapped around our items have appearance properties that we can alternate:</p>
<pre>&lt;ListBox ItemsSource="{Binding Users}" AlternationCount="3"&gt; 
  &lt;ListBox.ItemContainerStyle&gt; 
    &lt;Style TargetType="{x:Type ListBoxItem}"&gt; 
      &lt;Setter Property="FontSize" Value="14" /&gt; 
      &lt;Setter Property="Foreground" Value="White" /&gt; 
      &lt;Setter Property="Padding" Value="5" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;Trigger Property="ListBox.AlternationIndex" Value="0"&gt; 
          &lt;Setter Property="Background" Value="Red" /&gt; 
        &lt;/Trigger&gt; 
        &lt;Trigger Property="ListBox.AlternationIndex" Value="1"&gt; 
          &lt;Setter Property="Background" Value="Green" /&gt; 
        &lt;/Trigger&gt; 
        &lt;Trigger Property="ListBox.AlternationIndex" Value="2"&gt; 
          &lt;Setter Property="Background" Value="Blue" /&gt; 
        &lt;/Trigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/ListBox.ItemContainerStyle&gt; 
&lt;/ListBox&gt; </pre>
<p>Here, we set the <kbd>AlternationCount</kbd> property to <kbd>3</kbd>, so we can have three different styles for our items and this pattern will be repeated for all three further items. We make a style for the item containers using the <kbd>ItemContainerStyle</kbd> property.</p>
<p>In this style, we use some simple triggers to change the color of the container background, depending on the value of the <kbd>AlternationIndex</kbd> property. Notice that the <kbd>AlternationCount</kbd> property starts at <kbd>0</kbd>, so the first item will have a red background, the second will have green, the third will have blue, then the pattern will repeat and the fourth will have red, and so on.</p>
<p>Alternatively, we could have declared an <kbd>AlternationConverter</kbd> instance for each property that we wanted to alter and data bind them to the <kbd>AlternationIndex</kbd> property and the converter. We could create the same visual output using this XAML instead:</p>
<pre>&lt;ListBox ItemsSource="{Binding Users}" AlternationCount="3"&gt; 
  &lt;ListBox.Resources&gt; 
    &lt;AlternationConverter x:Key="BackgroundConverter"&gt; 
      &lt;SolidColorBrush&gt;Red&lt;/SolidColorBrush&gt; 
      &lt;SolidColorBrush&gt;Green&lt;/SolidColorBrush&gt; 
      &lt;SolidColorBrush&gt;Blue&lt;/SolidColorBrush&gt; 
    &lt;/AlternationConverter&gt; 
  &lt;/ListBox.Resources&gt; 
  &lt;ListBox.ItemContainerStyle&gt; 
    &lt;Style TargetType="{x:Type ListBoxItem}"&gt; 
      &lt;Setter Property="FontSize" Value="14" /&gt; 
      &lt;Setter Property="Foreground" Value="White" /&gt; 
      &lt;Setter Property="Padding" Value="5" /&gt; 
      &lt;Setter Property="Background" 
        Value="{Binding (ItemsControl.AlternationIndex), <br/>        RelativeSource={RelativeSource Self}, <br/>        Converter={StaticResource BackgroundConverter}}" /&gt; 
    &lt;/Style&gt; 
  &lt;/ListBox.ItemContainerStyle&gt; 
&lt;/ListBox&gt; </pre>
<p>The <kbd>AlternationConverter</kbd> class works by simply returning the item from its collection that relates to the specified <kbd>AlternationIndex</kbd> value, where the first item is returned for index zero. Note that we need to include the parenthesis around the data bound class and property name because it is an Attached Property and we need to use a <kbd>RelativeSource.Self</kbd> binding because the property is set on the item container object itself. Let's see the output of these two code examples:  </p>
<div><img src="img/fe7b34ae-96eb-4c4e-8cbc-9934751acd07.png"/></div>
<p>There is one more useful property that the <kbd>ItemsControl</kbd> class provides and that is the <kbd>GroupStyle</kbd> property, which is used to display the child items in groups. To group items in the UI, we need to accomplish a few simple tasks. We first need to define XAML namespaces for our  <kbd>Converters</kbd> project and the <kbd>ComponentModel</kbd> CLR namespace:</p>
<pre><br/></pre>
<p>Next, we need to data bind a <kbd>CollectionViewSource</kbd> instance with one or more <kbd>PropertyGroupDescription</kbd> elements to our <kbd>Users</kbd> collection from the previous example. We then need to set that as the <kbd>ItemsSource</kbd> value for the <kbd>ItemsControl</kbd> and then set up its <kbd>GroupStyle</kbd>. Let's see the <kbd>StringToFirstLetterConverter</kbd> converter and <kbd>CollectionViewSource</kbd> object that we need to declare in the local <kbd>Resources</kbd> section:</p>
<pre>&lt;Converters:StringToFirstLetterConverter x:Key="StringToFirstLetterConverter" /&gt;<br/>&lt;CollectionViewSource x:Key="GroupedUsers" Source="{Binding MoreUsers}"&gt;<br/>  &lt;CollectionViewSource.GroupDescriptions&gt;<br/>    &lt;PropertyGroupDescription PropertyName="Name" <br/>      Converter="{StaticResource StringToFirstLetterConverter}" /&gt;<br/>  &lt;/CollectionViewSource.GroupDescriptions&gt;<br/>  &lt;CollectionViewSource.SortDescriptions&gt;<br/>    &lt;ComponentModel:SortDescription PropertyName="Name" /&gt;<br/>  &lt;/CollectionViewSource.SortDescriptions&gt;<br/>&lt;/CollectionViewSource&gt;</pre>
<p>We specify the property that we want to use to group items by using the <kbd>PropertyName</kbd> property of the <kbd>PropertyGroupDescription</kbd> element. Note that in our case, we only have a few <kbd>User</kbd> objects, and so there would be no groups if we simply grouped by name. Therefore, we added a converter to return the first letter from each name to group on and specified it using the <kbd>Converter</kbd> property.</p>
<p>We then added a basic <kbd>SortDescription</kbd> element to the <kbd>CollectionViewSource.SortDescriptions</kbd> collection in order to sort the <kbd>User</kbd> objects. We specified the <kbd>Name</kbd> property in the <kbd>PropertyName</kbd> property of the <kbd>SortDescription</kbd> element so that the <kbd>User</kbd> objects will be sorted by name. Let’s see the <kbd>StringToFirstLetterConverter</kbd> class now:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  [ValueConversion(typeof(string), typeof(string))] 
  public class StringToFirstLetterConverter : IValueConverter 
  { 
    public object Convert(object value, Type targetType, object parameter,
      CultureInfo culture) 
    { 
      if (value == null) return DependencyProperty.UnsetValue;<br/>      string stringValue = value.ToString();<br/>      if (stringValue.Length &lt; 1) return DependencyProperty.UnsetValue;
      return stringValue[0]; 
    } 
 
    public object ConvertBack(object value, Type targetType, 
      object parameter, CultureInfo culture) 
    { 
      return DependencyProperty.UnsetValue; 
    } 
  } 
} </pre>
<p>In this converter, we specify the data types that are involved in the implementation of the converter in the <kbd>ValueConversion</kbd> attribute, even though they are the same type. In the <kbd>Convert</kbd> method, we check the validity of our <kbd>value</kbd> input parameter and return the <kbd>DependencyProperty.UnsetValue</kbd> value if it is <kbd>null</kbd>. We then call the <kbd>ToString</kbd> method on it and if it is an empty string, we return the <kbd>DependencyProperty.UnsetValue</kbd> value. For all valid <kbd>string</kbd> values, we simply return the first letter.</p>
<p>As we do not need (or would not be able) to convert anything back using this converter, the <kbd>ConvertBack</kbd> method simply returns the <kbd>DependencyProperty.UnsetValue</kbd> value. By attaching this converter to the <kbd>PropertyGroupDescription</kbd> element, we are now able to group by the first letter of each name. Let's now see how we can declare the <kbd>GroupStyle</kbd> object:</p>
<pre>&lt;ItemsControl ItemsSource="{Binding Source={StaticResource GroupedUsers}}"  
  Background="White" FontSize="14"&gt; 
  &lt;ItemsControl.GroupStyle&gt; 
    &lt;GroupStyle&gt; 
      &lt;GroupStyle.HeaderTemplate&gt; 
        &lt;DataTemplate&gt; 
          &lt;TextBlock Text="{Binding Name, 
            Converter={StaticResource StringToFirstLetterConverter}}" 
            Background="Black" Foreground="White" FontWeight="Bold" 
            Padding="5,4" /&gt;
        &lt;/DataTemplate&gt; 
      &lt;/GroupStyle.HeaderTemplate&gt; 
    &lt;/GroupStyle&gt; 
  &lt;/ItemsControl.GroupStyle&gt; 
  &lt;ItemsControl.ItemTemplate&gt; 
    &lt;DataTemplate DataType="{x:Type DataModels:User}"&gt; 
      &lt;TextBlock Text="{Binding Name}" Foreground="Black" <br/>        Padding="0,2" /&gt;
    &lt;/DataTemplate&gt; 
  &lt;/ItemsControl.ItemTemplate&gt; 
&lt;/ItemsControl&gt; </pre>
<p>Note that we need to use the <kbd>Binding.Source</kbd> property to access the <kbd>CollectionViewSource</kbd> object named <kbd>GroupedUsers</kbd> from the local <kbd>Resources</kbd> section. We then declare the data template that defines what each group header will look like in the <kbd>HeaderTemplate</kbd> property. Here we make use of the <kbd>StringToFirstLetterConverter</kbd> instance that has also been declared in a suitable resource collection and set a few basic style properties.</p>
<p>Next, we specify a second data template, but one that defines what the items in each group should look like. We provide a very simple template that merely spaces the elements slightly and sets a few style properties. Let's see the output of this example:</p>
<div><img class="alignnone size-full wp-image-2020 image-border" src="img/d325ddef-c598-4132-af32-3c1955bb1387.png" style="width:16.50em;height:16.83em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Adorners</h1>
                
            
            
                
<p>An adorner is a special kind of class that is rendered above all UI controls, in what is known as an adorner layer. Adorner elements in this layer will always be rendered on top of the normal WPF controls, regardless of their <kbd>Panel.ZIndex</kbd> property setting. Each adorner is bound to an element of type <kbd>UIElement</kbd> and independently rendered in a position that is relative to the adorned element.</p>
<p>The purpose of the adorner is to provide certain visual cues to the application user. For example, we could use an adorner to display a visual representation of UI elements that are being dragged in a drag and drop operation. Alternatively, we could use an adorner to add handles to a UI control to enable users to resize the element.</p>
<p>As the adorner is added to the adorner layer, it is the adorner layer that is the parent of the adorner, rather than the adorned element. In order to create a custom adorner, we need to declare a class that extends the <kbd>Adorner</kbd> class.</p>
<p>When creating a custom adorner, we need to be aware that we are responsible for writing the code to render its visuals. However, there are a few different ways to construct our adorner graphics; we can use the <kbd>OnRender</kbd> or <kbd>OnRenderSizeChanged</kbd> methods and a drawing context to draw basic lines and shapes, or we can use the <kbd>ArrangeOverride</kbd> method to arrange .NET controls.</p>
<p>Adorners receive events like other .NET controls, although if we don't need to handle them, we can arrange for them to be passed straight through to the adorned element. In these cases, we can set the <kbd>IsHitTestVisible</kbd> property to <kbd>false</kbd> and this will enable pass-through hit-testing of the adorned element. Let's look at an example of a resizing adorner that lets us resize shapes on a canvas.</p>
<p>Before we investigate the adorner class, let's first see how we can use it. Adorners need to be initialized in code, and so a good place to do this is in the <kbd>UserControl.Loaded</kbd> method, when we can be certain that the canvas and its items will have been initialized. Note that as adorners are purely UI related, initializing them in the control's code behind does not present any conflict when using MVVM:</p>
<pre>public AdornerView()<br/>{<br/>  InitializeComponent();<br/>  Loaded += View_Loaded;<br/>}

... 
 
private void View_Loaded(object sender, RoutedEventArgs e) 
{ 
  AdornerLayer adornerLayer = AdornerLayer.GetAdornerLayer(Canvas); 
  foreach (UIElement uiElement in Canvas.Children) 
  { 
    adornerLayer.Add(new ResizeAdorner(uiElement)); 
  } 
} </pre>
<p>We access the adorner layer for the canvas that we will add the adorners to using the <kbd>AdornerLayer.GetAdornerLayer</kbd> method, passing in the canvas as the <kbd>Visual</kbd> input parameter. In this example, we attach an instance of our <kbd>ResizeAdorner</kbd> to each element in the canvas' <kbd>Children</kbd> collection and then add it to the adorner layer.</p>
<p>Now, we just need a <kbd>Canvas</kbd> panel named <kbd>Canvas</kbd> and some shapes to resize:</p>
<pre>&lt;Canvas Name="Canvas"&gt; 
  &lt;Rectangle Canvas.Top="50" Canvas.Left="50" Fill="Lime"  
    Stroke="Black" StrokeThickness="3" Width="150" Height="50" /&gt; 
  &lt;Rectangle Canvas.Top="25" Canvas.Left="250" Fill="Yellow"  
    Stroke="Black" StrokeThickness="3" Width="100" Height="150" /&gt; 
&lt;/Canvas&gt; </pre>
<p>Let's now see the code in our <kbd>ResizeAdorner</kbd> class:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Controls.Primitives; 
using System.Windows.Documents; 
using System.Windows.Input; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Views.Adorners 
{ 
  public class ResizeAdorner : Adorner 
  { 
    private VisualCollection visualChildren; 
    private Thumb top, left, bottom, right; 
 
    public ResizeAdorner(UIElement adornedElement) : base(adornedElement) 
    { 
      visualChildren = new VisualCollection(this); 
      top = InitializeThumb(Cursors.SizeNS, Top_DragDelta); 
      left = InitializeThumb(Cursors.SizeWE, Left_DragDelta); 
      bottom = InitializeThumb(Cursors.SizeNS, Bottom_DragDelta); 
      right = InitializeThumb(Cursors.SizeWE, Right_DragDelta); 
    } 
 
    private Thumb InitializeThumb(Cursor cursor, 
      DragDeltaEventHandler eventHandler) 
    { 
      Thumb thumb = new Thumb(); 
      thumb.BorderBrush = Brushes.Black; 
      thumb.BorderThickness = new Thickness(1); 
      thumb.Cursor = cursor; 
      thumb.DragDelta += eventHandler; 
      thumb.Height = thumb.Width = 6.0; 
      visualChildren.Add(thumb); 
      return thumb; 
    } 
 
    private void Top_DragDelta(object sender, DragDeltaEventArgs e) 
    { 
      FrameworkElement adornedElement = (FrameworkElement)AdornedElement; 
      adornedElement.Height =  
        Math.Max(adornedElement.Height - e.VerticalChange, 6); 
      Canvas.SetTop(adornedElement, 
        Canvas.GetTop(adornedElement) + e.VerticalChange); 
    } 
 
    private void Left_DragDelta(object sender, DragDeltaEventArgs e) 
    { 
      FrameworkElement adornedElement = (FrameworkElement)AdornedElement; 
      adornedElement.Width =  
        Math.Max(adornedElement.Width - e.HorizontalChange, 6); 
      Canvas.SetLeft(adornedElement, 
        Canvas.GetLeft(adornedElement) + e.HorizontalChange); 
    } 
 
    private void Bottom_DragDelta(object sender, DragDeltaEventArgs e) 
    { 
      FrameworkElement adornedElement = (FrameworkElement)AdornedElement; 
      adornedElement.Height =  
        Math.Max(adornedElement.Height + e.VerticalChange, 6); 
    } 
 
    private void Right_DragDelta(object sender, DragDeltaEventArgs e) 
    { 
      FrameworkElement adornedElement = (FrameworkElement)AdornedElement; 
      adornedElement.Width =  
        Math.Max(adornedElement.Width + e.HorizontalChange, 6); 
    } 
 
    protected override void OnRender(DrawingContext drawingContext) 
    { 
      SolidColorBrush brush = new SolidColorBrush(Colors.Transparent); 
      Pen pen = new Pen(new SolidColorBrush(Colors.DeepSkyBlue), 1.0); 
      drawingContext.DrawRectangle(brush, pen,  
        new Rect(-2, -2, AdornedElement.DesiredSize.Width + 4, 
        AdornedElement.DesiredSize.Height + 4)); 
    } 
 
    protected override Size ArrangeOverride(Size finalSize) 
    { 
      top.Arrange(
        new Rect(AdornedElement.DesiredSize.Width / 2 - 3, -8, 6, 6)); 
      left.Arrange(
        new Rect(-8, AdornedElement.DesiredSize.Height / 2 - 3, 6, 6)); 
      bottom.Arrange(new Rect(AdornedElement.DesiredSize.Width / 2 - 3, 
        AdornedElement.DesiredSize.Height + 2, 6, 6)); 
      right.Arrange(new Rect(AdornedElement.DesiredSize.Width + 2,  
        AdornedElement.DesiredSize.Height / 2 - 3, 6, 6)); 
      return finalSize;
    } 
    
    protected override int VisualChildrenCount 
    { 
      get { return visualChildren.Count; } 
    } 
 
    protected override Visual GetVisualChild(int index) 
    { 
      return visualChildren[index]; 
    } 
  } 
} </pre>
<p>Note that we have declared the <kbd>Adorners</kbd> namespace within the <kbd>Views</kbd> project, as this is the only place that it will be used. Inside the class, we declare the <kbd>VisualCollection</kbd> object that will contain the visuals that we want to render and then the visuals themselves, in the shape of <kbd>Thumb</kbd> controls.</p>
<p>We've chosen <kbd>Thumb</kbd> elements because they have built-in functionality that we want to take advantage of. They provide a <kbd>DragDelta</kbd> event that we will use to register the users' mouse movements when they drag each <kbd>Thumb</kbd>. These controls are normally used internally in the <kbd>Slider</kbd> and <kbd>ScrollBar</kbd> controls to enable users to alter values, so they're perfect for our purposes here.</p>
<p>We initialize these objects in the constructor, specifying a custom cursor and a different <kbd>DragDelta</kbd> event handler for each <kbd>Thumb</kbd> control. In these separate event handlers, we use the <kbd>HorizontalChange</kbd> or <kbd>VerticalChange</kbd> properties of the <kbd>DragDeltaEventArgs</kbd> object to specify the distance and direction of the mouse movement that triggered the event.</p>
<p>We use these values to move and/or resize the adorned element by the appropriate amount and direction. Note that we use the <kbd>Math.Max</kbd> method and the value <kbd>6</kbd> in our example to ensure that the adorned element cannot be resized smaller than the size of each <kbd>Thumb</kbd> element and the <kbd>Stroke</kbd> size of each adorned element.</p>
<p>After the four <kbd>DragDelta</kbd> event handlers, we find two different ways to render our adorner visuals. In the first method, we use the <kbd>DrawingContext</kbd> object that is passed into the <kbd>OnRender</kbd> method by the base class to manually draw shapes. This is somewhat similar to the way that we used to draw in the <kbd>Control.Paint</kbd> event handler methods when using <kbd>Windows.Forms</kbd>.</p>
<p>In this overridden method, we draw a rectangle that surrounds our element and is four pixels bigger than it in both dimensions. Note that we define a transparent background for the drawing brush, as we only want to see the rectangle border. Remember that adorner graphics are rendered on top of the adorned element, but we do not want to cover it.</p>
<p>In the <kbd>ArrangeOverride</kbd> method, we use .NET Framework to render our <kbd>Visual</kbd> elements using their <kbd>Arrange</kbd> methods, as we would in a custom panel. Note that we could just as easily render our rectangle border in this method using a <kbd>Rectangle</kbd> element; the <kbd>OnRender</kbd> method was used in this example merely as a demonstration.</p>
<p>In this method, we simply arrange each <kbd>Visual</kbd> element at the relevant position and size in turn. Calculating the appropriate positions can be achieved simply by dividing the width or height of each adorned element in half and subtracting half of the width or height of each thumb element.</p>
<p>Finally, we get to the protected overridden <kbd>VisualChildrenCount</kbd> property and <kbd>GetVisualChild</kbd> method. The <kbd>Adorner</kbd> class extends the <kbd>FrameworkElement</kbd> class and that will normally return either zero or one from the <kbd>VisualChildrenCount</kbd> property, as each instance is normally represented by either no visual, or a single rendered visual.</p>
<p>In our case and other situations when a derived class has multiple visuals to render, it is a requirement of the layout system that the correct number of visuals is specified. For example, if we always returned the value <kbd>2</kbd> from this property, then only two of our thumbs would be rendered on screen.</p>
<p>Likewise, we also need to return the correct item from our visual collection when requested to from the <kbd>GetVisualChild</kbd> method. If, for example, we always returned the first visual from our collection, then only that visual would be rendered, as the same visual cannot be rendered more than once. Let's see what our adorners look like when rendered above each of our shapes:</p>
<div><img class="alignnone size-full wp-image-2021 image-border" src="img/5ace8f73-a97b-45e1-bd69-aa16115d2aec.png" style="width:23.83em;height:13.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying existing controls</h1>
                
            
            
                
<p>When we find that the wide range of existing controls doesn't quite meet our needs, we might think that we need to create some new ones, as we would with other technologies. When using other UI languages, this might be the case, but with WPF, this is not necessarily true, as it provides a number of ways to modify the existing controls to suit our requirements.</p>
<p>As we found out earlier, all classes that extend the <kbd>FrameworkElement</kbd> class have access to the framework's styling capabilities and those that extend the <kbd>Control</kbd> class can have their appearance totally changed through their <kbd>ControlTemplate</kbd> property. All of the existing WPF controls extend these base cases, and so possess these abilities.</p>
<p>In addition to these capabilities that enable us to change the look of the pre-existing WPF controls, we are also able to leverage the power of Attached Properties to add additional functionality to them too. In this section, we will investigate these different ways of modifying the existing controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Styling</h1>
                
            
            
                
<p>Setting the various properties of a control is the simplest way to alter its look and enables us to make either minor or more dramatic changes to it. As most UI elements extend the <kbd>Control</kbd> class, they mostly share the same properties that affect their appearance and alignment. When defining styles for controls, we should specify their type in the <kbd>TargetType</kbd> property, as this helps the compiler to verify that the properties that we are setting actually exist in the class:</p>
<pre>&lt;Button Content="Go"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="Green" /&gt; 
      &lt;Setter Property="Background" Value="White" /&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<p>Failing to do so will result in the compiler stating that the member is not recognized or is not accessible. In these cases, we will need to specify the class type as well, in the format <kbd>ClassName.PropertyName</kbd>:</p>
<pre>&lt;Button Content="Go"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style&gt; 
      &lt;Setter Property="Button.Foreground" Value="Green" /&gt; 
      &lt;Setter Property="Button.Background" Value="White" /&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt;       </pre>
<p>One really useful property that the <kbd>Style</kbd> class declares is the <kbd>BasedOn</kbd> property. Using this property, we can base our styles on other styles and this enables us to create a number of incrementally different versions. Let's highlight this with an example:</p>
<pre>&lt;Style x:Key="TextBoxStyle" TargetType="{x:Type TextBox}"&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Margin" Value="0,0,0,5" /&gt; 
  &lt;Setter Property="Padding" Value="1.5,2" /&gt; 
  &lt;Setter Property="TextWrapping" Value="Wrap" /&gt; 
&lt;/Style&gt; 
&lt;Style x:Key="ReadOnlyTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource TextBoxStyle}"&gt; 
  &lt;Setter Property="IsReadOnly" Value="True" /&gt; 
  &lt;Setter Property="Cursor" Value="Arrow" /&gt; 
&lt;/Style&gt; </pre>
<p>Here, we define a simple style for the textboxes in our application. We name it <kbd>TextBoxStyle</kbd> and then reference it in the <kbd>BasedOn</kbd> property of the second style. This means that all of the property setters and triggers declared in the first style will also apply to the bottom style. In the second style, we add a few further setters to make the applied textbox read-only.</p>
<p>One last point to note is that if we wanted to base a style on the default style of a control, we can use the value that we normally enter into the <kbd>TargetType</kbd> property as the key to identify the style that we want to base the new style on:</p>
<pre>&lt;Style x:Key="ExtendedTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource {x:Type TextBox}}"&gt; 
  ... 
&lt;/Style&gt; </pre>
<p>Let's now move on to take a deeper look into resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Being resourceful</h1>
                
            
            
                
<p>Styles are most often declared in the various <kbd>Resources</kbd> dictionaries of the application, along with various templates, application colors, and brushes. The <kbd>Resources</kbd> property is of type <kbd>ResourceDictionary</kbd> and declared in the <kbd>FrameworkElement</kbd> class and so virtually all UI elements inherit it and can therefore host our styles and other resources.</p>
<p>Although the <kbd>Resources</kbd> property is of type <kbd>ResourceDictionary</kbd>, we do not need to explicitly declare this element:</p>
<pre>&lt;Application.Resources&gt; 
  &lt;ResourceDictionary&gt; 
    &lt;!-- Add resources here --&gt; 
  &lt;/ResourceDictionary&gt; 
&lt;/Application.Resources&gt; </pre>
<p>While there are some occasions when we do need to explicitly declare the <kbd>ResourceDictionary</kbd>, it will be implicitly declared for us if we do not:</p>
<pre>&lt;Application.Resources&gt; 
  &lt;!-- Add Resources here --&gt; 
&lt;/Application.Resources&gt; </pre>
<p>Every resource in each collection must have a key that uniquely identifies them. We use the <kbd>x:Key</kbd> directive to explicitly set this key, however, it can also be set implicitly as well. When we declare styles in any <kbd>Resources</kbd> section, we can specify the <kbd>TargetType</kbd> value alone, without setting the <kbd>x:Key</kbd> directive, in which case the style will be implicitly applied to all elements of the correct type that are in the scope of the style:</p>
<pre>&lt;Resources&gt; 
  &lt;Style TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="Foreground" Value="Green" /&gt; 
    &lt;Setter Property="Background" Value="White" /&gt; 
  &lt;/Style&gt; 
&lt;/Resources&gt; </pre>
<p>In this case, the value for the <kbd>x:Key</kbd> directive is implicitly set to <kbd>{x:Type Button}</kbd>. Alternatively, we can set the <kbd>x:Key</kbd> directive explicitly, so that the style must also be applied explicitly:</p>
<pre>&lt;Resources&gt; 
  &lt;Style x:Key="ButtonStyle"&gt; 
    &lt;Setter Property="Button.Foreground" Value="Green" /&gt; 
    &lt;Setter Property="Button.Background" Value="White" /&gt; 
  &lt;/Style&gt; 
&lt;/Resources&gt; 
... 
&lt;Button Style="{StaticResource ButtonStyle}" Content="Go" /&gt; </pre>
<p>Styles can have both values set as well, as shown in the following code:</p>
<pre>&lt;Resources&gt; 
  &lt;Style x:Key="ButtonStyle" TargetType="{x:Type Button}"&gt; 
    &lt;Setter Property="Foreground" Value="Green" /&gt; 
    &lt;Setter Property="Background" Value="White" /&gt; 
  &lt;/Style&gt; 
&lt;/Resources&gt; </pre>
<p>But a compilation error will be thrown if neither value is set:</p>
<pre>&lt;Resources&gt; 
  &lt;Style&gt; 
    &lt;Setter Property="Foreground" Value="Green" /&gt; 
    &lt;Setter Property="Background" Value="White" /&gt; 
  &lt;/Style&gt; 
&lt;/Resources&gt; </pre>
<p>The preceding XAML would result in the following compilation error:</p>
<pre><strong>The member "Foreground" is not recognized or is not accessible. <br/>The member "Background" is not recognized or is not accessible.</strong></pre>
<p>When a <kbd>StaticResource</kbd> with a specific key is requested, the lookup process first looks in the local control; if it has a style and that style has a resource dictionary, it checks that first; if there is no item with a matching key, it next looks in the resource collection of the control itself.</p>
<p>If there is still no match, the lookup process checks the resource dictionaries of each successive parent control until it reaches the <kbd>MainWindow.xaml</kbd> file. If it still does not find a match, then it will look in the application <kbd>Resources</kbd> section in the <kbd>App.xaml</kbd> file.</p>
<p><kbd>StaticResource</kbd> lookups occur once upon initialization and will suit our requirements for most of the time. When using a <kbd>StaticResource</kbd> to reference one resource that is to be used within another resource, the resource being used must be declared beforehand. That is to say that a <kbd>StaticResource</kbd> lookup from one resource cannot reference another resource that is declared after it in the resource dictionary:</p>
<pre>&lt;Style TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="Foreground" Value="{StaticResource RedBrush}" /&gt; 
&lt;/Style&gt; 
&lt;SolidColorBrush x:Key="RedBrush" Color="Red" /&gt; </pre>
<p>The preceding XAML would result in the following error:</p>
<pre><strong>The resource "RedBrush" could not be resolved.</strong></pre>
<p>Simply moving the declaration of the brush before the style would clear this error and get the application running again. However, there are certain situations when using a <kbd>StaticResource</kbd> to reference a resource isn't suitable. For example, we might need our styles to update during runtime in response to some programmatic or user interaction, such as a changing of the computer theme.</p>
<p>In these cases, we can use a <kbd>DynamicResource</kbd> to reference our resources and can rest assured that our styles will update when the relevant resources are changed. Note that the resource value is not looked up until it is actually requested, so this is perfect for resources that will not be ready until after the application starts. Note the following altered example:</p>
<pre>&lt;Style TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="Foreground" Value="{DynamicResource RedBrush}" /&gt; 
&lt;/Style&gt; 
&lt;SolidColorBrush x:Key="RedBrush" Color="Red" /&gt; </pre>
<p>In this case, there will be no compilation error, as the <kbd>DynamicResource</kbd> will retrieve the value whenever it is set. While it's great to have this ability, it's important not to abuse it, as using the <kbd>DynamicResource</kbd> will negatively affect performance. This is because they repeatedly lookup the value each time it is requested, whether the values have changed or not. For this reason, we should only ever use a <kbd>DynamicResource</kbd> if we really need to.</p>
<p>One final point about resource styles to mention here relates to scope. While this topic has been mentioned elsewhere in this book, it is outlined again here as it is essential to understand the resource lookup procedure. Application resources that are declared in the <kbd>App.xaml</kbd> file are available application-wide, so this is a great place to declare our common styles.</p>
<p>However, this is one of the furthest removed places that we can declare our styles, ignoring external resource dictionaries and theme styles. In general, the rule is that given a resource identifier conflict, the most local resources override those that are declared further away. Therefore, we can define our default styles in the application resources but retain the ability to override them locally.</p>
<p>Conversely, locally declared styles without an <kbd>x:Key</kbd> directive will be implicitly applied locally, but will not be applied to elements of the relevant type that are declared externally. We can, therefore, declare implicit styles in the <kbd>Resources</kbd> section of a panel for example and they will only be applied to elements of the relative type within the panel.</p>
<p> </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Merging resources</h1>
                
            
            
                
<p>If we have a large application and our application resources are becoming overcrowded, we have the option of splitting our default colors, brushes, styles, templates, and other resources into different files. In addition to organizational and maintenance benefits, this also enables our main resource files to be shared amongst our other applications, and so this promotes reusability too.</p>
<p>In order to do this, we first need one or more additional resource files. We can add an additional resource file using Visual Studio, by right-clicking on the relevant project and selecting the Add option and then the Resource Dictionary... option. Upon executing this command, we will be provided with a file like this:</p>
<pre>&lt;ResourceDictionary  
   
  &gt;   
&lt;/ResourceDictionary&gt; </pre>
<p>This is one of the occasions when we do need to explicitly declare the <kbd>ResourceDictionary</kbd> element. Once we have transferred our styles or other resources to this file, we can merge it into our main application resources file like this:</p>
<pre>&lt;Application.Resources&gt; 
  &lt;ResourceDictionary&gt; 
    &lt;!-- Add Resources here... --&gt; 
    &lt;ResourceDictionary.MergedDictionaries&gt; 
      &lt;ResourceDictionary Source="Default Styles.xaml" /&gt; 
      &lt;ResourceDictionary Source="Default Templates.xaml" /&gt; 
    &lt;/ResourceDictionary.MergedDictionaries&gt; 
    &lt;!-- ... or add resources here, but not in both locations --&gt; 
  &lt;/ResourceDictionary&gt; 
&lt;/Application.Resources&gt; </pre>
<p>Note that we do not specify the <kbd>x:Key</kbd> directive for this resource dictionary. In fact, if we did specify this value on the dictionary, we would receive a compilation error:</p>
<pre><strong>The "Key" attribute can only be used on an element that is contained in "IDictionary".</strong></pre>
<p>Note also that we can set the <kbd>ResourceDictionary.MergedDictionaries</kbd> value either above or below our locally declared resources, but not anywhere in the middle of them. Within this property, we can declare another <kbd>ResourceDictionary</kbd> element for each external resource file that we want to merge and specify its location using a <strong>Uniform Resource Identifier</strong> (<strong>URI</strong>) in the <kbd>Source</kbd> property.</p>
<p> </p>
<p>If our external resource files reside in our startup project with our <kbd>App.xaml</kbd> file, we can reference them with relative paths, as shown in the preceding example. Otherwise, we will need to use the Pack URI notation. To reference a resource file from a referenced assembly, we would need to use the following format:</p>
<pre>pack://application:,,,/ReferencedAssembly;component/ResourceFile.xaml </pre>
<p>In our case, assuming that we had some resource files in a folder named <kbd>Styles</kbd> in a separate project, or other referenced assembly, we would merge the file using the following path:</p>
<pre>&lt;ResourceDictionary 
  Source="pack://application:,,,/CompanyName.ApplicationName.Resources;
  component/Styles/Control Styles.xaml" /&gt;</pre>
<p>When merging resource files, it is important to understand how naming conflicts will be resolved. Although the <kbd>x:Key</kbd> directives that we set on our resources must each be unique within their declared resource dictionary, it is perfectly legal to have duplicated key values within separate resource files. As such, there is an order of priority that will be followed in these cases. Let's see an example.</p>
<p>Imagine that we have the aforementioned referenced resource file in a separate project and in that file, we have this resource:</p>
<pre>&lt;SolidColorBrush x:Key="Brush" Color="Red" /&gt; </pre>
<p>Note that we would need to add a reference to the <kbd>System.Xaml</kbd> assembly in that project in order to avoid errors. Now imagine that we also have the locally declared <kbd>Default Styles.xaml</kbd> resource file that was referenced in the previous example and in that file, we have this resource:</p>
<pre>&lt;SolidColorBrush x:Key="Brush" Color="Blue" /&gt; </pre>
<p>Let's add a <kbd>Default Styles 2.xaml</kbd> resource file with this resource in it:</p>
<pre>&lt;SolidColorBrush x:Key="Brush" Color="Orange" /&gt; </pre>
<p>Now, let's say that we merge all of these resource files and add this additional resource in our application resource file:</p>
<pre>&lt;Application.Resources&gt; 
  &lt;ResourceDictionary&gt; 
    &lt;ResourceDictionary.MergedDictionaries&gt; 
      &lt;ResourceDictionary Source="Default Styles.xaml" /&gt; 
      &lt;ResourceDictionary Source="Default Styles 2.xaml" /&gt; 
      &lt;ResourceDictionary Source="pack://application:,,,/ 
        CompanyName.ApplicationName.Resources; 
        component/Styles/Control Styles.xaml" /&gt; 
    &lt;/ResourceDictionary.MergedDictionaries&gt; 
    &lt;SolidColorBrush x:Key="Brush" Color="Green" /&gt; 
    ... 
  &lt;/ResourceDictionary&gt; 
&lt;/Application.Resources&gt; </pre>
<p>Finally, let's imagine that we have this in the XAML of one of our Views:</p>
<pre>&lt;Button Content="Go"&gt; 
  &lt;Button.Resources&gt; 
    &lt;SolidColorBrush x:Key="Brush" Color="Cyan" /&gt; 
  &lt;/Button.Resources&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="{StaticResource Brush}" /&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
 &lt;/Button&gt; </pre>
<p>Also, let's assume that we have this in the local resources of that file:</p>
<pre>&lt;UserControl.Resources&gt; 
  &lt;SolidColorBrush x:Key="Brush" Color="Purple" /&gt; 
&lt;/UserControl.Resources&gt; </pre>
<p>When running the application, our button text will be cyan, because the main rule of resource scope is that the highest priority resource that will be used will always be the most locally declared resource. If we removed or commented out the local brush declaration, the button text would then become purple when the application was next run.</p>
<p>If we removed the local purple brush resource from the control's <kbd>Resources</kbd> section, the application resources would be searched next in an attempt to resolve the <kbd>Brush</kbd> resource key. The next general rule is that the latest declared resource will be resolved. In this way, the button text would then become green, because of the locally declared resource in the <kbd>App.xaml</kbd> file, which would override the values from the merged dictionaries.</p>
<p>However, if this green brush resource was removed, an interesting thing would happen. Given the recently stated rules, we might expect that the button text would then be set to red by the <kbd>Control Styles.xaml</kbd> resource file from the referenced assembly. Instead, it will be set to orange by the resource in the <kbd>Default Styles 2.xaml</kbd> file.</p>
<p> </p>
<p>This is the result of a combination of the two rules together. The two locally declared resource files have a higher priority than the resource file from the referenced assembly because they have been declared more locally than it. The second of the two locally declared resource files takes precedence over the first because it was declared after the first.</p>
<p>If we removed the reference to the second of the locally declared resource files, the text would then be set to blue by the resource in the <kbd>Default Styles.xaml</kbd> file. If we then removed the reference to this file, we would finally see the red button text that would be set by the <kbd>Control Styles.xaml</kbd> file from the referenced assembly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Triggering changes</h1>
                
            
            
                
<p>In WPF, we have a number of <kbd>Trigger</kbd> classes that enable us to modify controls, albeit most commonly, just temporarily. All of them extend the <kbd>TriggerBase</kbd> base class and therefore inherit its <kbd>EnterActions</kbd> and <kbd>ExitActions</kbd> properties. These two properties enable us to specify one or more <kbd>TriggerAction</kbd> objects to apply when the trigger becomes active and/or inactive respectively.</p>
<p>While most trigger types also contain a <kbd>Setters</kbd> property that we can use to define one or more property setters that should occur when a certain condition is met, the <kbd>EventTrigger</kbd> class does not. Instead, it provides an <kbd>Actions</kbd> property that enables us to set one or more <kbd>TriggerAction</kbd> objects to be applied when the trigger becomes active.</p>
<p>Furthermore, unlike the other triggers, the <kbd>EventTrigger</kbd> class has no concept of state termination. This means that the action applied by the <kbd>EventTrigger</kbd> will not be undone when the triggering condition is no longer true. If you hadn't already guessed this, the conditions that trigger the <kbd>EventTrigger</kbd> instances are events, or <kbd>RoutedEvent</kbd> objects more specifically. Let's investigate this type of trigger first with a simple example that we saw in the <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>:</p>
<pre>&lt;Rectangle Width="300" Height="300" Fill="Orange"&gt; 
  &lt;Rectangle.Triggers&gt; 
    &lt;EventTrigger RoutedEvent="Loaded"&gt; 
      &lt;BeginStoryboard&gt; 
        &lt;Storyboard Storyboard.TargetProperty="Width"&gt; 
          &lt;DoubleAnimation Duration="0:0:1" To="50" AutoReverse="True"  
            RepeatBehavior="Forever" /&gt; 
        &lt;/Storyboard&gt; 
      &lt;/BeginStoryboard&gt; 
    &lt;/EventTrigger&gt; 
  &lt;/Rectangle.Triggers&gt; 
&lt;/Rectangle&gt; </pre>
<p>In this example, the trigger condition is met when the <kbd>FrameworkElement.Loaded</kbd> event is raised. The action that is applied is the start of the declared animation. Note that the <kbd>BeginStoryboard</kbd> class actually extends the <kbd>TriggerAction</kbd> class and this explains how we are able to declare it within the trigger. This action will be implicitly added into the <kbd>TriggerActionCollection</kbd> of the <kbd>EventTrigger</kbd> object, although we could have explicitly set it as follows:</p>
<pre>&lt;EventTrigger RoutedEvent="Loaded"&gt; 
  &lt;EventTrigger.Actions&gt; 
    &lt;BeginStoryboard&gt; 
      &lt;Storyboard Storyboard.TargetProperty="Width"&gt; 
        &lt;DoubleAnimation Duration="0:0:1" To="50" AutoReverse="True"  
          RepeatBehavior="Forever" /&gt; 
      &lt;/Storyboard&gt; 
    &lt;/BeginStoryboard&gt; 
  &lt;/EventTrigger.Actions&gt; 
&lt;/EventTrigger&gt; </pre>
<p>In addition to the <kbd>EventTrigger</kbd> class, there are also <kbd>Trigger</kbd>, <kbd>DataTrigger</kbd>, <kbd>MultiTrigger</kbd> and <kbd>MultiDataTrigger</kbd> classes that enable us to set properties or control animations when a certain condition, or multiple conditions in the case of the multi triggers, are met. Each has its own merits, but apart from the <kbd>EventTrigger</kbd> class, which can be used in any trigger collection, there are some restrictions on where we can use them.</p>
<p>Each control that extends the <kbd>FrameworkElement</kbd> class has a <kbd>Triggers</kbd> property of type <kbd>TriggerCollection</kbd>, that enable us to specify our triggers. However, if you've ever tried to declare a trigger there, then you're probably aware that we are only allowed to define triggers of type <kbd>EventTrigger</kbd> there.</p>
<p>However, there are further trigger collections that we can use to declare our other types of triggers. When defining a <kbd>ControlTemplate</kbd>, we have access to the <kbd>ControlTemplate.Triggers</kbd> collection. For all other requirements, we can declare our other triggers in the <kbd>Style.Triggers</kbd> collection. Remember that triggers defined in styles have a higher priority than those declared in templates.</p>
<p>Let's now take a look at the remaining types of triggers and what they can do for us. We start with the most simple, the <kbd>Trigger</kbd> class. Note that anything that the property trigger can do, the <kbd>DataTrigger</kbd> class can also do. However, the property trigger syntax is simpler and does not involve data binding and so it is more efficient.</p>
<p> </p>
<p>There are, however, a few requirements to using a property trigger and they are as follows. The relevant property must be a Dependency Property. Unlike the <kbd>EventTrigger</kbd> class, the other triggers do not specify actions to be applied when the trigger condition is met, but property setters instead.</p>
<p>We are able to specify one or more <kbd>Setter</kbd> objects within each <kbd>Trigger</kbd> object and they will also be implicitly added to the trigger's <kbd>Setters</kbd> property collection if we do not explicitly specify it. Note that also unlike the <kbd>EventTrigger</kbd> class, all other triggers will return the original property value when the trigger condition is no longer satisfied. Let's look at a simple example:</p>
<pre>&lt;Button Content="Go"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="Black" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
          &lt;Setter Property="Foreground" Value="Red" /&gt; 
        &lt;/Trigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<p>Here we have a button that will change the color of its text when the user mouse s over it. Unlike the <kbd>EventTrigger</kbd> however, its text color will return to its previously set color when the mouse is no longer over the button. Note also that property triggers use the properties of the controls that they are declared in for their conditions, as they have no way of specifying any other target.</p>
<p>As previously mentioned, the <kbd>DataTrigger</kbd> class can also perform this same binding. Let's see what that might look like:</p>
<pre>&lt;Button Content="Go"&gt; 
  &lt;Button.Style&gt; 
    &lt;Style TargetType="{x:Type Button}"&gt; 
      &lt;Setter Property="Foreground" Value="Black" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;DataTrigger Binding="{Binding IsMouseOver,  
          RelativeSource={RelativeSource Self}}" Value="True"&gt; 
          &lt;Setter Property="Foreground" Value="Red" /&gt; 
        &lt;/DataTrigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/Button.Style&gt; 
&lt;/Button&gt; </pre>
<p>As you can see, when using a <kbd>DataTrigger</kbd>, instead of setting the <kbd>Property</kbd> property of the <kbd>Trigger</kbd> class, we need to set the <kbd>Binding</kbd> property instead. In order to achieve the same functionality as the property trigger, we also need to specify the <kbd>RelativeSource.Self</kbd> enumeration member to set the binding source to the control that is declaring the trigger.</p>
<p>The general rule of thumb is that when we are able to use a simple property trigger that uses a property of the host control in its condition, we should use the <kbd>Trigger</kbd> class. When we need to use a property of another control, or a data object in our trigger condition, we should use a <kbd>DataTrigger</kbd>. Let's look at an interesting practical example now:</p>
<pre>&lt;Style x:Key="TextBoxStyle" TargetType="{x:Type TextBox}"&gt; 
  &lt;Style.Triggers&gt; 
    &lt;DataTrigger Binding="{Binding DataContext.IsEditable,  
      RelativeSource={RelativeSource AncestorType={x:Type UserControl}},
      FallbackValue=True}" Value="False"&gt; 
      &lt;Setter Property="IsReadOnly" Value="True" /&gt; 
    &lt;/DataTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<p>In this style, we added a <kbd>DataTrigger</kbd> element that data binds to an <kbd>IsEditable</kbd> property that we could declare in a View Model class, that would determine whether the users could edit the data in the controls on screen or not. This would assume that an instance of the View Model was correctly set as the <kbd>UserControl.DataContext</kbd> property.</p>
<p>If the value of the <kbd>IsEditable</kbd> property was <kbd>false</kbd>, then the <kbd>TextBox.IsReadOnly</kbd> property would be set to <kbd>true</kbd> and the control would become un-editable. Using this technique, we could make all of the controls in a form editable or un-editable by setting this property from the View Model.</p>
<p>The triggers that we have looked at so far have all used a single condition to trigger their actions or property changes. However, there are occasionally situations when we might need more than a single condition to trigger our property changes. For example, in one situation, we might want one particular style, and in another situation, we might want a different look. Let's see an example:</p>
<pre>&lt;Style x:Key="ButtonStyle" TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="Foreground" Value="Black" /&gt; 
  &lt;Style.Triggers&gt; 
    &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
      &lt;Setter Property="Foreground" Value="Red" /&gt; 
    &lt;/Trigger&gt; 
    &lt;MultiTrigger&gt; 
      &lt;MultiTrigger.Conditions&gt; 
        &lt;Condition Property="IsFocused" Value="True" /&gt; 
        &lt;Condition Property="IsMouseOver" Value="True" /&gt; 
      &lt;/MultiTrigger.Conditions&gt; 
      &lt;Setter Property="Foreground" Value="Green" /&gt; 
    &lt;/MultiTrigger&gt; 
  &lt;/Style.Triggers&gt; 
&lt;/Style&gt; </pre>
<p>In this example, we have two triggers. The first will change the button text to red when the mouse is over it. The second will change the button text to green if the mouse is over it <em>and</em> the button is focused.</p>
<p>Note that we had to declare the two triggers in this order, as triggers are applied from top to bottom. Had we swapped their order, then the text would never change to green because the single trigger would always override the value set by the first one.</p>
<p>We can specify as many <kbd>Condition</kbd> elements as we need within the <kbd>Conditions</kbd> collection and as many setters as we need within the <kbd>MultiTrigger</kbd> element itself. However, every condition must return true in order for the setters or other trigger actions to be applied.</p>
<p>The same can be said for the last trigger type to be introduced here, the <kbd>MultiDataTrigger</kbd>. The difference between this trigger and the previous one is the same as that between the property trigger and the data trigger. That is, the data and multi-data triggers have a much wider range of target sources, while triggers and multi triggers only work with properties of the local control:</p>
<pre>&lt;StackPanel&gt; 
  &lt;CheckBox Name="ShowErrors" Content="Show Errors" Margin="0,0,0,10" /&gt; 
  &lt;TextBlock&gt; 
    &lt;TextBlock.Style&gt; 
      &lt;Style TargetType="{x:Type TextBlock}"&gt; 
        &lt;Setter Property="Text" Value="No Errors" /&gt; 
        &lt;Style.Triggers&gt; 
          &lt;MultiDataTrigger&gt; 
            &lt;MultiDataTrigger.Conditions&gt; 
              &lt;Condition Binding="{Binding IsValid}" Value="False" /&gt; 
              &lt;Condition Binding="{Binding IsChecked,
                ElementName=ShowErrors}" Value="True" /&gt; 
            &lt;/MultiDataTrigger.Conditions&gt; 
            &lt;MultiDataTrigger.Setters&gt; 
              &lt;Setter Property="Text" Value="{Binding ErrorList}" /&gt; 
            &lt;/MultiDataTrigger.Setters&gt; 
          &lt;/MultiDataTrigger&gt; 
        &lt;/Style.Triggers&gt; 
      &lt;/Style&gt; 
    &lt;/TextBlock.Style&gt; 
  &lt;/TextBlock&gt; 
  ... 
&lt;/StackPanel&gt; </pre>
<p>This example demonstrates the wider reach of the <kbd>MultiDataTrigger</kbd> class, due to its access to the wide range of binding sources. We have a <kbd>Show Errors</kbd> checkbox, a <kbd>No Errors</kbd> textblock, and let's say, some other form fields that are not displayed here. One of the conditions of this trigger uses the <kbd>ElementName</kbd> property to set the binding source to the checkbox and requires it to be checked.</p>
<p>The other condition binds to an <kbd>IsValid</kbd> property from our View Model that would be set to <kbd>true</kbd> if there were no validation errors. The idea is that when the checkbox is checked and there are validation errors, the <kbd>Text</kbd> property of the <kbd>TextBlock</kbd> element will be data bound to another View Model property named <kbd>ErrorList</kbd>, which could output a description of the validation errors.</p>
<p>Also note that in this example, we explicitly declared the <kbd>Setters</kbd> collection property and defined our setter within it. However, that is optional and we could have implicitly added the setter to the same collection without declaring the collection, as shown in the previous <kbd>MultiTrigger</kbd> example.</p>
<p>Before moving onto the next topic, let's take a moment to investigate the <kbd>EnterActions</kbd> and <kbd>ExitActions</kbd> properties of the <kbd>TriggerBase</kbd> class that enable us to specify one or more <kbd>TriggerAction</kbd> objects to apply when the trigger becomes active and/or inactive respectively.</p>
<p>Note that we cannot specify style setters in these collections, as they are not <kbd>TriggerAction</kbd> objects; setters can be added to the <kbd>Setters</kbd> collection. Instead, we use these properties to start animations when the trigger becomes active and/or inactive. To do that, we need to add a <kbd>BeginStoryboard</kbd> element, which extends the <kbd>TriggerAction</kbd> class. Let's see an example:</p>
<pre>&lt;TextBox Width="200" Height="28"&gt; 
  &lt;TextBox.Style&gt; 
    &lt;Style TargetType="{x:Type TextBox}"&gt; 
      &lt;Setter Property="Opacity" Value="0.25" /&gt; 
      &lt;Style.Triggers&gt; 
        &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
          &lt;Trigger.EnterActions&gt; 
            &lt;BeginStoryboard&gt; 
              &lt;Storyboard Storyboard.TargetProperty="Opacity"&gt; 
                &lt;DoubleAnimation Duration="0:0:0.25" To="1.0" /&gt; 
              &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
          &lt;/Trigger.EnterActions&gt; 
          &lt;Trigger.ExitActions&gt; 
            &lt;BeginStoryboard&gt; 
              &lt;Storyboard Storyboard.TargetProperty="Opacity"&gt; 
                &lt;DoubleAnimation Duration="0:0:0.25" To="0.25" /&gt; 
              &lt;/Storyboard&gt; 
            &lt;/BeginStoryboard&gt; 
          &lt;/Trigger.ExitActions&gt; 
        &lt;/Trigger&gt; 
      &lt;/Style.Triggers&gt; 
    &lt;/Style&gt; 
  &lt;/TextBox.Style&gt; 
&lt;/TextBox&gt; </pre>
<p>In this example, the <kbd>Trigger</kbd> condition relates to the <kbd>IsMouseOver</kbd> property of the <kbd>TextBox</kbd> control. Note that declaring our animations in the <kbd>EnterActions</kbd> and <kbd>ExitActions</kbd> properties when using the <kbd>IsMouseOver</kbd> property is effectively the same as having two <kbd>EventTrigger</kbd> elements, one for the <kbd>MouseEnter</kbd> event and one for <kbd>MouseLeave</kbd> event.</p>
<p>In this example, the animation in the <kbd>EnterActions</kbd> collection will start as the user's mouse cursor enters the control and the animation in the <kbd>ExitActions</kbd> collection will start as the user's mouse cursor leaves the control.</p>
<p>We'll thoroughly cover animations later, in <a href="83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml">Chapter 7</a>, <em>Mastering Practical Animations</em>, but in short, the animation that starts as the user's mouse cursor enters the control will fade in the control from being almost transparent to being opaque.</p>
<p>The other animation will return the <kbd>TextBox</kbd> control to an almost transparent state when the user's mouse cursor leaves the control. This creates a nice effect when a mouse is dragged over a number of controls with this style. Now that we have a good understanding of triggers, let's move on to find other ways of customizing the standard .NET controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Templating controls</h1>
                
            
            
                
<p>While we can greatly vary the look of each control using styles alone, there are occasionally situations when we need to alter their template to achieve our goal. For example, there is no direct way to change the background color of a button through styles alone. In these situations, we need to alter the control's default template.</p>
<p>All UI elements that extend the <kbd>Control</kbd> class provide access to its <kbd>Template</kbd> property. This property is of type <kbd>ControlTemplate</kbd> and enables us to completely replace the originally declared template that defines the normal look of the control. We saw a simple example in the <a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>, but let's now have a look at another example:</p>
<pre>&lt;Button Content="Go" Width="100" HorizontalAlignment="Center"&gt; 
  &lt;Button.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
      &lt;Grid&gt; 
        &lt;Ellipse Fill="Orange" Stroke="Black" StrokeThickness="3"  
          Height="{Binding ActualWidth,  
          RelativeSource={RelativeSource Self}}" /&gt; 
        &lt;ContentPresenter HorizontalAlignment="Center"  
          VerticalAlignment="Center" TextElement.FontSize="18"  
          TextElement.FontWeight="Bold" /&gt; 
      &lt;/Grid&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/Button.Template&gt;   
&lt;/Button&gt; </pre>
<p>Here, we have a button that we have altered to look like a circle. It is very basic, as we have not bothered to define any mouseover or click effects, but it shows that there is nothing scary about overriding the default template of a control and that it is simple to achieve:</p>
<div><img class="alignnone size-full wp-image-2022 image-border" src="img/7b728e6a-0fac-480f-9952-0addb06bb33a.png" style="width:13.42em;height:13.33em;"/></div>
<p>Note that the <kbd>ContentPresenter</kbd> element is declared after the <kbd>Ellipse</kbd> element because the ellipse is not a content control and cannot have another element set as its content. This results in the content being drawn on top of the ellipse. A side effect of this is that we therefore need to add a panel inside the template, to enable us to provide more than a single piece of content.</p>
<p>Also note that as with styles, we need to specify the <kbd>TargetType</kbd> property of the template. To clarify this a little, we need to specify it if we want to data bind to any properties of the control, or if the template contains a <kbd>ContentPresenter</kbd> element. Omitting this declaration will not raise a compilation error in the latter case, but the content will simply not appear in our templated control. It is therefore good practice to always set this property to the appropriate type.</p>
<p>However, unlike styles, if we declared a <kbd>ControlTemplate</kbd> and set its <kbd>TargetType</kbd> property in a <kbd>Resources</kbd> collection without specifying the <kbd>x:Key</kbd> directive, it would not be implicitly applied to all buttons in the application. In this case, we would receive a compilation error:</p>
<pre><strong>Each dictionary entry must have an associated key.</strong></pre>
<p>Instead, we need to set the <kbd>x:Key</kbd> directive and explicitly apply the template to the <kbd>Template</kbd> property of the control. If we want our template to be applied to every control of that type then we need to set it in the default style for that type. In this case, we need to <em>not</em> set the <kbd>x:Key</kbd> directive of the style, so that it will be implicitly applied:</p>
<pre>&lt;ControlTemplate x:Key="ButtonTemplate" TargetType="{x:Type Button}"&gt; 
  ... 
&lt;/ControlTemplate&gt; 
&lt;Style TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="Template" Value="{StaticResource ButtonTemplate}" /&gt; 
&lt;/Style&gt; </pre>
<p>Note that we would not typically hard code property values as we did in this template example, unless we did not want the users of our framework to be able to set their own colors on our templated controls. More often than not, we would make proper use of the <kbd>TemplateBinding</kbd> class to apply the values set from outside the control to the inner controls defined within our template:</p>
<pre>&lt;Button Content="Go" Width="100" HorizontalAlignment="Center"  
  Background="Orange" HorizontalContentAlignment="Center"  
  VerticalContentAlignment="Center" FontSize="18"&gt; 
  &lt;Button.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
      &lt;Grid&gt; 
        &lt;Ellipse Fill="{TemplateBinding Background}"  
          Stroke="{TemplateBinding Foreground}" StrokeThickness="3"  
          Height="{Binding ActualWidth,  
          RelativeSource={RelativeSource Self}}" /&gt; 
        &lt;ContentPresenter HorizontalAlignment="{TemplateBinding  
          HorizontalContentAlignment}"  
          VerticalAlignment="{TemplateBinding  
          VerticalContentAlignment}" 
          TextElement.FontWeight="{TemplateBinding FontWeight}"
          TextElement.FontSize="{TemplateBinding FontSize}" /&gt; 
      &lt;/Grid&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/Button.Template&gt;   
&lt;/Button&gt; </pre>
<p>While this example is now far more verbose, it is also more practical and would enable users to set their own button properties. Setting this template in a default style would make the templated control far more reusable. Note that now, the hard coded values are made on the button control itself, with the exception of the <kbd>StrokeThickness</kbd> property.</p>
<p>There is no suitable property on the <kbd>Button</kbd> class that we could use to expose this inner control property. If this was a problem for us, we could expose the value of that property in a custom Attached Property and data bind to it on the button as follows:</p>
<pre>&lt;Button Attached:ButtonProperties.StrokeThickness="3" ... /&gt; </pre>
<p>And we could do the following inside the control template:</p>
<pre>&lt;Ellipse StrokeThickness=<br/>  "{Binding (Attached:ButtonProperties.StrokeThickness)}" ... /&gt; </pre>
<p>However, even though we have improved our template, there are certain elements defined in the default templates that affect the way their containing controls look or work. If we remove these elements, as we have done in the preceding example, we will break that default functionality. For example, our example button no longer has focusing or interaction effects.</p>
<p>Sometimes, we may only need to slightly adjust the original template, in which case, we would typically start with the default <kbd>ControlTemplate</kbd> and then make our slight adjustment to it. If we had done this with our button example and simply replaced the visual aspects, then we could have retained the original interactivity with it.</p>
<p>In days gone by, it could be quite difficult to find the default control templates for the various controls. We would previously need to try and track them down on the <a href="http://docs.microsoft.com">docs.microsoft.com</a> website, or use Blend; now, however, we can use Visual Studio to provide it for us.</p>
<p>In the WPF designer, select the relevant control, or click on it with the mouse in a XAML file. With the relevant control selected or focused, press the <em>F4</em> key on your keyboard to open the Properties window. Next, open the Miscellaneous category to find the Template property, or type <kbd>Template</kbd> in the search field at the top of the Properties window.</p>
<p>Click on the little square to the right of the Template value field and select the Convert to New Resource... item in the template options tooltip. In the popup dialog window that appears, name the new <kbd>ControlTemplate</kbd> to be added and decide where you want it to be defined:</p>
<div><img class="alignnone size-full wp-image-2023 image-border" src="img/ba4093df-71fa-4c6f-a565-632761fa496b.png" style="width:30.33em;height:16.33em;"/></div>
<p>Once you have entered the required details, click the OK button to create a copy of the default template of your selected control in your desired location. As an example, let's take a look at the default control template of the <kbd>TextBox</kbd> control:</p>
<pre>&lt;ControlTemplate TargetType="{x:Type TextBox}"&gt; 
  &lt;Border Name="border" BorderBrush="{TemplateBinding BorderBrush}"  
    BorderThickness="{TemplateBinding BorderThickness}"  
    Background="{TemplateBinding Background}"  
    SnapsToDevicePixels="True"&gt; 
    &lt;ScrollViewer Name="PART_ContentHost" Focusable="False"  
      HorizontalScrollBarVisibility="Hidden"  
      VerticalScrollBarVisibility="Hidden" /&gt; 
  &lt;/Border&gt; 
  &lt;ControlTemplate.Triggers&gt; 
    &lt;Trigger Property="IsEnabled" Value="False"&gt; 
      &lt;Setter Property="Opacity" TargetName="border" Value="0.56" /&gt; 
    &lt;/Trigger&gt; 
    &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
      &lt;Setter Property="BorderBrush" TargetName="border"  
        Value="#FF7EB4EA" /&gt; 
    &lt;/Trigger&gt; 
    &lt;Trigger Property="IsKeyboardFocused" Value="True"&gt; 
      &lt;Setter Property="BorderBrush" TargetName="border"  
        Value="#FF569DE5" /&gt; 
    &lt;/Trigger&gt; 
  &lt;/ControlTemplate.Triggers&gt; 
&lt;/ControlTemplate&gt; </pre>
<p>As we can see, most of the properties set on the inner controls have been exposed to the <kbd>TextBox</kbd> control through the use of the <kbd>TemplateBinding</kbd> class. At the end of the template are the triggers that react to various states, such as focus, mouseover, and enabled states.</p>
<p>However, inside the <kbd>Border</kbd> element, we see a <kbd>ScrollViewer</kbd> named <kbd>PART_ContentHost</kbd>. The fact that this is named with the <kbd>PART_</kbd> prefix specifies that this control is required within this template. All named parts of each UI element will be listed on the <em>[ControlType] Styles and Templates</em> pages on <a href="http://www.docs.microsoft.com">docs.microsoft.com</a>.</p>
<p>This named part control is required in the textbox because when the textbox is initialized, it programmatically adds the <kbd>TextBoxView</kbd> and <kbd>CaretElement</kbd> objects into the <kbd>ScrollViewer</kbd> object and these are the predominant elements that make up the textbox's functionality.</p>
<p>These specially named elements also need to be registered within the declaring class and we'll find out more about that later in the chapter as well. It is therefore important that we include these named controls in our custom templates if we want to keep the existing functionality.</p>
<p>Note that we will not receive any compilation errors or even trace warnings if we do not include these named controls, and we are free to leave them out if we do not require their relevant functionality. This following example, while hardly functional, it still perfectly valid:</p>
<pre>&lt;TextBox Text="Hidden Text Box"&gt; 
  &lt;TextBox.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type TextBox}"&gt; 
      &lt;ContentPresenter Content="{TemplateBinding Text}" /&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/TextBox.Template&gt; 
&lt;/TextBox&gt; </pre>
<p>Although this <kbd>TextBox</kbd> control will indeed display the specified text value, it will have no containing box like a normal <kbd>TextBox</kbd> element would. What will happen when this template is rendered is that the <kbd>ContentPresenter</kbd> element will see a <kbd>string</kbd> and default to displaying it in a <kbd>TextBlock</kbd> element.</p>
<p>Its <kbd>Text</kbd> property will still be data bound to the <kbd>Text</kbd> property of our <kbd>TextBox</kbd> control and so, when focused, it will still behave like a normal <kbd>TextBox</kbd> element and enable us to enter text. Of course, we won't see when it's focused because we didn't add any triggers to make that happen, and there won't be a caret as the <kbd>CaretElement</kbd> object will no longer be added.</p>
<p>Instead, if we simply supply the required named control, even without anything else, we'll still regain most of the original functionality:</p>
<pre>&lt;TextBox Name="Text" Text="Does this work?"&gt; 
  &lt;TextBox.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type TextBox}"&gt; 
      &lt;ScrollViewer Margin="0" Name="PART_ContentHost" /&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/TextBox.Template&gt; 
&lt;/TextBox&gt; </pre>
<p>Now, when we run our application, we have the caret and text cursor when the mouse is over the <kbd>TextBox</kbd> control, and so we have regained more of the functionality, but not the look. However usually, the best option is to keep as much of the original template as we can and only change the parts that we really need to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching properties</h1>
                
            
            
                
<p>When using WPF, we have one further tool at our disposal to enable us to manipulate the built-in controls and avoid the need to create new ones. We are, of course, discussing Attached Properties, so let's extend an example that we started looking at in <a href="" target="_blank"/><a href="2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml">Chapter 4</a>, <em>Becoming Proficient with Data Binding</em>.</p>
<p>In order to create a button that will enable us to set a second tooltip message to display when the control is disabled, we'll need to declare two Attached Properties. One will hold the disabled tooltip message and the other will be the previously mentioned read-only property that temporarily holds onto the original tooltip value. Let's look at our full <kbd>ButtonProperties</kbd> class now:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.Views.Attached 
{ 
  public class ButtonProperties : DependencyObject 
  { 
    private static readonly DependencyPropertyKey  
      originalToolTipPropertyKey =  
      DependencyProperty.RegisterAttachedReadOnly("OriginalToolTip", 
      typeof(string), typeof(ButtonProperties),  
      new FrameworkPropertyMetadata(default(string))); 
 
    public static readonly DependencyProperty OriginalToolTipProperty =  
      originalToolTipPropertyKey.DependencyProperty; 
 
    public static string GetOriginalToolTip( 
      DependencyObject dependencyObject) 
    { 
      return  
        (string)dependencyObject.GetValue(OriginalToolTipProperty); 
    } 
 
    public static DependencyProperty DisabledToolTipProperty =  
      DependencyProperty.RegisterAttached("DisabledToolTip",  
      typeof(string), typeof(ButtonProperties),  
      new UIPropertyMetadata(string.Empty, OnDisabledToolTipChanged)); 
 
    public static string GetDisabledToolTip(
      DependencyObject dependencyObject) 
    { 
      return (string)dependencyObject.GetValue(  
        DisabledToolTipProperty); 
    } 
 
    public static void SetDisabledToolTip(
      DependencyObject dependencyObject, string value) 
    { 
      dependencyObject.SetValue(DisabledToolTipProperty, value); 
    } 
 
    private static void OnDisabledToolTipChanged(DependencyObject  
      dependencyObject, DependencyPropertyChangedEventArgs e) 
    { 
      Button button = dependencyObject as Button;  
      ToolTipService.SetShowOnDisabled(button, true); 
      if (e.OldValue == null &amp;&amp; e.NewValue != null)  
        button.IsEnabledChanged += Button_IsEnabledChanged; 
      else if (e.OldValue != null &amp;&amp; e.NewValue == null)  
        button.IsEnabledChanged -= Button_IsEnabledChanged; 
    } 
 
    private static void Button_IsEnabledChanged(object sender,  
      DependencyPropertyChangedEventArgs e) 
    { 
      Button button = sender as Button; 
      if (GetOriginalToolTip(button) == null)  
        button.SetValue(originalToolTipPropertyKey,  
        button.ToolTip.ToString()); 
      button.ToolTip = (bool)e.NewValue ?  
        GetOriginalToolTip(button) : GetDisabledToolTip(button); 
    } 
  } 
} </pre>
<p class="mce-root"/>
<p>As with all Attached Properties, we start with a class that extends the <kbd>DependencyObject</kbd> class. In this class, we first declare the read-only <kbd>originalToolTipPropertyKey</kbd> field using the <kbd>RegisterAttachedReadOnly</kbd> method and the <kbd>OriginalToolTipProperty</kbd> property and its associated CLR getter.</p>
<p>Next, we use the <kbd>RegisterAttached</kbd> method to register the <kbd>DisabledToolTip</kbd> property that will hold the value of the tooltip to be displayed when the control is disabled. We then see its CLR getter and setter methods and its all-important <kbd>PropertyChangedCallback</kbd> handling method.</p>
<p>In the <kbd>OnDisabledToolTipChanged</kbd> method, we first cast the <kbd>dependencyObject</kbd> input parameter to its actual type of <kbd>Button</kbd>. We then use it to set the <kbd>ToolTipService.SetShowOnDisabled</kbd> Attached Property to <kbd>true</kbd>, which is required because we want the button's tooltip to be displayed when the button is disabled. The default value is <kbd>false</kbd>, so our Attached Property would not work without this step.</p>
<p>Next, we determine whether we need to attach or detach the <kbd>Button_IsEnabledChanged</kbd> event-handling method depending on the <kbd>NewValue</kbd> and <kbd>OldValue</kbd> property values of the <kbd>DependencyPropertyChangedEventArgs</kbd> object. If the old value is <kbd>null</kbd>, then the property has not been set before and we need to attach the handler; if the new value is <kbd>null</kbd>, then we need to detach the handler.</p>
<p>In the <kbd>Button_IsEnabledChanged</kbd> event-handling method, we first cast the <kbd>sender</kbd> input parameter to the <kbd>Button</kbd> type. We then use it to access the <kbd>OriginalToolTip</kbd> property and if it is <kbd>null</kbd>, we set it with the current value from the control's normal <kbd>ToolTip</kbd> property. Note that we need to pass the <kbd>originalToolTipPropertyKey</kbd> field into the <kbd>SetValue</kbd> method, as it is a read-only property.</p>
<p>Finally, we utilize the <kbd>e.NewValue</kbd> property value to determine whether to set the original tooltip or the disabled tooltip into the control's normal <kbd>ToolTip</kbd> property. Therefore, if the control is enabled, the <kbd>e.NewValue</kbd> property value will be <kbd>true</kbd> and the original tooltip will be returned; if the button is disabled, the disabled tooltip will be displayed. We could use this Attached Property as follows:</p>
<pre>&lt;Button Content="Save" Attached:ButtonProperties.DisabledToolTip="You must
  correct validation errors before saving" ToolTip="Saves the user" /&gt; </pre>
<p>As can be seen from this simple example, Attached Properties enable us to easily add new functionality to the existing suite of UI controls. This again highlights how versatile WPF is and demonstrates that we often have no need to create completely new controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining controls</h1>
                
            
            
                
<p>When we need to arrange a number of existing controls in a particular way, we typically use a <kbd>UserControl</kbd> object. This is why we normally use this type of control to build our Views. However, when we need to build a reusable control, such as an address control, we tend to separate these from our Views, by declaring them in a <kbd>Controls</kbd> folder and namespace within our Views project.</p>
<p>When declaring these reusable controls, it is customary to define Dependency Properties in the code behind and as long as there is no business-related functionality in the control, it is also OK to use the code behind to handle events. If the control is business-related, then we can use a View Model as we do with normal Views. Let's take a look at an example of an address control:</p>
<pre>&lt;UserControl x:Class=
  "CompanyName.ApplicationName.Views.Controls.AddressControl" 
   
   
  xmlns:Controls=
    "clr-namespace:CompanyName.ApplicationName.Views.Controls"&gt; 
  &lt;Grid&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
      &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Label" /&gt; 
      &lt;ColumnDefinition /&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;Grid.RowDefinitions&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;TextBlock Text="House/Street" /&gt; 
    &lt;TextBox Grid.Column="1" Text="{Binding Address.HouseAndStreet,  
      RelativeSource={RelativeSource  
      AncestorType={x:Type Controls:AddressControl}}}" /&gt; 
    &lt;TextBlock Grid.Row="1" Text="Town" /&gt; 
    &lt;TextBox Grid.Row="1" Grid.Column="1"  
      Text="{Binding Address.Town, RelativeSource={RelativeSource  
      AncestorType={x:Type Controls:AddressControl}}}" /&gt; 
    &lt;TextBlock Grid.Row="2" Text="City" /&gt; 
    &lt;TextBox Grid.Row="2" Grid.Column="1"  
      Text="{Binding Address.City, RelativeSource={RelativeSource  
      AncestorType={x:Type Controls:AddressControl}}}" /&gt; 
    &lt;TextBlock Grid.Row="3" Text="Post Code" /&gt; 
    &lt;TextBox Grid.Row="3" Grid.Column="1"  
      Text="{Binding Address.PostCode, RelativeSource={RelativeSource  
      AncestorType={x:Type Controls:AddressControl}}}" /&gt; 
    &lt;TextBlock Grid.Row="4" Text="Country" /&gt; 
    &lt;TextBox Grid.Row="4" Grid.Column="1"  
      Text="{Binding Address.Country, RelativeSource={RelativeSource  
      AncestorType={x:Type Controls:AddressControl}}}" /&gt; 
  &lt;/Grid&gt; 
&lt;/UserControl&gt; </pre>
<p>In this example, we declare this class within the <kbd>Controls</kbd> namespace and set up a XAML namespace prefix for it. We then see the <kbd>Grid</kbd> panel that is used to layout the address controls and notice that the <kbd>SharedSizeGroup</kbd> property is set on the <kbd>ColumnDefinition</kbd> element that defines the label column. This will enable the column sizes within this control to be shared with externally declared controls.</p>
<p>We then see all of the <kbd>TextBlock</kbd> and <kbd>TextBox</kbd> controls that are data bound to the control's address fields. There's not much to note here except that the data bound properties are all accessed through a <kbd>RelativeSource</kbd> binding to an <kbd>Address</kbd> Dependency Property that is declared in the code behind file of the <kbd>AddressControl</kbd>.</p>
<p>Remember that it's fine to do this when using MVVM as long as we are not encapsulating any business rules here. Our control merely enables the users to input or add address information, which will be used by various Views and View Models. Let's see this property now:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
using CompanyName.ApplicationName.DataModels; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class AddressControl : UserControl 
  { 
    public AddressControl() 
    { 
      InitializeComponent(); 
    } 
 
    public static readonly DependencyProperty AddressProperty = 
      DependencyProperty.Register(nameof(Address), 
      typeof(Address), typeof(AddressControl),  
      new PropertyMetadata(new Address())); 
 
    public Address Address 
    { 
      get { return (Address)GetValue(AddressProperty); } 
      set { SetValue(AddressProperty, value); } 
    } 
  } 
} </pre>
<p>This is a very simple control with just one Dependency Property. We can see that the <kbd>Address</kbd> property is of type <kbd>Address</kbd>, so let's have a quick look at that class next:</p>
<pre>namespace CompanyName.ApplicationName.DataModels 
{ 
  public class Address : BaseDataModel 
  { 
    private string houseAndStreet, town, city, postCode, country; 
 
    public string HouseAndStreet 
    { 
      get { return houseAndStreet; } 
      set { if (houseAndStreet != value) { houseAndStreet = value;  
        NotifyPropertyChanged(); } } 
    } 
 
    public string Town 
    { 
      get { return town; } 
      set { if (town != value) { town = value; NotifyPropertyChanged(); } }        
    } 
 
    public string City 
    { 
      get { return city; } 
      set { if (city != value) { city = value; NotifyPropertyChanged(); } }        
    } 
 
    public string PostCode 
    { 
      get { return postCode; } 
      set { if (postCode != value) { postCode = value;  
        NotifyPropertyChanged(); } } 
    } 
 
    public string Country 
    { 
      get { return country; } 
      set { if (country != value) { country = value;  
        NotifyPropertyChanged(); } } 
    } 
 
    public override string ToString() 
    { 
      return $"{HouseAndStreet}, {Town}, {City}, {PostCode}, {Country}";
    } 
  } 
} </pre>
<p>Again, we have a very simple class that is primarily made up from the address related properties. Note the use of the String Interpolation in the overridden <kbd>ToString</kbd> method to output a useful display of the class contents. Now we've seen the control, let's take a look at how we can use it in our application. We can edit a View that we saw earlier, so let's see the updated <kbd>UserView</kbd> XAML now:</p>
<pre>&lt;Grid TextElement.FontSize="14" Grid.IsSharedSizeScope="True" Margin="10"&gt; 
  &lt;Grid.Resources&gt; 
    &lt;Style TargetType="{x:Type TextBlock}"&gt; 
      &lt;Setter Property="HorizontalAlignment" Value="Right" /&gt; 
      &lt;Setter Property="VerticalAlignment" Value="Center" /&gt; 
      &lt;Setter Property="Margin" Value="0,0,5,5" /&gt; 
    &lt;/Style&gt; 
    &lt;Style TargetType="{x:Type TextBox}"&gt; 
      &lt;Setter Property="VerticalAlignment" Value="Center" /&gt; 
      &lt;Setter Property="Margin" Value="0,0,0,5" /&gt; 
    &lt;/Style&gt; 
  &lt;/Grid.Resources&gt; 
  &lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="Auto" SharedSizeGroup="Label" /&gt; 
    &lt;ColumnDefinition /&gt; 
  &lt;/Grid.ColumnDefinitions&gt; 
  &lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
  &lt;/Grid.RowDefinitions&gt; 
  &lt;TextBlock Text="Name" /&gt; 
  &lt;TextBox Grid.Column="1" Text="{Binding User.Name}" /&gt; 
  &lt;TextBlock Grid.Row="1" Text="Age" /&gt; 
  &lt;TextBox Grid.Row="1" Grid.Column="1" Text="{Binding User.Age}" /&gt; 
  &lt;Controls:AddressControl Grid.Row="2" Grid.ColumnSpan="2"  
    Address="{Binding User.Address}" /&gt; 
&lt;/Grid&gt; </pre>
<p>In this example, we can see the use of the <kbd>Grid.IsSharedSizeScope</kbd> property on the outermost <kbd>Grid</kbd> panel. Remember that the <kbd>SharedSizeGroup</kbd> property was set in the <kbd>AddressControl</kbd> XAML, although without this setting on the outer <kbd>Grid</kbd>, it does nothing by itself.</p>
<p>Looking at the outer panel's column definitions, we can see that we have also set the <kbd>SharedSizeGroup</kbd> property to the same value of <kbd>Label</kbd> on the left column so that the two panels' columns will be aligned.</p>
<p>We can skip over the two styles that are declared in the panel's <kbd>Resources</kbd> section as in a proper application, these would most likely reside in the application resources file. In the remainder of the View, we simply have a couple of rows of user properties and then <kbd>AddressControl</kbd>.</p>
<p>This code assumes that we have declared an <kbd>Address</kbd> property of type <kbd>Address</kbd> in our <kbd>User</kbd> class and populated it with suitable values in the <kbd>UserViewModel</kbd> class. Note how we data bind the <kbd>Address</kbd> property of the <kbd>User</kbd> class to the <kbd>Address</kbd> property of the control, rather than setting the <kbd>DataContext</kbd> property. As the control's internal controls are data bound using <kbd>RelativeSource</kbd> bindings, which specify their own binding source, they do not require any <kbd>DataContext</kbd> to be set. In fact, doing so in this example would stop it from working.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating custom controls</h1>
                
            
            
                
<p>When using WPF, we can generally create the UI that we want using the many techniques already discussed in this book. However, in the cases where we require a totally unique control with both a custom drawn appearance and custom functionality, then we may need to declare a custom control.</p>
<p>Developing custom controls is very different than creating <kbd>UserControl</kbd> elements and it can take some time to master this. To start with, we will need to add a new project of type WPF Custom Control Library to declare them in. Also, instead of having a XAML page and a code behind file, we only have the code file. At this point, you may be wondering where we define what our control should look like.</p>
<p>In fact, when defining a custom control, we declare our XAML in a separate file named <kbd>Generic.xaml</kbd>, which is added by Visual Studio when we add our controls project. To clarify, the XAML for all of the custom controls that we declare in this project will go into this file. This does not relate to controls that extend the <kbd>UserControl</kbd> class and we should not declare those in this project.</p>
<p>This <kbd>Generic.xaml</kbd> file gets added into a folder named <kbd>Themes</kbd> in the root directory of our WPF Custom Control Library project, as this is where the Framework will look for the default styles of our custom controls. As such, we must declare the UI design of our control in a <kbd>ControlTemplate</kbd> and set it to the <kbd>Template</kbd> property in a style that targets the type of our control in this file.</p>
<p class="mce-root"/>
<p>The style must be applied to all instances of our control and so the style is defined with the <kbd>TargetType</kbd> set, but without the <kbd>x:Key</kbd> directive. If you remember, this will ensure that it is implicitly applied to all instances of our control that don't have an alternative template explicitly applied.</p>
<p>A further difference is that we cannot directly reference any of the controls that are defined within the style in the <kbd>Generic.xaml</kbd> file. If you recall, when we provided a new template for the built-in controls, we were under no obligation to provide the same controls that were originally used. Therefore, if we tried to access a control from our original template that had been replaced, it would cause an error.</p>
<p>Instead, we generally need to access them by overriding the <kbd>FrameworkElement.OnApplyTemplate</kbd> method, which is raised once a template has been applied to an instance of our control. In this method, we should expect that our required control(s) will be missing and ensure that no errors occur if that is the case.</p>
<p>Let's look at a simple example of a custom control that creates a meter that can be used to monitor CPU activity, RAM usage, audio loudness, or any other regularly changing value. We'll first need to create a new project of type WPF Custom Control Library and rename the <kbd>CustomControl1.cs</kbd> class that Visual Studio adds for us to <kbd>Meter.cs</kbd>.</p>
<p>Note that we can only add a custom control to a project of this type and that when the project is added, Visual Studio will also add our <kbd>Themes</kbd> folder and <kbd>Generic.xaml</kbd> file, with a style for our control already declared inside it. Let's see the code in the <kbd>Meter.cs</kbd> file:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.CustomControls 
{ 
  public class Meter : Control 
  { 
    static Meter() 
    { 
      DefaultStyleKeyProperty.OverrideMetadata(typeof(Meter),  
        new FrameworkPropertyMetadata(typeof(Meter))); 
    } 
 
    public static readonly DependencyProperty ValueProperty =  
      DependencyProperty.Register(nameof(Value),  
      typeof(double), typeof(Meter), 
      new PropertyMetadata(0.0, OnValueChanged, CoerceValue)); 
 
    private static object CoerceValue(DependencyObject dependencyObject,
      object value) 
    { 
      return Math.Min(Math.Max((double)value, 0.0), 1.0); 
    } 
 
    private static void OnValueChanged(DependencyObject dependencyObject,
      DependencyPropertyChangedEventArgs e) 
    { 
      Meter meter = (Meter)dependencyObject; 
      meter.SetClipRect(meter); 
    } 
 
    public double Value 
    { 
      get { return (double)GetValue(ValueProperty); } 
      set { SetValue(ValueProperty, value); } 
    } 
 
    public static readonly DependencyPropertyKey clipRectPropertyKey =       
      DependencyProperty.RegisterReadOnly(nameof(ClipRect), typeof(Rect),  
      typeof(Meter), new PropertyMetadata(new Rect())); 
 
    public static readonly DependencyProperty ClipRectProperty =  
      clipRectPropertyKey.DependencyProperty; 
 
    public Rect ClipRect 
    { 
      get { return (Rect)GetValue(ClipRectProperty); } 
      private set { SetValue(clipRectPropertyKey, value); } 
    } 
 
    public override void OnApplyTemplate() 
    { 
      SetClipRect(this); 
    } 
 
    private void SetClipRect(Meter meter) 
    { 
      double barSize = meter.Value * meter.Height; 
      meter.ClipRect =  
        new Rect(0, meter.Height - barSize, meter.Width, barSize); 
    } 
  } 
} </pre>
<p>This is a relatively small class, with only two Dependency Properties and their associated CLR property wrappers and callback handlers. Of particular note is the class's static constructor and the use of the <kbd>DefaultStyleKeyProperty.OverrideMetadata</kbd> method.</p>
<p>This is also added by Visual Studio when adding the class and is required to override the type-specific metadata of the <kbd>DefaultStyleKey</kbd> Dependency Property when we derive a custom class from the <kbd>FrameworkElement</kbd> class.</p>
<p>Specifically, this key is used by the Framework to find the default theme style for our control and so, by passing the type of our class into the <kbd>OverrideMetadata</kbd> method, we are telling the Framework to look for a default style for this type in our <kbd>Themes</kbd> folder.</p>
<p>If you remember, the theme styles are the last place that the Framework will look for the style of a specific type and declaring styles just about anywhere else in the application will override the default styles defined here.</p>
<p>The first Dependency Property is the main <kbd>Value</kbd> property of the control and this is used to determine the size of the visible meter bar. This property defines a default value of <kbd>0.0</kbd> and attaches the <kbd>CoerceValue</kbd> and <kbd>OnValueChanged</kbd> callback handlers.</p>
<p>In the <kbd>CoerceValue</kbd> handling method, we ensure that the output value always remains between <kbd>0.0</kbd> and <kbd>1.0</kbd>, as that is the scale that we will be using. In the <kbd>OnValueChanged</kbd> handler, we update the value of the other Dependency Property, <kbd>ClipRect</kbd>, dependent upon the input value.</p>
<p>To do this, we first cast the <kbd>dependencyObject</kbd> input parameter to our <kbd>Meter</kbd> type and then pass that instance to the <kbd>SetClipRect</kbd> method. In this method, we calculate the relative size of the meter bar and define the <kbd>Rect</kbd> element for the <kbd>ClipRect</kbd> Dependency Property accordingly.</p>
<p>Next, we see the CLR property wrapper for the <kbd>Value</kbd> Dependency Property and then the declaration of the <kbd>ClipRect</kbd> Dependency Property. Note that we declare it using a <kbd>DependencyPropertyKey</kbd> element, thus making it a read-only property, because it is only for internal use and has no value in being exposed publicly. The actual <kbd>ClipRect</kbd> Dependency Property comes from this key element.</p>
<p>After this, we see the CLR property wrapper for the <kbd>ClipRect</kbd> Dependency Property and then we come to the aforementioned <kbd>OnApplyTemplate</kbd> method. In our case, the purpose of overriding this method is because often, data bound values will be set before the control's template has been applied and so we would not be able to correctly set the size of the meter bar from those values.</p>
<p>Therefore, when the template has been applied and the control has been arranged and sized, we call the <kbd>SetClipRect</kbd> method in order to set the <kbd>Rect</kbd> element for the <kbd>ClipRect</kbd> Dependency Property to the appropriate value. Before this point in time, the <kbd>Height</kbd> and <kbd>Weight</kbd> properties of the <kbd>meter</kbd> instance will be <kbd>double.NaN</kbd> (where <em>NaN</em> is short for <em>Not a Number</em>) and cannot be used to size the <kbd>Rect</kbd> element correctly.</p>
<p>When this method is called, we can rest assured that the <kbd>Height</kbd> and <kbd>Weight</kbd> properties of the <kbd>meter</kbd> instance will have valid values. Note that had we needed to access any elements from our template, we could have called the <kbd>FrameworkTemplate.FindName</kbd> method from this method, on the <kbd>ControlTemplate</kbd> object that is specified by our control's <kbd>Template</kbd> property.</p>
<p>If we had named a <kbd>Rectangle</kbd> element in our XAML <kbd>PART_Rectangle</kbd>, we could access it from the <kbd>OnApplyTemplate</kbd> method like this:</p>
<pre>Rectangle rectangle = Template.FindName("PART_Rectangle", this) as Rectangle; 
if (rectangle != null) 
{ 
  // Do something with rectangle 
} </pre>
<p>Note that we always need to check for <kbd>null</kbd>, because the applied template may be a custom template that does not contain the <kbd>Rectangle</kbd> element at all. Note also that when we require the existence of a particular element in the template, we can decorate our custom control class declaration with a <kbd>TemplatePartAttribute</kbd>, that specifies the details of the required control:</p>
<pre>[TemplatePart(Name = "PART_Rectangle", Type = typeof(Rectangle))] 
public class Meter : Control 
{ 
  ... 
} </pre>
<p>This will not enforce anything and will not raise any compilation errors if the named part is not included in a custom template, but it will be used in documentation and by various XAML tools. It helps users of our custom controls to find out which elements are required when they provide custom templates.</p>
<p>Now that we've seen the inner workings of this control, let's take a look at the XAML of the default style of our control in the <kbd>Generic.xaml</kbd> file to see how the <kbd>ClipRect</kbd> property is used:</p>
<pre>&lt;ResourceDictionary  
   
   
  xmlns:CustomControls=
    "clr-namespace:CompanyName.ApplicationName.CustomControls"&gt; 
  &lt;Style TargetType="{x:Type CustomControls:Meter}"&gt; 
    &lt;Setter Property="Template"&gt; 
      &lt;Setter.Value&gt; 
        &lt;ControlTemplate TargetType="{x:Type  
          CustomControls:Meter}"&gt; 
          &lt;ControlTemplate.Resources&gt; 
            &lt;LinearGradientBrush x:Key="ScaleColors"  
              StartPoint="0,1" EndPoint="0,0"&gt; 
              &lt;GradientStop Color="LightGreen" /&gt; 
              &lt;GradientStop Color="Yellow" Offset="0.5" /&gt; 
              &lt;GradientStop Color="Orange" Offset="0.75" /&gt;  
              &lt;GradientStop Color="Red" Offset="1.0" /&gt; 
            &lt;/LinearGradientBrush&gt; 
          &lt;/ControlTemplate.Resources&gt; 
          &lt;Border Background="{TemplateBinding Background}" 
            BorderBrush="{TemplateBinding BorderBrush}"  
            BorderThickness="{TemplateBinding BorderThickness}"<br/>            SnapsToDevicePixels="True"&gt; 
            &lt;Border.ToolTip&gt; 
              &lt;TextBlock Text="{Binding Value, StringFormat={}{0:P0}}" /&gt; 
            &lt;/Border.ToolTip&gt; 
            &lt;Rectangle Fill="{StaticResource ScaleColors}"  
              HorizontalAlignment="Stretch" VerticalAlignment="Stretch"  
              SnapsToDevicePixels="True" Name="PART_Rectangle"&gt; 
              &lt;Rectangle.Clip&gt; 
                &lt;RectangleGeometry Rect="{Binding ClipRect, 
                  RelativeSource={RelativeSource  
                  AncestorType={x:Type CustomControls:Meter}}}" /&gt; 
              &lt;/Rectangle.Clip&gt; 
            &lt;/Rectangle&gt; 
          &lt;/Border&gt; 
        &lt;/ControlTemplate&gt; 
      &lt;/Setter.Value&gt; 
    &lt;/Setter&gt; 
  &lt;/Style&gt; 
&lt;/ResourceDictionary&gt; </pre>
<p>When each custom control class is created in a WPF Custom Control Library project, Visual Studio adds an almost empty default style that sets a basic <kbd>ControlTemplate</kbd> and targets the type of the class into the <kbd>Generic.xaml</kbd> file. We just need to define our custom XAML within this template.</p>
<p>We start by declaring the <kbd>ScaleColors</kbd> gradient brush resource within the template. Note that the default value for the <kbd>Offset</kbd> property of a <kbd>GradientStop</kbd> element is <kbd>0</kbd> and so we can omit the setting of this property if that is the value that we want it set to. Therefore, when we see a declared <kbd>GradientStop</kbd>, like the one with the <kbd>Color</kbd> property set to <kbd>LightGreen</kbd>, we know its <kbd>Offset</kbd> property is set to <kbd>0</kbd>.</p>
<p>Our meter control is basically made up of a <kbd>Border</kbd> element that surrounds a <kbd>Rectangle</kbd> element. We use <kbd>TemplateBinding</kbd> elements to data bind the <kbd>Background</kbd>, <kbd>BorderBrush</kbd>, and <kbd>BorderThickness</kbd> properties of the <kbd>Border</kbd> element and set its <kbd>SnapsToDevicePixels</kbd> property to <kbd>True</kbd> to avoid aliasing.</p>
<p>This enables users of the control to specify the border and background colors of the internal <kbd>Border</kbd> element of the meter control from outside the control. We could just as easily have exposed an additional brush property to replace the <kbd>ScaleColors</kbd> resource and enable users to define their own meter scale brush.</p>
<p>Note that we couldn't use a <kbd>TemplateBinding</kbd> to data bind the <kbd>Value</kbd> property in the <kbd>ToolTip</kbd> element. This is not because we don't have access to it through the template, but because we need to use the <kbd>Binding.StringFormat</kbd> property and the <kbd>P</kbd> format specifier to transform our <kbd>double</kbd> property value to a percentage value.</p>
<p>If you remember, a <kbd>TemplateBinding</kbd> is a lightweight binding and does not offer this functionality. While it is beneficial to use it when we can, this example highlights the fact that we cannot use it in every circumstance.</p>
<p>Finally, we come to the all-important <kbd>Rectangle</kbd> element that is responsible for displaying the actual meter bar of our control. The <kbd>ScaleColors</kbd> brush resource is used here to paint the background of the rectangle. We set the <kbd>SnapsToDevicePixels</kbd> property to <kbd>true</kbd> on this element to ensure that the level that it displays is accurate and well-defined.</p>
<p>The magic in this control is formed by the use of the <kbd>UIElement.Clip</kbd> property. Essentially, this enables us to provide any type of <kbd>Geometry</kbd> element to alter the shape and size of the visible portion of a UI element. The geometry shape that we assign here will specify the visible portion of the control.</p>
<p>In our case, we declare a <kbd>RectangleGeometry</kbd> class, whose size and location are specified by its <kbd>Rect</kbd> property. We therefore data bind our <kbd>ClipRect</kbd> Dependency Property to this <kbd>Rect</kbd> property, so that the sizes calculated from the incoming data values are represented by this <kbd>RectangleGeometry</kbd> instance, and therefore the visible part of the <kbd>Rectangle</kbd> element.</p>
<p>Note that we do this so that the gradient that is painted on the meter bar remains constant and does not change with the height of the bar as its value changes. If we had simply painted the background of the rectangle with the brush resource and adjusted its height, the background gradient would move with the size of the meter bar and spoil the effect.</p>
<p>Therefore, the whole rectangle is always painted with the gradient brush and we simply use its <kbd>Clip</kbd> property to just display the appropriate part of it. In order to use it in one of our Views, we'd first need to specify the <kbd>CustomControls</kbd> XAML namespace prefix:</p>
<pre>xmlns:CustomControls="clr-namespace:CompanyName.ApplicationName.  
  CustomControls;assembly=CompanyName.ApplicationName.CustomControls"</pre>
<p>We could then declare a number of them, data bind some appropriate properties to their <kbd>Value</kbd> property, and set styles for them, just like any other control:</p>
<pre>&lt;StackPanel Orientation="Horizontal" HorizontalAlignment="Center"&gt; 
  &lt;StackPanel.Resources&gt; 
    &lt;Style TargetType="{x:Type CustomControls:Meter}"&gt; 
      &lt;Setter Property="Background" Value="Black" /&gt; 
      &lt;Setter Property="BorderBrush" Value="Black" /&gt; 
      &lt;Setter Property="BorderThickness" Value="2" /&gt; 
      &lt;Setter Property="HorizontalAlignment" Value="Center" /&gt; 
      &lt;Setter Property="Width" Value="20" /&gt; 
      &lt;Setter Property="Height" Value="100" /&gt; 
    &lt;/Style&gt; 
  &lt;/StackPanel.Resources&gt; 
  &lt;CustomControls:Meter Value="{Binding CpuActivity}" /&gt; 
  &lt;CustomControls:Meter Value="{Binding DiskActivity}" Margin="10,0" /&gt; 
  &lt;CustomControls:Meter Value="{Binding NetworkActivity}" /&gt; 
&lt;/StackPanel&gt; </pre>
<p>Given some valid properties to data bind to, the preceding example would produce an output similar to the following:</p>
<div><img class="alignnone size-full wp-image-2413 image-border" src="img/67f18285-8cda-41db-a3a0-14d808ed645f.jpg" style="width:10.75em;height:11.75em;"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've investigated the rich inheritance hierarchy of the built-in WPF controls, determining which abilities come from which base classes, and have seen how each control is laid out by their containing panels. We've examined the differences between the different panels and understand that some work better in certain conditions than others.</p>
<p>We've also uncovered the mysteries of the <kbd>ContentControl</kbd> and <kbd>ItemsControl</kbd> elements and now have a good understanding of <kbd>ContentPresenter</kbd> and <kbd>ItemsPresenter</kbd> objects. We moved on to discover a wide variety of ways for us to customize the built-in controls. Finally, we considered how best to make our own controls.</p>
<p>In the next chapter, we will further investigate the built-in controls, paying particular attention to the polymorphic ability of derived classes to override base class methods. We will introduce a number of examples that each highlight certain problems, and demonstrate how to overcome them each in turn by extending the built-in controls and overriding particular base class methods.</p>


            

            
        
    </body></html>