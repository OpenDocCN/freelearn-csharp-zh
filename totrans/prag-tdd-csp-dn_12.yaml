- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with Brownfield Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I cringe whenever I hear **brownfield project**, and probably you do too. Design
    decisions are already taken, code is already written by previous developers, and
    code quality varies between one class and another; brownfields are not for the
    faint-hearted.
  prefs: []
  type: TYPE_NORMAL
- en: As there could be multiple definitions for the term brownfield, I want to start
    by defining it here, so we are all on the same page. From this book’s perspective,
    a brownfield project is a project not covered by unit tests and was probably written
    a while ago. It might have been covered by other types of tests than unit tests,
    but we will still refer to it as a brownfield. Some techies also refer to it as
    a **legacy project**.
  prefs: []
  type: TYPE_NORMAL
- en: As you have already figured out, we have dedicated a whole chapter to brownfields
    as there are challenges in introducing TDD or unit testing to such projects. We
    will discuss those challenges and how to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy for enabling TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring for unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will better understand what you need to look
    for when enabling unit testing for your project. You will also get an insight
    into required code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12)'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we’ve been talking about adding new features while
    starting from the unit tests end (testing first). We relied on having a new functionality
    or modifying an existing functionality that is already covered by existing unit
    tests. This is not the case for brownfields as, when trying to apply TDD, you
    will face some of these challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection support**: Some legacy frameworks do not natively support
    DI, which is necessary for unit tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code modification challenges**: Changes to code that are not covered by tests
    (of any type) can introduce new bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time and effort challenges**: Introducing the ability to unit test the code
    requires time and effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through each challenge in detail, so you can consider them when the
    time comes.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, before learning about unit testing or TDD, we had to introduce
    DI. DI is what allows you to separate your code into units/components; it is a
    natural requirement for unit testing. There are two challenges in enabling DI
    – framework support and refactoring work. Let’s dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: Framework support for DI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a .NET book, so we are only interested in legacy .NET frameworks that
    do not support DI natively. In the early 2000s, while unit testing was becoming
    a trend, Microsoft was more interested in migrating developers from **Visual Basic
    6** (**VB6**) and **Active Server Pages** (**ASP**), thus enabling native DI in
    the early days of .NET was not on the priority list.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Win Forms and ASP.NET Web Forms were born with no native DI support.
    Surely, you can hack the framework and add some support for DI. Still, when you
    start shifting from the norms of a framework, you alienate other developers working
    on the code base and introduce subtle bugs and complexity to the design.
  prefs: []
  type: TYPE_NORMAL
- en: More modern frameworks, such as WPF, and ASP.NET MVC from the classical .NET
    Framework allowed dependency injection through third-party DI containers. Today,
    with ASP.NET Core, DI is natively supported using Microsoft-built DI containers.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a project that is built on a legacy framework with no native support
    for DI, such as Win Forms and ASP.NET Web Forms, I would say the effort put into
    bending these frameworks to enable unit testing needs to be weighed against the
    benefits of having unit tests. Maybe you can invest this effort in applying other
    types of testing to the project instead. Obviously, migrating the project into
    a modern framework solves this problem, but that has its own challenges as well.
  prefs: []
  type: TYPE_NORMAL
- en: If the framework supports DI natively or can support DI with little effort,
    then you are in luck, but is that all? Clearly, now you have to refactor everything
    to enable DI.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for DI support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We dedicated [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037)*, Understanding
    Dependency Injection by Example,* to discussing DI, so we will not go into details
    here. What we need to do when we plan to introduce unit tests or TDD is to make
    sure we are using DI to inject components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, all your components need to be injected through constructor injection,
    and instantiating a variable should not be done in the method or property code.
    With that said, consider the following unwelcome code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you have code that is not unit tested, you’ll probably find that all the
    components are instantiated in the code, and no DI container is used. In this
    case, you will have to go through the cases of direct instantiation and modify
    them to support DI. We will see an example of this at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all cases of direct instantiation will require you to refactor them for
    DI. Some cases are part of a standard library that you could unit test, but you
    shouldn’t. Take this line as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we had no intention of injecting the `UriBuilder` class, so
    you might not need to change the code because the class is not relying on an external
    dependency. Accordingly, injecting the class is not beneficial, but actually,
    it adds a bit of unnecessary effort.
  prefs: []
  type: TYPE_NORMAL
- en: In brief, to make the code unit testable, all the components need to be DI-ready.
    Depending on how big your project is and the way you want to implement it (such
    as iteratively), it will take time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DI is not the only challenge; modifying the code will pose a new
    challenge as well.
  prefs: []
  type: TYPE_NORMAL
- en: Code modification challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are adding non-unit tests to your project, you are working externally
    to the code and some of the activities can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the UI with an automation tool such as Selenium or Cypress. The tests
    will deal with the application like an external user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing integration testing by performing an end-to-end call, say on an API endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load testing a project by creating multiple instances of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penetration testing by trying to hack into the application externally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these activities do not require changing the code, but unit testing requires
    the production code to be in a certain shape.
  prefs: []
  type: TYPE_NORMAL
- en: When changing the code to enable unit testing, we risk breaking it. Imagine
    having a bug that found its way to production and the irony of the business hearing
    *it broke because we added tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I would be lying if I said that you have to change the code for unit testing
    because you can use an isolation testing framework, which would allow you to unit
    test the code without changing it. However, this would be the last resort if you
    really want to unit test and you cannot change the code. We’ll discuss this further
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are solutions to change the code that will reduce the possibility of breaking,
    so follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Time and effort challenges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of enabling dependency injection and refactoring the code into components
    that act as units is mentally challenging and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Think of approaching the process iteratively by dividing it into your sprints
    (or iterations, or whatever you call them) or by blocking some iterations and
    implementing your changes.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge here is to justify to the business the time spent in introducing
    unit testing and enabling TDD, as from their perspective, you still have the same
    product, the same number of bugs, and nothing is fixed, but you have just added
    tests. Obviously, you and I know that unit testing will guard the code against
    future bugs and add documentation, but the challenge is to convey this to the
    business. The next chapter is going to tackle dealing with the business when introducing
    TDD and unit testing, so I will stop here.
  prefs: []
  type: TYPE_NORMAL
- en: All these challenges have solutions; after all, we work in software! The next
    sections will address them with different strategies.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy of enabling TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is the time to discuss solutions to the challenges described in the previous
    section. Since *a picture is worth a thousand words*, I will present a workflow
    diagram that should clarify how to introduce unit testing into a brownfield project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The workflow of enabling TDD in a project ](img/Figure_12.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – The workflow of enabling TDD in a project
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the diagram and our options.
  prefs: []
  type: TYPE_NORMAL
- en: Consider rewriting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might consider rewriting because the existing project might be based on
    an old framework with fewer developers and less support. However, the rewriting
    idea is controversial. If you tell the business that the project requires rewriting,
    you will be their least favorite individual. Trust me; nobody wants to hear this.
    However, good rewriting doesn’t need to be a big bang; it can be divided into
    smaller chunks of upgrades and can be appended to sprints. Obviously, choosing
    a modern framework that supports DI natively or through a third party is out of
    the question.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to rewrite software, which are beyond the scope of this
    book. But if you are rewriting, you can start the new pieces with TDD, and the
    problem would be sorted!
  prefs: []
  type: TYPE_NORMAL
- en: Changing code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some settings, the code is too tangled to be changed, or sometimes the business
    doesn’t like the idea of changing the code for whatever reason. If you are facing
    one of these situations, then ask yourself whether it is worth adding unit tests
    or whether this effort should be put into other types of testing. Obviously, other
    types of tests will do good, although unit testing would even be more beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing can be done without DI; hence, you don’t need to change the code.
    Here you go, I let the secret out! But for this to work, you will have to use
    a **test isolation framework**. A test isolation framework makes some changes
    to the way components are loaded externally without touching the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the class does not implement an interface, and the `Products` property
    is not virtual. Let’s see how the **JustMock** **test isolation framework** by
    Telerik would unit test code related to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we only care about the two highlighted lines. `Products`
    property on the `Warehouse` class, although the property is not virtual and the
    `warehouse` object is not instantiated with the help of the mock library.
  prefs: []
  type: TYPE_NORMAL
- en: JustMock did some magic here, it made the `Warehouse` class mockable, despite
    that `Warehouse` doesn’t have an interface and `Products` is not virtual. No DI
    was required!
  prefs: []
  type: TYPE_NORMAL
- en: However, the isolation framework’s magic is not liked by most TDD practitioners,
    as it leads to bad programming practices. Plus, these frameworks are not free.
    They definitely solve a problem when you want to avoid code changes, but they
    pose the question, is it worth the effort and the cost?
  prefs: []
  type: TYPE_NORMAL
- en: Going through the hassle of having a dependency on a non-standard way of testing
    will require training, maintenance, and licensing costs, which should be weighed
    against utilizing any framework.
  prefs: []
  type: TYPE_NORMAL
- en: Native support for DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some frameworks within .NET have no notion of DI – Win Forms and Web Forms are
    perfect examples. You can force them to support DI, but this means bending the
    framework and being on your own. Sometimes, you can try to isolate the UI layer
    and unit test what is underneath it. That is good enough in this case.
  prefs: []
  type: TYPE_NORMAL
- en: What I want to say is having a framework that doesn’t natively support plugging
    in a DI container or has one that is built in, such as ASP.NET Core, will cost
    you more effort and will shift you away from the norm.
  prefs: []
  type: TYPE_NORMAL
- en: I would avoid unit testing such frameworks and promote the quality by employing
    other testing categories.
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage prior to unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code changes will lead to bugs, but what about careful code changes? Well, yes,
    it will still lead to bugs! Bugs will come when you change code, no matter how
    careful you are. So, what is your bug hunting plan?
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to change the code for unit testing, your code should have high
    coverage at first by other types of tests, mainly automation and integration.
    These tests will help to point out where you’ve broken the code before it gets
    to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical question coming up is, if I have high coverage with other types
    of tests, why do I need unit tests? The answers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If your project is still in development, then you will need unit tests. Also,
    preferably add new features in TDD style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change the balance of all the available tests to unit tests once your
    project can support them, as unit tests have advantages over other tests that
    we’ve discussed earlier in this book, in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your code is in maintenance mode and the coverage is already high, then I
    would argue that adding unit tests is not very useful. In this case, TDD would
    not be applicable as TDD is a companion of new features or features change.
  prefs: []
  type: TYPE_NORMAL
- en: My advice is not to change the code if it is not covered by tests, as your valuable
    effort in advancing the project might be countered by production bugs. Maybe the
    effort should be put into other tests or rewriting.
  prefs: []
  type: TYPE_NORMAL
- en: Every project is different and the strategies we have mentioned here are just
    points to consider. You should consider adding these to your train of thought
    when you plan the introduction of unit tests into a brownfield.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see samples of changing legacy code to allow unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write in TDD, your code is unit testable from the first moment. This
    is because you took into consideration DI scenarios. Brownfield code almost always
    has no consideration for DI, and it will have to change to accommodate it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the scenarios that you have to change, and then
    we will go through an example of a sample refactoring at the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Variables instantiated in the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you see a `new` keyword in the code that is instantiating a library
    or a service, then most probably, this needs refactoring. Take the following example
    of code in a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous line means we cannot inject a test double for `Foo`, so the code
    needs to change to inject it.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to do is to check whether `Foo` implements an interface for the
    methods you are using from this class. Let me break the bad news for you here
    – keep your expectations low; you most probably won’t find that the class implements
    an interface for the methods you are using unless you are consuming a well-designed
    and sophisticated framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will go through the process of making the code
    testable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface for your own class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you own the code in `Foo` and you can change it, great! Your code can change
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To this class and an additional interface, `IFoo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is easy. But what if the source code of this class is not accessible to
    you, or you are not allowed to change the source code?
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface for a third-party class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding an interface for a class you do not own is not possible. You have to
    go through another pattern, usually referred to as a wrapper class. You will need
    to create a new class and interface, as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have wrapped the `Foo` class with another class to intercept
    the calls to the `DoBar` method. This would allow us to add an interface in the
    same way we can add an interface to a class we own.
  prefs: []
  type: TYPE_NORMAL
- en: There is a bit of extra work here, but you will get used to it, and it will
    become straightforward after a couple of class changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an interface for our class, we can go to the second step, DI.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting your components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How you do dependency injection depends on the library you are using (ASP.NET
    Core, Win Forms, among others) and the way you’ve wired up your DI container.
    Let’s take an ASP.NET Core WebAPI project. To wire up your newly created or updated
    class, write code similar to the following in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the lifespan scope (transient, scoped, or singleton) will change
    based on the `Foo` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve done the modification, you can refactor your controller to inject
    `FooWrapper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a `wrapper` class and an interface so we can follow along with
    a familiar DI pattern, so the previous code became possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can go ahead and implement whatever unit testing you want to put in
    place, as you can inject a test double for `FooWrapper` at test time.
  prefs: []
  type: TYPE_NORMAL
- en: The instantiation scenario is sorted. Let’s explore another refactoring pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Static members replacement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static methods, which include extension methods, are simple, occupy fewer coding
    lines, and produce beautiful code. However, they are evil when it comes to dependency
    injection; as per the explanation in [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, static methods are not unit test
    friendly.
  prefs: []
  type: TYPE_NORMAL
- en: '`Date.Now` looks innocent, and `Now` is a read-only static property. If you
    want your unit test to freeze the time, for example, say you want to test what
    happens on February 29 (leap year), you can’t do that. The solution to this one
    is a wrapper, as discussed earlier. This is what you can do to make `Now` an instance
    method rather than a static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve done exactly what we’ve done earlier where we did not have control over
    the class (few sections back). We enabled DI support by introducing the wrapper
    pattern to the `DateTime` class. Now, you can inject `DateTimeWrapper` at runtime
    and use a test double for unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have control over the class, you might want to change the static member
    to an instance one (non-static) or introduce an additional instance member and
    keep the static member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a way to expose your static property as an instance property. You will
    also have to use the `PropWrapper` wrapper property instead of the non-wrapped
    one, `Prop`, in the rest of your code. In the previous example, we added an additional
    property, but you could also refactor the code to replace the static property
    if it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the consumer to rely on an instance member
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code consuming the previous `Foo` class might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After refactoring `Foo` as per the previous section, the implementation here
    can change into a unit-testable format, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have injected `IFoo` into the `Consumer` class and we have
    used another property, `PropWrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiated classes and static member calls can be easily spotted. However,
    the most notable thing about legacy code is that it doesn’t have a structure,
    and a component cannot be easily noticed and tested. So for this, we will have
    to make more changes.
  prefs: []
  type: TYPE_NORMAL
- en: Changing code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code in the brownfield project might be in a format that isn’t unit testable.
    One popular structure is the controller’s action method with all the code written
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to get the code into a unit-testable structure. I would choose
    an architecture such as DDD, as per *Part 2* of this book, where we’ve used services
    and domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous sample code works fine, but it is not unit testable. You can find
    the full listing in the `WeatherForecasterBefore` directory of this chapter in
    the `WeatherForecastController.cs` GitHub file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, most of the code is omitted for brevity. The code will call a third-party
    service called Open Weather, and get the forecast for the next 5 days for a certain
    geographical coordinate. It will then analyze the temperature and produce a word
    that describes the temperature feel, such as *Freezing* or *Balmy*.
  prefs: []
  type: TYPE_NORMAL
- en: The previous code also instantiates a `HttpClient` instance, which means there
    is no easy way of avoiding calling the third party whenever we try to unit test
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we shall invest some thoughts into changing this code into testable components.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing code change for a testable format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code that we’ve just seen can be made into components in several ways,
    and there is no one way to do it. This code does two things, so we can think of
    two components that will encompass all the code functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling Open Weather and obtaining a forecast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining the forecast and analyzing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea here is to have the controller with no business logic and if there
    is no business logic, then we will not need to unit test the controller. The controller,
    in general, should have no business logic, and it should do a single job – deliver
    **data transfer objects** (**DTOs**) to views (as of Model-View-Controller views).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will give the following names to our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenWeatherService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeatherAnalysisService`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The whole call to obtain the forecast and the temperature feeling analysis
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Workflow by components ](img/Figure_12.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Workflow by components
  prefs: []
  type: TYPE_NORMAL
- en: The client will call the APIs to obtain the forecast with the feeling. The weather
    forecast controller will receive the call and pass it to the weather analysis
    service, which loads the Open Weather service and calls an external dependency
    to obtain the weather.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see what the code looks like after our refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: The final testable code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are levels of refactoring invasiveness when you want to enable unit testing.
    I chose an aggressive level, but you might choose to refactor less code.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the whole refactored code in the **WeatherForecasterAfter** directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the controller looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The controller is almost empty, compared to how it was before. The action method
    in the controller is mapping the API call to the right service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `OpenWeatherService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The class contains the logic of mapping the feeling to the temperature and calling
    `OpenWeatherService`. The service doesn’t know how the Open Weather APIs are called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s look at `OpenWeatherService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The job of this service is to wrap the HTTP call to the internet Open Weather
    APIs with code.
  prefs: []
  type: TYPE_NORMAL
- en: The full unit tests for the newly added services can be found in the source
    code directory with the rest of the services.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we are doing the refactoring while assuming the code has undergone
    other types of testing. Aggressively refactoring code is time-consuming, especially
    for the first set of refactors, but remember that refactoring is also paying back
    part of the technical debt of the project. The code is now documented by the unit
    test as well, so this is a step forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the implications of enabling unit testing for
    a brownfield project. We’ve gone through the considerations to allow you to decide
    whether it is worth it and all the things that you have to watch for while progressing
    with the process.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you will encounter brownfield projects that went up in value
    and would benefit from unit tests and TDD. Hopefully, this chapter equipped you
    with the required knowledge to tackle them.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding to introduce TDD into your organization is not a straightforward process.
    The next chapter will go through the process and prepare you for some scenarios
    that you would face.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*JustMock (Isolation Framework from Telerik)*: [https://docs.telerik.com/devtools/justmock](https://docs.telerik.com/devtools/justmock%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft Fakes (Isolation Framework that comes with VS Enterprise)*: [https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes](https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TypeMock (Isolation Framework for classical .NET Framework)*: [https://www.typemock.com](https://www.typemock.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
