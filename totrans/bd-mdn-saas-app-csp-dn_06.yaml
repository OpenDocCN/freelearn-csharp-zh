- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Microservices for SaaS Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SaaS应用程序的微服务
- en: Microservices are a powerful architectural pattern that is becoming increasingly
    popular in modern software development. Microservices are a way of organizing
    a large application into smaller, more manageable, and independent services that
    can communicate with each other using well-defined interfaces. This approach has
    gained popularity over the years as companies seek to build more scalable and
    robust software systems. With the increasing complexity of modern applications,
    it has become clear that the traditional monolithic approach to building software
    is no longer adequate. Microservices offer a way to break down complex applications
    into smaller, more manageable pieces that can be developed, deployed, and maintained
    independently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种强大的架构模式，在现代软件开发中越来越受欢迎。微服务是将大型应用程序组织成更小、更易于管理和独立的子服务的方式，这些子服务可以使用定义良好的接口相互通信。随着公司寻求构建更具可扩展性和健壮性的软件系统，这种方法在近年来越来越受欢迎。随着现代应用程序复杂性的增加，传统的单体软件构建方法已不再足够。微服务提供了一种将复杂应用程序分解为更小、更易于管理、可独立开发、部署和维护的组件的方法。
- en: Implementing microservices requires a shift in the way that we think about building
    and deploying software. With microservices, we move away from the monolithic approach
    of building everything in a single application and instead build a series of smaller,
    independent services that can be deployed and scaled independently. This shift
    in approach allows us to build more flexible and resilient systems, as we can
    update, test, and deploy individual services independently. At the same time,
    we need to ensure that our microservices can communicate with each other efficiently
    and that we have mechanisms in place to handle errors and failures in our distributed
    systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实施微服务需要改变我们思考构建和部署软件的方式。使用微服务，我们摆脱了在单个应用程序中构建一切的单体方法，转而构建一系列较小的、独立的子服务，这些子服务可以独立部署和扩展。这种方法的转变使我们能够构建更灵活和有弹性的系统，因为我们能够独立更新、测试和部署单个服务。同时，我们需要确保我们的微服务能够高效地相互通信，并且我们有机制来处理分布式系统中的错误和故障。
- en: This chapter will explore the important considerations when building microservices,
    and provide a guide to help you get started with implementing microservices in
    your software development projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨构建微服务时的重要考虑因素，并提供指南，帮助您在软件开发项目中开始实施微服务。
- en: 'The following main topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Microservices and their uses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务及其用途
- en: Best practices for building performant and secure microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建高性能和安全的微服务的最佳实践
- en: How to use the skills we learned for RESTful APIs with microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用我们学到的技能来处理微服务的RESTful API
- en: Common pitfalls when building microservices and how to avoid them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建微服务时的常见陷阱以及如何避免它们
- en: Some practical advice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些实用建议
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码均可在[https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6)找到。
- en: What are microservices and why use them?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务以及为什么使用它们？
- en: Microservices are a software architecture style that structures an application
    as a collection of loosely coupled services. Unlike a traditional monolithic architecture,
    where all the functionality of the application is bundled into a single code base,
    microservices break down the functionality into smaller, independent services
    that can be developed, deployed, and scaled independently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种软件架构风格，它将应用程序结构化为一系列松散耦合的服务。与所有功能都打包在单个代码库中的传统单体架构不同，微服务将功能分解为更小、更独立的子服务，这些子服务可以独立开发、部署和扩展。
- en: The microservices architecture was first introduced in the early 2000s and has
    gained popularity in recent years due to the increasing demand for faster development
    and deployment cycles, flexible scaling, and improved application resilience.
    Microservices are seen as a way to deliver value to customers more quickly and
    with greater agility, making them ideal for organizations that are looking to
    rapidly iterate and innovate.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Microservices also have several benefits for organizations. By breaking down
    an application into smaller, focused services, organizations can increase the
    speed and efficiency of their development process. Teams can work on smaller,
    independent services in parallel, reducing the risk of delays and helping ensure
    that each service is delivered with high quality. Additionally, microservices
    can be deployed and scaled independently, allowing organizations to respond more
    quickly to changes in demand and optimize the performance of their applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: When learning about microservices, it’s important to appreciate the underlying
    concepts of loose and tight coupling.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The difference between loose and tight coupling
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a tightly coupled system, components are strongly dependent on one another
    and have a close relationship with each other. This means that changes in one
    component can have a significant and often breaking impact on other components
    in the system. Tightly coupled systems can quickly become very complex and difficult
    to maintain. Changes in one part of the system can cause unintended consequences
    elsewhere. If there is limited automated testing, this can be very difficult to
    detect and can result in bugs in production code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a loosely coupled system has components that are independent and
    have minimal dependencies on one another. This allows components to be developed,
    deployed, and maintained independently, with little or no impact on other components
    in the system. Loose coupling enables teams to work more efficiently and with
    greater agility, as changes to one component can be made with little or no impact
    on other parts of the system. It may sound like loose coupling is an obvious choice,
    but in practice, a lot of additional work is required to design a loosely coupled
    system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture is based on the principles of loose coupling,
    where an application is broken down into smaller, focused services that can be
    developed, deployed, and scaled independently. This allows organizations to respond
    more quickly to changes in demand, optimize the performance of their applications,
    and increase the speed and efficiency of their development process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: SaaS applications are typically quite complex. There will often be quite large
    teams working on the project, each of which will have areas of specialization.
    By breaking down an application into smaller, focused services, teams can work
    on them in parallel, reducing the risk of delays and increasing the speed of delivery.
    This helps organizations respond more quickly to changes in demand and deliver
    value to customers more rapidly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SaaS应用程序通常相当复杂。项目上通常会有一支相当大的团队在合作，每个团队都有自己的专业领域。通过将应用程序分解成更小、更专注的服务，团队可以并行工作，降低延迟风险并提高交付速度。这有助于组织更快地响应需求变化并向客户更快地交付价值。
- en: Another advantage of microservices is better scalability. Leaning on cloud-based
    infrastructure, each service can be deployed and scaled independently, allowing
    organizations to respond more quickly to changes in demand and optimize the performance
    of their applications. This is particularly important for SaaS applications, which
    often experience fluctuations in usage patterns. This can benefit the performance
    of the application, by provisioning more resources when the usage is high. When
    usage is low, some resources can be turned off, helping the organization manage
    its cloud compute costs and optimize the use of resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的另一个优点是更好的可伸缩性。依赖基于云的基础设施，每个服务都可以独立部署和扩展，使组织能够更快地响应需求变化并优化其应用程序的性能。这对于经常经历使用模式波动的SaaS应用程序尤为重要。当使用量高时，可以通过提供更多资源来提高应用程序的性能。当使用量低时，可以关闭一些资源，帮助组织管理其云计算成本并优化资源的使用。
- en: Microservices should also be designed to be highly resilient, meaning that even
    if one service fails, the impact on the overall system is minimal. This makes
    microservices ideal for SaaS applications, where downtime can have a significant
    impact on customer satisfaction and an according impact on the revenue of the
    company delivering the application. By breaking down an application into smaller,
    focused services, organizations can reduce the risk of unintended consequences
    when making changes to the system, making maintenance and modification easier
    and reducing the risk of downtime.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务还应设计为具有高度弹性，这意味着即使一个服务失败，对整个系统的影响也最小。这使得微服务非常适合SaaS应用程序，因为停机时间可能会对客户满意度产生重大影响，并相应地影响提供应用程序的公司的收入。通过将应用程序分解成更小、更专注的服务，组织可以降低在系统更改时意外后果的风险，使维护和修改更容易，并降低停机风险。
- en: Microservices are a valuable tool for organizations looking to develop SaaS
    applications. They offer increased agility, better scalability, improved resilience,
    easier maintenance, and better cost management, making them an ideal choice for
    organizations looking to rapidly iterate and innovate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是有志于开发SaaS应用程序的组织的一个有价值的工具。它们提供了更高的敏捷性、更好的可伸缩性、改进的弹性、更简单的维护和更好的成本管理，使它们成为寻求快速迭代和创新的组织的理想选择。
- en: Docker
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: With the `GoodHabits` service, we have been using Docker to run a `devcontainer`
    that encompasses the development environment, and the SQL server database. This
    is only one way that Docker can be used. At its core, Docker is a tool that can
    be used to run a process in a container. You can think of a container as a very
    lightweight virtual machine, typically running a Linux distro.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GoodHabits`服务，我们一直在使用Docker运行一个包含开发环境和SQL服务器数据库的`devcontainer`。这只是Docker可以使用的多种方式之一。在其核心，Docker是一个可以在容器中运行进程的工具。你可以将容器想象成一个非常轻量级的虚拟机，通常运行Linux发行版。
- en: Docker often becomes a very important tool when building with microservices.
    A microservice app will typically have many different components that must be
    running for the overall system to run. This could involve running code in different
    programming languages, and running against multiple different database platforms.
    Attempting to get everything running reliably on a dev machine, and in several
    cloud environments, can quickly become a nightmare!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker经常成为构建微服务时非常重要的工具。一个微服务应用程序通常会有许多不同的组件，这些组件必须运行才能使整个系统运行。这可能包括使用不同的编程语言运行代码，以及针对多个不同的数据库平台运行。试图在开发机器上可靠地运行所有内容，并在多个云环境中运行，很快就会变成一场噩梦！
- en: Docker provides an efficient and reliable way to run your microservices in a
    set of networked containers. By containerizing your microservices, you can isolate
    them from each other, making them easier to build and run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一种高效且可靠的方式来在一系列网络容器中运行您的微服务。通过容器化您的微服务，您可以隔离它们，使它们更容易构建和运行。
- en: Additionally, Docker allows you to easily package your microservices and their
    dependencies, making it simpler to deploy your services in different environments,
    including running them in a development environment. This helps ensure that your
    microservices will work consistently across different systems, which is essential,
    and also challenging when building microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Docker允许您轻松打包您的微服务和它们的依赖项，使您能够将服务部署到不同的环境中，包括在开发环境中运行。这有助于确保您的微服务能够在不同的系统上保持一致的工作，这对于微服务构建来说是至关重要的，尽管具有挑战性。
- en: While Docker is not strictly necessary for building microservices, it is highly
    recommended as a best practice to improve the efficiency and reliability of your
    microservices deployment. We’ll cover some more best practices in detail in the
    next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker对于构建微服务并非绝对必要，但它作为最佳实践被高度推荐，以提高微服务部署的效率和可靠性。我们将在下一节中详细讨论一些更多最佳实践。
- en: Best practices for building microservices
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务的最佳实践
- en: When building microservices, it’s important to think about best practices to
    ensure that you get the benefits from the additional work required to build a
    microservice application. The system should be scalable, maintainable, and resilient
    – payback for the extra effort! Here are some of the most important best practices
    or “principles” to keep in mind.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，考虑最佳实践以确保您从构建微服务应用程序所需的额外工作中获得好处是非常重要的。系统应该是可扩展的、可维护的和有弹性的——这是额外努力的回报！以下是一些最重要的最佳实践或“原则”，您需要记住。
- en: Design for failure
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 失败设计
- en: Microservices should be “designed for failure.” If they are going to fail (and
    all software will fail!), they should fail gracefully, with redundancy built in
    to ensure that the system continues to function even if one service fails.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该“设计为失败”。如果它们会失败（所有软件都会失败！），它们应该优雅地失败，内置冗余以确保即使一个服务失败，系统也能继续运行。
- en: One of the essential steps when designing for failure is *adding redundancy
    to your system*. This can be achieved by having multiple instances of each service
    running in parallel so that if one fails, others can continue to operate. Note
    that this will incur some additional costs, such as cloud hosting costs. Load
    balancing helps distribute the load evenly across multiple instances of a service,
    reducing the risk of a single instance becoming overwhelmed, and also helps redirect
    the load to another instance if one instance fails.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计失败时，一个重要的步骤是*向您的系统添加冗余*。这可以通过让每个服务的多个实例并行运行来实现，这样如果其中一个失败，其他实例可以继续运行。请注意，这将产生一些额外的成本，例如云托管成本。负载均衡有助于在服务的多个实例之间均匀分配负载，降低单个实例过载的风险，并在一个实例失败时帮助将负载重定向到另一个实例。
- en: '*Circuit breakers* are another useful tool when designing for failure. These
    can be used to automatically detect and isolate failing services, preventing them
    from affecting the rest of the system. This makes it more likely that the overall
    system will continue to operate, even if one service fails.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*断路器*在设计失败时也是另一个有用的工具。这些可以用来自动检测和隔离失败的服务，防止它们影响系统的其余部分。这使得即使一个服务失败，整体系统也有更大的可能性继续运行。'
- en: '*Idempotence* is also crucial when embracing the “design for failure” principle.
    This involves ensuring that each service is idempotent, meaning that it can be
    executed multiple times with the same result. This allows you to retry requests
    if a service fails, reducing the risk of data loss or inconsistent results. You
    will remember that we encountered this topic in the previous chapter when learning
    about certain HTTP verbs. The principle is the same here.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受“失败设计”原则时，*幂等性*也是至关重要的。这涉及到确保每个服务都是幂等的，意味着它可以多次执行并得到相同的结果。这允许您在服务失败时重试请求，从而降低数据丢失或不一致结果的风险。您会记得，我们在上一章学习某些HTTP动词时遇到了这个话题。这里的原理是相同的。
- en: '*Health checks* should be used to periodically test each service and determine
    whether it is operating correctly. This information can then be used to automatically
    redirect requests to other instances of the service if the original instance fails
    (leaning on the redundancy principle). These health checks should run automatically
    or on a defined schedule and can alert the team immediately if any issues arise.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用*健康检查*定期测试每个服务并确定其是否正常运行。然后，可以使用这些信息在原始实例失败时自动将请求重定向到该服务的其他实例（依赖于冗余原则）。这些健康检查应该自动运行或在定义的计划上运行，并在出现任何问题时立即通知团队。
- en: Focus on decoupling
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专注于解耦
- en: Microservices should be (by definition) loosely coupled, with minimal dependencies
    between services. This allows services to be developed, deployed, and modified
    independently, reducing the risk of unintended consequences.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是（按定义）松散耦合的，服务之间依赖性最小。这允许服务独立地进行开发、部署和修改，从而降低意外后果的风险。
- en: Decoupling is a central tenet and is an important aspect of building a microservices-based
    system. Decoupling refers to separating the concerns between different services,
    allowing them to operate independently and reducing the risk of cascading failures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦是一个核心原则，也是构建基于微服务系统的关键方面。解耦指的是在不同服务之间分离关注点，使它们能够独立运行并降低级联故障的风险。
- en: There must be *clear service boundaries* – each service should have a specific
    responsibility and purpose, without overlapping with other services. Doing so
    will help ensure that each service can be developed and deployed independently,
    reducing the interdependencies between services.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 必须有*明确的服务边界*——每个服务都应该有特定的责任和目的，不与其他服务重叠。这样做将有助于确保每个服务可以独立开发和部署，减少服务之间的相互依赖。
- en: '*Asynchronous communication* is an important aspect of decoupling services.
    Instead of direct communication, messages can be sent between services and processed
    at a later time. This allows each service to operate independently, reducing the
    risk of blocking and cascading failures.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步通信*是解耦服务的重要方面。而不是直接通信，消息可以在服务之间发送并在稍后处理。这允许每个服务独立运行，降低阻塞和级联故障的风险。'
- en: It is very important to *implement some form of versioning* when decoupling
    services. Each service should have a version number, which can allow multiple
    versions of a service to coexist in the system. This allows for changes to be
    made to a service without them affecting other services, reducing the interdependencies
    between services. We looked at versioning in the previous chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在解耦服务时实施某种形式的*版本控制*非常重要。每个服务都应该有一个版本号，这可以允许系统中共存多个服务版本。这允许对服务进行更改，而不会影响其他服务，减少服务之间的相互依赖。我们已经在上一章中讨论了版本控制。
- en: '*Using an event-driven architecture* is another important part of decoupling
    services. Events can trigger actions in other services, reducing the need for
    direct communication. This allows each service to operate independently, reducing
    the interdependencies between services. This is often seen with event-based message
    queues facilitating communication between the various services in the system.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用事件驱动架构*是解耦服务的重要部分。事件可以在其他服务中触发动作，减少直接通信的需求。这允许每个服务独立运行，减少服务之间的相互依赖。这在基于事件的消息队列促进系统内各种服务之间的通信时经常看到。'
- en: Finally, *service discovery* is a useful tool for decoupling services. If you
    consider a system that has maybe 20 different loosely coupled services hosted
    in the cloud in a constellation of Docker containers, and perhaps multiple versions
    of some of them, keeping track of where they are all running can become very challenging.
    Using some form of service discovery allows the system to detect and connect to
    other services automatically, reducing the need for hardcoded connections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*服务发现*是解耦服务的有用工具。如果你考虑一个系统，该系统可能包含20个不同的松散耦合服务，这些服务以Docker容器的星系形式托管在云中，并且可能有一些服务的多个版本，跟踪它们所有运行的地点可能会变得非常具有挑战性。使用某种形式的服务发现允许系统自动检测并连接到其他服务，减少硬编码连接的需求。
- en: Embracing the “focus on decoupling” principle helps in building a robust microservices-based
    system. By defining clear service boundaries, using asynchronous communication,
    implementing versioning, using event-driven architecture, and considering service
    discovery, you can ensure that your system is scalable, flexible, and resilient.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接受“关注解耦”原则有助于构建一个健壮的基于微服务的系统。通过定义清晰的服务边界，使用异步通信，实现版本控制，使用事件驱动架构，以及考虑服务发现，你可以确保你的系统是可扩展的、灵活的并且具有弹性。
- en: Embrace automation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受自动化
- en: Automation is critical for the efficient operation of microservices as it helps
    ensure consistency and reliability across services. Automation should be used
    as much as possible to improve testing (with an automated test suite), deployment
    (CI/CD), and scaling (perhaps with Terraform).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化对于微服务的有效运行至关重要，因为它有助于确保服务之间的一致性和可靠性。应尽可能使用自动化来提高测试（使用自动化测试套件）、部署（CI/CD）和扩展（可能使用Terraform）。
- en: Automation is a very important principle in all types of software development,
    but this is doubly true when building a SaaS application that makes use of a microservice
    architecture. Automating deployment and testing processes helps in reducing manual
    efforts and increases the speed of delivering new features to users. Automated
    deployment and testing processes ensure that services are deployed consistently,
    and any issues can be detected early in the development cycle. This helps in reducing
    downtime and increasing the overall efficiency of the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是所有类型软件开发中的一个非常重要的原则，但在构建利用微服务架构的SaaS应用程序时，这一点尤为重要。自动化部署和测试流程有助于减少人工工作量并加快将新功能交付给用户的速度。自动化的部署和测试流程确保服务的一致部署，并在开发周期早期发现任何问题。这有助于减少停机时间并提高系统的整体效率。
- en: '*Implementing CI/CD* helps ensure that code changes are automatically built,
    tested, and deployed. This helps in reducing the manual efforts involved in testing
    new features and gets them into the hands of the users as quickly as possible.
    CI/CD also helps in ensuring that code changes are deployed consistently and any
    issues are detected early in the development cycle. Using pipelines to automatically
    build, test, and deploy microservices will make managing the project as it starts
    to grow considerably easier!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*实施CI/CD*有助于确保代码更改自动构建、测试和部署。这有助于减少测试新功能所涉及的人工工作量，并尽可能快地将它们交付给用户。CI/CD还有助于确保代码更改的一致部署，并在开发周期早期发现任何问题。使用管道自动构建、测试和部署微服务将使项目管理在项目开始增长时变得更加容易！'
- en: It is also useful to automate monitoring and logging. Automating monitoring
    and logging helps in detecting issues early and reduces downtime. Automated monitoring
    and logging processes ensure that the system is monitored consistently and that
    any issues are detected early, reducing manual efforts and increasing the overall
    efficiency of the system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化监控和日志记录也是有用的。自动化监控和日志记录有助于早期发现问题并减少停机时间。自动化的监控和日志记录流程确保系统持续被监控，并且任何问题都能被早期发现，减少人工工作量并提高系统的整体效率。
- en: When in production, a SaaS application can experience rapid fluctuations in
    the demands being placed on various parts of the system. Automation can facilitate
    automatic scaling to ensure that the system can handle increased traffic without
    manual intervention. Automated scaling processes ensure that the system can scale
    up or down based on the traffic, reducing manual efforts and increasing the overall
    efficiency of the system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，SaaS应用程序可能会经历系统各部分需求量的快速波动。自动化可以促进自动扩展，以确保系统在无需人工干预的情况下处理增加的流量。自动扩展流程确保系统可以根据流量进行扩展或缩减，减少人工工作量并提高系统的整体效率。
- en: Embracing the “embrace automation” principle helps in building a robust and
    efficient microservices-based system. Automating deployment and testing processes,
    implementing CI/CD, automating monitoring and logging, and automating scaling
    processes help in streamlining the processes, reducing manual efforts, and increasing
    the efficiency of the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接受“拥抱自动化”原则有助于构建一个健壮且高效的基于微服务的系统。自动化部署和测试流程、实施CI/CD、自动化监控和日志记录以及自动化扩展流程有助于简化流程、减少人工工作量并提高系统的效率。
- en: Use contract-driven development
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于合同的开发
- en: Microservices should have well-defined contracts that define the interface between
    services. This allows services to evolve independently, while still ensuring compatibility.
    In this context, a “contract” means an agreement that specifies the interactions
    between services, including details about the inputs and outputs of each service,
    communication protocols, and data formats. This contract can be represented in
    various forms, such as API specifications, message formats, or documentation,
    and should be agreed upon by all the teams involved in building and maintaining
    the services.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该有定义良好的合同，这些合同定义了服务之间的接口。这允许服务独立演进，同时仍确保兼容性。在这个背景下，“合同”指的是一个协议，它指定了服务之间的交互，包括每个服务的输入和输出细节、通信协议和数据格式。这个合同可以用各种形式表示，如API规范、消息格式或文档，并且应由所有参与构建和维护服务的团队达成一致。
- en: Contract-driven development requires that clear contracts between services are
    defined. These contracts should define the inputs and outputs for each service
    and ensure that the services operate as expected. This helps in reducing the risk
    of breaking changes and increases the overall stability of the system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于合同的开发要求在服务之间定义清晰的合同。这些合同应定义每个服务的输入和输出，并确保服务按预期运行。这有助于降低破坏性变更的风险，并提高系统的整体稳定性。
- en: As with many parts of the application, testing is very important. *Contract
    testing* ensures that the contracts between services are tested and adhered to,
    reducing the risk of breaking changes and increasing the overall stability of
    the system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像应用的其他许多部分一样，测试非常重要。*合同测试*确保服务之间的合同得到测试并遵守，降低破坏性变更的风险，并提高系统的整体稳定性。
- en: The “use contract-driven development” principle helps in building a robust and
    stable microservices-based system. Defining clear contracts between services,
    testing contracts, implementing contract testing, and automating contract testing
    help in ensuring that the services are operating as expected and adhering to the
    defined interface, reducing the risk of breaking changes and increasing the overall
    stability of the system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “使用基于合同的开发”原则有助于构建一个健壮且稳定的基于微服务的系统。在服务之间定义清晰的合同、测试合同、实施合同测试和自动化合同测试，有助于确保服务按预期运行并遵守定义的接口，降低破坏性变更的风险，并提高系统的整体稳定性。
- en: Monitor and log aggressively
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主动监控和记录
- en: Microservices systems generate a large amount of data, and it’s important to
    have a robust monitoring and logging strategy in place. This will help you detect
    and diagnose issues – hopefully, before they have an impact on your user!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务系统生成大量数据，因此实施一个健壮的监控和日志记录策略至关重要。这将帮助您检测和诊断问题——希望在此之前，这些问题不会对您的用户产生影响！
- en: The system should be continuously and automatically monitored, with the monitoring
    covering the overall health of the service, the response times of the whole system
    and each microservice, and resource utilization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应持续自动监控，监控范围包括服务的整体健康状况、整个系统和每个微服务的响应时间以及资源利用率。
- en: Alongside the monitoring solution, there should also be a logging mechanism.
    Logging helps in tracking the activities of the system, detecting issues, and
    troubleshooting any problems. This logging should include logging requests, response
    times, and any error messages.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了监控解决方案之外，还应该有一个日志记录机制。日志记录有助于跟踪系统的活动、检测问题以及排除任何故障。这种日志记录应包括记录请求、响应时间和任何错误消息。
- en: Using centralized logging and monitoring helps in reducing manual efforts and
    increases the efficiency of the system. Centralized logging and monitoring ensure
    that the logs and the monitoring data are stored in a single place, making it
    easier to detect issues and troubleshoot problems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集中式日志记录和监控有助于减少人工工作量并提高系统的效率。集中式日志记录和监控确保日志和监控数据存储在单一位置，这使得检测问题和故障排除变得更加容易。
- en: There is no point in doing this monitoring and logging if the system never reports
    any issues! Automated alerting processes ensure that any issues are detected early
    and the appropriate team is notified, reducing manual efforts and increasing the
    overall efficiency of the system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统从未报告任何问题，进行这种监控和记录就没有意义了！自动警报流程确保任何问题都能及早发现，并且适当的团队会得到通知，从而减少人工工作量并提高系统的整体效率。
- en: Monitoring, logging, and alerting help ensure the system is robust and efficient.
    While they do add a little bit of additional work to the development process,
    which is not seen when the system is running smoothly, they are very much worth
    the time invested when things inevitably go wrong!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 监控、日志记录和警报有助于确保系统稳健高效。虽然它们确实会在开发过程中增加一点额外的工作量，这在系统运行顺畅时并不明显，但当事情不可避免地出错时，这些投入的时间是非常值得的！
- en: Implement security
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施安全
- en: It does somewhat go without saying, but microservices should be secure, with
    appropriate authentication, authorization, and encryption protocols in place.
    It’s also important to have a security strategy that covers the entire system,
    including the network, the infrastructure, and the services themselves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点虽然不言而喻，但微服务应该是安全的，应具备适当的身份验证、授权和加密协议。同时，拥有涵盖整个系统（包括网络、基础设施和自身服务）的安全策略也非常重要。
- en: The nature of microservices is such that security can be challenging. There
    will often be multiple containers running all sorts of different software, each
    with its own set of attack vectors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的本质使得安全可能具有挑战性。经常会运行多个容器，运行各种不同的软件，每个软件都有自己的攻击向量。
- en: Embracing the “implement security” principle is an essential aspect of building
    a microservices-based system. Security helps in protecting sensitive information,
    reducing the risk of security breaches, and ensuring the confidentiality and integrity
    of data. We must follow some steps to embrace this principle.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接受“实施安全”原则是构建基于微服务系统的基本方面。安全有助于保护敏感信息，降低安全漏洞的风险，并确保数据的机密性和完整性。我们必须遵循一些步骤来接受这一原则。
- en: Implementing authentication and authorization is the first step toward embracing
    the “implement security” principle. Authentication and authorization help in ensuring
    that only authorized users can access sensitive information, reducing the risk
    of security breaches. The authentication and authorization process should be robust
    and secure to ensure the confidentiality and integrity of data and must encompass
    every part of the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实施身份验证和授权是接受“实施安全”原则的第一步。身份验证和授权有助于确保只有授权用户才能访问敏感信息，降低安全漏洞的风险。身份验证和授权过程应该是稳健和安全的，以确保数据的机密性和完整性，并且必须涵盖系统的每个部分。
- en: '*Encrypting sensitive data* is a crucial aspect of embracing the “implement
    security” principle. Encryption helps in protecting sensitive information, reducing
    the risk of security breaches, and ensuring the confidentiality and integrity
    of data. The encryption should be applied to all sensitive data, including data
    at rest and data in transit.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密敏感数据*是接受“实施安全”原则的关键方面。加密有助于保护敏感信息，降低安全漏洞的风险，并确保数据的机密性和完整性。加密应应用于所有敏感数据，包括静态数据和传输中的数据。'
- en: Because there are so many moving parts in a SaaS/microservice-based system,
    security should be implemented at a network level to encompass every part of the
    system. The security measures at the network level should include firewalls, intrusion
    detection and prevention systems, and network segmentation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SaaS/微服务系统中有许多动态部分，因此应在网络层面实施安全措施，以涵盖系统的每个部分。网络层面的安全措施应包括防火墙、入侵检测和预防系统以及网络分段。
- en: Security is extremely important in any application. SaaS applications typically
    have complex security requirements. Embracing the “implement security” principle
    from the very start of the project helps in building a secure and reliable microservices-based
    SaaS application. Implementing authentication and authorization, encrypting sensitive
    data, and implementing security at the network level help in reducing the risk
    of security breaches and ensuring the confidentiality and integrity of data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，安全都极其重要。SaaS应用程序通常具有复杂的安全需求。从项目一开始就接受“实施安全”原则有助于构建一个安全可靠的基于微服务的SaaS应用程序。实施身份验证和授权、加密敏感数据以及在网络层面实施安全措施有助于降低安全漏洞的风险并确保数据的机密性和完整性。
- en: Focus on scalability
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注可扩展性
- en: Microservices should be designed to be scalable, both horizontally (by adding
    more instances) and vertically (by adding more resources to existing instances).
    This will allow you to respond quickly to changes in demand and ensure that the
    system continues to perform well under heavy load.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该设计成可扩展的，无论是水平扩展（通过添加更多实例）还是垂直扩展（通过向现有实例添加更多资源）。这将使您能够快速响应需求的变化，并确保系统在重负载下仍能良好运行。
- en: Embracing the “focus on scalability” principle is another important aspect of
    building a microservices-based SaaS application. Scalability helps in ensuring
    that the system can handle increased traffic, reduce downtime, and improve the
    overall performance of the system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥抱“关注可扩展性”原则是构建基于微服务的SaaS应用程序的另一个重要方面。可扩展性有助于确保系统可以处理增加的流量，减少停机时间，并提高系统的整体性能。
- en: Designing for scalability is the first step toward embracing the “focus on scalability”
    principle. Scalable design helps in ensuring that the system can handle increased
    traffic, reduce downtime, and improve the overall performance of the system. The
    design should take into account the expected traffic and resource utilization
    and should include provisions for increasing the resources as needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设计可扩展性是拥抱“关注可扩展性”原则的第一步。可扩展的设计有助于确保系统可以处理增加的流量，减少停机时间，并提高系统的整体性能。设计应考虑预期的流量和资源利用率，并应包括在需要时增加资源的措施。
- en: As we discussed earlier, containerization helps in improving the scalability
    of the system by packaging the services and their dependencies, making it easier
    to deploy and scale the services as needed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，容器化通过打包服务和它们的依赖项，有助于提高系统的可扩展性，使得按需部署和扩展服务变得更加容易。
- en: To get the most benefit from a containerized application, you should include
    a load balancer. Load balancing helps in distributing the traffic evenly across
    the available resources, reducing downtime and improving the overall performance
    of the system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要从容器化应用程序中获得最大利益，您应包括负载均衡器。负载均衡有助于在可用资源之间均匀分配流量，减少停机时间并提高系统的整体性能。
- en: With containers and a load balancer, it is possible to automate scaling in the
    application. Implementing auto-scaling helps in ensuring that the system can handle
    increased traffic, reduce downtime, and improve the overall performance of the
    system. Auto-scaling automatically increases or decreases the resources as needed,
    based on the traffic and resource utilization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过容器和负载均衡器，可以实现应用程序的自动化扩展。实施自动扩展有助于确保系统可以处理增加的流量，减少停机时间，并提高系统的整体性能。自动扩展会根据流量和资源利用率自动增加或减少所需的资源。
- en: Designing for scalability, embracing containerization, implementing load balancing,
    and implementing auto-scaling help in ensuring that the system can handle increased
    traffic, reduce downtime, and improve the overall performance of the system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设计可扩展性、拥抱容器化、实施负载均衡和实施自动扩展有助于确保系统可以处理增加的流量，减少停机时间，并提高系统的整体性能。
- en: Separate data stores
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离的数据存储
- en: Most applications have a single database that stores all of the information
    associated with the application. While this approach can be taken in a microservices
    application, you can also implement a database on a per-service basis. There are
    pros and cons to this approach, and you don’t necessarily need to use a separate
    data store per service. The choice of using a separate data store per service
    or a shared data store depends on the requirements and constraints of your system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都有一个数据库，存储与该应用程序相关的所有信息。虽然这种方法也可以在微服务应用程序中采用，但您还可以按服务实现数据库。这种方法有其优缺点，并且您不一定需要为每个服务使用单独的数据存储。是否使用每个服务的单独数据存储或共享数据存储取决于您系统的需求和限制。
- en: 'Having separate data stores for each service can provide benefits such as these:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个服务拥有单独的数据存储可以提供如下好处：
- en: '**Improved scalability**: Each service can scale its data store independently,
    allowing for better resource utilization and reducing the likelihood of resource
    contention'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升可扩展性**：每个服务都可以独立扩展其数据存储，从而实现更好的资源利用并降低资源争用的可能性'
- en: '**Improved resilience**: Each service can continue to function, even if one
    of the data stores experiences an issue'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提升弹性**：即使数据存储中的一个出现问题时，每个服务仍可以继续运行'
- en: '**Improved data isolation**: Each service has complete control over its data,
    making it easier to maintain data consistency and integrity'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高数据隔离性**：每个服务对其数据有完全的控制权，这使得维护数据一致性和完整性更容易'
- en: 'However, separate data stores can also introduce challenges:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，独立的数据存储也可能带来挑战：
- en: '**Increased operational complexity**: Managing multiple data stores can be
    more complex than managing a single data store'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的操作复杂性**：管理多个数据存储可能比管理单个数据存储更复杂'
- en: '**Increased latency**: Communication between services to access data in different
    data stores can introduce latency'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加延迟**：服务之间为了访问不同数据存储中的数据而进行的通信可能会引入延迟'
- en: '**Increased data duplication**: The same data may need to be stored in multiple
    data stores, increasing storage costs and the risk of data inconsistency'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的数据重复**：相同的数据可能需要在多个数据存储中存储，这会增加存储成本和数据不一致的风险'
- en: A shared data store, on the other hand, can simplify the architecture and reduce
    operational complexity, but it can also introduce constraints on scalability,
    resilience, and data isolation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用共享数据存储可以简化架构并减少操作复杂性，但它也可能对可扩展性、弹性和数据隔离引入限制。
- en: Ultimately, the choice between separate data stores and a shared data store
    depends on the specific requirements and constraints of your system and should
    be made based on a careful evaluation of the trade-offs involved.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择独立数据存储和共享数据存储取决于你系统的具体需求和限制，并且应该基于对涉及到的权衡的仔细评估来做出决定。
- en: Designing microservice applications is hard. There is a lot to think about to
    make sure that you can realize the benefits of this approach! These best practices
    will help you build microservices that are scalable, maintainable, and resilient.
    By following them, you can ensure that your microservices-based system is optimized
    for performance, efficiency, and reliability!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务应用程序是困难的。有很多事情需要考虑，以确保你能实现这种方法的益处！这些最佳实践将帮助你构建可扩展、可维护和有弹性的微服务。通过遵循它们，你可以确保你的基于微服务的系统在性能、效率和可靠性方面得到优化！
- en: Mixing microservices and RESTful APIs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合微服务和RESTful API
- en: When building a microservices-based architecture, REST is often used as the
    communication protocol between the different services. **REST**, or **Representational
    State Transfer**, is a commonly used and widely adopted web service architecture
    that provides a standardized way for clients and servers to communicate with each
    other. Microservices and REST are a natural fit, as REST provides the necessary
    communication infrastructure for microservices to communicate and exchange data
    with each other. We discussed contract-based development previously; the surface
    of the REST API can be seen as the contract for communication between services.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建基于微服务的架构时，REST通常用作不同服务之间的通信协议。**REST**，或**表征状态转移**，是一种常用且广泛采用的Web服务架构，为客户端和服务器之间提供了标准化的通信方式。微服务和REST是自然匹配的，因为REST为微服务之间的通信和数据交换提供了必要的通信基础设施。我们之前讨论了基于契约的开发；REST
    API的表面可以看作是服务之间通信的契约。
- en: One of the key advantages of using REST in a microservices-based system is that
    it provides a clear and standard way for services to communicate with each other.
    REST defines a set of rules for how services should exchange data, including the
    use of HTTP methods such as GET, POST, and DELETE, and the use of HTTP status
    codes to indicate success or failure. This makes it easy for developers to build
    and maintain microservices, as they know exactly what to expect when communicating
    with other services.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的系统中使用REST的一个关键优点是，它为服务之间提供了清晰和标准的通信方式。REST定义了一套规则，用于服务如何交换数据，包括使用HTTP方法（如GET、POST和DELETE）以及使用HTTP状态码来指示成功或失败。这使得开发者更容易构建和维护微服务，因为他们知道在与其他服务通信时可以期待什么。
- en: Another advantage of using REST in a microservices-based system is that it provides
    a scalable and flexible way for services to communicate with each other. REST
    is platform-agnostic, typically communicating over HTTP, which means that it can
    be used with a variety of programming languages and technologies, making it an
    ideal choice for building microservices.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于微服务的系统中使用REST的另一个优点是，它为服务之间提供了一种可扩展且灵活的通信方式。REST是平台无关的，通常通过HTTP进行通信，这意味着它可以与各种编程语言和技术一起使用，使其成为构建微服务的理想选择。
- en: Finally, using REST in a microservices-based system provides a secure way for
    services to communicate with each other. REST uses standard web security measures
    such as SSL/TLS encryption, which helps protect data in transit, and HTTP authentication,
    which helps ensure that only authorized clients can access the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在基于微服务的系统中使用REST提供了一种安全的服务间通信方式。REST使用标准的Web安全措施，如SSL/TLS加密，这有助于保护传输中的数据，以及HTTP身份验证，这有助于确保只有授权客户端可以访问数据。
- en: Microservices and REST are a natural fit, and using REST as the communication
    protocol between microservices provides a clear, scalable, and secure way for
    services to communicate and exchange data with each other. By using REST, developers
    can build and maintain microservices-based systems with confidence, knowing that
    they have a reliable and widely adopted communication infrastructure in place.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务和REST是天生匹配的，使用REST作为微服务之间的通信协议提供了一种清晰、可扩展且安全的服务间通信和交换数据的方式。通过使用REST，开发者可以自信地构建和维护基于微服务的系统，因为他们知道他们有一个可靠且广泛采用的通信基础设施。
- en: Splitting up a single REST API into microservices
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单个REST API拆分为微服务
- en: When you think of a “typical” RESTful API, you will probably be thinking of
    a system with several controllers, each grouping several related methods or endpoints.
    It is not uncommon for an enterprise system with a single **monolithic** API to
    have dozens of controllers and hundreds of endpoints. Splitting this up into a
    contract-driven microservice-based system is not easy. There is no one correct
    way to approach this, and it can be more art than science.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到一个“典型”的RESTful API时，你可能会想到一个包含多个控制器、每个控制器包含几个相关方法或端点的系统。一个企业系统拥有单个**单体**API并拥有数十个控制器和数百个端点并不罕见。将它们拆分为基于契约的微服务系统并不容易。没有一种正确的方法来处理这个问题，这更像是一门艺术而不是科学。
- en: 'Here are a few approaches that can be taken for splitting up a monolithic REST
    API into microservices:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以将单体REST API拆分为微服务的方法：
- en: '**Functionality-based**: This approach involves breaking down the monolithic
    API into smaller services based on the functionality they provide. For example,
    a service could be created to handle user authentication, while another could
    handle product management. This approach makes it easier to manage and maintain
    the services, as each one is focused on a specific task.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能驱动**: 这种方法涉及根据它们提供的功能将单体API分解为更小的服务。例如，可以创建一个服务来处理用户身份验证，另一个服务来处理产品管理。这种方法使得管理和维护服务变得更加容易，因为每个服务都专注于特定的任务。'
- en: '**Data-driven**: In this approach, the monolithic API is broken down into services
    based on the data they manage. For example, a service could be created to manage
    customer information, while another could manage order information. This approach
    is useful when there are different data access patterns, security requirements,
    or performance requirements for different datasets.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据驱动**: 在这种方法中，单体API被分解为基于它们管理的数据的服务。例如，可以创建一个服务来管理客户信息，另一个服务来管理订单信息。当不同数据集有不同的数据访问模式、安全要求或性能要求时，这种方法很有用。'
- en: '**Domain-driven**: This approach involves breaking down the monolithic API
    into services based on the domain it represents. For example, a service could
    be created to manage information about customers, while another could manage information
    about products. This approach is useful when there are complex business domains
    that can be broken down into smaller, manageable pieces.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域驱动**: 这种方法涉及根据它所代表的领域将单体API分解为服务。例如，可以创建一个服务来管理客户信息，另一个服务来管理产品信息。当存在可以分解为更小、更易管理的部分的复杂业务领域时，这种方法很有用。'
- en: '**Micro frontends**: This approach involves breaking down the monolithic API
    into microservices and using a micro frontend architecture to combine the services
    into a single user interface. This approach provides a way to scale the frontend
    and the backend independently, while still providing a seamless user experience.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微前端**: 这种方法涉及将单体API分解为微服务，并使用微前端架构将服务组合成一个单一的用户界面。这种方法提供了一种独立扩展前端和后端的方式，同时仍然提供无缝的用户体验。'
- en: Regardless of the approach used, it is important to consider the complexity
    of the API, the dependencies between the different parts of the API, and the skills
    and resources of the development team when determining the best way to split up
    a monolithic API into microservices. Additionally, it is important to continuously
    evaluate and refactor the microservices as needed to ensure that they continue
    to meet the needs of the application and the business.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法，在确定将单体API拆分为微服务的最佳方式时，考虑API的复杂性、API不同部分之间的依赖关系以及开发团队的技能和资源都是非常重要的。此外，根据需要持续评估和重构微服务，以确保它们继续满足应用程序和业务的需求。
- en: An often-asked question when discussing REST and microservices is, “*Should
    each controller in an API be its* *own microservice?*”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论REST和微服务时，经常被问到的问题是，“*API中的每个控制器是否应该是自己的微服务？*”
- en: The answer is not straightforward and depends on the specific requirements of
    your system and the size and complexity of each controller. In general, each microservice
    should represent a single, self-contained business capability, and multiple controllers
    can be part of a single microservice if they work together to provide a single
    business function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 答案并不直接，取决于您系统的具体要求以及每个控制器的规模和复杂性。一般来说，每个微服务应代表一个单一、自包含的业务能力，如果多个控制器共同提供单一业务功能，它们可以是一个微服务的一部分。
- en: If the controllers are tightly coupled and cannot be separated, it might make
    sense to have them in a single microservice. On the other hand, if each controller
    has separate business logic and data storage, and can be deployed and scaled independently,
    it might be a better fit to have each controller in its own microservice.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果控制器紧密耦合且无法分离，将它们放在单个微服务中可能是有意义的。另一方面，如果每个控制器具有独立的企业逻辑和数据存储，并且可以独立部署和扩展，那么每个控制器在其自己的微服务中可能更适合。
- en: The key is to determine the business functions that need to be performed and
    to decompose the system into a set of self-contained microservices that can be
    developed, deployed, and scaled independently. When in doubt, it is better to
    start with smaller microservices and consolidate them later if needed. This allows
    for easier testing and debugging, as well as more rapid development and deployment
    cycles.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于确定需要执行的业务功能，并将系统分解成一系列自包含的微服务，这些微服务可以独立开发、部署和扩展。当不确定时，最好从较小的微服务开始，如果需要的话再进行整合。这有助于简化测试和调试，以及更快的开发和部署周期。
- en: Each controller in an API doesn’t necessarily have to be its own microservice,
    but the decision should be based on the specific requirements of your system and
    the size and complexity of each controller.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: API中的每个控制器不一定是自己的微服务，但决策应基于您系统的具体要求以及每个控制器的规模和复杂性。
- en: 'When combining microservices and REST, there are several important topics to
    cover to build a robust and scalable system, which play a crucial role in building
    a microservices-based system:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合微服务和REST时，有几个重要主题需要涵盖，以构建一个健壮且可扩展的系统，这在构建基于微服务的系统中起着至关重要的作用：
- en: '**Designing RESTful APIs**: RESTful APIs should be designed to be scalable,
    flexible, and easy to consume.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计RESTful API**：RESTful API应设计为可扩展、灵活且易于消费。'
- en: '**API documentation**: API documentation should be clear, concise, and easy
    to understand, and should provide clear instructions on how to consume the APIs.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API文档**：API文档应清晰、简洁且易于理解，并提供如何消费API的明确说明。'
- en: '**API versioning**: API versioning helps in ensuring that the system can evolve,
    without breaking existing integrations.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API版本控制**：API版本控制有助于确保系统可以进化，而不会破坏现有的集成。'
- en: '**API security**: API security should be implemented to protect against unauthorized
    access, data theft, and other security risks.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API安全**：应实施API安全以防止未经授权的访问、数据盗窃和其他安全风险。'
- en: '**Error handling**: Error handling should be implemented to ensure that the
    system can handle and respond to errors consistently and predictably.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：应实施错误处理以确保系统能够一致和可预测地处理和响应错误。'
- en: '**Data consistency**: Data consistency is a crucial aspect of building a microservices-based
    system. Data consistency should be maintained across the microservices, to ensure
    that the system behaves as expected.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：数据一致性是构建基于微服务系统的关键方面。应在微服务之间保持数据一致性，以确保系统按预期运行。'
- en: When combining microservices and REST, it is important to focus on designing
    RESTful APIs, providing clear API documentation, implementing API versioning,
    securing the APIs, handling errors, and maintaining data consistency. These topics
    help in building a robust and scalable system that can handle increased traffic
    and provide a better user experience.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合微服务和REST时，重要的是要专注于设计RESTful API，提供清晰的API文档，实现API版本控制，确保API的安全性，处理错误，并维护数据一致性。这些主题有助于构建一个健壮且可扩展的系统，能够处理增加的流量并提供更好的用户体验。
- en: Common pitfalls and how to avoid them
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱及其避免方法
- en: Building SaaS apps is hard. Building a microservice application is hard. Combining
    the two is really hard, and there are several common pitfalls that you should
    avoid!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构建SaaS应用很难。构建微服务应用很难。将两者结合起来真的很难，而且有几个常见的陷阱你应该避免！
- en: The first, most common, and most important one to avoid is building the microservices
    too early. It is often easier to start with a monolith and slowly break off small
    sections of the app into small, self-contained services when the need arises and
    not before.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 避免的第一个、最常见且最重要的陷阱是过早地构建微服务。通常情况下，从单体开始，并在需要时逐渐将应用的小部分拆分为小型、自包含的服务，而不是提前这样做，会更容易。
- en: So, perhaps the best advice I can give about microservices is to not use them...
    until you have to! But, given that this is a chapter about microservices, here
    are some common traps that should be avoided if you have decided to go down this
    route!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于微服务，我能给出的最好建议可能就是不要使用它们……除非你真的需要！但是，鉴于这是一本关于微服务的章节，以下是一些如果你决定走这条路应该避免的常见陷阱！
- en: '**Over-complication**: One of the most common pitfalls when building microservices
    is over-complicating the architecture. This can result in additional bugs, increased
    maintenance costs, and longer development times.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度复杂化**：在构建微服务时最常见的陷阱之一就是过度复杂化架构。这可能导致额外的错误、增加的维护成本和更长的开发时间。'
- en: '**Lack of communication and coordination**: When building microservices, it
    is important to ensure that there is effective communication and coordination
    between teams. Without this, there can be delays and misunderstandings, which
    can result in problems with the overall architecture, which will inevitably manifest
    as a degraded experience for the users of the system.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏沟通和协调**：在构建微服务时，确保团队之间有有效的沟通和协调是很重要的。没有这一点，可能会出现延误和误解，这可能导致整体架构出现问题，这不可避免地会表现为系统用户体验的下降。'
- en: '**Inconsistent data**: When using microservices, it is important to ensure
    that data is consistent across all services. Otherwise, it can lead to problems
    with data integrity and accuracy.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据不一致**：在使用微服务时，确保数据在所有服务中保持一致是很重要的。否则，可能会导致数据完整性和准确性问题。'
- en: '**Increased deployment complexity**: Microservices can increase deployment
    complexity as each service must be deployed and managed individually.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署复杂性增加**：微服务可能会增加部署复杂性，因为每个服务都必须单独部署和管理。'
- en: '**Debugging complexity**: Debugging complex microservice architectures can
    be more difficult than debugging a monolithic architecture.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试复杂性**：调试复杂的微服务架构可能比调试单体架构更困难。'
- en: 'Here’s how to avoid the common pitfalls when building microservices:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在构建微服务时避免常见陷阱的方法：
- en: '**Over-complicated microservice architecture**: This can be avoided by keeping
    the architecture simple, focusing on the single responsibility principle, and
    defining clear boundaries for each microservice. It is also important to prioritize
    the microservices that need to be built and make sure they align with business
    goals.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度复杂的微服务架构**：可以通过保持架构简单、专注于单一职责原则，并为每个微服务定义清晰的边界来避免。同样重要的是要优先考虑需要构建的微服务，并确保它们与业务目标一致。'
- en: '**Lack of communication and collaboration between teams**: This can be mitigated
    by creating a culture of collaboration and having clear communication channels
    between teams. It’s also important to have regular meetings between teams to ensure
    that everyone is on the same page.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队间缺乏沟通和协作**：可以通过营造协作文化，在团队之间建立清晰的沟通渠道来缓解。定期召开团队会议也很重要，以确保每个人都处于同一页面上。'
- en: '**Underestimating the complexity of data management**: To avoid this, it’s
    important to properly plan out the data management strategy for each microservice.
    This includes defining the data sources, data ownership, and data consistency.
    Using a data management solution, such as a data management platform or event
    sourcing, can also help.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低估数据管理的复杂性**：为了避免这一点，重要的是要为每个微服务合理规划数据管理策略。这包括定义数据源、数据所有权和数据一致性。使用数据管理解决方案，如数据管理平台或事件溯源，也可以有所帮助。'
- en: '**Not adequately monitoring microservices**: To avoid this pitfall, it’s important
    to have a solid monitoring strategy in place. This includes setting up logging
    and monitoring for each microservice and having alerting mechanisms in place for
    when things go wrong.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未能充分监控微服务**：为了避免这个陷阱，重要的是要有一个稳固的监控策略。这包括为每个微服务设置日志记录和监控，并在出现问题时设置警报机制。'
- en: '**Lack of security considerations**: To avoid this, it’s important to have
    a solid security strategy in place. This includes considering security at every
    stage of the microservice development process, including architecture, design,
    development, and deployment. It’s also important to regularly review the security
    strategy and make changes as needed.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏安全考虑**：为了避免这一点，重要的是要有一个稳固的安全策略。这包括在微服务开发的每个阶段（包括架构、设计、开发和部署）考虑安全。定期审查安全策略并根据需要做出更改也同样重要。'
- en: Some practical advice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些实用建议
- en: Microservices are a huge and complex topic – rather than trying to give a demonstration
    of a full microservice application here, I will instead offer some practical advice
    using the demo app we have been building as the basis for this advice. The implementation
    is left up to you!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个庞大且复杂的话题——而不是在这里尝试展示一个完整的微服务应用程序的演示，我将提供一些基于我们一直在构建的演示应用程序的实用建议。具体的实现留给你来完成！
- en: A microservice architecture example
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构示例
- en: It is worth reiterating that in many cases, the best approach when planning
    a new application is to start with a single monolith app and carve off sections
    of the app into microservices when the need arises.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值得重申的是，在规划新的应用程序时，在许多情况下，最佳做法是从一个单体的应用程序开始，并在需要时将应用程序的部分划分为微服务。
- en: 'For this example, I will assume that the Good Habits app has grown to the point
    where it is necessary to start thinking about separating it into microservices.
    I think that a useful way to split this up might be something like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我将假设 Good Habits 应用程序已经发展到需要开始考虑将其划分为微服务的地步。我认为一种有用的分割方式可能如下：
- en: '![Figure 6.1 – Suggested microservice architecture](img/B19343_06_01.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 建议的微服务架构](img/B19343_06_01.jpg)'
- en: Figure 6.1 – Suggested microservice architecture
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 建议的微服务架构
- en: Let’s discuss the components in this diagram a bit more.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论一下这个图中的组件。
- en: User interfaces and clients
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面和客户端
- en: It is very common these days for an application to have both a web client app
    and a mobile app – and sometimes, a desktop application as well. All of these
    clients will be communicating with the same backend and the same microservices.
    It is common to build a single **gateway** API that manages all external communication
    between the various microservices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个应用程序既有网络客户端应用程序又有移动应用程序——有时，还有桌面应用程序，这种情况非常普遍。所有这些客户端都将与同一个后端和同一个微服务进行通信。通常，会构建一个单一的
    **网关** API 来管理各种微服务之间的所有外部通信。
- en: API gateway
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 网关
- en: Although it’s possible to enable user interface applications to directly communicate
    with microservices, managing this can become incredibly complex. The diagram only
    displays three microservices, but there could easily be 20 or more. Consider the
    added complexity of orchestrating communication between more than 20 microservices
    and three or more types of client UI – the situation becomes even more difficult
    to visualize and much harder to manage in practice!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有可能让用户界面应用程序直接与微服务进行通信，但管理这一点可能会变得极其复杂。图中只显示了三个微服务，但实际上可能有 20 个或更多。考虑一下在 20
    个或更多的微服务以及三种或更多类型的客户端 UI 之间协调通信的附加复杂性——这种情况在视觉上变得更加困难，在实践中也更难以管理！
- en: Using an API gateway in a microservice architecture provides several benefits.
    Firstly, an API gateway acts as a single entry point for clients, allowing for
    easier management of requests, authentication, and authorization. It also enables
    the composition of different microservices into a unified API, which can simplify
    the client’s interaction with the system. The API gateway can also provide load
    balancing and failover capabilities, which are important for high-availability
    systems. Another important benefit is the ability to enforce security and traffic
    policies, as well as to monitor and log requests. By using an API gateway, developers
    can more easily manage and evolve a microservice architecture, while maintaining
    a high level of security and performance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中使用API网关提供了几个好处。首先，API网关充当客户端的单一点入口，使得请求管理、身份验证和授权更加容易。它还允许将不同的微服务组合成一个统一的API，这可以简化客户端与系统的交互。API网关还可以提供负载均衡和故障转移功能，这对于高可用性系统非常重要。另一个重要好处是能够强制执行安全性和流量策略，以及监控和记录请求。通过使用API网关，开发者可以更容易地管理和演进微服务架构，同时保持高水平的安全性和性能。
- en: Message broker
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息代理
- en: A message broker is used to facilitate communication between the various backend
    microservices. This performs much the same function on the backend as the API
    gateway does for the frontend. It detangles all of the communication between the
    services. Again, while we only have three services in the diagram, we should keep
    in mind that a real-world system may have many more, and inter-service communication
    can quickly become extremely complex and inefficient.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理用于促进各种后端微服务之间的通信。这在后端执行的功能与API网关在前端执行的功能非常相似。它解开了服务之间的所有通信。虽然我们图中只有三个服务，但我们应记住，现实世界的系统可能拥有更多服务，并且服务间的通信可能会迅速变得极其复杂和低效。
- en: Using a message broker in a microservice architecture provides many benefits.
    One of the main advantages is that it allows services to communicate with each
    other asynchronously, decoupling the sender from the receiver. This can improve
    reliability and scalability as services can process messages at their own pace
    and are not blocked by the performance of other services. A message broker can
    also act as a buffer between services, which can be particularly useful if one
    service is temporarily unavailable. It can help avoid message loss by persisting
    messages until they can be delivered to the appropriate service. A message broker
    can also provide a centralized way to monitor and manage the flow of messages
    between services, making it easier to track and debug issues. Finally, by separating
    the communication concerns from the business logic, services can be more easily
    tested and deployed independently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中使用消息代理提供了许多好处。其中一个主要优势是它允许服务以异步方式相互通信，解耦发送者与接收者。这可以提高可靠性和可伸缩性，因为服务可以以自己的速度处理消息，不会被其他服务的性能所阻塞。消息代理还可以作为服务之间的缓冲区，这在某个服务暂时不可用时尤其有用。它可以通过持久化消息直到它们可以被交付到适当的服务来帮助避免消息丢失。消息代理还可以提供一种集中式的方式来监控和管理服务之间的消息流，这使得跟踪和调试问题更加容易。最后，通过将通信关注点从业务逻辑中分离出来，服务可以更容易地进行测试和独立部署。
- en: Using a message broker (and an API gateway) leans into a number of the microservice
    good design principles that we discussed earlier in this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息代理（以及API网关）遵循了我们之前在本章中讨论的许多微服务良好设计原则。
- en: 'Several message brokers are commonly used in .NET microservice applications,
    including the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET微服务应用程序中，常用的几个消息代理包括以下：
- en: '**RabbitMQ**: An open source message broker that supports multiple messaging
    protocols, including AMQP, MQTT, and STOMP'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RabbitMQ**：一个支持多种消息协议的开源消息代理，包括AMQP、MQTT和STOMP'
- en: '**Apache Kafka**: A distributed streaming platform that is optimized for handling
    high-volume and high-velocity data streams'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Kafka**：一个优化的分布式流平台，适用于处理高容量和高速度的数据流'
- en: '**Azure Service Bus**: A fully-managed messaging service provided by Microsoft
    Azure that supports both traditional messaging patterns and pub/sub scenarios'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Service Bus**：由Microsoft Azure提供的一个完全托管的 messaging 服务，支持传统消息模式和 pub/sub
    场景'
- en: '**AWS Simple Queue Service (SQS)**: A fully-managed message queue service provided
    by Amazon Web Services that decouples and scales microservices, distributed systems,
    and serverless applications'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS Simple Queue Service (SQS)**: 亚马逊网络服务提供的一项完全托管的消息队列服务，用于解耦和扩展微服务、分布式系统和无服务器应用程序'
- en: '**NServiceBus**: A messaging framework for .NET that provides a unified programming
    model for building distributed systems using a variety of messaging patterns'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NServiceBus**: 一个.NET消息框架，提供了一种统一的编程模型，用于使用各种消息模式构建分布式系统'
- en: All of these tools provide reliable message delivery, scalability, and fault
    tolerance, and they can help simplify the communication between microservices
    in a distributed system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都提供可靠的消息传递、可扩展性和容错性，并且可以帮助简化分布式系统中微服务之间的通信。
- en: The services
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: 'To give an example, I have laid out three services:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以举例来说，我已经概述了三种服务：
- en: A user service, which will handle everything related to the users. This includes
    authentication, password management, and keeping personal information up to date.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户服务，将处理与用户相关的一切。这包括身份验证、密码管理和保持个人信息更新。
- en: A habit service, which deals with everything related to the habits that the
    users are trying to track.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个习惯服务，处理与用户试图跟踪的习惯相关的一切。
- en: A feed service. In this more advanced version of the Good Habits app, I have
    assumed that there will be the ability to see your friends’ progress in a social
    media-style feed.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个内容服务。在这个更高级的Good Habits应用版本中，我假设将能够以社交媒体风格的内容流查看你朋友的进度。
- en: Please note that I have chosen to also separate the data stores into individual
    databases. This allows us to treat each data store slightly differently. I have
    also decided to use a relational database for the User and the Habit service,
    but a document (NoSQL) database for the Feed service. This is a superpower of
    microservices – you can use different types of data storage based on the use case
    for individual microservices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我选择将数据存储也分开到单独的数据库中。这使我们能够对每个数据存储进行稍微不同的处理。我还决定为用户和习惯服务使用关系型数据库，而为内容服务使用文档（NoSQL）数据库。这是微服务的一个超级功能——可以根据单个微服务的用例使用不同类型的数据存储。
- en: The User service
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户服务
- en: I have specifically broken this out because storing users’ private data should
    be taken very seriously. This data may include banking information (if the service
    has a paid tier) and may include personal information. It is easy to understand
    that the data that is stored in the User service may have to be treated more securely
    than the data in the Habit service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我特别将其分开，因为存储用户私人数据应该非常认真对待。这些数据可能包括银行信息（如果服务有付费层）和可能包括个人信息。很容易理解存储在用户服务中的数据可能需要比习惯服务中的数据更安全地处理。
- en: We should also consider that users in many jurisdictions have the right to be
    forgotten. By grouping all of the personal data in one place, we make this easier
    to achieve.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑许多司法管辖区中的用户有权被遗忘。通过将所有个人数据集中在一个地方，我们使这一点更容易实现。
- en: The User service would probably not be subject to particularly high demand.
    Users would be expected to update their details infrequently, so this service
    could have fewer resources allocated to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用户服务可能不会面临特别高的需求。预计用户不会经常更新他们的详细信息，因此可以为这个服务分配较少的资源。
- en: The Habit service
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习惯服务
- en: In the Good Habits application, it would be expected that the Habit service
    would do most of the heavy lifting in the application, and so would have additional
    resources allocated to it. This service should also be designed to scale easily
    so that more development time can be put into the performance, and perhaps less
    attention is paid to security than for the User service. (Of course, security
    is still important!!)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Good Habits应用程序中，预计习惯服务将在应用程序中承担大部分繁重的工作，因此将分配额外的资源给它。这个服务还应设计得易于扩展，以便可以将更多的时间投入到性能上，也许对用户服务的关注会少于对安全性的关注。（当然，安全性仍然很重要！！）
- en: The type of data in this service would be highly relational, so a relational
    store is the most appropriate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务中的数据类型将高度相关，因此关系型存储是最合适的。
- en: The Feed service
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容服务
- en: If we envisage a much more advanced version of the Good Habits app, we may have
    expanded to the point where we have a social network-type sets of features, which
    allows users to see their friends' progress and celebrate their success with them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设想一个更高级的Good Habits应用程序版本，我们可能已经扩展到拥有类似社交网络的功能集，这允许用户看到他们朋友的成绩并与他们一起庆祝他们的成功。
- en: This type of service is usually modeled using a document store, or something
    like GraphQL. A relational store is not appropriate. Using a microservice architecture
    allows us to choose the most appropriate type of data store!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的服务通常使用文档存储或类似GraphQL的东西来建模。关系型存储不合适。使用微服务架构允许我们选择最合适的数据存储类型！
- en: All of the information in the feed will have been selected by the users to make
    publicly available, so data security is less important in this service. We can
    be sure that there is no private data in this service, as the user data stores
    are not accessible from this service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 播放器中的所有信息都将由用户选择以供公开，因此在此服务中数据安全不太重要。我们可以确信在此服务中没有私有数据，因为用户数据存储对此服务不可访问。
- en: Overall architecture
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总体架构
- en: The architecture in *Figure 6**.1* shows one way that we could use microservices
    to break up the application. But there are many possible ways to do this, and
    it is more art than science.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**图6**.1中的架构展示了我们可以使用微服务来拆分应用程序的一种方式。但做这件事有许多可能的方法，这更多的是艺术而非科学。'
- en: The most important thing is to be guided by your users, and mindful of how the
    choices you make in splitting up the monolith will impact the users.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要遵循用户的需求，并考虑到你在拆分单体应用时所做的选择将如何影响用户。
- en: A practical example
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例
- en: While it is outside the scope of this chapter to provide a complete example
    of a microservices project, we can build out some of the principles in the `GoodHabits`
    project to cement our understanding of the preceding advice.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章范围内提供微服务项目的完整示例超出了范围，但我们可以在`GoodHabits`项目中构建一些原则，以巩固我们对先前建议的理解。
- en: 'To illustrate this, we can do the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以做以下操作：
- en: Add a very basic `UserService`, to show how we can interact with multiple microservices.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个非常基础的`UserService`，以展示我们如何与多个微服务交互。
- en: Add an API gateway that serves as a single point of entry to all of the microservices
    from any clients interacting with the system.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个API网关，作为所有客户端与系统交互时的单一入口点。
- en: UserService
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserService
- en: 'Run the following script to add the project and files for the User service:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下脚本以添加用户服务的项目和文件：
- en: '[PRE0]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we will configure how to start the Users microservices. Set up the `launchSettings.json`
    file so that it looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置如何启动用户微服务。设置`launchSettings.json`文件，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, add the following code to the controller:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下代码添加到控制器中：
- en: '[PRE2]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is all that is required to set up a very simple User service. You can start
    this up independently and see how it works with Swagger. The provided functionality
    is very basic, and it would be a fantastic exercise to try to build this service
    out a bit more.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置一个非常简单的用户服务所需的所有内容。你可以独立启动它，并查看它与Swagger如何协同工作。提供的功能非常基础，尝试构建这个服务更多一些将是一项极好的练习。
- en: API gateway
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API网关
- en: As described previously, an API gateway gives a client using the application
    a single point of entry into the application. All they need to do is talk to the
    gateway, and the complexity of the microservice implementation is kept hidden.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，API网关为使用应用程序的客户端提供了一个进入应用程序的单一点。他们需要做的只是与网关通信，从而隐藏了微服务实现的复杂性。
- en: 'We will use a package called Ocelot, which provides most of the functionality
    that we will need out of the box. To get started, execute the following script
    to set up the `ApiGateway` project:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为Ocelot的包，它提供了我们需要的绝大多数功能。要开始，执行以下脚本以设置`ApiGateway`项目：
- en: '[PRE3]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we did with `UserService`, we will need to modify the `launchsettings.json`
    file to configure how the API gateway starts. Set up the file like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对`UserService`所做的那样，我们需要修改`launchsettings.json`文件来配置API网关的启动方式。设置文件如下：
- en: '[PRE4]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, make the `Program.cs` file look like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使`Program.cs`文件看起来像这样：
- en: '[PRE5]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, you can see the key lines for the `Ocelot` package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`Ocelot`包的关键行。
- en: 'Finally, configure `Ocelot` by adding the following config to `Ocelot.json`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过向`Ocelot.json`添加以下配置来配置`Ocelot`：
- en: '[PRE6]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you look through the config file, you will see that we are simply mapping
    from one URL in the gateway to another URL in the two microservices that we have
    created, `HabitService` and `UserService`. This may seem like a needless complication,
    but if you consider that many more microservices might be added to the overall
    application, it makes sense to give a single point of entry.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看配置文件，你会看到我们只是在网关中的一个 URL 和我们创建的两个微服务（`HabitService` 和 `UserService`）中的另一个
    URL 之间进行映射。这看起来可能是一个不必要的复杂性，但如果你考虑到可能还会添加更多微服务到整个应用程序中，那么提供一个单一的入口点是有意义的。
- en: Running the combined application
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行组合应用程序
- en: To run the complete application, we need to start all four projects (`HabitService`,
    `UserService`, `APIGateway`, and `Client`) individually. This can become challenging,
    so we will set up tasks and launch configurations to manage this for us.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行完整的应用程序，我们需要分别启动四个项目（`HabitService`、`UserService`、`APIGateway` 和 `Client`）。这可能会变得具有挑战性，因此我们将设置任务和启动配置来帮助我们管理。
- en: 'In the `.vscode` folder, add the following code to `tasks.json`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.vscode` 文件夹中，将以下代码添加到 `tasks.json`：
- en: '[PRE7]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the same folder, add the following code to `launch.json`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹中，将以下代码添加到 `launch.json`：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also in `launch.json`, add the following compound tasks:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还在 `launch.json` 中添加以下复合任务：
- en: '[PRE9]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding configuration will allow VSCode to start all four projects by
    hitting the *F5* key, or by using the build and run menu.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置将允许通过按 *F5* 键或使用构建和运行菜单来启动 VSCode 的所有四个项目。
- en: 'There is much more that we could do at this point with the demo application.
    Some suggestions are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们还可以对演示应用程序做更多的事情。以下是一些建议：
- en: Build out the User service so that it includes a lot more functionality that
    would be required for a real app
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户服务构建得更加完善，使其包含更多对于真实应用程序所必需的功能
- en: Add additional routes to the `Ocelot` config
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `Ocelot` 配置中添加额外的路由
- en: Add a message queue (hint – try RabbitMQ)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个消息队列（提示：尝试 RabbitMQ）
- en: I hope that we have managed to illustrate most of the key learnings from this
    chapter and provided a foundation for you to build upon.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望我们已经成功地展示了本章的大部分关键学习内容，并为您提供了进一步构建的基础。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Microservices are a huge and complex topic, much too large to tackle in one
    chapter of a SaaS book! In this chapter, we provided a brief introduction to microservices,
    covering what they are and why they are important. We discussed the benefits of
    using microservices, including improved scalability, fault tolerance, and flexibility.
    We also talked about the challenges and pitfalls of implementing a microservices
    architecture, such as increased complexity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个庞大且复杂的话题，远远超出了在 SaaS 书籍的一章中可以解决的问题！在本章中，我们简要介绍了微服务，包括它们是什么以及为什么很重要。我们讨论了使用微服务的优点，包括提高可伸缩性、容错性和灵活性。我们还讨论了实现微服务架构的挑战和陷阱，例如复杂性增加。
- en: Next, we explored the common patterns for designing microservices, including
    service discovery, API gateways, and message brokers. We also looked at the role
    of containers and container orchestration systems, such as Docker, in deploying
    and managing microservices. Finally, we provided a set of pointers on how to implement
    a microservices architecture using C#, .NET, and various supporting tools. While
    this is only a small glimpse into the world of microservices, we hope that it
    has helped provide a foundation for your further exploration of this important
    topic.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了设计微服务的常见模式，包括服务发现、API 网关和消息代理。我们还研究了容器和容器编排系统（如 Docker）在部署和管理微服务中的作用。最后，我们提供了一系列关于如何使用
    C#、.NET 和各种支持工具实现微服务架构的指南。虽然这仅仅是微服务世界的一小部分，但我们希望这有助于为您进一步探索这个重要话题打下基础。
- en: In the next chapter, we will learn how to build a user interface with Blazor.
    We’ll interface this UI with the Good Habits backend that we have been building
    in previous chapters!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Blazor 构建用户界面。我们将把这个 UI 与我们在前几章中构建的 Good Habits 后端接口起来！
- en: Further reading
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涵盖的主题，请查看以下资源：
- en: 'How to build .NET Core microservices: [https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/](https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建 .NET Core 微服务：[https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/](https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/)
- en: 'Creating a simple data-driven CRUD microservice: [https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的数据驱动 CRUD 微服务：[https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice)
- en: '8 Ways to Secure Your Microservices Architecture: [https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/](https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 种保护微服务架构安全的方法：[https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/](https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/)
- en: 'Follow 6 key steps to deploy microservices in production: [https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production](https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下 6 个关键步骤在生产环境中部署微服务：[https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production](https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production)
- en: 'Microservices with .NET: [https://dotnet.microsoft.com/en-us/apps/aspnet/microservices](https://dotnet.microsoft.com/en-us/apps/aspnet/microservices)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET 的微服务：[https://dotnet.microsoft.com/en-us/apps/aspnet/microservices](https://dotnet.microsoft.com/en-us/apps/aspnet/microservices)
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What is the difference between a monolithic and microservices architecture?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体架构和微服务架构之间的区别是什么？
- en: What is the purpose of an API gateway in microservices architecture?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务架构中 API 网关的目的是什么？
- en: How does a message broker facilitate communication between microservices?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息代理如何促进微服务之间的通信？
- en: How does using a microservices architecture impact database design and management?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用微服务架构如何影响数据库设计和管理？
- en: What are some common challenges or pitfalls to consider when implementing microservices?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实施微服务时，需要考虑哪些常见的挑战或陷阱？
- en: 'Part 3: Building the Frontend'
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：构建前端
- en: After learning about the backend in the previous section, we will move on to
    the frontend. In this section, we will build a simple **user interface** (**UI**)
    using Blazor and connect this to the backend from the previous section. As well
    as the practical skills, this section will also introduce a lot of the theory
    around frontend development and building excellent UIs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节学习了后端之后，我们将继续学习前端。在本节中，我们将使用 Blazor 构建一个简单的 **用户界面**（**UI**），并将其与上一节的后端连接起来。除了实践技能外，本节还将介绍许多关于前端开发以及构建优秀用户界面的理论。
- en: 'This section has the following chapters:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 7*](B19343_07.xhtml#_idTextAnchor169), *Building a User Interface*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19343_07.xhtml#_idTextAnchor169), *构建用户界面*'
- en: '[*Chapter 8*](B19343_08.xhtml#_idTextAnchor200), *Authentication and Authorization*'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19343_08.xhtml#_idTextAnchor200), *身份验证和授权*'
