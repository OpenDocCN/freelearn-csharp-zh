<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Designing the Model</h1>
                </header>
            
            <article>
                
<p>Many think of domain models as data models. You can easily see this by searching for the <kbd>domain model</kbd> on Google—all the things you find are data diagrams or class diagrams. Although class diagrams sometimes contain some useful behavior (methods), even this does not happen that often. However, since the complexity of business is rarely in its data, we need to realize that behavior is an integral part of a domain model.</p>
<p>Big Picture EventStorming helps us to understand the whole business or a part of it, but we need to take it further to get to the implementation. Design-level EventStorming is just that—we look at the part of the system that is most interesting for us and dive deeper into it, discovering more events and new flows.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What does the domain model represent?</li>
<li>Patterns and anti-patterns</li>
<li>Design-level EventStorming</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Domain model</h1>
                </header>
            
            <article>
                
<p>As we discussed in <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml">Chapter 1</a>, <em>Why Domain-Driven Design?,</em> the software we design and implement has only one primary purpose—to solve a domain problem. Understanding the problem space or the business domain is crucial for the journey of finding proper solutions and satisfying users with the systems we make. When we get more understanding about the domain using techniques such as Big Picture EventStorming, as discussed in the previous chapter, we need to go a bit deeper and try visualizing our knowledge using visual artifacts that other people would understand and will be able to reason about. In short, we need a <strong>model</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What does the model represent?</h1>
                </header>
            
            <article>
                
<p>There are many different things described by the word <strong>model</strong>. When we say <strong>model</strong>, we can think of a scale model of a car, a ship, or even a house. Such models represent real-life objects on a different scale and also demonstrate a substantially different level of detail. Some models could be quite abstract, such as a model of a building <span>complex</span>. Other models, however, can give a more detailed view of what they represent, such as scale <span>models of </span>cars, which are often very accurate. But most of the time, such models are also missing some of the important features of real cars, such as the engine, the gearbox, and sophisticated electronics.</p>
<p>So, models represent some artifact of the real world, but with a narrow purpose. How much space the building will occupy and how high the whole complex will be, for example, are often just enough for a rough model, during the first review stage of the building project. Models do not intend to replicate real life. Instead, they represent some particular aspects of real life at a certain level of detail, depending on the purpose of the model.</p>
<p>A map of a city's transport lines is a great example. In any generic map, you can see that it shows the transport links, all stations, and changes. It also indicates some essential geographical aspects, such as relative distance to the sea or on which side of the river the stations are located.</p>
<p>At the same time, such map does not show the distance between stations and has no direct resemblance to real geographical locations. To find exactly where stations are located in the city, or how much time you would need to spend traveling from one station to another, you would need another map.</p>
<p>This example demonstrates that a particular model could represent some useful aspect of real life, but could ignore other elements as they are not necessary. This does not mean that those neglected aspects aren't important at all, just that they are not crucial to that particular problem space. Thus, the transport links map solves the problem of orientation for public transport users, and it does it well. But it does not solve the problem of navigating on the street, and it doesn't need to because it serves a different purpose.</p>
<p>As such, domain models in software also need to represent those aspects of the business domain that are essential to solving the problem in question. It is sometimes very tempting to put everything we know and, to go further on this slippery path, everything we could assume about the business domain, in our model. But it would add unnecessary complexity to the model and won't help to solve the problem. Even worse, putting too many irrelevant details in the model might broaden the implementation scope and mystify the intention that the business people had in mind when specifying the problems they wanted to solve.</p>
<p>Going back to <a href="948b7834-c47c-4321-a91c-2ba58068c52e.xhtml">Chapter 1</a>, <em>Why Domain-Driven Design?</em>, if the business domain and the particular problems we have to solve are in our problem space, the domain model is purely in our solution space. We will be modeling our solution, and those models will be our domain models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Anemic domain model</h1>
                </header>
            
            <article>
                
<p>The term <strong>domain model</strong>, although it already existed, was widely acknowledged after it was mentioned in Martin Fowler's book<em> Patterns of Enterprise Application Architecture</em> by Addison Wesley, 2003. Here is how Fowler defines the term in his book (<a href="https://martinfowler.com/eaaCatalog/domainModel.html">https://martinfowler.com/eaaCatalog/domainModel.html</a>):</p>
<div class="packt_quote">"Domain model: An object model of the domain that incorporates both behavior and data."</div>
<p>This definition is quite short and concise. And still, somehow, it got it very wrong if you look at the various links on Google if you search for <kbd>domain model</kbd>. If you have done the same as I did and searched for the phrase, you've found out that the majority of found images, and most of the links, lead to something that we can consider as data models or entity models. Such models visualize entities, data fields with types and relations between entities. In the best cases, links are attributed by domain terminologies such as <em>attends</em> or <em>consist of</em>, and in some rare cases, we can find class diagrams that show some methods.</p>
<p>What we see in the case of entity or data models are so-called <strong>anemic models</strong>. As the term suggests, such models only express the system state and know nothing of how this state changes and what operations are done in the system. Usually, if you look at the implementations of these systems, you will find that everything the system does is some manipulation of data. New entities are created, new relations are made, and fields in entities are changed. That's all.</p>
<p>There are a couple of reasons why anemic models became popular. First, guidelines to visualize domain models in UML suggest that things that are envisioned are<strong> conceptual classes</strong>. These classes represent real-world entities and their properties. In UML, such models include items (entities) with attributes (fields), their associations (relations), and actors. Hence, there is no place for behavior in conceptual classes. The next reason is that the idea of conceptual classes somehow got lost, and these UML models became the only domain models, where domain behavior was considered insignificant.</p>
<p>Getting back to Fowler, in the bliki article about anemic models (<a href="https://martinfowler.com/bliki/AnemicDomainModel.html">https://martinfowler.com/bliki/AnemicDomainModel.html</a>), he clearly defines this way of modeling systems as an anti-pattern. In addition to the previous description, anemic models often tend to be implemented entirely by database operations. Models that consist of objects with relations <span>closely </span>resemble relational models, and therefore relational databases are most frequently used to persist such objects. The association between an anemic domain model and its state in the database is so tight that they become siblings and cannot be distinguished from one another.</p>
<p>Very often, if you find a system with an anemic model as the domain model, you will have a hard time understanding what the system does since all you see in the code is SQL and calls to run it. And if you ask people who work with the system about where you can find the implementation of their model, they will most probably point directly to the database. There is also an opinion that anemic domain models are useful in cases where the application has little or no behavior, and such a model serves perfectly fine as a persistence model. I would argue that in such cases, there is no reason to call it a domain model. Data models are perfectly fine since they serve the purpose of persistence. However, there is no real justification for presenting data models as domain models, since these are two different things.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional languages and anemic models</h1>
                </header>
            
            <article>
                
<p>There is one more thing worth mentioning here. There are discussions in the functional programming communities about whether the models they design are anemic too. This is because, in functional programming, the use of classes is not mandatory and sometimes not even possible. Even when it is possible, it is not natural to use classes because functions and functional composition can solve many problems more easily. I would argue that if the behavior is still <span>modeled and implemented as functions, such a model is not anemic. It might not directly fit the original definition, but 2003 was the time of dominance for object-oriented programming languages, so it was natural to use the term <strong>object model</strong>. However, the key here is in the combination of data and behavior, and definitely, when using a rich type system combined with clearly defined functions that express intent, such a model is indeed not anemic.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What to include in the domain model</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier, a domain model's objects represent data and the behavior of the domain. By writing <em>objects</em>, I don't mean anything related to object-oriented languages, but rather the essence they represent. The implementation of a domain model is also shaped by the programming language that is used, so that such objects can be records, structs or, in fact, objects. Because this book is about using C# to implement <strong>Domain-Driven Design</strong> (<strong>DDD</strong>), we will be using classes and objects to implement our domain models. </p>
<p>Even when we are equipped with the notion of polymorphism, we can combine data and behavior inside our classes. This does not directly mean that our domain model will include such classes. Everything that is part of the domain implementation is also part of the domain model. There is no better documentation for the domain model than the code that implements such a model.</p>
<p>Behavior and data in the model are interconnected. The behavior of the model has no other meaning than to manipulate the model's data, and since the data represents nothing else than what the model is interested in and operates on, such data is also known as the <strong>state</strong>. The state is the data that describes what our system looks like at a particular moment in time. Every behavior of the model changes the state. The state is that thing we persist to the database and that we can recover at any time before applying a new behavior.</p>
<p>This can be illustrated with a simple example:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9030e857-ceae-4898-8637-e01a28b85f20.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">State transition is triggered by an action, causes a reaction</div>
<p>Here, you can see the account balance as a piece of state. When we apply a behavior, the state changes. This is called a <strong>state transition</strong>. Each domain model behavior causes a transition in the domain model state. Everything that documents how the domain state changes should be a part of the domain model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design considerations</h1>
                </header>
            
            <article>
                
<p>As we've seen before, in object-oriented languages, we often see classes that use the power of polymorphism to keep the behavior close to the state. In functional languages, though, the state is usually maintained separately, since the behavior can be represented as functions that manipulate instances of record types that represent the state.</p>
<p>Logically, things such as communication protocols, user input validation, and persistence implementation are not seen as part of the domain model. These are technical and infrastructure concerns. A good rule of thumb here is that the whole domain model should be testable without involving any infrastructure. Primarily, in your domain model tests, you should not use test harnesses and mocks.</p>
<p>If you look at the onion architecture, the hexagonal architecture, and clean architecture principles, you will find that they have one thing in common. The center of any application is the <strong>Domain</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/23cccb9b-ee68-4a41-afe0-f8ba1167cf45.png" style="width:31.17em;height:30.17em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Onion architecture</div>
<p><strong>Application services</strong> and <strong>Infrastructure</strong> are kept outside and form layers around this core of the system. Unlike a layered architecture, which has dependencies going down from the UI layer to the data layer, we can see that the <strong>Domain</strong> is the center of everything, and everything depends on it. Such a change, although it could be recognized as a small adjustment, has a very significant impact. Instead of everything depending on the data layer, which makes the database the master of all, the focus shifts to the domain, making the domain model the most significant part of the system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CQRS</h1>
                </header>
            
            <article>
                
<p>In addition to the previously discussed ways to design domain models as polymorphic classes using object-orientation and using functions operating with instances of record types for some functional languages, there is a different way to express state transitions inside the domain. With this, I mean the CQRS patterns, which was coined by Greg Young a decade ago.</p>
<p>The term originated from <strong>command-query separation</strong> (<strong>CQS</strong>), formulated by Bertrand Meyer, which states that object methods are separated into two categories. These categories are as follows:</p>
<ul>
<li>Commands, which mutate the system (most often the object) state and return <kbd>void</kbd>.</li>
<li>Queries, which return part of the system state and do not change the state of the system. This makes queries side effect free (except things such as logging) and idempotent so that they can be executed many times and get the same result.</li>
</ul>
<p><strong>Command-query responsibility segregation</strong> (<strong>CQRS</strong>) takes this principle outside of an object. It is the same principle but applied to the system level. Development of this pattern took a few years, from 2007, when Greg presented the early vision of it on the InfoQ conference, to 2010, when the summary paper was published (<a href="https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf">https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf</a>). It also took Google a few years to recognize the acronym. A few years back, people who were eagerly looking for CQRS got a suggestion from Google saying <em><span class="packt_screen">Did you mean CARS</span></em><span class="packt_screen">?</span>, but today the pattern is widely known and praised.</p>
<p>Separating commands and queries on the system level means that any state transition for the system can be expressed by a command, and such a command should be handled efficiently, optimized to perform the state transition. Queries, on the other hand, return data derived from the system state, which means that queries can be executed differently and can be optimized for reading the state or any derivative of the state if such a derivative exists.</p>
<p>Such separation is beneficial in scenarios when there is a clear imbalance between writes to the database and reads from the database. A typical business or consumer-oriented application is massively imbalanced toward reads. However, stereotypical implementations are optimized for writes, using normalized relational databases, where writes can be performed rather efficiently but reads require numerous joins and extensive filtering:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b813d2fd-c3e5-4dad-80f8-f5d397d7ddf4.png" style="width:39.08em;height:36.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">CQRS with a single database</div>
<p>In the simplest scenarios, CQRS can be implemented just by using database-mapped domain objects to execute operations on a domain model that mutate the system state (usually, it is done using ORM tools) and using direct SQL queries with joins across multiple tables to retrieve the system, completely ignoring the domain model class hierarchy. It leads to great optimization of reads and at the same time rightfully increases awareness of the state persistence mechanism. While this method is entirely legitimate, you should realize that, in this case, queries need to be either adequately abstracted from the data persistence layer, or be designed outside of the domain model.</p>
<p>In more complex scenarios, we could have not only two different <em>clients</em> to manipulate the same domain entities, but also split these entities apart. We will be looking closely at such techniques later in this book when we discuss event sourcing.</p>
<p>You might be wondering why CQRS made it into the domain model design section of the book, instead of being explained in the part that belongs to the implementation. The reason for this is that CQRS makes commands and queries first-class domain objects. Domain events should always be seen as first-class domain objects, but in more advanced CQRS implementation models, domain events play the crucial role of keeping the whole system consistent, and therefore the role of domain events becomes even more critical.</p>
<p>This is why CQRS is mentioned right here, for us to realize that we should not only include classes with properties and methods for our domain model, but things like commands, queries, and domain events belong to the model just as much, and we will be looking at how to model all these elements in the next section.</p>
<p>My final note is that EventStorming is valuable, regardless of whether or not you use CQRS for your implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Design-level EventStorming</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we went through the process of modeling the whole business using Big Picture EventStorming. We mainly discussed domain events and later added hotspots and external systems.</p>
<p>In this section, we will be looking to model at a more detailed level, using richer notation, to move closer to the actual implementation of the model in code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting deeper knowledge</h1>
                </header>
            
            <article>
                
<p>Let's go back to the moment when we finished the Big Picture EventStorming workshop. The team spent a couple of hours discussing essential topics:</p>
<ul>
<li>What processes does the business run?</li>
<li>What kind of objects participate in these processes?</li>
<li>What facts can we record about the system behavior?</li>
<li>Who does what?</li>
<li>What essential terms do we need to learn and use?</li>
</ul>
<p>Discussions about these points produced a diagram with a lot of orange sticky notes representing facts of life, which we call <strong>domain events</strong><em>.</em> There are also some pink sticky notes to be found here and there, indicating hotspots—things that need attention, further clarification, or cause worry. Usually, this means missing knowledge.</p>
<p>All these things bring the team somewhat closer to the actual implementation, but they don't feel like start coding just yet. The team members need to go deeper into the design and gain more specific knowledge about what actions can be performed in the system, and by whom.</p>
<p>This is a topic for another type of EventStorming workshop—design-level EventStorming. Let's look closer at how such a workshop can be organized.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparation for the workshop</h1>
                </header>
            
            <article>
                
<p>For more detailed EventStorming workshops, you need more or less the same things as for a Big Picture workshop:</p>
<ul>
<li>Paper roll or any other type of unlimited modeling space</li>
<li>Sticky notes of different colors; we'll get to the notation later on</li>
<li>Enough permanent markers</li>
</ul>
<p>Of course, the essential ingredient is to have the right people. But now, we are getting deeper into the details, so it is essential to choose one area to explore, and finding such a space is often a non-trivial task, which we will discuss later in this chapter. So, the right people would be those who will be busy writing the code, someone who is responsible for that part of the system as a product owner, and domain experts in the chosen area. As you can see, we can limit our group to fewer people than the Big Picture session.</p>
<p>Both options—limiting the scope and limiting the number of people—allow us to discuss the design in a much higher level of detail, have one single discussion thread, and have everyone express their thoughts and ask questions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extended notation</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Since EventStorming is language and technology agnostic, we cannot model things such as classes, fields, methods, or functions. Instead, we need to use more universal concepts. We already discussed such thoughts in the CQRS section, and there we saw that we can express the behavior in our domain model not just as a list of methods, but as the execution of commands. Commands express the user's intent. The domain model then gets its state transitioned, and new events are produced, recording the purpose and the state transition. Queries represent what users want to see on their screens to take decisions and execute other commands. So, this provides some elements for the design session that are not related to any specific programming language or technology.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Commands</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Commands and events are not bound to any language or technology. They also describe the system's behavior very well, using Ubiquitous Language and expressing the intent of our users.</span></p>
<p class="p1"><span class="s1">Therefore, we include commands in the notation for the design-level EventStorming. Commands express the intent of the users that interact with the system, so applying commands to our system would naturally produce state transitions and result in events being emitted inside our domain model. If we use blue sticky notes for commands, the regular flow of command processing will look like this:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7f16f81e-ff39-4b78-a1e9-84715d8cbf84.png" style="width:25.58em;height:7.42em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><span><span>The command triggers the state change</span></span></div>
<p class="p1"><span class="s1">Note that we have no arrows connecting sticky notes. The flow is determined solely by placing them together in chronological order. First, we ask the system to do something, and when the operation is accepted and performed, the system transitions its state and emits new events.</span></p>
<p class="p1"><span class="s1">Avoid using arrows in your modeling space in general, since they create spatial locking for your sticky notes, which you will stop moving around because arrows are drawn on paper or a whiteboard and cannot be moved. Such locking lowers down the modeling dynamics and prevents experimentation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read models</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The next new concept we will bring to our model is the read model. The read model is something that our users look at before asking the system to do something. It could be any screen in our application, such as a form, a dashboard, or a report. Any such screen contains a set of elements with a limited number of element types. Usually, we can classify elements as follows:</span></p>
<ul class="ul1">
<li class="li1"><span class="s2">The information shown as text and images</span></li>
<li class="li1"><span class="s2">Form elements such as input boxes, check boxes, and radio buttons</span></li>
<li class="li1"><span class="s2">Action buttons</span></li>
<li class="li1"><span class="s2">Navigation</span></li>
</ul>
<p class="p1"><span class="s2">When navigation elements naturally move users from one screen to another, action buttons are used to send commands to the system. Informational elements and form elements are something that our users look at before deciding what to do. What is shown inside these elements is defined by read-models. For the purpose of modeling, we could assume that our read models are screens in the system, so we can identify what information we need to combine and show to the user.</span></p>
<p class="p1"><span class="s2">To demonstrate this, let's look at the following example:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c59ed12-e19d-4e87-9d03-b17ce8e4e512.png" style="width:32.83em;height:14.08em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Read model, commands, and events</div>
<p class="p1"><span class="s1">So, the green sticky note here represents the read model for a classified ad. From there, the user can do specific actions: publish the ad or remove it. Executing one of these commands will result in an event being published by the domain model.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Users</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Most of the time, commands in our system are executed by people who use the system—by users. When designing the model, we often need to understand who is running which command, just because not all commands are allowed to be executed by everyone. We might define different user roles, such as <em>administrator</em>, <em>manager</em>, <em>reviewer</em>, and so on, and somehow visualize them, along with their ability to execute specific commands. You might also find it useful to identify personas and use them in addition to, or instead of roles. It is particularly helpful if you expect one person to perform different roles in the system or when you are modeling an existing system in which you know specific people and their particular duties, and using their names directly in the model will bring clarity and understanding to everyone involved.</span></p>
<p class="p1"><span class="s1">Visually, we can use smaller sticky notes with a person figure, drawn as the UML actor symbol. You might call your users <strong>actors</strong> too, but in UML, actors aren't necessary users. In EventStorming, we want users to be visualized differently, so we use larger pale magenta sticky notes to show external systems, as we discussed in the previous chapter.</span></p>
<p class="p1"><span class="s1">Let's put some users into our model:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21b1c75f-4cc9-42a5-9e8c-2f5b365b9ddb.png" style="width:34.58em;height:16.83em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Users are those who trigger commands</div>
<p class="p1"><span class="s1">I used a different read model, which can be used by two different types of users. Here, the <strong>Classified Ad</strong> owner can mark it as sold. But both the owner and someone who has the role of <strong>Reviewer</strong> can deactivate the ad.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Policies</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">The last elements we will be using in the design-level session is policy. As we learned, previously actions in the system are represented by commands. Users can execute actions by sending commands. When a command is processed, the system changes its state and emit events. This is the initial reaction of the system on the user's action. But, when we publish events, we also let <span>other elements of our domain model, that were previously unaware of the command being executed,</span> know that something happened. This is very useful in order <span>to </span>not execute all work linked to a certain action at once. Ideally, we should limit the amount of work we do to process a command to the absolute minimum. Technically, such atomic operations can be represented as one transaction. It might very well be that some other operations also need to be executed as the result of the domain model state transition, but we don't need to wrap these actions in one transaction and force the user to wait until all such work is done. This is exactly where we need policies. Policies subscribe to domain events, and when a policy receives some domain events it is interested in, it will check the event content and potentially send another command to the system to complement the work. There might be numerous policies reacting to the same event type, doing all kinds of post-processing in an asynchronous fashion, while the user gets control back after the original command has been executed.</span></p>
<p class="p1"><span class="s1">We can express a policy in our modeling space like this:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10f9e74b-f73b-4c64-a5ce-0be97120d96e.png" style="width:39.50em;height:14.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Policies might trigger commands based on events</div>
<p>Looking at this model, we can transcribe it like this—<em>when the owner of a classified ad marks it as sold, the system should also deactivate this ad</em>.</p>
<p>As you can see, a policy can react to domain events and issue commands, based on certain conditions. Such behavior is called <strong>reactive behavior</strong>, and systems that actively use this pattern can be referred to as<strong> reactive systems</strong>.</p>
<div class="packt_infobox">Please note that the term "reactive" became ambiguous during recent years. The <em>Reactive Manifesto</em> postulates the definition for a "reactive system", which is different from what I mean in this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">All together now</h1>
                </header>
            
            <article>
                
<p>To sum up, <span>we can draw a conceptual picture of </span><span>all the elements that were introduced in this section, like this:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0b313267-7b2e-47de-8dd9-9ccf37cfa6d5.png" style="width:39.33em;height:23.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The picture that explains (almost) everything—Alberto Brandolini</div>
<p>The transcription for this picture would be—the user, <span>using information from the system, </span><span>represented as the read model, </span><span>and information from the outside world, </span><span>feelings, and the thoughts of the user, </span><span>send operation requests to the system, known as <strong>commands</strong>, </span><span>which might result in a system state change</span> <span>that produces domain events. Domain events can trigger policies, which might issue new commands, based on the information received in those events and the system's state. External systems could also produce domain events. The system's state change results in reading models being updated as well, so the user can receive new information from the system and the cycle repeats.</span></p>
<p>This diagram can describe the majority of systems out there, and you might imagine that it is <span>not only </span>applicable to software systems. The picture also maps very nicely with CQRS and this, I believe, makes the CQRS pattern so useful. Some might argue that CQRS adds accidental complexity to the system due to implementation efforts. However, when done correctly, it adds more clarity to the models because it directly implements the <strong>separation of concerns</strong> (<strong>SoC</strong>) principle (<span><em>On the role of scientific thought</em> by </span>Edsger W. Dijkstra, 1974), and in general makes the system easier to build and maintain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the reference domain</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to design a part of the reference domain using the tools we have covered in this chapter.</p>
<p>Our team is getting together again to discuss a part of the system in more detail. They have decided that the classified ad life cycle is their core domain at the first stage and that the section related to additional services and payments will be implemented later due to their investor's decision to gain users before monetizing the application.</p>
<div class="packt_tip">It is important to realize that such decisions cannot be solely made by developers, and it is vital to involve all stakeholders in the decision-making process.</div>
<p>First things first, and we need to quickly review the events that were identified as part of the classified ad life cycle. Our team gets to work, but quickly reaches the point where they get this on the wall:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cbf8db0e-affd-4935-9957-9f7d0a4c4210.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The first round of the session—domain events only</div>
<p>As you can see, this model is a little bit different from the final model from the previous chapter. Every time the team discusses the model, some changes occur because team members get a better understanding of the domain.</p>
<p>The next thing they do is add some commands that result in events that are already present on the model. In many cases, commands demonstrate the direct intent of users to do something that directly results in events. These commands are the most obvious ones that come to the model first.</p>
<p>Sometime later, the model looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/46f5d087-8482-49b9-a122-fba539b1efb7.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Events and commands</div>
<p>The team then agrees that most commands are executed by users, but then a discussion sparks about who the user is. Technically, everyone who uses the system is a user. But different people can do different things, and something that is allowed to be done by administrators cannot be done by regular users. This is obvious, but from there, the team identifies the need to separate people by what they do. Of course, one person can always play different roles, but in this concrete example, most operations are done by one type of user—those who want to <em>sell</em> things. Naturally, the role is identified as a <em>seller</em>. After making this discovery, the model starts to go into more detail:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/4091a187-a67e-40f8-8541-6df340ef2bc6.png"/></p>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Events, commands, and actors</div>
<p>As you can see, along the way, more roles are identified and assigned to commands. For example, an ad cannot be approved or rejected by the seller; this makes no sense. Someone from inside the service needs to do this work and either allow the ad to be published or deny publication for one or another reason.</p>
<p>Interestingly enough, since the discussed context is only covering the ad life cycle, there is no buyer involved. So, the team keeps interchangeably using the words <strong>owner</strong> and <strong>seller</strong>. For the sake of consistency, they lean toward using the term <strong>seller</strong> but remember that all words in the Ubiquitous Language are context-specific. And the reason why we do not have the <strong>buyer</strong> here is that, as far as the team is currently concerned, they will only deal with buyers in some other parts of the system, meaning another context. Preliminarily, they identify that buyers would participate in conversations about buying agreements and terms, and in the escrow context, should this be required. Also, the team keeps thinking about mutual reviews and, naturally, both sellers and buyers will participate in this activity.</p>
<p>Then, thoughts start to roam around events that appear for different reasons. One of those events is <strong>Ad deactivated</strong>. The seller might click the <span class="packt_screen">Deactivate</span> button when looking at an ad, or an ad might be rejected for publication by the reviewer. The discovery is made that the <kbd>Deactivate Ad</kbd> command can be executed by both the seller and by the system itself when a <strong>policy</strong> to deactivate rejected ads is triggered. Adding policies to the model results in some more details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a2086a8e-44a1-46f5-a45c-272b0c4e5250.png" style="width:42.25em;height:31.67em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Part of the model with policies</div>
<p>Finally, the team went through some commands that require specific information to be displayed to allow users to make decisions and execute them as commands. Not everywhere <span>can </span>such clarity be reached during the first iteration, and in such cases, the team needs to postpone making any decisions to a later stage. It is more important to make progress and move on than chase too granular a model, which will never be perfect anyway.</p>
<p>For example, when adding a category to the ad, sellers must be able to choose from the list of existing categories using some advanced techniques such as type-ahead search. And for reviewers, it is helpful not only to see the ad's content but also get more details about the seller who authored the ad. A combination of factors, such as the seller's experience of the platform, the number of previously published ads, the number of currently published ads, and finally, the current ad content, can provide clarity for reviewers, helping them to distinguish malicious ads from legitimate ones.</p>
<p>When working with read models, there are a lot of opportunities for developers to work together with UX experts, UI designers, and other people, since real models are natural parts of the UI. But commands should not be forgotten either since they are the handlers that make the system do something useful. Without commands, the whole system would just be a collection of static pages, since there would be no way to change the system's state and execute any behavior. The entire UI of any system is a collection of read models with command executors attached to them as buttons and other action-triggering elements.</p>
<p>You might also think about <em>task-based UI</em>, a useful approach to designing UI elements in such a way that leads users to make simple, atomic, and precise operations. In our example, we used task-based UI too because our sellers change the ad price separately from the ad title simply because these operations are substantially different. The idea of task-based UI is very much aligned with CQRS and command handling. It's no surprise that the most information about this technique can be found in Greg Young's articles related to CQRS, such as this one: <a href="https://cqrs.wordpress.com/documents/task-based-ui/">https://cqrs.wordpress.com/documents/task-based-ui/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we identified the domain model and agreed that the model represents some part of real life, which is targeted to solve some specific problem. We also discussed the importance of behavior and that it is an essential part of the model that is often overlooked and even ignored.</p>
<p>Along the way, we introduced the CQRS pattern. It separates commands as something to be done inside the model and that represent behavior, from queries that have the only purpose of retrieving state.</p>
<p>Then, we got more elements for the EventStorming modeling technique in order to model <span>detail </span>in more depth, moving toward something that we can start implementing in code. We recognized that these new elements match well with the CQRS paradigms.</p>
<p>Finally, we went through the modeling session of our sample domain and got more insight into how the core part of the system should work, so we are now prepared to convert this knowledge into code. That is what we will be doing in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>For more information is a list of resources you can refer to:</p>
<ul>
<li><em>Introducing EventStorming</em>, Brandolini A. (2017), Leanpub (<a href="https://leanpub.com/introducing_eventstorming">https://leanpub.com/introducing_eventstorming</a>)</li>
<li><em>Microsoft Inductive User Interface Guidelines</em>, <span>Microsoft Corporation, 2001 (</span><a href="https://msdn.microsoft.com/en-us/library/ms997506.aspx">https://msdn.microsoft.com/en-us/library/ms997506.aspx</a>)</li>
<li><em>Task-Based UI</em> (<a href="https://cqrs.wordpress.com/documents/task-based-ui/">https://cqrs.wordpress.com/documents/task-based-ui/</a>)</li>
</ul>


            </article>

            
        </section>
    </body></html>