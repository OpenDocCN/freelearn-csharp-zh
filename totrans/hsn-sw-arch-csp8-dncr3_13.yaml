- en: Understanding the Different Domains in Software Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to a modern software development technique called
    **domain-driven design** (**DDD**), which was first proposed by Eric Evans. While
    DDD has existed for more than 15 years, it reached a great success in the last
    few years because of its ability to cope with two important problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling complex systems where no single expert has in-depth knowledge of the
    whole domain. This knowledge is split among several people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facing big projects with several development teams. There are many reasons why
    a project is split among several teams, with the most common being the team's
    size and all of its members having different skills and/or different locations.
    In fact, experience has proven that teams of more than 6-8 people are not efficacious
    and clearly different skills and locations prevent a tight interaction from occurring. Team
    splitting prevents tight interaction from happening for all the people involved
    in the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In turn, the importance of the two aforementioned problems grew more in the
    last few years for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Software systems always took up a lot of space inside every organization and
    became more and more complex and geographically distributed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, the need for frequent updates increased so that these complex
    software systems could be adapted, as per the needs of a quickly changing market.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding problems led to the conception of more sophisticated CI/CD cycles
    and the adoption of complex distributed architectures that may leverage reliability,
    high throughput, quick updates, and the capability to evolve legacy subsystems
    gradually. Yes – we are speaking of the microservices and container-based architectures
    we analyzed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this scenario, it's common to implement complex software systems with associated
    fast CI/CD cycles that always require more people to evolve and maintain them.
    In turn, this created the requirement of developing technologies that were adequate
    for high-complexity domains and for the cooperation of several loosely coupled
    development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze the basic principles, advantages, and common
    patterns related to DDD, as well as how to use them in our solutions. More specifically,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are software domains?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SOLID principles to map your domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – understanding the domains of the use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2017 or 2019 free Community Edition or better
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: All the code snippets in this chapter can be found in the GitHub repository
    associated with this book, [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)[.](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)
  prefs: []
  type: TYPE_NORMAL
- en: What are software domains?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml),
    *Functional and Nonfunctional Requirements*, and [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml),
    *Documenting the Requirements with Azure DevOps*, the transfer of knowledge from
    domain experts to the development team plays a fundamental role in software design.
    Developers try to communicate with experts and describe their solutions in a language
    that domain experts and stakeholders can understand. However, often, the same
    word has a different meaning in various parts of an organization, and what appear
    to be the same conceptual entities have completely different shapes in different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in our WWTravelClub use case, the order-payment and packages-handling
    subsystems use completely different models for customers. Order-payment characterizes a
    customer by their payment methods and currency, bank accounts, and credit cards,
    while package-handling is more concerned with the locations and packages that
    have been visited and/or purchased in the past, the user's preferences, and their
    geographical location. Moreover, while order-payment refers to various concepts
    with a language that we may roughly define as a *bank language*, packages-handling uses
    a language that is typical of travel agencies/operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classical way to cope with these discrepancies is to use a unique abstract
    entity called **customer**, which projects into two different views – the order-payment
    view and the packages-handling view. Each projection operation takes some operations
    and some properties from the **customer** abstract entity and changes their names.
    Since domain experts only give us the projected views, our main task as system
    designers is to create a conceptual model that can explain all the views. The
    following diagram shows how different views are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68ac81ab-ebad-4a37-921f-c8e3bf813822.png)'
  prefs: []
  type: TYPE_IMG
- en: The main advantage of the classic approach is that we have a unique and coherent
    representation of the data of the domain. If this conceptual model is built successfully,
    all the operations will have a formal definition and purpose and the whole abstraction
    will be a rationalization of the way the whole organization *should* work, possibly
    highlighting and correcting errors and simplifying some procedures.
  prefs: []
  type: TYPE_NORMAL
- en: However, what are the downsides of this approach? First of all, the way work
    is organized may have an excessive impact on the preexisting organization that
    may prevent it from operating correctly for a certain amount of time since the
    constraint of using a unique coherent model doesn't offer enough options to mitigate
    this impact. Errors must be removed, duplication must be removed, and everything
    must be perfectly coherent so that there is a minimum irreducible impact that
    we can't mitigate since the only way to mitigate it would be to renounce the overall
    coherence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This minimum impact can be acceptable in a small organization, when the software
    is destined for a small part of the overall organization, or when the software
    automatizes a small enough percentage of the data flow. However, as the software
    becomes the backbone of a whole geographically distributed organization, sharp
    changes become more unacceptable and unfeasible. Moreover, as the complexity of
    the software system grows, several other issues appear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arriving at a uniquely coherent view of data becomes more difficult since we
    can't face complexity by breaking these tasks into smaller loosely coupled tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As complexity grows, there is a need for frequents system changes, but it is
    quite difficult to update and maintain a unique global model. Moreover, bugs/errors
    that are introduced by changes in small subparts of the system may propagate to
    the whole organization through the uniquely shared model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System modeling must be split among several teams and only loosely coupled tasks
    can be faced with separate teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need to move to a microservice-based architecture makes the bottleneck of
    a unique database more unacceptable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the system grows, we need to communicate with more domain experts, each speaking
    a different language and each with a different view of that data model. Thus,
    we need to translate our unique model's properties and operations to/from more
    languages to be able to communicate with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the system grows, it becomes more inefficient to deal with records with several
    hundreds/thousands of fields. Such inefficiencies originate in database engines
    that inefficiently handle big records with several fields (memory fragmentation,
    problems with too many related indices, and so on). However, the main inefficiencies
    take place in ORMs and business layers that are forced to handle these big records
    in their update operations. In fact, while query operations usually require just
    a few fields that have been retrieved from the storage engine, updates and business
    processing involve the whole entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the traffic in the data storage subsystem grows, we need read and update/write
    parallelism in all the data operations. As we discussed in [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml),
    *How to Choose Your Data Storage in the Cloud*, while read parallelism is easily
    achieved with data replication, write parallelism requires sharding, and it is
    difficult to shard a uniquely monolithic and tightly connected data model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These issues are the reason for DDD's success in the last few years since they
    were characterized by more complex software systems that became the backbone of
    entire organizations. DDD's basic principles will be discussed in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain-driven design is about the construction of a unique domain model and
    keeps all the views as separate models. Thus, the whole application domain is
    split into smaller domains, each with a separate model. These separate domains
    are called **Bounded Contexts**. Each domain is characterized by the language
    spoken by the experts and used to name all the domain concepts and operations.
    Thus, each domain defines a common language used by both the expert and the development
    team called **Ubiquitous Language**. Translations are not needed anymore, and
    if the development team uses interfaces as a base for its code, the domain expert
    is able to understand and validate them since all the operations and properties
    are expressed in the same language that's used by the expert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''re getting rid of a cumbersome unique abstract model, but now we
    have several separated models that we need to relate somehow. DDD proposes that
    it will handle all of these separated models, that is, all the Bounded Contexts,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to add Bounded Context boundaries whenever the meaning of the language
    terms change. For instance, in the WWTravelClub use case, order-payment and packages-handling
    belong to different Bounded Contexts because they give a different meaning to
    the word **customer**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to explicitly represent relations among bounded contexts. Different
    development teams may work on different bounded contexts, but each team must have
    a clear picture of the relationship between the Bounded Context it is working
    on and all the other models. For this reason, such relationships are represented
    in a unique document that's shared with every team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to keep all the bounded contexts aligned with continuous integration.
    Meetings are organized and simplified system prototypes are built in order to
    verify that all the Bounded Contexts are evolving coherently, that is, that all
    the Bounded Contexts can be integrated into the desired application behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how the WWTravelClub example that we discussed
    in the previous section changes with the adoption of DDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7b60e75-1f5b-4d4f-88cd-fb420114cd19.png)'
  prefs: []
  type: TYPE_IMG
- en: There is a relationship between the customer entities of both Bounded Contexts,
    while the Purchase entity of the packages-handling Bounded Context is related
    to the payments. Identifying entities that map to each other in the various Bounded
    Contexts is the first step of formally defining the interfaces that represent
    all the possible communications among the contexts.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, from the preceding diagram, we know that payments are done after
    purchases, and so we can deduce that the payment-orders Bounded Context must have
    an operation to create a payment for a specific customer. In this domain, new
    customers are created if they don't already exist. The payment creation operation
    is triggered immediately after purchase. Since several more operations are triggered
    after an item is purchased, we can implement all the communication related to
    a purchase event with the Publisher/Subscriber pattern we explained in [Chapter
    9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and .NET Core
    Implementation*. These are known as **domain events** in DDD. Using events to
    implement communications between Bounded Contexts is very common since it helps
    keep Bounded Contexts loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Once an instance of either an event or an operation that's been defined in the
    Bounded Context's interface crosses the context boundary, it is immediately translated
    into the Ubiquitous Language of the receiving context. It is important that this
    translation is performed before the input data starts interacting with the other
    domain entities to avoid the Ubiquitous Language of the other domain becoming
    contaminated by extra-context terms.
  prefs: []
  type: TYPE_NORMAL
- en: Each Bounded Context implementation must contain a Data Model Layer completely
    expressed in terms of the Bounded Context Ubiquitous Language (class and interface
    names and property and method names), with no contamination from other Bounded
    Contexts Ubiquitous Languages, and without contamination from programming technical
    stuff. This is necessary to ensure good communication with domain experts and
    to ensure that domain rules are translated correctly into code so that they can
    be easily validated by domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a strong mismatch between the communication language and the target
    Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded
    Context boundary. The only purpose of this anti-corruption layer is to perform
    a language translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The document that contains a representation of all the Bounded Contexts, along
    with the Bounded Context''s mutual relationships and interface definitions, is
    called a **Context Mapping**. The relationships among contexts contain organizational constraints
    that specify the kind of cooperation that''s required among the team that works
    on the different Bounded Contexts. Such relationships don''t constrain the Bounded
    Context interfaces but do affect the way they may evolve during the software CI/CD
    cycle. They represent patterns of team cooperation. The most common patterns are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partner**: This is the original pattern suggested by Eric Evans. The idea
    is that the two teams have a mutual dependency on each other for delivery. In
    other terms, they decide together and, if needed, change the Bounded Context''s
    mutual communication specifications during the software CI/CD cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer/supplier development teams**: In this case, a team acts as a customer
    and the other acts as a supplier. Both teams define the interface of the customer
    side of the Bounded Context and some automated acceptance tests to validate it.
    After that, the supplier can work independently. This pattern works when the customer''s
    Bounded Context is the only active part that invokes the interface methods that
    are exposed by the other Bounded Context. This is adequate for the interaction
    between the order-payments and the packages-handling contexts, where order-payments
    acts as a supplier since its functions are subordinate to the needs of packages-handling.
    When this pattern can be applied, it decouples the two Bounded Contexts completely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conformist**: This is similar to the customer/supplier, but in this case,
    the customer side accepts an interface that''s been imposed by the supplier side
    with no negotiation stage. This pattern offers no advantages to the other patterns,
    but sometimes we are forced into the situation depicted by the pattern since either
    the supplier''s Bounded Context is implemented in a preexisting product that can''t
    be configured/modified too much or because it is a legacy subsystem that we don''t
    want to modify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth pointing out that the separation in Bounded Contexts is only efficacious
    if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction
    of complexity that's obtained by breaking a whole system into subparts would be
    overcome by the complexity of the coordination and communication processes. However,
    if Bounded Contexts are defined with the *language criterion*, that is, Bounded
    Context boundaries are added whenever the *Ubiquitous Language* changes, this
    should actually be the case. In fact, different languages may arise just as a
    result of a loose interaction between organization subparts since the more subparts
    there are for an organization to interact with, the more they end up using a common
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, all human organizations can grow by evolving into loosely coupled
    subparts for the same reason complex software systems may be implemented just
    for the cooperation of loosely coupled submodules: this is the only way humans
    are able to cope with complexity. From this, we can conclude that complex organizations/artificial
    systems can always be decomposed into loosely coupled subparts. We just need to
    understand *how*.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basic principles we've mentioned so far, DDD furnishes a few basic
    primitives to describe each Bounded Context, as well as some implementation patterns.
    While Bounded Context primitives are an integral part of DDD, these patterns are
    just useful heuristics we can use in our implementation, so their usage in some
    or in all Bounded Contexts is not obligatory once we opt for DDD adoption.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe primitives and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Entities and value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD entities represent domain objects that have a well-defined identity, as
    well as all the operations that are defined on them. They don't differ too much
    from the entities of other, more classical approaches. Also, DDD entities are
    the starting point of the storage layer design. The main difference is that DDD
    stresses their object-oriented nature more, while other approaches use them mainly
    as *records* whose properties can be written/updated without too many constraints.
    DDD, on the other hand, forces strong SOLID principles on them to ensure that
    only certain information is encapsulated inside of them and that only certain
    information is accessible from outside of them, which operations are allowed on
    them, and which business-level validation criteria apply to them.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, DDD entities are richer than the entities of record-based approaches.
    In other approaches, operations that manipulate entities are defined outside of
    them in classes that represent business and/or domain operations. In DDD, these
    operations are moved to the entity definitions as their class methods. The reason
    for this is that they offer better modularity and keep related chunks of software
    in the same place so that they can be maintained and tested easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the same reason, business validation rules are moved inside of DDD entities.
    DDD entity validation rules are business-level rules, so they must not be confused
    with database integrity rules or with user-input validation rules. They contribute
    to the way entities represent domain objects by encoding the constraints the represented
    objects must obey. In .NET Core, business validation can be carried out with one
    of the following techniques listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the validation methods in all the class methods that modify the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hooking the validation methods to all the property setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorating the class and/or its properties with a custom validation attribute
    and then invoking the `TryValidateObject` static method of the `System.ComponentModel.DataAnnotations.Validator`
    class on the entity each time it is modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once detected, validation errors must be handled somehow, that is, the current
    operation must be aborted and the error must be reported to an appropriate error
    handler. The simplest way to handle validation errors is by throwing an exception.
    This way, both purposes are easily achieved and we can choose where to intercept
    and handle them. Unfortunately, as we discussed in the *Performance issues that
    need to be considered while programming in C#* section of [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml), *Functional
    and Nonfunctional Requirements*, exceptions imply big performance penalties, so,
    often, different options are considered. Handling errors in the normal flow of
    control would break modularity by spreading the code that's needed to handle the
    error all over the stack of methods that caused the error, with a never-ending set
    of conditions all over that code. Therefore, more sophisticated options are needed.
  prefs: []
  type: TYPE_NORMAL
- en: A good alternative to exceptions is to notify the error handler of any errors
    that are defined in the Dependency Injection engine. Being scoped, the same service
    instance is returned while each request is being processed so that the handler
    that controls the execution of the whole call stack can inspect possible errors
    when the flow of control returns to it and can handle them appropriately. Unfortunately,
    this sophisticated technique can't abort the operation's execution immediately
    or return it to the controlling handler. Therefore, the developer is forced to
    add adequate control conditions to prevent the continuation of the operation.
    This is why exceptions are recommended for this scenario, notwithstanding their
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Business-level validation must not be confused with input validation, which
    will be discussed in more detail in [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml),
    *Presenting ASP.NET Core MVC*, since the two types of validation have different
    and complementary purposes. While business-level validation rules encode domain
    rules, input validation enforces the format of every single input (string length,
    email and URL correct formats, and so on), ensures that all the necessary input
    has been provided, enforces the execution of the chosen user-machine interaction
    protocols, and provides fast and immediate feedback that drives the user to interact
    with the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since DDD entities must have a well-defined identity, they must have properties
    that act as primary keys. It is common to override the `Object.Equal` method of
    all the DDD entities in such a way that two objects are considered equal whenever
    they have the same primary keys. This is easily achieved by letting all the entities
    inherit from an abstract `Entity` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that, once we've redefined the `Object.Equal` method
    in the `Entity` class, we can also override with the `==` and `!=` operators.
  prefs: []
  type: TYPE_NORMAL
- en: The `IsTransient` predicate returns `true` whenever the entity has been recently
    created and hasn't been recorded in the permanent storage, so its primary key
    is still undefined.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, it is good practice that, whenever you override the `Object.Equal`
    method of a class, you also override its `Object.GetHashCode` method so that class
    instances can be efficiently stored in data structures such as dictionaries and
    sets. That's why the Entity class overrides it.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth implementing an `IEntity<K>` interface that defines all the
    properties/methods of `Entity<K>`. This interface is useful whenever we need to
    hide data classes behind interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects, on the other hand, represent complex types that can't be encoded
    with numbers or strings. Therefore, they have no identity and no principal keys.
    They have no operations defined on them and are immutable; that is, once they've
    been created, all their fields can be read but cannot be modified. For this reason,
    they are usually encoded with classes whose properties have protected/private
    setters. Two value objects are considered equal when all their independent properties
    are equal (some properties are not independent since they just show data that's
    been encoded by other properties in a different way, as is the case for the ticks
    of `DateTime` and its representation of the date and time fields).
  prefs: []
  type: TYPE_NORMAL
- en: Typical value objects include costs represented as a number and a currency symbol,
    locations represented as longitude and latitude, addresses, contact information,
    and so on. When the interface of the storage engine is Entity Framework, which
    we analyzed in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# - Entity Framework Core*, and [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml),
    *How to Choose Your Data Storage in the Cloud*, value objects are connected with
    the entity that uses them through the `OwnsMany` and `OwnsOne` relationships.
    In fact, such relationships also accept classes with no principal keys defined
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: When the storage engine is a NoSQL database, value objects are stored inside
    the record of the entities that use them. On the other hand, in the case of relational
    databases, they can either be implemented with separated tables whose principal
    keys are handled automatically by Entity Framework and are hidden from the developer
    (no property is declared as a principal key) or, in the case of `OwnsOne`, they
    are flattened and added to the table associated with the entity that uses them.
  prefs: []
  type: TYPE_NORMAL
- en: Using SOLID principles to map your domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following subsections, we will describe some of the patterns that are
    commonly used with DDD. Some of them can be adopted in all projects, while others
    can only be used for certain Bounded Contexts. The general idea is that the business
    layer is split into two layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Application layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, the domain layer is based on the Ubiquitous Language and manipulates
    DDD entities and value objects. DDD entities and value objects are defined in
    this domain layer. The whole business layer communicates with the data layer that''s
    implemented with Entity Framework through interfaces that are defined in the domain
    layer but are implemented in the data layer. Data that''s passed/returned by these
    interface methods are known as DDD entities (the representation of queries and
    their results). The domain layer has no direct reference to the library that implements
    the data layer, but the connection between domain layer interfaces and their data
    layer implementations is performed in the dependency injection engine of the application
    layer. From this, we can understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The data layer has a reference to the domain layer since it must implement its
    interfaces and must create DDD entities and value objects that are defined in
    the domain layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application layer has references to the domain and data layers, but references
    to the data layer types only appear in the dependency engine, where they are associated
    with the respective interfaces that were defined in the domain layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the domain layer contains the representation of the domain objects, the
    methods to use on them, validation constraints, and its relationship with various
    entities. To increase modularity and decoupling, communication among entities
    is usually encoded with events, that is, with a publisher/subscriber pattern.
    This means entity updates can trigger events that have been hooked to business
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: This layered architecture allows us to change the whole data layer without affecting
    the domain layer, which only depends on the domain specifications and language
    and doesn't depend on the technical details of how the data is handled.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer contains the definitions of all the operations that may
    potentially affect several entities and the definitions of all the queries that
    are needed by the applications. Both business operations and queries use the interfaces
    defined in the domain layer to interact with the data layer. However, while business
    operations manipulate and exchange entities with these interfaces, queries send
    query specifications and receive generic DTOs from them. Business operations are
    invoked either by other layers (typically the presentation layer) or by communication
    with the application layer. Business operations may also be hooked to events that
    are triggered when entities are modified by other operations.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the application layer operates on the interfaces defined in the domain
    layer instead of interacting directly with their data layer implementations, which
    means that the application layer is decoupled from the data layer. More specifically,
    data layer objects are only mentioned in the dependency injection engine definitions.
    All the other application layer components refer to the interfaces that are defined
    in the domain layers, and the dependency injection engine injects the appropriate
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application layer communicates with other application components through
    one or more of the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: It exposes business operations and queries on a communication endpoint, such
    as an HTTP Web API (see [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*). In this case, the presentation
    layer may connect to this endpoint or to other endpoints that, in turn, take information
    from this and other endpoints. Application components that collect information
    from several endpoints and expose them in a unique endpoint are called gateways.
    They may be either custom or general-purpose, such as Ocelot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is referenced as a library by an application that directly implements the
    presentation layer, such as an ASP.NET Core MVC Web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't expose all the information through endpoints and communicates some
    of the data it processes/creates to other application components that, in turn,
    expose endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we describe these patterns, we need to understand the concept of aggregates.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have talked about entities as the *units* that are processed by a
    DDD-based business layer. However, several entities can be manipulated and made
    into single entities. An example of this is a purchase order and all of its items.
    In fact, it makes absolutely no sense to process a single order item independently
    of the order it belongs to. This happens because order-items are actually subparts
    of an order, not independent entities.
  prefs: []
  type: TYPE_NORMAL
- en: There is no transaction that may affect a single order-item without it affecting
    the order that the item is in. Imagine that two different people in the same company
    are trying to increase the total quantity of cement but one increases the quantity
    of type-1 cement (item 1) while the other increases the quantity of type-2 cement
    (item 2). If each item is processed as an independent entity, both quantities
    will be increased, which could cause an incoherent purchase order since the total
    quantity of cement would be increased twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if the whole order, along with all its order-items, is loaded
    and saved with every single transaction by both people, one of the two will overwrite
    the changes of the other one, so whoever makes the final change will have their
    requirements set. In a web application, it isn''t possible to lock the purchase
    order for the whole time the user sees and modifies it, so an optimistic concurrency
    policy is used. For instance, it is enough to add a version number to each purchase
    order and to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the order without opening any transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before saving the modified order, we open a transaction and perform a second
    read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version number of the newly retrieved order differs from the one of the
    order that was modified by the user, the operation is aborted because someone
    else modified the order that was shown to the user immediately after the first
    read. In this case, the user is informed of the problem and the newly retrieved
    order is shown to the user once more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the version number is unchanged, we increase the version number, proceed
    with the save, and commit the transaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A purchase order, along with all its subparts (its order-items), is called an
    **aggregate**, while the order entity is called the root of the aggregate. Aggregates
    always have roots since they are hierarchies of entities connected by *subparts* relations.
  prefs: []
  type: TYPE_NORMAL
- en: Since each aggregate represents a single complex entity, all the operations
    on it must be exposed by a unique interface. Therefore, the aggregate root usually
    represents the whole aggregate, and all the operations on the aggregate are defined
    as methods of the root entity.
  prefs: []
  type: TYPE_NORMAL
- en: When the *aggregate* pattern is used, the units of information that are transferred
    between the business layer and the data layer are called *aggregates*, queries,
    and query results. Thus, aggregates replace single entities.
  prefs: []
  type: TYPE_NORMAL
- en: What about the WWTravelClub location and packages entities we looked at in [Chapter
    6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data in C# -
    Entity Framework Core*, and [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*? Are packages part of the unique aggregates
    that are rooted in their associated locations? No! In fact, locations are rarely
    updated and changes that are made to a package have no influence on its location
    and on the other packages associated with the same location.
  prefs: []
  type: TYPE_NORMAL
- en: The repository and Unit of Work patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The repository pattern is how we implement the interface between the domain
    data layer. Interfaces that are implemented by repositories are defined in the
    domain layer, while their implementations are defined in the data layer. The peculiarity
    of this way of implementing the interface with the data layer is its entity-centric
    nature, meaning that there should be a different repository for each root aggregate.
    Each repository contains all the save/creation operations that were performed
    on the associated aggregate, as well as all the query operations that were performed
    on the entities that compose the aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: Since there are also transactions that can span several aggregates, usually,
    the repository pattern is applied with the *Unit of Work* pattern. The Unit of
    Work pattern states that each data layer interface (in our case, each repository)
    contains a reference to a *Unit of Work* interface that represents the identity
    of the current transaction. This means that several repositories with the same *Unit
    of Work* reference belong to the same transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both patterns can be implemented by defining some seed interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All the repository interfaces inherit from `IRepository<T>` and bind `T` to
    the aggregate root they are associated with, while *Unity of Work* simply implements `IUnitOfWork`.
    When using Entity Framework, `IUnitOfWork` is usually implemented with `DBContext`,
    which means that `SaveEntitiesAsync()` can perform other operations and then call
    the `DBContext` `SaveChangeAsync` method so that all the pending changes are saved
    with a single transaction. If a wider transaction that starts when some data is
    retrieved from the storage engine is needed, it must be started and committed/aborted
    by the application layer handler that takes care of the whole operation. `IRepository<T>`
    inherits from an empty `IRepisotory` interface to help automatic repository discovery.
    The GitHub repository associated with this book contains a `RepositoryExtensions`
    class whose `AddAllRepositories` `IServiceCollection` extension method automatically
    discovers all the repository implementations contained in an assembly and adds
    them to the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram of the data layer/domain layer/data layer architecture
    based on the repository and Unity of Work patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e4ba8d3-66e0-4aa9-8975-e6f64347fdb8.png)'
  prefs: []
  type: TYPE_IMG
- en: The main advantage of avoiding direct references to repository implementations
    is that the various modules can be tested easily if we mock these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: DDD entities and Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DDD requires entities to be defined in a way that is different from the way
    we defined entities in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*. In fact, Entity Framework
    entities are record-like lists of public properties with almost no methods, while
    DDD entities should have methods that encode domain logic, more sophisticated
    validation logic, and read-only properties. While further validation logic and
    methods can be added without breaking Entity Framework's operations, adding read-only
    properties that must not be mapped to database properties can create problems
    that must be handled adequately. Preventing properties from being mapped to the
    database is quite easy – all we need to do is decorate them with the `NotMapped`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issues that read-only properties have are a little bit more complex and
    can be solved in three fundamental ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the DDD entities as different classes and copy data to/from them when
    entities are returned/passed to repository methods. This is the easiest solution
    but it requires that you write some code so that you can convert the entities
    between the two formats. DDD entities are defined in the domain layer, while the
    EF entities continue being defined in the data layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let Entity Framework Core map fields to class private fields so that you can
    decide on how to expose them to properties by writing custom getters and/or setters.
    This can be done in the configuration code of the entity, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The main disadvantage of this approach is that the field is provided as a string,
    which prevents any compile-time checks and also prevents automatic refactoring,
    thereby creating possible sources of bugs and maintainability issues. Moreover,
    we can't use data annotations to configure the property since the whole configuration
    must be performed with the fluent interface of the `OnModelCreating` `DBContext`
    method. In this case, entity definitions must be moved from the domain layer as
    prescribed by DDD.
  prefs: []
  type: TYPE_NORMAL
- en: Hide the Entity Framework class with all its public properties behind an interface
    that, when needed, only exposes property getters. The interface is defined in
    the domain layer, while the entity continues being defined in the data layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the repository must expose a `Create` method that returns an implementation
    of the interface; otherwise, the higher layers won't be able to create new instances
    that can be added to the storage engine since interfaces can't be created with
    `new`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For instance, suppose that we would like to define a DDD interface called `IDestination`
    for the `Destination` class defined in the *Defining DB Entities* subsection of
    [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data
    in C# – Entity Framework Core*, and suppose we would like to expose the `Id`,
    `Name`, and `Country` properties as read-only since once a destination is created
    they can''t be modified anymore. Here, it is enough to let `Destination` implement `IDestination`
    and to define `Id`, `Name`, and `Country` as read-only in `IDestination`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've discussed the basic patterns of DDD and how to adapt the Entity
    Framework for the needs of DDD, we can discuss more advanced DDD patterns. In
    the next subsection, we will introduce the CQRS pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Command Query Responsibility Segregation (CQRS) pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its more general form, the usage of this pattern is quite easy: use different
    structures to store and query data. Here, the requirements regarding how to store
    and update data differ from the requirements of queries. In the case of DDD, the
    unit of storage is the *aggregate*, so additions, deletions, and updation involve
    aggregates, while queries usually involve more or less complicated transformations
    of properties that have been taken from several aggregates.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, usually, we don't perform business operations on query results – we
    just use them to compute other data (averages, sums, and so on). Therefore, while
    updates require entities with full object-oriented semantics (methods, validation
    rules, encapsulated information, and so on), query results just need sets of property/values
    pairs, so DTOs with only public properties and no methods work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its more common form, the pattern can be depicted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c535aa97-526c-4dff-8fe5-4fe14d85f1fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The main takeaway from this is that the extraction of query results don''t
    need to pass through the construction of entities and aggregates, but the fields
    shown in the query must be extracted from the storage engine and projected into
    ad hoc DTOs. If queries are implemented with LINQ, we need to use the `Select`
    clause to project the necessary properties into DTOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, in more complex situations, the CQRS may be implemented in a stronger
    form. Namely, we can use different Bounded Contexts to store preprocessed query
    results. This approach is common when queries involve data stored in different
    Bounded Contexts that's handled by different distributed microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the other option would be an aggregator microservice that queries all
    the necessary microservices in order to assemble each query result. However, recursive
    calls to other microservices to build an answer may result in unacceptable response
    times. Moreover, factoring out some preprocessing ensures better usage of the
    available resources. This pattern is implemented by sending changes caused by
    Bounded Context updates to all the microservices that need them for computing
    their preprocessed query results.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of this stronger form of the CQRS pattern transforms usual local database
    transactions into complex time-consuming distributed transactions since a failure
    in a single query preprocessor microservice should invalidate the whole transaction.
    As we explained in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, implementing distributed
    transactions is usually unacceptable for performance reasons, so the common solution
    is to renounce to immediate overall coherent database and to accept that the overall
    database will eventually be coherent after each update. Transient failures can
    be solved with the retry policies that we analyzed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, while permanent failures
    are handled by performing corrective actions on the already committed local transactions
    instead of pretending to implement an overall globally distributed transaction.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, communication between
    microservices is often implemented with the publisher/subscriber pattern to improve
    microservice separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you may be asking the following question:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Why do we need to keep the original data once we have all the preprocessed
    query results? We will never use them to answer queries!"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the answers to this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are the source of `truth` that we may need to recover from failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need them to compute new preprocessed results when we add new queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need them to process new updates. In fact, processing updates usually requires
    that some of the data is retrieved from the database, possibly shown to the user,
    and then modified. For instance, to modify an item in an existing purchase order,
    we need the whole order so that we can show it to the user and compute the changes
    so that we can forward it to other microservices. Moreover, whenever we modify
    or add data to the storage engine, we must verify the coherence of the overall
    database (unique key constraints, foreign key constraints, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will describe a common pattern that's used for handling
    operations that span several aggregates or several Bounded Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Command handlers and domain events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep aggregates separated, usually, interactions with other aggregates and
    other Bounded Contexts is done through events. It is good practice to store all
    the events when they are computed during each aggregate process instead of processing
    them immediately in order to avoid them interfering with the ongoing computation.
    This is easily achieved by adding the following code to the abstract Entity class
    defined in the *Entities and value objects* subsection of this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `IEventNotification` is an empty interface that's used to mark classes
    as events.
  prefs: []
  type: TYPE_NORMAL
- en: Event processing is usually performed immediately before changes are stored
    in the storage engine. Accordingly, a good place to perform event processing is
    in the `SaveEntitiesAsync()` method of each `IUnitOfWork` implementation (see
    the *The repository and Unit of Work patterns* subsection).
  prefs: []
  type: TYPE_NORMAL
- en: 'Subscriptions to an event, `T`, can be provided as an implementation of the `IEventHandler<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Analogously, business operations can be described by the `command` object,
    which contains all the input data of the operation, while the code that implements
    the actual operation can be provided through the implementation of an `ICommandHandler<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ICommand` is an empty interface that's used to mark classes as commands. `ICommandHandler<T>`
    and `IEventHandler<T>` are examples of the command pattern we described in [Chapter
    9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and .NET Core
    Implementation*.
  prefs: []
  type: TYPE_NORMAL
- en: Each `ICommandHandler<T>` can be registered in the dependency injection engine
    so that classes that need to execute a command, `T`, can use `ICommandHandler<T>`
    in their constructor. This way, we decouple the abstract definition of a command
    (command class) from the way it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same construction can''t be applied to events, `T`, and their `IEventHandler<T>` because
    when an event is triggered, we need to retrieve several `IEventHandler<T>` and
    not just one. We need to do this since each event may have several subscriptions.
    However, a few lines of code can easily solve this difficulty. First, we need
    to define a class that hosts all the handlers for a given event type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that each class that needs to trigger event `T` requires an `EventTrigger<T>` and
    then passes the event to be triggered to its `Trigger` method, which, in turn,
    invokes all the handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we need to register `EventTrigger<T>` in the dependency injection engine.
    A good idea is to define the dependency injection extensions that we can invoke
    to declare each event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This `AddEventHandler` extension must automatically produce a DI definition
    for `EventTrigger<T>` and must process all the handlers that are declared with
    `AddEventHandler` for each type, `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extension class does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `H` types of all the handlers associated with each event, `T`, are recorded
    in a list contained in an entry of a dictionary indexed by the `T` type of the
    event. Then, each `H` is recorded in the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: The first time an entry for an event, `T`, is added, the corresponding dictionary
    entry is created (a `List<Type>`) and the corresponding `EventTrigger<T>` is added
    to the dependency injection engine. The `EventTrigger<T>` instance is created
    by a function that's passed to `AddSingleton<EventTrigger<T>>`, which uses the
    dictionary entry for `T` to get all the handler types. Then, all the handler types
    are used to retrieve the instances for the dependency injection engine with `p.GetService(type)`.
    We can use this operation since all the handler types were registered in the dependency
    injection engine. Finally, the list of all the handlers is used to create the
    required instance of `EventTrigger<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: When the program starts up, all the `ICommandHandler<T>` and `IEventHandler<T>`
    implementations can be retrieved with reflection and registered automatically.
    To help with automatic discovery, they inherit from `ICommandHandler` and `IEventHandler`,
    which are both empty interfaces. The `EventDIExtensions` class, which is available
    in this book's GitHub repository, contains methods for the automatic discovery
    and registration of command handlers and event handlers. The GitHub repository
    also contains an `IEventMediator` interface and its `EventMediator` interface,
    whose `TriggerEvents(IEnumerable<IEventNotification> events)` method retrieves
    all the handlers associated with the events it receives in its argument from the
    dependency injection engine and executes them. It is enough to have `IEventMediator`
    injected into a class so that it can trigger events. `EventDIExtensions` also
    contains an extension method that discovers all the queries that implement the
    empty `IQuery` interface and adds them to the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated implementation is given by the `MediatR` NuGet package.
    The previous subsection is dedicated to an extreme implementation of the CQRS
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Event sourcing is an extreme implementation of the stronger form of CQRS. It
    is useful when the original Bounded Context isn''t used at all to retrieve information
    and just as a *source of truth* is used for new queries and for recovering from
    failures. In this case, instead of updating data, we simply add events that describe
    the operation that was performed: *deleted record Id 15*, changed the name to
    *John in Id 21*, and so on. These events are immediately sent to all the dependent
    Bounded Contexts, and in the case of failures and/or the addition of new queries,
    all we have to do is to reprocess some of them.'
  prefs: []
  type: TYPE_NORMAL
- en: While all of the techniques we've described up until now can be used in every
    type of project if minor modifications are made, event sourcing requires a deep
    analysis to be performed before it can be adopted since, in several cases, it
    may create bigger problems than the ones it can solve. To get an idea of the problems
    it may cause when it's misused, imagine that we apply it to purchase orders that
    have been modified and validated by several users before being approved. Since
    purchase orders need to be retrieved before they're updated/validated, the purchase
    order's Bounded Context isn't used just as a *source of truth*, so event sourcing
    should not be applied to it. If this isn't the case, then we can apply event sourcing
    to it, in which case our code would be forced to rebuild the whole order from
    the recorded events each time the order is updated.
  prefs: []
  type: TYPE_NORMAL
- en: An example of its usage is the revenue logging system we described at the end
    of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying a Microservice
    Architecture to Your Enterprise Application*. Single revenues are recorded with
    event sourcing and then sent to the microservice we described in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, which, in turn, uses
    them to preprocess future queries, that is, to compute daily revenues.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how DDD can be applied to this book's WWTravelClub
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – understanding the domains of the use case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the requirements listed in the *Case study – WWTravelClub* section of
    [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding the Importance
    of Software Architecture*, and for the analysis in the *Use case – where do I
    store data?* section of [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*, we know that the WWTravelClub system
    is composed of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Information about the available destinations and packages. We implemented the
    first prototype of this subsystem's data layer in [Chapter 7](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml), *How
    to Choose Your Data Storage in the Cloud*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reservation/purchase orders subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with the experts/reviews subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment subsystem. We briefly analyzed the features of this subsystem and its
    relationship with the reservation purchase subsystem at the beginning of the *Domain-driven
    design* section of this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User accounts subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics reporting subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do the preceding subsystems represent different *Bounded Contexts*? Can some
    subsystems be split into different Bounded Contexts? The answers to these questions
    are given by *the languages* that are spoken in each subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: The language that's spoken in subsystem 1 is the language of *travel agencies*.
    There is no concept of a customer; just of locations, packages, and their features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language that's spoken in subsystem 2 is common to all service purchases,
    such as the available resources, reservations, and purchase orders. This is a
    separate Bounded Context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The language that''s spoken in subsystem 3 has a lot in common with subsystem
    1''s language. However, there are also typical *social media* concepts, such as
    rating, chats, post sharing, media sharing, and so on. This subsystem can be split
    into two parts: a social media subsystem that has a new bounded context and an
    *available information* subsystem that is part of the Bounded Context of subsystem
    1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we pointed out in the *Domain-driven design* section, in subsystem 4, we
    speak the language of *banking*. This subsystem communicates with the reservation
    purchase subsystem and executes tasks that are needed to carry out a purchase.
    From these observations, we can see that it is a different Bounded Context and
    has a customer/supplier relationship with the purchase/reservation system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsystem 5 is definitely a separate Bounded Context (as in almost all web applications).
    It has a relationship with all the Bounded Contexts that either have a concept
    of a user or a concept of a customer because the concept of user accounts always
    maps to these concepts. But how? Simple—the currently logged-in user is assumed
    to be the social media user of the social media Bounded Context, the customer
    of the reservation/purchase Bounded Context, and the payer of the payment Bounded
    Context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query-only subsystem, that is, 6, speaks the language of analytics and statistics
    and differs a lot from the languages that are spoken in the other subsystems.
    However, it has a connection with almost all the Bounded Contexts since it takes
    all its input from them. The preceding constraints force us to adopt CQRS in its
    strong form, thereby considering it a query-only separated Bounded Context. We
    implemented a part of it in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    a Microservice Architecture to Your Enterprise Application*, by using a microservice
    that conforms to a strong form of CQRS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, each of the listed subsystems defines a different Bounded Context,
    but part of the *communication with the experts/reviews subsystem* must be included
    in the *Information about available destinations and packages* Bounded Context.
  prefs: []
  type: TYPE_NORMAL
- en: As the analysis continues and a prototype is implemented, some Bounded Contexts
    may split and some others may be added, but it is fundamental to immediately start
    modeling the system and to immediately start analyzing the relations among the
    Bounded Contexts with the partial information we have since this will drive further
    investigations and will help us define the communication protocols and Ubiquitous
    Languages that are needed so that we can interact with the domain experts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a basic first sketch of the domain map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/070f378b-16a3-47ff-bfd1-dd1a800fade6.png)'
  prefs: []
  type: TYPE_IMG
- en: For simplicity, we've omitted the **Statistics reporting** Bounded Context.
    Here, we're assuming that the **User accounts** and **Social** Bounded Contexts
    have a *conformist* relationship with all the other Bounded Contexts that communicate
    with them because they are implemented with already existing software, so all
    the other components must adapt to them.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the relationship between **Reservation** and **Payments** is
    *customer/supplier* because *Payments* furnishes services that are used to execute
    the tasks of *Reservation*. All the other relationships are classed as *Partners*.
    The various concepts of customer/user that most Bounded Contexts have are coordinated
    by the **User accounts** authorization token, which indirectly takes care of mapping
    these concepts between all the Bounded Contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The *Packages/location* subsystem not only communicates the packages information
    that's needed for carrying out a reservation/purchase – it also takes care of
    informing pending purchase orders of possible price changes. Finally, we can see
    that social interactions are started from an existing review or location, thereby
    creating communication with the *Package/locations* Bounded Context.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the main reasons for the adoption of domain-driven
    design and why and how it faces the needs of the market. Here, we described how
    to identify domains and how to coordinate the teams that work on different domains
    of the same application with domain maps. Then, we analyzed the way DDD represents
    data with entities, value objects and aggregates, furnishing advice, and code
    snippets so that we could implement them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some typical patterns that are used with DDD, that is, the repository
    and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then,
    we learned how to implement them in practice. We also showed you how to implement
    domain events and the command pattern with decoupled handling so that we can add
    furnishing code snippets to real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the principles of DDD in practice to define domains and to
    create the first sketch of a domain map for this book's WWTravelClub use case.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to maximize code reuse in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What furnishes the main hints so that we can discover domain boundaries?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main tool that's used for coordinating the development of a separate
    Bounded Context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that each entry that composes an aggregate communicates with the
    remainder of the system with its own methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is there a single aggregate root?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many repositories can manage an aggregate?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a repository interact with the application layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the Unit of Work pattern needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the reasons for the light form of CQRS? What about the reasons for
    its strongest form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main tool that allows us to couple commands/domain events with their
    handlers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that event sourcing can be used to implement any Bounded Context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More resources on domain-driven design can be found here: [https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed discussion of CQRS design principles can be found here: [http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on MediatR can be found on MediatR's GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good description of event sourcing, along with an example of it, can be seen
    in the following blog post by Martin Fowler: [https://martinfowler.com/eaaDev/EventSourcing.html ](https://martinfowler.com/eaaDev/EventSourcing.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
