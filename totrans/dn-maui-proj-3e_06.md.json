["```cs\n    namespace GalleryApp.Models;\n    public class Photo\n    {\n      public string Filename { get; set; }\n      public byte[] Bytes { get; set; }\n    }\n    ```", "```cs\n    namespace GalleryApp.Services;\n    using System.Collections.ObjectModel;\n    using GalleryApp.Models;\n    public interface IPhotoImporter\n    {\n      Task<ObservableCollection<Photo>> Get(int start, int  count, \n    Quality quality = Quality.Low);\n      Task<ObservableCollection<Photo>> Get(List<string> filenames, \n    Quality quality = Quality.Low);\n    }\n    ```", "```cs\n    namespace GalleryApp.Services;\n    public enum Quality\n    {\n      Low,\n      High\n    }\n    ```", "```cs\n    namespace GalleryApp.Services;\n    using GalleryApp.Models;\n    using System.Collections.ObjectModel;\n    internal partial class PhotoImporter : IPhotoImporter\n    {\n      private partial Task<string[]> Import();\n      public partial Task<ObservableCollection<Photo>> Get(int \n    start, int count, Quality quality);\n      public partial Task<ObservableCollection<Photo>> \n    Get(List<string> filenames, Quality quality);\n    }\n    ```", "```cs\n    namespace GalleryApp;\n    internal partial class AppPermissions\n    {\n    }\n    ```", "```cs\n    internal partial class AppPermissions\n    {\n      internal partial class AppPermission : Permissions.Photos\n      {\n      }\n    }\n    ```", "```cs\n    public static async Task<PermissionStatus> \n    CheckRequiredPermission() => await Permissions.\n    CheckStatusAsync<AppPermission>();\n    ```", "```cs\n    public static async Task<PermissionStatus> \n    CheckAndRequestRequiredPermission()\n    {\n      PermissionStatus status = await Permissions.\n    CheckStatusAsync<AppPermission>();\n      if (status == PermissionStatus.Granted)\n                return status;\n      if (status == PermissionStatus.Denied && DeviceInfo.Platform \n    == DevicePlatform.iOS)\n      {\n        // Prompt the user to turn on in settings\n        // On iOS once a permission has been denied it may not be \n    requested again from the application\n        await App.Current.MainPage.DisplayAlert(\"Required App \n    Permissions\", \"Please enable all permissions in Settings for \n    this App, it is useless without them.\", \"Ok\");\n      }\n      if\n      (Permissions.ShouldShowRationale<AppPermission>())\n      {\n        // Prompt the user with additional information as to why the \n    permission is needed\n        await App.Current.MainPage.DisplayAlert(\"Required App \n    Permissions\", \"This is a Photo gallery app, without these \n    permissions it is useless.\", \"Ok\");\n      }\n      status = await MainThread.InvokeOnMainThreadAsync(Permissions.\n    RequestAsync<AppPermission>);\n      return status;\n      }\n    }\n    ```", "```cs\n<key> NSPhotoLibraryUsageDescription </key>\n<string> We want to show your photos in this app </string>\n```", "```cs\n    private Dictionary<string,PHAsset> assets;\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n    }\n    ```", "```cs\n    var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n    ```", "```cs\n    internal partial class PhotoImporter\n    {\n      private Dictionary<string,PHAsset> assets;\n      private partial async Task<string[]> Import()\n      {\n        var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n        if (status == PermissionStatus.Granted)\n        {\n          assets = PHAsset.FetchAssets(PHAssetMediaType.Image, null)\n          .Select(x => (PHAsset)x)\n          .ToDictionary(asset => asset.\n    ValueForKey((NSString)\"filename\").ToString(), asset => asset);\n        }\n        return assets?.Keys.ToList().ToArray();\n    }\n    ```", "```cs\nprivate void AddImage(ObservableCollection<Photo> photos, string path, \nPHAsset asset, Quality quality)\n  {\n    var options = new PHImageRequestOptions()\n    {\n      NetworkAccessAllowed = true,\n      DeliveryMode = quality == Quality.Low ?\n      PHImageRequestOptionsDeliveryMode.FastFormat :\n      PHImageRequestOptionsDeliveryMode.HighQualityFormat\n    };\n        PHImageManager.DefaultManager.RequestImageForAsset(asset, \nPHImageManager.MaximumSize, PHImageContentMode.AspectFill, options, \n(image, info) =>\n    {\n      using NSData imageData = image.AsPNG();\n      var bytes = new byte[imageData.Length];\n             System.Runtime.InteropServices.Marshal.Copy(imageData.\nBytes, bytes, 0, Convert.ToInt32(imageData.Length));\n      photos.Add(new Photo()\n      {\n        Bytes = bytes,\n        Filename = Path.GetFileName(path)\n      });\n    });\n  }\n```", "```cs\npublic partial async Task<ObservableCollection<Photo>> Get(int start, \nint count, Quality quality)\n  {\n    var photos = new ObservableCollection<Photo>();\n    var status = await AppPermissions.\nCheckAndRequestRequiredPermission();\n    if (status == PermissionStatus.Granted)\n    {\n      var result = await Import();\n      if (result.Length == 0)\n      {\n        return photos;\n      }\n      Index startIndex = start;\n      Index endIndex = start + count;\n      if (endIndex.Value >= result.Length)\n      {\n        endIndex = result.Length;\n      }\n      if (startIndex.Value > endIndex.Value)\n      {\n        return photos;\n      }\n      foreach (var path in result[startIndex..endIndex])\n      {\n        AddImage(photos, path, assets[path], quality);\n      }\n    }\n    return photos;\n  }\n```", "```cs\npublic partial async Task<ObservableCollection<Photo>> \nGet(List<string> filenames, Quality quality)\n  {\n    var photos = new ObservableCollection<Photo>();\n    var result = await Import();\n    if (result?.Length == 0)\n    {\n      return photos;\n    }\n    foreach (var path in result)\n    {\n      if (filenames.Contains(path))\n      {\n        AddImage(photos, path, assets[path], quality);\n      }\n    }\n    return photos;\n  }\n```", "```cs\n    <key> NSPhotoLibraryUsageDescription </key>\n    <string> We want to show your photos in this app </string>\n    ```", "```cs\nusing Android.OS;\n[assembly: Android.App.UsesPermission(Android.Manifest.Permission.\nReadMediaImages)]\n[assembly: Android.App.UsesPermission(Android.Manifest.Permission.\nReadExternalStorage, MaxSdkVersion = 32)]\nnamespace GalleryApp;\ninternal partial class AppPermissions\n{\n  internal partial class AppPermission : Permissions.Photos\n  {\n    public override (string androidPermission, bool isRuntime)[] \nRequiredPermissions\n    {\n      get\n      {\n        List<(string androidPermission, bool isRuntime)> perms = new();\n        if (Build.VERSION.SdkInt >= BuildVersionCodes.Tiramisu)\n                    perms.Add((global::Android.Manifest.Permission.\nReadMediaImages, true));\n        else\n                    perms.Add((global::Android.Manifest.Permission.\nReadExternalStorage, true));\n        return perms.ToArray();\n      }\n    }\n  }\n}\n```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      return paths.ToArray();\n    }\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n      if (status == PermissionStatus.Granted)\n      {\n      }\n      return paths.ToArray();\n    }\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n      if (status == PermissionStatus.Granted)\n      {\n        var imageUri = MediaStore.Images.Media.ExternalContentUri;\n        var projection = new string[] { MediaStore.IMediaColumns.\n    Data };\n        var orderBy = MediaStore.Images.IImageColumns.DateTaken;\n        var cursor = Platform.CurrentActivity.ContentResolver.\n    Query(imageUri, projection, null, null, orderBy);\n        while (cursor.MoveToNext())\n        {\n          string path = cursor.GetString(cursor.\n    GetColumnIndex(MediaStore.IMediaColumns.Data));\n          paths.Add(path);\n        }\n      }\n      return paths.ToArray();\n    }\n    ```", "```cs\npublic partial async Task<ObservableCollection<Photo>> Get(int start, \nint count, Quality quality)\n{\n  var photos = new ObservableCollection<Photo>();\n  var result = await Import();\n  if (result.Length == 0)\n  {\n    return photos;\n  }\n  Index startIndex = start;\n  Index endIndex = start + count;\n  if (endIndex.Value >= result.Length)\n  {\n    endIndex = result.Length;\n  }\n  if (startIndex.Value > endIndex.Value)\n  {\n    return photos;\n  }\n  foreach (var path in result[startIndex..endIndex])\n  {\n    photos.Add(new()\n    {\n      Bytes = File.ReadAllBytes(path),\n      Filename = Path.GetFileName(path)\n    });\n  }\n  return photos;\n}\n```", "```cs\npublic partial async Task<ObservableCollection<Photo>> \nGet(List<string> filenames, Quality quality)\n{\n  var photos = new ObservableCollection<Photo>();\n  var result = await Import();\n  if (result.Length == 0)\n  {\n    return photos;\n  }\n  foreach (var path in result)\n  {\n    var filename = Path.GetFileName(path);\n    if (!filenames.Contains(filename))\n    {\n      continue;\n    }\n    photos.Add(new Photo()\n    {\n      Bytes = File.ReadAllBytes(path),\n      Filename = filename\n    });\n  }\n  return photos;\n}\n```", "```cs\n    <PackageReference Include=\"System.Data.OleDb\" Version=\"7.0.0\" \n    Condition=\"$([MSBuild]::GetTargetPlatformIdentifier('$(Target\n    Framework)')) == 'windows'\" />\n    <PackageReference Include=\"tlbimp-Microsoft.Search.Interop\" \n    Version=\"1.0.0\" Condition=\"$([MSBuild]::GetTargetPlatform\n    PackageReference so that it is only used when TargetPlatformIdentifier is 'windows'.\n    ```", "```cs\n    using GalleryApp.Models;\n    using Microsoft.Search.Interop;\n    using System.Data.OleDb;\n    ```", "```cs\n    ISearchQueryHelper queryHelper;\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      return paths.ToArray();\n    }\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n      if (status == PermissionStatus.Granted)\n      {\n      }\n      return paths.ToArray();\n    }\n    ```", "```cs\n    private partial async Task<string[]> Import()\n    {\n      var paths = new List<string>();\n      var status = await AppPermissions.\n    CheckAndRequestRequiredPermission();\n      if (status == PermissionStatus.Granted)\n      {\n        string sqlQuery = queryHelper.GenerateSQLFromUserQuery(\" \");\n        using OleDbConnection conn = new(queryHelper.\n    ConnectionString);\n        conn.Open();\n        using OleDbCommand command = new(sqlQuery, conn);\n        using OleDbDataReader WDSResults = command.ExecuteReader();\n        while (WDSResults.Read())\n        {\n          var itemUrl = WDSResults.GetString(0);\n          paths.Add(itemUrl);\n        }\n      }\n      return paths.ToArray();\n    }\n    ```", "```cs\npublic partial async Task<ObservableCollection<Photo>> Get(int start, \nint count, Quality quality)\n{\n}\n```", "```cs\nstring[] patterns = { \".png\", \".jpeg\", \".jpg\" };\nstring[] locations = {\nEnvironment.GetFolderPath(Environment.SpecialFolder.MyPictures),\n      Environment.GetFolderPath(Environment.SpecialFolder.\nCommonPictures),\n     Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.\nUserProfile),\"OneDrive\",\"Camera Roll\")\n};\n```", "```cs\nqueryHelper = new CSearchManager().GetCatalog(\"SystemIndex\").\nGetQueryHelper();\nqueryHelper.QueryMaxResults = start + count;\nqueryHelper.QuerySelectColumns = \"System.ItemPathDisplay\";\nqueryHelper.QueryWhereRestrictions = \"AND (\";\nforeach (var pattern in patterns)\n     queryHelper.QueryWhereRestrictions += \" Contains(System.\nFileExtension, '\" + pattern + \"') OR\";\nqueryHelper.QueryWhereRestrictions = queryHelper.\nQueryWhereRestrictions[..^2];\nqueryHelper.QueryWhereRestrictions += \")\";\nqueryHelper.QueryWhereRestrictions += \" AND (\";\nforeach (var location in locations)\n     queryHelper.QueryWhereRestrictions += \" scope='\" + location + \"' \nOR\";\nqueryHelper.QueryWhereRestrictions = queryHelper.\nQueryWhereRestrictions[..^2];\nqueryHelper.QueryWhereRestrictions += \")\";\nqueryHelper.QuerySorting = \"System.DateModified DESC\";\n```", "```cs\nvar photos = new ObservableCollection<Photo>();\nvar result = await Import();\nif (result?.Length == 0)\n{\n  return photos;\n}\nIndex startIndex = start;\nIndex endIndex = start + count;\nif (endIndex.Value >= result.Length)\n{\n  endIndex = result.Length;\n}\nif (startIndex.Value > endIndex.Value)\n{\n  return photos;\n}\nforeach (var uri in result[startIndex..endIndex])\n{\n  var path = new System.Uri(uri).AbsolutePath;\n  photos.Add(new()\n  {\n    Bytes = File.ReadAllBytes(path),\n    Filename = Path.GetFileName(path)\n  });\n}\nreturn photos;\n```", "```cs\npublic partial async Task<ObservableCollection<Photo>> \nGet(List<string> filenames, Quality quality)\n{\n}\n```", "```cs\nqueryHelper = new CSearchManager().GetCatalog(\"SystemIndex\").\nGetQueryHelper();\nqueryHelper.QuerySelectColumns = \"System.ItemPathDisplay\";\nqueryHelper.QueryWhereRestrictions = \"AND (\";\nforeach (var filename in filenames)\n     queryHelper.QueryWhereRestrictions += \" Contains(System.Filename, \n'\" + filename + \"') OR\";\nqueryHelper.QueryWhereRestrictions = queryHelper.\nQueryWhereRestrictions[..^2];\nqueryHelper.QueryWhereRestrictions += \")\";\n```", "```cs\nvar photos = new ObservableCollection<Photo>();\nvar result = await Import();\nif (result?.Length == 0)\n{\n  return photos;\n}\nforeach (var uri in result)\n{\n  var path = new System.Uri(uri).AbsolutePath;\n  var filename = Path.GetFileName(path);\n  if (filenames.Contains(filename))\n  {\n    photos.Add(new()\n    {\n      Bytes = File.ReadAllBytes(path),\n      Filename = filename\n    });\n  }\n}\nreturn photos;\n```", "```cs\n    using GalleryApp.Services;\n    using Microsoft.Extensions.Logging;\n    public static class MauiProgram\n    {\n      public static MauiApp CreateMauiApp()\n      {\n        var builder = MauiApp.CreateBuilder();\n        builder\n          .UseMauiApp<App>()\n          .ConfigureFonts(fonts =>\n          {\n            fonts.AddFont(\"OpenSans-Regular.ttf\", \n    \"OpenSansRegular\");\n            fonts.AddFont(\"OpenSans-Semibold.ttf\", \n    \"OpenSansSemibold\");\n          });\n    #if DEBUG\n        builder.Logging.AddDebug();\n    #endif\n      builder.Services.AddSingleton<IPhotoImporter>(serviceProvider \n    => new PhotoImporter());\n        return builder.Build();\n      }\n    }\n    ```", "```cs\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n    <Shell\n        x:Class=\"GalleryApp.AppShell\"\n\n        >\n        <ShellContent Title=\"Home\" ContentTemplate=\"{DataTemplate views:MainView}\" />\n        <ShellContent Title=\"Gallery\" ContentTemplate=\"{DataTemplate views:GalleryView}\" />\n    </Shell>\n    ```", "```cs\n            builder.Services.\n    AddSingleton<IPhotoImporter>(serviceProvider => new \n    PhotoImporter());\n            builder.Services.AddTransient<Views.MainView>();\n            builder.Services.AddTransient<Views.GalleryView>();\n    return builder.Build();\n    ```", "```cs\n    namespace GalleryApp.ViewModels;\n    using CommunityToolkit.Mvvm.ComponentModel;\n    public abstract partial class ViewModel: ObservableObject\n    {\n        [ObservableProperty]\n        [NotifyPropertyChangedFor(nameof(IsNotBusy))]\n        private bool isBusy;\n        public bool IsNotBusy => !IsBusy;\n        abstract protected internal Task Initialize();\n    }\n    ```", "```cs\nnamespace GalleryApp.ViewModels;\nusing CommunityToolkit.Mvvm.ComponentModel;\nusing GalleryApp.Models;\nusing GalleryApp.Services;\nusing System.Collections.ObjectModel;\nusing System.Threading.Tasks;\npublic partial class GalleryViewModel : ViewModel\n{\n    private readonly IPhotoImporter photoImporter;\n    [ObservableProperty]\n    public ObservableCollection<Photo> photos;\n    public GalleryViewModel(IPhotoImporter photoImporter) : base()\n    {\n        this.photoImporter = photoImporter;\n    }\n    override protected internal async Task Initialize()\n    {\n        IsBusy = true;\n        Photos = await photoImporter.Get(0, 20);\n        Photos.CollectionChanged += Photos_CollectionChanged;\n        await Task.Delay(3000);\n        IsBusy = false;\n    }\n    private void Photos_CollectionChanged(object sender, System.\nCollections.Specialized.NotifyCollectionChangedEventArgs e)\n    {\n        if (e.NewItems != null && e.NewItems.Count > 0)\n        {\n            IsBusy = false;\n            Photos.CollectionChanged -= Photos_CollectionChanged;\n        }\n    }\n}\n```", "```cs\n        builder.Services.AddSingleton<IphotoImporter>(serviceProvider \n=> new PhotoImporter());\n        builder.Services.AddTransient<ViewModels.GalleryViewModel>();\nbuilder.Services.AddTransient<Views.MainView>();\nbuilder.Services.AddTransient<Views.GalleryView>();\nreturn builder.Build();\n```", "```cs\nnamespace GalleryApp.Converters;\nusing System.Globalization;\ninternal class BytesToImageConverter : IValueConverter\n{\n    public object Convert(object value, Type targetType, object \nparameter, CultureInfo culture)\n    {\n        if (value != null)\n        {\n            var bytes = (byte[])value;\n            var stream = new MemoryStream(bytes);\n            return ImageSource.FromStream(() => stream);\n        }\n        return null;\n    }\n    public object ConvertBack(object value, Type targetType, object \nparameter, CultureInfo culture)\n    {\n        throw new NotImplementedException();\n    }\n}\n```", "```cs\n<ContentPage  \n\n    x:Class=\"GalleryApp.Views.GalleryView\"\n    Title=\"GalleryView\">\n    <ContentPage.Resources>\n      <ResourceDictionary>\n        <converters:BytesToImageConverter x:Key=\"ToImage\" />\n      </ResourceDictionary>\n    </ContentPage.Resources>\n</ContentPage>\n```", "```cs\npublic GalleryView(GalleryViewModel viewModel)\n{\n    InitializeComponent();\n    BindingContext = viewModel;\n      MainThread.InvokeOnMainThreadAsync(viewModel.Initialize);\nGalleryViewModel. That instance is set as BindingContext for the page. This object will be used in the XAML bindings of the view. Finally, we initialize the view model asynchronously.\nWhat we will show in this view is a grid with three columns. To build this with .NET MAUI, we will use the `CollectionView` control. To specify the layout that `CollectionView` should have, add a `GridItemsLayout`element to the `ItemsLayout` property of `CollectionView`. Follow these steps to build this view:\n\n1.  Navigate to `GalleryView.xaml`.\n\n    Import the namespaces for `GalleryApp.ViewModels` and `GalleryApp.Models` as `viewModels` and `models`, respectively:\n\n    ```", "```cs\n\n     2.  On `ContentPage`, set `x:DataType` to `viewModels:GalleryViewModel`. This makes the bindings compile, which will make our view faster to render:\n\n    ```", "```cs\n\nNow, we can see the photos in the view. However, we will also need to create the content that will be shown when we don’t have any photos to show as they have not been loaded yet, or if there are no photos available. Add the following highlighted code to create a `DataTemplate` object to show when `CollectionView`doesn’t have any data:\n\n```", "```cs\n\n Now, we can run the app. The next step is to load more photos when a user reaches the end of the view.\nLoading photos incrementally\nTo load more than the first 20 items, we will load photos incrementally so that when users scroll to the end of `CollectionView`, it will start to load more items. `CollectionView` has built-in support for loading data incrementally. Because we get an `ObservableCollection`object back from the photo importer and data is added asynchronously to it, we need to create an event listener to handle when items are added to the photo importer so that we can add it to the `ObservableCollection`instance that we bound to `CollectionView`. Create the event listener by navigating to `GalleryViewModel.cs` and adding the following code at the end of the class:\n\n```", "```cs\n\n The only thing we have left to do to get the incremental load to work is to bind `CollectionView` to the code we created in `ViewModel`. The following code will trigger the loading of more photos when the user has just five items left:\n\n```", "```cs\n\n Now that we have a view that shows photos and loads them incrementally, we can make it possible to add photos as favorites.\nSaving favorites\nIn `GalleryView`, we want to be able to select favorites that we can show in `MainView`. To do that, we need to store the photos that we have selected so that it remembers our selection. Create a new interface in the `GalleryApp` project named `ILocalStorage` in the `Services` folder:\n\n```", "```cs\n\n The easiest way to store/persist data in .NET MAUI is to use the built-in property store. `Preferences` is a static class in the `Microsoft.Maui.Storage` namespace. Follow these steps to use it:\n\n1.  Create a new class named `MauiLocalStorage` in the `Services` folder.\n2.  Implement the `ILocalStorage` interface:\n\n    ```", "```cs\n\nTo be able to use `ILocalStorage` with constructor injection, we need to register it with the container. Navigate to the `MauiProgram` class and add the following highlighted code:\n\n```", "```cs\n\n Now, we are ready to use the local storage.\nNavigate to the `GalleryViewModel` class, add the `ILocalStorage`interface to the constructor, and assign it to a field:\n\n```", "```cs\n\n The next step is to create a command that we can bind to from the view when we select photos. The command will monitor which photos we have selected and notify other views that we have added favorite photos. We will use `WeakReferenceManager` from `CommunityToolkit` to send messages from `GalleryViewModel` to `MainViewModel`.\nFollow these steps to implement the `GalleryViewModel` side:\n\n1.  Create a new class in the `Services` folder named `Messages`:\n\n    ```", "```cs\n\n    This is used to define the message type we are sending to `MainViewModel`.\n\n     2.  Navigate to `GalleryViewModel`.\n3.  Create a new method named `AddFavorites` that is attributed to the `RelayCommand` type.\n4.  Add the following code:\n\n    ```", "```cs\n\nNow, we are ready to start working with the view. The first thing we will do is make it possible to select photos. Navigate to `GalleryView.xaml` and set the `SelectionMode` mode of `CollectionView` to `Multiple` to make it possible to select multiple items:\n\n```", "```cs\n\n When a user selects a photo, we want it to be clear which photos have been selected. To achieve this, we will use `VisualStateManager`. We will do this by creating a style for `Grid` and setting `Opacity` to `0.5`, as in the following code. Add the code to `Resources` of the page:\n\n```", "```cs\n\n To save the selected photos, we will create a toolbar item that the user can tap:\n\n1.  Add `ToolbarItem` with the `Text` property set to `Select`.\n2.  Add an event handler named `SelectToolBarItem_Clicked`:\n\n    ```", "```cs\n\n     3.  Navigate to the code behind the `GalleryView.xaml.cs` file.\n4.  Add the following `using` statements:\n\n    ```", "```cs\n\n     5.  Create an event handler named `SelectToolBarItem_Clicked`:\n\n    ```", "```cs\n\nNow that we are done with `GalleryView`, we will continue with the main view, which will show the latest photos and the favorite photos in two carousels.\nCreating the carousels for MainView\nThe last view in this app is `MainView`, which is the view that is visible when users start the app. This view will show two carousel views—one with recent photos and one with favorite photos.\nCreating the view model for MainView\nWe will start by creating `ViewModel` that we will use for the view. In the `ViewModel` folder, create a new class named `MainViewModel`:\n\n```", "```cs\n\n In the preceding code, the `Initialize` method is used to register a callback with `Weak` **ReferenceManager**. This callback invokes the `LoadFavorites` method if the message sent was `Message.FavoritesAddedMessage`. Recall that `Messages.Favorites` **AddedMessage** is sent from `GalleryViewModel` after selecting new photos.\nIn the `LoadFavorites` method, the favorites are loaded from the storage provider instance in `localStorage`. Then, the photos from the favorites are imported using the `photoImporter` instance.\nWe need to add the view model to dependency injection so that we can use it in the view. Open `MauiProgram` and add the highlighted code:\n\n```", "```cs\n\n Now that we have created `MainViewModel`, we will continue with the latest photos.\nShowing the latest photos\nWe are now ready to set up the carousel views. We have already created the view model, so we can use the view model to populate the view with content.\nLet’s look at the steps to create the view:\n\n1.  In the constructor of the code, behind the `MainView.xaml.cs` file, set `ViewModel` to `BindingContext`:\n\n    ```", "```cs\n\n     2.  Navigate to `MainView.xaml`.\n3.  Add the following code:\n\n    ```", "```cs\n\n    The `CarouselView` control is used to present data to the user in a scrollable layout, where the user can swipe to move through the collection of items. It is very similar to `CollectionView`; however, the uses of the two controls are different. You would use `CollectionView` when you want to display a list of items with an indeterminate length, and `CarouselView` is used to highlight items from a list of items with a limited length. Since `CarouselView` shares implementations with the `CollectionView` control, it uses the familiar `ItemTemplate` property to customize how each item is displayed. It adds an `ItemsLayout` property to define how the collection of items is displayed. `CarouselView` can use either a `Horizontal` or `Vertical` layout direction, with `Horizontal` being the default.\n\n    In `MainView`, `CarouselView` is used to display the `Recent` photos from `MainViewModel`. `ItemsLayout` is customized to set the scrolling behavior so that items will snap into view using the start, or left edge of the image. The `SnapPointType` property set to `Mandatory` makes sure that `CarouselView` snaps the image into place after scrolling, which would ensure a single image is always in view.\n\n    `ItemsTemplate` is used to display an image that is data-bound to each photo and displays the image from the bytes in the `Photo` model. `BytesToImageConverter` converts the byte array from the `Photo` model into `ImageSource` that can be displayed by the `Image` control. The `Image` control has the `Aspect` property set to `AspectFill`, allowing the image control to resize the image, maintaining the aspect ratio of the source image to fill the available visible space.\n\nNow that we have shown the latest photos in a carousel, the next (and the last) step is to show the favorite photos in another carousel.\nShowing the favorite photos\nThe last thing we will do in this app is add a carousel to show favorite photos. Add the following highlighted code inside `Grid`, after the first `CarouselView`, as shown in the following code snippet:\n\n```", "```cs\n\n For the `Favorites` photos, again, `CarouselView` is used with a few changes from `CarouselView` displaying the `Recent` photos. The most visible change is that the `ItemsLayout` property is now using `MandatorySingle` for the value of `SnapPointsType`. This forces a behavior that only allows the user to swipe one image at a time, snapping each image into view.\nThe `ItemTemplate` property has also been changed to add a rounded border around each image, with a background color.\nNew to this `CarouselView` is the `EmptyViewTemplate` property. This is used to display the text `\"No favorites selected\"` when the `Favorites` property is empty.\nFinally, `IndicatorView` was added to provide the user with a visual cue of how many items are in `CarouselView` and which item is currently displayed. `CarouselView` is connected to `IndicatorView` by the `IndicatorView` property of `CarouselView`. The `IndicatoryView` property is set to the `x:Name` property of `IndicatorView`. The `IndicatorView` displays on the page as a series of horizontal light gray dots, with the dot representing the current image in red.\nThat is all—now, we can run the app and see both the most recent photos and the photos that have been marked as favorites.\nSummary\nIn this chapter, we focused on photos. We learned how to import photos from the platform-specific photo galleries and how we can display them as a grid using `CollectionView` and in carousels using `CarouselView`. This makes it possible for us to build other apps and provides multiple options for presenting data to users, as we can now pick the best method for the situation.\nAdditionally, we learned about permissions and how to check and request permission to use protected resources in our app.\nIf you are interested in extending the app even further, try creating a page to view the details of the photo, or to view the photo in full screen by tapping on the photo.\nIn the next chapter, we will build an app using location services and look at how to visualize location data on a map.\n\n```"]