- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing and Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delves into the foundational concepts of unit testing and **Test-Driven
    Development** ( **TDD** ) within Visual Studio 2022. You will learn about the
    significance of writing tests before code and explore the integration of testing
    frameworks. Practical examples will guide you through creating effective unit
    tests, ensuring code reliability, and fostering a test-driven mindset.
  prefs: []
  type: TYPE_NORMAL
- en: We will embark on a journey to understand the essentials of unit testing and
    TDD. We’ll start by gaining an overview of these foundational concepts and exploring
    their significance in the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Following this introduction, we will delve into the practical aspects of setting
    up unit testing within Visual Studio Code. This section will guide you through
    the initial steps of configuring your development environment, laying the groundwork
    for the integration of testing frameworks into your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Once the setup is complete, we will transition into creating our first test
    using IntelliTest, a feature of Visual Studio that automates the generation of
    unit tests. This hands-on experience will demonstrate how IntelliTest can streamline
    the testing process, making it more efficient and less time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will apply what we’ve learned in a real-world example, practicing TDD
    from the ground up. This section will walk you through the process of writing
    tests before code, a core principle of TDD, and how it can lead to more robust
    and reliable software.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will explore how to automate your testing process with Live Unit
    Testing, a feature that runs your unit tests in the background as you code. This
    section will show you how to enable and utilize Live Unit Testing to enhance your
    development workflow, ensuring that your code remains reliable and bug-free throughout
    the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing unit testing and TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up unit testing in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tests with IntelliTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing TDD with a real-world example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating your tests with Live Unit Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch01)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing unit testing and TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before delving into the usage of unit testing and the TDD approach through Visual
    Studio, let’s begin with a refresher on what they are and why it’s valuable to
    consider them in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a focused software testing method that targets individual units
    or components within a software system. The primary aim of unit testing is to
    ensure that each software unit functions as intended, meeting specified requirements.
    Typically conducted by developers, unit testing takes place early in the development
    stage, preceding the integration and testing of the entire system.
  prefs: []
  type: TYPE_NORMAL
- en: Automated unit tests are executed whenever code undergoes modification, ensuring
    that new changes do not disrupt existing functionality. These tests are meticulously
    crafted to validate the smallest conceivable unit of code, such as a function
    or method, in isolation from the broader system. This approach empowers developers
    to swiftly identify and address issues in the initial phases of development, thereby
    enhancing overall software quality and reducing the time needed for subsequent
    testing phases.
  prefs: []
  type: TYPE_NORMAL
- en: The F.I.R.S.T principles of unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By conscientiously embracing the **Fast, Isolated/Independent, Repeatable, Self-Validating,
    Timely** ( **F.I.R.S.T.** ) principles in unit testing, developers are guided
    in the meticulous crafting of effective tests. These principles serve as a compass,
    steering the testing process toward excellence by instilling key criteria that
    underpin the reliability and robustness of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at each of the factors of F.I.R.S.T. in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast** : The speed of execution is a fundamental characteristic of effective
    unit tests. It is imperative that unit tests run swiftly, as developers frequently
    execute them throughout the development process. A fast test suite provides rapid
    feedback, allowing developers to promptly identify and rectify issues. This not
    only accelerates the development cycle but also cultivates a culture of responsiveness,
    where developers are encouraged to run tests frequently. The ability to obtain
    quick feedback enhances the early detection of potential problems, fostering a
    proactive approach to software quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated/independent** : Independence is a cornerstone principle in unit
    testing. Each unit test should operate in isolation, devoid of dependencies on
    other tests. The order in which tests are executed or the success or failure of
    one test must not impact the results of another. This isolation ensures that developers
    can pinpoint and address issues in a focused manner, simplifying the debugging
    process. By adhering to the principle of independence, developers gain the advantage
    of precisely identifying the source of a problem, thereby expediting the resolution
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable** : The repeatability of unit tests is paramount for maintaining
    the integrity of the testing process. A unit test should consistently produce
    the same result every time it is executed. This consistency ensures reliability
    in the test results, facilitating a dependable and predictable testing environment.
    If a test fails, developers should be able to reproduce the failure consistently,
    enabling them to investigate and resolve issues with confidence. Repeatability
    is a cornerstone for establishing trust in the testing suite and the overall software
    development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-validating** : Unit tests should possess self-contained criteria for
    success or failure, requiring no manual interpretation. A self-validating test
    ensures unambiguous results, reducing the potential for misinterpretation. Developers
    can quickly understand the state of the code based solely on the test results,
    streamlining the debugging and issue-resolution processes. The self-validating
    nature of unit tests contributes to the clarity and effectiveness of the testing
    suite, enabling developers to make informed decisions based on the unambiguous
    outcomes of each test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timely** : Timeliness in test writing is a critical factor in the effectiveness
    of unit testing. Ideally, tests should be authored before the corresponding code
    is implemented. This proactive approach ensures that tests serve as a living specification
    for the desired behavior, guiding the implementation process. Writing tests in
    a timely manner establishes a foundation for a well-defined and controlled development
    cycle. Timely testing also plays a pivotal role in identifying and addressing
    issues early in the development cycle, reducing the likelihood of defects propagating
    to later stages of the software development process. Embracing timely testing
    enhances the overall efficiency and reliability of the software development life
    cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve established a foundational understanding of unit testing and
    its principles, let’s turn our attention to the broader context of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: TDD – unifying principles for software quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These F.I.R.S.T principles seamlessly pave the way to an overarching methodology
    known as TDD. TDD merges design, development, and testing into a unified framework,
    providing developers with a comprehensive approach to not only crafting simple
    and clean code but also ensuring thorough testing. The incremental development
    approach systematically tests all facets of business logic, making TDD the gold
    standard for creating high-quality software. It embodies the best coding and design
    practices throughout the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main purpose of TDD is to achieve simpler and more reliable code. For that,
    TDD follows a simple and effective process, illustrated by the **red-green-refactor
    cycle** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The TDD cycle](img/B22218_01_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The TDD cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand this TDD cycle in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red – writing a** **failing test** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first phase of TDD, known as the Red phase, developers embark on the
    journey by articulating their intent through the creation of a failing test. This
    test specifically targets a small unit of functionality that has not yet been
    implemented. It serves as a tangible expression of the desired behavior, essentially
    outlining the expectations for the code that is yet to be written. It is important
    to note that, at this stage, the test is expected to fail since the corresponding
    functionality is absent from the code base.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The primary purpose of the Red phase is to set a clear objective for the subsequent
    development process. By initially focusing on the expected outcome without any
    code in place, developers define a roadmap for the functionality they are about
    to implement. This intentional act of writing a test before writing the code not
    only establishes a specification for the upcoming functionality but also helps
    solidify the developer’s understanding of the problem at hand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Green – writing the minimum amount of code to pass** **the test** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the Red phase, the development process proceeds to the Green phase.
    Here, the developer crafts the minimal amount of code necessary to make the previously
    written test pass successfully. The emphasis during this phase is on simplicity
    and efficiency. The goal is not to create an elaborate solution but to address
    the immediate requirement highlighted by the failing test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By concentrating on the bare minimum code required for success, developers foster
    a culture of simplicity and avoid unnecessary complexities. This focused approach
    encourages the creation of code that meets the specific needs outlined by the
    test, laying the foundation for a solution that is both functional and concise.
    The success of the test in this phase signifies the achievement of the targeted
    functionality, validating the initial expectations set in the Red phase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Refactor – refactoring** **the code** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a passing test in place, the development process enters the Refactor phase.
    At this juncture, the developer takes a step back to review and enhance the code
    that has been implemented. The primary objectives during refactoring are to improve
    the maintainability, readability, and extensibility of the code without altering
    its functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refactoring is a critical aspect of TDD as it ensures that the code base remains
    clean and adaptable to future changes. Developers strive to eliminate redundancies,
    improve naming conventions, and apply design patterns where appropriate. This
    phase reinforces the commitment to producing not only functional but also well-crafted
    code. The successful completion of this phase sets the stage for a code base that
    is not only effective but also sustainable in the long run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Repeat –** **iterative process** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD follows an iterative approach, and the Repeat phase encapsulates the cyclical
    nature of this development methodology. The entire Red-Green-Refactor cycle is
    repeated for each new piece of functionality that needs to be implemented. This
    iterative process ensures a systematic and gradual evolution of the code base,
    with each cycle contributing to the overall development of the software.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By repeating the cycle, developers continually refine and expand the application,
    responding to evolving requirements and ensuring that the code remains aligned
    with the project’s objectives. This iterative nature of TDD promotes adaptability
    and agility, making it a valuable methodology for projects with changing or evolving
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: This approach not only ensures the creation of functional software but also
    cultivates a mindset of continuous improvement and adaptability in the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: AAA pattern – a structured approach to testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building upon the principles of TDD and F.I.R.S.T, another key methodology in
    the realm of unit testing is the **Arrange-Act-Assert** ( **AAA** ) pattern. This
    pattern provides a uniform structure for organizing tests within a suite. The
    AAA pattern contributes significantly to the readability and maintainability of
    test suites, aligning seamlessly with the overarching goals of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AAA pattern breaks down a test into three distinct sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange** : This section is about setting up the test environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Arrange section, the focus is on preparing the environment for the test.
    This involves setting up the objects to be tested, bringing the **System under
    Test** ( **SUT** ) to a specific state, and configuring any dependencies. Whether
    instantiating objects directly or preparing test doubles dependencies, the goal
    is to establish a controlled and consistent starting point for the test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Act** : This section is about performing the action on the SUT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Act section is where the actual interaction with the SUT takes place. This
    involves invoking a method or action on the SUT, passing any required dependencies,
    and capturing the output value, if applicable. The Act phase is crucial for simulating
    the real-world usage of the system and observing its behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Assert** : This section focuses on verifying the expected outcome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Assert section, the test makes explicit claims about the expected outcome.
    This may include checking the return value, inspecting the final state of the
    SUT and its collaborators, or verifying the methods called on them. The Assert
    phase is the culmination of the test, ensuring that the behavior aligns with the
    anticipated results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The AAA pattern’s structured approach provides clarity and consistency across
    all tests in a suite. By adhering to this pattern, developers can easily comprehend
    and navigate through tests, ultimately reducing the maintenance cost of the entire
    test suite. Whether starting with Arrange, Act, or Assert, the AAA pattern accommodates
    different testing styles while promoting a unified and systematic testing methodology.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve had a tour of unit testing and TDD, let’s dive in and see how
    to create a unit test project within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up unit testing in Visual Studio 2022
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first create a unit test project within Visual Studio.
    Once that is done, we’ll go through an overview of the **Test Explorer** view
    and its main options. The **Test Explorer** view serves as a central hub for all
    testing activities within the IDE, offering a comprehensive overview of our test
    suite’s status and performance. It allows us to easily navigate through test results,
    identify failures, and access detailed information about each test case.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio and .NET support three testing frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MSTest** : This is the default testing framework provided by Microsoft for
    .NET applications. It’s fully integrated into Visual Studio and offers features
    for writing and running tests within the IDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NUnit** : This is a popular open-source testing framework for .NET applications.
    It provides a flexible and extensible platform for writing and executing tests
    and is widely used in the . NET community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xUnit** : This is another open-source testing framework for .NET applications.
    It follows a more modern and flexible approach compared to MSTest and NUnit and
    is gaining popularity among . NET developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, you need to create a new project for your test set, in the solution
    containing the project we want to test. Right-click on your solution and select
    **Add** | **New Project...** . This will take you to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Adding a new test project](img/B22218_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Adding a new test project
  prefs: []
  type: TYPE_NORMAL
- en: I filtered this view by the three top dropdowns to keep displaying the template
    projects for testing available by default in Visual Studio. You may notice that
    the last two templates on the list mention **Playwright** . Playwright is a library
    that enables end-to-end testing for modern web apps. With it, you can create unit
    tests to assess the functionality of your user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Since xUnit is the most used framework in the industry, we will focus on it
    for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create your unit test project is by right-clicking directly
    on your class in your code base and selecting **Create Unit Tests** from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Selecting Create Unit Tests from the menu](img/B22218_01_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Selecting Create Unit Tests from the menu
  prefs: []
  type: TYPE_NORMAL
- en: 'This action will open a menu that allows you to configure your unit test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – The Create Unit Tests window](img/B22218_01_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – The Create Unit Tests window
  prefs: []
  type: TYPE_NORMAL
- en: By default, this allows you to create an MSTestv2 project, but you can install
    additional extensions to use other frameworks. If you already have a unit tests
    project created, you may add your test methods to it.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how you create them, all the tests in this project can be managed
    in the **Test Explorer** view and we will explore it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Test Explorer view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test Explorer serves as a powerful and centralized tool in Visual Studio 2022,
    facilitating the management and execution of unit tests. This feature-rich window
    allows developers to seamlessly view, organize, and run their unit tests within
    the **Integrated Development** **Environment** ( **IDE** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'To access Test Explorer, there are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: You can navigate to the **Test** menu in Visual Studio or utilize the convenient
    keyboard shortcut accessed by pressing *Ctrl* + *E* , releasing them, and then
    pressing *T* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since version 17.6, you can use the **all-in-one search** feature to quickly
    access all the features provided by Visual Studio. Simply open an all-in-one search
    using the *Ctrl* + *Q* shortcut, type **Test Explorer** , then press *Enter* ,
    and you’ll be directed to the **Test** **Explorer** window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a visualization of the **Test** **Explorer** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – The Test Explorer window](img/B22218_01_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – The Test Explorer window
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Test Explorer** console provides a clear and organized view of all available
    tests, making it easy for developers to navigate through their test suites. This
    interface offers advanced functionality for test management, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Categorize and group tests** : Utilize attributes and categories to group
    tests based on functional areas, features, or specific requirements. This helps
    in creating a logical hierarchy and makes it easier to focus on specific subsets
    of tests. By default, tests are grouped based on **Project** , followed by **Namespace**
    , and then **Class** . If you wish to modify the organization of your tests, simply
    click on the **Group By** button in Test Explorer and choose a new grouping criterion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.6 – Test Explorer – Group By](img/B22218_01_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Test Explorer – Group By
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the description of the groups you can choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration** : Groups tests by execution time: **Fast** , **Medium** , and
    **Slow**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State** : Groups tests by execution results: **Failed Tests** , **Skipped
    Tests** , **Passed Tests** , and **Not Run**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Framework** : Groups tests by the framework their projects’ target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace** : Groups tests by the containing namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project** : Groups tests by the containing project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** : Groups tests by the containing class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering and searching** : With a large code base, locating specific tests
    can be challenging. Test Explorer offers filtering options and a powerful search
    functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Test Explorer – applying a search filter](img/B22218_01_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Test Explorer – applying a search filter
  prefs: []
  type: TYPE_NORMAL
- en: You can enter a command in the textbox, such as **Namespace:""** or any other
    filter criteria you wish to use for your search. Additionally, you can directly
    click on the provided command to initiate your filtering.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a playlist** : You can create and manage playlists of tests in Visual
    Studio to organize and run specific sets of tests. To create a playlist, select
    one or more tests in Test Explorer, right-click, and choose **Add to Playlist**
    | **New Playlist** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Test Explorer – Add to Playlist](img/B22218_01_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Test Explorer – Add to Playlist
  prefs: []
  type: TYPE_NORMAL
- en: The playlist opens in a new **Test Explorer** tab, where you can save it with
    a name and location. You can edit playlists by adding or removing tests, and you
    can use the **Edit** button to manage tests more conveniently with checkboxes.
    Playlists can be dynamic, and automatically updated based on the tests included
    or excluded. They can be saved as XML files and edited manually if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have had an overview of the **Test Explorer** view, let’s explore a preview
    functionality of Visual Studio 2022 and create a test using it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test with IntelliTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, our goal is to explore how to use IntelliTest for creating
    tests. For that, we will first learn how to enable the IntelliTest functionality.
    Next, we will learn how to execute it and generate tests with it. At the end of
    the section, we will learn how to organize our generated unit tests by saving,
    executing, and reviewing them.
  prefs: []
  type: TYPE_NORMAL
- en: IntelliTest offers characterization tests, allowing you to understand how code
    behaves through a suite of traditional unit tests. This suite can serve as a regression
    suite, aiding in handling the challenges of refactoring legacy or unfamiliar code.
  prefs: []
  type: TYPE_NORMAL
- en: Through guided test input generation, IntelliTest employs an open-code analysis
    and constraint-solving approach to automatically produce precise test input values,
    often without requiring user intervention. It generates factories for complex
    object types and allows customization of these factories to meet specific requirements.
    Assertions specified as correctness properties in the code are utilized to further
    direct test input generation.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated seamlessly into the Visual Studio IDE, IntelliTest provides a cohesive
    environment for test suite generation. Information gathered during test suite
    creation, including automatically generated inputs, code outputs, and generated
    test cases, as well as their pass or fail statuses, is readily available within
    Visual Studio. This integration enables easy iteration between code refinement
    and IntelliTest reruns without leaving the IDE. Test results can be saved as a
    unit test project within the solution and are automatically recognized by Visual
    Studio Test Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'IntelliTest is available in Visual Studio Enterprise Edition. It systematically
    explores the code base, generating test data and unit tests for each method to
    ensure comprehensive code coverage and validate code behavior. As of the time
    of writing, IntelliTest is a preview feature in Visual Studio 17.9, so you must
    enable it from the **Options** menu by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Tools** | **Options** | **Manage** **Preview Features** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **IntelliTest support for NetFx and Net6 using Z3 v4** option under
    **Preview Features** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Enable Preview Features – Intellitest](img/B22218_01_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Enable Preview Features – Intellitest
  prefs: []
  type: TYPE_NORMAL
- en: 'Once enabled, we can explore how IntelliTest works. For example, I’ve created
    a public class implementing **FizzBuzz** . To generate tests with IntelliTest
    for the class, right-click on the class name, find the **IntelliTest (Preview)**
    option, and then select **Generate Tests** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – IntelliTest – Generate Tests](img/B22218_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – IntelliTest – Generate Tests
  prefs: []
  type: TYPE_NORMAL
- en: IntelliTest execution and test generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliTest executes our code multiple times using various inputs. Each execution
    is documented in a table, displaying the input test data along with the corresponding
    output or any exceptions that occur.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Generating tests with IntelliTest](img/B22218_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Generating tests with IntelliTest
  prefs: []
  type: TYPE_NORMAL
- en: After test generation, we can access the test project and examine the parameterized
    unit tests that have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: Saving, executing, and reviewing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We may choose the unit tests we want to keep and use the save option to save
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – IntelliTest’s save option](img/B22218_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – IntelliTest’s save option
  prefs: []
  type: TYPE_NORMAL
- en: The select box in the top-left corner of the window allows you to filter through
    all the methods of the class. The individual unit tests, associated with each
    row, are stored in the **.g.cs** file within the test project, while the parameterized
    unit test is stored in its respective **.** **cs** file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – IntelliTest – unit test project](img/B22218_01_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – IntelliTest – unit test project
  prefs: []
  type: TYPE_NORMAL
- en: We can execute these unit tests and review the outcomes using Test Explorer,
    just as we would handle manually created unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to classic unit tests, we can generate the project without running IntelliTest
    first by choosing the option in the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Using IntelliTest to generate tests from your code base is a valuable tool,
    especially for legacy projects and non-regression testing. Now, let’s move forward
    with a real-world example to illustrate how to implement TDD within Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing TDD with a real-world example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TDD, everything begins with the specification and a thorough understanding
    of the intended functionality. It’s essential to grasp the meaning of what we
    want to accomplish in order to write effective tests. With that in mind, let’s
    establish a scenario for our example.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a **ValidateMail** method that will process email verification.
    Our goal here is to explore the tools available in Visual Studio to enhance our
    TDD experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have outlined our requirements, our next step is to begin by creating
    our unit test project. For this, we’ll choose xUnit, as discussed earlier in this
    chapter. We will create an empty Class Library Project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by writing a test, in our xUnit project, that specifies the behavior
    or functionality we want to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we’ll notice when writing this code is that our test doesn’t
    compile because the **User** class doesn’t exist yet in our Class Library Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll leverage the power of IntelliSense to create our class and its method.
    IntelliSense is an integrated code completion tool within Visual Studio, offering
    various features such as List Members, Parameter Info, Quick Info, and Complete
    Word. These functionalities facilitate a deeper understanding of the code being
    utilized, assist in managing typed parameters, and enable the quick addition of
    calls to properties and methods with minimal keystrokes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place the cursor on the **User()** class and expand the IntelliSense menu,
    selecting the **Generate new type…** quick action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Generate new type...](img/B22218_01_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Generate new type...
  prefs: []
  type: TYPE_NORMAL
- en: This will open a window where we can choose the accessibility ( **Default**
    , **Internal** , or **Public** ), the kind ( **Class** or **Struct** ), the project,
    and whether to create a new file or use an existing one. Since we selected our
    Class Library project, the accessibility of our new class is obviously set to
    **Public** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.15 – The Generate Type window](img/B22218_01_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.15 – The Generate Type window
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the same way, we will use IntelliSense to create our **ValidateMail()**
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.16 – Generate method ValidateMail’](img/B22218_01_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.16 – Generate method ValidateMail’
  prefs: []
  type: TYPE_NORMAL
- en: With that done, our test is built, but it still fails because we have yet to
    fix its behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s our **User** class with the minimum amount of code to make our test
    pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a **ValidateMail** method returning **true** that should respect
    the specification of our test.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the quick access feature, above your method, to run the unit test
    without going to the **Test** **Explorer** view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17 – Using the quick access tool to run a test](img/B22218_01_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.17 – Using the quick access tool to run a test
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we are; our first test is green. We can write the second testing class
    that will handle the cases where our **ValidateMail()** must return **false**
    . For that, we will use the **Theory** and **InlineData** xUnit attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are up for another iteration, from red to green. Here’s the method with
    the minimum amount of code to make the unit test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are checking each condition of our test method, with one **If** for
    each test to make it pass.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our approach maintains a naïve and simple perspective. Now,
    it’s time to enter the refactor phase of our TDD process. For that, we will explore
    a feature of Visual Studio named Live Unit Test.
  prefs: []
  type: TYPE_NORMAL
- en: Automating your tests with Live Unit Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the capabilities of automating testing with
    Live Unit Test. First, we will learn how to configure Live Unit Testing. Then,
    we will see how to launch it
  prefs: []
  type: TYPE_NORMAL
- en: Live Unit Testing revolutionizes the testing process by automatically executing
    unit tests in real-time as you make code changes. This dynamic feature provides
    developers with the ability to refactor and modify code with increased confidence.
    By automatically running all affected tests during code editing, Live Unit Testing
    ensures that any changes made do not introduce regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Live Unit Testing offers insights into the adequacy of test coverage
    for your code base. It visually presents code coverage in real-time, allowing
    developers to quickly identify areas where tests are lacking.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s activate this feature by navigating to **Test** | **Live Unit Testing**
    | **Start** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Start Live Unit Testing](img/B22218_01_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – Start Live Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: 'When you launch Live Unit Testing for the first time, the configuration window
    will open up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Configure Live Unit Testing](img/B22218_01_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Configure Live Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Live Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Live Unit Testing is deactivated, you can access the setup wizard by navigating
    to **Test** | **Live Unit Testing** | **Configure Live** **Unit Testing** .
  prefs: []
  type: TYPE_NORMAL
- en: During a Live Unit Testing operation, a workspace — a duplicate of the original
    repository — is established. Any modifications made in Visual Studio that are
    not yet saved are integrated into this workspace. Subsequently, Live Unit Testing
    initiates a build, conducts a test run, and furnishes the latest code coverage
    report.
  prefs: []
  type: TYPE_NORMAL
- en: The initial setup in the wizard should address file copying origins and destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand more about the settings in this wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repository root** : This is the main folder that contains all the necessary
    files for Live Unit Testing. It should include all the source code, binaries,
    and tools required for testing. If the solution file is not located within this
    root folder, adjustments may need to be made to ensure proper setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workspace folder** : This (set, by default, to **lut** for Live Unit Testing)
    is where Live Unit Testing stores a copy of the repository. By default, this root
    is created in the user’s home folder, but it can be customized based on preference
    or specific requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Excluded files** : Exclude generated artifacts from being copied to the Live
    Unit Testing workspace to prevent interference with regular builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build options** : By default, Live Unit Testing utilizes multiple CPU cores
    for faster builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test case timeout** : This allows setting a specific time duration, after
    which tests are automatically aborted if they exceed the allotted time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use multiple processors** : By default, Live Unit Testing attempts to utilize
    multiple processors for faster test execution. However, deselect this option if
    your machine experiences slowdowns or if parallel test execution causes issues,
    such as file conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we select **<custom>** for the **Excluded** files, we can define our own
    rules. The setup wizard will bring us to the **lutignore** file editor without
    default values filled in.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Configure lutignore file](img/B22218_01_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Configure lutignore file
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get an overview of the **lutignore** file structure according to the Microsoft
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **lutignore** file follows the same format as a **gitignore** file. It
    should include rules that correspond to folders or files created during the build
    process, ensuring they are not copied into the workspace for Live Unit Testing.
    For most default project templates, the provided **lutignore** file is adequate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: These rules prevent the copying of any **BIN** or **OBJ** folders to the Live
    Unit Testing workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your repository has a single build folder, specify that folder in the **ignore**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This rule ensures that the **ARTIFACTS** folder is not copied to the Live Unit
    Testing workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where your repository contains additional tools within the build folder,
    those tools should also be excluded using matching patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first rule excludes the **ARTIFACTS** folder. The second ensures that the
    **TOOLS** subfolder within **ARTIFACTS** is copied, which may contain necessary
    tools and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Live Unit Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have configured Live Unit Testing, it is open and awaiting a playlist
    of tests to run.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21 – Live Unit Testing console](img/B22218_01_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Live Unit Testing console
  prefs: []
  type: TYPE_NORMAL
- en: Use the pen icon to add your set of tests. Alternatively, you can add all your
    tests by clicking on the link at the bottom of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our previous example and our **ValidateMail()** function, you can
    see green checkmarks on the left side of our code lines. These indicate that the
    code is covered by passing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22 – Live Unit Testing checkmarks](img/B22218_01_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – Live Unit Testing checkmarks
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can proceed to the refactoring step of our TDD iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will concatenate all the conditions and intentionally let the tests
    fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we update the document, Live Unit Testing automatically rebuilds and updates
    the test status indicators, changing checkmarks to red crosses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23 – Live unit test red crosses](img/B22218_01_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23 – Live unit test red crosses
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can fix our code and the checkmarks will appear automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the process is very smooth, but in a larger code base with more
    unit tests, they may not have finished running while we have already made changes
    to the code. For this issue, you have an option in the top-level menu of Visual
    Studio: **Tools** | **Options** | **Live Unit Testing** | **General** .'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24 – Additional configuration – Live Unit Testing](img/B22218_01_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24 – Additional configuration – Live Unit Testing
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this window, you can customize your Live Unit Testing experience according
    to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that Live Unit Testing offers a quick visualization of our code coverage.
    You can access a deeper analysis of the coverage of your code base in Visual Studio
    by navigating to the **Test** menu and selecting **Analyze Code Coverage for All
    Tests** . For more information, you can consult the Microsoft documentation at
    [https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp](https://learn.microsoft.com/en-us/visualstudio/test/using-code-coverage-to-determine-how-much-code-is-being-tested?view=vs-2022&tabs=csharp)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the importance of unit testing as a non-regression
    or development process. We began with a reminder of good unit testing practices
    and TDD before exploring the functionalities offered by Visual Studio 2022 to
    enhance our productivity.
  prefs: []
  type: TYPE_NORMAL
- en: We provided an overview of the **Test Explorer** view, demonstrating how to
    manage and organize unit tests. Then, we delved into the new IntelliSense feature,
    which provides tools to easily add non-regression tests to legacy code bases with
    minimal effort, freeing our minds for future refactoring. Finally, we learned
    how to leverage IntelliSense tools and Live Unit Testing to facilitate our TDD
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the world of debugging and explore
    all that Visual Studio 2022 offers for advanced strategies.
  prefs: []
  type: TYPE_NORMAL
