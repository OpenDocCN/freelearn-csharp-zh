<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Lighting Models</h1>
                
            
            <article>
                
<p class="calibre3">In the previous chapters, we introduced Surface Shaders and explained how we can change physical properties (such as Albedo and Specular) to simulate different materials. How does this really work? At the heart of every Surface Shader, there is its <strong class="calibre5">lighting model</strong>. It's the function that takes these properties and calculates the final shade of each pixel. Unity usually hides this from the developers because in order to write a lighting model, you have to understand how light reflects and refracts onto surfaces. This chapter will finally show you how lighting models work and give you the basics to create your own.</p>
<p class="calibre3">In this chapter, you will learn the following recipes:</p>
<ul class="calibre11">
<li class="calibre12">Creating a custom diffuse lighting model</li>
<li class="calibre12">Creating a toon shader</li>
<li class="calibre12">Creating a Phong Specular type</li>
<li class="calibre12">Creating a BlinnPhong Specular type</li>
<li class="calibre12">Creating an Anisotropic Specular type</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            <article>
                
<p class="calibre3">Simulating the way light works is a very challenging and resource-consuming task. For many years, video games have used very simple lighting models which, despite lacking realism, were very believable. Even if most 3D engines are now using physically-based renderers, it is worth exploring some simpler techniques. The ones presented in this chapter are reasonably realistic and widely adopted on devices with low resources such as mobile phones. Understanding these simple lighting models is also essential if you want to create your own.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a custom diffuse lighting model</h1>
                
            
            <article>
                
<p class="calibre3">If you are familiar with Unity 4, you may know that the default shader it provided was based on a lighting model called <strong class="calibre5">Lambertian reflectance</strong>. This recipe will show you how it is possible to create a shader with a custom lighting model and explains the mathematics<strong class="calibre5"> </strong>involved and implementation. The following diagram shows the same geometry rendered with a Standard Shader (right) and a diffuse Lambert one (left):</p>
<div class="cdpaligncenter"><img src="../images/00078.jpeg" class="calibre25"/></div>
<p class="calibre3">Shaders based on Lambertian reflectance are classified as non-photorealistic; no object in the real world really looks like this. However, Lambert Shaders are still often used in low-poly games as they produce a neat contrast between the faces of complex geometries. The lighting model used to calculate the Lambertian reflectance is also very efficient, making it perfect for mobile games.</p>
<p class="calibre3">Unity has already provided us with a lighting function that we can use for our shaders. It is called the Lambertian lighting model. It is one of the more basic and efficient forms of reflectance, which you can find in a lot of games even today. As it is already built in the Unity Surface Shader language, we thought it best to start with this first and build on it. You can also find an example in the Unity reference manual, but we will go into more depth and explain where the data is coming from and why it is working the way it is. This will help you get a nice grounding in setting up custom lighting models so that we can build on this knowledge in the future recipes in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Let's start by carrying out the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader and give it a name (<kbd class="calibre13">SimpleLambert</kbd>).</li>
<li value="2" class="calibre12">Create a new material, give it a name <span>(</span><kbd class="calibre13">SimpleLambertMat</kbd><span>)</span>, and assign the new shader to its <kbd class="calibre13">shader</kbd> property.</li>
<li value="3" class="calibre12">Then, create a sphere object and place it roughly in the center of the scene and attach the new material to it.</li>
<li value="4" class="calibre12">Finally, let's create a directional light to cast some light on our object if one isn't created already.</li>
<li class="calibre12" value="5">When your assets have been set up in Unity, you should have a scene that resembles the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00079.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">The Lambertian reflectance can be achieved with the following changes to the shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Begin by replacing <span>the shader's </span><kbd class="calibre13">Properties</kbd><span> block with the </span>following :</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _MainTex("Texture", 2D) = "white" <br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Since we are removing all of the other properties, remove the <kbd class="calibre13">_Glossiness</kbd>, <kbd class="calibre13">_Metallic</kbd>, and <kbd class="calibre13">_Color</kbd> declarations inside of the <kbd class="calibre13">SubShader</kbd> section.</li>
<li value="3" class="calibre12">Change the <kbd class="calibre13">#pragma</kbd> directive of the shader so that, instead of <kbd class="calibre13">Standard</kbd>, it uses our custom lighting model:</li>
</ol>
<pre class="calibre18">#pragma surface surf SimpleLambert  </pre>
<div class="packt_infobox">If you try to run the script now, it will complain that it doesn't know what the <kbd class="calibre37">SimpleLambert</kbd> lighting model is. We will need to create a function called <kbd class="calibre37">Lighting</kbd>  + the name that we gave here with instructions on how to light the object, which we will be writing later on in this recipe. In this case, it would be <kbd class="calibre37">LightingSimpleLambert</kbd>.</div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Use a very simple surface function, which just samples the texture according to its UV data:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutput o) { 
  o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb; 
} </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Add a function called <kbd class="calibre13">LightingSimpleLambert()</kbd> that will contain the following code for the Lambertian reflectance:</li>
</ol>
<pre class="calibre18">// Allows us to use the SimpleLambert lighting mode<br class="title-page-name"/>half4 LightingSimpleLambert (SurfaceOutput s, half3 lightDir, <br class="title-page-name"/>                             half atten) <br class="title-page-name"/>{ <br class="title-page-name"/>  // First calculate the dot product of the light direction and the <br class="title-page-name"/>  // surface's normal<br class="title-page-name"/>  half NdotL = dot(s.Normal, lightDir); <br class="title-page-name"/><br class="title-page-name"/>  // Next, set what color should be returned<br class="title-page-name"/>  half4 color; <br class="title-page-name"/><br class="title-page-name"/>  color.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten); <br class="title-page-name"/>  color.a = s.Alpha; <br class="title-page-name"/><br class="title-page-name"/>  // Return the calculated color<br class="title-page-name"/>  return color; <br class="title-page-name"/>} </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Save your script and return to the Unity editor. You should notice that it looks somewhat different than what was there before:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00080.jpeg" class="calibre25"/></div>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">The effect is even easier to see if we use the cylinders we used in the previous chapter, <a href="part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 3</a>, <em class="calibre2">Surface Shaders and Texture Mapping</em>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00081.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">As previously seen in <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 2</span></a>, <em class="calibre14">Creating Your First Shader</em>, the <kbd class="calibre13">#pragma</kbd> directive is used to specify which surface function to use. Choosing a different lighting model works in a similar fashion: <kbd class="calibre13">SimpleLambert</kbd> forces Cg to look for a function called <kbd class="calibre13">LightingSimpleLambert()</kbd>. Note the <kbd class="calibre13">Lighting</kbd> at the beginning, which is omitted in the directive.</p>
<p class="calibre3">The <kbd class="calibre13">Lighting</kbd> function takes three parameters: the <em class="calibre14">surface output</em> (which contains the physical properties such as the albedo and transparency), the <em class="calibre14">direction</em> the light is coming from, and its <em class="calibre14">attenuation</em>.</p>
<p class="calibre3">According to Lambertian reflectance, the amount of light a surface reflects depends on the angle between the incident light and surface normal. If you have played pool billiards, you are surely familiar with this concept; the direction of a ball depends on its incident angle against the wall. If you hit a wall at a 90 degree angle, the ball will come back at you; if you hit it with a very low angle, its direction will be mostly unchanged. The Lambertian model makes the same assumption; if the light hits a triangle at a 90 degree angle, all the light gets reflected back. The lower the angle, the less light is reflected back to you. This concept is shown in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00082.jpeg" class="calibre25"/></div>
<p class="calibre3">This simple concept has to be translated into a mathematical form. In vector algebra, the angle between two unit vectors can be calculated via an operator called <strong class="calibre5">dot product</strong>. When the dot product is equal to zero, two vectors are orthogonal, which means that they make a 90-degree angle. When it is equal to one (or minus one), they are parallel to each other. Cg has a function called <kbd class="calibre13">dot()</kbd>, which implements the dot product extremely efficiently.</p>
<p class="calibre3">The following diagram shows a light source (sun) shining on a complex surface. <strong class="calibre5">L</strong> indicates the light direction (called <kbd class="calibre13">lightDir</kbd> in the shader) and <strong class="calibre5">N</strong> is the normal to the surface. The light is reflected with the same angle that it hits the surface with:</p>
<div class="cdpaligncenter"><img src="../images/00083.jpeg" class="calibre89"/></div>
<div class="packt_infobox">For more information on normals and what they mean mathematically check out: <a href="https://en.wikipedia.org/wiki/Normal_(geometry)" class="calibre31">https://en.wikipedia.org/wiki/Normal_(geometry)</a></div>
<p class="calibre3">Lambertian reflectance simply uses the <kbd class="calibre13">NdotL</kbd> dot product as a multiplicative coefficient for the intensity of light:</p>
<div class="mce-root1"><img src="../images/00084.gif" class="calibre90"/></div>
<p class="calibre3">When <em class="calibre14">N</em> and <em class="calibre14">L</em> are parallel, all the light is reflected back to the source, causing the geometry to appear brighter. The <kbd class="calibre13">_LightColor0</kbd> variable contains the color of the light that is calculated.</p>
<div class="packt_infobox"><span class="calibre27">Prior to Unity 5, the intensity of the lights was different. If you are using an old diffuse shader based on the Lambertian model, you may notice that </span><kbd class="calibre37">NdotL</kbd><span class="calibre27"> is multiplied by two: </span><kbd class="calibre37">(NdotL * atten * 2)</kbd><span class="calibre27">, rather than </span><kbd class="calibre37">(NdotL * atten)</kbd><span class="calibre27">. If you are importing a custom shader from Unity 4, you will need to correct this manually. Legacy Shaders, however, have already been designed taking this aspect into account.</span></div>
<p class="calibre3">When the dot product is negative, the light is coming from the opposite side of the triangle. This is not a problem for opaque geometries as triangles that are not facing the camera frontally are culled (discarded) and not rendered.</p>
<p class="calibre3">This basic Lambert is a great starting point when you are prototyping your shaders as you can get a lot accomplished in terms of writing the core functionality of the shader while not having to worry about the basic <kbd class="calibre13">Lighting</kbd> functions.</p>
<p class="calibre3">Unity has provided us with a lighting model that has already taken the task of creating a Lambert lighting for you. If you look at the <kbd class="calibre13">UnityCG.cginc</kbd> file found in your Unity's installation directory under the <kbd class="calibre13">Data</kbd> folder, you will notice that you have Lambert and BlinnPhong lighting models available for you to use. The moment you compile your shader with <kbd class="calibre13">#pragma surface surf Lambert</kbd>, you are telling the shader to utilize Unity's implementation of the Lambert <kbd class="calibre13">Lighting</kbd> function in the <kbd class="calibre13">UnityCG.cginc</kbd> file so that you don't have to write that code over and over again. We will explore how the BlinnPhong model works later in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a toon shader</h1>
                
            
            <article>
                
<p class="calibre3">One of the most used effects in games is <strong class="calibre5">toon shading</strong>, which is also known as <strong class="calibre5">celluloid</strong> (<strong class="calibre5">CEL</strong>) shading. It is a non-photorealistic rendering technique that makes 3D models appear flat. Many games use it to give the illusion that the graphics are being hand-drawn rather than being 3D modeled. You can see, in the following diagram, a sphere rendered with a toon Shader (left) and a <span class="calibre6">Standard Shader (right):</span></p>
<div class="cdpaligncenter"><img src="../images/00085.jpeg" class="calibre91"/></div>
<p class="calibre3">Achieving this effect using just surface functions is not impossible, but it would be extremely expensive and time consuming. The surface function, in fact, only works on the properties of the material, not its actual lighting condition. As toon shading requires us to change the way light reflects, we need to create our custom lighting model instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Let's start this recipe by creating a shader and its material and importing a special texture, as follows:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Start by creating a new shader; in this example, we will duplicate the one made in the previous recipe by selecting it in the <span>Project</span> tab and then hit <em class="calibre2">Ctrl </em>+ <em class="calibre2">D</em>. We will change the name of this new <kbd class="calibre13">shader</kbd> to <kbd class="calibre13">ToonShader</kbd>.</li>
</ol>
<div class="packt_tip2">You can rename an object in the <span class="calibre27">Project</span> window by single-clicking on the name.</div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Create a new material for the shader (<kbd class="calibre13">ToonShaderMat</kbd>) and attach it to a 3D model. Toon shading works best on curved surfaces.</li>
<li value="3" class="calibre12">This recipe requires an additional texture called a <strong class="calibre1">ramp map</strong>,<strong class="calibre1"> </strong>which will be used to dictate when we want to use certain colors depending on the shade received:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00086.jpeg" class="calibre25"/></div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">This book has an example texture in <kbd class="calibre13">Chapter 4</kbd> | <kbd class="calibre13">Textures</kbd> folder. If you decide to import your own, it is important that you select your next texture and, from the <span>Inspector</span> tab, change the ramp map's <span>Wrap Mode</span> to <span>Clamp</span>. If you want the edges between the colors to be sharp, the <span>Filter Mode</span> should also be set to <span>Point</span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00087.jpeg" class="calibre25"/></div>
<div class="packt_infobox"><span class="calibre27">The example project included with this book already has this step completed in the <kbd class="calibre37">Assets </kbd></span>| <span class="calibre27"><kbd class="calibre37">Chapter 4 </kbd></span>| <span class="calibre27"><kbd class="calibre37">Texture </kbd></span>| <span class="calibre27"><kbd class="calibre37">ToonRamp</kbd> file, but it is a good idea to verify that this is the case before moving forward. </span> </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">The toon aesthetic can be achieved with the following changes to the shader:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Add a new property for a texture called <kbd class="calibre13">_RampTex</kbd>:</li>
</ol>
<pre class="calibre18">_RampTex ("Ramp", 2D) = "white" {} </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Add its relative variable in the <kbd class="calibre13">CGPROGRAM</kbd> section:</li>
</ol>
<pre class="calibre18">sampler2D _RampTex; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Change the <kbd class="calibre13">#pragma</kbd> directive so that it points to a function called <kbd class="calibre13">LightingToon()</kbd>:</li>
</ol>
<pre class="calibre18">#pragma surface surf Toon </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Replace the <kbd class="calibre13">LightingSimpleLambert</kbd> function with the following function instead:</li>
</ol>
<pre class="calibre18">fixed4 LightingToon (SurfaceOutput s, fixed3 lightDir, <br class="title-page-name"/>            fixed atten) <br class="title-page-name"/>{ <br class="title-page-name"/>  // First calculate the dot product of the light direction and the <br class="title-page-name"/>  // surface's normal<br class="title-page-name"/>  half NdotL = dot(s.Normal, lightDir); <br class="title-page-name"/>      <br class="title-page-name"/>  // Remap NdotL to the value on the ramp map<br class="title-page-name"/>  NdotL = tex2D(_RampTex, fixed2(NdotL, 0.5)); <br class="title-page-name"/> <br class="title-page-name"/>  // Next, set what color should be returned<br class="title-page-name"/>  half4 color; <br class="title-page-name"/><br class="title-page-name"/>  color.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten ); <br class="title-page-name"/>  color.a = s.Alpha; <br class="title-page-name"/><br class="title-page-name"/>  // Return the calculated color<br class="title-page-name"/>  return color; <br class="title-page-name"/>} </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Save the script, open up the <kbd class="calibre13">ToonShaderMat</kbd>, and assign the <kbd class="calibre13">Ramp</kbd> property to your ramp map. If all goes well, you should see something like the following in your scene:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00088.jpeg" class="calibre92"/></div>
<div class="packt_tip">This effect may be modified by the lighting in the scene. You can change the illumination of the scene by going to <span class="calibre27">Window </span>| <span class="calibre27">Lighting </span>| <span class="calibre27">Settings</span> and changing the <span class="calibre27">Environment </span>| <span class="calibre27">Environment Lighting </span>| <span class="calibre27">Intensity Multiplier</span> property to <kbd class="calibre37">0</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">The main characteristic of toon shading is the way the light is rendered; surfaces are not shaded uniformly. To achieve this effect, we need a ramp map. Its purpose is to remap the Lambertian light intensity <kbd class="calibre13">NdotL</kbd> to another value. Using a ramp map without a gradient, we can force the lighting to be rendered in steps. The following diagram shows how the ramp map is used to correct the light intensity:</p>
<div class="cdpaligncenter"><img src="../images/00089.jpeg" class="calibre93"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more...</h1>
                
            
            <article>
                
<p class="calibre3">There are many different ways whereby you can achieve a toon shading effect. Using different ramps can produce dramatic changes in the way your models look, so you should experiment in order to find the best one.</p>
<p class="calibre3">An alternative to ramp textures is to <strong class="calibre5">snap</strong> the light intensity <kbd class="calibre13">NdotL</kbd> so that it can only assume a certain number of values equidistantly sampled from <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd>:</p>
<pre class="calibre19">half4 LightingCustomLambert (SurfaceOutput s, half3 lightDir, <br class="title-page-name"/>                half3 viewDir, half atten) <br class="title-page-name"/>{ <br class="title-page-name"/>  half NdotL = dot (s.Normal, lightDir); <br class="title-page-name"/><br class="title-page-name"/>  // Snap instead<br class="title-page-name"/>  half cel = floor(NdotL * _CelShadingLevels) / <br class="title-page-name"/>             (_CelShadingLevels - 0.5); <br class="title-page-name"/><br class="title-page-name"/>  // Next, set what color should be returned<br class="title-page-name"/>  half4 color; <br class="title-page-name"/><br class="title-page-name"/>  color.rgb = s.Albedo * _LightColor0.rgb * (cel * atten ); <br class="title-page-name"/>  color.a = s.Alpha; <br class="title-page-name"/><br class="title-page-name"/>  // Return the calculated color<br class="title-page-name"/>  return color; <br class="title-page-name"/>} </pre>
<p class="calibre3">To snap a number we first multiply <kbd class="calibre13">NdotL</kbd> by the <kbd class="calibre13">_CelShadingLevels</kbd> variable,  round the result to an integer through the <kbd class="calibre13">floor</kbd> function, and then divides it back. This rounding is done by the <kbd class="calibre13">floor</kbd> function which will effectively remove the decimal point from a number. By doing this, the <kbd class="calibre13">cel</kbd> quantity is forced to assume one of the <kbd class="calibre13">_CelShadingLevels</kbd> equidistant values from <kbd class="calibre13">0</kbd> to <kbd class="calibre13">1</kbd>. This removes the need for a ramp texture and makes all the color steps of the same size. If you are going for this implementation, remember to add a property called <kbd class="calibre13">_CelShadingLevels</kbd> to your shader. You can find an example of this in the example code for this chapter. Try dragging the <span class="calibre6">Levels</span> property to see how it affects how the screenshot is shown:</p>
<div class="cdpaligncenter"><img src="../images/00090.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a Phong Specular type</h1>
                
            
            <article>
                
<p class="calibre3">The specularity of an object surface simply describes how shiny it is. These types of effects are often referred to as view-dependent effects in the shader world. This is because, in order to achieve a realistic Specular effect in your shaders, you need to include the direction of the camera or the user facing the object's surface. The most basic and performance-friendly Specular type is the Phong Specular effect. It is the calculation of the light direction reflecting off of the surface compared to the user's view direction. It is a very common Specular model used in many applications, from games to movies. While it isn't the most realistic in terms of accurately modeling the reflected Specular, it gives a great approximation of what is expected of shininess that performs well in most situations. Additionally, if your object is further away from the camera and there is no need for a very accurate Specular, this is a great way to provide a Specular effect to your shaders.</p>
<p class="calibre3">In this recipe, we will be covering how to implement the per-vertex version of the shader and also the per-pixel version using some new parameters in the Surface Shader's <kbd class="calibre13">Input</kbd> struct. We will see the difference and discuss when and why to use these two different implementations for different situations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">To start with this recipe, perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new shader (<kbd class="calibre13">Phong</kbd>), material(<kbd class="calibre13">PhongMat</kbd>), and a new scene with a sphere in it with a <span>Plane</span> underneath it (<span>GameObject</span> | <span>3D Objects </span>| <span>Plane</span>).</li>
<li value="2" class="calibre12">Attach the shader to the material and the material to the object. To finish off your new scene, create a new directional light if one is not there already, so that you can see your Specular effect as you code it:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00091.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">Follow these steps to create a Phong lighting model:</p>
<ol class="calibre15">
<li value="1" class="calibre12">You might be seeing a pattern at this point, but we always like to start out with our most basic part of the shader writing process: the creation of properties. So, let's remove all of the current properties with their definitions in the <kbd class="calibre13">SubShader</kbd> block and then add the following properties to the shader:</li>
</ol>
<pre class="calibre62">Properties 
{ 
  _MainTint ("Diffuse Tint", Color) = (1,1,1,1) 
  _MainTex ("Base (RGB)", 2D) = "white" {} 
  _SpecularColor ("Specular Color", Color) = (1,1,1,1) 
  _SpecPower ("Specular Power", Range(0,30)) = 1 
} </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We then have to make sure to add the corresponding variables to our <kbd class="calibre13">CGPROGRAM</kbd> block in our <kbd class="calibre13">SubShader{}</kbd> block:</li>
</ol>
<pre class="calibre62">float4 _SpecularColor; 
sampler2D _MainTex; 
float4 _MainTint; 
float _SpecPower; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Now, we have to add our custom lighting model so that we can compute our own Phong Specular. Don't worry if it doesn't make sense at this point; we will cover each line of code in the <em class="calibre2">How it works...</em> section of this recipe. Add the following code to the shader's <kbd class="calibre13">SubShader{}</kbd> function:</li>
</ol>
<pre class="calibre62">fixed4 LightingPhong (SurfaceOutput s, fixed3 lightDir, <br class="title-page-name"/>                      half3 viewDir, fixed atten) 
{ 
  // Reflection 
  float NdotL = dot(s.Normal, lightDir); 
  float3 reflectionVector = normalize(2.0 * s.Normal * <br class="title-page-name"/>     NdotL - lightDir); 
 
  // Specular 
  float spec = pow(max(0, dot(reflectionVector, viewDir)), <br class="title-page-name"/>     _SpecPower); 
  float3 finalSpec = _SpecularColor.rgb * spec; 
 
  // Final effect 
  fixed4 c; 
  c.rgb = (s.Albedo * _LightColor0.rgb * max(0,NdotL) * <br class="title-page-name"/>     atten) + (_LightColor0.rgb * finalSpec); 
  c.a = s.Alpha; 
  return c; 
} </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Next, we have to tell the <kbd class="calibre13">CGPROGRAM</kbd> block that it needs to use our custom Lighting function instead of one of the built-in ones. We do this by changing the <kbd class="calibre13">#pragma</kbd> statement to the following:</li>
</ol>
<pre class="calibre62">CGPROGRAM 
#pragma surface surf Phong </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Finally, let's update the <kbd class="calibre13">surf</kbd> function to the following:</li>
</ol>
<pre class="calibre62">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/> half4 c = tex2D (_MainTex, IN.uv_MainTex) * _MainTint;<br class="title-page-name"/> o.Albedo = c.rgb;<br class="title-page-name"/> o.Alpha = c.a;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">The following screenshot demonstrates the result of our custom Phong lighting model using our own custom reflection vector:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00092.jpeg" class="calibre25"/></div>
<div class="packt_tip">Try changing the <span class="calibre27">Specular Power</span> property and notice the effect that you see.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Let's break down the Lighting function by itself, as the rest of the shader should be pretty familiar to you at this point.</p>
<p class="calibre3">In the previous recipes, we have used a Lighting function that provided only the light direction, <kbd class="calibre13">lightDir</kbd>.</p>
<p class="calibre3">Unity comes with a set of Lighting functions that you can use, including one that provides the view direction, <kbd class="calibre13">viewDir</kbd>.</p>
<p class="calibre3">To figure out how to write your own custom lighting mode refer to the following table replacing NameYouChoose with the lighting function name you gave in the <kbd class="calibre13">#pragma</kbd> statement or go to <span class="calibre6"><a href="http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html" class="calibre10">http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html</a></span> for more details:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre46"><strong class="calibre1">Not view-dependent</strong></td>
<td class="calibre46"><kbd class="calibre13"><kbd class="calibre94">half4 LightingNameYouChoose</kbd> (<kbd class="calibre94">SurfaceOutput s</kbd>, <kbd class="calibre94">half3</kbd> <kbd class="calibre94">lightDir</kbd>, <kbd class="calibre94">half atten</kbd></kbd>);</td>
</tr>
<tr class="calibre45">
<td class="calibre46"><strong class="calibre1">View-dependent</strong></td>
<td class="calibre46"><kbd class="calibre13">half4 LightingNameYouChoose (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten);</kbd></td>
</tr>
</tbody>
</table>
<p class="calibre3"> </p>
<p class="calibre3">In our case, we are using a Specular shader, so we need to have the view-dependent <kbd class="calibre13">Lighting</kbd> function structure. We have to write the following:</p>
<pre class="calibre19">CPROGRAM 
#pragma surface surf Phong 
fixed4 LightingPhong (SurfaceOutput s, fixed3 lightDir, half3 viewDir, fixed atten) 
{ 
  // ... 
} </pre>
<p class="calibre3">This will tell the shader that we want to create our own view-dependent shader. Always make sure that your Lighting function name is the same in your <kbd class="calibre13">Lighting</kbd> function declaration and the <kbd class="calibre13">#pragma</kbd> statement, or Unity will not be able to find your lighting model.</p>
<p class="calibre3">The components that play a role in the <kbd class="calibre13">Phong</kbd> model are described in the following image. We have the light direction <strong class="calibre5">L</strong> (coupled with its perfect reflection <strong class="calibre5">R</strong>) and normal direction <strong class="calibre5">N</strong>. They have all been encountered before in the Lambertian model, with the exception of <strong class="calibre5">V</strong>, which is the <strong class="calibre5">view direction</strong>:</p>
<div class="cdpaligncenter"><img src="../images/00093.jpeg" class="calibre95"/></div>
<p class="calibre3">The <kbd class="calibre13">Phong</kbd> model assumes that the final light intensity of a reflective surface is given by two components, its diffuse color, and Specular value, as follows:</p>
<div class="mce-root1"><img src="../images/00094.gif" class="calibre25"/></div>
<p class="calibre3">The diffuse component <em class="calibre14">D</em> remains unchanged from the Lambertian model:</p>
<div class="mce-root1"><img src="../images/00095.gif" class="calibre25"/></div>
<p class="calibre3">The Specular component <em class="calibre14">S</em> is defined as follows:</p>
<div class="mce-root1"><img src="../images/00096.gif" class="calibre25"/></div>
<p class="calibre3">Here, <em class="calibre14">p</em> is the Specular power defined as <kbd class="calibre13">_SpecPower</kbd> in the shader. The only unknown parameter is <em class="calibre14">R</em>, which is the reflection of <em class="calibre14">L</em> according to <em class="calibre14">N</em>. In vector algebra, this can be calculated as follows:</p>
<div class="mce-root2"><img src="../images/00097.gif" class="calibre25"/></div>
<p class="calibre3">This is exactly what is calculated in the following:</p>
<pre class="calibre19">float3 reflectionVector = normalize(2.0 * s.Normal * NdotL - <br class="title-page-name"/>                                    lightDir);</pre>
<p class="calibre3">This has the effect of bending the normal towards the light; as a vertex, normal is pointing away from the light, it is forced to look at the light. Refer to the following diagram for a more visual representation. The script that produces this debug effect is included in this book's support page at <span class="calibre6"><a href="https://www.packtpub.com/books/content/support" class="calibre10">https://www.packtpub.com/books/content/support</a></span>:</p>
<div class="cdpaligncenter"><img src="../images/00098.jpeg" class="calibre96"/></div>
<p class="calibre3">The following diagram displays the final result of our Phong Specular calculation isolated in the shader:</p>
<div class="cdpaligncenter"><img src="../images/00099.jpeg" class="calibre97"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a BlinnPhong Specular type</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Blinn</strong> is another more efficient way of calculating and estimating specularity. It is done by getting the half vector from the view direction and light direction. It was brought into the world of Cg by Jim Blinn. He found that it was much more efficient to just get the half vector instead of calculating our own reflection vectors. It cut down on the code and processing time. If you actually look at the built-in BlinnPhong lighting model included in the <kbd class="calibre13">UnityCG.cginc</kbd> file, you will notice that it is using the half vector as well, hence it is named BlinnPhong. It is just a simpler version of the full Phong calculation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">To start with this recipe, perform the following steps:</p>
<ol class="calibre15">
<li value="1" class="calibre12">This time, instead of creating a whole new scene, let's just use the objects and scene that we have by using <span>File </span>| <span>Save Scene As...</span>, and create a new shader (BlinnPhong<span>) </span>and material (<kbd class="calibre13">BlinnPhongMat</kbd>):</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00100.jpeg" class="calibre98"/></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Once you have a new shader, double-click on it to launch your IDE of choice so that you can start editing your shader.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">Perform the following steps to create a BlinnPhong lighting model:</p>
<ol class="calibre15">
<li value="1" class="calibre12">First, <span>let's remove all of the current properties with their definitions in the <kbd class="calibre13">SubShader</kbd> block. Then</span> we need to add our own properties to the <kbd class="calibre13">Properties</kbd> block so that we can control the look of the Specular highlight:</li>
</ol>
<pre class="calibre62">Properties 
{ 
  _MainTint ("Diffuse Tint", Color) = (1,1,1,1) 
  _MainTex ("Base (RGB)", 2D) = "white" {} 
  _SpecularColor ("Specular Color", Color) = (1,1,1,1) 
  _SpecPower ("Specular Power", Range(0.1,60)) = 3 
} </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Then we need to make sure that we have created the corresponding variables in our <kbd class="calibre13">CGPROGRAM</kbd> block so that we can access the data from our <kbd class="calibre13">Properties</kbd> block, in our subshader:</li>
</ol>
<pre class="calibre62">sampler2D _MainTex; 
float4 _MainTint; 
float4 _SpecularColor; 
float _SpecPower; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Now it's time to create our custom lighting model that will process our Diffuse and Specular calculations. The code is as follows:</li>
</ol>
<pre class="calibre62">fixed4 LightingCustomBlinnPhong (SurfaceOutput s, <br class="title-page-name"/>                  fixed3 lightDir, <br class="title-page-name"/>                  half3 viewDir, <br class="title-page-name"/>                  fixed atten) <br class="title-page-name"/>{ <br class="title-page-name"/>  float NdotL = max(0,dot(s.Normal, lightDir)); <br class="title-page-name"/> <br class="title-page-name"/>  float3 halfVector = normalize(lightDir + viewDir); <br class="title-page-name"/>  float NdotH = max(0, dot(s.Normal, halfVector)); <br class="title-page-name"/>  float spec = pow(NdotH, _SpecPower) * _SpecularColor; <br class="title-page-name"/> <br class="title-page-name"/>  float4 color; <br class="title-page-name"/>  color.rgb = (s.Albedo * _LightColor0.rgb * NdotL) + <br class="title-page-name"/>        (_LightColor0.rgb * _SpecularColor.rgb * spec) * atten; <br class="title-page-name"/>  color.a = s.Alpha; <br class="title-page-name"/>  return color; <br class="title-page-name"/>} </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Then update the <kbd class="calibre13">surf</kbd> function to the following:</li>
</ol>
<pre class="calibre62">void surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/> half4 c = tex2D (_MainTex, IN.uv_MainTex) * _MainTint;<br class="title-page-name"/> o.Albedo = c.rgb;<br class="title-page-name"/> o.Alpha = c.a;<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">To complete our shader, we will need to tell our CGPROGRAM block to use our custom lighting model rather than a built-in one by modifying the <kbd class="calibre13">#pragma</kbd> statement with the following code:</li>
</ol>
<pre class="calibre62">CPROGRAM 
#pragma surface surf CustomBlinnPhong </pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">The following screenshot demonstrates the results of our BlinnPhong lighting model:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00101.jpeg" class="calibre99"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">The BlinnPhong Specular is almost exactly like the Phong Specular, except that it is more efficient because it uses less code to achieve almost the same effect. Before the introduction of physically-based rendering, this approach was the default choice for Specular reflection in Unity 4.</p>
<p class="calibre3">Calculating the reflection vector <strong class="calibre5">R</strong> is generally expensive. The BlinnPhong Specular replaces it with the half vector <strong class="calibre5">H</strong> between the view direction <strong class="calibre5">V</strong> and light direction <strong class="calibre5">L</strong>:</p>
<div class="cdpaligncenter"><img src="../images/00102.jpeg" class="calibre100"/></div>
<p class="calibre3">Instead of calculating our own reflection vector, we are simply going to get the vector halfway between the view direction and light direction, basically simulating the reflection vector. It has actually been found that this approach is more physically accurate than the last approach, but we thought it necessary to show you all the possibilities:</p>
<div class="mce-root3"><img src="../images/00103.gif" class="calibre25"/></div>
<p class="calibre3">According to vector algebra, the half vector can be calculated as follows:</p>
<div class="mce-root2"><img src="../images/00104.gif" class="calibre25"/></div>
<p class="calibre3">Here |V+L| is the length of the vector V+L. In Cg, we simply need to add the view direction and light direction together and then normalize the result to a unity vector:</p>
<pre class="calibre19">float3 halfVector = normalize(lightDir + viewDir); </pre>
<p class="calibre3">Then, we simply need to dot the vertex normal with this new half vector to get our main Specular value. After this, we just take it to a power of <kbd class="calibre13">_SpecPower</kbd> and multiply it by the Specular color variable. It's much lighter on the code and math, but still gives us a nice Specular highlight that will work for many real-time situations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<p class="calibre3">The light models seen in this chapter are extremely simple; no real material is perfectly matte or perfectly specular. Moreover, it is not uncommon for complex materials such as clothing, wood, and skin to require knowledge of how light scatters in the layers beneath the surface. Use the following table to recap the different lighting models encountered so far:</p>
<table border="1" class="calibre43">
<tbody class="calibre44">
<tr class="calibre45">
<td class="calibre101"><strong class="calibre1"><span>Technique</span></strong></td>
<td class="calibre102"><strong class="calibre1"><span>Type</span></strong></td>
<td class="calibre103"><strong class="calibre1"><span>Light Intensity (I)</span></strong></td>
</tr>
<tr class="calibre45">
<td class="calibre101"><span>Lambertian</span></td>
<td class="calibre102"><span>Diffuse</span></td>
<td class="calibre103">
<div class="cdpalignleft1"><img src="../images/00105.gif" class="calibre25"/></div>
</td>
</tr>
<tr class="calibre45">
<td class="calibre101"><kbd class="calibre13"><span>Phong</span></kbd></td>
<td class="calibre102"><span>Specular</span></td>
<td class="calibre103">
<div class="cdpalignleft1"><img src="../images/00106.gif" class="calibre25"/></div>
<div class="cdpalignleft1"><img src="../images/00107.gif" class="calibre25"/></div>
</td>
</tr>
<tr class="calibre45">
<td class="calibre101"><span>BlinnPhong</span></td>
<td class="calibre102"><span>Specular</span></td>
<td class="calibre103">
<div class="cdpalignleft1"><img src="../images/00108.gif" class="calibre25"/></div>
<div class="cdpalignleft1"><img src="../images/00109.gif" class="calibre25"/></div>
</td>
</tr>
</tbody>
</table>
<div class="title-page-name"/>
<p class="calibre3"> </p>
<p class="calibre3">There are other interesting models such as the Oren-Nayar lighting model for rough surfaces: <span class="calibre6"><a href="https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model" class="calibre10">https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model</a>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating an Anisotropic Specular type</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Anisotropic</strong> is a type of Specular or reflection that simulates the directionality of grooves in a surface and modifies/stretches the Specular in the perpendicular direction. It is very useful when you want to simulate brushed metals, not a metal with a clear, smooth, and polished surface. Imagine the Specular that you see when you look at the data side of a CD or DVD or the way Specular is shaped at the bottom of a pot or pan. You will notice that if you carefully examine the surface, there is a direction to the grooves, usually in the way the metal was brushed. When you apply a Specular to this surface, you get a Specular stretched in the perpendicular direction.</p>
<p class="calibre3">This recipe will introduce you to the concept of augmenting your Specular highlights to achieve different types of brushed surfaces. In future recipes, we will look at the ways in which we can use the concepts of this recipe to achieve other effects, such as stretched reflections and hair, but here, you are going to learn the fundamentals of the technique first. We will be using this shader as a reference for our own custom Anisotropic Shader:<span class="calibre6"><br class="calibre7"/>
<a href="http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader" class="calibre10">http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader</a>.<br class="calibre7"/></span>The following diagram shows examples of different types of Specular effects that you can achieve using Anisotropic Shaders in Unity:</p>
<div class="cdpaligncenter"><img src="../images/00110.gif" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3">Let's start this recipe by creating a shader, its material, and some lights for our scene:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Create a new scene with some objects and lights so that we can visually debug our shader. In this case, we will be using some capsules, a sphere, and a cylinder.</li>
<li value="2" class="calibre12">Then create a new shader and material, and hook them up to your objects:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00111.jpeg" class="calibre25"/></div>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Lastly, we will need some sort of normal map that will indicate the directionality of our Anisotropic Specular highlight.</li>
<li class="calibre12" value="4">The following screenshot shows the Anisotropy normal map we will be using for this recipe. It is available from this book's support page at <span><a href="https://www.packtpub.com/books/content/support" class="calibre10">https://www.packtpub.com/books/content/support</a></span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00112.jpeg" class="calibre104"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it...</h1>
                
            
            <article>
                
<p class="calibre3">To create an Anisotropic effect, we need to make the following changes to the shader previously created:</p>
<ol class="calibre15">
<li value="1" class="calibre12">We first need to remove the old properties and then add the properties that we are going to need for our shader. These will allow a lot of artistic control over the final appearance of the surface:</li>
</ol>
<pre class="calibre62">Properties 
{ 
  _MainTint ("Diffuse Tint", Color) = (1,1,1,1) 
  _MainTex ("Base (RGB)", 2D) = "white" {} 
  _SpecularColor ("Specular Color", Color) = (1,1,1,1) 
  _Specular ("Specular Amount", Range(0,1)) = 0.5 
  _SpecPower ("Specular Power", Range(0,1)) = 0.5 
  _AnisoDir ("Anisotropic Direction", 2D) = "" {} 
  _AnisoOffset ("Anisotropic Offset", Range(-1,1)) = -0.2 
} </pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">We then need to make the connection between our <kbd class="calibre13">Properties</kbd> block and<br class="title-page-name"/>
our <kbd class="calibre13">SubShader{}</kbd> block so that we can use the data being provided by the <kbd class="calibre13">Properties</kbd> block:</li>
</ol>
<pre class="calibre62">sampler2D _MainTex; 
sampler2D _AnisoDir; 
float4 _MainTint; 
float4 _SpecularColor; 
float _AnisoOffset; 
float _Specular; 
float _SpecPower; </pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Now we can create our <kbd class="calibre13">Lighting</kbd> function that will produce the correct Anisotropic effect on our surface. We will use the following code for this:</li>
</ol>
<pre class="calibre62">fixed4 LightingAnisotropic(SurfaceAnisoOutput s, fixed3 <br class="title-page-name"/>   lightDir, half3 viewDir, fixed atten) 
{ 
  fixed3 halfVector = normalize(normalize(lightDir) + <br class="title-page-name"/>     normalize(viewDir)); 
  float NdotL = saturate(dot(s.Normal, lightDir)); 
 
  fixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), <br class="title-page-name"/>     halfVector);  float aniso = max(0, sin(radians((HdotA + _AnisoOffset) * <br class="title-page-name"/>     180)));  float spec = saturate(pow(aniso, s.Gloss * 128) * <br class="title-page-name"/>     s.Specular); 
 
  fixed4 c; 
  c.rgb = ((s.Albedo * _LightColor0.rgb * NdotL) + <br class="title-page-name"/>     (_LightColor0.rgb * _SpecularColor.rgb * spec)) * <br class="title-page-name"/>     atten; 
  c.a = s.Alpha; 
  return c; 
} </pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">In order to use this new <kbd class="calibre13">Lighting</kbd> function, we need to tell the subshader's <kbd class="calibre13">#pragma</kbd> statement to look for it instead of using one of the built-in <kbd class="calibre13">Lighting</kbd> functions: </li>
</ol>
<pre class="calibre62">CGPROGRAM 
#pragma surface surf Anisotropic </pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">We have also given the Anisotropic normal map its own UVs by declaring the following code in the <kbd class="calibre13">struct Input</kbd>. This isn't entirely necessary as we could just use the UVs from the main texture, but this gives us independent control over the tiling of our brushed metal effect so that we can scale it to any size we want:</li>
</ol>
<pre class="calibre62">struct Input  
{ 
  float2 uv_MainTex; 
  float2 uv_AnisoDir; 
}; </pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">We also need to add the <kbd class="calibre13"><span>struct </span>SurfaceAnisoOutput</kbd>:</li>
</ol>
<pre class="calibre62">struct SurfaceAnisoOutput 
{ 
  fixed3 Albedo; 
  fixed3 Normal; 
  fixed3 Emission; 
  fixed3 AnisoDirection; 
  half Specular; 
  fixed Gloss; 
  fixed Alpha; 
}; </pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12">Finally, we need to use the <kbd class="calibre13">surf()</kbd> function to pass the correct data to our <kbd class="calibre13">Lighting</kbd> function. Hence, we will get the per-pixel information from our Anisotropic normal map and set our Specular parameters as follows:</li>
</ol>
<pre class="calibre62">void surf(Input IN, inout SurfaceAnisoOutput o) 
{ 
  half4 c = tex2D(_MainTex, IN.uv_MainTex) * _MainTint; 
  float3 anisoTex = UnpackNormal(tex2D(_AnisoDir, <br class="title-page-name"/>     IN.uv_AnisoDir)); 
 
  o.AnisoDirection = anisoTex; 
  o.Specular = _Specular; 
  o.Gloss = _SpecPower; 
  o.Albedo = c.rgb; 
  o.Alpha = c.a; 
} </pre>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">Save your script and return to the Unity editor. Select the <kbd class="calibre13">AnisotropicMat</kbd> material and assign the <span>Anisotropic Direction</span> property to the texture we talked about in the <em class="calibre2">Getting ready</em> section of this recipe. Afterward, adjust the Anisotopic <kbd class="calibre13">Offset</kbd> property using the slider and notice the changes.</li>
</ol>
<p class="calibre3">The Anisotropic normal map allows us to give the surface direction and helps us disperse the Specular highlight around the surface. The following screenshot demonstrates the result of our Anisotropic Shader:</p>
<div class="cdpaligncenter"><img src="../images/00113.jpeg" class="calibre105"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works...</h1>
                
            
            <article>
                
<p class="calibre3">Let's break down this shader into its core components and explain why we are getting the effect. We will mostly be covering the custom Lighting function here, as the rest of the shader should be pretty self-explanatory at this point.</p>
<p class="calibre3">We first start by declaring our own <kbd class="calibre13">SurfaceAnisoOutput struct</kbd>. We need to do this in order to get the per-pixel information from the Anisotropic normal map, and the only way we can do this in a Surface Shader is to use a <kbd class="calibre13">tex2D()</kbd> function in the <kbd class="calibre13">surf()</kbd> function. The following code shows the custom surface output structure used in our shader:</p>
<pre class="calibre19">struct SurfaceAnisoOutput 
{ 
  fixed3 Albedo; 
  fixed3 Normal; 
  fixed3 Emission; 
  fixed3 AnisoDirection; 
  half Specular; 
  fixed Gloss; 
  fixed Alpha; 
}; </pre>
<p class="calibre3">We can use the <kbd class="calibre13">SurfaceAnisoOutput</kbd> struct as a way of interacting between the Lighting function and the surface function. In our case, we are storing the per-pixel texture information in the variable called <kbd class="calibre13">anisoTex</kbd> in our <kbd class="calibre13">surf()</kbd> function and then passing this data to the <kbd class="calibre13">SurfaceAnisoOutput</kbd> struct by storing it in the <kbd class="calibre13">AnisoDirection</kbd> variable. Once we have this, we can use the per-pixel information in the <kbd class="calibre13">Lighting</kbd> function using <kbd class="calibre13">s.AnisoDirection</kbd>.</p>
<p class="calibre3">With this data connection set up, we can move on to our actual lighting calculations. This begins by getting the usual out of the way, the half vector, so that we don't have to do the full reflection calculation and diffuse lighting, which is the vertex normal dotted with the light vector or direction. This is done in Cg with the following lines:</p>
<pre class="calibre19">fixed3 halfVector = normalize(normalize(lightDir) + <br class="title-page-name"/>                    normalize(viewDir)); 
float NdotL = saturate(dot(s.Normal, lightDir)); </pre>
<p class="calibre3">Then, we start the actual modification to the Specular to get the right look. We first dot the normalized sum of the vertex normal and per-pixel vectors from our Anisotropic normal map with the <kbd class="calibre13">halfVector</kbd> calculated in the previous step. This gives us a float value that gives a value of <kbd class="calibre13">1</kbd> as the surface normal, which is modified by the Anisotropic normal map as it becomes parallel with <kbd class="calibre13">halfVector</kbd> and <kbd class="calibre13">0</kbd> as it is perpendicular. Finally, we modify this value with a <kbd class="calibre13">sin()</kbd> function so that we can basically get a darker middle highlight and ultimately a ring effect based on <kbd class="calibre13">halfVector</kbd>. All the previously mentioned operations are summarized in the following two lines of Cg code:</p>
<pre class="calibre19">fixed HdotA = dot(normalize(s.Normal + s.AnisoDirection), <br class="title-page-name"/>                  halfVector); 
float aniso = max(0, sin(radians((HdotA + _AnisoOffset) * 180))); </pre>
<p class="calibre3">Finally, we scale the effect of the <kbd class="calibre13">aniso</kbd> value by taking it to a power of <kbd class="calibre13">s.Gloss</kbd>, and then globally decrease its strength by multiplying it by <kbd class="calibre13">s.Specular</kbd>:</p>
<pre class="calibre19">float spec = saturate(pow(aniso, s.Gloss * 128) * s.Specular); </pre>
<p class="calibre3">This effect is great for creating more advanced metal type surfaces, especially the ones that are brushed and appear to have directionality to them. It also works well for hair or any sort of soft surface with directionality to it. The following screenshot shows the result of displaying the final Anisotropic lighting calculation:</p>
<div class="cdpaligncenter"><img src="../images/00114.jpeg" class="calibre106"/></div>
<p class="calibre3"> </p>


            </article>

            
        </section>
    </body></html>