- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Forms with Validation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about creating forms and validating them, which
    is an excellent opportunity to build our admin interface, where we can manage
    our blog posts and also take a look at the new enhanced form navigation. We will
    also build multiple reusable components and learn about some of the new functionalities
    in Blazor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be super fun, and we will use a lot of the things we have
    learned up until now.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Exploring form elements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom validation class attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at bindings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an admin interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an abstraction layer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have followed the previous chapters or use the `Chapter05` folder
    as a starting point.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Exploring form elements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many form elements in HTML, and we can use them all in Blazor. In
    the end, what Blazor outputs is HTML.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Blazor does have components that will add to the functionality, so we can and
    should try to use those components instead of HTML elements. The built-in components
    give us great functionality for free.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Blazor offers the following components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputBase<>`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputCheckbox`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputDate<TValue>`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputNumber<TValue>`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputSelect<TValue>`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputText`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputTextArea`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputRadio`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InputRadioGroup`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationMessage`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationSummary`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through them all in the next sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: EditForm
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`EditForm` renders as a `form` tag, but it has a lot more functionalities.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: First, we will not create an action or method like traditional `form` tags;
    Blazor will handle all of that.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` will create an `EditContext` instance as a cascading value so that
    all the components you put inside of `EditForm` will access the same `EditContext`.
    `EditContext` tracks the metadata regarding the editing process, such as what
    fields have been edited, and keeps track of any validation messages.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You need to assign either a model (a class you wish to edit) or an `EditContext`
    instance.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: For most use cases, assigning a model is the way to go, but for more advanced
    scenarios, you might want to be able to trigger `EditContext.Validate()`, for
    example, to validate all the controls connected to `EditContext`. This is very
    rarely done, but it might be good to know it is possible.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '`EditForm` has the following events that you can use to handle form submissions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '`OnValidSubmit` gets triggered when the data in the form validates correctly
    (we will come back to validation in just a bit).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnInvalidSubmit` gets triggered if the form does not validate correctly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSubmit` gets triggered when the form is submitted, regardless of whether
    the form validates correctly or not. Use `OnSubmit` if you want to control the
    validation yourself.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at an example.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a class that holds a person; the class has a name and an age for that
    person and looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`EditForm` for this class would look like this (without any other elements
    for now):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`EditForm` specifies a model (in this case, `personmodel`), and we are listening
    to the `OnValidSubmit` event.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The `Submit` button is a regular HTML button that is not a specific Blazor component.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: InputBase<>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the Blazor input classes derive from the `InputBase` class. It has a bunch
    of things we can use for all of the `input` components; we will go through the
    most important ones.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`InputBase` handles `AdditionalAttributes`, which means that if we add any
    other attributes to the tag, they will automatically get transferred to the output.
    This means that the components derived from this class can leverage any HTML attributes
    since they will be part of the output.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '`InputBase` has properties for `Value`, which we can bind to, and an event
    callback for when the value changes called `ValueChanged`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: We can also change `DisplayName` so that the automated validation messages will
    reflect the correct name and not the property’s name, which is the default behavior.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Not all controls support the `DisplayName` property. Some properties are only
    used inside the component, and we will return to those in a bit.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: InputCheckbox
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputCheckbox` component will render as `<input type="checkbox">`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: InputDate<TValue>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputDate` component will render as `<input type="date">`. We can use `DateTime,
    DateOnly, TimeOnly,` and `DateTimeOffset` as values for the `InputDate` component.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to format the date; it will use the web browser’s current setting.
    This behavior is by design and is part of the HTML5 spec.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: InputNumber<TValue>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputNumber` component will render as `<input type="number">`. We can use
    `Int32`, `Int64`, `Single`, `Double`, and `Decimal` as values for the `InputNumber`
    component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: InputSelect<TValue>
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputSelect` component will render as `<select>`. We will create `InputSelect`
    later in this chapter, so I won’t go into further detail here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: InputText
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputText` component will render as `<input type="text">`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: InputTextArea
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputSelect` component will render as `<textarea>`. In this chapter, we
    will build our own version of this control.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: InputRadio
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputRadio` component will render as `<input type="radio">`. Use this for
    individual options.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: InputRadioGroup
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputRadioGroup` component is not an element itself but rather groups other
    `InputRadioInputs`. Use this to group options. We can add multiple `InputRadio`
    components inside of the `InputRadioGroup`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: InputFile
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `InputFile` component will render as `<Input type="file">`. This component
    will make it easier to get the file data. It will supply us with a stream for
    each file’s content.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can dive into `InputFile` further by checking out the documentation here:
    [https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0](https://learn.microsoft.com/en-us/aspnet/core/blazor/file-uploads?view=aspnetcore-8.0).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there is a Blazor component for almost all the HTML form controls,
    with some added functionality such as validation, which we will see in the next
    section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already touched on validation; there are some built-in functionalities
    in the `input` components and `EditForm` to handle validation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: One way to add validation to our form is to use `DataAnnotations`. Using DataAnnotations,
    we don’t have to write any custom logic to ensure the data in the form is correct;
    instead, we can add attributes to the data model and let `DataAnnotationsValidator`
    take care of the rest.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of `DataAnnotations` instances in .NET already that we can
    use; we can also build our own annotations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the built-in data annotations are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`Required`: This makes the field required.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email`: This will check that the entered value is an email address.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinLength`: This will check that the number of characters is not fewer than
    the value specified.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxLength`: This will check that the number of characters is not exceeded.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Range`: This will check that the value is within a specific range.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many more annotations that can help us validate our data. To test
    this out, let’s add data annotations to our data classes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: In the `Data.Models` project, open `Models/BlogPost.cs`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the file, add a `using` statement for System.ComponentModel.DataAnnotations:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `Required` and `MinLength` attributes to the `Title` property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Required` attribute will ensure we can’t leave the title empty, and `MinLength`
    will make sure it has at least `5` characters.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Text` property:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Required` attribute will ensure the `Text` property cannot be empty, which
    makes sense – why would we create an empty blog post?
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Category.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Required` attribute will make sure we can’t leave the name empty.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Tag.cs`, and at the top of the file, add a `using` statement for
    `System.ComponentModel.DataAnnotations`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` property:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Required` attribute will make sure we can’t leave the name empty.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `Models/Comment.cs`, and at the top of the file, add a `using` statement
    for `System.ComponentModel.DataAnnotations`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Required` attribute to the `Name` and `Text` properties:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Great, now our data models have validation built into them. We need to give
    our users feedback on what went wrong with the validation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We can do that by using the `ValidationMessage` or `ValidationSummary` components.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ValidationMessage
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ValidationMessage` component can show us individual error messages for
    a specific property. We want to use this component to show validation errors under
    a form element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a `ValidationMessage` component, we have to specify the `For` property
    with the name of the property we want to show the validation errors for:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ValidationSummary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ValidationSummary` component will show all the validation errors as a
    list for the entire `EditContext`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don’t need to supply any model or property to the `ValidationSummary` component
    since it gets access to the `EditContext` using the cascading value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: I prefer to show the error close to the problem so the user can see where the
    issue is. However, we also have the option to show the validation errors as a
    list using `ValidationSummary`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: To ensure our input controls match the Bootstrap theme (or whatever theme we
    might use), we can create our **custom validation class**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Custom validation class attributes
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By simply using the edit form, input components, and `DataAnnotationValidator`,
    the framework will automatically add classes to the components when it is and
    isn’t valid.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: By default, these classes are `.valid` and `.invalid`. In .NET 5, we were given
    a way to customize these class names ourselves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: When using Bootstrap, the default class names are `.is-valid` and `.is-invalid`
    , and the list of class names must also include `.form-control` to get the proper
    styles.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The next component we build will help us get the proper Bootstrap styling on
    all our form components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create our own `FieldCssClassProvider` to customize what classes Blazor
    will use:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, inside the `ResuableComponents` folder, add
    a new class called `BootstrapFieldCssClassProvider.cs`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new class and add the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`BootstrapFieldCssClassProvider` needs an `EditContext` instance to work.'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code will check whether the form (or `EditContext` to be specific) is valid
    and whether or not it has been modified. Based on that, it returns the correct
    CSS classes.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It returns the form control for all elements; that way, we don’t have to add
    it to every element in the form. We could validate an untouched form as valid
    or invalid, but we don’t want it to show that the form is OK just because it hasn’t
    been changed yet.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Without the code we are about to build, we need to get the `EditContext` instance
    from our `EditForm` and then set `FieldCssClassProvider` on `EditContext` as follows:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`CurrentEditContext.SetFieldCssClassProvider(provider);`'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will do that more elegantly (in my humble opinion) with the `CustomCssClassProvider`
    we will create next.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Earlier in this chapter, I mentioned that `EditForm` exposes its `EditContext`
    as `CascadingValue`.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That means we will build a component that we can just put inside of our `EditForm`
    and access `EditContext` that way.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the root of the project, add a new class
    and name it `CustomCssClassProvider.cs`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file and replace the content with the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This generic component takes a `type` value, in this case, the type of `Provider`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We specified that `type` must inherit from `FieldCssClassProvider` and must
    have a constructor without parameters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The component inherits from `ComponentBase`, which makes it possible to place
    the component inside a Blazor component.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are writing our component with C# only, but it is not rendering
    anything.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We have a `Cascading` parameter that will be populated from `EditForm`. We throw
    an exception if `EditContext` is missing for some reason (for example, if we place
    the component outside of `EditForm`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set `FieldCssClassProvider` on `EditContext`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the component, we have to add the following code inside of `EditForm`
    (don’t worry, we will create an `EditForm` soon):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We provide our `CustomCssClassProvider` component with the right `ProviderType`:
    `BootstrapFieldCssClassProvider`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one way of implementing components to help us encapsulate functionality.
    We could have written the code this way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But with the new `CustomCssClassProvider` component, we can write the same
    thing like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we are doing something with `EditContext`, we can always create a component
    like this since it is a `cascading` parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a component that will make our form controls look like Bootstrap
    controls and instead of adding specific code to every component, we can now add
    the `CustomCssClassProvider` component. Next, it’s time to put that into practice
    and create a couple of forms by building our admin interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Looking at bindings
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are using bindings to bind data to our form controls. We
    briefly discussed bindings in *Chapter 5*, *Creating Advanced Blazor Components*,
    but it’s time to dig deeper into bindings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Binding to HTML elements
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With HTML elements, we can use `@bind` to bind variables to the element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we are binding to a textbox, we would do it like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`@bind` and `@bind-value` both work and do the same thing. Note the lower `v`
    in value. The input element is an HTML element that will render as a normal HTML
    element with no extra features (except binding). Compare this to `InputText`,
    which will work in a similar way but also give you additional features like validation
    and styles.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value in the variable will change when we leave the textbox.
    But we can change that behavior by adding a `@bind:event` attribute like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can even take full control over what is happening by using the `@bind:get`
    and `@bind:set` attributes like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are doing the same thing as `@bind`, so we can’t use them together with
    `@bind`. The `@bind:set` attribute has another nice feature. We can run asynchronous
    methods when we set a value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a way for us to run a method after the value is set by using
    `@bind:after` like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This gives us great flexibility when it comes to binding to HTML elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we can also set the culture using `@bind:culture`. Both date
    and number fields use invariant culture and will use the appropriate browser formatting,
    but if we use a text field, we can change the behavior like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Where `GBCulture`, in this case, is a `CultureInfo` object. Lastly, we can
    set the format using `@bind:format`. This is only implemented for `DateTime` at
    this point:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We now know how we can bind to HTML elements. Next, we will take a look at binding
    to components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Binding to components
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When binding to components, `Get`, `Set`, and `After` will also work. `Culture`,
    `Event`, and `Format` will work on some components.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'When binding to a component, we use `@bind-{ParameterName}`, so for the parameter
    `Value`, it would look like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the background, `@bind-Value` will affect two other parameters, `ValueExpression`
    and `ValueChanged`. This means you will not be able to set them manually if you
    use `@bind-Value`. When we change the value, `ValueChanged` will get triggered,
    and we can listen to the event and make things happen when it changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `Get` and `Set` like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We must always supply both `Get` and `Set` and they cannot be combined with
    `@bind-Value`. These samples use `InputText`, a built-in Blazor component, but
    this concept works with any parameter on any component. The same thing goes for
    `After`. It can be used with any component, like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have access to some nice binding features, and they work when binding to
    components as well as HTML elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will build an admin interface using bindings.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Building an admin interface
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it’s time to build a simple admin interface for our blog.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: List categories
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit categories
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List tags
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit tags
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List blog posts
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit blog posts
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look at the preceding list, we might notice that some of the things seem
    similar – perhaps we can build shared components for those. Categories and tags
    are very similar; they have names, and the name is the only thing we should be
    able to edit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a component for that. The component is going to be responsible for
    listing, adding, deleting, and updating the object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the object we are working with is either `Category` or `Tag`, we need
    to be able to call different APIs depending on the object, so our component needs
    to be generic:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the root of the project, add a new Razor
    component and call it `ItemList.razor`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the newly created file and at the top of the file, add:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`@typeparam` is to make the component generic, and the variable holding the
    generic type is called `ItemType`.'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `code` section (if you don’t have one already), and add the following
    lines of code:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need two parameters: a list where we can add all the items and an `ItemTemplate`
    instance that we can use to change how we want the items to be shown. The `EditorRequired`
    attribute makes sure that we need to set this value when using the component.
    Otherwise, Visual Studio will show hostile error messages until we fix it.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we are using `RenderFragment<T>`, which will give us access to
    the item inside the template (things will become clearer as soon as we implement
    it).
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need a couple of events; add the following code to the `code` section:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We added two events; the first is when we delete a tag or a category. We will
    send an event to the parent component where we can add the code needed to delete
    the item.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second one is when we select an item so that we can edit the item.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add the UI; replace the top of the file below the `@typeparam`
    to the code tag with:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we look back to *Step 3*, we’ll notice that we used the variable for the
    lists and `RenderFragment`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Then, we use the new `Virtualize` component to list our items; to be fair, we
    might not have that many categories or tags, but why not use it when we can? We
    set the `Items` property to `"Items"` (which is the name of our list) and the
    `Context` parameter to `"item"`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: We can give it whatever name we want; we’re only going to use it inside of the
    `Virtualize` render template.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We added two buttons that simply invoke the `EventCallback` instance we added
    in *Step 4*. Between those buttons, we added `@ItemTemplate(item)`; we want Blazor
    to render the template, but we also send the current item in the loop.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: That means we have access to the item’s value inside our template.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing categories
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our new component, it’s now time to create a component for listing and
    editing our categories:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SharedComponents` project, open `_Imports.razor`. Make sure the following
    namespaces are included: `@using SharedComponents` and `@using Microsoft.AspNetCore.Components.Forms`.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Pages` folder, select **Add** | **New folder**, and name
    the folder `Admin`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Pages/Admin` folder, add a new Razor component and name it `CategoryList.razor`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, replace `<h3>CategoryList</h3>` with the following
    code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We started with the `@page` directive, telling Blazor that if we navigate to
    the `"``admin/categories"` URL, we will get to the `CategoryList.Razor` component.
    This component has some interactivity, so we need to set what interactivity mode
    we wish to use. In this case, we are using `InteractiveServer`. If we want to
    use `InteractiveAuto` or `InteractiveWebAssembly`, we need to put the component
    in the `BlazorWebApp.Client` project. We will add a `using` statement and then
    inject our API.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to add a form to edit the categories. Add the following code
    under the code from the previous step:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    OK. For validation, we added `DataAnnotationsValidator`, which will validate the
    supplied data against the annotations we added to the `Tag` and `Category` classes.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added `InputText` and connected it to a `Category` object called `Item` (which
    we will add in just a second).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Below that, we added `ValidationMessage`, which will show any errors for the
    `name` property, and then a **Submit** button.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add our `ItemList` component; under the code we added in
    the previous step, add this code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add our component and we bind the `Items` property to a list of items (we
    will create that list in the next step).
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We bind the `Select` and `Delete` events to methods and we specify the type
    of the list in the `ItemType` property. Then, we have `ItemTemplate`. Since we
    are using `RenderFragment<T>`, we now have access to a variable called `context`.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We convert that variable to a category and print out the name of the category.
    This is the template for each item that will be shown on the list.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we add the following code to replace the `code` section:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We added a list to hold all our categories and a variable that holds one item
    (the item currently being edited). We use `OnInitializedAsync` to load all the
    categories from the API.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Delete` and `Save` methods call the API’s corresponding method, and the
    `Select` method takes the provided item and puts it into the item variable (ready
    to be edited).
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We check whether we already have the item in the list before we add it to the
    list. Run the project and navigate to `/admin/categories`.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try to add, edit, or delete a category, as shown in *Figure 6.1*:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_01.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The Edit category view'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need a component for listing and editing tags as well – it is pretty
    much the same thing, but we need to use `Tag` instead of `Category`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing tags
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just created a component for listing and editing categories; now, we need
    to create a component to list and edit tags:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client` project, in the `Pages`folder, add a new folder
    called`Admin`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Razor component called `TagList.razor`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, replace `<h3>TagList</h3>` with the following
    code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We started with the `@page` directive telling Blazor that if we navigate to
    the `"admin/tags"` URL, we will get to the `TagList.Razor` component. We also
    specify the render mode as `InteractiveServer`. We add a `using` statement and
    then inject our API.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to add a form to edit the tags. Add the following code under
    the code from the previous step:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We added `EditForm`, which will execute the `Save` method if the form validates
    without a problem. For validation, we added `DataAnnotationsValidator`, which
    will validate the supplied data against the annotations we added to the `Tag`
    and `Category` classes.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are using Bootstrap, we want our form controls to look the same, so
    we added `CustomCssClassProvider`, which we created earlier in this chapter.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We added `InputText` and connected it to a `Tag` object called `Item` (which
    we will add in a moment).
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Below it, we add a `ValidationMessage` instance that will show any errors for
    the `name` property and then a **Submit** button.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to add our `ItemList` component. Under the code we added in
    the previous step, add this code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We added our component and bound the `Items` property to a list of items (we
    will create that list in the next step). We bind the `Select` and `Delete` events
    to methods and specify the `List` type in the `ItemType` property.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we have `ItemTemplate`; since we are using `RenderFragment<T>`, we now
    have access to a variable called `context`. We convert that variable to a tag
    and print out the tag’s name.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the template for each item shown in the list.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we replace the code section with the following code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We added a list to hold all our tags and a variable that holds one item (the
    item currently being edited). We use `OnInitializedAsync` to load all the tags
    from the API.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Delete` and `Save` methods call the API’s corresponding method and the
    `Select` method takes the provided item and puts it into the `Item` variable (ready
    to be edited).
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We check whether we already have the item in the list before we add it to the
    list.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the project and navigate to `/admin/tags`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to add, edit, and delete a tag, as shown in *Figure 6.2*:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_02.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The Edit tag view'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need ways to list and edit blog posts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Listing and editing blog posts
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with listing and editing blog posts:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `Pages/Admin` folder, add a new Razor
    component called `BlogPostList.razor`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `BlogPostList.razor` file, replace `<h3>BlogPostList</h3>`
    with the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We added a `page` directive, injected our API, and listed the blog posts using
    a `foreach` loop. We also enabled `StreamingRendering`, because this page doesn’t
    have any interactivity, so there is no need to add that. This also means we can’t
    use the `Virtualize` component since it is interactive.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also linked the posts to a URL with the `Id` instance of the blog.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code in the `code` section:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We added the functionality to load posts from the database and a small delay
    so that we can see **Loading…** for just a brief moment. Now, there is only one
    thing left in the section: adding a page where we can edit the blog post.'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A very popular way of writing blog posts is using Markdown; our blog engine
    will support that. Since Blazor supports any .NET standard **dynamic link library**
    (**DLL**), we will add an existing library called `Markdig`.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the same engine that Microsoft uses for their `docs` site.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can extend `Markdig` with different extensions (as Microsoft has done), but
    let’s keep this simple and only add support for Markdown without all the fancy
    extensions.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Under the `SharedComponents` project, right-click on the **Dependencies** node
    in Solution Explorer and select **Manage NuGet Packages**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Markdig` and click **Install**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class in the root of the project called `InputTextAreaOnInput.cs`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file and replace its contents with the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is taken from Microsoft’s GitHub repository; it is how they
    implement the `InputTextArea` component.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In their build system, they can’t handle `.razor` files, so that’s why they
    implement the code this way. I made one change in Microsoft’s code, and that is
    `oninput`, which used to say `OnChange`.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For most cases, `OnChange` will be just fine, which means when I leave the textbox,
    the value will be updated (and trigger validations). But in our case, we want
    the preview of the HTML to be updated in real time, which is why we had to implement
    our own.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One option could have been not to use the `InputTextArea` component and instead
    use the `TextArea` tag, but we would lose the validation highlighting. This is
    the way to go if we ever need to customize the behavior on an input control.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I recommend using `.razor` files over `.cs` files if you make many changes to
    the implementation.
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Pages/Admin` folder, add a new Razor component called `BlogPostEdit.razor`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `BlogPostEdit.razor` file, replace `<h3>BlogPostEdit</h3>`
    with the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We add two different `page` directives because we want to be able to create
    a new blog post as well as supply an ID to edit an already existing one. If we
    do not supply an ID, the `Id` parameter will be null (or the default).
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We inject our API and `NavigationManager` as well as adding `using` statements.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need some variables. Add the following code in the `code` section:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We added a parameter for the blog post ID (if we want to edit one), a variable
    to hold the post we are editing, one to hold all the categories, and one to hold
    all the tags. We also added a variable to hold the currently selected category
    and one to hold the Markdown converted to HTML.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add the form; add the following code:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We add an `EditForm`, and when we submit the form (if it is valid), we execute
    the `SavePost` method. We add `DataAnnotationValidator`, which will validate our
    model against the data annotations in the class.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We add `CustomCssClassProvider` so that we get the correct Bootstrap class names.
    Then, we add components for the title, publish date, category, tags, and, last
    but not least, the text (the blog post’s content).
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we add the text using the component we created in *Step 4* (the component
    that updates for each keystroke).
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also hook up the `@onkeyup` event to update the preview for each keystroke.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to add our `SavePost` method. Add the following code in the `code`
    section:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, it’s time to show the preview. Add the following code just below the `EditForm`
    close tag:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use `MarkupString` to make sure Blazor outputs the HTML code without escaping
    the characters. You might remember that from *Chapter 4*, *Understanding Basic
    Blazor Components*.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it is time to set up `Markdig`. Add the following code somewhere in the
    `code` section:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To configure `Markdig`, we need to create a pipeline. As I mentioned earlier
    in the chapter, this is the engine Microsoft uses for their documentation site.
    It has many extensions available, including source code highlighting and emoticons.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also added emoticons to the pipeline to make it a little more fun.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We must also add code to load the data (`blog` `posts`, `categories`, and `tags`).
    Add the following methods in the `code` section:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, run the site, navigate to `/admin/blogposts`, click on a blog post to
    edit it, and test the new Markdown support. *Figure 6.3* shows the **Edit** page
    with Markdown support:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21849_06_03.png)'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 6.3: The Edit page with Markdown support'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We still have one more thing to do: we need to ensure that the blog post page
    shows a converted HTML version of the Markdown.'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `/Pages/Post.razor` and add the following `using` statement at the top
    of the file:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following code to the `code` section:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Replace the following row:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Replace the preceding row with this:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Great job! Now, we have an admin interface up and running so that we can start
    writing blog posts.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the code we wrote, no textbox has a label; what we can do is add
    a label in all the places we are using a textbox. Some component vendors have
    a label built into their components. I prefer doing that myself. Add an abstraction
    layer on top of any built-in components or third-party components.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Adding an abstraction layer
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This has saved us more times than I can count. Adding an abstraction layer
    does take some time and effort, but I promise you, you will get that time back.
    So, why should we do this? Well, for several reasons: if we are using Bootstrap,
    for example, and we want to upgrade Bootstrap to the latest version, there might
    be classes that have changed. By using components, it’s easy to only change those
    components. It also makes it easier to change component vendors in the future
    if you have your own components encapsulating the third-party components. But
    the real reason is that if we add a layer, we can set the team’s programming style/language.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Everything we build will have the same default values, the same access to properties,
    and the same UX. We can add functionality, but in most cases, it is more important
    to limit the functionality.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: A third-party component has a lot of functionality; it should cater to many
    different use cases. But they also mean that your team now has access to many
    different functionalities that can make the UX different for each developer that
    implements the functionality.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a couple of shared components to the project.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a textbox with a label and validation message built in.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at our `CategoryList` component, the code looks like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A label using Bootstrap looks something like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s see if we can combine these; some features are already built in. Since
    we only add a layer, we don’t have to handle as much functionality. We rather
    need to send the parent component values to the encapsulated component. Let’s
    look at some code to see what’s going on:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponent` project, in the `ResusableComponents` folder, add a
    new Razor component and call it `BlogInputText.razor`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let’s take a look at what is going on. First, we add a parameter so that we
    have an ID that we can use for the `label` tag in the next step. We add a string
    that can contain text for our label, id we do have some text, we render the label.
    If it is `null`, we don’t render the label. I prefer not to have a “`ShowLabel`"
    property. If there is a text, it should show the label. We also have the current
    edit context, which we will use to send to the next level of components.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our form we have an `EditForm`; the `EditForm` will send the `EditContext`
    to all the child components and will keep track of the state of the form. We want
    to grab that edit context and send that to all the components inside of this component
    as well.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the trio of value parameters, `Value`, `ValueChanged`, and `ValueExpression`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the non-code part of the page, add the following (replacing the three tags):'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: First, we grab the `CurrentEditContext` and send that to a child component;
    this way, all the children will have the same edit context as the parent `EditForm`.
    If we have any text in the `Label` parameter, we should show the label. Then we
    add the `InputText`, the built-in component. If we would like to do this with
    a third-party library, we would do it in a similar way. Next is where things get
    a bit more complicated; we could have simply said `@bind-Value`, which would notify
    Blazor that a change has happened, but it would notify the `EditContext` that
    the `Value` parameter of our component has been changed, not the model.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, instead of doing that, we set the `Value` parameter and the `ValueChanged`
    parameter to the parameters that we send to the component. This way, the notification
    of the value changed will directly notify that the model has been changed. The
    `ValueExpression` will make sure that the `EditContext` gets notified of the change
    and will show the corresponding validation message. To be honest, in this example,
    it doesn’t really matter, but if we were using a third-party component with validation
    built in, it might not work (depending on how they build the component). So, using
    this method should always work.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we have the `ValidationMessage`, which shows any error in the model, and
    we are using the same `ValueExpression` here.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to use this component. Let’s change the `Taglist` first. In the
    `BlazorWebApp.Client` project, in the `Pages/Admin` folder, open `Taglist.razor`.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right now, we have the following code:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Replace this code with the following:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, isn’t that kind of elegant?
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s do the same with the `CategoryList`. In the `SharedComponent` project,
    in the `Pages/Admin` folder, open `CategoryList.razor`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following code:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Replace the preceding code with the following code:'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This kind of change makes me genuinely happy – it simplifies usage, makes the
    UI easier to understand, and removes the need for duplicated code. Even though
    we know how to do this now, I want to add one more example that perhaps showcases
    the really nice benefits of working this way. Let’s create a button component
    as well. This component will be a bit more to take in:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new component and name it `BlogButton.razor`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content with this code:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are adding a normal HTML button, nothing fancy. We add functionality to change
    the type (`button` or `submit`), whether it is disabled or not, what CSS class
    it should have, a method to run, and the title.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `code` section:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we are doing the same thing as with the `BlogTextbox`, and we bring in
    the `EditContext`, which we will use in just a bit.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also have a `RenderFragment` for the content of the button.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following code:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we add a couple of `private` fields that we will use in the component,
    then we add a property for whether the button is disabled or not. It will use
    `EditContext` to check whether there are any errors in the form, save those errors
    in a variable, and if the form is OK, enable the button, and if it is not, disable
    the button. There is a downside to this implementation; for the validation to
    trigger, we need to click somewhere else on the page to trigger the change in
    the field. So, now, the button will be disabled if the form is not OK.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This code will get a `Title` for the button and it will be shown when hovering
    your mouse over the button. We can also set a `HelpText` or a disabled help text.
    If the function is disabled for any reason, it might not have anything to do with
    the for we will show a text that explains why the button is disabled. It will
    also add any form errors to the button so it is easy to understand what form element
    is the problem without having to scroll to the element.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to use the button, but without a form, simply executing
    a method. Add the following code:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we have a delegate for `OnClick`, we want the button to simply be a button.
    If we don’t have a delegate, we assume the button is used inside of an `EditForm`.
    When the button is clicked, the `OnButtonClick` method will run.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we get to the really juicy part. Let’s add an `enum`; we can add it in
    the `code` section:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Notice that we are not using vocabulary like primary or danger – that’s Bootstrap
    lingo. What we want to know is what the button is used for. When we add a button,
    what is the most likely scenario in which the button will be used?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a parameter for `ButtonType` like this:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We add a parameter for `ButtonType` and an internal property that translates
    the “Save” use case, for example, to a Bootstrap CSS class.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our team doesn’t have to bother remembering which Bootstrap class they should
    use; they know it’s a button, and they know what the button is used for. The component
    takes care of the rest.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s test it out!
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, in the `Pages/Admin` folder, open `TagList.razor.`
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you run the project now, you will see that the button is disabled if we haven’t
    made any changes to the form, and will become enabled if we add something to the
    textbox.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s do the same for the `CategoryList`. In the `SharedComponents` project,
    in the folder `Pages/Admin`, open `CategoryList.razor`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There are more places we can modify and add this button to, but let’s not spend
    time on that for now. If you want, you can return to this and make sure we are
    using the new button and `InputText` everywhere.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: We have one more component to build.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Locking the navigation
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 7, we got a new component called `NavigationLock`. Right now, if we
    write a blog post and click somewhere in the menu, our changes will be lost. The
    same thing happens if we change the URL and press *Enter*. With `NavigationLock`,
    we can prevent that from happening.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigationLock` can prevent us from leaving the page and navigating to another
    page in our site. In that case, we can show a custom message using JavaScript.
    If we navigate to another site, it can trigger a warning, but we don’t have control
    over the message shown. This functionality is built into the browser.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement this in the same way we did with `FieldCssClassProvider`,
    as a reusable component. We want to check whether our `EditContext` has any changes
    made so we can trigger the navigation lock:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `ReusableComponents` folder, add a
    new Razor component and name it `BlogNavigationLock.razor`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the component, add the following code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We inject an `IJSRuntime` to make JavaScript calls. We will return to JavaScript
    interop in *Chapter 10*, *JavaScript Interop*.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also implement the `IDisposable` interface.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We have a `CascadingParameter`, which gets the current `EditContext`, just as
    we did with `FieldCssClassProvider`.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also added a string that is the message shown when we try to navigate from
    the page.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a change happens in the `EditContext`, we need to update the component
    and make sure it locks the navigation. Add the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We start to listen for field changes, and if a field changes, we call the `StateHasChanged`
    method to update the component.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`InvokeAsync` is needed since the call comes from another thread.'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also override the `Dispose` method and remove the event listener.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `code` section, add the following code:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This method will make a JavaScript call if there are changes in the `EditContext`
    (or model), showing a confirm dialog and the message we added. If we do not confirm,
    the navigation will be prevented.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can add the `NavigationLock` component. Just under the directives,
    add the following code:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This `NavigationLock` component will prevent external navigation (navigating
    to another site) and internal navigation (navigating to another page in our blog).
    It checks whether the `EditContext` (model) has any changes and prevents external
    navigation. On internal navigation, it will execute the `OnBeforeInternalNavigation`
    method, which checks whether the `EditContext` has been changed.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we only have one more thing to do.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Pages/Admin/BlogPostEdit.razor`, add the new Razor component we created
    just below the `CustomCssClassProvider`:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will get the `EditContext` from the cascading value, and execute the code
    we just wrote.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following:'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the `code` section, add the following:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the `SavePostAsync` method, just before navigating to `admin/blogposts`,
    add the following:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When saving the object, the `EditContext` doesn’t know that, so we are telling
    the `EditContext` that the model is now unmodified, so the navigation should not
    be stopped.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another site (it should work).
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another page (it should work).
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the blog post.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another site (it should show a message box).
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another page. You might notice that, in our case, it doesn’t
    show a message box when we navigate to another page. What is up with that? It
    seems to be a limitation in how this component works. If we were running `InteractiveServer`
    or `InteractiveWebAssembly`, it would work. Navigation using static server rendering
    (which is what happens when we navigate) won’t trigger the navigation change.
    If we want to test this, we can change our project to run as Blazor Server.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, in the `Components` folder, open the `App.razor`
    file.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the following line:'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Replace the preceding line with the following line:'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we can try it again:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the site, navigate to `Admin/BlogPosts`, and click a blog post.
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another site (it should work).
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to navigate to another page (it should work).
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the blog post.
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another site (it should show a message box).
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Try navigating to another page (it should show a message box).
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, change it back to `<Routes />`.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The point of this is to show that, in some cases, the built-in components will
    act differently depending on the render mode. I honestly think that this is a
    bug rather than a feature, but there are discussions about this.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We have implemented another reusable component. Next, let’s take a
    look at how we can use a form with a static server-side rendered component using
    enhanced form navigation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced Form Navigation
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET 8, we got server-side rendering. Adding interactivity to a component
    is simple, as we have seen. But sometimes we just want a form and a submit button.
    Do we really have to enable WebAssembly or a SignalR connection for this? I’m
    glad you asked! The answer is, no, we don’t.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a component to showcase that our blog posts need comments:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SharedComponents` project, in the `Pages` folder, add a new Razor component
    called `Comments.razor`. This component should do two things: list comments and
    create a new comment.'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `comments` file, replace the content with the following:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This is a list of comments and some bootstrap classes to make it look better.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continue by adding the form:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We are still using an `EditForm` just as before and an `OnValidSubmit` property.
    There are some things that are new here, though. We are specifying the method
    we are using to post the form – in this case, a post method. We are also naming
    the form with the `FormName` parameter. These two properties must be there. We
    are using the `DataAnnotationValidator` and the `CustomCssClassProvider` we created
    earlier. We are even using the `BlogInputText`. But since this component isn’t
    interactive, our button will not work as it is disabled by default, and if we
    remove the interactivity, it will stay disabled. So, in this case, we have to
    add a button the old-fashioned way. We can make sure that there is a non-interactive
    button for cases like this as well.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it is time for the code part of the form:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we are using a parameter so that our component knows what blog post to
    show comments for. It has `EditorRequired`, so Visual Studio will warn you if
    it is missing. The `Model` parameter has the `SupplyParameterFromForm` attribute,
    which is required. This is so Blazor knows what property to fill with data when
    the form is posted. The rest of the code is the same as the code we have used
    previously.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Post.cs` and add the following code just beneath the line @((MarkupString)Markdig.Markdown.ToHtml(BlogPost.Text,
    pipeline)):'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: So, what is happening?
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we submit our form, the component will be rerendered, creating a new instance
    of the component and filling the (in our case) `Model` parameter with the data
    from the post. With interactive components, `OnInitialized` and `OnInitializedAsync`
    will only run once (unless we are running prerendering). With these static components,
    it will reload the component. But we also get a “problem” because the scrolling
    positions get lost when the page reloads. We will now find ourselves at the top
    of the page, which is not a great user experience. Luckily, there is a solution;
    this is where the `Enhance` part comes in. By adding `Enhance` to our form, it
    will now keep its scroll position after posting the page. Pretty neat, right?
    We can also use a normal form instead of an `EditForm`.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It would then look something like this:'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Instead of `Enhance`, we add `data-enhance`. Personally, I prefer to use an
    `EditForm` where I can, but it might be good to know that there are options.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use `data-permanent` to keep the information in the form fields
    for a search parameter, for example. This way, the enhanced navigation will not
    update that data when the response is returned. How many times have we used a
    search field, misspelled something, and then the search field is empty and we
    need to retype everything? This is where `data-permanent` saves us.
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Amazing!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: This has been a heavy chapter, but wow, we have done so much – a whole bunch
    of new and reusable components and a complete admin interface.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught us how to create forms and make API calls to get and save
    data.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: We built custom input controls and got Bootstrap styling on our controls. Most
    business apps use forms; we can add logic close to the data by annotating data.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了自定义输入控件，并给我们的控件添加了Bootstrap样式。大多数商业应用程序都使用表单；我们可以通过注释数据来在数据附近添加逻辑。
- en: We also created multiple reusable components and used many of the things we
    discussed in previous chapters. We even touched on JavaScript interop, which we
    will go into more detail about in *Chapter 10*, *JavaScript Interop*.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了多个可重用组件，并使用了之前章节中讨论的许多内容。我们甚至触及了JavaScript互操作性的话题，我们将在*第10章*，*JavaScript互操作性*中对其进行更详细的介绍。
- en: The functionality that Blazor offers when it comes to validation and input controls
    will help us build amazing applications and give our users a great experience.
    You may notice that, right now, the admin pages are wide open. We need to secure
    our blog with a login, but we will come to that in *Chapter 8*, *Authentication
    and Authorization*.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor在验证和输入控件方面的功能将帮助我们构建令人惊叹的应用程序，并为我们的用户提供极佳的体验。你可能已经注意到，目前管理页面是开放的。我们需要通过登录来保护我们的博客，但这一点将在*第8章*，*认证和授权*中详细说明。
- en: In the next chapter, we will create a web API to get data when we are running
    components such as `InteractiveAuto` or `InteractiveWebAssembly`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建一个Web API，以便在运行`InteractiveAuto`或`InteractiveWebAssembly`等组件时获取数据。
