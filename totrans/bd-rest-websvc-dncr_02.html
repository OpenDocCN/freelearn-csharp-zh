<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building the Initial Framework – Laying the Foundation of the Application</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we talked about REST, its characteristics, and how it is implemented in ASP.NET Core. We will go ahead with that knowledge and set up the environment to develop an application in this chapter.</p>
<p>We will start building the basic framework of the app. We will understand each and every HTTP verb, how they work, and their implementation paradigms in ASP.NET Core Web API. Before all that, we will have a quick look at SOAP and how it is different from REST.</p>
<p>While we walk though the verbs, we will explore a very easy-to-use tool to analyze the HTTP requests and responses.</p>
<p>We will cover the following topics:</p>
<ul>
<li>All about web services (REST and SOAP)</li>
<li>Running the development server</li>
<li>REST verbs and status codes</li>
<li>Implementation of verbs in ASP.NET Core Web API</li>
<li>Examples using Postman</li>
<li>SOAP versus REST</li>
<li>Single-page application model with REST API</li>
<li>Service-oriented architecture (SOA) overview with REST</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOAP</h1>
                </header>
            
            <article>
                
<p><strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) is an XML-based messaging protocol for exchanging information among computers. SOAP relies on application layer protocols, most often <strong>Hypertext Transfer Protocol</strong> (<strong>HTTP</strong>) or <strong>Simple Mail Transfer Protocol</strong> (<strong>SMTP</strong>), for message negotiation and transmission. As we are talking about HTTP, which is installed and runs on every operating system, web services implementing SOAP can be called from any platform using any language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOAP structure</h1>
                </header>
            
            <article>
                
<p>We already know that a SOAP message is an XML document, but let's have a better look by way of a diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad718f4f-5d99-4e2e-893e-eb665dc02a08.png" style="width:20.33em;height:15.00em;"/></div>
<p>The following is a description of the components from the preceding diagram:</p>
<ul>
<li class="mce-root"><strong>Envelope</strong>: Mandatory element of SOAP message structure. Defines the start and the end of the message.</li>
<li class="mce-root"><strong>Header</strong>: Optional element of the SOAP message. It contains information regarding the SOAP message that can be used to process the data.</li>
<li class="mce-root"><strong>Body</strong>: This is the main part, which contains the actual message in XML structure. Obviously, it is a mandatory element.</li>
<li class="mce-root"><strong>Fault</strong>: If any errors occur while processing the SOAP message, an optional Fault element can be used to provide information about them.</li>
</ul>
<p>You must be thinking who exactly told us to follow this type of structure. Well, there is an organization named W3 that proposes standards for particular technologies. They have done the same for the SOAP structure.</p>
<p>You can easily find details about the SOAP envelope at <a href="http://www.w3.org/2001/12/soap-envelope">http://www.w3.org/2001/12/soap-envelope</a>. Likewise, you can see details about SOAP encoding and data types at <a href="http://www.w3.org/2001/12/soap-encoding">http://www.w3.org/2001/12/soap-encoding</a>.<a href="http://www.w3.org/2001/12/soap-encoding"/></p>
<div class="mce-root packt_infobox">Whatever we discuss about the structure of the SOAP message is defined by the W3 organization. However, this organization constantly investigates ways to optimize structures and bring in more robust specifications from time to time. So, we have to update with the latest specifications provided by them and implement them accordingly. </div>
<p>The following block depicts the general structure of a SOAP message:</p>
<pre class="mce-root">&lt;?xml version = "1.0"?&gt;<br/>&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV = "http://www.w3.org/2001/12/soap-envelope" <br/> SOAP-ENV:encodingStyle = "http://www.w3.org/2001/12/soap-encoding"&gt;<br/>  &lt;SOAP-ENV:Header&gt;<br/>    ...<br/>    ...<br/>  &lt;/SOAP-ENV:Header&gt;<br/>  &lt;SOAP-ENV:Body&gt;<br/>    ...<br/>    ...<br/>    &lt;SOAP-ENV:Fault&gt;<br/>      ...<br/>      ...<br/>    &lt;/SOAP-ENV:Fault&gt;<br/>    ...<br/>  &lt;/SOAP-ENV:Body&gt;<br/>&lt;/SOAP_ENV:Envelope&gt;</pre>
<p>The receiver is notified about the whole SOAP message with the indication of an envelope. What this means is, if the message received by the client has an envelope inside it, then the message is completely received and the client can parse and use it for further processing. Thus, the SOAP envelope plays the role of packaging the whole message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Important points about SOAP</h1>
                </header>
            
            <article>
                
<p>The following are some important points about SOAP:</p>
<ul>
<li class="mce-root"><kbd>Envelope</kbd> in every SOAP message has the root position and that is mandatory for all SOAP messages.</li>
<li class="mce-root">Exactly one body element should be present inside one SOAP envelope.</li>
<li class="mce-root">The <kbd>Header</kbd> element is an optional element. However, if that is present, then there should be only one <kbd>Header</kbd> element.</li>
<li class="mce-root">The <kbd>Header</kbd> must appear as the first child of the envelope, before the body element.</li>
<li class="mce-root">The <kbd>ENV</kbd> namespace prefix and the <kbd>Envelope</kbd> element are used in order to build one SOAP envelope. (Refer to the following example.)</li>
<li class="mce-root">The <kbd>encodingStyle</kbd> attribute defines the data types used in the document. This gives a generalization of the data types that appear in the message. If this attribute appears on any SOAP element, it will apply the encoding rules to the element's contents and all child elements.</li>
</ul>
<p class="mce-root">The following is an example of a v1.2-compliant SOAP message:</p>
<pre class="mce-root">&lt;?xml version = "1.0"?&gt;<br/>&lt;SOAP-ENV:Envelope <br/> xmlns:SOAP-ENV = "http://www.w3.org/2001/12/soap-envelope" <br/> SOAP-ENV:encodingStyle = "http://www.w3.org/2001/12/soap-encoding"&gt;<br/> ...<br/> SOAP Message information goes here<br/> ...<br/>&lt;/SOAP-ENV:Envelope&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOAP with HTTP POST</h1>
                </header>
            
            <article>
                
<p class="mce-root">The <kbd>Authors</kbd> mentioned in the HTTP header is actually the URL of the controller or program to be invoked that have a <kbd>POST</kbd> action method inside it. Everything is hosted at <a href="http://www.packtpub.com">www.packtpub.com</a>.</p>
<pre class="mce-root">POST /Authors HTTP/1.1<br/>Host: www.packtpub.com<br/>Content-Type: application/soap; charset="utf-8"<br/>Content-Length: nnnn<br/><br/>&lt;?xml version = "1.0"?&gt;<br/>&lt;SOAP-ENV:Envelope <br/>xmlns:SOAP-ENV = "http://www.w3.org/2001/12/soap-envelope" <br/>SOAP-ENV:encodingStyle = " http://www.w3.org/2001/12/soap-encoding"&gt;<br/>  ...<br/>  Message information goes here<br/>  ...<br/>&lt;/SOAP-ENV:Envelope&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST</h1>
                </header>
            
            <article>
                
<p>REST is an architectural style for providing standards between computer systems on the web, so that systems can communicate with each other easily. Services compliant to the REST style are often called RESTful services.</p>
<p>Let's talk about a few important constraints of a web service when it is tagged as RESTful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server and client are independent</h1>
                </header>
            
            <article>
                
<p>With REST, there is no restriction or dependency between server and client. Both can be independent of each other. It's just the URL by which the client understands the service. The code for a web service on a server can be modified without caring about the clients that are associated with it and vice versa.</p>
<p>This kind of separation helps the client/server architecture to breathe freely without any hurdles. Therefore, designing the application and separating its core business logic becomes easy. What I mean by that is simple. Designing the app can be done using client-side technologies and the RESTful web service is invoked wherever there is a necessity for business-related operations in a database.</p>
<p>However, keeping both server and client modular and separate depends on one condition and that is the format of the messages they send and receive. Both of them should be aware of the message format to send and receive.</p>
<p>As the user interface is separated from the business-and data-storage-related operations, flexibility and scalability can be improved by simplifying the server components. Moreover, the separation allows each component to evolve independently.</p>
<p class="mce-root">REST endpoints are exposed by certain URLs. Different clients can connect using the URL, then perform the action intended and get the response back.</p>
<p>In this book, we will build a small e-commerce web service with minimal operations, where a user can use a cart and make orders. These operations will be exposed using endpoints. As we discussed, endpoints can be easily consumed from different types of clients including mobile apps, web apps, server-side code, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Statelessness</h1>
                </header>
            
            <article>
                
<p>The concept is very easy to understand. In a server/client architecture, the server needs to know which client is requesting data from it and, accordingly, it decides what to send and what not to send.</p>
<p>However, REST systems are stateless. That means the server does not need to know anything about the client's state and vice versa. That would eventually remove the overhead on the server to identify the client each time a request comes in.</p>
<p>But now the question is, how do the client and server interact? The answer is through appropriate messages. Suppose a user wants to see one order detail. It would simply ask the server by sending the ID of the order and the server would return the order details in either <kbd>.json</kbd><span><span> or </span></span><kbd>.xml</kbd> format, which can be easily parsed by the client. Every message has the required information for how to deal with that. </p>
<p>These constraints (along with a few other constraints such as <em>caching</em>, <em>layered system</em>, <em>uniform interface</em>, and <em>code on demand</em>) when implemented on a web service help RESTful applications achieve reliability, optimized performance, and scalability. The reason being that components can be managed independently, updated flawlessly, and reused without affecting the system as a whole.</p>
<p class="mce-root">Let's look at exactly how communication takes place between the server and client in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the environment</h1>
                </header>
            
            <article>
                
<p>Before we explore the communication mechanism, let's first set up the development environment. We will use Visual Studio 2017 for our examples.</p>
<p>Open Visual Studio and undertake our favorite step, <span class="packt_screen">File | New | Project</span>, which opens up a dialog window with available templates, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/942c014e-419a-4f13-ad2a-952404753a71.png"/></div>
<p>Select <span class="packt_screen">ASP.NET Core Web Application</span> as shown in the preceding screenshot. Don't forget to select <span class="packt_screen">.NET Core</span> in the left-hand side panel. Everything looks cool now.</p>
<p>Let's click <span class="packt_screen">OK</span> and then we will land on another dialog where we can select more templates related to our web app. Obviously, we will click on <span class="packt_screen">Web API</span> and then click <span class="packt_screen">OK</span>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65a05503-18af-4f76-85b3-7546b4c189b5.png"/></div>
<p>The project is created. Beautifully, it has crafted all the necessary components and created an example controller for us named <kbd>ValuesController</kbd> as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/970fa804-0df1-455c-b192-a74719363e49.png"/></div>
<p>Now, here is one interesting fact. Notice that the <kbd>ValuesController</kbd> class inherits the <kbd>Controller</kbd> base class. If you were familiar with Web API in ASP.NET before Core, you might know that the base class was <kbd>ApiController</kbd> instead. The reason behind this change is to have a uniformity between API and MVC structures. <kbd>Controller</kbd> was the base class in ASP.NET MVC. Now in ASP.NET Core, both MVC and Web API templates inherit the same base class. With ASP.NET Core, MVC and Web API are merged into one programming model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>To make sure everything is working fine, let's run the application.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/069f0012-8421-4563-8ce5-29f9cfcbdd07.png"/></div>
<p>Let's discuss what has just happened in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What's cooking here?</h1>
                </header>
            
            <article>
                
<p>Notice the URL, <kbd>localhost:57571/api/values</kbd>, which sends the request to <kbd>ValuesController</kbd> because the route defined over the controller is <kbd>[Route("api/[controller]")]</kbd>. By convention, the controller name is always appended with the text <em><span class="packt_screen">Controller</span></em>. Thus <kbd>api/values</kbd> hits <kbd>ValuesController</kbd>.</p>
<p>Now the question is, how it returns <kbd>value1</kbd> and <kbd>value2</kbd>. That is because we directly accessed the URL through the browser, which ultimately sent a <kbd>GET</kbd> request to the controller. As the controller already has a <kbd>Get</kbd> method, it got executed. The <kbd>Get</kbd> method is as follows:</p>
<pre>// GET api/values<br/>[HttpGet]<br/>public IEnumerable&lt;string&gt; Get()<br/>{<br/>  return new string[] { "value1", "value2" };<br/>}</pre>
<p>This method returns an array of strings, which is printed in the browser. For understanding, the URL format is already there above the method <em>(</em><kbd>api/values</kbd><em>)</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interesting facts</h1>
                </header>
            
            <article>
                
<p>Let's experiment with a few things now. You will get a very good insight into what happens behind the scenes:</p>
<ol>
<li>Add another method, <kbd>Get12()</kbd>, to the controller and remove the <kbd>[HttpGet]</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">public IEnumerable&lt;string&gt; Get12()<br/>{<br/>  return new string[] { "value1", "value2", "value3" };<br/>}<br/>// GET api/values<br/>//[HttpGet] - Remove this attribute<br/>public IEnumerable&lt;string&gt; Get()<br/>{<br/>  return new string[] { "value1", "value2" };<br/>}</pre>
<p style="padding-left: 60px">What do you think the output would be? It's interesting. Here is the output:</p>
<div class="CDPAlignCenter CDPAlign" style="color: black;font-size: 1em"><img src="assets/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png" style="font-size: 1em;"/></div>
<p class="mce-root" style="padding-left: 60px"><span>That means it found two <kbd>GET</kbd> methods and it was not able to decide which one to execute. Note that neither of them is decorated by an attribute, such as</span> <kbd>[HttpGet]</kbd><span>.</span></p>
<ol start="2">
<li>Now let's plan to bring back the attribute and test what happens. However, we will decorate the new <kbd>Get12</kbd> method and leave the old <kbd>Get</kbd> method intact with the attribute commented. So, the code would be:</li>
</ol>
<pre style="padding-left: 60px">[HttpGet]<br/>public IEnumerable&lt;string&gt; Get12()<br/>{<br/>  return new string[] { "value1", "value2", "value3" };<br/>}<br/>// GET api/values<br/>//[HttpGet]<br/>public IEnumerable&lt;string&gt; Get()<br/>{<br/>  return new string[] { "value1", "value2" };<br/>}</pre>
<p style="padding-left: 60px">Let's have a quick look at what we did to the output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/44d0405c-533e-4096-99f8-ab9938248849.png"/></div>
<p style="padding-left: 60px">Clear enough! The <kbd>Get12</kbd> <span>method was executed and the reason for this was that we explicitly told it that it was the <kbd>Get</kbd> method by way of the</span> <kbd>[HttpGet]</kbd> attribute.</p>
<ol start="3">
<li>More fun can be experienced by adding an attribute to both of the methods:</li>
</ol>
<pre style="padding-left: 60px">[HttpGet]<br/>public IEnumerable&lt;string&gt; Get12()<br/>{<br/>  return new string[] { "value1", "value2", "value3" };<br/>}<br/>// GET api/values<br/>[HttpGet]<br/>public IEnumerable&lt;string&gt; Get()<br/>{<br/>  return new string[] { "value1", "value2" };<br/>}</pre>
<p style="padding-left: 60px">Can you guess the output? Yes, it is the same as we saw when we had both methods without the attribute <strong>AmbiguousActionException</strong><span> as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dea1eca8-9d5a-4494-a68d-97c3e164e9e2.png"/></div>
<ol start="4">
<li>Finally, let's have another method named <kbd>HelloWorld()</kbd> with the attribute along with the existing ones. Let's remove the attributes from the other ones:</li>
</ol>
<pre style="padding-left: 60px">[HttpGet]<br/>public string HelloWorld()<br/>{<br/>  return "Hello World";<br/>}<br/>public IEnumerable&lt;string&gt; Get12()<br/>{<br/>  return new string[] { "value1", "value2", "value3" };<br/>}<br/>// GET api/values<br/>public IEnumerable&lt;string&gt; Get()<br/>{<br/>  return new string[] { "value1", "value2" };<br/>}</pre>
<p style="padding-left: 60px">Perfect! Let's see the output. It's <span class="packt_screen">Hello World</span><span> in the browser:</span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><img src="assets/9de3bc08-6ea3-4602-aed1-01ebf59429fc.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Conclusions</h1>
                </header>
            
            <article>
                
<p>The following conclusions can be made from the preceding observation. Note that we are talking about <kbd>GET</kbd> requests with the URL <kbd>api/values</kbd>, which means we are talking about all nonparameterized action methods in the controller. While reading the following points, ignore methods with parameters or other attributes:</p>
<ul>
<li>When we access a particular Web API controller without any parameters (for example, <kbd>api/values</kbd>), action methods with the <kbd>[HttpGet]</kbd> attribute are searched first from the controller.</li>
<li>If an attribute is not mentioned in nonparameterized methods, then the .NET Core runtime will get confused when selecting one action method for the request.</li>
<li>There is no restriction on the naming convention of the action method. As long as it is the only method with no <kbd>[HttpGet]</kbd> attribute or the only method with an <kbd>[HttpGet]</kbd> attribute, it would be perfectly executed when <kbd>GET request</kbd> comes to the API.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request and response</h1>
                </header>
            
            <article>
                
<p>Now that we have had a quick look at the demo <kbd>ValuesController</kbd>, let's examine exactly how the client sends the request and how it receives the response.</p>
<p>A REST request generally consists of the following:</p>
<ul>
<li class="mce-root"><strong>HTTP verb:</strong> This denotes what kind of operation the requests want to perform on the server.</li>
<li class="mce-root"><strong>Header:</strong> This element of the REST request allows the client to pass more information about the request.</li>
<li class="mce-root"><strong>URL:</strong> The actual path to the resource that the REST request wants to operate on.</li>
<li class="mce-root"><strong>Body:</strong> The body can contain extra data related to a resource to identify or update it. This is optional though.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP verbs</h1>
                </header>
            
            <article>
                
<p class="mce-root">The following are basic HTTP verbs used while requesting a REST system for resource interaction:</p>
<ul>
<li class="mce-root"><strong>GET:</strong> Used to retrieve a specific resource by its identity or a collection of resources</li>
<li class="mce-root"><strong>POST:</strong> Used to create/insert a new resource</li>
<li class="mce-root"><strong>PUT:</strong> Used to update a specific resource by its identity</li>
<li class="mce-root"><strong>DELETE:</strong> Used to remove a specific resource by its identity</li>
</ul>
<p>Let's try to explore the request/response mechanism in REST for these verbs one by one. We will try to design an e-commerce application with basic operations. In the first phase, we will work on products, which is the core of these types of apps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Postman</h1>
                </header>
            
            <article>
                
<p>To test the API, we can use a very easy-to-use tool named <em>Postman</em>. It can be downloaded from: <a href="https://www.getpostman.com/">https://www.getpostman.com/</a>. Please download and open it. We will see how to send requests through Postman and analyze responses we get from Web API in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">GET</h1>
                </header>
            
            <article>
                
<p>I will add another controller called <kbd>ProductsController</kbd>. For now, let's have a simple action method, <kbd>GET</kbd>, which will return some products. The products are hard-coded in the action method for now. The method will look like the following:</p>
<pre>using Microsoft.AspNetCore.Mvc;<br/>using System.Collections.Generic;<br/>namespace DemoECommerceApp.Controllers<br/>{<br/>  [Produces("application/json")]<br/>  <strong>[Route("api/[Controller]")]</strong><br/>  public class ProductsController : Controller<br/>  {<br/>    // GET: api/Products<br/>    <strong>[HttpGet]</strong><br/>    public IEnumerable&lt;Product&gt; Get()<br/>    {<br/>      return new Product[]<br/>      {<br/>        new Product(1, "Oats", new decimal(3.07)),<br/>        new Product(2, "Toothpaste", new decimal(10.89)),<br/>        new Product(3, "Television", new decimal(500.90))<br/>      };<br/>    }<br/>  }<br/>}</pre>
<p>The <kbd>[Route]</kbd> attribute is provided with a well-defined template of  <kbd>"api/[Controller]"</kbd>. Here, the controller name is <kbd>ProductsController</kbd>. When we request using the URL <kbd>api/Products</kbd>, the framework will search for a controller with that route defined on it. The <kbd>[Controller]</kbd> placeholder is a special naming convention that will be replaced with the text (name of controller) <kbd>Products</kbd> at runtime. However, you can directly write the fully qualified template with the controller name, such as <kbd>[Route (api/Products)]</kbd>.</p>
<p>So, this <kbd>GET</kbd> method will return us three products with their details. The <kbd>Product</kbd> class can be designed, like the following, with a constructor to build <em>Product</em> objects:</p>
<pre>public class Product<br/>{<br/>  public Product(int id, string name, decimal price)<br/>  {<br/>    Id = id;<br/>    Name = name;<br/>    Price = price;<br/>  }<br/>  public int Id { get; set; }<br/>  public string Name { get; set; }<br/>  public decimal Price { get; set; }<br/>}</pre>
<p>We are done. Let's do a <kbd>GET request</kbd> through <em>Postman</em> to analyze the request and response mechanism in REST. For a <kbd>GET request</kbd>, it's simple. Just open Postman. Then follow the steps mentioned in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/619271a2-f6d7-4240-a326-96f485df93d3.png"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Executing GET request in Postman</div>
<p>In <strong>Step-1</strong>, just paste the URL, which is <kbd>http://localhost:57571/api/products</kbd> for our example. Everything else is already set for a <kbd>GET</kbd> request. You can see the request type to the left of the URL box, which is <kbd>GET</kbd>. That means the current request will be a <kbd>GET</kbd> request. Hit the <span class="packt_screen">Send</span> button as shown in <strong>Step-2</strong>.</p>
<p>The response is a list of products shown inside the section at the bottom. It's in <kbd>.json</kbd> format. Please refer to the following screenshot, which displays the response of the <kbd>GET</kbd> request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17867f88-93d2-46ef-987f-2ce009fa1106.png"/></div>
<p>Now that you have had a pleasant look at how <kbd>GET</kbd> works, let's analyze what happens behind the scenes. The client, which is <em>Postman</em> here, sends an HTTP request and gets a response in return. While sending requests it also specifies the Request Headers, and the server, in return, sends the Response Headers.</p>
<div class="packt_infobox">HTTP Headers enable the client and server to both send and receive additional information with the request and response respectively. This decides the exact behavior of the HTTP transaction. You can refer to the following resources to learn more about the headers. We will have a quick look at the headers in the next section:<br/>
<ul>
<li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers</a></li>
</ul>
</div>
<p>In Postman, you can click on <span class="packt_screen">Code<strong>,</strong></span> as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7a7fe2db-4d7b-4326-90bf-a2365cae80ee.png"/></div>
<p>Clicking on this link will open one modal that will show you the HTTP Request Headers sent to the server to serve the request. Check out the following screenshot of the modal, which clearly mentions the Request Type as <kbd>GET</kbd>, <kbd>Host</kbd> as the URL of the API, and then other headers such as <kbd>Cache-Control</kbd> and <kbd>Postman-Token</kbd>: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9d077605-65eb-4f0c-b7d7-b6d2cbe02ff6.png"/></div>
<p class="CDPAlignLeft CDPAlign">Want to know what the <em>jQuery</em> code snippet looks like for this <kbd>GET</kbd> call? It's super-easy with Postman. Click on <span class="packt_screen">Code</span> on the main screen, then from the drop-down menu containing languages, select <em><span class="packt_screen">jQuery</span></em>. (See the following screenshot.) Moreover, you can get code in different languages by selecting from the drop-down list. Happy copying!</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e9a0b8cb-9885-4c77-a57e-17f420a0974a.png" style="width:46.33em;height:21.50em;"/></div>
<p><em>Response Header</em> is clearly shown on the main page, as shown in the following screenshot. Notice that there is a <span class="packt_screen">Status</span> code mentioned, which is <span class="packt_screen">200 OK</span> in this case. So, what does this code signify?</p>
<p>Let's talk about it in the next section.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17c42408-1b22-4bdd-9665-6f0052afbb7d.png"/></div>
<div class="mce-root CDPAlignCenter CDPAlign packt_figref">Postman Response Headers</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Status codes</h1>
                </header>
            
            <article>
                
<p>When a server returns responses, it includes status codes. These status codes inform the client how the request performed on the server. As a developer, you do not need to know every status code (there are many of them), but you should know the most common ones and how they are used:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Status Code</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr>
<td><span class="packt_screen">200 OK</span></td>
<td>Standard response for successful HTTP requests.</td>
</tr>
<tr>
<td><span class="packt_screen">201 CREATED</span></td>
<td>Standard response for an HTTP request when an item is successfully created.</td>
</tr>
<tr>
<td><span class="packt_screen">204 NO CONTENT</span></td>
<td>Standard response for successful HTTP requests, if nothing is returned in the response body.</td>
</tr>
<tr>
<td><span class="packt_screen">400 BAD REQUEST</span></td>
<td>Request cannot be processed because of bad request syntax, excessive size, or another client error.</td>
</tr>
<tr>
<td><span class="packt_screen">403 FORBIDDEN</span></td>
<td>Client does not have permission to access the requested resource.</td>
</tr>
<tr>
<td><span class="packt_screen">404 NOT FOUND</span></td>
<td>Resource could not be found at this time. It might have been deleted, or does not exist yet.</td>
</tr>
<tr>
<td><span class="packt_screen">500 INTERNAL SERVER ERROR</span></td>
<td>This response comes whenever there is a failure or exception happens while processing the server side codes.</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">Some status codes are (by default) expected from the server for the following HTTP verbs:</p>
<ul>
<li class="mce-root"><kbd>GET</kbd>: Returns <span class="packt_screen">200 OK</span></li>
<li class="mce-root"><kbd>POST</kbd>: Returns <span class="packt_screen">201 CREATED</span></li>
<li class="mce-root"><kbd>PUT</kbd>: Returns <span class="packt_screen">200 OK</span></li>
<li class="mce-root"><kbd>DELETE</kbd>: Returns <span class="packt_screen">204 NO CONTENT</span> if the operation failed</li>
</ul>
<p>We already saw how API returned <span class="packt_screen">200 OK</span> for the <kbd>GET</kbd> request. As we move forward with other verbs, we will explore the responses returned with the codes mentioned previously.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ASP.NET Core HTTP attributes</h1>
                </header>
            
            <article>
                
<p>According to the <em>Internet Engineering Task Force (IETF) RFC-7231</em> document (<a href="https://tools.ietf.org/html/rfc7231">https://tools.ietf.org/html/rfc7231</a>), ASP.NET Core has implemented seven HTTP attributes out of the eight HTTP verbs listed. The only exclusion in the framework, from the list of verbs, is the HTTP TRACE verb.</p>
<p>Following is the complete list of HTTP verb attributes that are provided in ASP.NET Core:</p>
<ul>
<li class="mce-root"><kbd>HttpGetAttribute</kbd></li>
<li class="mce-root"><kbd>HttpPostAttribute</kbd></li>
<li class="mce-root"><kbd>HttpPutAttribute</kbd></li>
<li class="mce-root"><kbd>HttpDeleteAttribute</kbd></li>
<li class="mce-root"><kbd>HttpHeadAttribute</kbd></li>
<li class="mce-root"><kbd>HttpPatchAttribute</kbd></li>
<li class="mce-root"><kbd>HttpOptionsAttribute</kbd></li>
</ul>
<p>As the verb name is attached with the attribute, it is very obvious that they will be used for their respective verbs. These attributes help the framework to understand what action method is associated with what verb. With that in mind, it can decide which one to execute when a request comes for the controller.</p>
<p class="mce-root">Another important attribute for routing is also provided by the framework, named <kbd>RouteAttribute</kbd>.</p>
<p>There are a few more attributes used for the parameters of action methods to help recognize parameters passed to the API action from different places of the request such as URL, Body, and so on. Following are some attributes present in the framework for the action parameters:</p>
<ul>
<li class="mce-root"><kbd>FromServicesAttribute</kbd></li>
<li class="mce-root"><kbd>FromRouteAttribute</kbd></li>
<li class="mce-root"><kbd>FromQueryAttribute</kbd></li>
<li class="mce-root"><kbd>FromBodyAttribute</kbd></li>
<li class="mce-root"><kbd>FromFormAttribute</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">POST</h1>
                </header>
            
            <article>
                
<p>POST is used to create a resource. In our case, we will try to create a product using a POST request to the server. Before doing that, we will make a few changes to our project. You can find all related code on GitHub (<a href="https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-services-with-DOTNET-Core</a>), so don't worry at all!</p>
<p>Why wait then? Let's write the Post method as follows:</p>
<pre> // POST: api/Products<br/>[HttpPost]<br/>public async Task&lt;IActionResult&gt; Post([FromBody]Product product)<br/>  =&gt; (await _productService.CreateProductAsync(product))<br/>    ? (IActionResult)Created($"api/products/{product.Id}", product) // HTTP 201<br/>    : StatusCode(500); // HTTP 500</pre>
<p>The action method calls <kbd>CreateProductAsync</kbd> of the related service and checks if the operation was successful. If successful, it sends back <kbd>201</kbd>, else <kbd>500</kbd>. Note that to send back the correct status code, we are leveraging the <kbd>IActionResult</kbd>. This interface has a large set of subclasses that are accessible via the <kbd>Controller</kbd> class. Since we inherit from the <kbd>Controller</kbd> base class, we can easily use methods such as <kbd>StatusCode</kbd> to return our intended status according to the operation we performed on the resource.</p>
<p>In the previous section, we mentioned that on <kbd>POST</kbd> success, we should get <span class="packt_screen">201 CREATED</span> and on failure, it should send a generalized <span class="packt_screen">500 Internal Server Error</span> response. That is what the code does.</p>
<p>There is another interesting thing, that is: <kbd>Created($"api/products/{product.Id}", product)</kbd>. This is a method inside the <kbd>Controller</kbd> class which assigns the URL to the location and 201 to the status code of the response. Don't believe me!? Okay, let me prove it by way of <em>Postman</em>, right away.</p>
<p>Have a look at the following screenshot taken from the <em>Postman</em> request screen:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/63d0c202-8c23-4619-8af2-04c5a66798fb.png"/></div>
<p>Notice that we passed the data for a product as JSON and after creating the product, the API returned us the status code as <span class="packt_screen">201 Created</span> and the URL of the new product created, which is <span class="packt_screen">api/products/1</span>. What that means is that when you run this URL as a <kbd>GET</kbd> request, you will receive the newly created product details. Simple, isn't it?</p>
<p>As you can see, the datatype of the passed product details is JSON, but the question is, who told the server that it is in that format? Well, that's the request header <kbd>content-type</kbd> set with value <span><kbd>application/json</kbd>. You can see that in the last screenshot. A default encoding of <kbd>charset=utf-8</kbd> is appended by <em>Postman</em>.</span></p>
<p><span>However, interestingly, how come <em>Postman</em> knew that we wanted the datatype content to be JSON? It can't set it automatically. I told it to do that.</span></p>
<p><span>The option to set any type of request header is just below the URL textbox. Refer to the following screenshot, which shows that I have set the <kbd>content-type</kbd> header:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae9c588d-6399-4589-9ff3-7d9b78150004.png"/></div>
<p>For the previously mentioned <kbd>GET</kbd> request, which returns the product details by ID, we can design the action method as follows:</p>
<pre>// GET: api/Products/1<br/>[HttpGet("{id}")]<br/>public Task&lt;Product&gt; Get(int id)<br/>  =&gt; _productService.GetOrderAsync(id);</pre>
<p>Here, we are providing a template argument of <kbd>"{id}"</kbd> to <kbd>[HttpGet]</kbd>. This will make sure that one HTTP Get route such as <kbd>api/orders/1</kbd> is available—where the ID is a variable passed to the <kbd>GET</kbd> request.</p>
<div class="packt_infobox">We have a service called <kbd>ProductService</kbd> which is implementing the interface <kbd>IProductService</kbd> and through the constructor of the controller, the service (dependency) is injected, which is called <em>dependency injection</em>. With .NET Core, it's very easy to handle dependencies with the built-in <em>inversion of control container</em>. If you are not getting what I am talking about, then I would highly recommend going through my other book on this topic, <em>Dependency Injection in .NET Core </em>(<a href="https://www.packtpub.com/application-development/dependency-injection-net-core-20">https://www.packtpub.com/application-development/dependency-injection-net-core-20</a>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PUT</h1>
                </header>
            
            <article>
                
<p>The HTTP PUT verb is idempotent. This means that the first HTTP PUT request with a certain payload will impact the server and the resource. It will update the resource specified by ID. However, subsequent HTTP PUT requests with the same payload would result in the same response as the first one.</p>
<p class="mce-root">Consider the following example where we will update one product:</p>
<pre>// PUT: api/Products/1<br/>[HttpPut("{id}")]<br/>public async Task&lt;IActionResult&gt; Put(int id, [FromBody]Product product)<br/>  =&gt; (await _productService.UpdateProductAsync(id, product))<br/>    ? Ok()<br/>    : StatusCode(500);</pre>
<p>The <kbd>[HttpPut]</kbd> attribute is supplied with a template of <kbd>{id}</kbd> similar to what we had in <kbd>[HttpGet]</kbd>. In the case of <kbd>PUT</kbd>, it would get the ID from the URL and the <kbd>Product</kbd> object from the body of the request, which is specified by the <kbd>[FromBody]</kbd> attribute as we did in the case of <kbd>POST</kbd> in the previous section.</p>
<p>When the ID and the product object is tied with the arguments, the method body starts execution, which in turn calls the service method <kbd>UpdateProductAsync</kbd> with the same parameters. That method would return a Boolean based on whether the update was successful. If everything was successful, we would return <span class="packt_screen">200 OK</span> by calling the <kbd>OK()</kbd> method, otherwise a <span class="packt_screen">500 Internal Server Error</span> would be given if an error occurred.</p>
<p>Let me show you the screenshot from Postman:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/85d426a0-14ac-4d18-b9ff-b713b5490480.png"/></div>
<p>Another status code, <span class="packt_screen">301 Moved Permanently</span>, can be returned if the <kbd>PUT</kbd> request comes with an ID that has expired, meaning the product passed in the request body is not associated with the ID. To identify this condition, we need to add business logic accordingly, and if we can verify whether the ID is related to the product or not. If not, we can simply return <span class="packt_screen">301 Moved Permanently</span> with the new URL where the product actually exists currently. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">DELETE</h1>
                </header>
            
            <article>
                
<p>Ideally, a <kbd>DELETE</kbd> request should delete the resource. Once the operation is successful, we can send a <span class="packt_screen">200 OK</span> status code by calling the <kbd>OK()</kbd> method.</p>
<p>Refer to the following code block:</p>
<pre>// DELETE: api/Products/1<br/>[HttpDelete("{id}")]<br/>public async Task&lt;IActionResult&gt; Delete(int id)<br/>  =&gt; (await _productService.DeleteOrderAsync(id))<br/>    ? (IActionResult)Ok()<br/>    : NoContent();</pre>
<p>Notice the <kbd>DeleteOrderAsync</kbd> method, which is provided with the ID of the product to delete. Now, you can return a Boolean from that method, which will indicate whether the operation was successful or not. If you don't find any product for that ID, simply return <kbd>false</kbd>.  Then, we will decide what to return to the client accordingly.</p>
<p>If you return <kbd>false</kbd>, <kbd>NoContent()</kbd> can be used to return status code <em>204</em>. If the resource is already deleted and the client is requesting the same, then the server will return a status code <span class="packt_screen">204 No Content</span>. That means the server is not able to find the requested resource as it does not exist anymore.</p>
<p>Have a look at the Postman screenshot. See the <span class="packt_screen">Status</span> code is <em><span class="packt_screen">200 OK</span></em> for a successful delete:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8f1cd17b-a04c-43da-9af4-aa519632813f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SOAP versus REST</h1>
                </header>
            
            <article>
                
<p>Following are some key differences between SOAP and REST:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>SOAP</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>REST</strong></div>
</td>
</tr>
<tr>
<td>It is an XML-based message protocol.</td>
<td>It is an architectural style.</td>
</tr>
<tr>
<td>WSDL is used for communication between client and server. </td>
<td>XML or JSON is used to send and receive data between client and server.</td>
</tr>
<tr>
<td>Services are invoked by calling the RPC method.</td>
<td>Services expose endpoints via URLs.</td>
</tr>
<tr>
<td>Response is easily readable by a human.</td>
<td>Response is readable in the form of plain XML or JSON.</td>
</tr>
<tr>
<td>Data transfer occurs over HTTP. It leverages protocols such as SMTP, FTP, and so on.</td>
<td>REST data transfer occurs over HTTP only.</td>
</tr>
<tr>
<td>It is difficult to call a SOAP service from JavaScript.</td>
<td>It is very easy to call a REST service from JavaScript.</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single-page application model</h1>
                </header>
            
            <article>
                
<p>Traditionally, in a web application, the client requests the server for a web page. Then, the server responds to the client with the requested HTML page after validating and authenticating the request, if necessary. The next request to the server might occur when a user hits some link on the page, submits a form, and so on. The server again processes the request and sends back the response with another HTML page.</p>
<p>Don't you think instead of getting the whole HTML page (which would be mostly the same look and feel as the last loaded page), we should just get the data we need and update the currently loaded page itself without posting back to the server? Yes, modern web development works in that regard. Today, we just need data from the server on demand using Ajax. After receiving the data, we will just update the UI with JavaScript or a client-side framework such as Angular.</p>
<p>This is what we call a <strong>s</strong><span><strong>ingle-page application</strong> (<strong>SPA</strong>). On the first request to the server, the server responds with the entire page for the app. Unlike traditional web apps, subsequent requests won't ask for an HTML page, rather they will ask for data using Ajax requests where the type of content is usually JSON. After getting data, the browser has to update only the portion of the page that has changed instead of reloading the entire page again. The SPA definitely improves user experiences by responding quickly to user actions on the same page because reloading the page takes away a user's attention for a moment.</span></p>
<p class="mce-root">However, implementing SPA is not so easy as we have to be sure that we are showing fresh data on the page whenever needed. Here, emerging technologies, such as ASP.NET Web API, and JavaScript frameworks, such as AngularJS and CSS3 come in handy when designing SPAs.</p>
<p>Your application can call different endpoints of the REST API to do certain tasks and update the UI after getting responses without reloading the page. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Service-oriented architecture</h1>
                </header>
            
            <article>
                
<p>Like SPA, Web API plays an important role in <strong>service-oriented architecture</strong> (<strong>SOA</strong>). As the name suggests, it is an architecture methodology that deals with separation of responsibility from a business-oriented point of view into independent services. Often, these independent services or components can be designed using RESTful Web APIs.</p>
<p>Consider an e-commerce application that would have different components such as ordering, billing, payment processing, customer profile management, and so on. Each of these components has its own business logic and can be implemented independently.</p>
<p>The following diagram represents a pictorial view of such an application having independent components:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/caf5879a-a824-4cf6-a707-2668eeace98e.png" style="width:35.00em;height:21.25em;"/></div>
<p>To make them independent, RESTful APIs can be exposed for these components, which can be easily consumed by any client/application including other components as well, as long as they satisfy the authentication and authorization.</p>
<p>Following is a pictorial representation of a monolithic or traditional application architecture versus SOA. It's perfectly clear how SOA introduces reusable components for the same business application. Moreover, implementing them with Web API brings the capability to expose that to outside for consumption by any application:  </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b0c2ee14-34e7-4937-b027-18e9b449c2dd.png" style="width:32.67em;height:20.25em;"/></div>
<p>SOA implementation is beyond the scope of this book because there is a lot of stuff about Web API we need to explore in the next chapters. Whatever we do with the application in this book would use one Web API, but you can separate them out to build a more scalable architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We started with some basic knowledge of SOAP and then we moved towards REST gradually.</p>
<p>This chapter shed some light on the fundamental REST building blocks and how they actually work. We explored the different status codes returned by widely used HTTP verbs.</p>
<p>To explore the request and response cycles of Web API, you can use Postman, where you not only have control over what is being sent and received, but also the ability to get code for different languages in order to consume the API.</p>
<p>ASP.NET Core attributes can be tied to controller action methods to make them more expressive and manageable in terms of routing and arguments.</p>
<p><em>Single-page applications</em> can be easily designed using client-side technologies and consuming ASP.NET Core Web APIs so that pages can be updated as soon as responses are received to have a smooth user experience. </p>
<p>Web APIs can be plugged into the s<em>ervice-oriented architecture</em> to have a modular design that improves scalability. By separating different critical components of the whole architecture with the help of APIs, it leaves us in a better position to reuse the components in different applications and expose them to the world so that they can be consumed by anyone.</p>
<p>In the next chapter, we will look at the important parts of the Web API architecture related to authentication.</p>


            </article>

            
        </section>
    </body></html>