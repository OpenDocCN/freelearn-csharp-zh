<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-17" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introduction to CLI Applications</h1>
			<p>In <a id="_idIndexMarker000"/>the realm of computing, <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) applications exemplify the enduring power and efficiency of text-based user interfaces. Unlike their graphical counterparts, CLI applications offer a streamlined, no-frills approach to interacting with software, allowing users to execute commands, manipulate files, and perform a myriad of tasks right from the terminal, or automate them so these tasks do not require user interaction <span class="No-Break">at all!</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>An IT professional’s <span class="No-Break">typical day</span></li>
				<li>What CLI applications are, what their benefits are, and when to <span class="No-Break">use them</span></li>
				<li>Popular <span class="No-Break">CLI applications</span></li>
			</ul>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>A day in the life of an IT professional</h1>
			<p>It’s a beautiful Monday morning. Today, my team and I are starting a <span class="No-Break">new project.</span></p>
			<p>The <a id="_idIndexMarker001"/>project is to <a id="_idIndexMarker002"/>build a web<a id="_idIndexMarker003"/> application using <strong class="bold">ASP.NET</strong> with <strong class="bold">Entity Framework</strong> as an <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>), <strong class="bold">NuGet</strong> for <a id="_idIndexMarker004"/>managing dependencies, <strong class="bold">Git</strong> as a <a id="_idIndexMarker005"/>code versioning system, and, since the application is to be deployed on Azure, <strong class="bold">Bicep</strong> as an<a id="_idIndexMarker006"/> infrastructure <span class="No-Break">scripting language.</span></p>
			<p>A few years ago, I <a id="_idIndexMarker007"/>would have used <a id="_idIndexMarker008"/>GUI applications for <a id="_idIndexMarker009"/>this, such as the full-fledged <strong class="bold">Visual Studio</strong>, <strong class="bold">GitHub Desktop</strong>, or <strong class="bold">GitKraken</strong>, and<a id="_idIndexMarker010"/> the <span class="No-Break"><strong class="bold">Azure portal</strong></span><span class="No-Break">.</span></p>
			<p>Today, I doing most of my work<a id="_idIndexMarker011"/> in <strong class="bold">Visual Studio Code</strong> and its <span class="No-Break">integrated terminal.</span></p>
			<p>So, I use commands such as <strong class="source-inline">mkdir</strong> to <a id="_idIndexMarker012"/>create my project directory, <strong class="source-inline">cd</strong> to <a id="_idIndexMarker013"/>position myself into this<a id="_idIndexMarker014"/> directory, <strong class="source-inline">dotnet new</strong> to create my project, <strong class="source-inline">git init</strong> to <a id="_idIndexMarker015"/>initialize the<a id="_idIndexMarker016"/> Git repository, <strong class="source-inline">dotnet add package</strong> to add NuGet packages as dependencies to my project, <strong class="source-inline">dotnet ef dbcontext scaffold</strong> to <a id="_idIndexMarker017"/>generate a database context and all the entity type classes for my<a id="_idIndexMarker018"/> database, <strong class="source-inline">dotnet build</strong> to compile my <a id="_idIndexMarker019"/>application, and <strong class="source-inline">dotnet run</strong> to run it. When comes the time to deploy my application to Azure, I use commands such as <strong class="source-inline">az login</strong> to log <a id="_idIndexMarker020"/>into my Azure <a id="_idIndexMarker021"/>account, <strong class="source-inline">az account set</strong> to position myself onto the appropriate subscription, and finally, <strong class="source-inline">az deployment group create</strong> to <a id="_idIndexMarker022"/>deploy my Azure infrastructure as declared in my <span class="No-Break">Bicep script.</span></p>
			<p>When I realized that, I paused to pay careful attention to the situation. Wow, CLI applications are everywhere! They are truly part of our daily operations, no matter the role we play in an <span class="No-Break">IT team.</span></p>
			<p>I wondered how I missed that… then it hit me. This might be because<a id="_idIndexMarker023"/> CLI applications are a bit shy (they have no flashy UIs), and for that reason, we may not always notice them, so let me tell you about some <span class="No-Break">common ones:</span></p>
			<ul>
				<li>If you are a developer, you have certainly used the .NET CLI (<strong class="source-inline">dotnet</strong>), the Node.js CLI (<strong class="source-inline">node</strong>), the npm package manager (<strong class="source-inline">npm</strong>), the Angular CLI (<strong class="source-inline">ng</strong>), Python (<strong class="source-inline">python</strong>), Git (<strong class="source-inline">git</strong>), Docker (<strong class="source-inline">docker</strong>), Kubernetes (<strong class="source-inline">kubectl</strong>), and <span class="No-Break">many more.</span></li>
				<li>If you are a DevOps engineer, you may be using Git (<strong class="source-inline">git</strong>), GitHub (<strong class="source-inline">gh</strong>), Azure DevOps (<strong class="source-inline">az</strong> <strong class="source-inline">devops</strong>), Docker (<strong class="source-inline">docker</strong>), Kubernetes (<strong class="source-inline">kubectl</strong>), Ansible (<strong class="source-inline">ansible</strong>), and <span class="No-Break">so on.</span></li>
				<li>If you are a system administrator, you may be regularly using package managers on various operating systems, such as <strong class="source-inline">apt</strong> on Linux, <strong class="source-inline">brew</strong> on macOS, or even <strong class="source-inline">choco</strong> or <strong class="source-inline">winget</strong> on Windows. You also most likely use shells, automation, and configuration tools such as PowerShell <span class="No-Break">or Bash.</span></li>
				<li>If you are a cloud administrator or architect, you may be using the Azure CLI (<strong class="source-inline">az</strong>), the AWS CLI (<strong class="source-inline">aws</strong>), Terraform (<strong class="source-inline">terraform</strong>), or Bicep (<strong class="source-inline">bicep</strong>), <span class="No-Break">among others.</span></li>
				<li>If you are a data scientist, you might be using Python (<strong class="source-inline">python</strong>), R (<strong class="source-inline">R</strong>), Pandas (<strong class="source-inline">pandas</strong>), SQL (<strong class="source-inline">sql</strong>), or Jupyter Notebooks (<span class="No-Break"><strong class="source-inline">jupyter notebook</strong></span><span class="No-Break">).</span></li>
				<li>If you are a video or audio producer, a content creator, or simply a multimedia enthusiast, you are probably using <strong class="source-inline">FFmpeg</strong> (yes, it is a CLI application) to manipulate, convert, and analyze <span class="No-Break">media files.</span></li>
				<li>And the list goes on <span class="No-Break">and on…</span></li>
			</ul>
			<p>Then, I started wondering why this happened. How come we switched from those beautiful UIs with their shiny colors and animations, inviting us to do all sorts of tasks and activities, to the blinking cursor inside of that terminal that is waiting for us to tell it what to do? This might seem like a big leap <span class="No-Break">backward, right?</span></p>
			<p>I know I struggled with that feeling until I figured out why CLI applications are so great! Sure, they make us look cool and smart in front of our Muggle friends and relatives. But it’s not about that. Okay… not only about that. Because, when we are alone working on our project, there are not many people <span class="No-Break">to impress.</span></p>
			<p><span class="No-Break">So…</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Why care about CLI applications?</h1>
			<p>Because<a id="_idIndexMarker024"/> they improve our productivity by keeping us focused on the task <span class="No-Break">at hand.</span></p>
			<p>You see, when we switch contexts between different applications, the chances are that we lose sight of what we were doing and get derailed from our task by some other <span class="No-Break">unrelated activity.</span></p>
			<p>By relying on CLI applications, all the commands that we type and execute happen to be within the same terminal, so we have a better chance of staying focused on what we are doing, thus <span class="No-Break">achieving more.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>To CLI or not to CLI?</h1>
			<p>That is the question. And the answer is quite simple: you don’t have to choose. In some scenarios, CLI applications make perfect sense, while in others they make no sense. Imagine using Microsoft Teams, Slack, or any tool of the Adobe Creative Suite. Would it make sense to interact with these applications as CLI applications? Of course not! (unless it is for installing and <span class="No-Break">configuring them).</span></p>
			<p>So, the point here is that you become aware of the power of CLI applications, and you start taking advantage of them in your everyday workflow. They are not meant to replace those outstanding <span class="No-Break">GUI applications.</span></p>
			<p>As my wife, Lamia Rarrbo (who is an executive coach) says: “This is not an <strong class="bold">or</strong> situation but rather an <span class="No-Break"><strong class="bold">and</strong></span><span class="No-Break"> situation.”</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>CLI applications as the building block for creating workstation profiles</h1>
			<p>Let me tell you a <a id="_idIndexMarker025"/>true story. A few years ago, one of my customers asked me to come up with a solution to build workstation configuration profiles for different roles within <span class="No-Break">their company.</span></p>
			<p>This is nothing new, you may say, and you are <span class="No-Break">exactly right!</span></p>
			<p>So, what makes this situation worth mentioning? What makes <span class="No-Break">it special?</span></p>
			<p>For many years, this used to be achieved using customized OS images, depending on the role you have in the organization. However, this comes at <span class="No-Break">a cost:</span></p>
			<ul>
				<li>The cost of storage: These images tend to be large and hence require a lot of disk space to <span class="No-Break">store them.</span></li>
				<li>The cost of OS updates: When a new OS version is introduced, the IT department must recreate <span class="No-Break">all images.</span></li>
				<li>The cost of tools updates: When new versions of the tools utilized by the various profiles are introduced, the IT department must recreate the <span class="No-Break">impacted images.</span></li>
				<li>The cost of frustration: Since computers are configured using these images, and because this activity is solely performed by the IT department, it causes frustrations at both ends. First, users accuse the IT department of being slow at providing them with their new machine (“<em class="italic">3 weeks to configure a new laptop?! You gotta be kidding me!</em>”. We have all heard this at some point, right?). Second, the IT people have to configure these computers <em class="italic">in addition</em> to their <span class="No-Break">other tasks.</span></li>
			</ul>
			<p>The solution I <a id="_idIndexMarker026"/>proposed is to leverage CLI applications to provide users with more autonomy while ensuring that the IT department still has control over what is deployed on <span class="No-Break">the workstations.</span></p>
			<p>So, I built configuration profiles for each role as a PowerShell script. This script relies on <em class="italic">Chocolatey</em> (and, later, on <em class="italic">WinGet</em>) to install all the necessary tools for a given user role. These scripts were stored on a file share that users had access to according to their role (so, for example, if you are an analyst, you don’t have access to the developer profile, and <span class="No-Break">so on).</span></p>
			<p>This solution provided <span class="No-Break">multiple advantages:</span></p>
			<ul>
				<li>The IT department now only installs the OS, configures the user account, and hand the workstation to <span class="No-Break">the user</span></li>
				<li>The user can now navigate to the file share and start the installation of their software based on <span class="No-Break">their profile</span></li>
				<li>The IT department can update the configuration profiles, or provide new ones, without having an impact on the users and without making <span class="No-Break">them wait</span></li>
			</ul>
			<p>Hence, by leveraging CLI tools, we were able to automate workstation configuration in a personalized manner, according to users’ profiles. Imagine how tedious this would have been if we had to install each and every application through its <span class="No-Break">GUI assistant!</span></p>
			<p>By relying on CLI tools, we were able to improve both the IT department’s productivity and <span class="No-Break">users’ satisfaction.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Even heavy graphical applications have a CLI tool!</h1>
			<p>Why is the preceding <span class="No-Break">story interesting?</span></p>
			<p>It’s not because of the use of PowerShell, WinGet, or Chocolatey. These are clearly <span class="No-Break">CLI tools.</span></p>
			<p>It is because we designed a way to install software from the command line without involving any GUI. This means that even if we are installing graphical applications (such as the Microsoft Office suite, internet browsers, and the Adobe suite), we are doing so by relying on their own <span class="No-Break">CLI tools.</span></p>
			<p>Yes, these graphical applications provide a CLI tool allowing us to install (and sometimes also configure) <span class="No-Break">these applications.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Even ChatGPT has a CLI!</h1>
			<p>A quick Google search and I found that there are even CLI applications <a id="_idIndexMarker027"/>for <strong class="bold">ChatGPT</strong>! Can you <span class="No-Break">believe that?!</span></p>
			<p>You can check out some of them at <a href="https://github.com/kardolus/chatgpt-cli">https://github.com/kardolus/chatgpt-cli</a> <span class="No-Break">and </span><a href="https://github.com/marcolardera/chatgpt-cli"><span class="No-Break">https://github.com/marcolardera/chatgpt-cli</span></a><span class="No-Break">.</span></p>
			<p>I am telling you: CLI applications are truly everywhere, and once you start caring about them, you start noticing how much they are part of <span class="No-Break">your day!</span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Summary</h1>
			<p>If you work in IT, you have most likely already used at least one CLI application of some sort (and the chances are that you use many of them!), and you may even be using it on a <span class="No-Break">daily basis.</span></p>
			<p>I am sure that, by now, you have understood the value of CLI applications and the role they play in your <span class="No-Break">everyday job.</span></p>
			<p>In this book, we will explore every aspect of building our very own CLI applications, that serve our needs and those of our users <span class="No-Break">and customers.</span></p>
			<p>Feeling excited? Then, grab your keyboard, fire up your terminal, and let’s <span class="No-Break">start coding!</span></p>
			<p>We have only scratched the surface of what CLI applications can do and why they’re an essential tool in today’s tech landscape. I want this book to be your roadmap and your guide in this <span class="No-Break">exciting journey.</span></p>
			<p>Oh, and by the way, do not simply read this book, <span class="No-Break">experience it!</span></p>
			<p>Now, turn this page, and let’s continue our journey together. The world of CLI applications <span class="No-Break">awaits you!</span></p>
			<p>Enjoy <span class="No-Break">the journey.</span></p>
		</div>
	</body></html>