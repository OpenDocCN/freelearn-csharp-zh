<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"/>3</h1>
<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"/>Extending Functionality with Unity Plugins</h1>
<p class="calibre3">Welcome to <a href="B22017_03.xhtml#_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 3</em></a>, where we’ll delve into the world of Unity plugins. We’ll explore how to effectively integrate these plugins into your projects. This chapter aims to familiarize you with the different types of plugins available in the Unity ecosystem and guide you through the process of seamlessly incorporating them. By grasping the fundamentals of plugin integration, you’ll be able to make the most of existing solutions, enhance your game features, and save valuable development time. Let’s jump in and discover how Unity plugins can significantly boost your game development capabilities.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Understanding Unity plugins</li>
<li class="calibre11">Integrating Unity plugins</li>
<li class="calibre11">Best practices for using Unity plugins</li>
</ul>
<h1 id="_idParaDest-49" class="calibre5"><a id="_idTextAnchor051" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">You will need the following to follow this chapter:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Unity version 2022.3.13</strong>: Download and install Unity version 2022.3.13 or any other version. It is recommended to install the 2022 version.</li>
<li class="calibre11"><strong class="bold">Primary IDE – Visual Studio 2022</strong>: Ensure Visual Studio 2022 is installed for optimal learning.</li>
<li class="calibre11"><strong class="bold">GitHub repository for code samples</strong>: Access code samples and project files on our GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003</a>. Clone or download the repository to have easy access to the code demonstrated in this chapter.</li>
</ul>
<h1 id="_idParaDest-50" class="calibre5"><a id="_idTextAnchor052" class="calibre6 pcalibre1 pcalibre"/>Understanding Unity plugins</h1>
<p class="calibre3">In the world <a id="_idIndexMarker166" class="calibre6 pcalibre1 pcalibre"/>of game development, Unity plugins are like handy tools that developers can add to their toolkit. Think of them as special add-ons or extra features that make building games easier and more exciting.</p>
<p class="calibre3">Let’s explore here how<a id="_idIndexMarker167" class="calibre6 pcalibre1 pcalibre"/> these optional upgrades can elevate your game development endeavors:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Boost to game development</strong>: Unity plugins are essential tools in the world of game development. These compact bundles of code serve as valuable additions to Unity, acting much like specialized ingredients seamlessly integrated into your game. Crafted by fellow developers, these plugins are generously shared within the Unity community, offering benefits to all.</li>
<li class="calibre11"><strong class="bold">The significance of Unity plugins in game development</strong>: The appeal of Unity plugins lies in their ability to enhance game development effortlessly. Picture this: you’re constructing a game, and you envision characters with incredibly smooth movements or breathtaking special effects such as dazzling explosions. Instead of grappling with complex code to achieve these elements, Unity plugins provide a solution. They save time and effort by leveraging the expertise of skilled developers, allowing you to relish the outcomes.</li>
<li class="calibre11"><strong class="bold">Extending functionality – elevating games to new heights</strong>: Extending functionality with plugins is akin to granting your game superpowers. It goes beyond the basics, allowing you to incorporate various features without delving into the complexities of starting from square one. It’s like an upgrade for your game, making it more enjoyable and engaging.</li>
</ul>
<p class="calibre3">Unity plugins play a vital role in the realm of game development, equipping developers with a toolbox to amplify the capabilities of Unity. It’s crucial to discern between two main categories of plugins: core plugins and extra plugins. Core plugins, inherent to Unity, provide foundational functionalities right out of the box. On the flip side, extra plugins act as optional upgrades, allowing you to tailor your toolkit to suit the specific needs of your project. To better understand these distinctions, let’s consider a comparison:</p>
<table class="no-table-style" id="table001-1">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Plugin Type</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Core plugins</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Pre-packaged with Unity, offering foundational functionalities</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Extra plugins</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Optional upgrades that can be chosen based on specific project requirements</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3">In this chapter, we will<a id="_idIndexMarker168" class="calibre6 pcalibre1 pcalibre"/> prioritize additional plugins as they play a crucial role in enhancing the project, delving into how to seamlessly extend and integrate them<a id="_idIndexMarker169" class="calibre6 pcalibre1 pcalibre"/> into your projects. Our spotlight on the extra plugins falls on the <strong class="bold">new Input System</strong> and <strong class="bold">Cinemachine</strong> – as <a id="_idIndexMarker170" class="calibre6 pcalibre1 pcalibre"/>essential extra plugins, prominent choices for enhancing your game without delving into the core functionalities.</p>
<p class="calibre3">In the next section, we will start talking about installing the plugins and how to extend them using C# scripts.</p>
<h1 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor053" class="calibre6 pcalibre1 pcalibre"/>Integrating Unity plugins</h1>
<p class="calibre3">Let’s delve into<a id="_idIndexMarker171" class="calibre6 pcalibre1 pcalibre"/> the seamless process of integrating external plugins into your Unity projects. Discover how this skill unlocks a world of possibilities, enhancing your game development experience with refined character movements, cinematic visual effects, and more. Dive in and elevate your projects.</p>
<p class="calibre3">We will start with the new Input System and how to use it for handling input for our character.</p>
<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor054" class="calibre6 pcalibre1 pcalibre"/>New Input System</h2>
<p class="calibre3">Unity handles<a id="_idIndexMarker172" class="calibre6 pcalibre1 pcalibre"/> input through two systems: the older Input Manager, which is integrated into the editor, and the more recent Input System package. The <a id="_idIndexMarker173" class="calibre6 pcalibre1 pcalibre"/>aged Input Manager is an integral part of Unity’s core, readily available if you choose not to install the Input System package. Offering a fresher perspective, the Input System package enables you to employ any input device to govern your Unity content, taking the place of Unity’s traditional Input Manager. Installation of the new Input System package is a breeze – simply use the Package Manager. We will install it and use it in this section.</p>
<p class="calibre3">In the <a id="_idIndexMarker174" class="calibre6 pcalibre1 pcalibre"/>following table, we’ll compare the old Input System with the new one, highlighting their key differences:</p>
<table class="no-table-style" id="table002">
<colgroup class="calibre12">
<col class="calibre13"/>
<col class="calibre13"/>
<col class="calibre13"/>
</colgroup>
<tbody class="calibre14">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Feature</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Old </strong><strong class="bold">Input Manager</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">New </strong><strong class="bold">Input System</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Device support</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Limited to keyboards, mice, and gamepads</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Unified API for all devices</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Input actions</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Basic button and axis mappings</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Complex actions with triggers and combinations</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Architecture</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Polling-based continuously checks input states at regular intervals, such as every frame, to detect changes and respond to user actions in real-time</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Event-driven relies on triggering callbacks or events based on user actions, promoting modularity and efficient handling of input events without continuous polling</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Performance</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Can be sluggish</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Efficient and responsive</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">Extensibility</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Closed system</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Open-source and extensible</p>
</td>
</tr>
</tbody>
</table>
<p class="calibre3">Excited for more exploration? Look <a id="_idIndexMarker175" class="calibre6 pcalibre1 pcalibre"/>forward to the following section, where we’ll delve into configuring the system, crafting personalized actions, and unlocking its full potential.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please be aware that the new Input System is compatible with Unity versions 2019.4 and above, and it necessitates the .NET 4 runtime. Projects utilizing the old .NET 3.5 runtime are not supported.</p>
<p class="calibre3">In the following figure, you can choose <strong class="bold">Input System</strong> inside the <strong class="bold">Package Manager</strong> and install it:</p>
<div><div><img alt="Figure 3.1 – Input System package inside Package Manager panel" src="img/B22017_03_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Input System package inside Package Manager panel</p>
<p class="calibre3">After <a id="_idIndexMarker176" class="calibre6 pcalibre1 pcalibre"/>finishing the installation process, Unity will ask you if you want to<a id="_idIndexMarker177" class="calibre6 pcalibre1 pcalibre"/> enable the new backends. By choosing <strong class="bold">Yes</strong>, Unity will enable the new backends and disable the old backends, and the Unity Editor will restart. You can see a <strong class="bold">Warning</strong> message in the following figure:</p>
<div><div><img alt="Figure 3.2 – Warning message after installing the new Input System" src="img/B22017_03_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Warning message after installing the new Input System</p>
<p class="calibre3">Please take<a id="_idIndexMarker178" class="calibre6 pcalibre1 pcalibre"/> note that you have the option to simultaneously enable <a id="_idIndexMarker179" class="calibre6 pcalibre1 pcalibre"/>both the old and new systems. To accomplish this, set <strong class="bold">Active Input Handling</strong> to <strong class="bold">Both</strong>.</p>
<p class="calibre3">Locate the relevant setting in the <strong class="bold">Player</strong> settings (navigate to <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Player</strong>), specifically under <strong class="bold">Active Input Handling</strong>. Feel free to adjust this setting at your convenience; however, please note that making changes will necessitate restarting the Editor.</p>
<div><div><img alt="Figure 3.3 – Input settings inside the Project Settings" src="img/B22017_03_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Input settings inside the Project Settings</p>
<p class="calibre3">Now that <a id="_idIndexMarker180" class="calibre6 pcalibre1 pcalibre"/>we’ve been<a id="_idIndexMarker181" class="calibre6 pcalibre1 pcalibre"/> introduced to the new Input System, let’s explore its implementation.</p>
<h3 class="calibre9">Implementing Unity’s new Input System</h3>
<p class="calibre3">In this <a id="_idIndexMarker182" class="calibre6 pcalibre1 pcalibre"/>subsection, our focus shifts to the practical application of Unity’s new Input System. Get ready to dive into hands-on learning as we guide you through the step-by-step process of implementation. By the end of this section, you’ll have the skills and knowledge needed to seamlessly integrate the new Input System into your Unity projects, enhancing control and responsiveness. Let’s get hands-on and delve into the practical steps of implementing this powerful tool together.</p>
<p class="calibre3">In Unity’s<a id="_idIndexMarker183" class="calibre6 pcalibre1 pcalibre"/> new Input System, <code>InputActions</code> are pivotal for defining and structuring input controls such as keyboard keys, mouse buttons, and controller inputs within an InputActionAsset. These actions are bound to specific input bindings and organized into<a id="_idIndexMarker184" class="calibre6 pcalibre1 pcalibre"/> logical groupings called <code>PlayerInput</code> component integrates InputActions into GameObjects, allowing for efficient input event handling through callbacks and events. InputActions support rebinding and overrides, empowering players to customize input bindings while maintaining a cohesive Input System architecture that enhances modularity and reusability compared to Unity’s legacy Input System. Let’s use the new Input System.</p>
<ol class="calibre15">
<li class="calibre11">Create a new input action (<strong class="bold">Create</strong> | <strong class="bold">Input Actions</strong>) in the folder inside your project, as you can see in the next figure:</li>
</ol>
<div><div><img alt="Figure 3.4 – Choosing Input Actions from the Create panel" src="img/B22017_03_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Choosing Input Actions from the Create panel</p>
<ol class="calibre15">
<li value="2" class="calibre11">Then, you can open this input action, and a new panel will appear, as shown in the<a id="_idIndexMarker185" class="calibre6 pcalibre1 pcalibre"/> following figure:</li>
</ol>
<div><div><img alt="Figure 3.5 – Input Action panel" src="img/B22017_03_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Input Action panel</p>
<ol class="calibre15">
<li value="3" class="calibre11">Change the <strong class="bold">Action Type</strong> value to <strong class="bold">Pass Through</strong> and <strong class="bold">Control Type</strong> to <strong class="bold">Vector 2</strong>, as you can see in the following figure:</li>
</ol>
<div><div><img alt="Figure 3.6 – Action Properties" src="img/B22017_03_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Action Properties</p>
<ol class="calibre15">
<li value="4" class="calibre11">Then, choose to <a id="_idIndexMarker186" class="calibre6 pcalibre1 pcalibre"/>add bindings for movement, as you can see in the next figure:</li>
</ol>
<div><div><img alt="Figure 3.7 – Choosing bindings for movement" src="img/B22017_03_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Choosing bindings for movement</p>
<ol class="calibre15">
<li value="5" class="calibre11">Here, you can rename the name of the movement binding. Also, you can start to set the input keys for each process in the <strong class="bold">Path</strong> dropdown, as you can see in the following figure:</li>
</ol>
<div><div><img alt="Figure 3.8 – Movement binding" src="img/B22017_03_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Movement binding</p>
<ol class="calibre15">
<li value="6" class="calibre11">The magic<a id="_idIndexMarker187" class="calibre6 pcalibre1 pcalibre"/> of the new Input System shines as you can assign multiple bindings for the same action across different devices, as demonstrated in the following figure:</li>
</ol>
<div><div><img alt="Figure 3.9 – Arrows bindings" src="img/B22017_03_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Arrows bindings</p>
<ol class="calibre15">
<li value="7" class="calibre11">You can also add new actions for <strong class="bold">Jump</strong> and <strong class="bold">Dash</strong>, but for them, you need to change<a id="_idIndexMarker188" class="calibre6 pcalibre1 pcalibre"/> the <strong class="bold">Action Type</strong> value to <strong class="bold">Button</strong>. Your final settings should look something like this:</li>
</ol>
<div><div><img alt="Figure 3.10 – Adding Jump and Dash" src="img/B22017_03_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Adding Jump and Dash</p>
<ol class="calibre15">
<li value="8" class="calibre11">As the final step for this input action asset, you need to return to the input action in <strong class="bold">Inspector</strong> and choose <strong class="bold">Generate C# Class</strong> for it:</li>
</ol>
<div><div><img alt="Figure 3.11 – Generating an input class" src="img/B22017_03_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Generating an input class</p>
<ol class="calibre15">
<li value="9" class="calibre11">Then, we<a id="_idIndexMarker189" class="calibre6 pcalibre1 pcalibre"/> will create a wrapper script to take callbacks from the inputs and invoke new actions to perform movement:<p class="calibre3">We are going to create a wrapper for using the new Input System, starting with implementing gameplay map actions in our <code>PlayerInput</code> script as follows:</p><pre class="source-code">
public class PlayerInput : MonoBehaviour , GamePlay.IGamePlayMapActions</pre></li> <li class="calibre11">Also, we will register callbacks for this action and create events so that we can use them later in our <strong class="source-inline1">PlayerMovement</strong> script, as you can see in the following code block:<pre class="source-code">
 private GamePlay gameplayControls;
 public static UnityAction onJump = delegate { };
 public static UnityAction onDash = delegate { };
 public static UnityAction&lt;Vector2&gt; onMovement = delegate { };
        private void OnEnable()
        {
            if (gameplayControls == null)
            {
                gameplayControls = new GamePlay();
                gameplayControls.GamePlayMap.SetCallbacks(this);
            }
            gameplayControls.GamePlayMap.Enable();
        }
        private void OnDisable()
        {
            gameplayControls.GamePlayMap.Disable();
        }</pre></li> <li class="calibre11">Now, magic <a id="_idIndexMarker190" class="calibre6 pcalibre1 pcalibre"/>happens here. When we get the action callback and then invoke our events, we will subscribe to these events in the <strong class="source-inline1">PlayerMovement</strong> script, as you can see in the following code block:<pre class="source-code">
public class PlayerMovement : MonoBehaviour
    {
        private void OnEnable()
        {
            PlayerInput.onJump += Jump;
            PlayerInput.onDash += Dash;
            PlayerInput.onMovement += MovementInput;
        }
        private void OnDisable()
        {
            PlayerInput.onJump -= Jump;
            PlayerInput.onDash -= Dash;
            PlayerInput.onMovement -= MovementInput;
        }</pre><p class="calibre3">Here are the<a id="_idIndexMarker191" class="calibre6 pcalibre1 pcalibre"/> functions for movement in the <code>PlayerMovement</code> script:</p><pre class="source-code">  private void MovementInput(Vector2 input)
        {
            movementVector = input;
        }
        private void MovePlayer()
        {
            Vector3 movement = new Vector3(movementVector.x , 0f , movementVector.y) * moveSpeed * Time.deltaTime;
            transform.Translate(movement);
        }
        private void Jump()
        {
            if (isGrounded)
            {
                playerRigidbody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
                isGrounded = false;
            }
        }
        private void Dash()
        {
            if (canDash)
            {
                Vector3 dashVector = new Vector3(movementVector.x, 0f, movementVector.y).normalized;
                playerRigidbody.AddForce(dashVector * dashForce, ForceMode.Impulse);
                canDash = false;
                Invoke(nameof(ResetDash), dashCooldown);
            }
        }
        private void FixedUpdate()
        {
            MovePlayer();
            CheckGrounded();
        }
        private void CheckGrounded()
        {
            isGrounded = Physics.Raycast(groundChecker.position, Vector3.down, groundDistance, groundLayer);
        }
        private void ResetDash()
        {
            canDash = true;
        }</pre></li> </ol>
<p class="calibre3">Voilà! The new <a id="_idIndexMarker192" class="calibre6 pcalibre1 pcalibre"/>Input System is now employed for player movement.</p>
<h3 class="calibre9">Discussing advanced techniques</h3>
<p class="calibre3">In the upcoming section, we<a id="_idIndexMarker193" class="calibre6 pcalibre1 pcalibre"/> are going to talk about more advanced techniques for the new Input System. Let’s explore Unity’s Input System features by looking at Interactions and Processors, which help adjust input signals before they activate actions:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Interactions</strong>: Interactions<a id="_idIndexMarker194" class="calibre6 pcalibre1 pcalibre"/> modify or filter the raw input signal before reaching the action. Unity’s Input System provides a variety of built-in Interactions, such as <strong class="bold">Tap</strong>, <strong class="bold">Slow Tap</strong>, and <strong class="bold">Press</strong>, each serving specific use cases. For example, we can utilize <strong class="bold">Multi Tap</strong> for double jumps or activating special powers, while <strong class="bold">Press </strong>can help solve parts of puzzles in the game.<p class="calibre3">In the <a id="_idIndexMarker195" class="calibre6 pcalibre1 pcalibre"/>following figure, you can find a list of Interactions to be applied:</p></li>
</ul>
<div><div><img alt="Figure 3.12 – Interactions" src="img/B22017_03_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Interactions</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Processors</strong>: Processors <a id="_idIndexMarker196" class="calibre6 pcalibre1 pcalibre"/>are applied to the input data after the Interaction but before the action triggers. They allow you to manipulate the input data, such as scaling, inverting, or smoothing analog values. Processors contribute to the fine-tuning of input behavior; you can apply them on controls, bindings, and actions.<p class="calibre3">In the following figure, you will find a list of Processors to be applied:</p></li>
</ul>
<div><div><img alt="Figure 3.13 – Processors" src="img/B22017_03_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Processors</p>
<p class="calibre3">Having gained<a id="_idIndexMarker197" class="calibre6 pcalibre1 pcalibre"/> insights<a id="_idIndexMarker198" class="calibre6 pcalibre1 pcalibre"/> into Unity’s Input System, we now understand how Interactions and Processors refine input signals, enhancing control mechanisms within our game development endeavors. In the next section, let’s delve into Cinemachine, an essential tool in Unity that revolutionizes game development with cinematic flair.</p>
<h2 id="_idParaDest-53" class="calibre7"><a id="_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"/>Cinemachine</h2>
<p class="calibre3">Let’s talk<a id="_idIndexMarker199" class="calibre6 pcalibre1 pcalibre"/> about Cinemachine, a game-changer in Unity that takes your game development to cinematic levels. If you’re a Unity developer, Cinemachine <a id="_idIndexMarker200" class="calibre6 pcalibre1 pcalibre"/>is your go-to tool for effortlessly managing dynamic camera moves, crafting cinematic scenes, and enhancing the way players navigate virtual worlds.</p>
<p class="calibre3">At its core, Cinemachine introduces virtual cameras, which are like your personal camera crew for the digital stage. No need for complex camera scripts – Cinemachine simplifies the process, making it easy to guide player perspectives. Whether you want action-packed shots, serene landscapes, or immersive story moments, Cinemachine lets you play director without the headaches.</p>
<h3 class="calibre9">Benefits of Cinemachine</h3>
<p class="calibre3">Explore the array <a id="_idIndexMarker201" class="calibre6 pcalibre1 pcalibre"/>of features Cinemachine offers for seamless and captivating camera control and storytelling in Unity game development as follows:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Intuitive controls</strong>: Cinemachine provides a user-friendly interface and intuitive controls, eliminating the need for complex camera scripting and making it accessible to developers of all skill levels</li>
<li class="calibre11"><strong class="bold">Effortless perspective guidance</strong>: With Cinemachine, you can effortlessly guide player perspectives, from dynamic action sequences to serene landscapes, without delving into intricate code</li>
<li class="calibre11"><strong class="bold">Realism with procedural noise</strong>: Cinemachine introduces realism into scenes through procedural noise, offering subtle yet impactful effects such as camera shakes during key moments, enhancing the overall gaming experience</li>
<li class="calibre11"><strong class="bold">Composer for automatic framing</strong>: The <strong class="bold">Composer</strong> component automates the camera’s position <a id="_idIndexMarker202" class="calibre6 pcalibre1 pcalibre"/>and <strong class="bold">field-of-view</strong> (<strong class="bold">FOV</strong>) adjustments, ensuring focus on essential elements, streamlining the framing process, and saving valuable development time</li>
<li class="calibre11"><strong class="bold">Seamless Timeline integration</strong>: Cinemachine seamlessly integrates with Unity’s Timeline, enabling the easy creation of cinematic sequences for a more immersive and narrative-driven gaming experience</li>
<li class="calibre11"><strong class="bold">Enhanced storytelling capabilities</strong>: Beyond a camera system, Cinemachine acts as a creative ally, enhancing storytelling capabilities and making games more captivating and memorable for players</li>
</ul>
<p class="calibre3">In summary, Cinemachine presents an array of features designed to streamline camera control and enhance storytelling in Unity game development, offering intuitive controls, effortless perspective guidance, realism with procedural noise, automated framing with the <strong class="bold">Composer</strong> component, seamless Timeline integration, and enhanced storytelling capabilities.</p>
<h3 class="calibre9">Using Cinemachine in our game</h3>
<p class="calibre3">Let’s kick off our <a id="_idIndexMarker203" class="calibre6 pcalibre1 pcalibre"/>journey with Cinemachine by exploring how to integrate it into our game seamlessly. In this subsection, we will learn how to install Cinemachine and set up your virtual camera for enhanced scene management and dynamic camera movements.</p>
<p class="calibre3">In the following figure, you can see the <strong class="bold">Package Manager</strong> panel, from which you can choose and install packages and wait till the editor finishes compiling scripts:</p>
<div><div><img alt="Figure 3.14 – Installing Cinemachine from the Package Manager" src="img/B22017_03_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Installing Cinemachine from the Package Manager</p>
<p class="calibre3">Unity provides a variety of cameras within the Cinemachine package. Let’s discuss some of these cameras and their respective uses:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Freelook </strong><strong class="bold">Camera (CinemachineFreeLook)</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Usage</em>: The<a id="_idIndexMarker204" class="calibre6 pcalibre1 pcalibre"/> Freelook Camera provides versatile control for creating dynamic and cinematic camera movements in 3D environments. It is often used for character exploration, action sequences, and immersive gameplay experiences where fluid camera motion adds depth and engagement.</li><li class="calibre11"><em class="italic">Key features</em>: Allows for multi-axis rotation, adjustable follow and look-at targets, customizable damping for smooth transitions, and the ability to define multiple rig configurations for different camera behaviors.</li></ul></li>
<li class="calibre11"><strong class="bold">Virtual </strong><strong class="bold">Camera (CinemachineVirtualCamera)</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Usage</em>: The<a id="_idIndexMarker205" class="calibre6 pcalibre1 pcalibre"/> Virtual Camera serves as a foundational camera tool in Cinemachine, offering precise control over framing, composition, and behavior. It is suitable for a wide range of scenarios, including character tracking, scene framing, cutscenes, and scripted camera sequences.</li><li class="calibre11"><em class="italic">Key features</em>: Provides options for <a id="_idIndexMarker206" class="calibre6 pcalibre1 pcalibre"/>target tracking, damping settings for smooth transitions, customizable FOV, <strong class="bold">depth of field</strong> (<strong class="bold">DOF</strong>), and various blending modes for seamless camera transitions and effects.</li></ul></li>
<li class="calibre11"><strong class="bold">2D </strong><strong class="bold">Camera (CinemachineVirtualCamera)</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Usage</em>: The <a id="_idIndexMarker207" class="calibre6 pcalibre1 pcalibre"/>2D Camera variant of CinemachineVirtualCamera is specifically designed for 2D game development, offering similar functionality to the 3D Virtual Camera but tailored for 2D environments. It is ideal for platformers, side-scrolling games, and other 2D projects requiring dynamic camera control.</li><li class="calibre11"><em class="italic">Key features</em>: Supports 2D-specific settings such as orthographic mode, pixel-perfect camera setup, pixel snapping, and follow and dead zones tailored for 2D gameplay mechanics. Allows for smooth tracking of 2D characters, parallax effects, and cinematic camera movements in 2D space.</li></ul></li>
</ul>
<p class="calibre3">In the following demonstration, we’ll implement the Virtual Camera to highlight the specific changes that <a id="_idIndexMarker208" class="calibre6 pcalibre1 pcalibre"/>occur when transitioning from Unity’s default camera to Cinemachine cameras.</p>
<p class="calibre3">Choose <strong class="bold">Virtual Camera</strong> from the <strong class="bold">Cinemachine</strong> list. When you try to add components, the main camera will be managed by Cinemachine moving forward:</p>
<div><div><img alt="Figure 3.15 – Virtual Camera option" src="img/B22017_03_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Virtual Camera option</p>
<p class="calibre3">After choosing <strong class="bold">Virtual Camera</strong>, the <strong class="bold">CinemachineBrain</strong> component will be added to the <strong class="bold">MainCamera</strong> GameObject, as seen in <em class="italic">Figure 3</em><em class="italic">.16</em>. The <strong class="bold">CinemachineBrain</strong> component <a id="_idIndexMarker209" class="calibre6 pcalibre1 pcalibre"/>orchestrates multiple virtual cameras, managing their activation, blending, and behavior for smooth transitions and dynamic camera control, crucial for creating immersive and visually engaging scenes in Unity projects using Cinemachine:</p>
<div><div><img alt="Figure 3.16 – CinemachineBrain component" src="img/B22017_03_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.16 – CinemachineBrain component</p>
<p class="calibre3">Also, it will create a new game object for<a id="_idIndexMarker210" class="calibre6 pcalibre1 pcalibre"/> this virtual camera inside the scene that has the <strong class="bold">CinemachineVirtualCamera</strong> component, as seen in the following figure:</p>
<div><div><img alt="Figure 3.17 – CinemachineVirtualCamera component" src="img/B22017_03_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.17 – CinemachineVirtualCamera component</p>
<p class="calibre3">In summary, you successfully integrated Cinemachine into your game, allowing for streamlined camera<a id="_idIndexMarker211" class="calibre6 pcalibre1 pcalibre"/> management and dynamic virtual camera movements to enhance your game’s visual experience.</p>
<h3 class="calibre9">Enhancing gameplay dynamics – adding shake effects with Cinemachine</h3>
<p class="calibre3">Utilizing Cinemachine to<a id="_idIndexMarker212" class="calibre6 pcalibre1 pcalibre"/> elevate our game experience, we’ll now explore the integration of effects, specifically focusing on incorporating a shake effect using the <strong class="bold">CinemachineImpulseListener</strong> component. This essential component in Unity’s Cinemachine package acts as a crucial receiver of impulse signals from other Cinemachine modules, translating them into impactful visual and auditory effects within the game. Its primary function involves listening for impulse signals triggered by events such as collisions or explosions, enabling developers to apply customizable parameters such as intensity and duration for immersive feedback experiences. Seamlessly integrated with Cinemachine modules, the <strong class="bold">CinemachineImpulseListener</strong> component enhances gameplay and cinematic effects by delivering synchronized and dynamic responses to in-game events, thus significantly enhancing the overall immersive and engaging player experience.</p>
<p class="calibre3">The shake effect stands out as a highly impactful element in game design, contributing significantly to the overall player experience. Whether applied to simulate fire, collisions, or other gameplay elements, this effect adds a layer of dynamism and engagement. Integrating a shake effect effectively enhances the player’s immersion during gameplay, creating a more compelling and enjoyable experience.</p>
<p class="calibre3">We will begin implementing this feature in the following steps:</p>
<ol class="calibre15">
<li class="calibre11">We will start by clicking on <strong class="bold">Add Extension</strong>. It will show us a menu like this:</li>
</ol>
<div><div><img alt="Figure 3.18 – Extensions menu" src="img/B22017_03_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Extensions menu</p>
<ol class="calibre15">
<li value="2" class="calibre11">Then, we <a id="_idIndexMarker213" class="calibre6 pcalibre1 pcalibre"/>click on the <strong class="bold">CinemachineImpulseListener</strong> component to add to our camera.<p class="calibre3">We can tweak the values inside this component to achieve a better effect for our game, as you can see in the following figure:</p></li>
</ol>
<div><div><img alt="Figure 3.19 – CinemachineImpulseListener component" src="img/B22017_03_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.19 – CinemachineImpulseListener component</p>
<p class="calibre3">You can <a id="_idIndexMarker214" class="calibre6 pcalibre1 pcalibre"/>learn more about values in Unity’s official documentation: <a href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/" class="calibre6 pcalibre1 pcalibre">https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/</a>.</p>
<p class="callout-heading"> Tip</p>
<p class="callout">For most Unity components, tooltips appear when you hover your mouse over the variable name.</p>
<p class="calibre3">Then, we need to add <strong class="bold">CinemachineImpulseSource</strong> to a game object. In our case, we can easily add it to the player game object, as most Interactions will be from this player. The <strong class="bold">CinemachineImpulseSource</strong> component in Unity’s Cinemachine package is a versatile tool for generating impulse signals that simulate impactful events within a game. By defining parameters such as intensity and duration, we can create a range of effects such as camera shakes, controller vibrations, or screen flashes. Integrated seamlessly with other Cinemachine components, <strong class="bold">CinemachineImpulseSource</strong> enhances gameplay and cinematic experiences by allowing dynamic responses to events and fine-tuning effects for immersive and engaging player experiences. Its customization options and scripting capabilities enable us to tailor effects to match the game’s aesthetics and mechanics, adding depth and interactivity to the overall game world.</p>
<p class="calibre3">We will <a id="_idIndexMarker215" class="calibre6 pcalibre1 pcalibre"/>need a reference to <strong class="bold">CinemachineImpulseSource</strong> in our scripts to start using it:</p>
<div><div><img alt="Figure 3.20 – CinemachineImpulseSource component" src="img/B22017_03_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.20 – CinemachineImpulseSource component</p>
<ol class="calibre15">
<li value="3" class="calibre11">Now, we will use the <strong class="source-inline1">PlayerEffects</strong> script, which will subscribe to the <strong class="source-inline1">PlayerShoot</strong> fire event to generate an impulse.<p class="calibre3">In the following <a id="_idIndexMarker216" class="calibre6 pcalibre1 pcalibre"/>code, we will generate an impulse when the player shoots fire:</p><pre class="source-code">
[RequireComponent(typeof(CinemachineImpulseSource))]
    public class PlayerEffects : MonoBehaviour
    {
        private CinemachineImpulseSource cinemachineImpulse;
        private void OnEnable()
        {
            PlayerShoot.onFire += ApplyShootFireEffect;
        }
        private void OnDisable()
        {
            PlayerShoot.onFire -= ApplyShootFireEffect;
        }
        private void Start()
        {
            cinemachineImpulse = GetComponent&lt;CinemachineImpulseSource&gt;();
        }
        private void ApplyShootFireEffect()
        {
            cinemachineImpulse.GenerateImpulse();
        }
    }</pre></li> </ol>
<p class="calibre3">That’s it! Now, whenever<a id="_idIndexMarker217" class="calibre6 pcalibre1 pcalibre"/> the player shoots, the effect will be applied.</p>
<h3 class="calibre9">Dynamic cinematic experiences – seamless camera blending with Cinemachine</h3>
<p class="calibre3">Another <a id="_idIndexMarker218" class="calibre6 pcalibre1 pcalibre"/>application of <strong class="bold">Cinemachine</strong> lies in its ability to manage multiple cameras concurrently and seamlessly blend between them at runtime. This functionality proves valuable in scenarios where you want to create a dedicated camera for specific in-game events. For instance, you can design a special camera that triggers when the player encounters a boss, automatically activating when the player enters a boss room.</p>
<p class="calibre3">In the following figure, you can find the option to add custom blends in the Cinemachine component. Click <strong class="bold">Create Asset</strong> to generate a new scriptable object, which will be responsible for managing the transition between cameras, as well as orchestrating the tween action during the transition:</p>
<div><div><img alt="Figure 3.21 – Custom Blends section in Cinemachine component" src="img/B22017_03_21.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.21 – Custom Blends section in Cinemachine component</p>
<p class="calibre3">As seen in the<a id="_idIndexMarker219" class="calibre6 pcalibre1 pcalibre"/> following figure, using a scriptable object for <strong class="bold">CinemachineBlenderSettings</strong>, you can add transitions between cameras. The <strong class="bold">CinemachineBlenderSettings</strong> component in Unity’s Cinemachine package is instrumental in orchestrating smooth transitions between virtual cameras within a scene. By defining blend curves, weighting parameters, and blend techniques, we can control the rate, style, and visual dominance of camera blending, resulting in seamless and visually engaging camera movements during gameplay or cinematic sequences. With support for prioritization, triggering mechanisms, and extensive customization options, <strong class="bold">CinemachineBlenderSettings</strong> empowers us to create dynamic and immersive camera transitions tailored to the game’s aesthetics and narrative, enhancing overall player experience and immersion:</p>
<div><div><img alt="Figure 3.22 – CinemachineBlenderSettings scriptable object" src="img/B22017_03_22.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.22 – CinemachineBlenderSettings scriptable object</p>
<p class="calibre3">To utilize this functionality, you can enable or disable the game objects of the cameras or adjust the priority of the current camera by increasing it and decreasing the priority of the previous camera.</p>
<pre>SwitchCamera()</strong> function, which accepts an <code>Enum</code> parameter representing the camera type. This enables us to selectively activate the desired camera based on the specified type:</pre>
<pre class="source-code">
   public class CameraManager : Singlton&lt;CameraManager&gt;
    {
        // Dictionary to map enum values to Cinemachine virtual cameras
        public GenericDictionary&lt;CameraType, CinemachineVirtualCamera&gt; cameraDictionary = new GenericDictionary&lt;CameraType, CinemachineVirtualCamera&gt;();
        // Reference to the currently active virtual camera
        private CinemachineVirtualCamera currentCamera;
        void Start()
        {
            SwitchCamera(CameraType.PlayerCamera);
        }
        // Function to switch between virtual cameras using the enum
        public void SwitchCamera(CameraType newCameraType)
        {
            // Disable the current camera
            if (currentCamera != null)
            {
                currentCamera.gameObject.SetActive(false);
            }
            // Enable the new camera based on the enum
            if (cameraDictionary.ContainsKey(newCameraType))
            {
                currentCamera = cameraDictionary[newCameraType];
                currentCamera.gameObject.SetActive(true);
            }
            else
            {
                Debug.LogWarning("Camera of type " + newCameraType + " not found in the dictionary.");
            }
        }
    }
    // Enum to represent different cameras
    public enum CameraType
    {
        PlayerCamera,
        BossCamera,
        // Add more camera types as needed
    }</pre> <p class="calibre3">You can find all the code in<a id="_idIndexMarker221" class="calibre6 pcalibre1 pcalibre"/> our GitHub repo, the link to which is mentioned in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<p class="callout-heading">Note</p>
<p class="callout">I have chosen to use enums instead of strings for better performance efficiency.</p>
<p class="calibre3">The following code outlines the enum for various camera types:</p>
<pre class="source-code">
public enum CameraType
    {
        PlayerCamera,
        BossCamera,
        // Add more camera types as needed
    }
PlayerCollision</strong> class:</pre>
<pre class="source-code">
namespace FusionFuryGame
{
    public class PlayerCollision : MonoBehaviour
    {
        private void OnTriggerEnter(Collider other)
        {
            if (other.CompareTag("BossArea"))
            {
                CameraManager.Instance.SwitchCamera(CameraType.BossCamera);
            }
        }
        private void OnTriggerExit(Collider other)
        {
            if (other.CompareTag("BossArea"))
            {
                CameraManager.Instance.SwitchCamera(CameraType.PlayerCamera);
            }
        }
    }
}</pre> <p class="callout-heading">Tip</p>
<p class="callout">Given the abundance of Unity plugins, it’s essential to pick the right one for your project.</p>
<p class="calibre3">In conclusion, Cinemachine<a id="_idIndexMarker223" class="calibre6 pcalibre1 pcalibre"/> offers Unity developers intuitive camera controls, effortless perspective guidance, realism with procedural noise, automatic framing, seamless Timeline integration, and enhanced storytelling capabilities. As we conclude this section, we have explored its features and benefits, preparing to leverage its power in our game development endeavors.</p>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor056" class="calibre6 pcalibre1 pcalibre"/>Best practices for using Unity plugins</h1>
<p class="calibre3">Before<a id="_idIndexMarker224" class="calibre6 pcalibre1 pcalibre"/> integrating plugins into your project, it’s essential to thoroughly explore their functionality, understand their documentation, assess compatibility and potential impact, evaluate specific features, stay updated with releases, check version compatibility, maintain project integrity, set up a testing environment, document integrations for future reference, and track and resolve issues encountered during integration:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Exploring plugin functionality</strong>: Before adding a plugin, thoroughly explore its features and functionalities</li>
<li class="calibre11"><strong class="bold">Understanding documentation</strong>: Dive into the plugin’s documentation for a clear understanding of its capabilities</li>
<li class="calibre11"><strong class="bold">Compatibility and impact assessment</strong>: Evaluate how the plugin aligns with your project, considering aspects such as performance and potential conflicts</li>
<li class="calibre11"><strong class="bold">Feature assessment</strong>: Assess specific features to ensure they meet your project’s requirements</li>
<li class="calibre11"><strong class="bold">Keeping plugins updated</strong>: Stay informed about updates, bug fixes, and new features for your integrated plugins</li>
<li class="calibre11"><strong class="bold">Version compatibility checks</strong>: Verify that the plugin aligns with the current Unity version, exercising caution during Unity updates</li>
<li class="calibre11"><strong class="bold">Maintaining project integrity</strong>: Back up your entire project before making significant changes to avoid data loss</li>
<li class="calibre11"><strong class="bold">Testing environment</strong>: Create a dedicated testing environment to evaluate plugin updates or modifications</li>
<li class="calibre11"><strong class="bold">Documentation for future reference</strong>: Create detailed integration documentation and include configurations, settings, and troubleshooting steps</li>
<li class="calibre11"><strong class="bold">Issue tracking and resolution</strong>: Maintain a record of encountered issues and their resolutions for future reference</li>
</ul>
<p class="calibre3">In<a id="_idIndexMarker225" class="calibre6 pcalibre1 pcalibre"/> summary, exploring, understanding, assessing, updating, checking compatibility, maintaining integrity, testing, documenting, and tracking issues are crucial steps in effectively integrating and managing plugins within your Unity project.</p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor057" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In wrapping up this chapter, we’ve covered the ins and outs of Unity plugins, understanding the basic and extended features they offer. You’ve also learned how to integrate the new Input System and Cinemachine using C#, gaining practical skills to enhance your game development projects. We’ve emphasized the importance of adopting best practices when working with plugins, setting the stage for more efficient integration into your projects. As you reflect on keeping your code organized and neat, these skills will be valuable as you continue your journey toward becoming a skilled Unity developer.</p>
<p class="calibre3">Looking ahead to the next chapter, <em class="italic">Creating Fun Game Mechanics with C# in Unity</em>, get ready to expand your game development toolkit. Building on what you’ve learned about clean coding practices, you’ll explore how to bring excitement to your games through the expressive C# programming language. Imagine seamlessly incorporating your knowledge of plugins and organized code into the creation of engaging game mechanics. The upcoming chapter promises exciting challenges and discoveries that will further enhance your Unity development skills. Get ready to dive into the world of crafting immersive and enjoyable game mechanics in <a href="B22017_04.xhtml#_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 4</em></a>. Happy coding on this ongoing journey of skill-building!</p>
</div>
</body></html>