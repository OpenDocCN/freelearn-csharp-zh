<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>14 Layering and Clean Architecture</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="15" id="layering-and-clean-architecture">
<h1 data-number="15"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">14 Layering and Clean Architecture</span></h1>
<section class="level2" data-number="15.1" id="before-you-begin-join-our-book-community-on-discord-13">
<h2 data-number="15.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file74.png" style="width:10em"/></span><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">In this chapter, we explore the inherent concepts behind layering. </span><span class="koboSpan" id="kobo.6.2" xmlns="http://www.w3.org/1999/xhtml">Layering is a popular way of organizing computer systems by encapsulating major concerns into layers. </span><span class="koboSpan" id="kobo.6.3" xmlns="http://www.w3.org/1999/xhtml">Those concerns are related to a computer vocation, such as data access, instead of a business concern, such as inventory. </span><span class="koboSpan" id="kobo.6.4" xmlns="http://www.w3.org/1999/xhtml">Understanding the concepts behind layering is essential, as other concepts were born from layers and are very common.We start this chapter by exploring the initial ideas behind layering. </span><span class="koboSpan" id="kobo.6.5" xmlns="http://www.w3.org/1999/xhtml">Then, we explore alternatives that can help us solve different problems. </span><span class="koboSpan" id="kobo.6.6" xmlns="http://www.w3.org/1999/xhtml">We use anemic and rich models and expose their pros </span><strong/><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml"> and cons. </span><span class="koboSpan" id="kobo.7.2" xmlns="http://www.w3.org/1999/xhtml">Finally, we quickly explore </span><strong><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture</span></strong><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">, an evolution of layering, and a way to organize layers.This chapter lays out the evolution of layering, starting with basic, restrictive, and even flawed techniques, then we gradually move toward more modern patterns. </span><span class="koboSpan" id="kobo.9.2" xmlns="http://www.w3.org/1999/xhtml">This journey should help you understand the concepts and practices behind layering, giving you a stronger understanding than just learning one way of doing things. </span><span class="koboSpan" id="kobo.9.3" xmlns="http://www.w3.org/1999/xhtml">The key is to understand.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">Introducing layering</span></li>
<li><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">Responsibilities of the common layers</span></li>
<li><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml">Abstract layers</span></li>
<li><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Sharing a model</span></li>
<li><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture</span></li>
<li><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Implementing layering in real life</span></li>
</ul>
<p><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">Let’s get started!</span></p>
</section>
<section class="level2" data-number="15.2" id="introducing-layering">
<h2 data-number="15.2"><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">Introducing layering</span></h2>
<p><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve explored a few design patterns and played with ASP.NET Core, it is time to jump into layering. </span><span class="koboSpan" id="kobo.18.2" xmlns="http://www.w3.org/1999/xhtml">In most computer systems, there are layers. </span><span class="koboSpan" id="kobo.18.3" xmlns="http://www.w3.org/1999/xhtml">Why? </span><span class="koboSpan" id="kobo.18.4" xmlns="http://www.w3.org/1999/xhtml">Because it is an efficient way to partition and organize units of logic together. </span><span class="koboSpan" id="kobo.18.5" xmlns="http://www.w3.org/1999/xhtml">We could conceptually represent layers as horizontal software segments, each encapsulating a concern.</span></p>
<section class="level3" data-number="15.2.1" id="classic-layering-model">
<h3 data-number="15.2.1"><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">Classic layering model</span></h3>
<p><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start by examining a classic three-layer application design:</span></p>
<figure>
<span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.1: A classic three-layer application design" src="../media/file75.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.1: A classic three-layer application design</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml"> represents any user interface that a user can interact with to reach the </span><strong><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.27.2" xmlns="http://www.w3.org/1999/xhtml">It could be an ASP.NET Core web application. </span><span class="koboSpan" id="kobo.27.3" xmlns="http://www.w3.org/1999/xhtml">Anything from WPF to WinForms to Android could be a valid non-web presentation layer alternative.The </span><strong><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml"> represents the core logic driven by the business rules; this solves the application’s problem. </span><span class="koboSpan" id="kobo.29.2" xmlns="http://www.w3.org/1999/xhtml">The domain layer is also called the </span><strong><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">business logic layer</span></strong><span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml">BLL</span></strong><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml">).The </span><strong><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml"> represents the bridge between the data and the application. </span><span class="koboSpan" id="kobo.35.2" xmlns="http://www.w3.org/1999/xhtml">The layer can store the data in a SQL Server database, a NoSQL database hosted in the cloud, a mix of many data sources, or anything else that fits the business needs. </span><span class="koboSpan" id="kobo.35.3" xmlns="http://www.w3.org/1999/xhtml">The data layer is also called the </span><strong><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml">data access layer</span></strong><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml">DAL</span></strong><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml">) and the </span><strong><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml">persistence layer</span></strong><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml">.Let’s jump to an example. </span><span class="koboSpan" id="kobo.41.2" xmlns="http://www.w3.org/1999/xhtml">Given that a user has been authenticated and authorized, here is what happens when they want to create a book in a bookstore application built using those three layers:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml">The user requests the page by sending a </span><code><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">GET</span></code><span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml"> request to the server.</span></li>
<li><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml">The server handles that </span><code><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">GET</span></code><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml"> request (</span><strong><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml">) and then returns the page to the user.</span></li>
<li><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml">The user fills out the form and sends a </span><code><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml"> request to the server.</span></li>
<li><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">The server handles the </span><code><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml">POST</span></code><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml"> request (</span><strong><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">) and then sends it to the </span><strong><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml"> for processing.</span></li>
<li><span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml"> executes the logic required to create a book, then tells the </span><strong><span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml"> to persist that data.</span></li>
<li><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">After unrolling to the presentation layer, the server returns the appropriate response to the user, most likely a page containing a list of books and a message saying the operation was successful.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml">Following a classic layering architecture, a layer can only talk to the next layer in the stack—</span><strong><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml">presentation</span></strong><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml"> talks to </span><strong><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml">, which talks to </span><strong><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml">, and so on. </span><span class="koboSpan" id="kobo.72.2" xmlns="http://www.w3.org/1999/xhtml">The important part is that </span><strong><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml">each layer must be independent and isolated to limit tight coupling</span></strong><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml">.In this classic layering model, each layer should own its </span><strong><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">model</span></strong><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.76.2" xmlns="http://www.w3.org/1999/xhtml">For example, the presentation layer should not send its </span><strong><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml">view models</span></strong><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml"> to the </span><strong><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml"> layer; only </span><strong><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml">domain objects</span></strong><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml"> should be used there. </span><span class="koboSpan" id="kobo.82.2" xmlns="http://www.w3.org/1999/xhtml">The opposite is also true: since the </span><strong><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml"> returns its own objects to the </span><strong><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml">, the </span><strong><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml"> should not leak them to its consumers but organize the required information into </span><strong><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">view models</span></strong><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><strong><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml">DTO</span></strong><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml"> instead.Here is a visual example:</span></p>
<figure>
<span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.2: Diagram representing how the layers interact with one another" src="../media/file76.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.2: Diagram representing how the layers interact with one another</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml">Even if three is probably the most popular number of layers, we can create as many as we need; we are not limited to three layers.Let’s examine the advantages and disadvantages of classic layering, starting with the advantages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml">Knowing the purpose of a layer makes it easy to understand. </span><span class="koboSpan" id="kobo.96.2" xmlns="http://www.w3.org/1999/xhtml">For example, guessing that the data layer components read or write some data somewhere is easy.</span></li>
<li><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml">It creates a cohesive unit built around a single concern. </span><span class="koboSpan" id="kobo.97.2" xmlns="http://www.w3.org/1999/xhtml">For example, our </span><strong><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml"> should not render any user interface but stick to accessing data.</span></li>
<li><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml">It allows us to decouple the layer from the rest of the system (the other layers). </span><span class="koboSpan" id="kobo.100.2" xmlns="http://www.w3.org/1999/xhtml">You can isolate and work within a layer with limited to no knowledge of the others. </span><span class="koboSpan" id="kobo.100.3" xmlns="http://www.w3.org/1999/xhtml">For example, suppose you are tasked with optimizing a query in a data access layer. </span><span class="koboSpan" id="kobo.100.4" xmlns="http://www.w3.org/1999/xhtml">In that case, you don’t need to know about the user interface that eventually displays that data to a user. </span><span class="koboSpan" id="kobo.100.5" xmlns="http://www.w3.org/1999/xhtml">You only need to focus on that element, optimize it, test it in isolation, and then ship the layer or redeploy the application.</span></li>
<li><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml">Like any other isolated unit, it should be possible to reuse a layer. </span><span class="koboSpan" id="kobo.101.2" xmlns="http://www.w3.org/1999/xhtml">For example, we could reuse our </span><strong><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml">data access layer</span></strong><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml"> in another application that needs to query the same database for a different purpose (a different </span><strong><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
</ul>
<blockquote>
<p><strong><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml">TIP</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml">Some layers are theoretically easier to reuse than others, and reusability could add more or less value, depending on the software you are building. </span><span class="koboSpan" id="kobo.107.2" xmlns="http://www.w3.org/1999/xhtml">I have never seen a layer being integrally reused in practice, and I’ve rarely heard or read about such a situation—each time rather ends in a not-so-reusable-after-all situation.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml">Based on my experience, I would strongly suggest not over-aiming at reusability when it is not a precise specification that adds value to your application. </span><span class="koboSpan" id="kobo.108.2" xmlns="http://www.w3.org/1999/xhtml">Limiting your overengineering endeavors could save you and your employers a lot of time and money. </span><span class="koboSpan" id="kobo.108.3" xmlns="http://www.w3.org/1999/xhtml">We must not forget that our job is to deliver value.</span></p>
</blockquote>
<blockquote>
<p><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml">As a rule of thumb, do what needs to be done, not more, but do it well.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">OK, now, let’s look at the drawbacks:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml">By splitting your software horizontally into layers, each feature crosses all of the layers. </span><span class="koboSpan" id="kobo.111.2" xmlns="http://www.w3.org/1999/xhtml">This often leads to cascading changes between layers. </span><span class="koboSpan" id="kobo.111.3" xmlns="http://www.w3.org/1999/xhtml">For example, if we decide to add a field to our bookstore database, we would need to update the database, the code that accesses it (</span><strong><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml">), the business logic (</span><strong><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml">), and the user interface (</span><strong><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.117.2" xmlns="http://www.w3.org/1999/xhtml">With volatile specs or low-budget projects, this can become painful!</span></li>
<li><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml">Implementing a full-stack feature is more challenging for newcomers because it crosses all layers.</span></li>
<li><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml">Using layering often leads to or is caused by a separation of responsibilities between the staff. </span><span class="koboSpan" id="kobo.119.2" xmlns="http://www.w3.org/1999/xhtml">For example, DBAs manage the data layer, backend devs manage the domain layer, and frontend devs manage the presentation layer, leading to coordination and knowledge-sharing issues.</span></li>
<li><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml">Since a layer directly depends on the layer under it, dependency injection is impossible without introducing an </span><strong><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml">abstraction layer</span></strong><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml"> or referencing lower layers from the </span><strong><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.124.2" xmlns="http://www.w3.org/1999/xhtml">For example, if the </span><strong><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml"> depends on the </span><strong><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml">, changing the data layer would require rewriting all of that coupling from the </span><strong><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml"> to the </span><strong><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml">Since each layer owns its entities, the more layers you add, the more copies there are of the entities, leading to minor performance loss and a higher maintenance cost. </span><span class="koboSpan" id="kobo.133.2" xmlns="http://www.w3.org/1999/xhtml">For example, the </span><strong><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml"> copies a </span><strong><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">DTO</span></strong><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml"> to a </span><strong><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml">domain object</span></strong><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.139.2" xmlns="http://www.w3.org/1999/xhtml">Then, the </span><strong><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml"> copies it to a </span><strong><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">data object</span></strong><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.143.2" xmlns="http://www.w3.org/1999/xhtml">Finally, the </span><strong><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml"> translates it into SQL to persist it into a </span><strong><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">database</span></strong><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml"> (SQL Server, for example). </span><span class="koboSpan" id="kobo.147.2" xmlns="http://www.w3.org/1999/xhtml">The opposite is also true when reading from the database.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">We explore ways to combat some of those drawbacks later.I strongly recommend that you don’t do what we just explored. </span><span class="koboSpan" id="kobo.148.2" xmlns="http://www.w3.org/1999/xhtml">It is an old, more basic way of doing layering. </span><span class="koboSpan" id="kobo.148.3" xmlns="http://www.w3.org/1999/xhtml">We are looking at multiple improvements to this layering system in this chapter, so keep reading before jumping to a conclusion. </span><span class="koboSpan" id="kobo.148.4" xmlns="http://www.w3.org/1999/xhtml">I decided to explore layering from the beginning in case you have to work with that kind of application. </span><span class="koboSpan" id="kobo.148.5" xmlns="http://www.w3.org/1999/xhtml">Furthermore, studying its chronological evolution, fixing some flaws, and adding options should help you understand the concepts instead of just knowing a single way of doing things. </span><span class="koboSpan" id="kobo.148.6" xmlns="http://www.w3.org/1999/xhtml">Understanding the patterns is the key to software architecture, not just learning how to apply them.</span></p>
</section>
<section class="level3" data-number="15.2.2" id="splitting-the-layers">
<h3 data-number="15.2.2"><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml">Splitting the layers</span></h3>
<p><span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve discussed layers and seen them as big horizontal slices of responsibilities, we can organize our applications more granularly by splitting those big slices vertically, creating multiple smaller layers. </span><span class="koboSpan" id="kobo.150.2" xmlns="http://www.w3.org/1999/xhtml">This can help us organize applications by features or by bounding context, and it could also allow us to compose various user interfaces using the same building blocks, which would be easier than reusing colossal-size layers.Here is a conceptual representation of this idea:</span></p>
<figure>
<span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.3: Organizing multiple applications using smaller partially shared layers" src="../media/file77.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.3: Organizing multiple applications using smaller partially shared layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml">We can split an application into multiple features (vertically) and divide each into layers (horizontally). </span><span class="koboSpan" id="kobo.153.2" xmlns="http://www.w3.org/1999/xhtml">Based on the previous diagram, we named those features as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml">Inventory management</span></li>
<li><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml">Online shopping</span></li>
<li><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml">Others</span></li>
</ul>
<p><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml">So, we can bring in the online shopping domain and data layers to our Shopping web API without bringing everything else with it. </span><span class="koboSpan" id="kobo.157.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, we can bring the online shopping domain layer to the mobile app and swap its data layer for another that talks to the web API.We could also use our web API as a plain and simple data access application with different logic attached to it while keeping the shopping data layer underneath.We could end up with the following recomposed applications (this is just one possible outcome):</span></p>
<figure>
<span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.4: Organizing multiple applications using smaller partially shared layers" src="../media/file78.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.4: Organizing multiple applications using smaller partially shared layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">These are just examples of what we can conceptually do with layers. </span><span class="koboSpan" id="kobo.160.2" xmlns="http://www.w3.org/1999/xhtml">However, the most important thing to remember is not how the diagrams are laid out but the specifications of the applications you are building. </span><span class="koboSpan" id="kobo.160.3" xmlns="http://www.w3.org/1999/xhtml">Only those specs and good analyses can help you create the best possible design for that exact problem. </span><span class="koboSpan" id="kobo.160.4" xmlns="http://www.w3.org/1999/xhtml">I used a hypothetical shopping example here, but it could have been anything.Splitting huge horizontal slices vertically makes each piece easier to reuse and share. </span><span class="koboSpan" id="kobo.160.5" xmlns="http://www.w3.org/1999/xhtml">This improvement can yield interesting results, especially if you have multiple frontend apps or plan to migrate away from a monolith.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml">A </span><strong><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">monolithic application</span></strong><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml"> (or monolith) is a program deployed as a single integrated piece with low modularity. </span><span class="koboSpan" id="kobo.163.2" xmlns="http://www.w3.org/1999/xhtml">A monolith can leverage layers or not. </span><span class="koboSpan" id="kobo.163.3" xmlns="http://www.w3.org/1999/xhtml">People often compare monolithic applications to microservices applications because they are antipodes. </span><span class="koboSpan" id="kobo.163.4" xmlns="http://www.w3.org/1999/xhtml">We explore microservices in </span><em><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 19</span></em><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml">Introduction to Microservices Architecture</span></em><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml">, and monoliths in </span><em><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 20</span></em><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml">Modular Monoliths</span></em><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
</section>
<section class="level3" data-number="15.2.3" id="layers-versus-tiers-versus-assemblies">
<h3 data-number="15.2.3"><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">Layers versus tiers versus assemblies</span></h3>
<p><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml">So far in this chapter, we have been talking about layers without talking about making them into code. </span><span class="koboSpan" id="kobo.173.2" xmlns="http://www.w3.org/1999/xhtml">Before jumping into that subject, I’d like to discuss </span><strong><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">tiers</span></strong><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.175.2" xmlns="http://www.w3.org/1999/xhtml">You may have seen the term </span><strong><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml">3-tier architecture</span></strong><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml"> somewhere before or heard people talking about </span><strong><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">tiers</span></strong><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml">layers</span></strong><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml">, possibly interchanging them in the same context as synonyms. </span><span class="koboSpan" id="kobo.181.2" xmlns="http://www.w3.org/1999/xhtml">However, they are not the same.In a nutshell:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">Tiers</span></strong><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml"> are </span><strong><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">physical</span></strong></li>
<li><strong><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml">Layers</span></strong><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml"> are </span><strong><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">logical</span></strong></li>
</ul>
<section class="level4" data-number="15.2.3.1" id="what-is-a-tier">
<h4 data-number="15.2.3.1"><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml">What is a Tier?</span></h4>
<p><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml">We can deploy each </span><strong><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml">tier</span></strong><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml"> on its own machine. </span><span class="koboSpan" id="kobo.191.2" xmlns="http://www.w3.org/1999/xhtml">For example, you could have a database server, a server hosting your web API that contains the business logic (the </span><strong><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml">), and another server that serves an Angular application (</span><strong><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml">presentation</span></strong><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml">); these are three tiers (three distinct machines), and each </span><strong><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml">tier</span></strong><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml"> can scale independently.We look at layers next.</span></p>
</section>
<section class="level4" data-number="15.2.3.2" id="what-is-a-layer">
<h4 data-number="15.2.3.2"><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml">What is a Layer?</span></h4>
<p><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml">On the other hand, each </span><strong><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">layer</span></strong><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml"> is only the logical organization of code, with concerns organized and divided in a layered fashion. </span><span class="koboSpan" id="kobo.201.2" xmlns="http://www.w3.org/1999/xhtml">For example, you may create one or more projects in Visual Studio and organize your code into three layers. </span><span class="koboSpan" id="kobo.201.3" xmlns="http://www.w3.org/1999/xhtml">For example, a Razor Pages application depends on a business logic layer that depends on a data access layer. </span><span class="koboSpan" id="kobo.201.4" xmlns="http://www.w3.org/1999/xhtml">When you deploy that application, all these layers, including the database, are deployed together on the same server. </span><span class="koboSpan" id="kobo.201.5" xmlns="http://www.w3.org/1999/xhtml">This would be one tier and three layers. </span><span class="koboSpan" id="kobo.201.6" xmlns="http://www.w3.org/1999/xhtml">Of course, nowadays, chances are you have a cloud database somewhere, which adds a second tier to that architecture: the application tier (which still has three layers) and database tier.Now that we’ve discussed </span><strong><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">layers</span></strong><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">tiers</span></strong><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml">, let’s look at a </span><strong><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">layer</span></strong><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml"> versus an </span><strong><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml">assembly</span></strong><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</section>
<section class="level4" data-number="15.2.3.3" id="what-is-an-assembly">
<h4 data-number="15.2.3.3"><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml">What is an assembly?</span></h4>
<p><strong><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml">Assemblies</span></strong><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml"> are commonly compiled into </span><code><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml">.dll</span></code><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">.exe</span></code><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml"> files; you can compile and consume them directly. </span><span class="koboSpan" id="kobo.216.2" xmlns="http://www.w3.org/1999/xhtml">In most cases, each project of a Visual Studio solution gets compiled into an assembly. </span><span class="koboSpan" id="kobo.216.3" xmlns="http://www.w3.org/1999/xhtml">You can also deploy them as NuGet packages and consume them from </span><a href="https://www.nuget.org"><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml">nuget.org</span></a><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml"> or a custom NuGet repository of your choosing. </span><span class="koboSpan" id="kobo.218.2" xmlns="http://www.w3.org/1999/xhtml">But there is no one-to-one relationship between a layer and an assembly or a tier and an assembly; assemblies are only consumable units of compiled code: a library or a program.Moreover, you do not need to split your layers into different assemblies; you can have your three layers residing in the same assembly. </span><span class="koboSpan" id="kobo.218.3" xmlns="http://www.w3.org/1999/xhtml">It can be easier to create undesirable coupling this way, with all of the code being in the same project, but it is a viable option with some rigor, rules, and conventions. </span><span class="koboSpan" id="kobo.218.4" xmlns="http://www.w3.org/1999/xhtml">Moving each layer to an assembly does not necessarily improve the application; the code inside each layer or assembly can become mixed up and coupled with other system parts.Don’t get me wrong: you can create an assembly per layer; I even encourage you to do so in most cases, but doing so does not mean the layers are not tightly coupled. </span><span class="koboSpan" id="kobo.218.5" xmlns="http://www.w3.org/1999/xhtml">A layer is simply a logical unit of organization, so each contributor’s responsibility is to ensure the layer’s code stays healthy.Furthermore, having multiple assemblies let us deploy them to one or more machines, potentially different machines, leading to multiple tiers.Let’s now look at the responsibilities of the most common layers.</span></p>
</section>
</section>
</section>
<section class="level2" data-number="15.3" id="responsibilities-of-the-common-layers">
<h2 data-number="15.3"><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">Responsibilities of the common layers</span></h2>
<p><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml">In this section, we explore the most commonly used layers in more depth. </span><span class="koboSpan" id="kobo.220.2" xmlns="http://www.w3.org/1999/xhtml">We do not dig too deep into each one, but the overview should help you understand the essential ideas behind layering.</span></p>
<section class="level3" data-number="15.3.1" id="presentation">
<h3 data-number="15.3.1"><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">Presentation</span></h3>
<p><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml"> is probably the easiest layer to understand because it is the only one we can see: the user interface. </span><span class="koboSpan" id="kobo.224.2" xmlns="http://www.w3.org/1999/xhtml">However, the presentation layer can also be the data contracts in case of a REST, OData, GraphQL, or other types of web service. </span><span class="koboSpan" id="kobo.224.3" xmlns="http://www.w3.org/1999/xhtml">The presentation layer is what the user uses to access your program. </span><span class="koboSpan" id="kobo.224.4" xmlns="http://www.w3.org/1999/xhtml">As another example, a CLI program can be a presentation layer. </span><span class="koboSpan" id="kobo.224.5" xmlns="http://www.w3.org/1999/xhtml">You write commands in a terminal, and the CLI dispatches them to its domain layer, executing the required business logic.The key to a maintainable presentation layer is to keep it as focused on displaying the user interface as possible with as little business logic as possible.Next, we look at the </span><strong><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml"> to see where these calls go.</span></p>
</section>
<section class="level3" data-number="15.3.2" id="domain">
<h3 data-number="15.3.2"><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml">Domain</span></h3>
<p><span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml"> is where the software’s value resides and where most of the complexity lies. </span><span class="koboSpan" id="kobo.230.2" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml"> is the home of your business logic rules.It is easier to sell a </span><strong><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">user interface</span></strong><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml"> than a </span><strong><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml"> since users connect to the domain through the presentation. </span><span class="koboSpan" id="kobo.236.2" xmlns="http://www.w3.org/1999/xhtml">However, it is important to remember that the domain is responsible for solving the problems and automating the solutions; the </span><strong><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml"> only links users’ actions to the </span><strong><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">.We usually build the domain layer around a domain model. </span><span class="koboSpan" id="kobo.240.2" xmlns="http://www.w3.org/1999/xhtml">There are two macro points of view on this:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml">Using a </span><strong><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">rich model</span></strong><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml">Using an </span><strong><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">anemic model</span></strong><span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
</ul>
<blockquote>
<p><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml">You can leverage </span><strong><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml">DDD</span></strong><span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml">) to build that model and the program around it. </span><span class="koboSpan" id="kobo.251.2" xmlns="http://www.w3.org/1999/xhtml">DDD goes hand in hand with rich models, and a well-crafted model should simplify the maintenance of the program. </span><span class="koboSpan" id="kobo.251.3" xmlns="http://www.w3.org/1999/xhtml">Doing DDD is not mandatory, and you can achieve the required level of correctness without it.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml">Another dilemma is persisting the domain model directly into the database or using an intermediate data model. </span><span class="koboSpan" id="kobo.252.2" xmlns="http://www.w3.org/1999/xhtml">We talk about that in more detail in the </span><em><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml">Data</span></em><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml"> section.Meanwhile, we look at the two primary ways to think about the domain model, starting with the rich domain model.</span></p>
<section class="level4" data-number="15.3.2.1" id="rich-domain-model">
<h4 data-number="15.3.2.1"><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml">Rich domain model</span></h4>
<p><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">A rich domain model is more object-oriented, in the “purest” sense of the term, and encapsulates the domain logic as part of the model inside methods. </span><span class="koboSpan" id="kobo.256.2" xmlns="http://www.w3.org/1999/xhtml">For example, the following class represents the rich version of a minimal </span><code><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml"> class that contains only a few properties:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml">public class Product
{
    public Product(string name, int quantityInStock, int? </span><span class="koboSpan" id="kobo.259.2" xmlns="http://www.w3.org/1999/xhtml">id = null)
    {
        Name = name ?? </span><span class="koboSpan" id="kobo.259.3" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(name));
        QuantityInStock = quantityInStock;
        Id = id;
    }
    public int? </span><span class="koboSpan" id="kobo.259.4" xmlns="http://www.w3.org/1999/xhtml">Id { get; init; }
    public string Name { get; init; }
    public int QuantityInStock { get; private set; }
    public void AddStock(int amount)
    {
        if (amount == 0) { return; }
        if (amount &lt; 0) { 
            throw new NegativeValueException(amount);
        }
        QuantityInStock += amount;
    }
    public void RemoveStock(int amount)
    {
        if (amount == 0) { return; }
        if (amount &lt; 0) { 
            throw new NegativeValueException(amount);
        }
        if (amount &gt; QuantityInStock) { 
            throw new NotEnoughStockException(
                QuantityInStock, amount); 
        }
        QuantityInStock -= amount;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml">AddStock</span></code><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml">RemoveStock</span></code><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml"> methods represent the domain logic of adding and removing stock for the product inventory. </span><span class="koboSpan" id="kobo.264.2" xmlns="http://www.w3.org/1999/xhtml">Of course, we only increment and decrement a property’s value in this case, but the concept would be the same in a more complex model.The biggest advantage of this approach is that most of the logic is built into the model, making this very domain-centric with operations programmed on model entities as methods. </span><span class="koboSpan" id="kobo.264.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, it reaches the basic ideas behind object-oriented design, where behaviors should be part of the objects, making them a virtual representation of their real-life counterparts.The biggest drawback is the accumulation of responsibilities by a single class. </span><span class="koboSpan" id="kobo.264.4" xmlns="http://www.w3.org/1999/xhtml">Even if object-oriented design tells us to put logic into the objects, this does not mean it is always a good idea. </span><span class="koboSpan" id="kobo.264.5" xmlns="http://www.w3.org/1999/xhtml">If flexibility is important for your system, hardcoding logic into the domain model may hinder your ability to evolve business rules without changing the code itself (it can still be done). </span><span class="koboSpan" id="kobo.264.6" xmlns="http://www.w3.org/1999/xhtml">A rich model might be a good choice for your project if the domain is fixed and predefined.A relative drawback of this approach is that injecting dependencies into the domain model is harder than other objects, such as services. </span><span class="koboSpan" id="kobo.264.7" xmlns="http://www.w3.org/1999/xhtml">This drawback reduces flexibility and increases the complexity of creating the models.A rich domain model can be useful if you are building a stateful application where the domain model can live in memory longer than the time of an HTTP request. </span><span class="koboSpan" id="kobo.264.8" xmlns="http://www.w3.org/1999/xhtml">Other patterns can help you with that, such as </span><strong><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">Model-View-View-Model</span></strong><span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml">MVVM</span></strong><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml">), Model-View-Presenter (MVP), and </span><strong><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml">Model-View-Update</span></strong><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml">MVU</span></strong><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml">).If you believe your application would benefit from keeping the data and the logic together, then a rich domain model is most likely a good idea for your project. </span><span class="koboSpan" id="kobo.272.2" xmlns="http://www.w3.org/1999/xhtml">If you are practicing DDD, I probably don’t have to tell you that a rich model is the way to go. </span><span class="koboSpan" id="kobo.272.3" xmlns="http://www.w3.org/1999/xhtml">Without DDD notions, achieving a maintainable and flexible rich model is challenging.A rich model can be a good option if your program is built around a complex domain model and persists those classes directly to your database using an </span><strong><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml">object-relational mapper</span></strong><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml">ORM</span></strong><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.276.2" xmlns="http://www.w3.org/1999/xhtml">Using Cosmos DB, Firebase, MongoDB, or any other document database can make storing complex models as a single document easier than a collection of tables (this applies to anemic models too).As you may have noticed, there are a lot of “ifs” in this section because I don’t think there is an absolute answer to whether a rich model is better or not, and it is more a question of whether it is better for your specific case than better overall. </span><span class="koboSpan" id="kobo.276.3" xmlns="http://www.w3.org/1999/xhtml">You also need to take your personal preferences and skills into account.Experience is most likely your best ally here, so I’d recommend coding, coding, and coding more applications to acquire that experience.</span></p>
</section>
<section class="level4" data-number="15.3.2.2" id="anemic-domain-model">
<h4 data-number="15.3.2.2"><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml">Anemic domain model</span></h4>
<p><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml">An anemic domain model usually does not contain methods but only getters and setters. </span><span class="koboSpan" id="kobo.278.2" xmlns="http://www.w3.org/1999/xhtml">Such models must not contain business logic rules. </span><span class="koboSpan" id="kobo.278.3" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml">Product</span></code><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml"> class we had previously would look like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">public class Product
{
    public int? </span><span class="koboSpan" id="kobo.281.2" xmlns="http://www.w3.org/1999/xhtml">Id { get; set; }
    public required string Name { get; set; }
    public int QuantityInStock { get; set; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, there is no method in the class anymore, only the three properties with public setters. </span><span class="koboSpan" id="kobo.282.2" xmlns="http://www.w3.org/1999/xhtml">We can also leverage a record class to add immutability to the mix. </span><span class="koboSpan" id="kobo.282.3" xmlns="http://www.w3.org/1999/xhtml">As for the logic, we must move it elsewhere, in other classes. </span><span class="koboSpan" id="kobo.282.4" xmlns="http://www.w3.org/1999/xhtml">One such pattern would be to move the logic to a </span><strong><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">service layer</span></strong><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml">.A </span><strong><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml">service layer</span></strong><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml"> in front of such an </span><strong><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml">anemic model</span></strong><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml"> would take the input, mutate the domain object, and update the database. </span><span class="koboSpan" id="kobo.288.2" xmlns="http://www.w3.org/1999/xhtml">The difference is that the service owns the logic instead of the rich model.With the anemic model, separating the operations from the data can help us add flexibility to a system. </span><span class="koboSpan" id="kobo.288.3" xmlns="http://www.w3.org/1999/xhtml">However, enforcing the model’s state at any given time can be challenging since external actors (services) are modifying the model instead of the model managing itself.Encapsulating logic into smaller units makes it easier to manage each of them, and it is easier to inject those dependencies into the service classes than injecting them into the entities themselves. </span><span class="koboSpan" id="kobo.288.4" xmlns="http://www.w3.org/1999/xhtml">Having more smaller units of code can make a system more dreadful for a newcomer as it can be more complex to understand since it has more moving parts. </span><span class="koboSpan" id="kobo.288.5" xmlns="http://www.w3.org/1999/xhtml">On the other hand, if the system is built around well-defined abstractions, it can be easier to test each unit in isolation.However, the tests can be quite different. </span><span class="koboSpan" id="kobo.288.6" xmlns="http://www.w3.org/1999/xhtml">In the case of our rich model, we test the rules and the persistence separately. </span><span class="koboSpan" id="kobo.288.7" xmlns="http://www.w3.org/1999/xhtml">We call this </span><strong><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml">persistence ignorance</span></strong><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml">, which allows us to test business rules in isolation. </span><span class="koboSpan" id="kobo.290.2" xmlns="http://www.w3.org/1999/xhtml">Then we could create integration tests to cover the persistence aspect of the service layer and more unit and integration tests on the data and domain levels. </span><span class="koboSpan" id="kobo.290.3" xmlns="http://www.w3.org/1999/xhtml">With an anemic model, we test both the business rules and the persistence simultaneously with integration tests at the service layer level or test only the business rules in unit tests that mock the persistence part away. </span><span class="koboSpan" id="kobo.290.4" xmlns="http://www.w3.org/1999/xhtml">Since the model is just a data bag without logic, there is nothing to test there.All in all, if the same rigorous domain analysis process is followed, the business rules of an anemic model backed by a service layer should be as complex as a rich domain model. </span><span class="koboSpan" id="kobo.290.5" xmlns="http://www.w3.org/1999/xhtml">The biggest difference should be in which classes the methods are located.An anemic model is a good option for stateless systems, such as RESTful APIs. </span><span class="koboSpan" id="kobo.290.6" xmlns="http://www.w3.org/1999/xhtml">Since you have to recreate the model’s state for every request, an anemic model can offer you a way to independently recreate a smaller portion of the model with smaller classes optimized for each use case. </span><span class="koboSpan" id="kobo.290.7" xmlns="http://www.w3.org/1999/xhtml">Stateless systems require a more procedural type of thinking than a purely object-oriented approach, leaving the anemic models as excellent candidates for that.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml">I personally love anemic models behind a service layer, but some people would not agree with me. </span><span class="koboSpan" id="kobo.291.2" xmlns="http://www.w3.org/1999/xhtml">I recommend choosing what you think is best for the system you are building instead of doing something based on what someone else did in another system.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml">Another good tip is to let the refactoring flow </span><em><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">top-down</span></em><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml"> to the right location. </span><span class="koboSpan" id="kobo.294.2" xmlns="http://www.w3.org/1999/xhtml">For example, if you feel that a method is bound to an entity, nothing stops you from moving that piece of logic into that entity instead of a service class. </span><span class="koboSpan" id="kobo.294.3" xmlns="http://www.w3.org/1999/xhtml">If a service is more appropriate, move the logic to a service class.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s go back to the </span><strong><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml"> and explore a pattern that emerged over the years to shield the </span><strong><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml">domain model</span></strong><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml"> using a </span><strong><span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml">service layer</span></strong><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">, splitting the </span><strong><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml"> into two distinct pieces.</span></p>
</section>
<section class="level4" data-number="15.3.2.3" id="service-layer">
<h4 data-number="15.3.2.3"><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml">Service layer</span></h4>
<p><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml">service layer</span></strong><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml"> shields the domain model and encapsulates domain logic. </span><span class="koboSpan" id="kobo.307.2" xmlns="http://www.w3.org/1999/xhtml">The service layer orchestrates the complexity of interacting with the model or external resources such as databases. </span><span class="koboSpan" id="kobo.307.3" xmlns="http://www.w3.org/1999/xhtml">Multiple components can then use the service layer while having limited knowledge of the model:</span></p>
<figure>
<span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.5: Service layer relationships with other layers" src="../media/file79.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.5: Service layer relationships with other layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml">The preceding diagram shows that the presentation layer talks to the service layer, which manages the domain model and implements the business logic.The </span><strong><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml">service layer</span></strong><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml"> contains services, which are classes that interact with other </span><strong><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml">domain objects</span></strong><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">, such as the </span><strong><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml">domain model</span></strong><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml"> and the </span><strong><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml">.We can further divide services into two categories, </span><strong><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml">domain services</span></strong><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><strong><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml">application services</span></strong><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml">:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml">Domain services</span></strong><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml"> are those services we are talking about so far. </span><span class="koboSpan" id="kobo.324.2" xmlns="http://www.w3.org/1999/xhtml">They contain domain logic and allow consumers from the presentation layer to read or write data. </span><span class="koboSpan" id="kobo.324.3" xmlns="http://www.w3.org/1999/xhtml">They access and mutate the domain model.</span></li>
<li><strong><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml">Application services</span></strong><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml"> like email services are unrelated to the domain and should live elsewhere, like in a shared (why rewrite an email service for every project, right?).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">As with other layers, your service layer could expose its own model, shielding its consumers from domain model (internal) changes. </span><span class="koboSpan" id="kobo.327.2" xmlns="http://www.w3.org/1999/xhtml">In other words, the service layer should only expose its contracts and interfaces (keyword: shield). </span><strong><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml">A service layer is a form of façade.</span></strong></p>
<blockquote>
<p><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml">We further explore ways to keep copying anemic classes into other anemic classes to a minimum.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml">There are many ways to interpret this layer, and I’ll try to illustrate as many as possible in a condensed manner (from simpler to more complex ones):</span></p>
<ul>
<li><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml">The classes and interfaces of the service layer could be part of the domain layer’s assembly, created in a </span><em><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">Services</span></em><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml"> directory, for example. </span><span class="koboSpan" id="kobo.333.2" xmlns="http://www.w3.org/1999/xhtml">This is less reusable, but it paves the way to sharing services in the future without managing multiple projects at first. </span><span class="koboSpan" id="kobo.333.3" xmlns="http://www.w3.org/1999/xhtml">It needs rigor to not depend on what you should not.</span></li>
<li><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml">The service layer could be an assembly containing interfaces and implementation. </span><span class="koboSpan" id="kobo.334.2" xmlns="http://www.w3.org/1999/xhtml">This is a great compromise between reusability and maintenance time. </span><span class="koboSpan" id="kobo.334.3" xmlns="http://www.w3.org/1999/xhtml">Chances are you will never need two implementations (see the next point) because the services are tied to the logic; they are the domain. </span><span class="koboSpan" id="kobo.334.4" xmlns="http://www.w3.org/1999/xhtml">You could even hide the implementation, as we did with the </span><strong><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml">opaque façade</span></strong><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml"> in </span><em><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 11</span></em><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">Structural Patterns</span></em><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml">The service layer could be divided into two assemblies -- one containing abstractions (referenced by consumers) and one containing implementations.</span></li>
<li><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">The service layer could be an actual web service tier (such as a web API).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">When writing services code, by convention, people usually suffix a service class with </span><code><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">Service</span></code><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml">, such as </span><code><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">ProductService</span></code><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml">InventoryService</span></code><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml">; the same goes for interfaces (</span><code><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml">IProductService</span></code><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml">IInventoryService</span></code><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml">).No matter which technique you choose, remember that the service layer contains the domain logic and shields the domain model from direct access.The service layer is an amazing addition that shields and encapsulates the logic for manipulating an anemic domain model. </span><span class="koboSpan" id="kobo.353.2" xmlns="http://www.w3.org/1999/xhtml">It can defeat the purpose of a rich domain model if it’s just a pass-through but can be very useful to handle complex, non-atomic business rules that affect multiple domain objects.The primary decider of whether or not to add a service layer is tied to the complexity of your project’s domain. </span><span class="koboSpan" id="kobo.353.3" xmlns="http://www.w3.org/1999/xhtml">The more complex, the more it makes sense. </span><span class="koboSpan" id="kobo.353.4" xmlns="http://www.w3.org/1999/xhtml">The more trivial, the less it makes sense. </span><span class="koboSpan" id="kobo.353.5" xmlns="http://www.w3.org/1999/xhtml">Here are a few tips:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml">Add a service layer when using an anemic model.</span></li>
<li><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml">Add a service layer for very complex domains.</span></li>
<li><span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml">Do not add a service layer for low-complexity domains or </span><em><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml">façade over database</span></em><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml"> applications.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml">Now, let’s look at the data layer.</span></p>
</section>
</section>
<section class="level3" data-number="15.3.3" id="data">
<h3 data-number="15.3.3"><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml">Data</span></h3>
<p><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml"> is where the persistence code goes. </span><span class="koboSpan" id="kobo.363.2" xmlns="http://www.w3.org/1999/xhtml">In most programs, we need some kind of persistence to store our application data, which is often a database. </span><span class="koboSpan" id="kobo.363.3" xmlns="http://www.w3.org/1999/xhtml">Several patterns come to mind when discussing the data layer, including the </span><strong><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml">Unit of Work</span></strong><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml">Repository patterns</span></strong><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">, which are very common. </span><span class="koboSpan" id="kobo.367.2" xmlns="http://www.w3.org/1999/xhtml">We cover these two patterns very briefly at the end of this subsection.We can persist our </span><strong><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml">domain model</span></strong><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml"> as is or create a </span><strong><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml">data model</span></strong><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml"> that is more suited to be stored. </span><span class="koboSpan" id="kobo.371.2" xmlns="http://www.w3.org/1999/xhtml">For example, a many-to-many relationship is not a thing in the object-oriented world, while it is from a relational database standpoint.You can view a </span><strong><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml">data model</span></strong><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml"> like a </span><strong><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml">DTO</span></strong><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml"> for the data. </span><span class="koboSpan" id="kobo.375.2" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml">data model</span></strong><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml"> is how the data is stored in your data store; that is, how you modeled your data or what you have to live with.In a classic layering project, you have no choice but to have a data model. </span><span class="koboSpan" id="kobo.377.2" xmlns="http://www.w3.org/1999/xhtml">However, we explore better solutions as we continue to explore additional options.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml">An </span><strong><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">ORM</span></strong><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml"> is a piece of software that translates objects into a database language such as SQL. </span><span class="koboSpan" id="kobo.380.2" xmlns="http://www.w3.org/1999/xhtml">It allows mutating data, querying data, loading that data into objects, and more.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml">Modern data layers usually leverage an </span><strong><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml">ORM</span></strong><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml"> such as </span><strong><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml">Entity Framework Core</span></strong><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml">EF Core</span></strong><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml">), which does a big part of our job, making our lives easier. </span><span class="koboSpan" id="kobo.387.2" xmlns="http://www.w3.org/1999/xhtml">In the case of </span><strong><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml">EF Core</span></strong><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml">, it allows us to choose between multiple providers, from SQL Server to Cosmos DB, passing by the in-memory provider. </span><span class="koboSpan" id="kobo.389.2" xmlns="http://www.w3.org/1999/xhtml">The great thing about EF Core is that it already implements the </span><strong><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml">Unit of Work</span></strong><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml"> and the </span><strong><span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml">Repository</span></strong><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml"> patterns for us, among other things. </span><span class="koboSpan" id="kobo.393.2" xmlns="http://www.w3.org/1999/xhtml">In the book, we use the in-memory provider to cut down setup time and run integration tests.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml">If you’ve used EF6 before and dread Entity Framework, know that EF Core is lighter, faster, and easier to test. </span><span class="koboSpan" id="kobo.394.2" xmlns="http://www.w3.org/1999/xhtml">Feel free to give it a second shot. </span><span class="koboSpan" id="kobo.394.3" xmlns="http://www.w3.org/1999/xhtml">EF Core’s performance is very high now too. </span><span class="koboSpan" id="kobo.394.4" xmlns="http://www.w3.org/1999/xhtml">However, if you want complete control over your SQL code, look for Dapper (not to be confused with </span><strong><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml">Dapr</span></strong><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml">).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml">I don’t want to go into too much detail about these patterns, but they are important enough to deserve an overview. </span><span class="koboSpan" id="kobo.397.2" xmlns="http://www.w3.org/1999/xhtml">As mentioned, EF Core already implements these patterns, so we don’t have to deal with them. </span><span class="koboSpan" id="kobo.397.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, using such patterns is not always desirable, can be hard to implement right, and can lead to bloated data access layers, but they can also be very useful when used well.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml">I’ve written a multi-part article series about the Repository pattern. </span><span class="koboSpan" id="kobo.398.2" xmlns="http://www.w3.org/1999/xhtml">See the </span><em><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></em><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml"> section.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml">In the meantime, let’s at least study their goals to know what they are for, and if the situation arises where you need to write such components, you know where to look.</span></p>
<section class="level4" data-number="15.3.3.1" id="repository-pattern">
<h4 data-number="15.3.3.1"><span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml">Repository pattern</span></h4>
<p><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml">The goal of the Repository pattern is to allow consumers to query the database in an object-oriented way. </span><span class="koboSpan" id="kobo.403.2" xmlns="http://www.w3.org/1999/xhtml">Usually, this implies caching objects and filtering data dynamically. </span><span class="koboSpan" id="kobo.403.3" xmlns="http://www.w3.org/1999/xhtml">EF Core represents this concept with a </span><code><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml"> and provides dynamic filtering using LINQ and the </span><code><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml">IQueryable&lt;T&gt;</span></code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml"> interface.People also use the term </span><strong><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml">repository</span></strong><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml"> to represent the </span><strong><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml">Table Data Gateway pattern</span></strong><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml">, which is another pattern that models a class that gives us access to a single table in a database and provides access to operations such as creating, updating, deleting, and fetching entities from that database table. </span><span class="koboSpan" id="kobo.411.2" xmlns="http://www.w3.org/1999/xhtml">Both patterns are from the </span><em><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">Patterns of Enterprise Application Architecture</span></em><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml"> and are extensively used.Homegrown custom implementations usually follow the Table Data Gateway pattern more than the Repository pattern. </span><span class="koboSpan" id="kobo.413.2" xmlns="http://www.w3.org/1999/xhtml">They are based on an interface that looks like the following code and contains methods to create, update, delete, and read entities. </span><span class="koboSpan" id="kobo.413.3" xmlns="http://www.w3.org/1999/xhtml">They can have a base entity or not, in this case, </span><code><span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml">IEntity&lt;TId&gt;</span></code><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.415.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml">Id</span></code><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml"> property can also be generic or not:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">public interface IRepository&lt;T, TId&gt;
    where T : class, IEntity&lt;TId&gt;
{
    Task&lt;IEnumerable&lt;T&gt;&gt; AllAsync(CancellationToken cancellationToken);
    Task&lt;T?&gt; GetByIdAsync(TId id, CancellationToken cancellationToken);
    Task&lt;T&gt; CreateAsync(T entity, CancellationToken cancellationToken);
    Task UpdateAsync(T entity, CancellationToken cancellationToken);
    Task DeleteAsync(TId id, CancellationToken cancellationToken);
}
public interface IEntity&lt;TId&gt;
{
    TId Id { get; }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml">One thing that often happens with those table data gateways is that people add a save method to the interface. </span><span class="koboSpan" id="kobo.419.2" xmlns="http://www.w3.org/1999/xhtml">As long as you update a single entity, it should be fine. </span><span class="koboSpan" id="kobo.419.3" xmlns="http://www.w3.org/1999/xhtml">However, that makes transactions that cross multiple repositories harder to manage or dependent on the underlying implementation (breaking abstraction). </span><span class="koboSpan" id="kobo.419.4" xmlns="http://www.w3.org/1999/xhtml">To commit or revert such transactions, we can leverage the Unit of Work pattern, moving the save method from the table data gateway there.For example, when using EF Core, we can use </span><code><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;Product&gt;</span></code><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml"> (the </span><code><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">db.Products</span></code><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml"> property) to add new products to the database, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml">db.Products.Add(new Data.Product
{
    Id = 1,
    Name = "Banana",
    QuantityInStock = 50
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml">For the querying part, the easiest way to find a single product is to use it like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml">var product = _db.Products.Find(productId);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml">However, we could use LINQ instead:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml">_db.Products.Single(x =&gt; x.Id == productId);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml">These are some of the querying capabilities that a </span><strong><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml">repository</span></strong><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml"> should provide. </span><span class="koboSpan" id="kobo.431.2" xmlns="http://www.w3.org/1999/xhtml">EF Core seamlessly translates LINQ into the configured provider expectations like SQL, adding extended filtering capabilities.Of course, with EF Core, we can query collections of items, fetching all products and projecting them as domain objects like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml">_db.Products.Select(p =&gt; new Domain.Product
{
    Id = p.Id,
    Name = p.Name,
    QuantityInStock = p.QuantityInStock
});</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml">We can also filter further using LINQ here; for example, by querying all the products that are out of stock:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml">var outOfStockProducts = _db.Products
    .Where(p =&gt; p.QuantityInStock == 0);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml">We could also allow a margin for error, like so:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml">var mostLikelyOutOfStockProducts = _db.Products
    .Where(p =&gt; p.QuantityInStock &lt; 3);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml">We now have briefly explored how to use the EF Core implementation of the Repository pattern, </span><code><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.439.2" xmlns="http://www.w3.org/1999/xhtml">These few examples might seem trivial, but it would require considerable effort to implement custom repositories on par with EF Core’s features.EF Core’s unit of work, the </span><code><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml">DbContext</span></code><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml"> class, contains the </span><em><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml">save</span></em><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml"> methods to persist the modifications done to all its </span><code><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml"> properties (the repositories). </span><span class="koboSpan" id="kobo.445.2" xmlns="http://www.w3.org/1999/xhtml">Homebrewed implementations often feature such methods on the repository itself, making cross-repository transactions harder to handle and leading to bloated repositories containing tons of operation-specific methods to handle such cases.Now that we understand the concept behind the </span><strong><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml">Repository pattern</span></strong><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml">, let’s jump into an overview of the </span><strong><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml">Unit of Work pattern</span></strong><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml"> before going back to layering.</span></p>
</section>
<section class="level4" data-number="15.3.3.2" id="unit-of-work-pattern">
<h4 data-number="15.3.3.2"><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml">Unit of Work pattern</span></h4>
<p><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml">A </span><strong><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml">unit of work</span></strong><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml"> keeps track of the object representation of a transaction. </span><span class="koboSpan" id="kobo.453.2" xmlns="http://www.w3.org/1999/xhtml">In other words, it manages a registry of what objects should be created, updated, and deleted. </span><span class="koboSpan" id="kobo.453.3" xmlns="http://www.w3.org/1999/xhtml">It allows us to combine multiple changes in a single transaction (one database call), offering multiple advantages over calling the database every time we make a change.Assuming we are using a relational database, here are two advantages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">First, it can speed up data access; calling a database is slow, so limiting the number of calls and connections can improve performance.</span></li>
<li><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">Second, running a transaction instead of individual operations allows us to roll back all operations if one fails or commit the transaction as a whole if everything succeeds.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml">EF Core implements this pattern with the </span><code><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml">DbContext</span></code><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml"> class and its underlying types, such as the </span><code><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml">DatabaseFacade</span></code><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml">ChangeTracker</span></code><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml"> classes.Our small applications don’t need transactions, but the concept remains the same. </span><span class="koboSpan" id="kobo.462.2" xmlns="http://www.w3.org/1999/xhtml">Here is an example of what happens using EF Core:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml">var product = _db.Products.Find(productId);
product.QuantityInStock += amount;
_db.SaveChanges();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml">The preceding code does the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">Queries the database for a single entity.</span></li>
<li><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml">Changes the value of the </span><code><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">QuantityInStock</span></code><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml"> property.</span></li>
<li><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml">Persists the changes back into the database.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml">In reality, what happened is closer to the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">We ask EF Core for a single entity through the </span><code><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml">ProductContext</span></code><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml"> (a unit of work), which exposes the </span><code><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;Product&gt;</span></code><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml"> property (the product repository). </span><span class="koboSpan" id="kobo.475.2" xmlns="http://www.w3.org/1999/xhtml">Under the hood, EF Core does the following:
</span><ol type="A">
<li><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml">Queries the database.</span></li>
<li><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">Caches the entity.</span></li>
<li><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml">Tracks changes for that entity.</span></li>
<li><span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml">Returns it to us.</span></li>
</ol></li>
<li><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml">We change the value of the </span><code><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml">QuantityInStock</span></code><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml"> property; EF Core detects the change and marks the object as </span><em><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml">dirty</span></em><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">We tell the unit of work to persist the changes that it tracked, saving the </span><em><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml">dirty product</span></em><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml"> back to the database.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml">In a more complex scenario, we could have written the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml">_db.Products.Add(newProduct);
_db.Products.Remove(productToDelete);
product.Name = "New product name";
_db.SaveChanges();</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">Here, the </span><code><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">SaveChanges()</span></code><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml"> method triggers saving the three operations instead of sending them individually. </span><span class="koboSpan" id="kobo.492.2" xmlns="http://www.w3.org/1999/xhtml">You can control database transactions using the </span><code><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">Database</span></code><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml"> property of </span><code><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">DbContext</span></code><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml"> (see the </span><em><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></em><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml"> section for more information).Now that we’ve explored the </span><strong><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml">unit of work</span></strong><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml"> pattern, we could implement one by ourselves. </span><span class="koboSpan" id="kobo.500.2" xmlns="http://www.w3.org/1999/xhtml">Would that add value to our application? </span><span class="koboSpan" id="kobo.500.3" xmlns="http://www.w3.org/1999/xhtml">Probably not. </span><span class="koboSpan" id="kobo.500.4" xmlns="http://www.w3.org/1999/xhtml">If you want to build a custom </span><strong><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml">unit of work</span></strong><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml"> or a wrapper over EF Core, there are plenty of existing resources to guide you. </span><span class="koboSpan" id="kobo.502.2" xmlns="http://www.w3.org/1999/xhtml">Unless you want to experiment or need a custom </span><strong><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml">unit of work</span></strong><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml">repository</span></strong><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml"> (which is possible), I recommend staying away from doing that. </span><span class="koboSpan" id="kobo.506.2" xmlns="http://www.w3.org/1999/xhtml">Remember: </span><strong><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml">do only what needs to be done for your program to be correct</span></strong><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml">Don’t get me wrong when I say </span><em><span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml">do only what needs to be done</span></em><span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml">; wild engineering endeavors and experimentations are a great way to explore, and I encourage you to do so. </span><span class="koboSpan" id="kobo.511.2" xmlns="http://www.w3.org/1999/xhtml">However, I recommend doing so in parallel so that you can innovate, learn, and possibly even migrate that knowledge to your application later instead of wasting time and breaking things. </span><span class="koboSpan" id="kobo.511.3" xmlns="http://www.w3.org/1999/xhtml">If you are using Git, creating an experimental branch is a good way of doing this. </span><span class="koboSpan" id="kobo.511.4" xmlns="http://www.w3.org/1999/xhtml">You can then delete it when your experimentation does not work, merge the branch if it yields positive results, or leave it there as a reference (depending on the team’s policies in place).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">Now that we explored a high-level view of the Repository and Unit of Work patterns, and what those common layers are for, we can continue our journey of using layers.</span></p>
</section>
</section>
</section>
<section class="level2" data-number="15.4" id="abstract-layers">
<h2 data-number="15.4"><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml">Abstract layers</span></h2>
<p><span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml">This section looks at abstract layers using an abstract data layer implementation. </span><span class="koboSpan" id="kobo.514.2" xmlns="http://www.w3.org/1999/xhtml">This type of abstraction can be very useful and is another step closer to </span><strong><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture</span></strong><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.516.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, you can abstract almost anything this way, which is nothing more than applying the </span><strong><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">Dependency Inversion Principle</span></strong><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">DIP</span></strong><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml">).Let’s start with some context and the problem:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml"> is where the logic lies.</span></li>
<li><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">UI</span></strong><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml"> links the user to the </span><strong><span class="koboSpan" id="kobo.527.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.528.1" xmlns="http://www.w3.org/1999/xhtml">, exposing the features built into that </span><strong><span class="koboSpan" id="kobo.529.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.530.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.531.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.532.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.533.1" xmlns="http://www.w3.org/1999/xhtml"> should be an implementation detail that the </span><strong><span class="koboSpan" id="kobo.534.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.535.1" xmlns="http://www.w3.org/1999/xhtml"> blindly uses.</span></li>
<li><span class="koboSpan" id="kobo.536.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.537.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.538.1" xmlns="http://www.w3.org/1999/xhtml"> contains the code that knows where the data is stored, which should be irrelevant to the </span><strong><span class="koboSpan" id="kobo.539.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.540.1" xmlns="http://www.w3.org/1999/xhtml">, but the </span><strong><span class="koboSpan" id="kobo.541.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.542.1" xmlns="http://www.w3.org/1999/xhtml"> directly depends on it.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.543.1" xmlns="http://www.w3.org/1999/xhtml">The solution to </span><strong><span class="koboSpan" id="kobo.544.1" xmlns="http://www.w3.org/1999/xhtml">break the tight coupling</span></strong><span class="koboSpan" id="kobo.545.1" xmlns="http://www.w3.org/1999/xhtml"> between the </span><strong><span class="koboSpan" id="kobo.546.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.547.1" xmlns="http://www.w3.org/1999/xhtml"> and the </span><strong><span class="koboSpan" id="kobo.548.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.549.1" xmlns="http://www.w3.org/1999/xhtml"> persistence implementations is to create an additional abstract layer, as shown in the following diagram:</span></p>
<figure>
<span class="koboSpan" id="kobo.550.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.6: Replacing the data (persistence) layer with a data abstraction layer" src="../media/file80.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.551.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.6: Replacing the data (persistence) layer with a data abstraction layer</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.552.1" xmlns="http://www.w3.org/1999/xhtml">New rule: </span><strong><span class="koboSpan" id="kobo.553.1" xmlns="http://www.w3.org/1999/xhtml">only interfaces and data model classes go into the data abstractions layer</span></strong><span class="koboSpan" id="kobo.554.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.554.2" xmlns="http://www.w3.org/1999/xhtml">This new layer now defines our data access API and does nothing but expose a set of interfaces—the contract.Then, </span><strong><span class="koboSpan" id="kobo.555.1" xmlns="http://www.w3.org/1999/xhtml">we can create one or more data implementations</span></strong><span class="koboSpan" id="kobo.556.1" xmlns="http://www.w3.org/1999/xhtml"> based on that abstract layer contract, like using EF Core. </span><span class="koboSpan" id="kobo.556.2" xmlns="http://www.w3.org/1999/xhtml">The link between the abstractions and implementations is done with dependency injection. </span><span class="koboSpan" id="kobo.556.3" xmlns="http://www.w3.org/1999/xhtml">The bindings defined in the </span><strong><span class="koboSpan" id="kobo.557.1" xmlns="http://www.w3.org/1999/xhtml">composition root</span></strong><span class="koboSpan" id="kobo.558.1" xmlns="http://www.w3.org/1999/xhtml"> explain the indirect connection between the presentation and the data implementation.The new dependency tree looks like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.559.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.7: The relationships between layers" src="../media/file81.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.560.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.7: The relationships between layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.561.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.562.1" xmlns="http://www.w3.org/1999/xhtml">presentation layer</span></strong><span class="koboSpan" id="kobo.563.1" xmlns="http://www.w3.org/1999/xhtml"> references a </span><strong><span class="koboSpan" id="kobo.564.1" xmlns="http://www.w3.org/1999/xhtml">data implementation layer</span></strong><span class="koboSpan" id="kobo.565.1" xmlns="http://www.w3.org/1999/xhtml"> for the sole purpose of creating the DI bindings. </span><span class="koboSpan" id="kobo.565.2" xmlns="http://www.w3.org/1999/xhtml">We need those bindings to inject the correct implementation when creating </span><strong><span class="koboSpan" id="kobo.566.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.567.1" xmlns="http://www.w3.org/1999/xhtml"> classes. </span><span class="koboSpan" id="kobo.567.2" xmlns="http://www.w3.org/1999/xhtml">Besides, </span><strong><span class="koboSpan" id="kobo.568.1" xmlns="http://www.w3.org/1999/xhtml">the presentation layer must not use the data layer’s abstractions or implementations</span></strong><span class="koboSpan" id="kobo.569.1" xmlns="http://www.w3.org/1999/xhtml">.I created a sample project that showcases the relationships between the projects and the classes. </span><span class="koboSpan" id="kobo.569.2" xmlns="http://www.w3.org/1999/xhtml">However, that project would have added pages of code, so I decided not to include it in the book. </span><span class="koboSpan" id="kobo.569.3" xmlns="http://www.w3.org/1999/xhtml">The most important thing about abstract layers is the dependency flow between the layers, not the code itself.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.570.1" xmlns="http://www.w3.org/1999/xhtml">The project is available on GitHub (</span><a href="https://adpg.link/s9HX"><span class="koboSpan" id="kobo.571.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/s9HX</span></a><span class="koboSpan" id="kobo.572.1" xmlns="http://www.w3.org/1999/xhtml">).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.573.1" xmlns="http://www.w3.org/1999/xhtml">In that project, the program injects an instance of the </span><code><span class="koboSpan" id="kobo.574.1" xmlns="http://www.w3.org/1999/xhtml">EF.ProductRepository</span></code><span class="koboSpan" id="kobo.575.1" xmlns="http://www.w3.org/1999/xhtml"> class when a consumer asks for an object that implements the </span><code><span class="koboSpan" id="kobo.576.1" xmlns="http://www.w3.org/1999/xhtml">IProductRepository</span></code><span class="koboSpan" id="kobo.577.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.577.2" xmlns="http://www.w3.org/1999/xhtml">In that case, the consuming class is </span><code><span class="koboSpan" id="kobo.578.1" xmlns="http://www.w3.org/1999/xhtml">ProductService</span></code><span class="koboSpan" id="kobo.579.1" xmlns="http://www.w3.org/1999/xhtml"> and only depends on the </span><code><span class="koboSpan" id="kobo.580.1" xmlns="http://www.w3.org/1999/xhtml">IProductRepository</span></code><span class="koboSpan" id="kobo.581.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.581.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.582.1" xmlns="http://www.w3.org/1999/xhtml">ProductService</span></code><span class="koboSpan" id="kobo.583.1" xmlns="http://www.w3.org/1999/xhtml"> class is unaware of the implementation itself: it leverages only the interface. </span><span class="koboSpan" id="kobo.583.2" xmlns="http://www.w3.org/1999/xhtml">The same goes for the program that loads a </span><code><span class="koboSpan" id="kobo.584.1" xmlns="http://www.w3.org/1999/xhtml">ProductService</span></code><span class="koboSpan" id="kobo.585.1" xmlns="http://www.w3.org/1999/xhtml"> class but knows only about the </span><code><span class="koboSpan" id="kobo.586.1" xmlns="http://www.w3.org/1999/xhtml">IProductService</span></code><span class="koboSpan" id="kobo.587.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.587.2" xmlns="http://www.w3.org/1999/xhtml">Here is a visual representation of that dependency tree:</span></p>
<figure>
<span class="koboSpan" id="kobo.588.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.8: The dependency flow between layers, classes, and interfaces" src="../media/file82.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.589.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.8: The dependency flow between layers, classes, and interfaces</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.590.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding diagram, look at how dependencies converge on the </span><code><span class="koboSpan" id="kobo.591.1" xmlns="http://www.w3.org/1999/xhtml">Data.Abstract</span></code><span class="koboSpan" id="kobo.592.1" xmlns="http://www.w3.org/1999/xhtml"> layer. </span><span class="koboSpan" id="kobo.592.2" xmlns="http://www.w3.org/1999/xhtml">The dependency tree ends up on that abstract data layer.With this applied piece of architectural theory, we are inverting the flow of dependencies on the data layer by following the </span><strong><span class="koboSpan" id="kobo.593.1" xmlns="http://www.w3.org/1999/xhtml">DIP</span></strong><span class="koboSpan" id="kobo.594.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.594.2" xmlns="http://www.w3.org/1999/xhtml">We also cut out the direct dependency on EF Core, allowing us to implement a new data layer and swap it without impacting the rest of the application or update the implementation without affecting the domain. </span><span class="koboSpan" id="kobo.594.3" xmlns="http://www.w3.org/1999/xhtml">As I mentioned previously, swapping layers should not happen very often, if ever. </span><span class="koboSpan" id="kobo.594.4" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, this is an important part of the evolution of layering, and more importantly, we can apply this technique to any layer or project, not just the data layer, so it is imperative to understand how to invert the dependency flow.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.595.1" xmlns="http://www.w3.org/1999/xhtml">To test the APIs, you can use the Postman collection that comes with the book; visit </span><a href="https://adpg.link/postman8"><span class="koboSpan" id="kobo.596.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/postman8</span></a><span class="koboSpan" id="kobo.597.1" xmlns="http://www.w3.org/1999/xhtml"> or GitHub (</span><a href="https://adpg.link/net8"><span class="koboSpan" id="kobo.598.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/net8</span></a><span class="koboSpan" id="kobo.599.1" xmlns="http://www.w3.org/1999/xhtml">) for more info.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.600.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s explore sharing and persisting a rich domain model.</span></p>
</section>
<section class="level2" data-number="15.5" id="sharing-the-model">
<h2 data-number="15.5"><span class="koboSpan" id="kobo.601.1" xmlns="http://www.w3.org/1999/xhtml">Sharing the model</span></h2>
<p><span class="koboSpan" id="kobo.602.1" xmlns="http://www.w3.org/1999/xhtml">We have explored strict layering and how to apply the DIP, but we still have multiple models. </span><span class="koboSpan" id="kobo.602.2" xmlns="http://www.w3.org/1999/xhtml">An alternative to copying models from one layer to another is to share a model between multiple layers, generally as an assembly. </span><span class="koboSpan" id="kobo.602.3" xmlns="http://www.w3.org/1999/xhtml">Visually, it looks like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.603.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.9: Sharing a model between all three layers" src="../media/file83.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.604.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.9: Sharing a model between all three layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.605.1" xmlns="http://www.w3.org/1999/xhtml">Everything has pros and cons, so no matter how much time this can save you at first, it will come back to haunt you and become a pain point later as the project advances and becomes more complex.Suppose you feel that sharing a model is worth it for your application. </span><span class="koboSpan" id="kobo.605.2" xmlns="http://www.w3.org/1999/xhtml">In that case, I recommend using </span><strong><span class="koboSpan" id="kobo.606.1" xmlns="http://www.w3.org/1999/xhtml">view models</span></strong><span class="koboSpan" id="kobo.607.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><strong><span class="koboSpan" id="kobo.608.1" xmlns="http://www.w3.org/1999/xhtml">DTOs</span></strong><span class="koboSpan" id="kobo.609.1" xmlns="http://www.w3.org/1999/xhtml"> at the presentation level to control and keep the input and output of your application loosely coupled from your model. </span><span class="koboSpan" id="kobo.609.2" xmlns="http://www.w3.org/1999/xhtml">This way of shielding your lower layers can be represented as follows:</span></p>
<figure>
<span class="koboSpan" id="kobo.610.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.10: Sharing a model between the domain and data layers" src="../media/file84.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.611.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.10: Sharing a model between the domain and data layers</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.612.1" xmlns="http://www.w3.org/1999/xhtml">By doing that, you will save some time initially by sharing your model between your domain and data layers. </span><span class="koboSpan" id="kobo.612.2" xmlns="http://www.w3.org/1999/xhtml">By hiding that shared model under the presentation layer, you should dodge many problems in the long run, making this a good compromise between quality and development time. </span><span class="koboSpan" id="kobo.612.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, since your presentation layer shields your application from the outside world, you can refactor your other layers without impacting your consumers.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.613.1" xmlns="http://www.w3.org/1999/xhtml">This is pretty much how Clean Architecture does it but represented differently. </span><span class="koboSpan" id="kobo.613.2" xmlns="http://www.w3.org/1999/xhtml">Using that, the model is at the center of the application and is manipulated and persisted. </span><span class="koboSpan" id="kobo.613.3" xmlns="http://www.w3.org/1999/xhtml">While the layers have different names, the concept remains very similar. </span><span class="koboSpan" id="kobo.613.4" xmlns="http://www.w3.org/1999/xhtml">More on that later.</span></p>
</blockquote>
<p><strong><span class="koboSpan" id="kobo.614.1" xmlns="http://www.w3.org/1999/xhtml">View models</span></strong><span class="koboSpan" id="kobo.615.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.616.1" xmlns="http://www.w3.org/1999/xhtml">DTOs</span></strong><span class="koboSpan" id="kobo.617.1" xmlns="http://www.w3.org/1999/xhtml"> are key elements to successful programs and developers’ sanity; they should save you many headaches for long-running projects. </span><span class="koboSpan" id="kobo.617.2" xmlns="http://www.w3.org/1999/xhtml">We revisit and explore the concepts of controlling the input and output later in </span><em><span class="koboSpan" id="kobo.618.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 16</span></em><span class="koboSpan" id="kobo.619.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.620.1" xmlns="http://www.w3.org/1999/xhtml">Mediator and CQRS Design Patterns</span></em><span class="koboSpan" id="kobo.621.1" xmlns="http://www.w3.org/1999/xhtml">, where inputs become </span><strong><span class="koboSpan" id="kobo.622.1" xmlns="http://www.w3.org/1999/xhtml">commands</span></strong><span class="koboSpan" id="kobo.623.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.624.1" xmlns="http://www.w3.org/1999/xhtml">queries</span></strong><span class="koboSpan" id="kobo.625.1" xmlns="http://www.w3.org/1999/xhtml">.Meanwhile, let’s merge that concept with an abstraction layer. </span><span class="koboSpan" id="kobo.625.2" xmlns="http://www.w3.org/1999/xhtml">In the previous project, the </span><strong><span class="koboSpan" id="kobo.626.1" xmlns="http://www.w3.org/1999/xhtml">data abstraction layer</span></strong><span class="koboSpan" id="kobo.627.1" xmlns="http://www.w3.org/1999/xhtml"> owned the </span><strong><span class="koboSpan" id="kobo.628.1" xmlns="http://www.w3.org/1999/xhtml">data model</span></strong><span class="koboSpan" id="kobo.629.1" xmlns="http://www.w3.org/1999/xhtml">, and the </span><strong><span class="koboSpan" id="kobo.630.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.631.1" xmlns="http://www.w3.org/1999/xhtml"> owned the </span><strong><span class="koboSpan" id="kobo.632.1" xmlns="http://www.w3.org/1999/xhtml">domain model</span></strong><span class="koboSpan" id="kobo.633.1" xmlns="http://www.w3.org/1999/xhtml">.In this architectural alternative, we are sharing the model between the two layers. </span><span class="koboSpan" id="kobo.633.2" xmlns="http://www.w3.org/1999/xhtml">The presentation layer can indirectly use that shared model to dialog with the domain layer without exposing it externally. </span><span class="koboSpan" id="kobo.633.3" xmlns="http://www.w3.org/1999/xhtml">The objective is to directly persist the </span><strong><span class="koboSpan" id="kobo.634.1" xmlns="http://www.w3.org/1999/xhtml">domain model</span></strong><span class="koboSpan" id="kobo.635.1" xmlns="http://www.w3.org/1999/xhtml"> and skip the copy from the </span><strong><span class="koboSpan" id="kobo.636.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.637.1" xmlns="http://www.w3.org/1999/xhtml"> to the </span><strong><span class="koboSpan" id="kobo.638.1" xmlns="http://www.w3.org/1999/xhtml">data layer</span></strong><span class="koboSpan" id="kobo.639.1" xmlns="http://www.w3.org/1999/xhtml"> while having that data abstraction layer that breaks the tight coupling between the domain logic and the persistence.Here is a visual representation of that:</span></p>
<figure>
<span class="koboSpan" id="kobo.640.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.11: Diagram representing a shared rich model" src="../media/file85.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.641.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.11: Diagram representing a shared rich model</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.642.1" xmlns="http://www.w3.org/1999/xhtml">It is well suited for </span><strong><span class="koboSpan" id="kobo.643.1" xmlns="http://www.w3.org/1999/xhtml">rich models,</span></strong><span class="koboSpan" id="kobo.644.1" xmlns="http://www.w3.org/1999/xhtml"> but we can also do this for anemic models. </span><span class="koboSpan" id="kobo.644.2" xmlns="http://www.w3.org/1999/xhtml">With a </span><strong><span class="koboSpan" id="kobo.645.1" xmlns="http://www.w3.org/1999/xhtml">rich domain model</span></strong><span class="koboSpan" id="kobo.646.1" xmlns="http://www.w3.org/1999/xhtml">, you delegate the job of reconstructing the model to the ORM and immediately start calling its methods.The ORM also recreates the anemic model, but those classes just contain data, so you need to call other pieces of the software that contain the logic to manipulate those objects.In the code sample, the </span><strong><span class="koboSpan" id="kobo.647.1" xmlns="http://www.w3.org/1999/xhtml">data abstraction layer</span></strong><span class="koboSpan" id="kobo.648.1" xmlns="http://www.w3.org/1999/xhtml"> now contains only the data access abstractions, such as the repositories, and it references the new </span><code><span class="koboSpan" id="kobo.649.1" xmlns="http://www.w3.org/1999/xhtml">Model</span></code><span class="koboSpan" id="kobo.650.1" xmlns="http://www.w3.org/1999/xhtml"> project that is now the persisted model.Conceptually, it cleans up a few things:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.651.1" xmlns="http://www.w3.org/1999/xhtml">The data abstraction layer’s only responsibility is to contain data access abstractions.</span></li>
<li><span class="koboSpan" id="kobo.652.1" xmlns="http://www.w3.org/1999/xhtml">The domain layer’s only responsibility is implementing the domain services and the logic that is not part of that rich model.</span></li>
<li><span class="koboSpan" id="kobo.653.1" xmlns="http://www.w3.org/1999/xhtml">In the case of an anemic model, the domain layer’s responsibility would be to encapsulate all the domain logic.</span></li>
<li><span class="koboSpan" id="kobo.654.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.655.1" xmlns="http://www.w3.org/1999/xhtml">Model</span></code><span class="koboSpan" id="kobo.656.1" xmlns="http://www.w3.org/1999/xhtml"> project contains the entities.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.657.1" xmlns="http://www.w3.org/1999/xhtml">Once again, I skip publishing most of the code here as it is irrelevant to the overall concept. </span><span class="koboSpan" id="kobo.657.2" xmlns="http://www.w3.org/1999/xhtml">If you think reading the code would help, you can consult and explore the sample on GitHub (</span><a href="https://adpg.link/9F5C"><span class="koboSpan" id="kobo.658.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/9F5C</span></a><span class="koboSpan" id="kobo.659.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.659.2" xmlns="http://www.w3.org/1999/xhtml">Using an IDE to browse the code should help you understand the flow, and as with the abstract layer, the dependencies between the projects, classes, and interfaces are the key to this.Nevertheless, here is the </span><code><span class="koboSpan" id="kobo.660.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.661.1" xmlns="http://www.w3.org/1999/xhtml"> class that uses that shared model so you can peek at some code that directly relates to the explanations:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.662.1" xmlns="http://www.w3.org/1999/xhtml">namespace Domain.Services;
public class StockService : IStockService
{
    private readonly IProductRepository _repository;
    public StockService(IProductRepository repository)
    {
        _repository = repository ?? </span><span class="koboSpan" id="kobo.662.2" xmlns="http://www.w3.org/1999/xhtml">throw new ArgumentNullException(nameof(repository));
    }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.663.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, we are injecting an implementation of the </span><code><span class="koboSpan" id="kobo.664.1" xmlns="http://www.w3.org/1999/xhtml">IProductRepository</span></code><span class="koboSpan" id="kobo.665.1" xmlns="http://www.w3.org/1999/xhtml"> interface we use in the next two methods. </span><span class="koboSpan" id="kobo.665.2" xmlns="http://www.w3.org/1999/xhtml">Next, we look at the </span><code><span class="koboSpan" id="kobo.666.1" xmlns="http://www.w3.org/1999/xhtml">AddStockAsync</span></code><span class="koboSpan" id="kobo.667.1" xmlns="http://www.w3.org/1999/xhtml"> method:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.668.1" xmlns="http://www.w3.org/1999/xhtml">    public async Task&lt;int&gt; AddStockAsync(int productId, int amount, CancellationToken cancellationToken)
    {
        var product = await _repository.FindByIdAsync(productId, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(productId);
        }
        product.AddStock(amount);
        await _repository.UpdateAsync(product, cancellationToken);
        return product.QuantityInStock;
    }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.669.1" xmlns="http://www.w3.org/1999/xhtml">The fun starts in the preceding code, which does the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.670.1" xmlns="http://www.w3.org/1999/xhtml">The repository recreates the product (model) that contains the logic.</span></li>
<li><span class="koboSpan" id="kobo.671.1" xmlns="http://www.w3.org/1999/xhtml">It validates that the product exists.</span></li>
<li><span class="koboSpan" id="kobo.672.1" xmlns="http://www.w3.org/1999/xhtml">It uses that model and calls the </span><code><span class="koboSpan" id="kobo.673.1" xmlns="http://www.w3.org/1999/xhtml">AddStock</span></code><span class="koboSpan" id="kobo.674.1" xmlns="http://www.w3.org/1999/xhtml"> method (encapsulated domain logic).</span></li>
<li><span class="koboSpan" id="kobo.675.1" xmlns="http://www.w3.org/1999/xhtml">It tells the repository to update the product.</span></li>
<li><span class="koboSpan" id="kobo.676.1" xmlns="http://www.w3.org/1999/xhtml">It returns the updated product’s </span><code><span class="koboSpan" id="kobo.677.1" xmlns="http://www.w3.org/1999/xhtml">QuantityInStock</span></code><span class="koboSpan" id="kobo.678.1" xmlns="http://www.w3.org/1999/xhtml"> to the consumer of the service.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.679.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore the </span><code><span class="koboSpan" id="kobo.680.1" xmlns="http://www.w3.org/1999/xhtml">RemoveStockAsync</span></code><span class="koboSpan" id="kobo.681.1" xmlns="http://www.w3.org/1999/xhtml"> method:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.682.1" xmlns="http://www.w3.org/1999/xhtml">    public async Task&lt;int&gt; RemoveStockAsync(int productId, int amount, CancellationToken cancellationToken)
    {
        var product = await _repository.FindByIdAsync(productId, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(productId);
        }
        product.RemoveStock(amount);
        await _repository.UpdateAsync(product, cancellationToken);
        return product.QuantityInStock;
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.683.1" xmlns="http://www.w3.org/1999/xhtml">We applied the same logic as the </span><code><span class="koboSpan" id="kobo.684.1" xmlns="http://www.w3.org/1999/xhtml">AddStock</span></code><span class="koboSpan" id="kobo.685.1" xmlns="http://www.w3.org/1999/xhtml"> method to the </span><code><span class="koboSpan" id="kobo.686.1" xmlns="http://www.w3.org/1999/xhtml">RemoveStock</span></code><span class="koboSpan" id="kobo.687.1" xmlns="http://www.w3.org/1999/xhtml"> method, but it calls the </span><code><span class="koboSpan" id="kobo.688.1" xmlns="http://www.w3.org/1999/xhtml">Product.RemoveStock</span></code><span class="koboSpan" id="kobo.689.1" xmlns="http://www.w3.org/1999/xhtml"> method instead. </span><span class="koboSpan" id="kobo.689.2" xmlns="http://www.w3.org/1999/xhtml">From the </span><code><span class="koboSpan" id="kobo.690.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.691.1" xmlns="http://www.w3.org/1999/xhtml"> class, we can see the service gating the access to the domain model (the product), fetching and updating the model through the abstract data layer, manipulating the model by calling its methods, and returning domain data (an </span><code><span class="koboSpan" id="kobo.692.1" xmlns="http://www.w3.org/1999/xhtml">int</span></code><span class="koboSpan" id="kobo.693.1" xmlns="http://www.w3.org/1999/xhtml"> in this case, but could be an object).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.694.1" xmlns="http://www.w3.org/1999/xhtml">This type of design can be either very helpful or undesirable. </span><span class="koboSpan" id="kobo.694.2" xmlns="http://www.w3.org/1999/xhtml">Too many projects depending on and exposing a shared model can lead to leaking part of that model to consumers, for example exposing properties that shouldn’t be, exposing the whole domain model as output, or the very worst, exposing it as an input and opening exploitable holes and unexpected bugs.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.695.1" xmlns="http://www.w3.org/1999/xhtml">Be careful not to expose your shared model to the presentation layer consumers.</span></p>
</blockquote>
</blockquote>
<p><span class="koboSpan" id="kobo.696.1" xmlns="http://www.w3.org/1999/xhtml">Pushing logic into the model is not always possible or desirable, which is why we are exploring multiple types of domain models and ways to share them. </span><span class="koboSpan" id="kobo.696.2" xmlns="http://www.w3.org/1999/xhtml">Making a good design is often about options and deciding what option to use for each scenario. </span><span class="koboSpan" id="kobo.696.3" xmlns="http://www.w3.org/1999/xhtml">There are also tradeoffs to make between flexibility and robustness.The rest of the code is similar to the abstract layer project. </span><span class="koboSpan" id="kobo.696.4" xmlns="http://www.w3.org/1999/xhtml">Feel free to explore the source code (</span><a href="https://adpg.link/9F5C"><span class="koboSpan" id="kobo.697.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/9F5C</span></a><span class="koboSpan" id="kobo.698.1" xmlns="http://www.w3.org/1999/xhtml">) and compare it with the other projects. </span><span class="koboSpan" id="kobo.698.2" xmlns="http://www.w3.org/1999/xhtml">The best way to learn is to practice, so play with the samples, add features, update the current features, remove stuff, or even build your own project. </span><span class="koboSpan" id="kobo.698.3" xmlns="http://www.w3.org/1999/xhtml">Understanding these concepts will help you apply them to different scenarios, sometimes creating unexpected but efficient constructs.Now, let’s look at the final evolution of layering: Clean Architecture.</span></p>
</section>
<section class="level2" data-number="15.6" id="clean-architecture">
<h2 data-number="15.6"><span class="koboSpan" id="kobo.699.1" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture</span></h2>
<p><span class="koboSpan" id="kobo.700.1" xmlns="http://www.w3.org/1999/xhtml">Now that we’ve covered many layering approaches, it is time to combine them into </span><strong><span class="koboSpan" id="kobo.701.1" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture</span></strong><span class="koboSpan" id="kobo.702.1" xmlns="http://www.w3.org/1999/xhtml">, also known as Hexagonal Architecture, Onion Architecture, Ports and Adapters, and more. </span><span class="koboSpan" id="kobo.702.2" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture is an evolution of the layers, a way of organizing the relationships between the layers, yet very similar to what we just built. </span><span class="koboSpan" id="kobo.702.3" xmlns="http://www.w3.org/1999/xhtml">Instead of presentation, domain, and data (or persistence), Clean Architecture suggests </span><strong><span class="koboSpan" id="kobo.703.1" xmlns="http://www.w3.org/1999/xhtml">UI</span></strong><span class="koboSpan" id="kobo.704.1" xmlns="http://www.w3.org/1999/xhtml">, </span><strong><span class="koboSpan" id="kobo.705.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></strong><span class="koboSpan" id="kobo.706.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><strong><span class="koboSpan" id="kobo.707.1" xmlns="http://www.w3.org/1999/xhtml">Infrastructure</span></strong><span class="koboSpan" id="kobo.708.1" xmlns="http://www.w3.org/1999/xhtml">.As we saw previously, we can design a layer containing abstractions or implementations. </span><span class="koboSpan" id="kobo.708.2" xmlns="http://www.w3.org/1999/xhtml">When implementations depend only on abstractions, that inverts dependency flow. </span><span class="koboSpan" id="kobo.708.3" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture emphasizes such layers but with its own guidance about organizing them.We also explored the theoretical concept of breaking layers into smaller ones (or multiple projects), thus creating “fractured layers” that are easier to port and reuse. </span><span class="koboSpan" id="kobo.708.4" xmlns="http://www.w3.org/1999/xhtml">Clean Architecture leverages that concept at the infrastructure layer level.There are probably as many points of view and variants of this as there are names for it, so I’ll try to be as general as possible while keeping the essence. </span><span class="koboSpan" id="kobo.708.5" xmlns="http://www.w3.org/1999/xhtml">By doing this, if you are interested in this type of architecture, you can pick a resource and dig deeper into it, following the style you prefer.Let’s take a look at a diagram that resembles what we can find online:</span></p>
<figure>
<span class="koboSpan" id="kobo.709.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.12: A diagram representing the most basic Clean Architecture layout" src="../media/file86.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.710.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.12: A diagram representing the most basic Clean Architecture layout</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.711.1" xmlns="http://www.w3.org/1999/xhtml">From a layering diagram-like standpoint, the preceding diagram could look like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.712.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.13: A two-layer view of the previous Clean Architecture diagram" src="../media/file87.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.713.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.13: A two-layer view of the previous Clean Architecture diagram</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.714.1" xmlns="http://www.w3.org/1999/xhtml">Depending on your chosen method, you can split those layers into multiple other sublayers. </span><span class="koboSpan" id="kobo.714.2" xmlns="http://www.w3.org/1999/xhtml">One thing that we often see is dividing the </span><strong><span class="koboSpan" id="kobo.715.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></strong><span class="koboSpan" id="kobo.716.1" xmlns="http://www.w3.org/1999/xhtml"> layer into </span><strong><span class="koboSpan" id="kobo.717.1" xmlns="http://www.w3.org/1999/xhtml">Entities</span></strong><span class="koboSpan" id="kobo.718.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.719.1" xmlns="http://www.w3.org/1999/xhtml">Use cases</span></strong><span class="koboSpan" id="kobo.720.1" xmlns="http://www.w3.org/1999/xhtml">, like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.721.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.14: Widespread Clean Architecture layout diagram" src="../media/file88.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.722.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.14: Widespread Clean Architecture layout diagram</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.723.1" xmlns="http://www.w3.org/1999/xhtml">Since people in the tech industry are creative, there are many names for many things, but the concepts remain the same. </span><span class="koboSpan" id="kobo.723.2" xmlns="http://www.w3.org/1999/xhtml">From a layering diagram-like standpoint, that diagram could look like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.724.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.15: A layer-like view of the previous Clean Architecture diagram" src="../media/file89.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.725.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.15: A layer-like view of the previous Clean Architecture diagram</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.726.1" xmlns="http://www.w3.org/1999/xhtml">The infrastructure layer is conceptual and can represent multiple projects, such as an infrastructure assembly containing EF Core implementations and a website project representing the web UI. </span><span class="koboSpan" id="kobo.726.2" xmlns="http://www.w3.org/1999/xhtml">We could also add more projects to the infrastructure layer.The dependency rule of Clean Architecture states that dependencies can only point inward, from the outer layers to the inner layers. </span><span class="koboSpan" id="kobo.726.3" xmlns="http://www.w3.org/1999/xhtml">This means that abstractions lie inside, and concretions lie outside. </span><span class="koboSpan" id="kobo.726.4" xmlns="http://www.w3.org/1999/xhtml">Based on the preceding layer-like diagram, inside translates to downward. </span><span class="koboSpan" id="kobo.726.5" xmlns="http://www.w3.org/1999/xhtml">That means a layer can use any direct or transitive dependencies, which means that infrastructure can depend on use cases and entities.Clean Architecture follows all the principles that we’ve been discussing since the beginning of this book, such as decoupling our implementations using abstractions, dependency inversion, and separation of concerns. </span><span class="koboSpan" id="kobo.726.6" xmlns="http://www.w3.org/1999/xhtml">These implementations are glued over abstractions using dependency injection (this is not mandatory, but it helps).I’ve always found those circle diagrams a bit confusing, so here is my take on an updated, more linear diagram:</span></p>
<figure>
<span class="koboSpan" id="kobo.727.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.16: A two-layer view of Clean Architecture’s common elements" src="../media/file90.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.728.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.16: A two-layer view of Clean Architecture’s common elements</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.729.1" xmlns="http://www.w3.org/1999/xhtml">Now, let’s revisit our layered application using Clean Architecture, starting with the </span><strong><span class="koboSpan" id="kobo.730.1" xmlns="http://www.w3.org/1999/xhtml">core layer</span></strong><span class="koboSpan" id="kobo.731.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.731.2" xmlns="http://www.w3.org/1999/xhtml">The core project contains the domain model, the use cases (services), and the interfaces needed to fulfill those use cases. </span><span class="koboSpan" id="kobo.731.3" xmlns="http://www.w3.org/1999/xhtml">We must not access external resources in this layer: no database calls, disk access, or HTTP requests. </span><span class="koboSpan" id="kobo.731.4" xmlns="http://www.w3.org/1999/xhtml">This layer contains the interfaces that expose such interaction, but the implementations live in the </span><strong><span class="koboSpan" id="kobo.732.1" xmlns="http://www.w3.org/1999/xhtml">infrastructure layer</span></strong><span class="koboSpan" id="kobo.733.1" xmlns="http://www.w3.org/1999/xhtml">.The presentation layer was renamed </span><code><span class="koboSpan" id="kobo.734.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.735.1" xmlns="http://www.w3.org/1999/xhtml"> and lives in the outer layer with the EF Core implementation. </span><span class="koboSpan" id="kobo.735.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.736.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.737.1" xmlns="http://www.w3.org/1999/xhtml"> project depends only on the </span><code><span class="koboSpan" id="kobo.738.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.739.1" xmlns="http://www.w3.org/1999/xhtml"> project. </span><span class="koboSpan" id="kobo.739.2" xmlns="http://www.w3.org/1999/xhtml">Once again, since the composition root is in this project, it must load the EF Core implementation project to configure the IoC container.Here is a diagram representing the relation between the shared model and the new Clean Architecture project structure:</span></p>
<figure>
<span class="koboSpan" id="kobo.740.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.17: From shared project to the Clean Architecture project structure" src="../media/file91.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.741.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.17: From shared project to the Clean Architecture project structure</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.742.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding diagram, we took the center of the classic layered solution and merged the layers into a single </span><code><span class="koboSpan" id="kobo.743.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.744.1" xmlns="http://www.w3.org/1999/xhtml"> project.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.745.1" xmlns="http://www.w3.org/1999/xhtml">Here’s the link to this project on GitHub: </span><a href="https://adpg.link/rT1P"><span class="koboSpan" id="kobo.746.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/rT1P</span></a><span class="koboSpan" id="kobo.747.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.748.1" xmlns="http://www.w3.org/1999/xhtml">Most of the code is not that relevant since, once again, the most significant aspect is the dependency flow and relationships between projects. </span><span class="koboSpan" id="kobo.748.2" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, here is a list of changes that I made aside from moving the pieces to different projects:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.749.1" xmlns="http://www.w3.org/1999/xhtml">I removed the </span><code><span class="koboSpan" id="kobo.750.1" xmlns="http://www.w3.org/1999/xhtml">ProductService</span></code><span class="koboSpan" id="kobo.751.1" xmlns="http://www.w3.org/1999/xhtml"> class and </span><code><span class="koboSpan" id="kobo.752.1" xmlns="http://www.w3.org/1999/xhtml">IProductService</span></code><span class="koboSpan" id="kobo.753.1" xmlns="http://www.w3.org/1999/xhtml"> interface and used the </span><code><span class="koboSpan" id="kobo.754.1" xmlns="http://www.w3.org/1999/xhtml">IProductRepository</span></code><span class="koboSpan" id="kobo.755.1" xmlns="http://www.w3.org/1999/xhtml"> interface directly from the </span><code><span class="koboSpan" id="kobo.756.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.757.1" xmlns="http://www.w3.org/1999/xhtml"> class (</span><code><span class="koboSpan" id="kobo.758.1" xmlns="http://www.w3.org/1999/xhtml">Core</span></code><span class="koboSpan" id="kobo.759.1" xmlns="http://www.w3.org/1999/xhtml"> project) and the </span><code><span class="koboSpan" id="kobo.760.1" xmlns="http://www.w3.org/1999/xhtml">/products</span></code><span class="koboSpan" id="kobo.761.1" xmlns="http://www.w3.org/1999/xhtml"> endpoint (</span><code><span class="koboSpan" id="kobo.762.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.763.1" xmlns="http://www.w3.org/1999/xhtml"> project: </span><code><span class="koboSpan" id="kobo.764.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.765.1" xmlns="http://www.w3.org/1999/xhtml">).</span></li>
<li><span class="koboSpan" id="kobo.766.1" xmlns="http://www.w3.org/1999/xhtml">I removed the </span><code><span class="koboSpan" id="kobo.767.1" xmlns="http://www.w3.org/1999/xhtml">IStockService</span></code><span class="koboSpan" id="kobo.768.1" xmlns="http://www.w3.org/1999/xhtml"> interface, and now both the add and remove stocks endpoints (</span><code><span class="koboSpan" id="kobo.769.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.770.1" xmlns="http://www.w3.org/1999/xhtml"> project: </span><code><span class="koboSpan" id="kobo.771.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.772.1" xmlns="http://www.w3.org/1999/xhtml">) depend directly on the </span><code><span class="koboSpan" id="kobo.773.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.774.1" xmlns="http://www.w3.org/1999/xhtml"> class.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.775.1" xmlns="http://www.w3.org/1999/xhtml">Why use the </span><code><span class="koboSpan" id="kobo.776.1" xmlns="http://www.w3.org/1999/xhtml">IProductRepository</span></code><span class="koboSpan" id="kobo.777.1" xmlns="http://www.w3.org/1999/xhtml"> interface directly, you might wonder? </span><span class="koboSpan" id="kobo.777.2" xmlns="http://www.w3.org/1999/xhtml">Since the </span><code><span class="koboSpan" id="kobo.778.1" xmlns="http://www.w3.org/1999/xhtml">Web</span></code><span class="koboSpan" id="kobo.779.1" xmlns="http://www.w3.org/1999/xhtml"> project (</span><strong><span class="koboSpan" id="kobo.780.1" xmlns="http://www.w3.org/1999/xhtml">infrastructure layer</span></strong><span class="koboSpan" id="kobo.781.1" xmlns="http://www.w3.org/1999/xhtml">) depends on the </span><strong><span class="koboSpan" id="kobo.782.1" xmlns="http://www.w3.org/1999/xhtml">core layer</span></strong><span class="koboSpan" id="kobo.783.1" xmlns="http://www.w3.org/1999/xhtml">, we can leverage the inward dependency flow. </span><span class="koboSpan" id="kobo.783.2" xmlns="http://www.w3.org/1999/xhtml">It is acceptable to use a repository directly as long as the feature has no business logic. </span><span class="koboSpan" id="kobo.783.3" xmlns="http://www.w3.org/1999/xhtml">Programming empty shells and pass-through services adds useless complexity. </span><span class="koboSpan" id="kobo.783.4" xmlns="http://www.w3.org/1999/xhtml">However, when business logic starts to be involved, create a service or any other domain entity you deem necessary for that scenario. </span><span class="koboSpan" id="kobo.783.5" xmlns="http://www.w3.org/1999/xhtml">Don’t pack business logic into your controllers or minimal API delegates.I removed the </span><code><span class="koboSpan" id="kobo.784.1" xmlns="http://www.w3.org/1999/xhtml">IStockService</span></code><span class="koboSpan" id="kobo.785.1" xmlns="http://www.w3.org/1999/xhtml"> interface since the </span><code><span class="koboSpan" id="kobo.786.1" xmlns="http://www.w3.org/1999/xhtml">StockService</span></code><span class="koboSpan" id="kobo.787.1" xmlns="http://www.w3.org/1999/xhtml"> class contains concrete business rules that can be consumed as is from the infrastructure layer. </span><span class="koboSpan" id="kobo.787.2" xmlns="http://www.w3.org/1999/xhtml">I know we have emphasized using interfaces since the beginning of the book, but I also often said that principles are not laws. </span><span class="koboSpan" id="kobo.787.3" xmlns="http://www.w3.org/1999/xhtml">All in all, there is nothing to abstract away: if the business rules change, the old ones won’t be needed anymore. </span><span class="koboSpan" id="kobo.787.4" xmlns="http://www.w3.org/1999/xhtml">On the other hand, we could have kept the interface.To wrap this up, Clean Architecture is a proven pattern for building applications that is fundamentally an evolution of layering. </span><span class="koboSpan" id="kobo.787.5" xmlns="http://www.w3.org/1999/xhtml">Many variants can help you manage use cases, entities, and infrastructure; however, we will not cover those here. </span><span class="koboSpan" id="kobo.787.6" xmlns="http://www.w3.org/1999/xhtml">There are many open-source projects to start with Clean Architecture if you seek organizational guidance.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.788.1" xmlns="http://www.w3.org/1999/xhtml">I left a few links in the </span><em><span class="koboSpan" id="kobo.789.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></em><span class="koboSpan" id="kobo.790.1" xmlns="http://www.w3.org/1999/xhtml"> section.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.791.1" xmlns="http://www.w3.org/1999/xhtml">If you think this is a great fit for you, your team, your project, or your organization, feel free to dig deeper and adopt this pattern. </span><span class="koboSpan" id="kobo.791.2" xmlns="http://www.w3.org/1999/xhtml">In subsequent chapters, we explore some patterns, such as CQRS, Publish-Subscribe, and feature-based design, which we can combine with Clean Architecture to add flexibility and robustness. </span><span class="koboSpan" id="kobo.791.3" xmlns="http://www.w3.org/1999/xhtml">These become particularly useful as your system grows in size and complexity.</span></p>
</section>
<section class="level2" data-number="15.7" id="implementing-layering-in-real-life">
<h2 data-number="15.7"><span class="koboSpan" id="kobo.792.1" xmlns="http://www.w3.org/1999/xhtml">Implementing layering in real life</span></h2>
<p><span class="koboSpan" id="kobo.793.1" xmlns="http://www.w3.org/1999/xhtml">Now that we covered all of this, it is important to note that on the one hand, there is the theory, and on the other, life is hitting you in the face. </span><span class="koboSpan" id="kobo.793.2" xmlns="http://www.w3.org/1999/xhtml">Suppose you are working in a big enterprise. </span><span class="koboSpan" id="kobo.793.3" xmlns="http://www.w3.org/1999/xhtml">In that case, chances are your employer can pour hundreds of thousands or even millions of dollars into a feature to run experiments, spend months designing every little piece, and ensure everything is perfect. </span><span class="koboSpan" id="kobo.793.4" xmlns="http://www.w3.org/1999/xhtml">Even then, is achieving perfection even possible? </span><span class="koboSpan" id="kobo.793.5" xmlns="http://www.w3.org/1999/xhtml">Probably not.For companies that don’t have that type of capital, you must build entire products for a few thousand dollars sometimes because they are not trying to resell them but just need that tool built. </span><span class="koboSpan" id="kobo.793.6" xmlns="http://www.w3.org/1999/xhtml">That is where your architectural skills come in handy. </span><span class="koboSpan" id="kobo.793.7" xmlns="http://www.w3.org/1999/xhtml">How do you design the least-worst product in a maintainable fashion while meeting stakeholders' expectations? </span><span class="koboSpan" id="kobo.793.8" xmlns="http://www.w3.org/1999/xhtml">The most important part of the answer is to set expectations upfront. </span><span class="koboSpan" id="kobo.793.9" xmlns="http://www.w3.org/1999/xhtml">Moreover, never forget that someone needs to maintain and change the software over time; no software does not evolve; there’s always something.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.794.1" xmlns="http://www.w3.org/1999/xhtml">If you are in a position where you must evaluate the feasibility of products and features in this context, setting expectations lower can be a good way to plan for the unplannable. </span><span class="koboSpan" id="kobo.794.2" xmlns="http://www.w3.org/1999/xhtml">It is easier to overdeliver than justify why you underdelivered.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.795.1" xmlns="http://www.w3.org/1999/xhtml">Let’s dig deeper into this and look at a few tricks to help you out. </span><span class="koboSpan" id="kobo.795.2" xmlns="http://www.w3.org/1999/xhtml">Even if you are working for a larger enterprise, you should get something out of it.</span></p>
<section class="level3" data-number="15.7.1" id="to-be-or-not-to-be-a-purist">
<h3 data-number="15.7.1"><span class="koboSpan" id="kobo.796.1" xmlns="http://www.w3.org/1999/xhtml">To be or not to be a purist?</span></h3>
<p><span class="koboSpan" id="kobo.797.1" xmlns="http://www.w3.org/1999/xhtml">In your day-to-day work, you may not always need the rigidity of a </span><strong><span class="koboSpan" id="kobo.798.1" xmlns="http://www.w3.org/1999/xhtml">domain layer</span></strong><span class="koboSpan" id="kobo.799.1" xmlns="http://www.w3.org/1999/xhtml"> to create a wall in front of your data. </span><span class="koboSpan" id="kobo.799.2" xmlns="http://www.w3.org/1999/xhtml">Maybe you just don’t have the time or the money, or it’s just not worth doing.Taking and presenting the data can often work well enough, especially for simple data-driven applications that are only a user interface over a database, as is the case for many internal tools.The answer to the </span><em><span class="koboSpan" id="kobo.800.1" xmlns="http://www.w3.org/1999/xhtml">“To be or not to be a purist?”</span></em><span class="koboSpan" id="kobo.801.1" xmlns="http://www.w3.org/1999/xhtml"> question is: it depends!</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.802.1" xmlns="http://www.w3.org/1999/xhtml">This section covers layering, but we explore other patterns that are feature-oriented, so I suggest you continue reading and explore using the techniques from </span><em><span class="koboSpan" id="kobo.803.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 17</span></em><span class="koboSpan" id="kobo.804.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.805.1" xmlns="http://www.w3.org/1999/xhtml">Vertical Slice Architecture</span></em><span class="koboSpan" id="kobo.806.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.807.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 18</span></em><span class="koboSpan" id="kobo.808.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.809.1" xmlns="http://www.w3.org/1999/xhtml">Request-EndPoint-Response (REPR)</span></em><span class="koboSpan" id="kobo.810.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><em><span class="koboSpan" id="kobo.811.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 20</span></em><span class="koboSpan" id="kobo.812.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.813.1" xmlns="http://www.w3.org/1999/xhtml">Modular Monolith</span></em><span class="koboSpan" id="kobo.814.1" xmlns="http://www.w3.org/1999/xhtml">, to improve your design while keeping the design overhead low.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.815.1" xmlns="http://www.w3.org/1999/xhtml">Here are a few examples of things that the answer depends on, to help you out:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.816.1" xmlns="http://www.w3.org/1999/xhtml">The project; for example:
</span><ul>
<li><strong><span class="koboSpan" id="kobo.817.1" xmlns="http://www.w3.org/1999/xhtml">Domain-heavy or logic-intensive projects</span></strong><span class="koboSpan" id="kobo.818.1" xmlns="http://www.w3.org/1999/xhtml"> will benefit from a domain layer, helping you centralize parts for an augmented level of reusability and maintainability.</span></li>
<li><strong><span class="koboSpan" id="kobo.819.1" xmlns="http://www.w3.org/1999/xhtml">Data management projects</span></strong><span class="koboSpan" id="kobo.820.1" xmlns="http://www.w3.org/1999/xhtml"> tend to have less or no logic in them. </span><span class="koboSpan" id="kobo.820.2" xmlns="http://www.w3.org/1999/xhtml">We can often build them without adding a domain layer as the </span><strong><span class="koboSpan" id="kobo.821.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.822.1" xmlns="http://www.w3.org/1999/xhtml"> is often only a tunnel from the </span><strong><span class="koboSpan" id="kobo.823.1" xmlns="http://www.w3.org/1999/xhtml">presentation</span></strong><span class="koboSpan" id="kobo.824.1" xmlns="http://www.w3.org/1999/xhtml"> to the </span><strong><span class="koboSpan" id="kobo.825.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.826.1" xmlns="http://www.w3.org/1999/xhtml">; a pass-through layer. </span><span class="koboSpan" id="kobo.826.2" xmlns="http://www.w3.org/1999/xhtml">We can often simplify those systems by dividing them into two layers: </span><strong><span class="koboSpan" id="kobo.827.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.828.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.829.1" xmlns="http://www.w3.org/1999/xhtml">presentation</span></strong><span class="koboSpan" id="kobo.830.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
</ul></li>
<li><span class="koboSpan" id="kobo.831.1" xmlns="http://www.w3.org/1999/xhtml">Your team; for example, a highly skilled team may tend to use advanced concepts and patterns more efficiently, and the learning curve for newcomers should be easier due to the number of seasoned engineers that can support them on the team. </span><span class="koboSpan" id="kobo.831.2" xmlns="http://www.w3.org/1999/xhtml">This does not mean that less skilled teams should aim lower; on the contrary, it may just be harder or take longer to start. </span><span class="koboSpan" id="kobo.831.3" xmlns="http://www.w3.org/1999/xhtml">Analyze each project individually and find the best patterns to drive them accordingly.</span></li>
<li><span class="koboSpan" id="kobo.832.1" xmlns="http://www.w3.org/1999/xhtml">Your boss; if the company you work for puts pressure on you and your team to deliver complex applications in record time and nobody tells your boss that it is impossible, you may need to cut corners a lot and enjoy many maintenance headaches with crashing systems, painful deployments, and more. </span><span class="koboSpan" id="kobo.832.2" xmlns="http://www.w3.org/1999/xhtml">That being said, if it is inevitable for these types of projects, I’d go with a very simple design that does not aim at reusability—aim at low-to-average testability and code stuff that just works.</span></li>
<li><span class="koboSpan" id="kobo.833.1" xmlns="http://www.w3.org/1999/xhtml">Your budget; once again, this often depends on the people selling the application and the features. </span><span class="koboSpan" id="kobo.833.2" xmlns="http://www.w3.org/1999/xhtml">I saw promises that were impossible to keep but delivered anyway with a lot of effort, extra hours, and corner-cutting. </span><span class="koboSpan" id="kobo.833.3" xmlns="http://www.w3.org/1999/xhtml">The thing to remember when going down that path is that at some point, there is no return from the accumulated </span><strong><span class="koboSpan" id="kobo.834.1" xmlns="http://www.w3.org/1999/xhtml">technical debt</span></strong><span class="koboSpan" id="kobo.835.1" xmlns="http://www.w3.org/1999/xhtml">, and it will just get worse (this applies to all budgets).</span></li>
<li><span class="koboSpan" id="kobo.836.1" xmlns="http://www.w3.org/1999/xhtml">The audience; the people who use the software can make a big difference to how you build it: ask them. </span><span class="koboSpan" id="kobo.836.2" xmlns="http://www.w3.org/1999/xhtml">For example, suppose you are building a tool for your fellow developers. </span><span class="koboSpan" id="kobo.836.3" xmlns="http://www.w3.org/1999/xhtml">In that case, you can cut corners that you would not for less technically skilled users (like delivering a CLI tool instead of a full-blown user interface). </span><span class="koboSpan" id="kobo.836.4" xmlns="http://www.w3.org/1999/xhtml">On the other hand, if you’re aiming your application at multiple clients (web, mobile, and so on), isolating your application’s components and focusing on reusability could be a winning design.</span></li>
<li><span class="koboSpan" id="kobo.837.1" xmlns="http://www.w3.org/1999/xhtml">The expected quality; you should not tackle the problem in the same way for building a prototype and a SaaS application. </span><span class="koboSpan" id="kobo.837.2" xmlns="http://www.w3.org/1999/xhtml">It is acceptable, even encouraged, for a prototype to have no tests and not follow best practices, but I’d recommend the opposite for a production-quality application.</span></li>
<li><span class="koboSpan" id="kobo.838.1" xmlns="http://www.w3.org/1999/xhtml">Any other things that life throws at you; yes, life is unpredictable, and no one can cover every possible scenario in a book, so just keep the following in mind when building your next piece of software:
</span><ul>
<li><span class="koboSpan" id="kobo.839.1" xmlns="http://www.w3.org/1999/xhtml">Do not over-engineer your applications.</span></li>
<li><span class="koboSpan" id="kobo.840.1" xmlns="http://www.w3.org/1999/xhtml">Only implement features that you need, not more, as per the </span><strong><span class="koboSpan" id="kobo.841.1" xmlns="http://www.w3.org/1999/xhtml">you aren’t gonna need it</span></strong><span class="koboSpan" id="kobo.842.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.843.1" xmlns="http://www.w3.org/1999/xhtml">YAGNI</span></strong><span class="koboSpan" id="kobo.844.1" xmlns="http://www.w3.org/1999/xhtml">) </span><strong/><span class="koboSpan" id="kobo.845.1" xmlns="http://www.w3.org/1999/xhtml"> principle.</span></li>
<li><span class="koboSpan" id="kobo.846.1" xmlns="http://www.w3.org/1999/xhtml">Use your judgment and take the less-worst options; there is no perfect solution.</span></li>
</ul></li>
</ul>
<p><span class="koboSpan" id="kobo.847.1" xmlns="http://www.w3.org/1999/xhtml">I hope you found this guidance helpful and that it will serve you in your career.</span></p>
</section>
<section class="level3" data-number="15.7.2" id="building-a-façade-over-a-database">
<h3 data-number="15.7.2"><span class="koboSpan" id="kobo.848.1" xmlns="http://www.w3.org/1999/xhtml">Building a façade over a database</span></h3>
<p><span class="koboSpan" id="kobo.849.1" xmlns="http://www.w3.org/1999/xhtml">Data-driven programs are a type of software that I often see in smaller enterprises. </span><span class="koboSpan" id="kobo.849.2" xmlns="http://www.w3.org/1999/xhtml">Those companies need to support their day-to-day operations with computers, not the other way around. </span><span class="koboSpan" id="kobo.849.3" xmlns="http://www.w3.org/1999/xhtml">Every company needs internal tools, and many needed them yesterday.The reason is simple; every company is unique. </span><span class="koboSpan" id="kobo.849.4" xmlns="http://www.w3.org/1999/xhtml">Because it’s unique, due to its business model, leadership, or employees, it also needs unique tools to help with its day-to-day operations. </span><span class="koboSpan" id="kobo.849.5" xmlns="http://www.w3.org/1999/xhtml">Those small tools are often simple user interfaces over a database, controlling access to that data. </span><span class="koboSpan" id="kobo.849.6" xmlns="http://www.w3.org/1999/xhtml">In these cases, you don’t need over-engineered solutions, as long as everyone is informed that the tool will not evolve beyond what it is: a small tool.In real life, this one is tough to explain to non-programmers because they tend to see complex use cases as easy to implement and simple use cases as hard to implement. </span><span class="koboSpan" id="kobo.849.7" xmlns="http://www.w3.org/1999/xhtml">It’s normal; they just don’t know, and we all don’t know something. </span><span class="koboSpan" id="kobo.849.8" xmlns="http://www.w3.org/1999/xhtml">In these scenarios, a big part of our job is also to educate people. </span><span class="koboSpan" id="kobo.849.9" xmlns="http://www.w3.org/1999/xhtml">Advising decision-makers about the differences in quality between a small tool and a large business application. </span><span class="koboSpan" id="kobo.849.10" xmlns="http://www.w3.org/1999/xhtml">Educating and working with stakeholders makes them aware of the situation and make decisions with you, leading to higher project quality that meets everyone’s expectations. </span><span class="koboSpan" id="kobo.849.11" xmlns="http://www.w3.org/1999/xhtml">This can also reduce the “</span><em><span class="koboSpan" id="kobo.850.1" xmlns="http://www.w3.org/1999/xhtml">it’s not my fault</span></em><span class="koboSpan" id="kobo.851.1" xmlns="http://www.w3.org/1999/xhtml">” syndrome from both sides.I’ve found that immersing customers and decision-makers in the decision process and having them follow the development cycle helps them understand the reality behind the programs and helps both sides stay happy and grow more satisfied. </span><span class="koboSpan" id="kobo.851.2" xmlns="http://www.w3.org/1999/xhtml">Stakeholders not getting what they want is no better than you being super stressed over unreachable deadlines.That said, our educational role does not end with decision-makers. </span><span class="koboSpan" id="kobo.851.3" xmlns="http://www.w3.org/1999/xhtml">Teaching new tools and techniques to your peers is also a major way to improve your team, peers, and yourself. </span><span class="koboSpan" id="kobo.851.4" xmlns="http://www.w3.org/1999/xhtml">Explaining concepts is not always as easy as it sounds.Nevertheless, data-driven programs may be hard to avoid, especially if you are working for SMEs, so try to get the best out of it. </span><span class="koboSpan" id="kobo.851.5" xmlns="http://www.w3.org/1999/xhtml">Nowadays, with low-code and no-code solutions and all the open-source libraries, you might be able to save yourself a lot of this kind of trouble, but maybe not all.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.852.1" xmlns="http://www.w3.org/1999/xhtml">Remember that someday, someone must maintain those small tools. </span><span class="koboSpan" id="kobo.852.2" xmlns="http://www.w3.org/1999/xhtml">Think of that person as you, and think about how you’d like some guidelines or documentation to help you. </span><span class="koboSpan" id="kobo.852.3" xmlns="http://www.w3.org/1999/xhtml">I’m not saying to over-document projects, as documentation often gets out of sync with the code and becomes more of a problem than a solution. </span><span class="koboSpan" id="kobo.852.4" xmlns="http://www.w3.org/1999/xhtml">However, a simple </span><code><span class="koboSpan" id="kobo.853.1" xmlns="http://www.w3.org/1999/xhtml">README.md</span></code><span class="koboSpan" id="kobo.854.1" xmlns="http://www.w3.org/1999/xhtml"> file at the project's root explaining how to build and run the program and some general guidelines could be beneficial. </span><span class="koboSpan" id="kobo.854.2" xmlns="http://www.w3.org/1999/xhtml">Always think about documentation as if you were the one reading it. </span><span class="koboSpan" id="kobo.854.3" xmlns="http://www.w3.org/1999/xhtml">Most people don’t like to spend hours reading documentation to understand something simple, so keep it simple.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.855.1" xmlns="http://www.w3.org/1999/xhtml">When building a </span><em><span class="koboSpan" id="kobo.856.1" xmlns="http://www.w3.org/1999/xhtml">façade over a database</span></em><span class="koboSpan" id="kobo.857.1" xmlns="http://www.w3.org/1999/xhtml">, you want to keep it simple. </span><span class="koboSpan" id="kobo.857.2" xmlns="http://www.w3.org/1999/xhtml">Also, you should make it clear that it should not evolve past that role. </span><span class="koboSpan" id="kobo.857.3" xmlns="http://www.w3.org/1999/xhtml">One way to build this would be to use EF Core as your data layer and scaffold an MVC application as your presentation layer, shielding your database. </span><span class="koboSpan" id="kobo.857.4" xmlns="http://www.w3.org/1999/xhtml">You can use the built-in ASP.NET Core authentication and authorization mechanism if you need access control. </span><span class="koboSpan" id="kobo.857.5" xmlns="http://www.w3.org/1999/xhtml">You can then choose role-based or policy-based access control or any other way that makes sense for your tool and allows you to control access to the data the way you need to.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.858.1" xmlns="http://www.w3.org/1999/xhtml">Keeping it simple should help you build more tools in less time, making everyone happy.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.859.1" xmlns="http://www.w3.org/1999/xhtml">From a layering standpoint, using my previous example, you will end up having two layers sharing the data model:</span></p>
<figure>
<span class="koboSpan" id="kobo.860.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 14.18: A façade-like presentation layer over a database application’s design" src="../media/file92.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.861.1" xmlns="http://www.w3.org/1999/xhtml">Figure 14.18: A façade-like presentation layer over a database application’s design</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.862.1" xmlns="http://www.w3.org/1999/xhtml">Nothing stops you from creating a </span><strong><span class="koboSpan" id="kobo.863.1" xmlns="http://www.w3.org/1999/xhtml">view model</span></strong><span class="koboSpan" id="kobo.864.1" xmlns="http://www.w3.org/1999/xhtml"> here and there for more complex views, but the key is to keep the logic’s complexity to a minimum. </span><span class="koboSpan" id="kobo.864.2" xmlns="http://www.w3.org/1999/xhtml">Otherwise, you may discover the hard way that sometimes, rewriting a program from scratch takes less time than trying to fix it. </span><span class="koboSpan" id="kobo.864.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, nothing stops you from using any other presentation tools and components available to you.Using this data-driven architecture as a temporary application while the main application is in development is also a good solution. </span><span class="koboSpan" id="kobo.864.4" xmlns="http://www.w3.org/1999/xhtml">It takes a fraction of the time to build, and the users have access to it immediately. </span><span class="koboSpan" id="kobo.864.5" xmlns="http://www.w3.org/1999/xhtml">You can even get feedback from it, which allows you to fix any mistakes before they are implemented in the real (future) application, working like a living prototype.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.865.1" xmlns="http://www.w3.org/1999/xhtml">A good database design in these sorts of applications can go a long way.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.866.1" xmlns="http://www.w3.org/1999/xhtml">Not all projects are that simple, but still, many are; the key is to make the program good enough while ensuring you cut the right corners. </span><span class="koboSpan" id="kobo.866.2" xmlns="http://www.w3.org/1999/xhtml">The presentation layer in these types of applications could leverage a low-code solution such as Power Apps, for example.</span></p>
</section>
</section>
<section class="level2" data-number="15.8" id="summary-13">
<h2 data-number="15.8"><span class="koboSpan" id="kobo.867.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.868.1" xmlns="http://www.w3.org/1999/xhtml">Layering is one of the most used architectural techniques when it comes to designing applications. </span><span class="koboSpan" id="kobo.868.2" xmlns="http://www.w3.org/1999/xhtml">An application is often split into multiple different layers, each managing a single responsibility. </span><span class="koboSpan" id="kobo.868.3" xmlns="http://www.w3.org/1999/xhtml">The three most popular layers are </span><strong><span class="koboSpan" id="kobo.869.1" xmlns="http://www.w3.org/1999/xhtml">presentation</span></strong><span class="koboSpan" id="kobo.870.1" xmlns="http://www.w3.org/1999/xhtml">, </span><strong><span class="koboSpan" id="kobo.871.1" xmlns="http://www.w3.org/1999/xhtml">domain</span></strong><span class="koboSpan" id="kobo.872.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><strong><span class="koboSpan" id="kobo.873.1" xmlns="http://www.w3.org/1999/xhtml">data</span></strong><span class="koboSpan" id="kobo.874.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.874.2" xmlns="http://www.w3.org/1999/xhtml">You are not limited to three layers; you can split each into smaller layers (or smaller pieces inside the same conceptual layer), leading to composable, manageable, and maintainable applications.Moreover, you can create abstraction layers to invert the flow of dependency and separate interfaces from implementations, as we saw in the </span><em><span class="koboSpan" id="kobo.875.1" xmlns="http://www.w3.org/1999/xhtml">Abstract layers</span></em><span class="koboSpan" id="kobo.876.1" xmlns="http://www.w3.org/1999/xhtml"> section. </span><span class="koboSpan" id="kobo.876.2" xmlns="http://www.w3.org/1999/xhtml">You can persist the domain entities directly or create an independent model for the data layer. </span><span class="koboSpan" id="kobo.876.3" xmlns="http://www.w3.org/1999/xhtml">You can also use an anemic model (no logic or method) or a rich model (packed with entity-related logic). </span><span class="koboSpan" id="kobo.876.4" xmlns="http://www.w3.org/1999/xhtml">You can share that model between multiple layers or have each layer possess its own.Out of layering was born Clean Architecture, which guides organizing your application into concentric layers, often dividing the application into use cases.Let’s see how this approach can help us move toward the </span><strong><span class="koboSpan" id="kobo.877.1" xmlns="http://www.w3.org/1999/xhtml">SOLID</span></strong><span class="koboSpan" id="kobo.878.1" xmlns="http://www.w3.org/1999/xhtml"> principles at app scale:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.879.1" xmlns="http://www.w3.org/1999/xhtml">S</span></strong><span class="koboSpan" id="kobo.880.1" xmlns="http://www.w3.org/1999/xhtml">: Layering leads us toward splitting responsibilities horizontally, with each layer oriented around a single macro-concern. </span><span class="koboSpan" id="kobo.880.2" xmlns="http://www.w3.org/1999/xhtml">The main goal of layering is responsibility segregation.</span></li>
<li><strong><span class="koboSpan" id="kobo.881.1" xmlns="http://www.w3.org/1999/xhtml">O</span></strong><span class="koboSpan" id="kobo.882.1" xmlns="http://www.w3.org/1999/xhtml">: Abstract layers enable consumers to act differently (change behaviors) based on the provided implementation (concrete layer).</span></li>
<li><strong><span class="koboSpan" id="kobo.883.1" xmlns="http://www.w3.org/1999/xhtml">L</span></strong><span class="koboSpan" id="kobo.884.1" xmlns="http://www.w3.org/1999/xhtml">: N/A</span></li>
<li><strong><span class="koboSpan" id="kobo.885.1" xmlns="http://www.w3.org/1999/xhtml">I</span></strong><span class="koboSpan" id="kobo.886.1" xmlns="http://www.w3.org/1999/xhtml">: Splitting layers based on features (or cohesive groups of features) is a way of segregating a system into smaller blocks (interfaces).</span></li>
<li><strong><span class="koboSpan" id="kobo.887.1" xmlns="http://www.w3.org/1999/xhtml">D</span></strong><span class="koboSpan" id="kobo.888.1" xmlns="http://www.w3.org/1999/xhtml">: Abstraction layers lead directly to the dependency flow’s inversion, while classic layering leads in the opposite direction.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.889.1" xmlns="http://www.w3.org/1999/xhtml">In the next chapter, we learn how to centralize the logic of copying objects (models) using object mappers and an open-source tool to help us skip the implementation, also known as productive laziness.</span></p>
</section>
<section class="level2" data-number="15.9" id="questions-13">
<h2 data-number="15.9"><span class="koboSpan" id="kobo.890.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.891.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.892.1" xmlns="http://www.w3.org/1999/xhtml">When creating a layered application, is it true that we must have presentation, domain, and data layers?</span></li>
<li><span class="koboSpan" id="kobo.893.1" xmlns="http://www.w3.org/1999/xhtml">Is a rich domain model better than an anemic domain model?</span></li>
<li><span class="koboSpan" id="kobo.894.1" xmlns="http://www.w3.org/1999/xhtml">Does EF Core implement the Repository and Unit of Work patterns?</span></li>
<li><span class="koboSpan" id="kobo.895.1" xmlns="http://www.w3.org/1999/xhtml">Do we need to use an ORM in the data layer?</span></li>
<li><span class="koboSpan" id="kobo.896.1" xmlns="http://www.w3.org/1999/xhtml">Can a layer in Clean Architecture access any inward layers?</span></li>
</ol>
</section>
<section class="level2" data-number="15.10" id="further-reading-11">
<h2 data-number="15.10"><span class="koboSpan" id="kobo.897.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.898.1" xmlns="http://www.w3.org/1999/xhtml">Here are a few links to help you build on what we learned in this chapter:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.899.1" xmlns="http://www.w3.org/1999/xhtml">Dapper</span></strong><span class="koboSpan" id="kobo.900.1" xmlns="http://www.w3.org/1999/xhtml"> is a simple yet powerful ORM for .NET, made by the people of Stack Overflow. </span><span class="koboSpan" id="kobo.900.2" xmlns="http://www.w3.org/1999/xhtml">If you like writing SQL, but don’t like mapping data to objects, this ORM might be for you: </span><a href="https://adpg.link/pTYs"><span class="koboSpan" id="kobo.901.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/pTYs</span></a><span class="koboSpan" id="kobo.902.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.903.1" xmlns="http://www.w3.org/1999/xhtml">An article that I wrote in 2017, talking about the Repository pattern; that is, « Design Patterns: ASP.NET Core Web API, services, and repositories | Part 5: Repositories, the ClanRepository, and integration testing »: </span><a href="https://adpg.link/D53Z"><span class="koboSpan" id="kobo.904.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/D53Z</span></a><span class="koboSpan" id="kobo.905.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.906.1" xmlns="http://www.w3.org/1999/xhtml">Entity Framework Core – Using Transactions: </span><a href="https://adpg.link/gxwD"><span class="koboSpan" id="kobo.907.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/gxwD</span></a><span class="koboSpan" id="kobo.908.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
<li><span class="koboSpan" id="kobo.909.1" xmlns="http://www.w3.org/1999/xhtml">Here are resources about Clean Architecture:
</span><ul>
<li><span class="koboSpan" id="kobo.910.1" xmlns="http://www.w3.org/1999/xhtml">Common web application architectures (Microsoft Learn): </span><a href="https://adpg.link/Pnpn"><span class="koboSpan" id="kobo.911.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/Pnpn</span></a></li>
<li><span class="koboSpan" id="kobo.912.1" xmlns="http://www.w3.org/1999/xhtml">Microsoft eShopOnWeb ASP.NET Core Reference Application: </span><a href="https://adpg.link/dsw1"><span class="koboSpan" id="kobo.913.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/dsw1</span></a></li>
<li><span class="koboSpan" id="kobo.914.1" xmlns="http://www.w3.org/1999/xhtml">GitHub—Clean Architecture (Ardalis/Steve Smith)—Solution templates: </span><a href="https://adpg.link/tpPi"><span class="koboSpan" id="kobo.915.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/tpPi</span></a></li>
<li><span class="koboSpan" id="kobo.916.1" xmlns="http://www.w3.org/1999/xhtml">GitHub—Clean Architecture (Jason Taylor)—Solution templates: </span><a href="https://adpg.link/jxX2"><span class="koboSpan" id="kobo.917.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/jxX2</span></a></li>
</ul></li>
</ul>
</section>
<section class="level2" data-number="15.11" id="answers-10">
<h2 data-number="15.11"><span class="koboSpan" id="kobo.918.1" xmlns="http://www.w3.org/1999/xhtml">Answers</span></h2>
<ol>
<li><span class="koboSpan" id="kobo.919.1" xmlns="http://www.w3.org/1999/xhtml">No, you can have as many layers as you need and name and organize them as you want.</span></li>
<li><span class="koboSpan" id="kobo.920.1" xmlns="http://www.w3.org/1999/xhtml">No, both have their place, their pros, and their cons.</span></li>
<li><span class="koboSpan" id="kobo.921.1" xmlns="http://www.w3.org/1999/xhtml">Yes. </span><span class="koboSpan" id="kobo.921.2" xmlns="http://www.w3.org/1999/xhtml">A </span><code><span class="koboSpan" id="kobo.922.1" xmlns="http://www.w3.org/1999/xhtml">DbContext</span></code><span class="koboSpan" id="kobo.923.1" xmlns="http://www.w3.org/1999/xhtml"> is an implementation of the Unit of Work pattern. </span><code><span class="koboSpan" id="kobo.924.1" xmlns="http://www.w3.org/1999/xhtml">DbSet&lt;T&gt;</span></code><span class="koboSpan" id="kobo.925.1" xmlns="http://www.w3.org/1999/xhtml"> is an implementation of the Repository pattern.</span></li>
<li><span class="koboSpan" id="kobo.926.1" xmlns="http://www.w3.org/1999/xhtml">No, you can query any system in any way you want. </span><span class="koboSpan" id="kobo.926.2" xmlns="http://www.w3.org/1999/xhtml">For example, you could use ADO.NET to query a relational database, manually create the objects using a </span><code><span class="koboSpan" id="kobo.927.1" xmlns="http://www.w3.org/1999/xhtml">DataReader</span></code><span class="koboSpan" id="kobo.928.1" xmlns="http://www.w3.org/1999/xhtml">, track changes using a </span><code><span class="koboSpan" id="kobo.929.1" xmlns="http://www.w3.org/1999/xhtml">DataSet</span></code><span class="koboSpan" id="kobo.930.1" xmlns="http://www.w3.org/1999/xhtml">, or do anything else that fits your needs. </span><span class="koboSpan" id="kobo.930.2" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, ORMs can be very convenient.</span></li>
<li><span class="koboSpan" id="kobo.931.1" xmlns="http://www.w3.org/1999/xhtml">Yes. </span><span class="koboSpan" id="kobo.931.2" xmlns="http://www.w3.org/1999/xhtml">A layer can never access outward layers, only inward ones.</span></li>
</ol>
</section>
</section>
</body>
</html>
