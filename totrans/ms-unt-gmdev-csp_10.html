<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"/>6</h1>
<h1 id="_idParaDest-95" class="calibre5"><a id="_idTextAnchor099" class="calibre6 pcalibre1 pcalibre"/>Effective Game Data Handling and Management with C# in Unity</h1>
<p class="calibre3">Welcome to <a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 6</em></a>, where we’ll delve into effective game data handling and management using C# in Unity. Through practical exploration, you’ll learn how to organize, store, and retrieve game data seamlessly. From understanding data organization and serialization to implementing save and load systems, you’ll be able to empower players to preserve their progress and craft dynamic, data-driven gameplay experiences. By the end of this chapter, you’ll have mastered the art of wielding C# for efficient game data management, unlocking endless possibilities for immersive gameplay. Let’s embark on this journey together, where mastery of game data opens doors to boundless creativity in game development.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Data organization and serialization with C#</li>
<li class="calibre11">Creating save and load systems using C#</li>
<li class="calibre11">Data-driven gameplay with C#</li>
</ul>
<h1 id="_idParaDest-96" class="calibre5"><a id="_idTextAnchor100" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">To complete this chapter, you must have the following:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Unity version 2022.3.13</strong>: Download and install Unity, choosing version <strong class="source-inline1">2022.3.13</strong> for optimal compatibility with the provided content.</li>
<li class="calibre11"><strong class="bold">Primary IDE – Visual Studio 2022</strong>: The tutorials and code samples in this chapter have been crafted using Visual Studio 2022. Ensure it’s installed so that you can follow along seamlessly. Feel free to explore Rider or other IDEs if you prefer, though note that the instructions that have been provided are tailored for Visual Studio.</li>
<li class="calibre11"><strong class="bold">GitHub repository for code samples</strong>: You can access the code samples and project files for this chapter via this book’s dedicated GitHub repository:  <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2006</a>. Clone or download the repository so that you have easy access to the code provided in this chapter.</li>
</ul>
<h1 id="_idParaDest-97" class="calibre5"><a id="_idTextAnchor101" class="calibre6 pcalibre1 pcalibre"/>Data organization and serialization with C#</h1>
<p class="calibre3">In this section, we’ll <a id="_idIndexMarker358" class="calibre6 pcalibre1 pcalibre"/>dive into data organization and serialization with C# in Unity. Here, we’ll learn how to manage game data efficiently. First, we’ll talk about picking the right data structures, such as arrays and lists, and how to make your own. Then, we’ll cover serialization, which<a id="_idIndexMarker359" class="calibre6 pcalibre1 pcalibre"/> helps save and load game data. Then, we’ll explore Unity’s options, such as <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) and <strong class="bold">eXtensible Markup Language</strong> (<strong class="bold">XML</strong>). By covering some simple examples, we’ll <a id="_idIndexMarker360" class="calibre6 pcalibre1 pcalibre"/>show you how to organize and save game data neatly using C#. Let’s start learning how to master game data management!</p>
<h2 id="_idParaDest-98" class="calibre7"><a id="_idTextAnchor102" class="calibre6 pcalibre1 pcalibre"/>Understanding data structures</h2>
<p class="calibre3">Selecting the <a id="_idIndexMarker361" class="calibre6 pcalibre1 pcalibre"/>appropriate data structure for storing information in your game involves considering factors such as the type of data, how frequently it will be accessed, and the operations you need to perform on that data. Here are some examples to illustrate how you can choose the right method:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Arrays</strong>: Use<a id="_idIndexMarker362" class="calibre6 pcalibre1 pcalibre"/> arrays when you have a fixed-size collection of <a id="_idIndexMarker363" class="calibre6 pcalibre1 pcalibre"/>elements of the same type.<p class="calibre3">For instance, if you have a game with a set number of levels, as shown in the following code, you might use an array to store level data, such as scores or the completion status for each level:</p><pre class="source-code">
int[] levelScores = new int[10]; // An array to store scores for 10 levels</pre></li> <li class="calibre11"><strong class="bold">Lists</strong>: Lists<a id="_idIndexMarker364" class="calibre6 pcalibre1 pcalibre"/> are dynamic arrays that can grow or shrink in<a id="_idIndexMarker365" class="calibre6 pcalibre1 pcalibre"/> size at runtime. They are suitable when you need to add or remove elements frequently.<p class="calibre3">For example, if you have a game with an inventory system where items can be added or removed dynamically, a list would be more appropriate. Take a look at the following code for an example:</p><pre class="source-code">
List&lt;string&gt; inventoryItems = new List&lt;string&gt;(); // A list to store inventory items
inventoryItems.Add("Sword");
inventoryItems.Add("Potion");</pre></li> <li class="calibre11"><strong class="bold">Dictionaries</strong>: Dictionaries<a id="_idIndexMarker366" class="calibre6 pcalibre1 pcalibre"/> are useful when you <a id="_idIndexMarker367" class="calibre6 pcalibre1 pcalibre"/>need to associate keys with values. They are ideal for situations where you need to quickly look up values based on specific keys.<ul class="calibre16"><li class="calibre11">For instance, if you have a game with a leaderboard, you might use a dictionary to map player names to their scores, as shown here:<pre class="source-code">
Dictionary&lt;string, int&gt; leaderboard = new Dictionary&lt;string, int&gt;(); leaderboard.Add("Player1", 1000);
leaderboard.Add("Player2", 1500);</pre></li></ul></li> <li class="calibre11"><strong class="bold">Custom data structures</strong>: Sometimes, none of the built-in data structures are the <a id="_idIndexMarker368" class="calibre6 pcalibre1 pcalibre"/>perfect fit for your needs. In such cases, you <a id="_idIndexMarker369" class="calibre6 pcalibre1 pcalibre"/>can create custom data structures tailored to your specific requirements.<ul class="calibre16"><li class="calibre11">For example, if you’re developing a complex RPG game, you might create a custom data structure to represent character attributes and abilities. The <strong class="source-inline1">Character</strong> class is one such custom data structure:<pre class="source-code">
public class Character {
  public string Name;
  public int Health;
  public int AttackDamage;
}</pre></li></ul></li> </ul>
<p class="calibre3">By carefully <a id="_idIndexMarker370" class="calibre6 pcalibre1 pcalibre"/>considering the nature of your data and the operations you need to perform, you can choose the most appropriate data structure for your game, ensuring optimal performance and efficient data management.</p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor103" class="calibre6 pcalibre1 pcalibre"/>Enhancing game performance with proper data structure selection</h2>
<p class="calibre3">In the <a id="_idIndexMarker371" class="calibre6 pcalibre1 pcalibre"/>world of game creation, where speed and efficiency matter most, picking the right data structures is crucial. It helps game makers achieve smoother and faster gameplay, making their games more enjoyable for players.</p>
<p class="calibre3">Choosing the appropriate data structure can significantly benefit game performance in several ways:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Optimized memory usage</strong>: Using the right data structure helps minimize memory usage, which is crucial for performance, especially in resource-intensive games.<ul class="calibre16"><li class="calibre11">For example, if your game only needs to store a fixed number of elements of the same type, using an array instead of a list can save memory because arrays have a fixed size.</li></ul></li>
<li class="calibre11"><strong class="bold">Faster access and retrieval</strong>: Certain data structures offer faster access and retrieval times, which can improve overall game responsiveness.<ul class="calibre16"><li class="calibre11">For instance, dictionaries provide constant-time lookups, making them ideal for scenarios where you need to quickly retrieve values based on keys, such as accessing player data in a leaderboard.</li></ul></li>
<li class="calibre11"><strong class="bold">Efficient data manipulation</strong>: Choosing the appropriate data structure can streamline data manipulation operations, leading to smoother gameplay experiences.<ul class="calibre16"><li class="calibre11">Lists, for example, allow for efficient insertion and removal of elements, making them suitable for dynamic scenarios such as managing an inventory where items are frequently added or removed.</li></ul></li>
<li class="calibre11"><strong class="bold">Enhanced code readability and maintainability</strong>: Using the right data structure can make your code more readable and maintainable, leading to easier debugging and future updates. Custom data structures tailored to your game’s specific needs can improve code organization and clarity, making it easier <a id="_idIndexMarker372" class="calibre6 pcalibre1 pcalibre"/>for you and other developers to understand and modify the code base.<ul class="calibre16"><li class="calibre11">For instance, if your game includes challenges, you can design a custom class specifically for managing these challenges. Within this class, you can incorporate attributes such as a list of rewards and a unique identifier for each challenge. This approach enhances the readability of your code base.</li></ul></li>
<li class="calibre11"><strong class="bold">Reduced processing overhead</strong>: Optimal data structures help reduce processing overhead, contributing to smoother gameplay and better overall performance.<ul class="calibre16"><li class="calibre11">For example, if your game needs to iterate through a collection of elements in a specific order, using a list instead of a dictionary can eliminate unnecessary key-value pair lookups, resulting in faster iteration times.</li></ul></li>
</ul>
<p class="calibre3">In summary, selecting the appropriate data structure is critical for optimizing game performance as it helps minimize memory usage, improve access times, streamline data manipulation, enhance code readability, and reduce processing overhead. By understanding the characteristics and advantages of different data structures, game developers can design more efficient and responsive gameplay experiences for players.</p>
<p class="calibre3">In the upcoming subsection, we’ll delve deeper into Unity’s serialization, exploring its role in efficiently saving and loading data.</p>
<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor104" class="calibre6 pcalibre1 pcalibre"/>Serialization in Unity</h2>
<p class="calibre3"><strong class="bold">Serialization</strong> is the <a id="_idIndexMarker373" class="calibre6 pcalibre1 pcalibre"/>process of converting complex objects or data structures into a format that can be easily stored or transmitted and then reconstructed later. In the context of Unity game development, serialization plays a crucial role in saving and loading game data. By serializing game objects and their properties, Unity can store them in a format that can be saved to disk or transferred over the network, allowing for persistence between sessions and enabling features such as saving games and networked multiplayer.</p>
<p class="calibre3">Serialization<a id="_idIndexMarker374" class="calibre6 pcalibre1 pcalibre"/> is a fundamental aspect of game development for several reasons:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Persistence between sessions</strong>: Serialization allows game state and player progress to be saved and loaded between gameplay sessions. This enables features such as saving and loading game progress, maintaining player inventories, and preserving game settings.</li>
<li class="calibre11"><strong class="bold">Network communication</strong>: Serialization facilitates transmitting game data over the network, which is essential for multiplayer games, client-server architectures, and online features. By serializing game objects and messages, Unity can send data between clients and servers efficiently.</li>
<li class="calibre11"><strong class="bold">Data interchange</strong>: Serialization allows data to be exchanged between different systems and platforms. For example, game data can be serialized into a standardized format such as JSON or XML, allowing it to be shared with other applications or integrated with web services.</li>
<li class="calibre11"><strong class="bold">Data persistence</strong>: Serialization allows data to be stored in a structured format, such as files or databases, ensuring that it persists even when the game isn’t running. This is crucial for features such as saving and loading user preferences, high scores, and game configurations.</li>
</ul>
<p class="calibre3">By understanding the principles of serialization and mastering Unity’s serialization options, we can implement robust and flexible data management systems, enabling features such as save games, networked multiplayer, and data-driven gameplay mechanics. Serialization is a fundamental tool in our toolkit, empowering us to create immersive and dynamic gaming experiences across platforms and genres.</p>
<p class="calibre3">In Unity, serialization is seamlessly integrated into the engine’s workflow, allowing us to easily save and load game data using built-in APIs and utilities. Unity provides various serialization options, including JSON, XML, and binary serialization, each suited to different use cases and requirements. As we can see in this section.</p>
<p class="calibre3">Let’s explore the options that are available in Unity so that we can integrate them into our game. We’ll begin by defining each option and providing an example for better understanding. We’ll delve into each one and illustrate their usage.</p>
<h3 class="calibre9">JSON serialization and deserialization</h3>
<p class="calibre3">JSON is a<a id="_idIndexMarker375" class="calibre6 pcalibre1 pcalibre"/> lightweight data-interchange format that is commonly used for transmitting data between a server and a web application. In Unity, JSON <a id="_idIndexMarker376" class="calibre6 pcalibre1 pcalibre"/>serialization and deserialization <a id="_idIndexMarker377" class="calibre6 pcalibre1 pcalibre"/>are useful for scenarios where you need to exchange data with external systems or web services.</p>
<p class="calibre3"><em class="italic">Example</em>: In the following code block, we’re utilizing Unity’s built-in system to serialize and deserialize data:</p>
<pre class="source-code">
// Serialize object to JSON string
string jsonString = JsonUtility.ToJson(myObject);
// Deserialize JSON string back to object
MyClass deserializedObject = JsonUtility.FromJson&lt;MyClass&gt;(jsonString);</pre> <h3 class="calibre9">XML serialization and deserialization</h3>
<p class="calibre3">XML is a <a id="_idIndexMarker378" class="calibre6 pcalibre1 pcalibre"/>versatile format that is used for data exchange and configuration settings. Unity supports XML serialization and deserialization, making it suitable for scenarios where you need to work<a id="_idIndexMarker379" class="calibre6 pcalibre1 pcalibre"/> with legacy systems or integrate with platforms<a id="_idIndexMarker380" class="calibre6 pcalibre1 pcalibre"/> that use XML as the data interchange format.</p>
<p class="calibre3"><em class="italic">Example</em>: The following code block demonstrates how to serialize and deserialize data to and from XML.</p>
<p class="calibre3">To utilize this type of serialization, you must include the <code>using System.IO;</code> and <code>using System.Xml.Serialization;</code> namespaces, like so:</p>
<pre class="source-code">
// Serialize object to XML string
XmlSerializer serializer = new XmlSerializer(typeof(MyClass));
StringWriter writer = new StringWriter();
serializer.Serialize(writer, myObject);
string xmlString = writer.ToString();
// Deserialize XML string back to object
StringReader reader = new StringReader(xmlString);
MyClass deserializedObject = (MyClass)serializer.Deserialize(reader);</pre> <p class="calibre3">Let’s take a closer look at the <a id="_idIndexMarker381" class="calibre6 pcalibre1 pcalibre"/>XML serialization and deserialization provided <a id="_idIndexMarker382" class="calibre6 pcalibre1 pcalibre"/>here:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Serialization process</strong>:<ul class="calibre16"><li class="calibre11">Serialization is the process of converting an object into a format that can be easily stored or transmitted and reconstructed later</li><li class="calibre11"><strong class="source-inline1">XmlSerializer</strong> is a class provided by the .NET framework for serializing and deserializing objects to and from XML format</li><li class="calibre11"><strong class="source-inline1">XmlSerializer serializer = new XmlSerializer(typeof(MyClass));</strong>: This line creates an instance of the <strong class="source-inline1">XmlSerializer</strong> class that specifies the type of object (<strong class="source-inline1">MyClass</strong>) to be serialized</li><li class="calibre11"><strong class="source-inline1">StringWriter writer = new StringWriter();</strong>: This line creates a <strong class="source-inline1">StringWriter</strong> object, which is used to write XML content as a string</li><li class="calibre11"><strong class="source-inline1">serializer.Serialize(writer, myObject);</strong>: This line serializes the <strong class="source-inline1">myObject</strong> instance of <strong class="source-inline1">MyClass</strong> into XML format and writes it to <strong class="source-inline1">StringWriter</strong></li><li class="calibre11"><strong class="source-inline1">string xmlString = writer.ToString();</strong>: This line converts the XML content written to <strong class="source-inline1">StringWriter</strong> into a string representation and stores it in the <strong class="source-inline1">xmlString</strong> variable</li></ul></li>
<li class="calibre11"><strong class="bold">Deserialization process</strong>:<ul class="calibre16"><li class="calibre11">Deserialization <a id="_idIndexMarker383" class="calibre6 pcalibre1 pcalibre"/>is the process of reconstructing an object from its serialized XML representation.</li><li class="calibre11"><strong class="source-inline1">StringReader reader = new StringReader(xmlString);</strong>: This line creates a <strong class="source-inline1">StringReader</strong> object, which is used to read XML content from a string.</li><li class="calibre11"><strong class="source-inline1">(MyClass)serializer.Deserialize(reader);</strong>: This line deserializes the XML content from <strong class="source-inline1">StringReader</strong> back into an object of the <strong class="source-inline1">MyClass</strong> type. The <strong class="source-inline1">Deserialize</strong> method of the <strong class="source-inline1">XmlSerializer</strong> class is used for this purpose.</li><li class="calibre11">The deserialized object is then assigned to the <strong class="source-inline1">deserializedObject</strong> variable, ready for use in the program.</li></ul></li>
</ul>
<p class="calibre3">In summary, the provided code block demonstrates how to serialize an object of the <code>MyClass</code> type as an XML string and then deserialize the XML string back into an object of the same type using the <code>XmlSerializer</code> class in C#. This process allows objects to be easily persisted to storage or transmitted over a network in XML format and reconstructed later for use in the application.</p>
<h3 class="calibre9">Binary serialization and deserialization</h3>
<p class="calibre3">Binary serialization <a id="_idIndexMarker384" class="calibre6 pcalibre1 pcalibre"/>and deserialization are ideal for scenarios where you need to <a id="_idIndexMarker385" class="calibre6 pcalibre1 pcalibre"/>save and load game data efficiently, such as implementing save games or storing configuration settings locally on the user’s device. Binary serialization provides a compact representation of data and faster read/write times compared to text-based formats such as JSON or XML.</p>
<p class="calibre3"><em class="italic">Example</em>: The following code block shows how to serialize and deserialize data to and from binary format.</p>
<p class="calibre3">To utilize this type of serialization, you must include the <code>using System.IO;</code> and<code> using System.Runtime.Serialization.Formatters.Binary;</code> namespaces, as<a id="_idIndexMarker386" class="calibre6 pcalibre1 pcalibre"/> follows:</p>
<pre class="source-code">
// Serialize object to binary format
BinaryFormatter formatter = new BinaryFormatter();
MemoryStream stream = new MemoryStream();
formatter.Serialize(stream, myObject);
byte[] binaryData = stream.ToArray();
// Deserialize binary data back to object
stream = new MemoryStream(binaryData);
MyClass deserializedObject = (MyClass)formatter.Deserialize(stream);</pre> <p class="calibre3">Let’s take a closer <a id="_idIndexMarker387" class="calibre6 pcalibre1 pcalibre"/>look at this code block:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Serialization process</strong>:<ul class="calibre16"><li class="calibre11">Serialization is the process of converting an object into a format that can be easily stored or transmitted and reconstructed later</li><li class="calibre11"><strong class="source-inline1">BinaryFormatter</strong> is a class provided by the .NET framework for serializing and deserializing objects to and from binary format</li><li class="calibre11"><strong class="source-inline1">BinaryFormatter formatter = new BinaryFormatter();</strong>: This line creates an instance of the <strong class="source-inline1">BinaryFormatter</strong> class, which is used for binary serialization</li><li class="calibre11"><strong class="source-inline1">MemoryStream stream = new MemoryStream();</strong>: This line creates a <strong class="source-inline1">MemoryStream</strong> object, which is used to store binary data in memory</li><li class="calibre11"><strong class="source-inline1">formatter.Serialize(stream, myObject);</strong>: This line serializes the <strong class="source-inline1">myObject</strong> instance into binary format and writes it to <strong class="source-inline1">MemoryStream</strong></li><li class="calibre11"><strong class="source-inline1">byte[] binaryData = stream.ToArray();</strong>: This line converts the binary data written to <strong class="source-inline1">MemoryStream</strong> into a byte array, which can be easily stored or transmitted</li></ul></li>
<li class="calibre11"><strong class="bold">Deserialization process</strong>:<ul class="calibre16"><li class="calibre11">Deserialization<a id="_idIndexMarker388" class="calibre6 pcalibre1 pcalibre"/> is the process of reconstructing an object from its serialized binary representation.</li><li class="calibre11"><strong class="source-inline1">stream = new MemoryStream(binaryData);</strong>: This line creates a new <strong class="source-inline1">MemoryStream</strong> object, initialized with the binary data stored in the <strong class="source-inline1">binaryData</strong> byte array.</li><li class="calibre11"><strong class="source-inline1">(MyClass)formatter.Deserialize(stream);</strong>: This line deserializes the binary data from the <strong class="source-inline1">MemoryStream</strong> back into an object of the <strong class="source-inline1">MyClass</strong> type. The <strong class="source-inline1">Deserialize</strong> method of the <strong class="source-inline1">BinaryFormatter</strong> class is used for this purpose.</li><li class="calibre11">The deserialized object is then assigned to the <strong class="source-inline1">deserializedObject</strong> variable, ready for use in the program.</li></ul></li>
</ul>
<p class="calibre3">In summary, the preceding code block demonstrates how to serialize an object of the <code>MyClass</code> type to binary format and then deserialize the binary data back into an object of the same type using the <code>BinaryFormatter</code> class in C#. This process allows objects to be easily persisted to storage or transmitted over a network in binary format and reconstructed later for use in the application.</p>
<h3 class="calibre9">ScriptableObject serialization</h3>
<p class="calibre3"><strong class="bold">ScriptableObjects</strong> are <a id="_idIndexMarker389" class="calibre6 pcalibre1 pcalibre"/>Unity assets that allow you to store data in a serialized <a id="_idIndexMarker390" class="calibre6 pcalibre1 pcalibre"/>format and create custom editor interfaces for modifying that data in Unity Editor. They are useful for managing configuration settings, defining game parameters, and creating reusable components that can be shared across multiple game objects.</p>
<p class="calibre3"><em class="italic">Example</em>: In the following code blocks, we will explore an example of scriptable object data. Then, we’ll demonstrate how to utilize serialization and deserialization with scriptable objects.</p>
<p class="calibre3">The first code block<a id="_idIndexMarker391" class="calibre6 pcalibre1 pcalibre"/> contains a ScriptableObject that’s designed for game settings, encapsulating essential data relevant to the game’s operation:</p>
<pre class="source-code">
[CreateAssetMenu(fileName = "NewSettings", menuName = "Game Settings")]
public class GameSettings : ScriptableObject {
    public int playerHealth;
    public int enemyCount;
    public float playerSpeed;
}</pre> <p class="calibre3">For the second code block, the <code>SettingsManager</code> class contains a reference to the <code>GameSettings</code> data and includes functions for saving and loading settings:</p>
<pre class="source-code">
public class SettingsManager : MonoBehaviour {
    public GameSettings gameSettings;
    // Serialize the GameSettings ScriptableObject to a file
    public void SaveSettings() {
        string jsonSettings = JsonUtility.ToJson(gameSettings);
        System.IO.File.WriteAllText(Application.persistentDataPath + "/settings.json", jsonSettings);
    }
    // Deserialize the GameSettings ScriptableObject from a file
    public void LoadSettings() {
        if (System.IO.File.Exists(Application.persistentDataPath + "/settings.json")) {
            string jsonSettings = System.IO.File.ReadAllText(Application.persistentDataPath + "/settings.json");
            gameSettings = JsonUtility.FromJson&lt;GameSettings&gt;(jsonSettings);
        }
    }
}</pre> <p class="calibre3">Let’s take a <a id="_idIndexMarker392" class="calibre6 pcalibre1 pcalibre"/>closer look at the <code>SettingsManager</code> class:</p>
<ul class="calibre10">
<li class="calibre11">The <strong class="source-inline1">SaveSettings()</strong> method:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">public void</strong> <strong class="source-inline1">SaveSettings() { ... }</strong>: This method is responsible for saving the game settings to a file</li><li class="calibre11"><strong class="source-inline1">JsonUtility.ToJson(gameSettings)</strong>: This method serializes the <strong class="source-inline1">gameSettings</strong> object to JSON format</li><li class="calibre11"><strong class="source-inline1">System.IO.File.WriteAllText(...)</strong>: This method writes the serialized JSON data to a file named <strong class="source-inline1">settings.json</strong> in the persistent data path of the application</li></ul></li>
<li class="calibre11">The <strong class="source-inline1">LoadSettings()</strong> method:<ul class="calibre16"><li class="calibre11"><strong class="source-inline1">public void LoadSettings() { ... }</strong>: This method is responsible for loading the game settings from a file</li><li class="calibre11"><strong class="source-inline1">System.IO.File.Exists(...)</strong>: This method checks if the <strong class="source-inline1">settings.json</strong> file exists in the persistent data path</li><li class="calibre11"><strong class="source-inline1">System.IO.File.ReadAllText(...)</strong>: This method reads the JSON data from the <strong class="source-inline1">settings.json</strong> file</li><li class="calibre11"><strong class="source-inline1">JsonUtility.FromJson&lt;GameSettings&gt;(jsonSettings)</strong>: This method deserializes the JSON data back into a <strong class="source-inline1">GameSettings</strong> object and assigns it to the <strong class="source-inline1">gameSettings</strong> variable</li></ul></li>
</ul>
<p class="calibre3">Overall, the <code>SettingsManager</code> class provides functionality to save and load game settings using JSON serialization <a id="_idIndexMarker393" class="calibre6 pcalibre1 pcalibre"/>and deserialization. It demonstrates basic file I/O operations in Unity for handling persistent data.</p>
<p class="calibre3">Regarding ScriptableObjects, we have the flexibility to save them using XML or binary formats, and we can treat them as custom classes that encapsulate specific data.</p>
<p class="calibre3">To summarize, choosing the appropriate serialization and deserialization options in Unity depends on factors such as data interchange requirements, performance considerations, and integration with external systems. Understanding the strengths and limitations of each option allows developers to make informed decisions and implement efficient data management solutions in their Unity projects.</p>
<p class="calibre3">Having understood the importance of data organization, let’s consider the role save and load systems can play in a game’s management.</p>
<h1 id="_idParaDest-101" class="calibre5"><a id="_idTextAnchor105" class="calibre6 pcalibre1 pcalibre"/>Creating save and load systems using C#</h1>
<p class="calibre3">Save and load systems <a id="_idIndexMarker394" class="calibre6 pcalibre1 pcalibre"/>play a pivotal role in managing game progress and ensuring seamless player experiences. In this section, we’ll delve into various methods, from basic <strong class="bold">PlayerPrefs</strong> to <a id="_idIndexMarker395" class="calibre6 pcalibre1 pcalibre"/>more robust file-based save systems, enabling us, as developers, to preserve and retrieve player data within Unity efficiently.</p>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor106" class="calibre6 pcalibre1 pcalibre"/>PlayerPrefs</h2>
<p class="calibre3">PlayerPrefs <a id="_idIndexMarker396" class="calibre6 pcalibre1 pcalibre"/>in Unity serve as a straightforward solution for storing key-value pairs, which is crucial for preserving simple game data. Understanding PlayerPrefs is fundamental for efficiently managing basic player preferences and progress within Unity projects. Operating as a key-value store, PlayerPrefs is specifically designed for storing player preferences and small data amounts between game sessions. Its simple interface facilitates setting and retrieving data, making it ideal for managing settings, user preferences, and basic game progress.</p>
<h3 class="calibre9">Usage tips</h3>
<p class="calibre3">Let’s explore <a id="_idIndexMarker397" class="calibre6 pcalibre1 pcalibre"/>essential usage tips for maximizing the benefits of PlayerPrefs in Unity game development, including insights into data serialization, encryption, and security measures, as well as performance optimization techniques:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Data serialization</strong>: While PlayerPrefs natively supports storing basic data types, such as integers, floats, and strings, more complex data structures require serialization. We can serialize custom data structures into a format that’s compatible with PlayerPrefs, enabling us to store and retrieve complex game data.</li>
<li class="calibre11"><strong class="bold">Encryption and security</strong>: You can protect sensitive player data by implementing encryption mechanisms before storing them in PlayerPrefs. By encrypting PlayerPrefs data, we can safeguard against unauthorized access and protect player privacy.</li>
<li class="calibre11"><strong class="bold">Optimizing performance</strong>: PlayerPrefs access involves disk I/O operations, which can impact performance, especially in resource-intensive games. To mitigate performance overhead, batch PlayerPrefs operations where possible and minimize frequent read/write operations during gameplay.</li>
</ul>
<p class="calibre3">Incorporating these usage tips will help us optimize PlayerPrefs usage, ensuring data security, performance efficiency, and effective handling of complex game data in Unity projects.</p>
<p class="calibre3">Now, let’s look at an example demonstrating how to utilize PlayerPrefs for saving and loading data.</p>
<p class="calibre3">In this first code block, the <code>GameData</code> class is a custom class containing game data fields that must be saved and loaded:</p>
<pre class="source-code">
// Define a class for game data serialization
[System.Serializable]
public class GameData {
    public int playerLevel;
    public int playerExperience;
    // Additional game data fields...
}</pre> <p class="calibre3">The second code block<a id="_idIndexMarker398" class="calibre6 pcalibre1 pcalibre"/> contains the save and load functions, which use PlayerPrefs with the <code>GameData</code> class:</p>
<pre class="source-code">
// Save game data to PlayerPrefs
public void SaveGame() {
    GameData gameData = new GameData();
    // Populate game data with current game state
    gameData.playerLevel = PlayerController.instance.level;
    gameData.playerExperience = PlayerController.instance.experience;
    // Serialize game data to JSON
    string jsonData = JsonUtility.ToJson(gameData);
    // Save serialized data to PlayerPrefs
    PlayerPrefs.SetString("GameData", jsonData);
    PlayerPrefs.Save();
}
// Load game data from PlayerPrefs
public void LoadGame() {
    if (PlayerPrefs.HasKey("GameData")) {
        // Retrieve serialized data from PlayerPrefs
        string jsonData = PlayerPrefs.GetString("GameData");
        // Deserialize JSON data to game data object
        GameData gameData = JsonUtility.FromJson&lt;GameData&gt;(jsonData);
        // Apply loaded game data to game state
        PlayerController.instance.level = gameData.playerLevel;
        PlayerController.instance.experience = gameData.playerExperience;
    }
}</pre> <p class="calibre3">Let’s take a<a id="_idIndexMarker399" class="calibre6 pcalibre1 pcalibre"/> closer look at the saving and loading functions:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">SaveGame()</strong>:<ul class="calibre16"><li class="calibre11">This function is responsible for saving the game data.</li><li class="calibre11">It initializes a new instance of the <strong class="source-inline1">GameData</strong> class, which likely contains fields representing various aspects of the game state.</li><li class="calibre11">The current game state is then captured and stored in the <strong class="source-inline1">GameData</strong> instance. In this example, it appears to be capturing the player’s level and experience from a <strong class="source-inline1">PlayerController</strong> singleton instance.</li><li class="calibre11">Next, the game data is serialized to JSON format using <strong class="source-inline1">JsonUtility.ToJson()</strong>.</li><li class="calibre11">Finally, the serialized JSON data is stored in <strong class="source-inline1">PlayerPrefs</strong> using <strong class="source-inline1">PlayerPrefs.SetString()</strong> with the <strong class="source-inline1">GameData</strong> key, and <strong class="source-inline1">PlayerPrefs.Save()</strong> is called to persist the changes.</li></ul></li>
<li class="calibre11"><strong class="source-inline1">LoadGame()</strong>:<ul class="calibre16"><li class="calibre11">This<a id="_idIndexMarker400" class="calibre6 pcalibre1 pcalibre"/> function loads the saved game data.</li><li class="calibre11">First, it checks if existing game data is stored in <strong class="source-inline1">PlayerPrefs</strong> by using the <strong class="source-inline1">GameData</strong> key alongside <strong class="source-inline1">PlayerPrefs.HasKey()</strong>.</li><li class="calibre11">If there is saved data, it retrieves the serialized JSON string from <strong class="source-inline1">PlayerPrefs</strong> using <strong class="source-inline1">PlayerPrefs.GetString("GameData")</strong>.</li><li class="calibre11">The JSON data is then deserialized back into a <strong class="source-inline1">GameData</strong> object using <strong class="source-inline1">JsonUtility.FromJson&lt;GameData&gt;()</strong>.</li><li class="calibre11">Finally, the loaded game data is applied to the game state. In this example, it seems to be setting the player’s level and experience back to their saved values.</li></ul></li>
</ul>
<p class="calibre3">Overall, these functions provide a simple mechanism for saving and loading game data using PlayerPrefs, allowing for basic persistence of game state between sessions.</p>
<p class="calibre3">Now that we’ve discussed the significant benefits of PlayerPrefs, let’s examine situations where it may not be the optimal choice.</p>
<h3 class="calibre9">Exploring the limitations and alternatives to PlayerPrefs</h3>
<p class="calibre3">While <a id="_idIndexMarker401" class="calibre6 pcalibre1 pcalibre"/>PlayerPrefs offers convenience and simplicity for storing small amounts of data in Unity games, it also has several limitations and disadvantages that may prompt us to explore alternative solutions:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Limited storage capacity</strong>: PlayerPrefs has a limited storage capacity, making it unsuitable for storing large amounts of data or complex data structures. Attempting to store excessive data in PlayerPrefs can lead to performance issues and memory constraints.</li>
<li class="calibre11"><strong class="bold">Security concerns</strong>: PlayerPrefs data is stored in plain text in the player’s registry (on Windows) or a <strong class="bold">plist</strong> file (on macOS and iOS), making it susceptible to tampering and unauthorized access. For applications that require enhanced security measures or compliance with data protection regulations, PlayerPrefs may not provide adequate protection for sensitive data.</li>
<li class="calibre11"><strong class="bold">Platform dependencies</strong>: PlayerPrefs storage locations and behavior may vary across<a id="_idIndexMarker402" class="calibre6 pcalibre1 pcalibre"/> different platforms and devices. This platform dependency can introduce inconsistencies and compatibility issues when deploying games to multiple platforms, requiring developers to implement platform-specific handling or alternative storage solutions.</li>
<li class="calibre11"><strong class="bold">Limited data types</strong>: PlayerPrefs supports a limited set of data types, including integers, floats, and strings. Complex data structures, arrays, or custom objects cannot be directly stored in PlayerPrefs without serialization and conversion, leading to additional complexity and potential performance overhead.</li>
<li class="calibre11"><strong class="bold">Persistence challenges</strong>: PlayerPrefs data is persisted across game sessions, but it may not persist across different devices or installations. Uninstalling or reinstalling the game, clearing application data, or switching devices can result in the loss of PlayerPrefs data, affecting player progress and preferences.</li>
<li class="calibre11"><strong class="bold">Performance overhead</strong>: Accessing PlayerPrefs involves disk I/O operations, which can introduce performance overhead, especially when reading or writing large amounts of data frequently. For applications that require high-performance data storage or real-time data access, PlayerPrefs may not meet performance requirements.</li>
</ul>
<p class="calibre3">Due to these limitations and considerations, we may opt for alternative data storage solutions, such as binary serialization, JSON serialization, database systems, or cloud-based storage services. These solutions offer greater flexibility, scalability, security, and performance for managing game data, especially in scenarios involving large datasets, complex data structures, or stringent security requirements. While PlayerPrefs remains a convenient option for simple data storage needs, we should carefully evaluate our requirements and consider alternative solutions when designing data management systems for Unity games.</p>
<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor107" class="calibre6 pcalibre1 pcalibre"/>Custom Save System</h2>
<p class="calibre3">In the <a id="_idIndexMarker403" class="calibre6 pcalibre1 pcalibre"/>constantly changing world of game creation, the need for strong and flexible save systems becomes more and more clear. Enter the Custom Save System – a smart solution that’s designed to handle the complexities of data management with skill and effectiveness. Unlike usual methods, such as PlayerPrefs, the <strong class="bold">Custom Save System</strong> gives us a versatile set of tools, including encryption, options for saving to the cloud, and smooth integration with scriptable objects.</p>
<h3 class="calibre9">Custom Save System features</h3>
<p class="calibre3">Let’s explore <a id="_idIndexMarker404" class="calibre6 pcalibre1 pcalibre"/>what features we can use in our custom save system:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Generic functionality</strong>: The custom save system boasts generic functions for saving and loading data, allowing for seamless integration with various scriptable objects. With dynamic parameters and return values tailored to the specific needs of each data type, it ensures adaptability and versatility in data management.</li>
<li class="calibre11"><strong class="bold">Encryption and decryption</strong>: Security is paramount in the world of game development. Leveraging encryption and decryption mechanisms, the Custom Save System ensures the confidentiality and integrity of sensitive player data. Through robust cryptographic algorithms, it guards against unauthorized access and tampering, fostering player trust and confidence.</li>
</ul>
<p class="calibre3">We’ll kick things off by crafting ScriptableObjects to manage the system’s data. I’ll draft the <code>PlayerData</code> script, which will store essential player information, as demonstrated in the subsequent code block:</p>
<pre class="source-code">
  [CreateAssetMenu(fileName = "PlayerData", menuName = "Data/Player Data")]
  public class PlayerData : ScriptableObject
  {
      public string playerName;
      public int playerLevel;
      public float playerExperience;
  }</pre> <p class="calibre3">Additionally, I’ll craft a <a id="_idIndexMarker405" class="calibre6 pcalibre1 pcalibre"/>script for <code>GameSettings</code>, which will store relevant game data, as exemplified in the subsequent code block:</p>
<pre class="source-code">
    [CreateAssetMenu(fileName = "GameSettings", menuName = "Data/Game Settings")]
    public class GameSettings : ScriptableObject
    {
        public int soundVolume;
        public bool isFullScreen;
        public int graphicsQuality;
    }</pre> <p class="calibre3">After creating these scripts, you can right-click, select <code>Data</code> and placing the instances inside it. Once you’ve done this, they’ll be structured similarly to the settings instance shown in <em class="italic">Figure 6</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 6.1 – Game Settings ScriptableObject instance" src="img/B22017_06_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Game Settings ScriptableObject instance</p>
<p class="calibre3">These <a id="_idIndexMarker406" class="calibre6 pcalibre1 pcalibre"/>data files have been provided for demonstration purposes only, allowing you to adjust them according to your project requirements.</p>
<p class="calibre3">Next, we’ll proceed by creating a save manager script. However, before diving into that, we must<a id="_idIndexMarker407" class="calibre6 pcalibre1 pcalibre"/> integrate <code>2022.3.13</code>. Follow these steps:</p>
<ol class="calibre15">
<li class="calibre11">Navigate to the top bar and open the <strong class="bold">Window</strong> menu, then select <strong class="bold">Package Manager</strong>. Click on the <strong class="bold">Add</strong> button located in the top-left corner. This action will prompt a menu to appear, as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</li>
</ol>
<div><div><img alt="Figure 6.2 – Adding the package from the git URL in the Package Manager panel" src="img/B22017_06_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Adding the package from the git URL in the Package Manager panel</p>
<ol class="calibre15">
<li value="2" class="calibre11">Paste <a href="https://com.unity.nuget.newtonsoft-json" class="calibre6 pcalibre1 pcalibre">com.unity.nuget.newtonsoft-json</a> into the provided panel, then click <strong class="bold">Add</strong>, as <a id="_idIndexMarker408" class="calibre6 pcalibre1 pcalibre"/>depicted in <em class="italic">Figure 6</em><em class="italic">.3</em>:</li>
</ol>
<div><div><img alt="Figure 6.3 – Adding the link for the git URL in the Package Manager panel" src="img/B22017_06_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Adding the link for the git URL in the Package Manager panel</p>
<p class="calibre3">Wait for the installation<a id="_idIndexMarker409" class="calibre6 pcalibre1 pcalibre"/> to finish and for Unity Editor to compile before creating the <code>SaveManager</code> script.</p>
<h3 class="calibre9">The SaveManager script</h3>
<p class="calibre3">This<a id="_idIndexMarker410" class="calibre6 pcalibre1 pcalibre"/> script is the <a id="_idIndexMarker411" class="calibre6 pcalibre1 pcalibre"/>fundamental component that’s responsible for saving and loading data in our game. As mentioned earlier, this approach is not standard, but rather one method we’ll utilize for our game. Feel free to adopt this method or implement your own approach according to your needs. The following code block contains the <code>SaveManager</code> script:</p>
<pre class="source-code">
    public class SaveManager : MonoBehaviour
    {
        private const string saveFileName = "saveData1.dat";
        private const string cloudSaveFileName = "cloudSaveData.dat";
        private static byte[] key = Convert.FromBase64String("kwAXmhR48HenPp04YXrKSNfRcFSiaQx35BlHnI7kzK0=");
        private static byte[] iv = Convert.FromBase64String("GcVb7iqWex9uza+Fcb3BCQ==");
        public static void SaveData(string key, string data)
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            // Load existing data
            Dictionary&lt;string, string&gt; savedData = LoadSavedData();
            // Add or update data based on its key
            savedData[key] = data;
            // Serialize the entire dictionary
            string jsonData = JsonConvert.SerializeObject(savedData);
            byte[] encryptedData = EncryptData(jsonData);
            // Write the serialized data to the file
            using (FileStream fileStream = new FileStream(filePath, FileMode.Create))
            {
                fileStream.Write(encryptedData, 0, encryptedData.Length);
            }
        }
        public static string LoadData(string key)
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            // Load existing data
            Dictionary&lt;string, string&gt; savedData = LoadSavedData();
            // Extract data based on its key
            if (savedData.ContainsKey(key))
            {
                return savedData[key];
            }
            else
            {
                Debug.LogWarning("No save data found for key: " + key);
                return null;
            }
        }</pre> <p class="calibre3">Let’s<a id="_idIndexMarker412" class="calibre6 pcalibre1 pcalibre"/> take a closer look at the save and load methods that will be used from other scripts:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">SaveData</strong>:<ul class="calibre16"><li class="calibre11">Saves a key-value pair to a file</li><li class="calibre11">Loads existing data, updates or adds new data based on the key, and serializes the dictionary to JSON</li><li class="calibre11">Encrypts the JSON data and writes it to the file</li></ul></li>
<li class="calibre11"><strong class="source-inline1">LoadData</strong>:<ul class="calibre16"><li class="calibre11">Loads data from the save file based on the provided key</li><li class="calibre11">Checks if the key exists in the dictionary and returns the corresponding value</li><li class="calibre11">Logs a warning and returns <strong class="source-inline1">null</strong> if the key doesn’t exist</li></ul></li>
</ul>
<p class="calibre3">The following code block contains static methods that handle input/output operations to load and save game data:</p>
<pre class="source-code">
        private static Dictionary&lt;string, string&gt; LoadSavedData()
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            if (File.Exists(filePath))
            {
                byte[] encryptedData = File.ReadAllBytes(filePath);
                string jsonData = DecryptData(encryptedData);
                return JsonConvert.DeserializeObject&lt;Dictionary&lt;string, string&gt;&gt;(jsonData);
            }
            else
            {
                Debug.LogWarning("No save data found.");
                return new Dictionary&lt;string, string&gt;();
            }
        }
        public static void DeleteSaveData()
        {
            string filePath = Path.Combine(Application.persistentDataPath, saveFileName);
            if (File.Exists(filePath))
            {
                File.Delete(filePath);
                Debug.Log("Save data deleted.");
            }
            else
            {
                Debug.LogWarning("No save data found to delete.");
            }
        }</pre> <p class="calibre3">Let’s take a<a id="_idIndexMarker413" class="calibre6 pcalibre1 pcalibre"/> closer look at the previous code block:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">LoadSavedData</strong>:<ul class="calibre16"><li class="calibre11">Loads saved data from the file and returns it as a dictionary</li><li class="calibre11">Reads encrypted data, decrypts it, deserializes JSON into a dictionary, and returns it</li></ul></li>
<li class="calibre11"><strong class="source-inline1">DeleteSaveData</strong>: Deletes the save data file if it exists</li>
</ul>
<p class="calibre3">In the following code block, we’re dealing with encryption and decryption to secure the data:</p>
<pre class="source-code">
        private static byte[] EncryptData(string data)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);
                using (MemoryStream msEncrypt = new MemoryStream())
                {
                    using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                        {
                            swEncrypt.Write(data);
                        }
                        return msEncrypt.ToArray();
                    }
                }
            }
        }
        private static string DecryptData(byte[] encryptedData)
        {
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = key;
                aesAlg.IV = iv;
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
                using (MemoryStream msDecrypt = new MemoryStream(encryptedData))
                {
                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                        {
                            return srDecrypt.ReadToEnd();
                        }
                    }
                }
            }
        }
    }</pre> <p class="calibre3">Let’s consider <a id="_idIndexMarker414" class="calibre6 pcalibre1 pcalibre"/>the encryption methods (<code>EncryptData</code> and <code>DecryptData</code>):</p>
<ul class="calibre10">
<li class="calibre11">Encrypts and decrypts data using the <strong class="source-inline1">AES</strong> encryption algorithm</li>
<li class="calibre11">Encrypts input data using the encryption key and <strong class="source-inline1">IV</strong> (<strong class="source-inline1">EncryptData</strong>)</li>
<li class="calibre11">Decrypts encrypted data using the same key and <strong class="source-inline1">IV</strong> (<strong class="source-inline1">DecryptData</strong>)</li>
</ul>
<p class="calibre3">In this script, there’s a method called <code>SaveData</code> for saving data. It requires the data to be in string format, along with its corresponding key. We have opted to store the data in a dictionary of string and string, enabling us to easily manage loading and saving data for various files.</p>
<p class="calibre3">For loading, we’re decrypting the string data and then loading it.</p>
<p class="calibre3">Additionally, I’ve implemented <strong class="bold">AES encryption</strong> methods to secure the data during encryption and <a id="_idIndexMarker415" class="calibre6 pcalibre1 pcalibre"/>decryption processes. While the details of AES encryption are beyond the scope of this book, you’re encouraged to explore it further if you’re interested in learning about encryption techniques.</p>
<p class="calibre3">To facilitate<a id="_idIndexMarker416" class="calibre6 pcalibre1 pcalibre"/> the generation of keys and IV, I’ve prepared a helper script. You can utilize this script by attaching it to a GameObject within your scene. This script will enable you to create the necessary key and IV for encryption purposes. You can find the generated keys in the <code>SaveManager</code> script; there’s no need to repeat the creation process as it only occurs once.</p>
<p class="calibre3">You can obtain the <code>KeyAndIVGenerator</code> script from the following code block:</p>
<pre class="source-code">
public class KeyAndIVGenerator : MonoBehaviour
{
    public static void GenerateKeyAndIV()
    {
        using (Aes aes = Aes.Create())
        {
            aes.GenerateKey();
            aes.GenerateIV();
            // Convert key and IV to base64 strings for easy storage and usage
            string base64Key = Convert.ToBase64String(aes.Key);
            string base64IV = Convert.ToBase64String(aes.IV);
            Debug.Log("Generated Key: " + base64Key);
            Debug.Log("Generated IV: " + base64IV);
        }
    }
    private void Start()
    {
        GenerateKeyAndIV();
    }
}</pre> <p class="calibre3">Here’s an<a id="_idIndexMarker417" class="calibre6 pcalibre1 pcalibre"/> explanation of the <code>KeyAndIVGenerator</code> class:</p>
<ul class="calibre10">
<li class="calibre11">The <strong class="source-inline1">KeyAndIVGenerator</strong> class contains a method named <strong class="source-inline1">GenerateKeyAndIV</strong>, which is responsible <a id="_idIndexMarker418" class="calibre6 pcalibre1 pcalibre"/>for generating encryption keys and <strong class="bold">initialization </strong><strong class="bold">vectors</strong> (<strong class="bold">IVs</strong>).</li>
<li class="calibre11">Inside the <strong class="source-inline1">GenerateKeyAndIV</strong> method, the <strong class="source-inline1">KeyAndIVGenerator</strong> class creates an instance of the <strong class="source-inline1">Aes</strong> class using the <strong class="source-inline1">Aes.Create()</strong> method, which represents the AES algorithm.</li>
<li class="calibre11">Then, it calls the <strong class="source-inline1">GenerateKey()</strong> and <strong class="source-inline1">GenerateIV()</strong> methods on the <strong class="source-inline1">Aes</strong> instance to generate a random encryption key and <strong class="source-inline1">IV</strong>.</li>
<li class="calibre11">After generating the key and <strong class="source-inline1">IV</strong>, it converts them into base64 strings using the <strong class="source-inline1">Convert.ToBase64String()</strong> method. <strong class="source-inline1">Base64</strong> encoding is used for easy storage and usage of the key and <strong class="source-inline1">IV</strong>.</li>
<li class="calibre11">Finally, it logs the generated key and <strong class="source-inline1">IV</strong> to the console using <strong class="source-inline1">Debug.Log()</strong> for debugging purposes.</li>
<li class="calibre11">The <strong class="source-inline1">Start</strong> method is called when the <strong class="source-inline1">KeyAndIVGenerator</strong> object is initialized, and it invokes the <strong class="source-inline1">GenerateKeyAndIV</strong> method to generate the key and <strong class="source-inline1">IV</strong> when the object starts.</li>
</ul>
<p class="calibre3">Overall, this code block demonstrates how to generate encryption keys and <code>IV</code> values using the AES algorithm and convert them into <code>base64</code> strings for storage and usage. This is commonly used in cryptography for securing data.</p>
<p class="calibre3">The following code block provides an example of the <code>GameManager</code> script, which utilizes the<a id="_idIndexMarker419" class="calibre6 pcalibre1 pcalibre"/> save and load methods from <code>SaveManager</code> to manage the process of saving and loading <code>PlayerData</code> and <code>GameSettings</code>:</p>
<pre class="source-code">
    public class GameManager : MonoBehaviour
    {
        public PlayerData playerData;
        public GameSettings gameSettings;
        private void Start()
        {
            LoadGameData();
        }
        private void OnApplicationQuit()
        {
            SaveGameData();
         }</pre> <p class="calibre3">Let’s consider the Unity callback functions:</p>
<ul class="calibre10">
<li class="calibre11">In the <strong class="source-inline1">Start</strong> method, it calls the <strong class="source-inline1">LoadGameData</strong> function to load the player data and game settings when the game starts</li>
<li class="calibre11">The <strong class="source-inline1">OnApplicationQuit</strong> method is invoked when the application is about to quit, and it calls the <strong class="source-inline1">SaveGameData</strong> function to save the player data and game settings before exiting</li>
</ul>
<p class="calibre3">The following code block contains the logic for loading and saving data:</p>
<pre class="source-code">
        private void LoadGameData()
        {
            if (playerData == null)
            {
            }
            else
            {
                JsonUtility.FromJsonOverwrite(SaveManager.LoadData("playerData"), playerData);
            }
            if (gameSettings == null)
            {
                gameSettings = ScriptableObject.CreateInstance&lt;GameSettings&gt;();
            }
            else
            {  JsonUtility.FromJsonOverwrite(SaveManager.LoadData("gameSettings"), gameSettings);
            }
        }
        private void SaveGameData()
        {
            SaveManager.SaveData("playerData", JsonUtility.ToJson(playerData));
            SaveManager.SaveData("gameSettings", JsonUtility.ToJson(gameSettings));
        }
    }</pre> <p class="calibre3">Let’s take a closer look at the saving and loading functions:</p>
<ul class="calibre10">
<li class="calibre11">The <strong class="source-inline1">LoadGameData</strong> function loads the player data and game settings from the save files using the <strong class="source-inline1">SaveManager.LoadData</strong> method. If the data is not found, it creates new instances of <strong class="source-inline1">PlayerData</strong> and <strong class="source-inline1">GameSettings</strong>.</li>
<li class="calibre11">The <strong class="source-inline1">SaveGameData</strong> function saves the player data and game settings to the save files using the <strong class="source-inline1">SaveManager.SaveData</strong> method. It converts the data objects into JSON format using <strong class="source-inline1">JsonUtility.ToJson</strong> before saving.</li>
</ul>
<p class="calibre3">Overall, this<a id="_idIndexMarker420" class="calibre6 pcalibre1 pcalibre"/> code block demonstrates a basic implementation of loading and saving game data using JSON serialization. It ensures that the player data and game settings are persisted across game sessions, allowing for a seamless gaming experience.</p>
<p class="calibre3">In this section, we learned how to save and load scriptable objects, the techniques of saving and loading to a file, encrypting using AES to protect the data, and how to generate encryption keys. Finally, we’ve practiced using these concepts practically.</p>
<p class="calibre3">Now, we need to understand the benefits of using a custom approach over PlayerPrefs.</p>
<h3 class="calibre9">Advantages over PlayerPrefs</h3>
<p class="calibre3">While <a id="_idIndexMarker421" class="calibre6 pcalibre1 pcalibre"/>PlayerPrefs offers simplicity, the Custom Save System goes beyond its limitations, providing a variety of features and functionalities unmatched by traditional storage methods. By reducing performance overhead and improving data security, it marks a new era of data management in Unity game development.</p>
<p class="calibre3">To summarize, the Custom Save System represents innovation and creativity – a testament to the ongoing pursuit of excellence in game development. With its capacity to streamline data management, enhance security measures, and improve player experiences, it has become the cornerstone of modern game development practices, reshaping the landscape with each save.</p>
<p class="calibre3">In the next section, we are going to implement ScriptableObjects with the player progress part of our game while saving and loading data.</p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor108" class="calibre6 pcalibre1 pcalibre"/>Data-driven gameplay with C#</h1>
<p class="calibre3"><strong class="bold">Data-driven design</strong> is an approach to game development where game behavior, content, and<a id="_idIndexMarker422" class="calibre6 pcalibre1 pcalibre"/> configuration are defined and controlled by external data files rather than hardcoded into the game’s source code. This approach offers several benefits, including increased flexibility, easier content iteration, and enhanced maintainability. By separating game data from code, we can modify game behavior, tweak parameters, and add new content without requiring code changes, thus accelerating iteration cycles and empowering designers to experiment with gameplay mechanics.</p>
<p class="calibre3">Let’s begin with one of the uses of ScriptableObjects for managing data.</p>
<h2 id="_idParaDest-105" class="calibre7"><a id="_idTextAnchor109" class="calibre6 pcalibre1 pcalibre"/>Creating data for stats</h2>
<p class="calibre3">We have<a id="_idIndexMarker423" class="calibre6 pcalibre1 pcalibre"/> the <code>PlayerMovement</code> script in our project, as shown in the following code block, which handles the player’s movement:</p>
<pre class="source-code">
   public class PlayerMovement : MonoBehaviour
   {
       public float moveSpeed = 5f;
       public float jumpForce = 5f;
       public float dashForce = 10f;
       public float dashCooldown = 2f;
       public Transform groundChecker;
       public LayerMask groundLayer;
       public float groundDistance;
       public Rigidbody playerRigidbody;
       private bool isGrounded = true;
       private bool canDash = true;
       private Vector3 movementVector;
  private void MovePlayer()
  {
      Vector3 movement = new Vector3(movementVector.x , 0f , movementVector.y) * moveSpeed * Time.deltaTime;
      transform.Translate(movement);
  }
//rest of code
}</pre> <p class="calibre3">Here, we <a id="_idIndexMarker424" class="calibre6 pcalibre1 pcalibre"/>can create a ScriptableObject that will contain the parameters of player movement, such as speed and force. Then, we can obtain a reference to that ScriptableObject.</p>
<p class="calibre3">The following code block contains a ScriptableObject named <code>PlayerStats</code> that will store movement data:</p>
<pre class="source-code">
[CreateAssetMenu(fileName = "PlayerStats", menuName = "Data/Player Stats")]
 public class PlayerStats : ScriptableObject
 {
     [SerializeField] float moveSpeed = 5f;
     [SerializeField] float jumpForce = 5f;
     [SerializeField] float dashForce = 10f;
     [SerializeField] float dashCooldown = 2f;
     public float MoveSpeed { get =&gt; moveSpeed; set =&gt; moveSpeed = value; }
     public float JumpForce { get =&gt; jumpForce; set =&gt; jumpForce = value; }
     public float DashForce { get =&gt; dashForce; set =&gt; dashForce = value; }
     public float DashCooldown { get =&gt; dashCooldown; set =&gt; dashCooldown = value; }
 }</pre> <p class="calibre3">Now, we can <a id="_idIndexMarker425" class="calibre6 pcalibre1 pcalibre"/>utilize the <code>PlayerStats</code> ScriptableObject as a variable within the player movement script and substitute any previous logic that used the movement variables with the player stats accordingly:</p>
<pre class="source-code">
  public class PlayerMovement : MonoBehaviour
  {
      public PlayerStats playerStats;
      public Transform groundChecker;
      public LayerMask groundLayer;
      public float groundDistance;
      public Rigidbody playerRigidbody;
      private bool isGrounded = true;
      private bool canDash = true;
      private Vector3 movementVector;
      private void MovePlayer()
      {
        Vector3 movement = new Vector3(movementVector.x , 0f , movementVector.y) * playerStats.MoveSpeed * Time.deltaTime;
        transform.Translate(movement);
      }
  //rest of code
  }</pre> <p class="calibre3">We did this <a id="_idIndexMarker426" class="calibre6 pcalibre1 pcalibre"/>because we require a single reference for all movement parameters, and it will be convenient later to apply or adjust the stats from other scripts, such as special power-ups, without altering the code within the player movement script. We can directly modify the ScriptableObject, and it will impact the player’s movement.</p>
<p class="calibre3">Moreover, if we include items in our game, consolidating all data into individual ScriptableObjects for each type of item would streamline usage and modifications across all objects. Without directly referencing those objects, we can alter the data file, and it will impact all objects utilizing that data.</p>
<p class="calibre3">Let’s consider another use for ScriptableObjects.</p>
<h2 id="_idParaDest-106" class="calibre7"><a id="_idTextAnchor110" class="calibre6 pcalibre1 pcalibre"/>Challenge system</h2>
<p class="calibre3">We can <a id="_idIndexMarker427" class="calibre6 pcalibre1 pcalibre"/>utilize ScriptableObjects for player progression within challenges, allowing us to effectively track challenges and save the progress made.</p>
<p class="calibre3">We will commence by migrating <code>CommonChallengeData</code> into a ScriptableObject, as demonstrated in the following code block:</p>
<pre class="source-code">
    [CreateAssetMenu(fileName = "CommonChallengeData", menuName = "Data/Common Challenge Data")]
    [Serializable]
    public class CommonChallengeData : ScriptableObject
    {
        public bool isCompleted;
        public RewardType rewardType; // Type of reward
        public int rewardAmount;      // Amount or value of the reward
    }</pre> <p class="calibre3">Then, upon <a id="_idIndexMarker428" class="calibre6 pcalibre1 pcalibre"/>completion of the challenge, we can utilize the save manager we previously established to store the challenge statistics. This can be seen in the <code>CompleteChallenge</code> function within <code>EnemyWavesChallenge</code> in the following code block:</p>
<pre class="source-code">
    public class EnemyWavesChallenge : BaseChallenge
    {
        //Rest of Code
        public override void CompleteChallenge()
        {
            if (!commonData.isCompleted)
            {
                RewardManager.Instance.GrantReward(commonData);
                commonData.isCompleted = true;
                SaveManager.SaveData(challengeSavedKey, JsonUtility.ToJson(commonData));
            }
            else
            {
                Debug.Log("Challenge already completed!");
            }
        }
        //Rest of code
    }</pre> <p class="calibre3">We included <a id="_idIndexMarker429" class="calibre6 pcalibre1 pcalibre"/>the last line in the <code>CompleteChallenge</code> method to save the challenge data within the completion function of the challenge. Thus, before commencing the challenge, we will verify its completion status in the challenge manager.</p>
<p class="calibre3">Additionally, we must utilize the data loading functionality from the <code>SaveManager</code> script within the <code>StartChallenge</code> function inside <code>ChallengeManager</code>, as illustrated in the following code block:</p>
<pre class="source-code">
    public class ChallengeManager : Singlton&lt;ChallengeManager&gt;
    {
        //Rest of code
        public void StartChallenge(ChallengeType challengeType)
        {
            if (challengeDictionary.TryGetValue(challengeType, out BaseChallenge challengeScript))
            {
                JsonUtility.FromJsonOverwrite(SaveManager.LoadData(challengeScript.challengeSavedKey), challengeScript.commonData);
                if (!challengeScript.commonData.isCompleted)
                {
                    SetCurrentChallenge(challengeScript);
                    currentChallenge.StartChallenge();
                }
                else
                {
                    Debug.Log("Challenge already completed!");
                }
            }
            else
            {
                Debug.LogError($"No challenge script found for ChallengeType {challengeType}");
            }
        }
//Rest of code
    }</pre> <p class="calibre3">This is a <a id="_idIndexMarker430" class="calibre6 pcalibre1 pcalibre"/>straightforward method to transition existing code for utilizing ScriptableObjects or an improved data management approach. Furthermore, it integrates saving and loading functionalities to monitor challenge progress. While designing the system from scratch would offer a better data handling strategy, this system was constructed differently. We had the opportunity to modify it in this chapter, emphasizing the importance of adapting existing code bases. We’ll delve deeper into refining these skills in <a href="B22017_07.xhtml#_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a>.</p>
<p class="calibre3">To summarize, data-driven gameplay<a id="_idIndexMarker431" class="calibre6 pcalibre1 pcalibre"/> with C# offers a powerful framework for creating dynamic, customizable, and immersive gaming experiences. By embracing data-driven design principles, and leveraging ScriptableObjects for modular gameplay elements, we can build flexible, extensible, and engaging games that captivate players and stand the test of time.</p>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor111" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we delved into concepts and techniques that are vital for efficient game development. We began by exploring the importance of data structures and their impact on game performance, emphasizing the significance of choosing the appropriate data structure for optimal results. Serialization in Unity took center stage as we navigated Unity’s serialization options, including XML, JSON, and binary serialization methods. We discussed the nuances of each serialization method and its suitability for different scenarios, laying the groundwork for robust data management in Unity projects.</p>
<p class="calibre3">We continued by doing a deep dive into PlayerPrefs and its limitations in Unity game development, paving the way for the Custom Save System. Through detailed discussions and practical examples, we unveiled the features and advantages of the Custom Save System over PlayerPrefs, highlighting its role in elevating data-driven gameplay experiences. The <code>SaveManager</code> Script emerged as a pivotal component, facilitating seamless data saving and loading operations with enhanced efficiency and flexibility. By leveraging C# and scriptableObjects, we are empowered to embrace data-driven gameplay mechanics and optimize the challenge system for enhanced user engagement and progression. Through meticulous exploration and hands-on learning, this chapter has equipped us with the knowledge and tools needed to master data organization and serialization in Unity with C#.</p>
<p class="calibre3">In <a href="B22017_07.xhtml#_idTextAnchor112" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a>, we’ll dive into the realm of collaborative game development and version control systems. Building on our foundational knowledge, we’ll explore how to effectively contribute to existing code bases and collaborate within development teams using C#. From understanding version control systems to mastering code merging and conflict resolution techniques, we’ll equip ourselves with essential skills to navigate shared code repositories seamlessly. Through practical examples and step-by-step guidance, we’ll learn about the intricacies of collaborating with shared code repositories and maintaining code quality in a team environment. Join us as we delve deeper into the collaborative aspects of game development, paving the way for enhanced teamwork and code management practices.</p>
</div>
</body></html>