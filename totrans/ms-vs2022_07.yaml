- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Machine Learning Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will embark on an exploration of integrating **machine learning**
    ( **ML** ) seamlessly into software development workflows using Visual Studio.
    As we continue to advance in the digital age, the integration of ML capabilities
    into applications has become increasingly pivotal, enabling intelligent decision-making
    and automation within our software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey begins with an introduction to ML, demystifying its core concepts
    and applications. Next, we will dive into the practical aspects by harnessing
    the power of **ML.NET** and **Model Builder** within Visual Studio. Through hands-on
    examples and guided tutorials, we’ll demonstrate how to create and train ML models
    directly within the familiar Visual Studio environment.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, the focus shifts toward deployment strategies for ML models.
    We’ll explore how to deploy a trained model within an ASP.NET Core web API, enabling
    real-time inference and integration with web-based applications. Additionally,
    we’ll explore deploying models within Azure Functions, leveraging serverless computing
    for scalable and cost-effective deployment scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating machine learning models with ML.NET and Model Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying models in an ASP.NET Core web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying models in Azure Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On this journey, we will unlock the potential of integrating ML into our software
    projects using Visual Studio, empowering us to build intelligent and adaptive
    applications that resonate with today’s technology landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wrote this chapter with the following version of Visual Studio in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch07](https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch07)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ML** is a branch of **artificial intelligence** ( **AI** ) focused on developing
    algorithms and statistical models that enable computers to perform tasks without
    explicit programming. These tasks can range from basic pattern recognition to
    complex decision-making processes. At its core, ML involves machines learning
    from data to improve the algorithms’ performance over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three primary types of ML:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervised learning** : This involves training a model on labeled data to
    predict outputs based on input data, such as regression (predicting continuous
    values) and classification (predicting discrete labels)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unsupervised learning** : This involves training a model on unlabeled data
    to identify patterns or structures within the dataset, such as clustering (grouping
    similar data points) and dimensionality reduction (reducing input variables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reinforcement learning** : Models learn to make decisions by interacting
    with an environment, and receiving feedback in the form of rewards or penalties
    to maximize the cumulative reward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ML utilizes various algorithms such as decision trees, **support vector machines**
    ( **SVMs** ), and neural networks, chosen based on specific problems, data characteristics,
    and desired outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: ML.NET, an open source, cross-platform ML framework by Microsoft, simplifies
    ML for .NET developers, enabling the integration of ML capabilities into applications
    without requiring deep expertise in ML or data science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key features of ML.NET include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-platform compatibility** : It works seamlessly on Windows, Linux, and
    macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with .NET** : It easily incorporates ML capabilities into . NET
    projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizable models** : Developers can tailor models to their needs, including
    training on custom datasets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency and explainability** : It provides tools for understanding how
    models make predictions, essential for building trust in AI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source and community-driven** : It benefits from community contributions,
    leading to ongoing improvements and new features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ML.NET** is a versatile framework that simplifies the integration of ML capabilities
    into .NET applications. Features such as **automated ML** ( **AutoML** ) and tools
    such as ML.NET CLI and Model Builder make the process straightforward, even for
    developers without extensive data science experience. It supports cross-platform
    development and seamlessly integrates with popular Python libraries such as TensorFlow
    and ONNX through NimbusML.'
  prefs: []
  type: TYPE_NORMAL
- en: The Model Builder tool within ML.NET streamlines model creation with AutoML,
    enabling developers to deploy models swiftly by loading their data. This tool
    automates the entire model-building process, including code generation for consuming
    these models. Combined with its flexibility to leverage existing ML libraries,
    ML.NET offers a robust solution for .NET developers seeking to incorporate ML
    into their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s dive into creating an ML model using ML.NET and the intuitive Model
    Builder **user** **interface** ( **UI** ).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ML model with ML.NET and the Model Builder UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially introduced as a preview feature in Visual Studio 2019, Model Builder
    has transitioned to a stable feature as of 2022. In this section, we will explore
    how to use Model Builder to create an ML model with ML.NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s ensure that the Model Builder component is installed correctly
    in our instance of Visual Studio. To do so, we open the Visual Studio Installer
    and confirm that ML.NET Model Builder is selected under the **Individual** **components**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Installer – ML.NET Model Builder](img/B22218_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Installer – ML.NET Model Builder
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create a new empty console project as a foundation for supporting
    our ML process. Now, we are all set, and we can create our ML.NET by using the
    file-adding menu by right-clicking on the project and selecting **Add** | **Machine**
    **Learning Model…** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Add an ML model](img/B22218_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Add an ML model
  prefs: []
  type: TYPE_NORMAL
- en: The preceding action will initiate the **.mbconfig** file. This file is a JSON
    file that keeps track of the state of the UI, including the model’s configuration,
    data transforms, algorithm, and settings such as learning rate, number of layers,
    and number of neurons.
  prefs: []
  type: TYPE_NORMAL
- en: The first step prompted by Model Builder, after choosing a name for the **.mbconfig**
    file, is to select a **Scenario** option for our ML model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Configuring .mbconfig](img/B22218_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Configuring .mbconfig
  prefs: []
  type: TYPE_NORMAL
- en: 'The selection window of Model Builder offers several scenarios organized into
    three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tabular** : This category includes scenarios for tasks such as regression,
    classification, and clustering, where the data is organized in a tabular format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Tabular](img/B22218_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Tabular
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer Vision** : This category encompasses scenarios related to image
    classification, object detection, and other computer vision tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.5 –  Computer Vision](img/B22218_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Computer Vision
  prefs: []
  type: TYPE_NORMAL
- en: '**Natural Language Processing** : This category includes scenarios for natural
    language processing tasks, such as sentiment analysis, text classification, and
    language translation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Natural Language Processing](img/B22218_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Natural Language Processing
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will choose the **Data Classification** scenario under the
    **Tabular** category.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to select the training environment. We have the option to
    train our ML model either locally on our machines or in the cloud on Azure, depending
    on the situation. When we train locally, we operate within the limitations of
    our computer resources (CPU, memory, and disk). However, when we train in the
    cloud, we can scale up our resources to address the requirements of our scenario,
    particularly for handling large datasets. Notice that the availability of the
    environment depends on the scenario we choose. Here’s a table of the current availability
    combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scenario** | **Local CPU** | **Local GPU** | **Azure** |'
  prefs: []
  type: TYPE_TB
- en: '| Data classification | **✔️** | **❌** | **❌** |'
  prefs: []
  type: TYPE_TB
- en: '| Value prediction | **✔️** | **❌** | **❌** |'
  prefs: []
  type: TYPE_TB
- en: '| Recommendation | **✔️** | **❌** | **❌** |'
  prefs: []
  type: TYPE_TB
- en: '| Forecasting | **✔️** | **❌** | **❌** |'
  prefs: []
  type: TYPE_TB
- en: '| Image classification | **✔️** | **✔️** | **✔️** |'
  prefs: []
  type: TYPE_TB
- en: '| Object detection | **❌** | **❌** | **✔️** |'
  prefs: []
  type: TYPE_TB
- en: '| Text classification | **✔️** | **✔️** | **❌** |'
  prefs: []
  type: TYPE_TB
- en: Now that we have chosen our scenario and training environment, we must gather
    the data that will be used for training. Model Builder will guide us through the
    process according to our selected scenario, helping us upload the data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can launch the training of our ML model. We can set a specific time
    for training to begin. Model Builder automatically chooses a training time based
    on our dataset size.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 –Train](img/B22218_07_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 –Train
  prefs: []
  type: TYPE_NORMAL
- en: During the **Evaluate** step, we’ll discover the best-performing algorithm and
    its highest accuracy, providing valuable insights into our model’s performance.
    This step also enables us to experiment with the model directly within the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Try your model** section, we can input sample data to generate predictions.
    The textbox comes pre-filled with the first line of data from our dataset, but
    we have the flexibility to modify the input and click the **Predict** button to
    observe different price predictions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Evaluate](img/B22218_07_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Evaluate
  prefs: []
  type: TYPE_NORMAL
- en: The last panel of Model Builder is about consuming the model we just created.
    Let’s explore how we can integrate our model into a web API using Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a model in an ASP.NET Core web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to integrate our ML.NET model into an existing
    web API. To do so, we will jump to the **Consume** panel of Model Builder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Consume](img/B22218_07_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Consume
  prefs: []
  type: TYPE_NORMAL
- en: The **Consume** panel within Model Builder is a critical tool for integrating
    our trained ML models into .NET applications. Once we’ve completed the evaluation
    phase, Model Builder generates a model file and the necessary code to incorporate
    the model into our application. These models are saved as a **.zip** file, and
    the code to load and use our model is added as a new project within our solution.
    Additionally, Model Builder provides a sample console application that we can
    run to see our model in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Consume** panel gives us options to create projects that consume our
    model, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console app** : Generates a .NET console application specifically for making
    predictions using our model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web API** : Sets up an ASP.NET Core web API, allowing us to consume our model
    over the internet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These projects are crucial for deploying our model in various environments,
    whether for local testing or web-based applications accessible online.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s click on the **Add web app to the solution** link to create the new ASP.NET
    Core web API exposing our model. That will set up a working web API, enabling
    us to expose the model we just trained, using the minimal API way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to understand how it’s articulate, we will take a look at what the wizard
    generates for us. Let’s explore the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Generating a web API project structure](img/B22218_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Generating a web API project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'The template utilizes the following packages to make ML.NET models accessible
    for ML:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft.ML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft.Extensions.ML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Among these libraries, in the **Program.cs** file, we observe that Visual Studio
    generates a POST request. Here’s the code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet uses the models generated by the model builder to set up an
    HTTP POST **endpoint /predict** in an ASP.NET Core minimal API application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible because of the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code is configuring an ASP.NET Core application to use an ML model stored
    in a file named **SampleML.mlnet** for making predictions. The model expects inputs
    of the **SampleML.ModelInput** type and produces outputs of the **SampleML.ModelOutput**
    type. This setup allows the application to efficiently manage and reuse the ML
    model across different parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can test the endpoints using the endpoints explorer and **.http** file,
    as we saw in [*Chapter 6*](B22218_06.xhtml#_idTextAnchor112) . Since the HTTP
    verb used for this endpoint is **POST** , we have to add a body to our request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the proper syntax to set up our working request in the **.** **http**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can validate that we own a web API able to consume our model generated
    by Model Builder. This web API can be seamlessly deployed like any other API in
    the . NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to consume our generated ML model, and that is to consume
    it through Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a model in Azure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to integrate the ML model generated by Model
    Builder into Azure Functions. This process will be less straightforward as no
    template is provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Functions** is a serverless computing service offered by Microsoft
    Azure. Serverless computing is a cloud computing execution model where the cloud
    provider runs the server, and dynamically manages the allocation of machine resources.
    Pricing is based on the actual number of resources consumed by an application,
    rather than pre-purchased units of capacity.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to ensure that the Azure development workload is well installed
    in our Visual Studio instance by navigating to the Visual Studio Installer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Azure development workload](img/B22218_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Azure development workload
  prefs: []
  type: TYPE_NORMAL
- en: Once the workload is installed, we can start by creating a new Azure Functions
    project, for example, we will name it **SampleML_AzureFunction** , and we will
    keep all parameters by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Azure Functions project](img/B22218_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Azure Functions project
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we need to add both libraries by ourselves, as seen in the previous
    section, using the NuGet Manager. We will open the NuGet Manager by right-clicking
    on the project name, selecting **Manage NuGet Packages…** , and then browsing
    for our needed libraries, to finally install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft.ML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft.Extension.ML**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, to be able to use our pre-trained model, all we need to do is copy the
    **.mbconfig** file to Azure Functions. After that, to be sure you can access the
    **.mlnet** package after compiling, we need to set the **Copy to Output Directory**
    properties to **Copy** **if newer** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The SampleML.Net properties](img/B22218_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The SampleML.Net properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are all set, we can develop our function following these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add **startup.cs** to configure our Azure Functions project to use **SampleML.mlnet**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the **predict** method of the ML.NET package in the Azure’s **run** method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we can test the Azure function using the Endpoints Explorer and **.http**
    , like how you tested the web API in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the integration of ML capabilities into software
    development workflows using Visual Studio, equipping developers with essential
    skills to leverage intelligent decision-making within applications.
  prefs: []
  type: TYPE_NORMAL
- en: We began by introducing the fundamental concepts of ML, providing an overview
    to understand its applications and significance in modern software development.
    Next, we delved into practical implementation by demonstrating how to create and
    train ML models using ML.NET and Model Builder within Visual Studio. Moving forward,
    we explored deployment strategies for trained models, showcasing how to deploy
    ML models within an ASP.NET Core web API for real-time inference and integration
    with web applications. Additionally, we discussed deploying models within Azure
    Functions to leverage serverless computing for scalable and efficient deployment
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you gained hands-on experience in building, training, and deploying
    ML models using Visual Studio, enabling you to infuse intelligent capabilities
    into your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll continue on track toward advanced cloud integration
    and services through Visual Studio 2022.
  prefs: []
  type: TYPE_NORMAL
