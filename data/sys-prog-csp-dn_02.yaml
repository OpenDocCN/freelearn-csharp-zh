- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The One Where Speed Matters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度至上的那一章
- en: '*Writing* *for performance*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*为性能而写作*'
- en: Most users agree that applications can never be fast enough. Anytime you talk
    to people about what annoys them in a piece of software, performance, or lack
    thereof, it is the one thing that gets to the top of the list.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户都认为应用程序永远不会足够快。每次你与人谈论软件中的烦恼，无论是性能还是缺乏性能，它都是排在最前面的一个问题。
- en: 'And that makes sense: we are all busy, and we certainly don’t want to spend
    time waiting for a piece of machinery to catch up with us. It has to be the other
    way around!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的：我们都很忙，我们当然不希望浪费时间等待机器赶上我们。它必须反过来！
- en: 'But if you think about it, you’ll realize it is a miracle that computers can
    do anything at all within a reasonable time. If you think you’re busy, just look
    at everything computers need to do! You can do the following experiment:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你仔细想想，你会意识到计算机在合理的时间内做任何事情都是一个奇迹。如果你觉得自己很忙，看看计算机需要做的一切！你可以进行以下实验：
- en: Reboot your computer.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动你的电脑。
- en: Log in.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录。
- en: 'Start (if you’re using Windows) Task Manager (hint: use the *Ctrl* + *Shift*
    + *Esc* combination).'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动（如果你使用的是Windows）任务管理器（提示：使用*Ctrl* + *Shift* + *Esc*组合键）。
- en: Look at how much stuff is going on in the section background processes.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看在“后台进程”部分有多少事情在进行。
- en: All of those processes are examples of system programming. They are all there
    to help the system do its job or to help the user-facing software get things done.
    And there are a lot of them. These processes all take up a bit of CPU time, a
    bit of networking, and some memory. Most are dormant and just waiting for something
    interesting to happen, but they are still there. They take away resources from
    the user-facing software.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些进程都是系统编程的例子。它们都在那里帮助系统完成其工作或帮助面向用户的软件完成任务。而且有很多这样的进程。这些进程都占用一点CPU时间、一点网络资源和一些内存。大多数都是休眠状态，只是在等待有趣的事情发生，但它们仍然存在。它们从面向用户的软件中夺取资源。
- en: I guess it is pretty clear that system software needs to be as small and as
    fast as possible so that there are enough resources left for the rest of the system
    – that is, the part the user cares about. The next chapter deals with making it
    small (or as memory-efficient as possible).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我想这很清楚：系统软件需要尽可能小和快，以便为系统的其余部分——即用户关心的部分——留下足够的资源。下一章将讨论如何使其尽可能小（或内存效率尽可能高）。
- en: In this chapter, we will cover the following topics
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题
- en: Why does speed matter?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么速度很重要？
- en: What is the **Common Type** **System** (**CTS**)?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共类型系统**（**CTS**）是什么？'
- en: What is the difference between value types and reference types?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的区别是什么？
- en: What has boxing got to do with performance, and what is it anyway?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封箱与性能有什么关系，它到底是什么？
- en: How to choose the right data structures and algorithms to be as fast as possible
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择合适的数据结构和算法，以尽可能快地完成任务
- en: How do strings work and how can we make them faster?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是如何工作的，我们如何使它们更快？
- en: What is unsafe code and how can we deal with it safely?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全代码是什么，我们如何安全地处理它？
- en: Some compiler flags that help speed things up
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些有助于加速的编译器标志
- en: To summarize, this chapter will show you how to make your systems as fast as
    possible. So, buckle up; we are about to go fast!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章将向您展示如何使您的系统尽可能快。所以，系好安全带；我们即将加速！
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will find all the code in this chapter in the following link: [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中找到本章的所有代码：[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter02)。
- en: Setting up the stage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置舞台
- en: 'So far, we’ve established that we need as much performance as possible to allow
    the other systems to do their things. But there are other reasons you might want
    to optimize your code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定我们需要尽可能多的性能来允许其他系统完成它们的工作。但还有其他原因你可能想要优化你的代码：
- en: Accessibility
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问性
- en: Hosting costs
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名托管费用
- en: Planned obsolescence
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划性淘汰
- en: Energy usage
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能耗
- en: Let’s examine these one by one.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查这些内容。
- en: Accessibility
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可访问性
- en: Whenever I mention accessibility to software developers, they usually think
    about making software useable for people with physical challenges. I like to think
    a bit broader. Not everybody can afford the latest and fastest hardware. Many
    people need to make do with older, slower machines. Suppose your code slows that
    already sluggish machine down. In that case, you might be responsible for these
    people not being able to use the device anymore.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我提到软件的可访问性时，软件开发者通常都会想到使软件对有身体挑战的人可用。我喜欢更广泛地思考。并不是每个人都能负担得起最新和最快的硬件。许多人需要使用较旧、较慢的机器。假设您的代码使这台已经缓慢的机器变得更慢。在这种情况下，您可能要为这些人无法再使用设备负责。
- en: Other people use shared devices. Often found in institutions, more than one
    person uses these devices, and everybody adds their software. If your software
    slows the machine down, it affects everybody.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人在共享设备上使用。这些设备通常在机构中找到，有多个人使用这些设备，每个人都添加他们的软件。如果您的软件使机器变慢，这会影响所有人。
- en: Hosting costs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名托管费用
- en: More software these days runs in the cloud, in which case you have to pay per
    usage. If your software requires a lot of horsepower to run, it might increase
    costs. When added up, every bit of performance loss impacts the monthly cloud
    provider bill.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，越来越多的软件在云端运行，在这种情况下，您必须按使用量付费。如果您的软件需要大量的计算能力来运行，它可能会增加成本。当累积起来，每一次性能损失都会影响每月的云服务提供商账单。
- en: Planned obsolescence
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划性淘汰
- en: 'Machines have a fiscal lifetime and an economic lifetime. These lifetimes determine
    when the company decides to replace the device. The fiscal lifetime is easy to
    calculate: when the organization buys a machine, the accountants tell you in how
    many years the value is too low to keep it around. They take the purchase price,
    calculate the depreciation for each year, and make notes of that in their spreadsheets.
    I’m oversimplifying things here, but I’m not an accountant.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 机器有财务寿命和经济寿命。这些寿命决定了公司何时决定更换设备。财务寿命的计算很简单：当组织购买一台机器时，会计师会告诉您在多少年后其价值变得太低，不值得保留。他们会计算每年的折旧，并在他们的电子表格中记录下来。我在这里简化了一些事情，但我也不是会计师。
- en: The economic lifetime is harder to calculate. This lifetime is usually when
    a machine becomes so unusable that it is no longer worth upgrading or investing
    in. A computer that becomes too slow to be used should be replaced, even if the
    fiscal lifetime hasn’t expired.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 经济寿命的计算比较困难。这个寿命通常是指机器变得如此不可用，以至于不再值得升级或投资的时候。一台变得太慢无法使用的电脑应该被更换，即使其财务寿命尚未到期。
- en: 'Your software could lead to that happening. If your performance is too low,
    the organization could write off the machine earlier than desired. And that leads
    to much e-waste: perfectly good computers get replaced simply because the software
    was written less-than-perfectly.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您的软件可能会导致这种情况发生。如果您的性能太低，组织可能会比预期更早地报废机器。这会导致大量的电子废物：性能良好的电脑仅仅因为软件编写得不够完美而被更换。
- en: Energy usage
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 能耗
- en: Using more CPU power means using more electrical power. You might think it might
    not be such a big difference, but in the end, all those machines use a lot of
    energy worldwide. Writing your code as efficiently as possible saves power usage
    and helps the environment. It’s as simple as that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多的 CPU 功率意味着使用更多的电力。您可能会认为这不会造成太大的差异，但最终，全球所有这些机器消耗了大量的能源。尽可能高效地编写您的代码可以节省电力消耗，并有助于环境保护。就这么简单。
- en: Performance can be gained in a lot of places, even in pieces of your code where
    you deal with the humble integer. Let’s discuss that!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 性能可以在很多地方得到提升，甚至在您处理谦逊的整数时也是如此。让我们来讨论一下！
- en: Which integer is the fastest?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哪个整数是最快的？
- en: 'Choosing the right type of integer to use can have an impact on the performance
    of your system. I wouldn’t worry too much about this: the CLR is pretty good at
    optimizing your code, and the `for` loop that iterates over a piece of code. If
    we have less than 255 iterations, we might be tempted to use a byte. After all,
    a byte is just 1 byte. If you use an integer, it will be 4 bytes. That is more
    memory and probably takes longer to process, right?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的整数类型可能会影响您系统的性能。我并不会对此过于担心：CLR 在优化您的代码方面做得相当不错，并且对于遍历代码片段的 `for` 循环也是如此。如果我们有不到
    255 次迭代，我们可能会倾向于使用字节。毕竟，一个字节只是 1 字节。如果您使用整数，它将是 4 字节。这意味着更多的内存，并且可能需要更长的时间来处理，对吧？
- en: Wrong!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 错误！
- en: Don’t try to outsmart the compiler. It knows the system a lot better than you
    do.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图欺骗编译器。它对系统的了解比你多得多。
- en: Let me show you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给您展示一下。
- en: 'We have the following four lines of C# code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下四行 C# 代码：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We set four variables to some values. The following table describes the specifics
    of each type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将四个变量设置为一些值。下表描述了每种类型的详细信息：
- en: '| **C# Type** | **Short Name** | **Description** | **MaxValue (Hexadecimal)**
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **C# 类型** | **简称** | **描述** | **MaxValue (十六进制)** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| System.Byte | byte | A byte | 0xFF |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| System.Byte | byte | 一个字节 | 0xFF |'
- en: '| System.UInt16 | ushort | Unsigned 16-bit integer | 0xFFFF |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| System.UInt16 | ushort | 无符号 16 位整数 | 0xFFFF |'
- en: '| System.UInt32 | uint | Unsigned 32-bit integer | 0xFFFFFFFF |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| System.UInt32 | uint | 无符号 32 位整数 | 0xFFFFFFFF |'
- en: '| System.UInt64 | ulong | Unsigned 64-bit integer | 0xFFFFFFFFFFFFFFFF |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| System.UInt64 | ulong | 无符号 64 位整数 | 0xFFFFFFFFFFFFFFFF |'
- en: 'Table 2.1: Numeric types with their maximum values'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：具有最大值的数值类型
- en: Let’s examine what the compiler makes out of it. If you want to see this for
    yourself, create a new C# console program in Visual Studio (using .NET 7 or .NET
    8), use top-level statements, and copy those four lines. Then, set a breakpoint
    on the first line and run it. As soon as you hit the breakpoint, press *Ctrl*
    + *K*, *G*. Doing that opens the disassembler.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看编译器是如何处理这些代码的。如果你想亲自查看，请在 Visual Studio 中创建一个新的 C# 控制台程序（使用 .NET 7 或 .NET
    8），使用顶层语句，并复制这四行。然后，在第一行设置一个断点并运行它。一旦你触发了断点，按 *Ctrl* + *K*，*G*。这样做会打开反汇编器。
- en: 'You’ll get something like this (I’ve cut some of the code that isn’t that useful
    to us here):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到类似这样的结果（我已经删除了一些对我们来说不是很有用的代码）：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I know I promised we wouldn’t be doing assembly programming, but you need to
    know what’s happening if you want your code to run as fast as possible. Let me
    talk you through it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我承诺我们不会进行汇编编程，但如果你想让你的代码尽可能快地运行，你需要知道发生了什么。让我带你了解一下。
- en: Lines 1, 3, 5, and 7 are comment lines that show the C# code that resulted in
    this assembly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1、3、5 和 7 行是注释行，显示了导致这些汇编代码的 C# 代码。
- en: On line 2, we can see the code the CPU handles when we want it to set the value
    to a variable. The actual command is MOV, which means move. It then takes two
    parameters. The first is the target of the MOV, and the second is the value. There
    are several types of MOV commands; this particular one moves a DWORD. In Win32,
    DWORD stands for Double Word, which we know as an unsigned 32-bit integer. We
    are moving the hardcoded value, `0FFh` (255 in decimal), to `[rbp+3Ch]`. In case
    you’re wondering, `rbp` is the stack pointer. So, we’re moving our value, `0xFF`,
    to position 3C on our stack.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 行，我们可以看到当我们要将值设置到变量中时 CPU 处理的代码。实际的命令是 MOV，意思是移动。它然后接受两个参数。第一个是 MOV 的目标，第二个是值。有几种类型的
    MOV 命令；这个特定的命令移动一个 DWORD。在 Win32 中，DWORD 代表 Double Word，我们知道它是一个无符号 32 位整数。我们将硬编码的值
    `0FFh`（十进制中的 255）移动到 `[rbp+3Ch]`。如果你想知道，`rbp` 是栈指针。因此，我们将我们的值 `0xFF` 移动到我们的栈上的
    3C 位置。
- en: 'Great. We should know that value types go on the stack instead of the heap.
    Don’t worry if you didn’t realize that. The next chapter is all about memory.
    For now, just accept that we have two types of memory: a small but fast stack
    and a slow but huge heap. This byte goes to the stack.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们应该知道值类型是放在栈上而不是堆上的。如果你没有意识到这一点，不要担心。下一章将全部关于内存。现在，只需接受我们有两种内存：一个小但快速的栈和一个慢但巨大的堆。这个字节将放在栈上。
- en: Line 4 moves `0xFFFF` to `[rbp+38h]`. Again, we are moving a `DWORD` here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第 4 行将 `0xFFFF` 移至 `[rbp+38h]`。再次强调，我们在这里移动的是一个 `DWORD`。
- en: 'Line 6 does more or less the same: we move `0xFFFFFFFF` to the stack. Again,
    it is a `DWORD`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 行大致做了同样的事情：我们将 `0xFFFFFFFF` 移至堆栈。再次强调，它是一个 `DWORD`。
- en: When compiled, a byte, a `UInt16`, and a `UInt32` are considered a `DWORD`.
    There is no difference between them. If you look at the assembly code, there’s
    no way of knowing what type the C# intended to use. That means there is no difference
    in performance here when using an 8-bit byte or a 32-bit unsigned integer. And
    in case you’re wondering, the signed 32-bit integer looks the same, with the difference
    that `Int32.MaxValue` is half the value of `UInt32.MaValue`. However, the compiled
    code is the same.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，一个字节、一个 `UInt16` 和一个 `UInt32` 被视为一个 `DWORD`。它们之间没有区别。如果你查看汇编代码，你无法知道 C#
    希望使用哪种类型。这意味着在使用 8 位字节或 32 位无符号整数时，性能上没有区别。如果你想知道，有符号 32 位整数看起来相同，区别在于 `Int32.MaxValue`
    是 `UInt32.MaxValue` 的一半。然而，编译后的代码是相同的。
- en: Look at the code to copy the 64-bit integer to the stack. That works quite differently.
    On line 8, we move `0xFFFFFFFF` to a register (a register is a special piece of
    memory inside the CPU that holds temporary variables). Then, we call CDQE. That
    copies whatever is in the EAX register (which can hold 32 bits) into the `RAX`
    register, which can hold 64 bits. Then, on line 10, it copies the first 32 bits
    of the contents to the stack.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码，将64位整数复制到栈上的操作完全不同。在第8行，我们将`0xFFFFFFFF`移动到一个寄存器（寄存器是CPU内部的一个特殊内存区域，用于存储临时变量）。然后，我们调用CDQE。这会将EAX寄存器（可以存储32位）中的内容复制到`RAX`寄存器，它可以存储64位。然后，在第10行，它将内容的前32位复制到栈上。
- en: 'As you can see, setting a variable to `Int64.MaxValue` involves a lot more
    work than the other three variants. It is considerably slower: the CPU has to
    do a lot more.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将变量设置为`Int64.MaxValue`比其他三个变体要复杂得多。它要慢得多：CPU需要做更多的工作。
- en: 'However – and this is important – this might not always be the case. This is
    what happens on my modern, beefy 64-bit Windows 11 machine. Things might be completely
    different on a low-powered Raspberry PI running Linux on an ARM processor. And
    that is one of the challenges of system programming: you must know how types behave
    to have the highest possible performance.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而——这很重要——这并不总是这种情况。这是我现代的、强大的64位Windows 11机器上的情况。在运行Linux的ARM处理器的低功耗Raspberry
    PI上，事情可能完全不同。这就是系统编程的一个挑战：你必须了解类型的行为才能获得最高的性能。
- en: I think it’s time to discuss the CTS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为现在是讨论CTS的时候了。
- en: The CTS
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CTS
- en: The CTS is a set of rules describing the types that are used in a .NET program.
    That’s it. Nothing binary is going on; it is just a set of rules – a standard
    that compilers, languages, and the runtime must adhere to.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: CTS是一组描述.NET程序中使用的类型的规则。仅此而已。没有二进制操作正在进行；它只是一组规则——一个编译器、语言和运行时必须遵守的标准。
- en: There are several different languages available on .NET Framework. Microsoft
    has C#, VB.Net, and F#. They also offer J#, a Java variant running on the CLR.
    You can also write .NET programs in C or C++. Other vendors also provide languages
    and tools you can choose from. Think of IronPython or Delphi.NET, for instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework上可用的语言有多种。微软有C#、VB.Net和F#。他们还提供了J#，这是一个在CLR上运行的Java变体。你还可以用C或C++编写.NET程序。其他供应商也提供了你可以选择的语言和工具。例如，考虑IronPython或Delphi.NET。
- en: All these languages must stick to the rules. The compiler must emit IL code
    (again, IL looks like assembly but isn’t). The JIT compiler then takes the IL
    to create machine code the CPU can understand and run.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些语言都必须遵守规则。编译器必须生成IL代码（再次强调，IL看起来像汇编语言，但并不是）。然后JIT编译器将IL转换为CPU可以理解和运行的机器代码。
- en: There is a subset of the rules in the CTS that are called the `[assembly:` `CLSCompliant(true)]`
    attribute.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CTS中有一组被称为`[assembly:` `CLSCompliant(true)]`属性的规则子集。
- en: Our aim here is not to design languages, so we aren’t going to dive deeper into
    this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的目标不是设计语言，所以我们不会深入探讨这个问题。
- en: All types used in .NET languages must adhere to the CTS rules. This book is
    not about learning to program in .NET. Still, knowing about the inner workings
    is crucial if you’re a system programmer. We will cover just the highlights of
    the CTS here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET语言中使用的所有类型都必须遵守CTS规则。这本书不是关于学习.NET编程的。然而，如果你是系统程序员，了解内部工作原理是至关重要的。在这里，我们将仅介绍CTS的要点。
- en: Value types and reference types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型和引用类型
- en: Later in this chapter, I’ll discuss value and reference types in a lot more
    detail. Here, I will simply say that value types hold their values directly. In
    contrast, reference types are pointers that point to a value somewhere else in
    memory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我会更详细地讨论值类型和引用类型。在这里，我只想简单地说，值类型直接持有它们的值。相比之下，引用类型是指向内存中其他位置的值的指针。
- en: Classes and structs
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和结构体
- en: .NET-based languages are supposed to be object-oriented. From this, it follows
    that the languages should support classes. These classes also have to have specific
    characteristics.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基于.NET的语言应该是面向对象的。从这个意义上说，这些语言应该支持类。这些类也必须具有特定的特征。
- en: '**Classes** should have visibility. They can be public, internal, protected,
    or private. We all know what those classifiers mean.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**应该具有可见性。它们可以是公共的、内部的、受保护的或私有的。我们都知道这些分类符的含义。'
- en: Classes have methods, properties, fields, delegates, and so on. These items
    can be private, protected, or public. You probably already know all of this; I
    don’t have to explain what this all is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类有方法、属性、字段、委托等。这些项可以是私有的、受保护的或公共的。你可能已经知道所有这些；我无需解释这些是什么。
- en: However, a lot of developers struggle with **structs**. To the casual observer,
    they are more or less the same. And yes, they are indeed similar. They can both
    have methods, properties, fields, and so on. They can both implement interfaces.
    And they can both have static members.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多开发者都在**结构体**上遇到困难。对于旁观者来说，它们或多或少是相同的。是的，它们确实相似。它们都可以有方法、属性、字段等。它们都可以实现接口。它们都可以有静态成员。
- en: The differences between classes and structs are more interesting. First, a class
    instance lives on the heap, and you will get a pointer that you store in the stack.
    However, a struct lives on the stack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体之间的区别更有趣。首先，类实例存在于堆上，你会得到一个存储在栈上的指针。然而，结构体存在于栈上。
- en: Since the variable that “holds” the class is the pointer to the heap memory
    where the data is stored, that variable can be null. In that case, it points to
    nothing; it is just a placeholder for a future instance of that class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“持有”类的变量是指向存储数据的堆内存的指针，因此该变量可以是null。在这种情况下，它指向空；它只是该类未来实例的一个占位符。
- en: 'A struct cannot be null. There is an edge case: nullable types such as `MyStruct?`
    can be null, but that is the whole point of nullable types. Structs cannot inherit
    from each other. They can implement interfaces, though, just like classes can.
    That also means you cannot have an “abstract” or “sealed” struct. Those two modifiers
    are meant for classes that must be inherited. Since we cannot inherit from structs,
    this doesn’t make sense.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体不能为null。有一个边缘情况：可空类型，如`MyStruct?`可以是null，但这正是可空类型的目的。结构体不能相互继承。尽管如此，它们可以像类一样实现接口。这也意味着你不能有一个“抽象”或“密封”的结构体。这两个修饰符是为了必须继承的类而设计的。由于我们不能从结构体中继承，这没有意义。
- en: 'Looking at this, you might think that a class is a better choice: there are
    only a few downsides and a lot of upsides in using them over structs. And you’re
    not wrong. But structs have one significant advantage over classes: they are initialized
    on the stack, not the heap. And as I said previously, the stack is way faster
    than the heap. Since we aim for maximum performance, structs are used much more
    in our applications than in others.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这里，你可能会认为类是一个更好的选择：与结构体相比，使用它们的缺点很少，优点很多。你并没有错。但是，结构体相对于类有一个显著的优势：它们在栈上初始化，而不是在堆上。正如我之前所说的，栈比堆快得多。由于我们追求最大性能，我们的应用程序中使用的结构体比其他地方多得多。
- en: Floating-point numbers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: We already saw that it doesn’t matter what kind of integer you use for most
    cases. UInt64, Int64, UInt128, and Int128 are generally slower than the other
    types, so only use them when you have thought it through and decided you need
    them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对于大多数情况，你使用的整数类型并不重要。UInt64、Int64、UInt128和Int128通常比其他类型慢，所以只有在你经过深思熟虑并决定你需要它们时才使用它们。
- en: 'Things are a bit different for floating-point numbers, however. We have three
    floating-point types in the CLS and, thus, in C#. Please look at the following
    table to see which ones they are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于浮点数来说，情况略有不同。在CLS和C#中，我们有三种浮点数类型。请查看以下表格，以了解它们是哪些：
- en: '| **Type** | **C# Type** | **Description** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **C# 类型** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| float | `System.Single` | 32-bit single-precision floating-point |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| float | `System.Single` | 32位单精度浮点数 |'
- en: '| double | `System.Double` | 64-bit double-precision floating-point |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| double | `System.Double` | 64位双精度浮点数 |'
- en: '| decimal | `System.Decimal` | The 128-bit decimal type is more precise but
    has a smaller range than a double |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| decimal | `System.Decimal` | 128位的十进制类型更精确，但范围比双精度浮点数小 |'
- en: 'Table 2.2: Floating-point types'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2：浮点数类型
- en: Which type you choose depends on your scenarios. You must select a decimal over
    a float if you need more precision. That would be obvious. But things are slightly
    more complicated if you don’t need the 128-bit precision a decimal gives you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪种类型取决于你的场景。如果你需要比float更精确的精度，你必须选择十进制。这将是显而易见的。但是，如果你不需要十进制提供的128位精度，事情就会稍微复杂一些。
- en: On a 64-bit machine, the double (`System.Double`) is the fastest floating-point
    number. The CPU can understand this natively, so no conversions are needed. Performance-wise,
    this is your best choice. However, a float (`System.Single`) is more memory efficient.
    However, this is only true on a 64-bit machine. If you’re targeting other platforms,
    the results might be different. For instance, if you want to run your code on
    an ARM-based device such as a Raspberry Pi, you will find that the CPU is optimized
    for the float type. So, you would be better off using a single-precision variety
    if you care about performance. Again, if your use case needs a higher precision,
    please use one of the other types. They are here for a reason, after all.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位机器上，双精度浮点数（`System.Double`）是最快的浮点数。CPU 可以原生理解它，因此不需要转换。从性能角度来看，这是你的最佳选择。然而，单精度浮点数（`System.Single`）在内存效率上更高。然而，这只在
    64 位机器上成立。如果你针对其他平台，结果可能会有所不同。例如，如果你想在基于 ARM 的设备（如 Raspberry Pi）上运行你的代码，你会发现 CPU
    优化了浮点类型。因此，如果你关心性能，最好使用单精度版本。再次强调，如果你的用例需要更高的精度，请使用其他类型之一。毕竟，它们的存在是有原因的。
- en: Where types live – the difference between value types and reference types
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型存储的位置——值类型和引用类型之间的差异
- en: Types in the CTS can be either a value type or a reference type. It is essential
    to know the difference between these two options. Value types operate on the stack,
    while reference types live on the heap. Stuff residing on the stack is usually
    much faster than what happens on the heap.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CTS 中的类型可以是值类型或引用类型。了解这两种选项之间的差异至关重要。值类型在栈上操作，而引用类型在堆上存在。位于栈上的内容通常比堆上的操作要快得多。
- en: From this, you would think using value types on the stack is the best way to
    get your desired sweet performance. Unfortunately, that is not how things work.
    The reference types are there for a reason, and they can give you significant
    performance improvements if used correctly!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，你可能会认为在栈上使用值类型是获得期望的良好性能的最佳方式。不幸的是，事情并非如此。引用类型的存在是有原因的，如果使用得当，它们可以给你带来显著的性能提升！
- en: The stack and the heap
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和堆
- en: Before discussing the difference between value types and reference types, we
    need to quickly look at the difference between the stack and the heap. I have
    already mentioned that the stack is faster than the heap but smaller. This is
    true, but there’s a bit more to this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论值类型和引用类型之间的差异之前，我们需要快速看一下栈和堆之间的差异。我已经提到栈比堆快但更小。这是真的，但还有更多内容。
- en: 'The following table shows the differences between the two types of memory:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了两种内存类型之间的差异：
- en: '| **Feature** | **Stack** | **Heap** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | **栈** | **堆** |'
- en: '| --- | --- | --- |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Allocation/Deallocation | Fast, compile time | Slow, runtime |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 分配/释放 | 快速，编译时 | 慢速，运行时 |'
- en: '| Lifespan | Limited to scope | Beyond scope |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 生命周期 | 限于作用域 | 超出作用域 |'
- en: '| Size Limitation | Smaller, fixed-size | Larger, dynamic size |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 大小限制 | 较小，固定大小 | 较大，动态大小 |'
- en: '| Data Types | Value types (usually) | Reference types |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 值类型（通常） | 引用类型 |'
- en: '| Behavior | Deterministic | Non-deterministic |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 行为 | 确定性 | 非确定性 |'
- en: '| Fragmentation | No | Possible |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 碎片化 | 无 | 可能 |'
- en: '| Thread | Thread-specific | Shared between threads |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 线程 | 线程特定 | 在线程之间共享 |'
- en: 'Table 2.3: Differences between stack and heap memory'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.3：栈内存和堆内存之间的差异
- en: The memory allocation for stack variables is done at compile time, and the memory
    is pushed on and popped off the stack. This makes allocation and deallocation
    extremely fast. For heap variables, the memory is allocated dynamically at runtime.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 栈变量的内存分配是在编译时完成的，内存被推入和弹出栈。这使得分配和释放非常快。对于堆变量，内存是在运行时动态分配的。
- en: However, the lifespan of variables on the stack is limited to the function’s
    scope or the block of code. Once your code no longer needs that variable, such
    as because you reached the end of a `for` loop, the memory for this variable is
    automatically freed. For the heap, it is up to you or the garbage collector to
    get rid of the memory when it’s unnecessary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，栈上变量的生命周期仅限于函数的作用域或代码块。一旦你的代码不再需要该变量，例如，因为你到达了 `for` 循环的末尾，该变量的内存将自动释放。对于堆，当它不再需要时，由你或垃圾回收器来处理内存的释放。
- en: The stack is smaller, and you are much more likely to run out of stack memory
    than heap memory. Heap memory can be huge, especially compared to stack memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 栈较小，你更有可能耗尽栈内存而不是堆内存。堆内存可以非常大，尤其是与栈内存相比。
- en: 'If you’re wondering how big that stack is, the answer is, “It depends.” You
    can even specify it yourself. Since the stack is tied to a thread, you can set
    the stack size when working with new threads:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道那个堆栈有多大，答案是，“这取决于。”你甚至可以自己指定它。由于堆栈与线程相关联，你可以在使用新线程时设置堆栈大小：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we created a new thread and gave it a `1 MB` stack. It’s easy to determine
    this! If you want to limit the amount of memory a thread uses, you can estimate
    how much you need and allocate it that way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的线程，并给它一个`1 MB`的堆栈。这很容易确定！如果你想限制线程使用的内存量，你可以估计你需要多少，并以此方式分配它。
- en: On a side note, most developers know of [https://StackOverflow.com](https://StackOverflow.com).
    Strangely enough, I have met many developers who have no idea where that name
    comes from.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，大多数开发者都知道[https://StackOverflow.com](https://StackOverflow.com)。奇怪的是，我遇到了很多不知道这个名字来源的开发者。
- en: When you create a thread with a given stack size but try to use more memory
    than available, you get a `StackOverflowException` error. That is where that name
    comes from.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个具有给定堆栈大小的线程，但尝试使用比可用更多的内存时，你会得到一个`StackOverflowException`错误。这就是这个名字的由来。
- en: 'Let me show you. Oh – and don’t use this in production code. This sample is
    just for illustrative purposes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你展示。哦——不要在生产代码中使用这个。这个示例只是为了说明目的：
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code calls a recursive function that does one thing: it calls
    itself. When you call a function or a method, the system stores the address to
    return to when the function ends. The system stores this return address on the
    stack. After all, this is short-lived and needs to be fast. You want to continue
    with your regular flow after the function call.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用了一个递归函数，它只做一件事：它调用自己。当你调用一个函数或方法时，系统会存储函数结束时返回的地址。系统将这个返回地址存储在堆栈上。毕竟，这是短暂的，需要快速。你希望在函数调用后继续你的常规流程。
- en: But this code does nothing except call a function repeatedly and never returns
    from it. Thus, the return address gets added to the stack thousands of times until
    the memory runs out, and you get that famous `StackOverflowException` error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码除了反复调用一个函数并且从不从中返回之外，什么也不做。因此，返回地址被添加到堆栈上数千次，直到内存耗尽，然后你会得到那个著名的`StackOverflowException`错误。
- en: If you want to experiment with this, run the preceding code in a separate thread
    and give it different stack sizes. Doing this will give you an idea of how significant
    an impact having the correct stack size has.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试这个，请在单独的线程中运行前面的代码，并给它不同的堆栈大小。这样做将给你一个关于正确堆栈大小有多重要的影响的概念。
- en: Boxing and unboxing
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封箱和拆箱
- en: So far, things look pretty straightforward. Value types live in the stack; reference
    types live on the heap. An integer is a value type; thus, you have it on the stack.
    A class you define is on the heap since that is a reference type. If you want
    your class to be faster, you can turn it into a struct and have it available quicker
    since it goes on the stack. You might be thinking this is easy, but you’d be wrong.
    Things can be a lot more complicated than that.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，事情看起来相当简单。值类型存在于栈上；引用类型存在于堆上。一个整数是值类型；因此，它在栈上。你定义的类在堆上，因为它是引用类型。如果你想使你的类运行得更快，你可以将其转换为结构体，并且可以更快地访问它，因为它位于栈上。你可能认为这很简单，但你会错的。事情可能比这复杂得多。
- en: 'Let’s look at our good friend, the integer. An integer is a whole number, so
    it has no decimal point. As we saw earlier, we have a couple of variations of
    the integer. We have the 16-bit, the 32-bit, the 64-bit, and even a 128-bit version.
    And we have them in signed and unsigned versions. We even have a byte: this is
    technically not an integer, but since it compiles to a DWORD, we can have it in
    the same category. An integer is a value type, so it lives on the stack. However,
    if you look at *Table 2.1*, you’ll see that the official name of an integer is
    `System.Int32`. I don’t know about you, but that looks like a class or a struct
    name.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的好朋友，整数。一个整数是一个整数，所以它没有小数点。正如我们之前看到的，我们有几种整数的变体。我们有16位、32位、64位，甚至128位版本。我们还有有符号和无符号版本。我们甚至有一个字节：从技术上讲，它不是一个整数，但由于它编译为DWORD，我们可以将其归入同一类别。整数是值类型，所以它位于栈上。然而，如果你看*表2.1*，你会看到整数的官方名称是`System.Int32`。我不知道你是否如此，但这看起来像是一个类或结构体的名称。
- en: A struct still lives on the stack, but it is less performant than you might
    expect compared to a simple integer. Luckily, the compiler helps us with this.
    As we saw earlier, the compiler turns our integers into DWORDs, so there is no
    performance penalty. But sometimes, things work differently. So, we need to talk
    about boxing and unboxing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体仍然位于栈上，但与简单的整数相比，它的性能可能不如你预期的那么好。幸运的是，编译器帮助我们处理这个问题。正如我们之前看到的，编译器将我们的整数转换为
    DWORD，所以没有性能损失。但有时，事情会有所不同。因此，我们需要讨论装箱和拆箱。
- en: 'C# is a genuine object-oriented language. That means everything is an object,
    and all descend from a base class. At the top level, one base class is the ancestor
    of all other classes. That is `System.Object`. Our integer is no different: the
    `System.Int32` struct derives from the `System.ValueType` class, which, in turn,
    is a descendant of `System.Object`. So, we still follow the rules of object orientation.
    Still, there seems to be a mix of classes and structs here. Don’t worry; these
    are semantics, and the compiler deals with them when needed.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种真正的面向对象的语言。这意味着一切都是对象，并且所有对象都从基类派生。在顶级，有一个基类是所有其他类的祖先。那就是 `System.Object`。我们的整数也不例外：`System.Int32`
    结构体从 `System.ValueType` 类派生，而 `System.ValueType` 类又是 `System.Object` 的后代。所以，我们仍然遵循面向对象的原则。尽管如此，这里似乎有类和结构体的混合。不用担心；这些都是语义问题，编译器在需要时处理它们。
- en: “Dealing with” sometimes means that the runtime converts value types into reference
    types or vice versa. That is what we call boxing and unboxing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: “处理”有时意味着运行时将值类型转换为引用类型，或者相反。这就是我们所说的装箱和拆箱。
- en: 'Boxing happens when the system converts a value type into a reference type.
    Converting a reference type into a value type is known as unboxing. Think of it
    as putting our value type in a box, in the shape of a class, or getting it out
    again if you go the other way:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统将值类型转换为引用类型时，就发生了装箱。将引用类型转换为值类型则称为拆箱。可以这样想，将我们的值类型放入一个形状为类的盒子中，或者如果你选择相反的方向，再将其从盒子中取出：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line declares a simple 32-bit integer, and we give it a value. We
    saw this previously; this is a relatively simple and fast instruction. In assembly,
    we move a hardcoded value into a DWORD position on the stack.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行声明了一个简单的 32 位整数，并给它赋值。我们之前见过；这是一条相对简单且快速的指令。在汇编中，我们将一个硬编码的值移动到栈上的 DWORD 位置。
- en: We want to make a copy of it, but this time, we use an object instead of an
    integer. Since `System.Int32` is derived from `System.Object` (with `System.ValueType`
    in between), you wouldn’t expect this to be that much work. In the end, we still
    have an integer. But things are more complicated. Again, let’s have a look at
    the assembly code. To be clear, you don’t need to know assembly, but it is easier
    to understand how to get the most performance if you know what happens under the
    hood.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要复制它，但这次我们使用对象而不是整数。由于 `System.Int32` 从 `System.Object` 派生（中间是 `System.ValueType`），你可能不会期望这需要太多工作。最终，我们仍然有一个整数。但事情更复杂。再次，让我们看看汇编代码。为了清楚起见，你不需要了解汇编，但如果你知道底层发生了什么，更容易理解如何获得最佳性能。
- en: 'Here, `object o = i` translates to quite a lot of code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`object o = i` 翻译成相当多的代码：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I won’t explain everything that’s happening here, but there are a lot of moving
    parts here. Line 3, however, is the important one: `CORINFO_HELP_NEWSFAST` is
    a method in the CLR that allocates memory on the heap. Yes, the heap. Not the
    stack. This is what we call a very expensive operation: it takes a relatively
    long amount of time. After that, much copying occurs, all of which takes time.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释这里发生的每一件事，但这里有很多动作。然而，第 3 行是重要的：`CORINFO_HELP_NEWSFAST` 是 CLR 中的一个方法，它在堆上分配内存。是的，堆。不是栈。这就是我们所说的非常昂贵的操作：它需要相对较长的时间。之后，发生了很多复制，所有这些都需要时间。
- en: 'Compare this with copying that integer variable to another integer without
    going through boxing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个与不经过装箱将整数变量复制到另一个整数变量进行比较：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This assembly code takes the value of what’s in the `i` variable (in the `[rbp+0x3C]`
    memory location) and moves it to the eax register. Then, it transfers that register
    to `[rbp+0x2C]`, where the new variable, `j`, is.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段汇编代码将变量 `i`（在 `[rbp+0x3C]` 内存位置中的值）移动到 eax 寄存器。然后，它将该寄存器的内容转移到 `[rbp+0x2C]`，那里是新的变量
    `j`。
- en: This was just two quick move calls, from the stack to the register (blazingly
    fast) and from the register back to the stack. That hardly takes time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是两个快速移动调用，从栈到寄存器（非常快）和从寄存器回到栈。这几乎不花时间。
- en: 'Going from the heap to the stack seems to be quicker since less coding is going
    on. Here, `int j = (int)o` leads to unboxing. The assembly for that code looks
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆到栈的转换似乎更快，因为这里进行的编码更少。在这里，`int j = (int)o`导致拆箱。这段代码的汇编代码如下：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This assembly code doesn’t have that very expensive call to allocate memory.
    This makes sense: the stack doesn’t require this. The stack has a fixed amount
    of memory, so you can use it if needed. If you run out of it, you get the `StackOverflow`
    exception we looked at earlier. The rest is just moving data about. There’s still
    much more code here than what we saw when we copied two integers. Still, it doesn’t
    look that bad, does it?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段汇编代码没有那个昂贵的内存分配调用。这是有道理的：栈不需要这个。栈有固定数量的内存，所以如果需要，你可以使用它。如果你用完了它，你会得到我们之前看过的`StackOverflow`异常。其余的只是移动数据。这里仍然有比我们复制两个整数时看到的更多的代码。但看起来并不那么糟糕，不是吗？
- en: 'Don’t be fooled: if we decide to use the `j` variable from now and not use
    `o` anymore, it can be removed from the heap. The garbage collector takes care
    of that, so you don’t have to worry about it. But the garbage collector also comes
    with a lot of performance loss. The garbage collector is the topic of another
    chapter but be assured it can be a huge performance drain. This isn’t obvious
    from this bit of code. There are hidden costs involved.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被骗：如果我们决定从现在开始使用`j`变量而不是再使用`o`，它可以从堆中移除。垃圾回收器会处理这件事，所以你不必担心。但是垃圾回收器也会带来很多性能损失。垃圾回收器是另一章的主题，但请放心，它可能会成为巨大的性能瓶颈。这一点从这段代码中并不明显。这里还涉及一些隐藏的成本。
- en: Hidden boxing and unboxing
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏的装箱和拆箱
- en: 'Copying a value type, such as an integer, to a reference type leads to boxing.
    If you can avoid that, you should do so. But sometimes, boxing and unboxing happen
    when you don’t expect it. Look at the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将值类型，例如整数，复制到引用类型会导致装箱。如果你能避免这种情况，你应该这样做。但有时，装箱和拆箱会在你意想不到的时候发生。看看下面的代码：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we declare an integer, `i`, in `DoSomething()`. Then, we call `DoSomethingElse()`
    with that integer. The original author of `DoSomethingElse` was trying to write
    the code so it could be reused. So, they decided to accept `System.Object` as
    a parameter. Since everything is, in the end, derived from that, this seems like
    a good idea. But it isn’t. Here, `i` will be boxed before being passed to `DoSomethingElse`,
    along with the performance penalty that happens when boxing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在`DoSomething()`中声明了一个整数`i`。然后，我们用这个整数调用`DoSomethingElse()`。`DoSomethingElse`的原作者试图编写可重用的代码。因此，他们决定接受`System.Object`作为参数。由于最终一切都是从这个派生出来的，这似乎是个好主意。但这并不正确。在这里，`i`在传递给`DoSomethingElse`之前会被装箱，并伴随着装箱时发生的性能损失。
- en: 'It would be better if the developer wrote the method like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者能像这样编写方法会更好：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, instead of accepting an object, we take a generic type. Since we pass
    it as an integer, the compiler understands that this is a value type and doesn’t
    convert it into an object. No boxing is happening here. This code is a lot faster
    than the previous version.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们不是接受一个对象，而是接受一个泛型类型。由于我们将其作为整数传递，编译器理解这是一个值类型，并且不会将其转换为对象。这里没有发生装箱。这段代码比之前的版本要快得多。
- en: How about this line of code?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码怎么样？
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It looks pretty simple. But again, boxing is happening here. Before string concatenation
    can happen, the `i` variable is first boxed to the reference type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单。但再次强调，这里发生了装箱。在字符串连接之前，`i`变量首先被装箱为引用类型。
- en: 'The next one is nice as well:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个也是不错的：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Value types are part of reference types that usually live on the heap. So, they
    need to be boxed. Getting the values back will then lead to unboxing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型是通常位于堆上的引用类型的一部分。因此，它们需要装箱。获取这些值将导致拆箱。
- en: 'Moving value types to reference types leads to this behavior. Take a look at
    the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将值类型移动到引用类型会导致这种行为。看看下面的代码：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is safe, right? We aren’t converting; we’re just declaring that we are
    interested in part of the integer that belongs to the `IComparable` interface.
    The `System.Int32` struct implements a lot of interfaces, and this happens to
    be one of them. Still, it is a struct, so all should be good.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是安全的，对吧？我们并没有进行转换；我们只是声明我们对整数的一部分感兴趣，这部分属于`IComparable`接口。`System.Int32`结构体实现了很多接口，这恰好是其中之一。尽管如此，它仍然是一个结构体，所以一切应该都很好。
- en: 'Let’s have a quick look at the associated assembly for that simple line of
    C# code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下那个简单的C#代码行的相关汇编代码：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should recognize this by now, especially the call to `CORINFO_HELP_NEWSFAST`.
    This is boxing in action. The same happens when using the `IEquatable<int> = 42`
    line. Although we now use a generic, we still get boxing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该已经认识到了这一点，特别是对`CORINFO_HELP_NEWSFAST`的调用。这是装箱操作。当使用`IEquatable<int> = 42`行时，也会发生同样的事情。尽管我们现在使用泛型，但我们仍然会遇到装箱。
- en: 'Let’s look at one more example. This one is a bit silly:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子。这个例子有点愚蠢：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have a string that we appoint to an object, `myString` (that is not
    the silly part). Then, we assign something to `stuff`, depending on `true` being
    true (which it always is; this is the silly part). If `true` is true, we assign
    `42` to stuff. If not, we copy `myString` to `var`. At first glance, you might
    expect `stuff` to be of the `int` type since `true` is always true. But that is
    not how a static-typed language works. It needs to know what type `stuff` is at
    compile time. The conditional operator, `? :`, expects both sides to be equivalent
    types. Thus, it decides that one part is an object and can cast the integer literal
    to an object. Therefore, it boxes that `42` into an object instance, and `stuff`
    here is another object instance. And there you have it: more boxing.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个字符串，我们将其分配给一个对象，`myString`（这不是愚蠢的部分）。然后，我们根据`true`为真（它总是为真；这是愚蠢的部分）将某个东西分配给`stuff`。如果`true`为真，我们将`42`分配给`stuff`。如果不为真，我们将`myString`复制到`var`。乍一看，你可能会期望`stuff`是`int`类型，因为`true`总是为真。但静态类型语言并不是这样工作的。它需要在编译时知道`stuff`的类型。条件运算符`?
    :`期望两边是等效类型。因此，它决定一部分是对象，并将整型文字转换为对象。因此，它将`42`装箱到对象实例中，而这里的`stuff`是另一个对象实例。这就是你所看到的：更多的装箱。
- en: Boxing and unboxing allow you to mix and match value and reference types. It
    would be tough to write reusable code otherwise. But be aware of this, and be
    mindful of the costs associated with boxing and unboxing. It happens in places
    you might not be aware of. And that results in less-than-stellar performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱和拆箱允许你混合和匹配值类型和引用类型。否则编写可重用代码会很困难。但要注意这一点，并注意装箱和拆箱相关的成本。它发生在你可能没有意识到的地方。这导致性能不佳。
- en: Choosing the right data structures and algorithms
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的数据结构和算法
- en: 'Object orientation is all about having the data and the operations on that
    data together in a cohesive and loosely coupled structure. That is what classes
    and structs do: they combine the two. This way, you can define your data structures
    in a way that makes sense concerning the system’s functionality.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的全部内容就是将数据和该数据上的操作在一个紧密且松散耦合的结构中放在一起。这正是类和结构体所做的事情：它们将两者结合起来。这样，你可以以对系统功能有意义的这种方式定义你的数据结构。
- en: But when speaking about performance, other factors come into play. Having static
    classes is usually a code smell that you must avoid. However, they’re fast. You
    don’t need to instantiate something, resulting in that costly call to allocate
    heap memory. And that memory doesn’t need to be cleaned by the garbage collector
    later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当谈到性能时，其他因素也会发挥作用。拥有静态类通常是一个你必须避免的代码问题。然而，它们运行得很快。你不需要实例化任何东西，从而避免了分配堆内存的昂贵调用。而且，这些内存不需要由垃圾回收器稍后清理。
- en: Of course, if you have member variables for that class, you might as well instantiate
    it. Ultimately, all that happens is that those variables end up on the heap (with
    a little bit of housekeeping). The methods themselves are part of your application
    code and are stored differently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你为那个类有成员变量，你不妨实例化它。最终，所有发生的事情就是那些变量最终出现在堆上（附带一点家务）。方法本身是应用程序代码的一部分，并且以不同的方式存储。
- en: The BCL also has many classes and data structures you can use to store data.
    Some of them are better suited for high performance than others. Which one you
    choose depends on your use case, but I think writing a bit more code is worth
    it if that means you can use a more efficient class.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: BCL（Base Class Library）也有许多类和数据结构可以用来存储数据。其中一些更适合高性能。你选择哪一个取决于你的用例，但我认为如果这意味着你可以使用更有效的类，写一点更多的代码是值得的。
- en: Arrays, Lists, and LinkedLists
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组、列表和链表
- en: '**Arrays**, **Lists**, and **LinkedLists** are all structures you can use to
    store data sequentially. That data is stored in the heap as well. Yes, you read
    that correctly. Look at the following two lines of code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**、**列表**和**链表**都是你可以用来按顺序存储数据的结构。这些数据也存储在堆上。是的，你读得对。看看以下两行代码：'
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line is a simple assignment. The system copies the hard-coded value
    of `42` (0x2A in hex) to a DWORD and stores it on the stack. The second line creates
    a new array, allocates memory for that on the heap, initializes the array, and
    then copies `42` into the first position.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个简单的赋值操作。系统将硬编码的值`42`（十六进制中的`0x2A`）复制到一个DWORD中，并将其存储在栈上。第二行创建了一个新的数组，在堆上为它分配内存，初始化数组，然后将`42`复制到第一个位置。
- en: Read that again and try to see if you can guess if there’s any boxing going
    on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再读一遍，并尝试猜测是否有任何装箱操作在进行。
- en: You might expect that there is, but there’s no boxing here. The array holds
    a pointer to a place in the heap that contains individual DWORD values. It knows
    how long each value is (32 bits, to be precise), so it can move the values directly
    without changing anything. Also, no unboxing occurs when taking an element from
    the array and storing it in a local variable. The system copies the DWORD value
    and leaves it at that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望有，但这里没有装箱。数组持有指向堆中包含单个DWORD值的内存位置的指针。它知道每个值有多长（精确到32位），因此它可以直接移动值而不做任何改变。此外，从数组中取出一个元素并将其存储在局部变量中时，不会发生解箱。系统复制DWORD值并保持原样。
- en: 'A list is the same as an array. Internally, the data is stored in an array.
    However, a list offers the option to resize it dynamically. Next to that, it has
    some nice methods such as `Add()`, `Remove()`, and `IndexOf()` that can be very
    helpful. But nothing comes for free: the methods take time to perform, and dynamic
    reallocation is very expensive in terms of performance. You must judge if you
    need those extra methods and dynamic reallocation. If you do, use a list. If you
    can go without, use an array.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表与数组相同。内部，数据存储在一个数组中。然而，列表提供了动态调整大小的选项。除此之外，它还有一些很好的方法，如`Add()`、`Remove()`和`IndexOf()`，这些方法可能非常有帮助。但没有什么是不需要付出代价的：这些方法需要时间来执行，动态重新分配在性能方面非常昂贵。你必须判断你是否需要这些额外的方法和动态重新分配。如果你需要，使用列表。如果你可以不使用它们，使用数组。
- en: 'There is an in-between solution: you can use `List<T>` and initialize it with
    an appropriate size. After all, you must do the same for an array: you need to
    know how big it is. Doing that causes the `List` class to initialize the array
    it uses internally to that exact size, and no reallocations happen – unless, of
    course, you find out you need more room. But that’s great; you don’t run out of
    memory. Yes, you get the performance penalty in that case, but that’s okay. If
    you pre-initialize the `List` class, the performance is almost identical to the
    pure, basic array.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个中间方案：你可以使用`List<T>`并用适当的大小初始化它。毕竟，你必须为数组做同样的事情：你需要知道它的大小。这样做会导致`List`类初始化它内部使用的数组到那个确切的大小，并且不会发生真正的重新分配——除非，当然，你发现你需要更多的空间。但那很好；你不会耗尽内存。是的，你会在那种情况下获得性能惩罚，但那没关系。如果你预先初始化`List`类，性能几乎与纯基本数组相同。
- en: 'The `LinkedList` class has some nice features. It is a double-linked list of
    items, which means each item is accompanied by a pointer to the next and the previous
    object. This means more data is needed to store things: we cannot just store the
    items themselves, but the system must also add those pointers. This results in
    slower behavior: those pointers must also be calculated and copied. So, you might
    think `LinkedList` is wrong when considering performance.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类有一些很好的特性。它是一个双链表，这意味着每个项目都伴随着指向下一个和前一个对象的指针。这意味着需要更多的数据来存储东西：我们不仅需要存储项目本身，系统还必须添加那些指针。这导致行为变慢：那些指针也必须被计算和复制。所以，当你考虑性能时，你可能会认为`LinkedList`是错误的。'
- en: However, `LinkedList` might be a great choice if your use case requires insertions
    and removals. Inserting an item simply means storing the object and adjusting
    some pointers. In an array or list, inserting would mean moving everything up
    one place in the internal array when you want something to sit in the middle.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的用例需要插入和删除，`LinkedList`可能是一个很好的选择。插入一个项目只是意味着存储对象并调整一些指针。在数组或列表中，插入意味着当你想要某个项目位于中间时，需要在内部数组中向上移动一个位置。
- en: Again, use your judgment. If you can, use arrays (or pre-initialized lists),
    go for the uninitialized list, and only then look at `LinkedLists`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，运用你的判断力。如果你可以，使用数组（或预先初始化的列表），选择未初始化的列表，然后才考虑`LinkedLists`。
- en: Stacks and queues
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和队列
- en: '**Stacks** and **queues** look very similar. They are more or less similar
    performance-wise, with one big difference: a stack is fast if you need to access
    the latest added items, whereas a queue is very fast when you need quick access
    to the items in the order they were entered. In other words, a stack is optimized
    for **last in, first out** (**LIFO**) scenarios, while a queue is better in **first
    in, first out** (**FIFO**) scenarios.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈** 和 **队列** 看起来非常相似。它们在性能上或多或少相似，但有一个很大的区别：如果你需要访问最新添加的项目，栈会很快，而当你需要快速访问按进入顺序排列的项目时，队列会非常快。换句话说，栈优化了
    **后进先出** (**LIFO**) 场景，而队列在 **先进先出** (**FIFO**) 场景中表现更好。'
- en: However, your code runs faster if you can think of a way to use a stack instead
    of a queue. A stack is slightly more efficient than a queue in handling its work,
    at least enough to make it worth rewriting your code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的代码可以通过使用栈而不是队列来运行得更快，那么你的代码会更快。栈在处理其工作方面比队列略有效率，至少足以使重写代码变得值得。
- en: HashSets and lists
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HashSets 和列表
- en: A `HashSet`. A `HashSet` can be efficient when you’re adding, removing, or looking
    up items.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet`。当你在添加、删除或查找项目时，`HashSet` 可以非常高效。'
- en: 'A `HashSet` has one significant advantage over a list concerning performance:
    a HashSet has a constant-time average complexity for add, delete, and search operations.
    A list, however, has a linear-time search complexity. In everyday English, a HashSet
    always takes the same time to look up items, no matter how many elements it contains.
    A list needs more search time when more items are added to it.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet` 在性能上相对于列表有一个显著的优势：`HashSet` 的添加、删除和搜索操作的平均时间复杂度是常数时间。然而，列表的搜索时间复杂度是线性的。在日常英语中，`HashSet`
    查找项目所需的时间总是相同的，无论它包含多少元素。当向列表中添加更多项目时，搜索所需的时间会更多。'
- en: 'But beware: a constant time means the time doesn’t change. This doesn’t imply
    a `HashSet` is faster! Quite the contrary: a `HashSet` can be pretty slow. And
    that makes sense: before an item is added to the `HashSet`, it needs to calculate
    the unique hash for that item. That hash is the key that’s used to store the object’s
    position. And then, it has to check if an object with that hash has already been
    added.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意：常数时间意味着时间不会改变。这并不意味着 `HashSet` 更快！恰恰相反：`HashSet` 可能相当慢。这很有道理：在将项目添加到 `HashSet`
    之前，它需要计算该项目的唯一哈希值。这个哈希值是用于存储对象位置的键。然后，它必须检查是否已经添加了具有该哈希值的对象。
- en: 'Of course, once this has been done, looking up an item is very quick: it needs
    to have the hash, and then it can find it easily. Also, when you have one of these
    two collections and need to add an item, the HashSet is faster than the list in
    many cases.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦完成这些操作，查找项目就会非常快：它需要哈希值，然后可以轻松找到它。此外，当你拥有这些两个集合之一并需要添加项目时，在许多情况下 `HashSet`
    比列表更快。
- en: As with most of these cases, look at your requirements and try to do a couple
    of benchmark tests to see what you can use best.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数这些情况一样，查看你的需求并尝试进行一些基准测试，以查看你可以使用什么最佳。
- en: SortedList, SortedDictionary, and Dictionary
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SortedList、SortedDictionary 和 Dictionary
- en: '`HashSet`, but the big difference is that you can retrieve the items by its
    key in a `Dictionary`. You can retrieve the data in the `HashSet`, but you must
    use a `foreach` statement to get them all or a `Linq` statement such as `Where()`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashSet`，但最大的区别是你可以通过其键在 `Dictionary` 中检索项目。你可以在 `HashSet` 中检索数据，但必须使用 `foreach`
    语句来获取所有项目或使用 `Linq` 语句，如 `Where()`。'
- en: 'The keys in the `SortedLis`t, `SortedDictionary`, and `Dictionary` must be
    unique. If your use case allows for that, these collections can do wonders, but
    only if you choose the right one. The following table compares these three types
    in terms of their performance:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList`、`SortedDictionary` 和 `Dictionary` 中的键必须是唯一的。如果你的用例允许这样做，这些集合可以发挥神奇的作用，但前提是你选择了正确的一个。以下表格比较了这三种类型在性能方面的差异：'
- en: '| **Property** | **Dictionary** **<****TKey, TValue>** | **SortedList** **<****TKey,
    TValue>** | **SortedDictionary <TKey,TValue>** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **Dictionary** **<****TKey, TValue>** | **SortedList** **<****TKey,
    TValue>** | **SortedDictionary <TKey,TValue>** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Underlying data structure | Hash table. | Array for keys, array for values.
    Keys are sorted. | Balanced binary search tree. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 基础数据结构 | 哈希表。 | 键的数组，值的数组。键已排序。 | 平衡的二叉搜索树。 |'
- en: '| Ordering | No ordering of elements. | Elements are sorted by key. | Elements
    are sorted by key. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 排序 | 元素无排序。 | 按键排序。 | 按键排序。 |'
- en: '| Insertion | *O(1*) average time complexity. | *O(n*) time complexity since
    it might need to shift elements to maintain order. | *O(log n)* time complexity.
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | *O(1)* 平均时间复杂度。 | *O(n)* 时间复杂度，因为它可能需要移动元素以保持顺序。 | *O(log n)* 时间复杂度。
    |'
- en: '| Deletion | *O(1)* average time complexity. | *O(n)* time complexity, for
    the same reason as insertion. | *O(log n)* time complexity. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | *O(1)* 平均时间复杂度。 | *O(n)* 时间复杂度，原因与插入相同。 | *O(log n)* 时间复杂度。 |'
- en: '| Lookup | *O(1)* average time complexity. | *O(log n)* time complexity. |
    *O(log n)* time complexity. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | *O(1)* 平均时间复杂度。 | *O(log n)* 时间复杂度。 | *O(log n)* 时间复杂度。 |'
- en: '| Memory | Generally less memory efficient than SortedList, but better than
    SortedDictionary. | More memory efficient than SortedDictionary since it uses
    arrays for the keys. | Generally less memory-efficient. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | 通常比 SortedList 内存效率低，但比 SortedDictionary 高。 | 由于它使用数组作为键，比 SortedDictionary
    内存效率更高。 | 通常内存效率较低。 |'
- en: '| Use-case | When you don’t want ordering but want fast insertions, deletions,
    and lookups. | When you have a relatively small dataset that you want to keep
    sorted and you will be doing lots of lookups. | When you have a larger dataset
    that you want to keep sorted, and you need faster insertions and deletions than
    SortedList offers. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 用例 | 当你不需要排序但需要快速插入、删除和查找时。 | 当你有一个相对较小的数据集，你希望保持排序并且将进行大量查找时。 | 当你有一个较大的数据集，你希望保持排序，并且需要比
    SortedList 提供的更快的插入和删除操作时。 |'
- en: 'Table 2.4: Key-based collections'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.4：基于键的集合
- en: Again, check your requirements and benchmarks to see what works best for you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，检查你的需求和基准测试，看看什么最适合你。
- en: Dictionary or last of tuples/objects
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典或最后的元组/对象
- en: A **List<Tuple>** and a **Dictionary** are different things, but with some rewrites,
    you could use both to achieve your goal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**List<Tuple>** 和 **Dictionary** 是不同的事物，但通过一些重写，你可以使用两者来实现你的目标。'
- en: The lookup speed in the `Dictionary` is very fast. Since you look for the key
    instead of the actual item, you can achieve a much better performance than with
    the list, where you have to iterate through the whole list to find what you need.
    Also, insertion and deletion are fast and constant when using a Dictionary.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 中的查找速度非常快。由于你查找的是键而不是实际的项目，你可以比在列表中迭代整个列表以找到所需内容时实现更好的性能。此外，使用
    Dictionary 进行插入和删除操作既快又恒定。'
- en: However, with a `Dictionary`, the keys need to be unique. With a list, this
    is not necessary. Again, with some rewrites, you might be able to use a `Dictionary`
    instead of a list and benefit from some highly-needed performance gains.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `Dictionary` 时，键必须是唯一的。使用列表则不必如此。再次强调，通过一些重写，你可能能够使用 `Dictionary` 而不是列表，并从中获得一些高度需要的性能提升。
- en: For versus ForEach
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: For 与 ForEach
- en: '**ForEach** is amazing. It helps us write our code so much faster. However,
    it can also slow down our code.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**ForEach** 是惊人的。它帮助我们更快地编写代码。然而，它也可能使我们的代码变慢。'
- en: '`ForEach` is so helpful that the people who built the compiler added all sorts
    of optimizations. ForEach does lots of work: it gets the enumerator and then enumerates
    through the collection using methods such as `MoveNext()`. They all take time,
    and you would think that it is much slower than using a `for` loop. However, these
    optimizations make the difference negligible when using For or ForEach on an array
    or `List<T>`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach` 非常有用，以至于构建编译器的人们添加了各种优化。`ForEach` 做了很多工作：它获取枚举器，然后使用 `MoveNext()`
    等方法遍历集合。这些操作都需要时间，你可能会认为它比使用 `for` 循环要慢得多。然而，这些优化使得在数组或 `List<T>` 上使用 For 或 ForEach
    时，差异微乎其微。'
- en: But suppose you use your own collection where you have implemented `IEnumerable<T>`
    and `IEnumerator<T>`. In that case, chances are the C# team did not optimize for
    that in the compiler. That might result in a slower loop than a regular `for`
    loop.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设你使用自己的集合，其中你实现了 `IEnumerable<T>` 和 `IEnumerator<T>`。在这种情况下，C# 团队可能没有在编译器中针对该操作进行优化。这可能会导致循环比常规的
    `for` 循环慢。
- en: As always, benchmark whether using the much more readable ForEach is better
    than a regular `for` loop.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，基准测试使用更易读的 ForEach 是否比常规的 `for` 循环更好。
- en: Strings
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: In the old days, strings used to be simple. You identified the length needed
    to store a sentence, allocated memory, and copied each character’s ASCII values
    in a single row. Then, you put a 0 (zero) at the end, and you were done. Easy.
    But then you realized you needed something more dynamic as you were unsure how
    long the string would be. So, you wrote code to change the buffer required to
    store it. You also realized that you needed to have some operations on those characters.
    For instance, you might have wanted to know how long the string was and not have
    to count the characters every time, or maybe you wanted to convert all characters
    into uppercase. So, you wrote code for that as well. At that point, you had some
    data in the form of characters (with the zero at the end) and some methods on
    that data. That is the definition of a class, so in C++, you write a `String`
    class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，字符串很简单。你确定存储一个句子所需的长度，分配内存，然后在一行中复制每个字符的ASCII值。然后，你在末尾放一个0（零），这样就完成了。很简单。但后来你意识到你需要更动态的东西，因为你不确定字符串会有多长。所以，你编写了代码来改变存储它的缓冲区大小。你也意识到你需要对这些字符进行一些操作。例如，你可能想知道字符串有多长，而不用每次都数字符，或者你可能想将所有字符转换为大写。所以，你也为此编写了代码。到那时，你有一些以字符形式存在的数据（末尾有一个零）和一些数据上的方法。这就是类的定义，所以在C++中，你编写一个`String`类。
- en: 'Things got even more complicated when you realized that other cultures used
    other characters. Luckily, others also realized this, so they created the **Unicode
    standard**. But now, instead of storing a single byte per character, you must
    store a Unicode character. And that can be anything from 8 bits (in UTF-8) to
    4 bytes. Then, you learned that although a single character can take 32 bits,
    that is technically incorrect: that applies to code points. A code point usually
    *is* the character, but sometimes, it isn’t. In those situations, the character
    you want to display has multiple code points in the string. That’s when most people
    give up.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到其他文化使用其他字符时，事情变得更加复杂。幸运的是，其他人也意识到了这一点，所以他们创建了**Unicode标准**。但现在，你必须存储一个Unicode字符，而不是每个字符一个字节。这可以是8位（在UTF-8中）到4个字节。然后，你了解到虽然单个字符可以占用32位，但这在技术上是不正确的：这适用于码点。码点通常*是*字符，但有时，它不是。在这些情况下，你想要显示的字符在字符串中有多个码点。这就是大多数人放弃的时候。
- en: 'The good news is that you no longer have to worry about that since we have
    the `System.String` class in .NET. It takes care of all of those details, and
    they look deceivingly simple. Assigning a sentence to an instance of that `String`
    class is as simple as the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你再也不必为此担心了，因为我们有.NET中的`System.String`类。它负责所有这些细节，而且看起来欺骗性地简单。将一个句子赋值给`String`类的实例就像以下代码一样简单：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line assigns `"Hello, World!"` to the `someMessage` variable. When
    we do this, the compiler generates all the code necessary to create an instance
    of the `System.String` class and initializes it with the correct text.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将`"Hello, World!"`赋值给`someMessage`变量。当我们这样做时，编译器会生成所有必要的代码来创建`System.String`类的一个实例，并用正确的文本初始化它。
- en: 'The following two lines contain the same Unicode characters: a friendly smiley.
    The first uses the Unicode character, while the second uses the actual character.
    Yes, this is valid C#!'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行包含相同的Unicode字符：一个友好的笑脸。第一行使用Unicode字符，而第二行使用实际的字符。是的，这是有效的C#！
- en: 'Strings are reference types, so they live on the heap. We learned that the
    heap is slower than the stack earlier, but we have no choice in this case. The
    pointer is copied when we copy a reference type to a new variable. This means
    we have two variables pointing to the same data structure. This also happens when
    we copy a string: a new pointer is made and points to that class’s same instance.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是引用类型，所以它们存在于堆上。我们之前学到堆比栈慢，但在这个情况下我们没有选择。当我们复制引用类型到一个新变量时，指针会被复制。这意味着我们有两个变量指向相同的数据结构。当我们复制字符串时也会发生这种情况：创建一个新的指针并指向那个类的相同实例。
- en: Strings are immutable. You cannot change the contents of a string. If you do
    that, the CLR creates a new string, and the old one is ready to be garbage collected.
    Again, this might lead to unwanted performance issues.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的。你不能改变字符串的内容。如果你这样做，CLR会创建一个新的字符串，而旧的字符串则准备好被垃圾回收。这再次可能导致不希望的性能问题。
- en: There are some other things we must consider when talking about string performance.
    Let’s go through them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论字符串性能时，我们必须考虑一些其他的事情。让我们来看看它们。
- en: Use StringBuilder for concatenation
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用StringBuilder进行连接
- en: 'When talking about string performance, this one gets the most attention. And
    for good reason: this simple “trick” can help get your application faster. The
    idea is that when you’re in a loop, do not concatenate strings. Create a `StringBuilder`
    object and use that. The difference in performance is enormous. And that makes
    sense: changing a string is impossible, so each time you add to one, a new one
    is created, the content is copied with the added string on top of it, and the
    old one is discarded.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到字符串性能时，这一点最受关注。而且有很好的理由：这个简单的“技巧”可以帮助你的应用程序更快。想法是在循环中，不要连接字符串。创建一个`StringBuilder`对象并使用它。性能差异是巨大的。这很有道理：字符串的更改是不可能的，所以每次添加到字符串时，都会创建一个新的字符串，内容是添加的字符串，并且旧的字符串被丢弃。
- en: Use `StringBuilders` in loops. You can go ahead and just do it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用`StringBuilders`。你可以继续这样做。
- en: Interning strings
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串的内部化
- en: 'Strings are interned. If you have a string in your code and the actual text
    is known at compile time, any other string with the same content will point to
    the same class. Have a look at this code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串被内部化。如果你的代码中有一个字符串，并且实际的文本在编译时已知，任何具有相同内容的其他字符串都将指向同一个类。看看这段代码：
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you run this code, you will get a message stating that both strings point
    to the same memory location.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你会得到一条消息，说明这两个字符串指向相同的内存位置。
- en: But if you read the contents of both strings from the console, use `Console.ReadLine()`.
    If you enter the same string twice, they will not be interned. This is because
    interning happens at compile time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你从控制台读取两个字符串的内容，使用`Console.ReadLine()`。如果你输入相同的字符串两次，它们将不会被内部化。这是因为内部化是在编译时发生的。
- en: You could call `String.Intern` yourself. This checks to see if the string you
    wish to intern is already there, and if so, it makes it point to that instead
    of having its own copy. This could save a lot of memory, but it has a performance
    penalty. So, use it wisely.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己调用`String.Intern`。这将检查你想要内部化的字符串是否已经存在，如果存在，它将使其指向那个位置，而不是拥有自己的副本。这可以节省大量的内存，但会有性能上的损失。所以，要明智地使用它。
- en: Use String.Concat or String.Join
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`String.Concat`或`String.Join`
- en: I said that you should use `StringBuilder` when joining strings in a loop. But
    creating a `StringBuilder` object is a bit overkill if you’re outside a loop and
    only want to add to a string once. In that case, you should use `String.Concat`
    or `String.Join`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我说当你在循环中连接字符串时应该使用`StringBuilder`。但是如果你不在循环中，只想向字符串添加一次，创建一个`StringBuilder`对象就有点过度了。在这种情况下，你应该使用`String.Concat`或`String.Join`。
- en: 'Just to be clear here: if you are looping, use `StringBuilder`. The `StringBuilder`
    object is the fastest way to concatenate strings. But creating an instance of
    a `StringBuilder` class takes time (it is a class, thus on the heap). If you only
    want to add one or two strings to an existing one, `String.Concat` is faster overall
    than having a `StringBuilder` object.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了清楚起见：如果你在循环中，使用`StringBuilder`。`StringBuilder`对象是连接字符串最快的方式。但是创建一个`StringBuilder`类的实例需要时间（它是一个类，因此位于堆上）。如果你只想向现有的字符串添加一个或两个字符串，`String.Concat`在整体上比使用`StringBuilder`对象更快。
- en: 'That looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE18]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `String.Join` object is another good way to build up strings. You can use
    this one when you want to combine a collection of items into one string. The list
    of items can be anything since the CLR calls `ToString()` on them. Here, `ToString()`
    needs to make sense; otherwise, you’ll get a long list of class names.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`String.Join`对象是构建字符串的另一种好方法。当你想要将一组项目组合成一个字符串时，可以使用这个方法。项目列表可以是任何东西，因为CLR会调用它们的`ToString()`方法。在这里，`ToString()`需要有意义；否则，你会得到一个长长的类名列表。'
- en: 'It looks like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE19]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Printing `result` will show `C#,VB.Net,F#,Delphi.Net` on your screen.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`result`将在你的屏幕上显示`C#,VB.Net,F#,Delphi.Net`。
- en: Be careful what you use as the list of elements. If those are `ValueTypes`,
    a lot of boxing happens. That negates our performance gain when using the suitable
    string methods.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你用作元素列表的内容。如果那些是`ValueTypes`，会发生大量的装箱。这抵消了我们使用合适的字符串方法时的性能提升。
- en: Comparison
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较
- en: 'Chances are that you have to compare strings in your code. There are several
    ways to improve your performance when doing that. For instance, taking into account
    a culture takes a lot longer compared to not doing that. If you don’t need a culture-specific
    check, you should specify that. The same goes for the casing: if you don’t care
    about the casing when comparing, please don’t use one of the comparisons that
    take care of that.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 很有可能你需要在代码中比较字符串。在这样做时，有几个方法可以提高你的性能。例如，考虑到文化因素比不考虑文化因素要花费更长的时间。如果你不需要特定的文化检查，你应该指定这一点。同样，对于
    casing：如果你在比较时不关心 casing，请不要使用那些处理 casing 的比较。
- en: 'There are several ways to compare strings. The most obvious one is the equality
    operator:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符串有几种方法。最明显的是相等运算符：
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, there’s no comparison at all. Since the compiler interns the strings,
    the pointers point to the same data. The equality checks for that and returns
    `true`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，根本不需要比较。由于编译器会内联字符串，指针指向相同的数据。对于这种情况的相等检查会返回 `true`。
- en: 'You could also do it like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样做：
- en: '[PRE21]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code does the same thing, with the same caveat concerning the interning.
    Here, `operator == calls Equals()`, so it shouldn’t be surprising that the results
    are the same, with the same performance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做的是同样的事情，同样需要注意内联的问题。这里，`operator ==` 调用 `Equals()`，所以结果相同，性能也相同。
- en: 'Now, look at this code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这段代码：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This way of comparing is significantly slower than the previous examples. The
    CLR now has to compare the strings in all their different appearances: in all
    sorts of cultures and all casings.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较方式比之前的例子慢得多。CLR现在必须比较字符串的所有不同形式：在所有 sorts of cultures 和所有 casing 中。
- en: This way works brilliantly if you need it, but if you don’t, please omit the
    options!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要它，这种方法非常好，但如果你不需要，请省略选项！
- en: 'I see many people writing this sort of code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到很多人编写这种代码：
- en: '[PRE23]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This way of comparing is the worst way of doing this. Calling `ToUpper()` doesn’t
    convert a string into all uppercase. Instead, it creates a new string with all
    uppercase characters. Again, strings are immutable, so the runtime creates a new
    one whenever you change something. Here, we are doing that twice so that we can
    compare them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较方式是做这件事最糟糕的方式。调用 `ToUpper()` 并不会将字符串转换成全部大写。相反，它创建了一个包含所有大写字符的新字符串。再次强调，字符串是不可变的，所以每次你更改内容时，运行时都会创建一个新的字符串。这里我们做了两次，以便进行比较。
- en: Using `StringComparison.IgnoreCase` is about five times as fast compared to
    calling `ToUpper()` (or `ToLower()` for that matter).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `StringComparison.IgnoreCase` 比调用 `ToUpper()`（或 `ToLower()`）快五倍。
- en: Preallocating StringBuilder
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预先分配 StringBuilder
- en: 'One final tip: knowing the length of the resulting string when using `StringBuilder`
    helps tremendously if you tell that class about that. Preallocating helps optimize
    the code and reduces many allocations, resulting in better performance.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点建议：当使用 `StringBuilder` 时，如果你知道结果的字符串长度，这会非常有帮助。预先分配有助于优化代码并减少许多分配，从而提高性能。
- en: Writing unsafe code
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写不安全代码
- en: A word of warning before we start talking about unsafe code. There is a reason
    it is called “unsafe.” You could be in for much trouble when you leave safe code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论不安全代码之前，有一个警告。这就是为什么它被称为“不安全”。当你离开安全代码时，你可能会遇到很多麻烦。
- en: The CLR checks many things for you when you run your code. For instance, it
    ensures type safety and ensures you are not playing around with spaces in memory
    that are not yours to play with.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，CLR会为你检查很多事情。例如，它确保类型安全，并确保你不会在内存中玩弄不属于你的空间。
- en: 'In the “old” days, when using C++ or C in Windows development, this was the
    primary source of program crashes. Developers made a slight mistake in their pointer
    arithmetic and ended up reading or writing memory they had no access to. The operating
    system immediately killed your process, and you got that dreaded `AccessViolationException`
    error. This is the ultimate slap on the wrist: the operating system telling you
    to stay out of someone else’s memory. Sometimes, it would be worse: the operating
    system might not have caught it, and you messed up the operating system or another
    program. That could lead to even worse situations: the whole machine could crash.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在“旧”的日子里，当在 Windows 开发中使用 C++ 或 C 时，这是程序崩溃的主要来源。开发者们在指针运算中犯了一点小错误，最终读取或写入他们没有访问权限的内存。操作系统立即终止你的进程，你得到了那个令人讨厌的
    `AccessViolationException` 错误。这是最后的警告：操作系统告诉你不要进入别人的内存。有时，情况会更糟：操作系统可能没有捕捉到它，而你搞砸了操作系统或另一个程序。这可能导致更糟糕的情况：整个机器可能崩溃。
- en: The safe environment of the CLR in .NET has practically removed that completely.
    The CLR governs everything you do and ensures you stay in the areas where you
    are allowed to stay.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 中 CLR 的安全环境实际上完全消除了这一点。CLR 控制你做的每一件事，并确保你留在被允许停留的区域。
- en: You’ve probably realized that this is nice, but checking what’s happening always
    has a performance hit. Nothing comes for free. We give up some performance in
    exchange for a stable system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到这很好，但检查所发生的事情总是会有性能损失。没有什么是免费的。我们为了稳定的系统而放弃了一些性能。
- en: If you want that performance back, you could tell the CLR to stay out of your
    way. The CLR will obey and hand over the reins to you. Again, you are on your
    own and responsible for not messing things up. But things run a bit faster now!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要恢复性能，你可以告诉 CLR 不要干涉你的方式。CLR 将会服从并将控制权交给你。再次强调，你现在完全独立，并负责不要搞砸事情。但现在运行得更快了！
- en: Let’s consider an example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。
- en: An array is a pointer to a consecutive list of items. So, `int[1000]` is just
    a pointer to a long list of a thousand integers, all nicely lined up.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是指向连续项目列表的指针。所以，`int[1000]` 只是指向一个由一千个整数组成的很长列表的指针，所有这些整数都整齐排列。
- en: You can access these items in the list by giving the array the index of the
    item you want. First, the CLR checks if the array has been initialized and not
    pointing to some weird random place in memory. Then, it checks if your index falls
    in the range that the CLR allocated for the array. If that checks out, it gets
    and returns the item for you. Nice.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过给数组提供你想要的项目索引来访问列表中的这些项。首先，CLR 会检查数组是否已初始化并且没有指向内存中的某个奇怪随机位置。然后，它会检查你的索引是否在
    CLR 为数组分配的范围内。如果检查无误，它会为你获取并返回项目。很好。
- en: 'The following code example iterates through the array and adds up all the values:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例遍历数组并计算所有值之和：
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This piece of code works nicely, but it can be faster. All those checks take
    time, and we might decide we don’t need them. We tell the CLR to take a break
    and leave it all to us!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行得很好，但可以更快。所有这些检查都需要时间，我们可能决定我们不需要它们。我们告诉 CLR 休息一下，让它全部由我们来处理！
- en: 'The following snippet shows how to do this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段展示了如何做到这一点：
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We declare the block we want to optimize with the `unsafe` keyword. Everything
    in that block is now no longer checked.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `unsafe` 关键字声明我们想要优化的代码块。该块中的所有内容现在将不再进行检查。
- en: Then, we retrieve the pointer to the array. We mark it as `fixed`. This keyword
    means the garbage collector doesn’t move the array until we are done with it.
    It would be disastrous if the garbage collector moved the array to another place
    in memory when we accessed it. The `fixed` keyword prevents that.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检索数组的指针。我们将其标记为 `fixed`。这个关键字意味着垃圾收集器在我们完成之前不会移动数组。如果我们访问它时垃圾收集器将数组移动到内存中的另一个位置，那将是灾难性的。`fixed`
    关键字防止这种情况发生。
- en: Then, we get the pointer to the end of the array in memory so that we know when
    to end. In the `for` loop, we get the pointer to the elements, read the data at
    that memory position, and add the `sum` variable.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在内存中获取数组的末尾指针，以便我们知道何时结束。在 `for` 循环中，我们获取元素的指针，读取该内存位置的数据，并将 `sum` 变量相加。
- en: This piece of code works fine. It is also faster than the safe version. But
    just for fun, mess around a bit with the pointers. Instead of letting it end at
    the end of the array, let it end at that position plus `0xFFFF`. Now, there is
    no way to tell what’s going to happen. It might continue reading past the end
    of the array, getting all those byes and adding them to `sum`. That would mean
    you are getting the wrong result. It is more likely that you get the `AccessViolationException`
    error, followed by your program being terminated.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行正常。它也比安全版本要快。但为了好玩，我们可以稍微玩一下指针。不要让它结束在数组的末尾，让它结束在当前位置加上 `0xFFFF`。现在，没有办法知道会发生什么。它可能会继续读取数组末尾之后的内容，将所有这些字节加到
    `sum` 上。这意味着你得到了错误的结果。更有可能的是，你会得到 `AccessViolationException` 错误，然后你的程序被终止。
- en: We use unsafe code to improve performance, such as in the preceding example,
    but also when we need to interact with native libraries written in C/C++. But
    if you can avoid it without sacrificing performance too much, please do.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不安全代码来提高性能，例如在前面示例中，以及当我们需要与用 C/C++ 编写的本地库交互时。但如果在不牺牲太多性能的情况下可以避免，请尽量避免。
- en: Compiler optimizations
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器优化
- en: 'I have said it before and will repeat it here: don’t try to outsmart the compiler.
    The C# compiler is a fantastic piece of software that can do tricks we can’t even
    think of. But sometimes, we can help the compiler make choices that affect performance
    in a good way.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经说过，现在再重复一遍：不要试图欺骗编译器。C# 编译器是一块非常出色的软件，可以做到我们甚至无法想象的事情。但有时，我们可以帮助编译器做出影响性能的良好选择。
- en: Aggressive optimization
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 侵略性优化
- en: 'Look at the following method:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的方法：
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I am sure you agree that this is not an exciting method. Calling this, however,
    does take a lot of time: the calling method has to store the return address, move
    all parameters (the integer values, `a` and `b`) to the right place, jump to the
    method, retrieve the parameters, do the actual work, store the return value in
    the right place, retrieve the return address, jump to that return address, and
    assign the result to the variable in the calling method.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你同意这并不是一个令人兴奋的方法。然而，调用它却需要花费很多时间：调用方法必须存储返回地址，将所有参数（整数值，`a` 和 `b`）移动到正确的位置，跳转到方法，检索参数，执行实际工作，将返回值存储在正确的位置，检索返回地址，跳转到那个返回地址，并将结果赋值给调用方法中的变量。
- en: 'The compiler knows this. So, in this particular case, it will probably optimize
    it and “inline” it. But if you think the compiler doesn’t know about this, you
    can instruct it to take a closer look at the code and be a bit more aggressive
    about it. You do that like so:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器知道这一点。所以，在这种情况下，它可能会优化它并“内联”它。但如果你认为编译器不知道这一点，你可以指示它更仔细地查看代码，并对此更加积极。你可以这样做：
- en: '[PRE27]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This tells the compiler to be aggressive when optimizing the code. This is
    a hint to the compiler: there is no guarantee it will do what you ask. But in
    this case, it will probably honor your request (again, it would likely have done
    it already) and inline the method.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器在优化代码时要积极。这是一个对编译器的提示：没有保证它会按照你的要求去做。但在这个例子中，它可能会尊重你的请求（再次强调，它可能已经这样做了）并内联方法。
- en: Inlining means it takes the method’s body and injects it into the calling method
    directly. So, instead of all this copying and moving I described previously, it
    will now execute the code inline, as if it is part of the original method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 内联意味着它将方法体直接注入到调用方法中。所以，现在它将执行代码内联，就像它是原始方法的一部分一样。这是之前我描述的所有复制和移动操作。
- en: 'This is way faster, of course. It also means your original method gets bigger:
    it now contains that extra bit of code, as do all the other methods that use this
    `AddUp()` method. It gets copied all over the place.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然要快得多。这也意味着你的原始方法变大了：它现在包含那额外的代码片段，所有使用这个 `AddUp()` 方法的其他方法也是如此。它被复制到各个地方。
- en: 'It is a matter of choice: more performance over less efficient memory usage.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个选择的问题：更多的性能与更高效的内存使用。
- en: The optimize flag
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化标志
- en: The compiler can optimize your code. But it doesn’t always do that. You can
    add the `optimize` flag to the compiler to force optimization.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以优化你的代码。但它并不总是这样做。你可以添加 `optimize` 标志到编译器来强制优化。
- en: 'There are several ways to do that. First, you can add it to the command line
    if you use that to build your code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点。首先，如果你使用命令行来构建你的代码，你可以将其添加到命令行中：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Alternatively, you can use `MSBuild`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `MSBuild`：
- en: '[PRE29]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: They both achieve the same result.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它们两者都达到了相同的结果。
- en: 'You could also set it as an option in your `CSProj` file. The best way to do
    that is to add it to the project properties:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`CSProj`文件中将它设置为选项。这样做最好的方式是将它添加到项目属性中：
- en: '![Figure 2.1: The project properties showing the Optimize code option](img/B20924_03_01.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1：显示优化代码选项的项目属性](img/B20924_03_01.jpg)'
- en: 'Figure 2.1: The project properties showing the Optimize code option'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：显示优化代码选项的项目属性
- en: As you can see, you can set **Optimize code** for **Debug** and **Release**.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以为**调试**和**发布**设置**优化代码**。
- en: 'This will add or change the following setting to your `.``csproj` file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的`.csproj`文件中添加或更改以下设置：
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It’s good to know that by default, programs compiled in the **Debug** configuration
    have optimizations turned off. In contrast, programs compiled in the **Release**
    configuration have it turned on.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 好知道默认情况下，以**调试**配置编译的程序关闭了优化。相比之下，以**发布**配置编译的程序则开启了优化。
- en: When debugging, you are better off using non-optimized code. When releasing,
    the opposite applies.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，使用非优化代码会更好。在发布时，情况则相反。
- en: Next steps
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Performance – that was what this chapter was all about. We learned why it is
    crucial, especially for system programming, to write software that is as fast
    and efficient as possible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 性能——这正是本章的主题。我们了解到为什么编写尽可能快和高效的软件对于系统编程至关重要。
- en: First, we looked at the BCL and the CLR and saw how the different data types
    can affect performance, but also that things don’t always behave as expected.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查了 BCL 和 CLR，并看到了不同数据类型如何影响性能，但也看到了事情并不总是像预期的那样表现。
- en: Then, we examined the types in the CTS and identified which types give us the
    best-performing systems and what to avoid. We spent quite some time in the `Strings`
    class. We also learned how to rewrite our code so that it uses the best tools
    this class gives us to make it behave faster.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了 CTS 中的类型，并确定了哪些类型能给我们带来最佳性能以及应该避免什么。我们在`Strings`类上花费了不少时间。我们还学习了如何重写我们的代码，以便使用这个类提供的最佳工具使其运行更快。
- en: After, we dove into the dark underworld of unsafe types and saw that they could
    give us even more performance but with the downside of the possibility of crashing
    our application, or even our system, in the most spectacular way.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们深入到不安全类型的黑暗世界中，并看到它们可以给我们带来更多的性能，但代价是可能以最壮观的方式崩溃我们的应用程序，甚至我们的系统。
- en: Finally, we looked at ways to help the compiler make our systems even faster.
    Here, we learned that the compiler is smart enough to make those changes. It’s
    worth repeating that you shouldn’t try to outsmart the system. You really should
    only use the unsafe code and compiler tricks if benchmarking shows that you have
    an issue. Otherwise, leave those two alone. However, they are good tricks to understand
    if you do need them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了帮助编译器使我们的系统更快的方法。在这里，我们了解到编译器足够智能，可以做出这些改变。值得重复的是，你不应该试图超越系统。你真的应该只在基准测试显示你有问题时才使用不安全代码和编译器技巧。否则，让这两者保持原样。然而，如果你确实需要它们，了解这些技巧是很好的。
- en: However, better performance often leads to less efficient memory usage. It is
    a trade-off. Sometimes, it is better to have a more memory-efficient system than
    it is to have a fast system. Sometimes, you have to mix and match. In the next
    chapter, we’ll consider memory and cover these aspects in greater detail.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更好的性能往往会导致内存使用效率降低。这是一个权衡。有时，拥有一个更内存高效的系统比拥有一个快速的系统更好。有时，你必须混合使用。在下一章中，我们将考虑内存并更详细地探讨这些方面。
