<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor116" class="pcalibre1 pcalibre calibre6"/>6</h1>
<h1 id="_idParaDest-115" class="calibre5"><a id="_idTextAnchor117" class="pcalibre1 pcalibre calibre6"/>Introduction to Object Pooling in Unity 2022</h1>
<p class="calibre3">In <a href="B18347_05.xhtml#_idTextAnchor096" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 5</em></a>, we imported and prepped artwork for use with additional 2D animation tooling, which is bringing the game to life. We also processed player input using an input action map – instead of reading device input directly – with the new Input System, and we made a <code>PlayerController</code> script to move the player.</p>
<p class="calibre3">We dove deeper into Mecanim as we learned how to transition between animations and drive animation state changes from code.</p>
<p class="calibre3">In this chapter, you will be introduced to object pooling while we use this optimization pattern for the player’s shooting mechanic, and we’ll accomplish that using Unity’s object pooling API. The object pooling software design will be based on a pooled player shooting model UML diagram.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">The object pooling pattern</li>
<li class="calibre15">A pooled player shooting model</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to create an optimized shooting mechanic for a ranged weapon.</p>
<h1 id="_idParaDest-116" class="calibre5"><a id="_idTextAnchor118" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter with the same artwork created for the project in the book, download the assets from the following GitHub link: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6</a>.</p>
<p class="calibre3">To follow along with your own artwork, you’ll need to create similar artwork using Adobe Photoshop, or a graphics program that can export layered Photoshop PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).</p>
<p class="calibre3">You can download the complete project on GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor119" class="pcalibre1 pcalibre calibre6"/>The object pooling pattern</h1>
<p class="calibre3">The <strong class="bold">object pooling</strong> design<a id="_idIndexMarker618" class="pcalibre1 pcalibre calibre6"/> pattern is a type of <strong class="bold">creational</strong> or <strong class="bold">abstract factory</strong> design<a id="_idIndexMarker619" class="pcalibre1 pcalibre calibre6"/> pattern that uses a stack to <a id="_idIndexMarker620" class="pcalibre1 pcalibre calibre6"/>hold a collection of initialized object instances. It is excellent for use in situations when you will have either a large number of objects that need to be spawned or objects that will be created and destroyed rapidly.</p>
<p class="calibre3">Since we will be shooting projectile objects from a weapon – which can be performed at a high rate by the player – this is a great place to apply object pooling because repeatedly instantiating and destroying objects comes with a high cost. In this case, object pooling provides a way to optimize <a id="_idIndexMarker621" class="pcalibre1 pcalibre calibre6"/>CPU, memory, and <strong class="bold">garbage </strong><strong class="bold">collection</strong> (<strong class="bold">GC</strong>).</p>
<p class="calibre3">Rather than creating a new projectile object directly every time the player needs to shoot, we’ll instead reuse an already instantiated projectile object by requesting it from the objects in the pool. As such, the Object Pool provides methods for requesting (getting) and returning (releasing) objects. So, for example, for a pool of 10 projectile objects, we’ll get one at a time from the pool when the player shoots and return the projectile that was shot when it expires (e.g., hit something).</p>
<p class="calibre3">If you recall from <a id="_idIndexMarker622" class="pcalibre1 pcalibre calibre6"/>our <strong class="bold">Game Design Document</strong> (<strong class="bold">GDD</strong>) in <a href="B18347_04.xhtml#_idTextAnchor079" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, specifically <em class="italic">Table 4.1</em>, we defined shooting capabilities, so we’ll use object pooling to implement this mechanic in a performant and optimized way, using Unity’s <a id="_idIndexMarker623" class="pcalibre1 pcalibre calibre6"/>new <strong class="bold">object </strong><strong class="bold">pooling</strong><strong class="bold"> API</strong>.</p>
<h2 id="_idParaDest-118" class="calibre8"><a id="_idTextAnchor120" class="pcalibre1 pcalibre calibre6"/>The Unity object pooling API</h2>
<p class="calibre3">Unity has added <a id="_idIndexMarker624" class="pcalibre1 pcalibre calibre6"/>a new namespace to the <a id="_idIndexMarker625" class="pcalibre1 pcalibre calibre6"/>engine – <code>UnityEngine.Pool</code> – that includes several new classes to implement the object pooling pattern. For our requirement of a weapon to shoot bullets, we’ll use the <code>ObjectPool&lt;T0&gt;</code> class.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout"><strong class="source-inline1">ObjectPool&lt;T0&gt;</strong>: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Pool.ObjectPool_1.xhtml</a></p>
<p class="calibre3">The following is a list of required actions we’ll need when working with the object pool:</p>
<ul class="calibre17">
<li class="calibre15"><code>Creating</code> (instantiating): Making a new object instance in the pool available.</li>
<li class="calibre15"><code>Getting</code> (requesting): Retrieving an available object instance from the pool (or creating and returning a new one if more are needed).</li>
<li class="calibre15"><code>Releasing</code> (returning): Putting an active object instance back into the pool for reuse when it’s finished with.</li>
<li class="calibre15"><code>Destroying</code> (removing): Removing an instantiated object from the pool completely if it grows over its size limit.</li>
</ul>
<p class="calibre3">Thankfully, or by design, the <code>ObjectPool&lt;T0&gt;</code> class provides everything we need, such as creating a<a id="_idIndexMarker626" class="pcalibre1 pcalibre calibre6"/> pool and taking and returning<a id="_idIndexMarker627" class="pcalibre1 pcalibre calibre6"/> items to the pool. Now, let’s create a new object pool for our projectiles.</p>
<h2 id="_idParaDest-119" class="calibre8"><a id="_idTextAnchor121" class="pcalibre1 pcalibre calibre6"/>Creating a new object pool</h2>
<p class="calibre3">Let’s have a look <a id="_idIndexMarker628" class="pcalibre1 pcalibre calibre6"/>at the following code that creates a new object pool of <code>BulletPrefab</code> projectiles (of type <code>ProjectileBase</code>; there’ll be more on this shortly in the <em class="italic">Creating the pooled player shooting </em><em class="italic">model</em> section):</p>
<pre class="source-code">
private void Start()
{
    _poolProjectiles = new ObjectPool&lt;ProjectileBase&gt;(
        CreatePooledItem, OnGetFromPool,
        OnReturnToPool, OnDestroyPoolItem,
        collectionCheck: false,
        defaultCapacity: 10,
        maxSize: 25);
    ProjectileBase CreatePooledItem() =&gt;
        Instantiate(_weapon1.BulletPrefab);
    void OnGetFromPool(ProjectileBase projectile) =&gt;
        projectile.gameObject.SetActive(true);
    void OnReturnToPool (ProjectileBase projectile) =&gt;
        projectile.gameObject.SetActive(false);
    void OnDestroyPoolItem(ProjectileBase projectile) =&gt;
        Destroy(projectile.gameObject);
}</pre> <p class="calibre3">In the preceding<a id="_idIndexMarker629" class="pcalibre1 pcalibre calibre6"/> code, we can see a method (a local function in this case) declared for each of the required <code>ObjectPool</code> parameters, corresponding to the actions we listed previously.</p>
<p class="callout-heading">A local function (C#)</p>
<p class="callout">The new <strong class="source-inline1">ObjectPool</strong> creation code uses local functions instead of a common approach, using lambdas (anonymous delegates), so that we, for one, avoid unnecessary memory allocations. We create a local function by declaring a method inside the body of an already existing method; this also limits the scope of a local function to only being able to be called from within the method, which promotes encapsulation over using private member methods (we don’t need these methods outside the scope of setting up the object pool, and they only need to be called once).</p>
<p class="callout">A delegate has to be created when using a lambda, which is an unnecessary allocation if a local function is used. Allocations to capture local variables are also avoided, as local functions are really just functions; no delegates are necessary. In addition, calling a local function is also cheaper, and performance can be increased even further if in-lined by the compiler (eliminating call-linkage overhead).</p>
<p class="callout">Also, local functions just look better! They provide better code readability and verbose parameter names – a lambda anonymous delegate would obscure each parameter type! (Can you tell I’m just a bit biased here?)</p>
<p class="callout">Here’s some additional reading on the subject: <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions" class="pcalibre1 pcalibre calibre6">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/local-functions</a>.</p>
<p class="callout">Here are some interesting design notes from when local functions were added to C# 7: <a href="https://github.com/dotnet/roslyn/issues/3911" class="pcalibre1 pcalibre calibre6">https://github.com/dotnet/roslyn/issues/3911</a>.</p>
<p class="calibre3">I’ve declared the<a id="_idIndexMarker630" class="pcalibre1 pcalibre calibre6"/> following local functions within the <code>Start()</code> method:</p>
<ul class="calibre17">
<li class="calibre15"><code>CreatePooledItem</code>: This will instantiate an object of type <code>ProjectileBase</code> when a new item is needed. This is a bullet Prefab we have a reference to on the player’s weapon.</li>
<li class="calibre15"><code>OnGetFromPool</code>: We’ll use <code>_poolProjectiles.Get()</code> to return a <code>ProjectileBase</code> object instance, while this method calls <code>gameObject.SetActive(true)</code> to enable the object for use.</li>
<li class="calibre15"><code>OnReturnToPool</code>: Calling <code>_poolProjectiles.Release(projectile)</code> will execute <code>projectile.gameObject.SetActive(false)</code> on the object instance passed in, making sure it’s inactive (disabled) while sitting in the pool waiting to be retrieved.</li>
<li class="calibre15"><code>OnDestroyPoolItem</code>: Calling <code>Destroy(projectile.gameObject)</code> when an item is removed from the pool means the object will no longer exist in the scene.</li>
</ul>
<p class="calibre3">To clarify some of the preceding actions, <em class="italic">instantiate</em> means an object is created and exists in the Scene. When the instantiated object’s active state is <code>SetActive(true)</code>, it is visible in the Scene, and code is executed.</p>
<p class="calibre3">Setting the<a id="_idIndexMarker631" class="pcalibre1 pcalibre calibre6"/> GameObject as <code>SetActive(false)</code> will ensure that it doesn’t display in the Scene, and for each component, the <code>Update()</code> method will no longer be called.</p>
<h2 id="_idParaDest-120" class="calibre8"><a id="_idTextAnchor122" class="pcalibre1 pcalibre calibre6"/>Additional parameters affecting the object pool</h2>
<p class="calibre3">Beyond the<a id="_idIndexMarker632" class="pcalibre1 pcalibre calibre6"/> preceding action methods, we have three additional parameters that affect how the pool functions. They are as follows:</p>
<ul class="calibre17">
<li class="calibre15"><code>collectionCheck</code>: We can save some CPU cycles if we set this parameter to <code>false</code>, as it won’t check whether an object was returned to the pool already (be cautious with this value, since it will throw errors if you try to release an item already in the pool).</li>
<li class="calibre15"><code>defaultCapacity</code>: You should set this value to the number of projectiles we’ll generally need to have available on screen simultaneously (you can best determine this number by playtesting the rate of fire).</li>
<li class="calibre15"><code>maxSize</code>: This value will prevent the pool from growing too large and getting out of hand. Any instances above this number will be destroyed instead of being returned to the pool (exceeding the maximum size often will trigger unwanted garbage collection, and resizing is an expensive operation – more CPU cycles – so you’ll want to fine-tune this value by playtesting too).</li>
</ul>
<p class="calibre3">Let’s put our new Object Pool to good use now by implementing the shooting mechanic, using a pool of bullet projectiles.</p>
<h1 id="_idParaDest-121" class="calibre5"><a id="_idTextAnchor123" class="pcalibre1 pcalibre calibre6"/>A pooled player shooting model</h1>
<p class="calibre3">We will use<a id="_idIndexMarker633" class="pcalibre1 pcalibre calibre6"/> an <strong class="bold">OOP</strong> (<strong class="bold">object-oriented programming</strong>) design <a id="_idIndexMarker634" class="pcalibre1 pcalibre calibre6"/>approach to the player shooting setup, allowing <a id="_idIndexMarker635" class="pcalibre1 pcalibre calibre6"/>for easy future extensibility of new types of weapons and projectiles.</p>
<h2 id="_idParaDest-122" class="calibre8"><a id="_idTextAnchor124" class="pcalibre1 pcalibre calibre6"/>Creating the pooled player shooting model</h2>
<p class="calibre3">Let’s consider <a id="_idIndexMarker636" class="pcalibre1 pcalibre calibre6"/>the following class diagram:</p>
<div><div><img alt="Figure 6.1 – A pooled player shooting UML class diagram" src="img/B18347_06_1.jpg" class="calibre78"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A pooled player shooting UML class diagram</p>
<p class="calibre3"><em class="italic">Figure 6</em><em class="italic">.1</em> presents a UML<a id="_idIndexMarker637" class="pcalibre1 pcalibre calibre6"/> diagram. <strong class="bold">UML</strong> stands for <strong class="bold">Unified Modeling Language</strong>, and it’s a standardized approach to specifying and visualizing the relationships of artifacts within software projects. There are several types of UML diagrams, each serving a specific purpose. The class diagram we’re using displays the static structure of a system, including classes, attributes, methods, and their relationships. It’s one of the most widely used diagrams in software architecture.</p>
<p class="callout-heading">Additional reading | UML diagram</p>
<p class="callout">UML: <a href="https://www.uml.org/what-is-uml.htm" class="pcalibre1 pcalibre calibre6">https://www.uml.org/what-is-uml.htm</a></p>
<p class="callout">PlantUML Language Reference Guide: <a href="https://plantuml.com/guide" class="pcalibre1 pcalibre calibre6">https://plantuml.com/guide</a></p>
<p class="callout">PlantText UML Editor: <a href="https://www.planttext.com/" class="pcalibre1 pcalibre calibre6">https://www.planttext.com/</a></p>
<p class="calibre3">Okay, we’ve modeled the system for the pooled player shooting part of our game’s code, but what does it mean? Referring to the diagram in <em class="italic">Figure 6</em><em class="italic">.1</em>, let’s break down the structure with these points:</p>
<ul class="calibre17">
<li class="calibre15">The <code>PlayerShootingPooled</code> class (<em class="italic">C</em>) – responds to <code>SendMessage()</code> of player input’s <code>OnFire()</code> event to shoot the weapon’s projectile:<ul class="calibre22"><li class="calibre15">This uses the <code>_poolProjectiles</code> object, which represents the stack of instantiated <code>ProjectileBase</code> objects (that is, <code>Bullet</code>)</li><li class="calibre15">It gets the <code>Bullet</code> (<em class="italic">C</em>) object Prefab (derived from the <code>ProjectileBase</code> (<em class="italic">A</em>) class type) for use in the <code>_poolProjectiles</code> (the <code>ObjectPool&lt;ProjectileBase&gt;</code> type) stack</li><li class="calibre15">It has a reference to the current ranged weapon (the <code>WeaponRanged</code> (<em class="italic">C</em>) class type) equipped to the player</li></ul></li>
<li class="calibre15">The <code>WeaponRanged</code> class (<em class="italic">C</em>) – represents any number of ranged weapon types we<a id="_idIndexMarker638" class="pcalibre1 pcalibre calibre6"/> can equip the player with:<ul class="calibre22"><li class="calibre15">It implements the <code>IWeapon</code> (<em class="italic">I</em>) interface, meaning that we must declare the same members (like a contract). Therefore, any classes that implement the interface will have the same members available (this allows us to swap out object types without having to change code that consumes the interface members).</li></ul></li>
<li class="calibre15">The <code>Bullet</code> class (<em class="italic">C</em>) is a component added to our bullet Prefab and assigned in the Inspector to the <code>WeaponRanged</code>-serialized <code>_bulletPrefab</code> field. The bullet Prefab is retrieved via the public <code>BulletPrefab</code> property (encapsulating the private variable) for consumption in the <code>PlayerShootingPooled</code> class:<ul class="calibre22"><li class="calibre15">This extends the inherited abstract class, <code>ProjectileBase</code> (making <code>Bullet</code> a subclass); we cannot instantiate a class-declared <code>abstract</code> and must instead use the derived class. However, members declared in the <code>base</code> class are available in the derived class.</li></ul></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">When we say <em class="italic">serializable</em>, we’re indicating that we’ll be able to make an assignment in the Inspector – a private field in most cases (in a C# script, the private field is decorated with the <strong class="source-inline1">[</strong><strong class="source-inline1">SerializeField]</strong> attribute).</p>
<p class="calibre3">After reading through the preceding details and reviewing the class diagram, you may have started<a id="_idIndexMarker639" class="pcalibre1 pcalibre calibre6"/> visualizing what our code should look like <code>… … …</code></p>
<p class="calibre3">Well, you can stop daydreaming about it now because the code follows.</p>
<p class="calibre3">Create a new C# script in <code>Assets/Scripts</code>, named <code>PlayerShootingPooled.cs</code>:</p>
<pre class="source-code">
using UnityEngine.Pool;
public class PlayerShootingPooled : MonoBehaviour
{
    [SerializeField] private WeaponRanged _weapon1;
    public int PoolDefaultCapacity = 10;
    public int PoolMaxSize = 25;
    private ObjectPool&lt;ProjectileBase&gt; _poolProjectiles;
    private void Start() {}    // new ObjectPool&lt;&gt;();
    private void OnFire() =&gt;
        _weapon1.Shoot(_poolProjectiles.Get(),
            ReturnProjectile);
    private void ReturnProjectile(
        ProjectileBase projectile) =&gt;
            _poolProjectiles.Release(projectile);
}</pre> <p class="calibre3">We’ve declared the <code>_weapon1</code> variable to assign the reference to the <code>WeaponRanged</code> Prefab object attached to the player’s hand in the Editor (at design time). We also declared public variables <code>PoolDefaultCapacity</code> and <code>PoolMaxSize</code>, with default values of <code>10</code> and <code>25</code>, respectively, for the default and maximum sizes of our private <code>ObjectPool</code>, declared as <code>_poolProjectiles</code>.</p>
<p class="calibre3">We’ll then use the <code>Start()</code> code from the previous <em class="italic">The Unity object pooling API</em> section (excluded <a id="_idIndexMarker640" class="pcalibre1 pcalibre calibre6"/>from the preceding code) and declare an <code>OnFire()</code> method, to be called via <code>PlayerInput SendMessage()</code> when the player presses the <em class="italic">fire</em> button. Within <code>OnFire()</code>, we will provide a <code>Bullet</code> instance, returned from calling <code>_poolProjectiles.Get()</code>, to shoot with.</p>
<p class="calibre3">Lastly, we will declare the <code>ReturnProjectile()</code> method, since it will be invoked by the <code>_weapon1.Shoot()</code> callback when the bullet is finished… doing what bullets do.</p>
<p class="callout-heading">A note on code architecture</p>
<p class="callout">When we create the pool item, we could pass a reference to <strong class="source-inline1">_poolProjectiles</strong> and call <strong class="source-inline1">Release()</strong> on it directly, but if we make this an <strong class="source-inline1">event</strong>, we can provide <strong class="source-inline1">ReturnProjectile()</strong> as a callback. Plus, we have the option of adding any additional callbacks. I don’t have any immediate plans for it. Still, it’s nice to consider the options to create a flexible approach, without having to refactor the code later to introduce the ability and possibly break functioning/tested code in the process.</p>
<p class="calibre3">Now, we will create a new C# script in <code>Assets/Scripts</code> named <code>WeaponRanged.cs</code>:</p>
<pre class="source-code">
using UnityEngine.Events;
public class WeaponRanged : MonoBehaviour, IWeapon
{
    [SerializeField] private ProjectileBase _bulletPrefab;
    public ProjectileBase BulletPrefab =&gt; _bulletPrefab;
    [SerializeField] private Transform _projectileSpawn;
    public void Shoot(ProjectileBase projectile,
        UnityAction&lt;ProjectileBase&gt; poolingReturnCallback)
    {
        projectile.transform.position =
            _projectileSpawn.position;
       projectile.Init(_projectileSpawn.right
            * transform.root.localScale.x,
                poolingReturnCallback);
    }
}</pre> <p class="calibre3">The <code>WeaponRanged</code> script is <a id="_idIndexMarker641" class="pcalibre1 pcalibre calibre6"/>where we’ll assign a reference to our bullet Prefab in the Inspector, using the serialized private field, <code>_bulletPrefab</code> – a weapon that shoots will require something to shoot, after all.</p>
<p class="calibre3">We’ve kept <code>_bulletPrefab</code> encapsulated and then allowed only read (getter) access to the reference via the <code>BulletPrefab</code> public property. So, <em class="italic">encapsulation</em> here means we don’t want any other classes to have access to set a bullet reference. The weapon will manage its own projectiles (although we could still add functionality later to assign a new bullet Prefab via a public setter method, such as <code>WeaponRanged.SetBulletPrefab(GameObject)</code> or similar).</p>
<p class="calibre3">The <code>Transform</code> variable, <code>_projectileSpawn</code>, provides a location where we’ll spawn the bullet Prefab that is shot from the weapon – we will set this up in the <code>WeaponRanged 1</code> Prefab later.</p>
<p class="calibre3">Lastly, the <code>Shoot()</code> method sets the position of the projectile that the pool provided to the projectile spawn position, and then it calls the <code>Init()</code> method on it (presumably to fire it off in the correct direction by applying some force to it).</p>
<p class="calibre3">We will also provide a reference to <code>poolingReturnCallback</code> so that the bullet Prefab can be released back to the pool when it collides with another object, or its lifespan expires.</p>
<p class="calibre3">Now, we will create a <a id="_idIndexMarker642" class="pcalibre1 pcalibre calibre6"/>new C# script in <code>Assets/Scripts/Interfaces</code> named <code>IWeapon.cs</code>:</p>
<pre class="source-code">
using UnityEngine.Events;
internal interface IWeapon
{
    ProjectileBase BulletPrefab { get; }
    void Shoot(ProjectileBase projectile,
        UnityAction&lt;ProjectileBase&gt;
            poolingReleaseCallback);
}</pre> <p class="calibre3">The <code>WeaponRanged</code> class implements the <code>IWeapon</code> interface to satisfy the contract, which means <code>WeaponRanged</code> must implement the <code>BulletPrefab</code> property and the <code>Shoot()</code> method declared in the <code>IWeapon</code> interface. Note that interface members in C# are public by default!</p>
<p class="calibre3">The weapon and object pooling portions of the class diagram in <em class="italic">Figure 6</em><em class="italic">.1</em> are now satisfied. Let’s finish up the class diagram implementation with the projectile that will be shot from the weapon.</p>
<p class="calibre3">Create a new C# script in <code>Assets/Scripts</code> named <code>Bullet.cs</code>, as follows:</p>
<pre class="source-code">
public class Bullet : ProjectileBase
{
    [SerializeField] private LayerMask CollideWith;
    protected override void
        OnTriggerEnter2D(Collider2D collision)
    {
        if ((CollideWith
            &amp; (1 &lt;&lt; collision.gameObject.layer)) != 0)
                base.Collided();
    }
    protected override void LifetimeExpired()
        =&gt; base.Collided();
}</pre> <p class="calibre3">The <code>Bullet</code> class extends the <code>ProjectileBase</code> class, meaning that it will inherit all the members and/or be required to <strong class="bold">override</strong> members. You can declare unique properties for a derived class that differentiate it from other derived classes (a tenet of <strong class="bold">inheritance</strong> in <a id="_idIndexMarker643" class="pcalibre1 pcalibre calibre6"/>OOP design).</p>
<p class="calibre3">We’re overriding the <code>OnTriggerEnter2D()</code> method – we’re required to, since it’s declared as <code>abstract</code> in the inherited <code>ProjectileBase</code> class – to perform the specific Bullet<a id="_idIndexMarker644" class="pcalibre1 pcalibre calibre6"/> collision action.</p>
<p class="calibre3">Note that we’re also calling the <code>Collided()</code> method in the inherited class by using the <code>base</code> keyword. <code>Collided()</code> is declared as <code>virtual</code>, which means we can redefine it in a derived class while also using it for the same basic/default functionality.</p>
<p class="calibre3">This bit of code – <code>((CollideWith &amp; (1 &lt;&lt; collision.gameObject.layer)) != 0)</code> – in the <code>OnTriggerEnter2D()</code> method evaluates whether the GameObject the <code>Bullet</code> collided with is included in the layers selected in <code>CollideWith LayerMask</code>. For example, we’ll select <em class="italic">Environment</em>, <em class="italic">Wall</em>, <em class="italic">Ground</em>, <em class="italic">Enemy</em>, and so on, but not <em class="italic">Player</em> for <code>Bullet</code> to collide with.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">LayerMask: <a href="https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/ScriptReference/LayerMask.xhtml</a></p>
<p class="callout">Bitwise and shift operators: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-" class="pcalibre1 pcalibre calibre6">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#left-shift-operator-</a>.</p>
<p class="calibre3">We’ve seen how <code>Bullet</code> extends the <code>ProjectileBase</code> class (via OOP inheritance), so let’s have a look at the <code>ProjectileBase</code> class now.</p>
<p class="calibre3">Create a new <a id="_idIndexMarker645" class="pcalibre1 pcalibre calibre6"/>C# script in <code>Assets/Scripts</code> named <code>ProjectileBase.cs</code>:</p>
<pre class="source-code">
using UnityEngine.Events;
public abstract class ProjectileBase : MonoBehaviour
{
    [SerializeField] private Rigidbody2D _rb;
    [SerializeField] private float _velocity = 30f;
    [SerializeField] private float _lifetime = 2f;
    private event
        UnityAction&lt;ProjectileBase&gt; _onCollisionAction;
    public virtual void Init(Vector2 direction,
        UnityAction&lt;ProjectileBase&gt; collisionCallback)
    {
        _onCollisionAction = collisionCallback;
        _rb.velocity = direction * _velocity;
        Invoke(nameof(LifetimeExpired), _lifetime);
    }
    protected abstract void
        OnTriggerEnter2D(Collider2D collision);
    protected abstract void LifetimeExpired();
    protected virtual void Collided()
    {
        CancelInvoke();
        _onCollisionAction?.Invoke(this);
    }
}</pre> <p class="calibre3">Here, we can see our bullet projectile’s default properties and behavior. By declaring <code>ProjectileBase</code> as an abstract base class, it cannot be instantiated (made a new instance of) directly, so we must declare a new class that extends or inherits from it.</p>
<p class="calibre3">Note that any derived classes can still be referenced by the base class it extends (in OOP, this is <a id="_idIndexMarker646" class="pcalibre1 pcalibre calibre6"/>the <strong class="bold">polymorphism</strong> principle). The derived class must override any members declared as<a id="_idIndexMarker647" class="pcalibre1 pcalibre calibre6"/> abstract but can optionally override members declared as virtual (while also being able to call base virtual methods for default behavior).</p>
<p class="calibre3">Let’s break down the code’s relevant items:</p>
<ul class="calibre17">
<li class="calibre15">Variable declarations for <code>_rb</code>, <code>_velocity</code>, and <code>_lifetime</code> provide a reference to the <code>RigidBody2D</code> component of the projectile Prefab, as well as configurable values for the rate of velocity and lifetime of the object</li>
<li class="calibre15">When <code>Init()</code> is called, the passed-in callback action is assigned to <code>_onCollisionAction</code> to be invoked later, and then <code>_rg.velocity</code> is set for <code>direction</code> and rate of <code>_velocity</code>, firing it off in the direction the weapon is pointing</li>
<li class="calibre15">Then, we have two abstract methods that must be overridden in the derived class(es) (for example, <code>Bullet</code>):<ul class="calibre22"><li class="calibre15"><code>OnTriggerEnter2D()</code>: This Unity message event is called when another object collides with the object.</li><li class="calibre15"><code>LifetimeExpired()</code>: In <code>Init()</code>, we invoke this method with a delay so that the projectile object only exists active in the Scene for a certain amount of time (releasing it back to the pool to be reused). The <code>_lifetime</code> value should be adjusted during playtesting so that the weapon’s range works well in-game.</li></ul></li>
<li class="calibre15">Finally, we have the <code>Collided()</code> method, which first cancels calling the <code>LifetimeExpired()</code> method at the <code>_lifetime</code> value (for example, as we don’t want to call <code>LifetimeExpired()</code> if <code>Collided()</code> was already called by a collision event) and then invokes the <code>_onCollisionAction</code> callback (releasing the object back to the pool).</li>
</ul>
<p class="callout-heading">Pooled player shooting model code</p>
<p class="callout">The complete aforementioned pooled Player shooting code can be downloaded from the GitHub repo here: <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch6/Unity%20Project/Assets/Scripts</a>.</p>
<p class="calibre3">Following the design<a id="_idIndexMarker648" class="pcalibre1 pcalibre calibre6"/> model from the UML class diagram in <em class="italic">Figure 6</em><em class="italic">.1</em>, we have now finished writing the code portion and are ready to move on to implementing it with the player.</p>
<h2 id="_idParaDest-123" class="calibre8"><a id="_idTextAnchor125" class="pcalibre1 pcalibre calibre6"/>Implementing the pooled shooting model</h2>
<p class="calibre3">Now, let’s see <a id="_idIndexMarker649" class="pcalibre1 pcalibre calibre6"/>how we implement the pooled player shooting model by creating the required Prefabs – a weapon and a projectile – for integration with the player. The Prefabs we’ll need, along with the steps to create them, are as follows:</p>
<ol class="calibre14">
<li class="calibre15"><code>Bullet 1</code>: The first projectile Prefab asset we’ll shoot from a ranged weapon:<ol class="calibre42"><li class="upper-roman">Import the <code>bullet1</code> artwork from the project files to the <code>Assets/Sprites</code> folder and set the PPU to <code>1280</code> (to set our larger bullet sprite to a good in-game size, which will be possibly adjusted later in relation to the size of the weapon firing the bullet). Also, set <code>64</code> for optimization, since it is a relatively small and fast-moving sprite.</li><li class="upper-roman">Create an empty GameObject in the <code>Bullet 1</code>. Remember that you can easily parent a GameObject in the <code>Rigidbody2D</code> and <code>CircleCollider2D</code> components to the parent object to <a id="_idIndexMarker650" class="pcalibre1 pcalibre calibre6"/>enable <code>Rigidbody2D</code> component, set <code>0</code>, and enable <code>CircleCollider2D</code> component, set <code>0.13</code>), as shown in <em class="italic">Figure 6</em><em class="italic">.2</em>:</li></ol></li></ol></li>
</ol>
<div><div><img alt="Figure 6.2 – the bullet Prefab setup" src="img/B18347_06_2.jpg" class="calibre79"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.2 – the bullet Prefab setup</p>
<ol class="calibre14">
<li class="upper-roman" value="5">Now, add the <code>Bullet</code> script to the parent object, and assign the <code>Rigidbody2D</code> field by clicking and dragging the <code>Rigidbody2D</code> section title to the field.</li>
<li class="upper-roman">Set <strong class="bold">Velocity</strong> and <strong class="bold">Lifetime</strong> to some initial starting values, and then assign the layers that the bullet should collide with, using the <strong class="bold">CollideWith</strong> field (note that you may need to add a new layer before you can assign it).</li>
<li class="upper-roman">Lastly, drag the<a id="_idIndexMarker651" class="pcalibre1 pcalibre calibre6"/> parent <code>Bullet 1</code> object from the <code>Assets/Prefabs</code> folder. Our bullet Prefab is now ready to be used with the weapon Prefab we’ll create next.</li>
</ol>
<ol class="calibre14">
<li value="2" class="calibre15"><code>WeaponRanged 1</code>: A ranged weapon that the player will hold and shoot a bullet projectile from:<ol class="calibre42"><li class="upper-roman">Import the <code>gun1</code> weapon artwork, and in the Sprite Editor, set a custom pivot (see <em class="italic">A</em> in <em class="italic">Figure 6</em><em class="italic">.3</em>) on the handle so that when it is attached (or spawned) to the player, it is in the correct position and can rotate on a pivot point (as you might expect it to behave).</li></ol></li>
</ol>
<p class="callout-heading">Pivot | Unity documentation</p>
<p class="callout">When working with a GameObject, the pivot serves as the reference point to position, rotate, and scale it. In Unity, when using the Transform tools, you can switch between the pivot or center of a GameObject in the Tool Settings overlay.</p>
<p class="callout">Position GameObjects | Gizmo handle position toggles: <a href="https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/PositioningGameObjects.xhtml</a></p>
<ol class="calibre14">
<li class="upper-roman" value="2">Drag the gun sprite into the <code>WeaponRanged 1</code>.</li>
<li class="upper-roman">Now, add a new empty GameObject, named <code>ProjectileSpawnPoint</code>, as a sibling to <a id="_idIndexMarker652" class="pcalibre1 pcalibre calibre6"/>the gun sprite object that we’ll use as the <strong class="bold">Transform</strong> position to spawn the projectile. Position this GameObject at the front of the gun’s muzzle (see <em class="italic">B</em> in <em class="italic">Figure 6</em><em class="italic">.3</em>):</li>
</ol>
<div><div><img alt="Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup" src="img/B18347_06_3.jpg" class="calibre80"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The weapon Prefab sprite and projectile spawn point setup</p>
<ol class="calibre14">
<li class="upper-roman" value="4">Now, add <code>WeaponRanged</code> as a component to the parent GameObject.</li>
<li class="upper-roman">The only two assignments we need to make on the <code>WeaponRanged</code> component are the <code>Bullet 1</code> from the <code>ProjectileSpawnPoint</code> object to the <code>WeaponRanged 1</code> object from the <code>Assets/Prefabs</code> folder.</li></ol></li>
</ol>
<p class="calibre3">Our pooled player <a id="_idIndexMarker653" class="pcalibre1 pcalibre calibre6"/>shooting model is ready to be used with the player character. Yay!</p>
<h2 id="_idParaDest-124" class="calibre8"><a id="_idTextAnchor126" class="pcalibre1 pcalibre calibre6"/>Adding pooled shooting to the player character</h2>
<p class="calibre3">We’ll dig right<a id="_idIndexMarker654" class="pcalibre1 pcalibre calibre6"/> into adding the weapon to our player. You can either make sure the player is in the current Scene or double-click on the <code>Player</code> Prefab in the <strong class="bold">Project</strong> window to open it up in <strong class="bold">Prefab</strong> Mode.</p>
<p class="calibre3">We’ll use the player’s (actor’s) bones to ensure the weapon follows the character’s hand while animating. Perform the following steps to anchor the weapon to the player’s hand:</p>
<ol class="calibre14">
<li class="calibre15">Find the hand bone under the <code>root_bone</code> hierarchy. In our case, it’s <code>bone_8</code> as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>.</li>
<li class="calibre15">Add an empty GameObject as a child of <code>bone_8</code>, and name it <code>Weapon_Attachment</code>; this will serve as the attachment point for the weapon. Making it separate from the bone provides additional options for positioning/rotating. Also, naming it with an <code>_Attachment</code> suffix means we can easily search for any/all objects in the <strong class="bold">Hierarchy</strong> that serve as attachment points.</li>
<li class="calibre15">You can now go ahead and drag the <code>WeaponRanged 1</code> Prefab from the <code>Weapon_Attachment</code> object (this becomes a nested Prefab, which means we can configure its properties at any time, independent of the <code>Player</code> Prefab).</li>
</ol>
<p class="calibre3">The following screenshot shows our player setup with the weapon in hand. In the following <em class="italic">Figure 6</em><em class="italic">.4</em>, you can see that I have also temporarily dragged in a <code>Bullet 1</code> Prefab to check its <a id="_idIndexMarker655" class="pcalibre1 pcalibre calibre6"/>scale in relation to the weapon (seen in context with the player character):</p>
<div><div><img alt="Figure 6.4 – The weapon Prefab added to the player" src="img/B18347_06_4.jpg" class="calibre81"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.4 – The weapon Prefab added to the player</p>
<p class="calibre3">As a final step, we need to add the <code>PlayerShootingPooled</code> script as a component to the root object of our <code>Player</code> Prefab. Then, we will drag the <code>WeaponRanged 1</code> object from the <strong class="bold">Hierarchy</strong> to the <strong class="bold">Weapon 1</strong> field on the component (as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>).</p>
<p class="calibre3">Here’s what our Prefab components – based on the classes in our UML diagram – look like in the Inspector with all their respective field assignments:</p>
<div><div><img alt="Figure 6.5 – Prefab configuration for the pooled player shooting setup" src="img/B18347_06_5.jpg" class="calibre82"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Prefab configuration for the pooled player shooting setup</p>
<p class="callout-heading">New to Unity 2022</p>
<p class="callout">This may not be new specifically to the 2022 tech stream, but I believe it’s a workflow improvement worth mentioning. You can simultaneously open up a focused <strong class="bold">Inspector</strong> window for different assets or GameObjects, without constantly changing your selection and using the Inspector. First, select the object, and then either right-click and choose <strong class="bold">Properties…</strong> (at the bottom) or press <em class="italic">Alt/Cmd + </em><em class="italic">P</em>.</p>
<p class="calibre3">Let’s go ahead and<a id="_idIndexMarker656" class="pcalibre1 pcalibre calibre6"/> playtest the results of our efforts!</p>
<p class="calibre3">Referring to <em class="italic">Figure 6</em><em class="italic">.4</em>, enter <code>PlayerCharacter1</code> object to pose the actor’s arm with the weapon attachment in a shooting position – using the IK <code>LimbSolver2D</code> target makes this easy-peasy.</p>
<p class="calibre3">We’ll give the player a proper shooting animation that points the weapon in a direction in <a href="B18347_08.xhtml#_idTextAnchor151" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a> so that we can target those pesky robot enem<a id="_idTextAnchor127" class="pcalibre1 pcalibre calibre6"/>ies (not that it’s their fault!).</p>
<p class="calibre3">This section taught us how to add a ranged weapon to the player by attaching it to a character’s limb, all <a id="_idIndexMarker657" class="pcalibre1 pcalibre calibre6"/>while using previously created Prefabs. I can’t stress how important it is to understand and use a good Prefab workflow in your projects!</p>
<h1 id="_idParaDest-125" class="calibre5"><a id="_idTextAnchor128" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter introduced object pooling and implemented it for the player’s shooting mechanic, using Unity’s object pooling API, while basing the software design on our pooled player shooting model UML diagram.</p>
<p class="calibre3">We finished by attaching the ranged weapon to the player, using<a id="_idTextAnchor129" class="pcalibre1 pcalibre calibre6"/> our configured Prefab components.</p>
<p class="calibre3">In the following chapter, we’ll add some juice to the player character with some visual effects, create some enemy NPCs (non-player characters), and finish by introducing enemy behavior through a state pattern.</p>
</div>
</div></body></html>