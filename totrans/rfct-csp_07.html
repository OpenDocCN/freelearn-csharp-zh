<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-162"><a id="_idTextAnchor161"/>7</h1>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Test-Driven Development</h1>
<p>Let’s continue our discussion of testing and ensuring the quality of our software processes by going in-depth with Test-Driven Development.</p>
<p>While this is a book about refactoring and Test-Driven Development is primarily intended for future development and bug fixing, it has some key lessons to teach us in software quality and the same tools Visual Studio provides to support Test-Driven Development can help immensely in the refactoring process.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>What is Test-Driven Development?</li>
<li>Test-Driven Development with Visual Studio</li>
<li>When to use Test-Driven Development</li>
</ul>
<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter07/Ch7BeginningCode</code> folder.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>What is Test-Driven Development?</h1>
<p><strong class="bold">Test-driven Development</strong> (<strong class="bold">TDD</strong>) is the <a id="_idIndexMarker422"/>process of writing your tests <em class="italic">before</em> you write your code for a new feature or to implement a new fix.</p>
<p>Under TDD, you first write a test for the feature you’re trying to implement or a test to reproduce the bug you’re about to fix. You do this in the most ideal way possible, which may even involve classes or methods that don’t exist at the start of your test.</p>
<p>Next, you do the minimum amount of work needed to make your code successfully compile. This isn’t to say that it runs perfectly or does the thing it is trying to do, in fact, you’re trying to start out with a red failing test that indicates your feature or fix doesn’t work.</p>
<p>This<a id="_idIndexMarker423"/> makes sense when you consider that at this point you haven’t implemented the new feature or made the fix to the code. So, the test <em class="italic">should</em> be a failing test.</p>
<p>Next, you write the minimum amount of code required to make your test pass. In this step, you are doing what you need to do to meet the specific requirement you are trying to address. Once you are finished, your test should turn into a green passing test.</p>
<p>After that, you refactor the code you added to implement your feature or fix and you refactor your test code as well; taking care to continue to run your unit tests to ensure you haven’t broken anything.</p>
<p>Once you’re satisfied with the state of your new code and your test, you look at the next requirement on the current work item you’re working on, write a test for that, and repeat the process until you have <a id="_idIndexMarker424"/>met all requirements. This process is illustrated in <em class="italic">Figure 7</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 7.1 – The Test-Driven Development Cycle" src="img/B21324_07_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The Test-Driven Development Cycle</p>
<p>Because you start with a failing red test, move on to a green passing test, and then refactor your code before starting again with a new requirement, TDD is sometimes referred to as <strong class="bold">Red / Green / </strong><strong class="bold">Refactor</strong>.</p>
<p>This process <a id="_idIndexMarker425"/>has a few key benefits:</p>
<ul>
<li>You can be confident your code addresses the problem by starting with a test.</li>
<li>Code written in this way is guaranteed to be covered by your tests.</li>
<li>When you start with how your code should be called by others, it tends to lead to more<a id="_idIndexMarker426"/> intuitive class designs for others to use later.</li>
</ul>
<p>This process, and its results, make a lot more sense with a practical example. So, let’s jump into some code and implement a new feature for Cloudy Skies Airlines.</p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/>Test-Driven Development with Visual Studio</h1>
<p>We’re starting<a id="_idIndexMarker427"/> this chapter with a nearly empty console project and a supporting xUnit test project that has already been linked to the main project as shown in <a href="B21324_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>. The structure of this project can be seen in <em class="italic">Figure 7</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 7.2 – Solution Explorer showing only a few files" src="img/B21324_07_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Solution Explorer showing only a few files</p>
<p>Over the course of the rest of this section, we’re going to add a new class to track frequent flier miles for Cloudy Skies Airlines.</p>
<p>The requirements<a id="_idIndexMarker428"/> we’ll be addressing (in order) are:</p>
<ul>
<li>When a new Frequent Flier Account is created it should start with a starting balance of 100 miles.</li>
<li>You should be able to add miles to the frequent flier account.</li>
<li>You should be able to mark miles as redeemed as long as this wouldn’t result in a negative balance.</li>
</ul>
<p>These are not complex requirements, but they should serve as a starting point for briefly exploring TDD.</p>
<p>We’ll start with the starting balance requirement.</p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Setting the starting balance</h2>
<p>Our first<a id="_idIndexMarker429"/> requirement involves the account starting with 100 miles already registered.</p>
<p>Under the guidance of TDD, we should start with a failing test. Thankfully, we already have a <code>MilesTrackerTests.cs</code> file, so that gives us a good place to start.</p>
<p>However, we have no classes in the <code>Chapter7</code> project to represent the mileage tracker, which poses a problem for us in writing the arrange section of our first test.</p>
<p>While there’s a temptation to “cheat” a bit by creating the class now, let’s follow a strictly TDD approach and write the test code in the way we’d prefer to interact with the class, knowing that the class doesn’t exist yet and this will cause some compiler errors for us in a moment.</p>
<p>Such a test might look like this:</p>
<pre class="source-code">
[Fact]
public void NewAccountShouldHaveStartingBalance() {
  // Arrange
  int expectedMiles = 100;
  // Act
  <strong class="bold">MileageTracker tracker = new();</strong>
  // Assert
  Assert.Equal(expectedMiles, <strong class="bold">tracker.Balance</strong>);
}</pre>
<p>This test sets an expected starting mileage variable, tries to instantiate a <code>MileageTracker</code>, and then asserts that the <code>Balance</code> property on this new tracker should be the expected amount.</p>
<p>This is a simple, concise, and readable test with a couple of tiny problems: <code>MileageTracker</code> and its <code>Balance</code> property don’t exist in our code yet, meaning our code won’t compile.</p>
<h3>Generating classes</h3>
<p>These <a id="_idIndexMarker430"/>compiler issues when creating new classes and new properties are normal and to be expected when coding under TDD. Thankfully Visual Studio has a Quick Actions refactoring available for us.</p>
<p>Select the <code>MileageTracker</code> in your act section and open the Quick Actions menu. From there note the various options to generate this Type as shown in <em class="italic">Figure 7</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 7.3 – Quick Actions to generate a new Type" src="img/B21324_07_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Quick Actions to generate a new Type</p>
<p>These options, as shown here, are great, but most of them would create the new class inside the test project which is not what we want. Since we want to customize the new type being created, select <strong class="bold">Generate </strong><strong class="bold">new type…</strong></p>
<p>This will open the <strong class="bold">Generate Type </strong>dialog allowing you to select the type, name, and location of the new type being generated. Change the <strong class="bold">Project</strong> to <em class="italic">Chapter7</em> and choose to create a new file as shown in <em class="italic">Figure 7</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 7.4 – Generating a new class in the Chapter7 project" src="img/B21324_07_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Generating a new class in the Chapter7 project</p>
<p>Next, click <code>MileageTracker.cs</code> file to the main project.</p>
<p>This <a id="_idIndexMarker431"/>class is boring at present with nothing in it, but we’ll add to it in a moment as we work on the next compiler error.</p>
<h3>Generating members</h3>
<p>Going back<a id="_idIndexMarker432"/> to our test, the <em class="italic">act</em> section now has no issues, but we still have a compiler error on the reference to <code>Balance</code> in the <em class="italic">Assert</em> section as shown in <em class="italic">Figure 7</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 7.5 – The C# Compiler pointing out that MileageTracker has Balance property" src="img/B21324_07_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The C# Compiler pointing out that MileageTracker has Balance property</p>
<p>Thankfully, Visual Studio gives us tools to generate properties. Let’s do that now so our code will at least compile.</p>
<p>Select <strong class="bold">Balance</strong> and then open the <strong class="bold">Quick Actions</strong> menu and choose <strong class="bold">Generate property ‘Balance’</strong> as shown in <em class="italic">Figure 7</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 7.6 – Generating a new property" src="img/B21324_07_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Generating a new property</p>
<p>Doing so causes Balance to be defined. If you hold down <em class="italic">Ctrl</em> and click on <code>Balance</code>, it will navigate you to <code>MileageTracker.cs</code> and we’ll see how the class is defined:</p>
<pre class="source-code">
public class MileageTracker {
  public IEnumerable&lt;object&gt; Balance { get; set; }
}</pre>
<p>Here, Visual Studio<a id="_idIndexMarker433"/> had to guess what property type <code>Balance</code> was and it guessed horribly wrong. Since this will otherwise cause compiler errors, change <code>Balance</code> to an <code>int</code>:</p>
<pre class="source-code">
public class MileageTracker {
  public <strong class="bold">int</strong> Balance { get; set; }
}</pre>
<p>With that change, the code should now compile, but let’s make one more change before we run our tests.</p>
<p>Remember that TDD requires us to write the minimum amount of code to do what we’re trying to do? Technically, Visual Studio has violated this principle by generating both a getter and a setter for our Balance property. In this test, we only need to get the <code>Balance</code> and not set it via this property. So, let’s protect that <code>Balance</code> by removing the setter:</p>
<pre class="source-code">
public class MileageTracker {
  public int Balance <strong class="bold">{ get; }</strong>
}</pre>
<p>With this bit of added encapsulation in hand and our code compiling, let’s run our test. When you do so, you should see the test fail stating that it expected <code>Balance</code> to be 100 but it actually was 0 as shown in <em class="italic">Figure 7</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 7.7 – Our first failing test" src="img/B21324_07_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Our first failing test</p>
<p>Under TDD, this is exactly what we’d want. We did the minimum amount of work to get an ideal test to <a id="_idIndexMarker434"/>compile, and that test failed because we hadn’t fully implemented the feature.</p>
<h3>Moving from red to green and onto refactoring</h3>
<p>Let’s implement<a id="_idIndexMarker435"/> the feature now.</p>
<p>While we know that our <code>MileageTracker</code> will need some additional things later, let’s implement this feature by writing the minimum amount of code possible:</p>
<pre class="source-code">
public class MileageTracker {
  public int Balance { get; } <strong class="bold">= 100</strong>;
}</pre>
<p>This now defaults new <code>MileageTracker</code> instances to have a starting balance of 100, which meets our needs and causes our test to turn green and pass when re-run.</p>
<p>With a green test, we now look for opportunities to refactor. While our test code is minimal, the <code>MileageTracker</code> does <a id="_idIndexMarker436"/>have a <strong class="bold">magic number</strong> in it. Magic numbers are <strong class="bold">code smells</strong> that <a id="_idIndexMarker437"/>represent some sort of undocumented business or technical requirement.</p>
<p>Let’s fix it by introducing a constant:</p>
<pre class="source-code">
public class MileageTracker {
    <strong class="bold">private const int SignUpBonus = 100;</strong>
    public int Balance { get; } = <strong class="bold">SignUpBonus</strong>;
}</pre>
<p>This code <a id="_idIndexMarker438"/>is now easier for others to understand, removing the code smell.</p>
<p class="callout-heading">Naming</p>
<p class="callout">Naming things in software engineering is hard. It’s possible the name that occurred to you for this class or the <code>SignUpBonus</code> <code>const</code> I introduced was different than the names I picked. That’s fine. What’s most important about a name is that it <em class="italic">communicates intent</em> to other developers and is not confused with something else in the system. While the name <code>StartingBalance</code> would have been fine for my const, I chose <code>SignUpBonus</code> because I thought it more clearly documented the business case for the starting balance.</p>
<p>Running the tests again results in a green passing test once more and there are no other obvious targets for refactoring, so we move on to the next requirement.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Adding miles and generating methods</h2>
<p>Our next requirement is <em class="italic">You should be able to add miles to the frequent </em><em class="italic">flier account</em>.</p>
<p>Let’s go back <a id="_idIndexMarker439"/>to our tests and add a new test for this requirement. Here we’ll again choose the most intuitive syntax and then make the code <a id="_idIndexMarker440"/>compile and test pass later:</p>
<pre class="source-code">
[Fact]
public void AddMileageShouldIncreaseBalance() {
  // Arrange
  MileageTracker tracker = new();
  // Act
  <strong class="bold">tracker.AddMiles(50);</strong>
  // Assert
  Assert.Equal(150, tracker.Balance);
}</pre>
<p>This test instantiates a <code>MileageTracker</code>, then tries to add 50 miles using a not-yet-created <code>AddMiles</code> method before verifying that the balance is 150 (100 starting miles plus the 50 we just added).</p>
<p>Of course, there is no <code>AddMiles</code> method in <code>MileageTracker</code>. Let’s add one by selecting <code>AddMiles</code> and then choosing <strong class="bold">Generate method ‘AddMiles’ </strong>from the <strong class="bold">Quick Actions</strong> menu as shown in <em class="italic">Figure 7</em><em class="italic">.8</em>:</p>
<div><div><img alt="Figure 7.8 – Adding a new method" src="img/B21324_07_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Adding a new method</p>
<p>Adding this method causes it to be created with the following implementation:</p>
<pre class="source-code">
public void AddMiles(int v) {
  throw new NotImplementedException();
}</pre>
<p>Obviously, this <a id="_idIndexMarker441"/>is not what the method should do. However, let’s follow strict TDD and move through the motions one step at a time.</p>
<p>Since our code now compiles, we can run the test and verify that it fails as expected.</p>
<p>Once we’re <a id="_idIndexMarker442"/>confident we have a test that can detect failing code we write only the minimum amount of code required to get the test to pass. This ensures that our tests are sufficient for finding actual problems with the code later.</p>
<p>A passing implementation of <code>AddMiles</code> might look like this:</p>
<pre class="source-code">
public class MileageTracker {
    private const int SignUpBonus = 100;
    public int Balance { get; set; } = SignUpBonus;
<strong class="bold">    public void AddMiles(int miles) {</strong>
<strong class="bold">      Balance += miles;</strong>
<strong class="bold">    }</strong>
  }
}</pre>
<p>As you can see, the code now compiles and results in green tests. This means we should move on to refactoring our code as needed.</p>
<p>The test code is still clean and the only refactoring I can see to apply here might be to use the <a id="_idIndexMarker443"/>expression-bodied members that we covered in <a href="B21324_04.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>. However, I’m going to leave the <a id="_idIndexMarker444"/>code in its current form as the class is still very minimal.</p>
<p>With that requirement complete, let’s move on to our final requirement around redeeming miles.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Redeeming miles and refactoring tests</h2>
<p>Our final<a id="_idIndexMarker445"/> requirement is <em class="italic">You should be able to mark miles as redeemed if this wouldn’t cause a negative balance</em>. This is a bit more <a id="_idIndexMarker446"/>complex than the last requirement as it has a condition attached to it.</p>
<p>As we did before, let’s start by writing a test:</p>
<pre class="source-code">
[Fact]
public void RedeemMileageShouldDecreaseBalance() {
    // Arrange
    MileageTracker tracker = new();
    tracker.AddMiles(900);
    // Act
    <strong class="bold">tracker.RedeemMiles(250);</strong>
    // Assert
    Assert.Equal(750, tracker.Balance);
}</pre>
<p>This test should look very similar to our <code>AddMiles</code> test earlier, except it calls out to a new <code>RedeemMiles</code> method.</p>
<p>Let’s use the <em class="italic">generate method</em> refactoring shown earlier to generate that empty <code>RedeemMiles</code> method and allow the code to compile.</p>
<p>This should result in a red failing test as shown in <em class="italic">Figure 7</em><em class="italic">.9</em> due to the default <code>throw new NotImplementedException</code> line in that method:</p>
<div><div><img alt="Figure 7.9 – The remove mileage test failing due to an Exception being thrown" src="img/B21324_07_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – The remove mileage test failing due to an Exception being thrown</p>
<p>However, moving<a id="_idIndexMarker447"/> from red to green is again trivial <a id="_idIndexMarker448"/>here by mirroring what we did for <code>AddMiles</code>:</p>
<pre class="source-code">
public class MileageTracker {
    private const int SignUpBonus = 100;
    public int Balance { get; set; } = SignUpBonus;
    public void AddMiles(int miles) {
      Balance += miles;
    }
<strong class="bold">    public void RedeemMiles(int miles) {</strong>
<strong class="bold">      Balance -= miles;</strong>
<strong class="bold">    }</strong>
  }
}</pre>
<p>This gets our test to pass and so we move on to looking for refactoring options. This code isn’t bad, so we continue to look for the next requirement.</p>
<p>In this case, we haven’t fully met the requirement we were trying to solve because we don’t cover trying to redeem more miles than are in an account. Let’s write a new test for that scenario:</p>
<pre class="source-code">
[Fact]
public void RedeemMileageShouldPreventNegativeBalance() {
    // Arrange
    MileageTracker tracker = new();
    <strong class="bold">int startingBalance = tracker.Balance;</strong>
    // Act
    <strong class="bold">tracker.RedeemMiles(2500);</strong>
    // Assert
    Assert.Equal(<strong class="bold">startingBalance</strong>, tracker.Balance);
}</pre>
<p>This <a id="_idIndexMarker449"/>test creates an account and takes note of its starting balance. The test then attempts to withdraw more miles than accounts <a id="_idIndexMarker450"/>start with and verifies that the ending balance is equal to the starting balance.</p>
<p>This doesn’t rely on any new methods in the tracker. As a result, our code compiles without changes. However, running this test results in a failure stating that balance was expected to be 100 but was -2400 instead.</p>
<p>With a red test in hand, let’s modify the <code>RedeemMiles</code> method to make the test green:</p>
<pre class="source-code">
public void RedeemMiles(int miles) {
  <strong class="bold">if (Balance &gt;= miles) {</strong>
    Balance -= miles;
  <strong class="bold">}</strong>
}</pre>
<p>Now, we check to make sure we have enough miles to fulfill the request and only reduce the mileage if that condition is met.</p>
<p>Running the tests again results in a full set of passing tests as shown in <em class="italic">Figure 7</em><em class="italic">.10</em>:</p>
<div><div><img alt="Figure 7.10 – Four passing tests around mileage" src="img/B21324_07_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Four passing tests around mileage</p>
<p>With a <a id="_idIndexMarker451"/>passing test in hand, we now look at<a id="_idIndexMarker452"/> refactoring. Since the <code>MileageTracker</code> is succinct and clear, we’ll move on to looking at our tests.</p>
<p class="callout-heading">What about exceptions?</p>
<p class="callout">Right now <code>RedeemMiles</code> will silently fail if you request more miles than desired, which might raise some alarm bells for you as a developer. In a real-world application, you’d probably want this method to either return a bool indicating if the redemption was successful or to throw an exception if the redemption was not possible. Both of these scenarios could be handled in TDD as additional requirements to implement, such as “If we try to redeem more miles than possible, an <code>InvalidOperationException</code> should be thrown”.</p>
<p>Looking at our tests, we do see that our <code>RemoveMileageShouldDecreaseBalance</code> and <code>RemoveMileageShouldPreventNegativeBalance</code> do similar things.</p>
<p>Due to the duplication between tests, we should combine these into a <code>Theory</code> with <code>InlineData</code> lines representing individual test cases. This would look something like the following:</p>
<pre class="source-code">
<strong class="bold">[Theory]</strong>
<strong class="bold">[InlineData(900, 250, 750)]</strong>
<strong class="bold">[InlineData(0, 2500, 100)]</strong>
public void RedeemMileageShouldResultInCorrectBalance(
  <strong class="bold">int addAmount, int redeemAmount, int expectedBalance</strong>) {
    // Arrange
    MileageTracker tracker = new();
    tracker.AddMiles(<strong class="bold">addAmount</strong>);
    // Act
    tracker.RedeemMiles(<strong class="bold">redeemAmount</strong>);
    // Assert
    Assert.Equal(<strong class="bold">expectedBalance</strong>, tracker.Balance);
}</pre>
<p>This <a id="_idIndexMarker453"/>form allows many tests to add an initial <a id="_idIndexMarker454"/>amount to the balance, redeem some number of miles, and then verify the result matches the expected balance. This also lets us easily add new scenarios as we identify them.</p>
<p>However, the name of the method is less meaningful than the more specific names we could use with individual <code>Fact</code> tests.</p>
<p>With passing tests and refactoring complete, we now move on to either the next requirement in this feature or the next work item in our queue. Let’s close the chapter by talking about TDD at a high level and when it’s right to use in your projects.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>When to use Test-Driven Development</h1>
<p>TDD is not<a id="_idIndexMarker455"/> always a good match for every task. Some tasks, such as highly visual user interface design may not fit into the TDD workflow very well, while others such as fixing an error observed in production or adding a new special case to a calculation are almost ideal for TDD.</p>
<p>Using TDD results in code that is generally easier to understand, has perfect or near-perfect code coverage on tests, and encourages refactoring along the way.</p>
<p>Many developers follow TDD but don’t follow it as strictly as outlined in this chapter. For example, instead of just generating a method, they may go ahead and implement the method and write additional argument validation code not required by their specific test.</p>
<p>Such <a id="_idIndexMarker456"/>deviations from TDD are common and often acceptable, though they usually result in a few pieces of code being added that don’t have supporting tests.</p>
<p>Ultimately, it’s up to you and your team to determine what works best for you and the work that you do, but I can tell you that projects I work on where TDD is possible tend to rapidly reach better quality levels, encourage more refactoring, and have better long-term success.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor170"/>Summary</h1>
<p>In this chapter, we covered Test-Driven Development (TDD) and showed how its process involves writing only the minimum possible amount of code to get to a failing test – make that test pass with the minimum amount of code needed – then, refactor all code as needed before moving on to the next requirement or work item.</p>
<p>We also saw how Visual Studio has Quick Actions that allow you to generate types, properties, and methods and support your efforts in following TDD.</p>
<p>In the next chapter, we’ll talk about anti-patterns that can lead to unmaintainable code and SOLID principles that help your code be robust and maintainable.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Questions</h1>
<ol>
<li>What areas of your code would be a good fit for using TDD?</li>
<li>What areas might be harder to apply TDD to?</li>
</ol>
<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Further reading</h1>
<p>You can find more information about materials discussed in this chapter at this URL:</p>
<ul>
<li><em class="italic">Test-Driven Development </em><em class="italic">Walkthrough:</em> <a href="https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer">https://learn.microsoft.com/en-us/visualstudio/test/quick-start-test-driven-development-with-test-explorer</a></li>
<li><em class="italic">Is TDD </em><em class="italic">Dead?</em>: <a href="https://martinfowler.com/articles/is-tdd-dead/">https://martinfowler.com/articles/is-tdd-dead/</a></li>
</ul>
</div>
</body></html>