- en: Mobile Shader Adjustment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the next two chapters, we are going to take a look at making the shaders
    that we write in a performance-friendly manner for different platforms. We won''t
    be talking about any one platform specifically, but we are going to break down
    the elements of shaders we can adjust in order to make them more optimized for
    mobiles and efficient on any platform in general. These techniques range from
    understanding what Unity offers in terms of built-in variables that reduce the
    overhead of the shaders memory to learning about ways in which we can make our
    own shader code more efficient. This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to make shaders more efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling your shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying our shaders for mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning the art of optimizing your shaders will come up in just about any game
    project that you work on. There will always come a point in any production where
    a shader needs to be optimized, or maybe it needs to use fewer textures but produces
    the same effect. As a technical artist or shader programmer, you have to understand
    these core fundamentals to optimize your shaders so that you can increase the
    performance of your game while still achieving the same visual fidelity. Having
    this knowledge can also help in setting the way in which you write your shader
    from the start. For instance, by knowing that the game built using your shader
    will be played on a mobile device, we can automatically set all our `Lighting`
    functions to use a half-vector as the view direction or set all of our float variable
    types to fixed or half so as to reduce the amountof memory used. These, and many
    other techniques, all contribute to your shaders running efficiently on your target
    hardware. Let's begin our journey and start learning how to optimize our shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques to make shaders more efficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a cheap shader? When first asked the question, it might be a little
    tough to answer, as there are many elements that go into making a more efficient
    shader. It could be the amount of memory used up by your variables. It could be
    the amount of textures the shader is using. It could also be that our shader is
    working fine, but we can actually produce the same visual effect with half the
    amount of data by reducing the amount of code we are using or data we are creating.
    We are going to explore a few of these techniques in this recipe and show how
    they can be combined to make your shader fast and efficient but still produce
    the high-quality visuals everyone expects from games today, whether on a mobile
    or PC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get this recipe started, we need to gather a few resources together.
    So, let''s perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and fill it with a simple sphere object and single directional
    light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new shader (`OptimizedShader01`) and material (`OptimizedShader01Mat`) and
    assign the shader to the material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then need to assign the material we just created to our sphere object in
    our
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'new scene:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, modify the shader so that it uses a diffuse texture and normal map
    and includes your own custom `Lighting` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, assign a base and normal map to your material (I used the `MudRockey`
    texture included in the assets for [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08),
    *Post Processing Stack*). You should now have a setup similar to the following
    screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This setup will allow us to take a look at some of the basic concepts that
    go into optimizing shaders using Surface Shaders in Unity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build a simple `DiffuseShader` to take a look at a few ways
    in which you can optimize your shaders in general.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll optimize our variable types so that they use less memory when they
    are
  prefs: []
  type: TYPE_NORMAL
- en: 'processing data:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the `struct Input` in our shader. Currently, our UVs are being
    stored in a variable of the `float2` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember that floats provide the highest form of precision at a full 32 bits
    of memory. This is needed for complex trigonometry or exponents, but if you can
    handle less precision, it''s much better to use either a half or a fixed instead.
    The half type provides up to 3 digits of precision using half the size, or 16
    bits of memory. That means we can have a `half2` with the same amount of memory
    of a single float. We need to change this to use `half2` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then move to our `Lighting` function and reduce the variables'' memory
    footprint by changing their types to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using the lowest precision type of `fixed`, which is only
    11  bits as compared to the `float` type's 32\. This is useful for simple calculations
    such as color or texture data, which is perfect for this particular case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In case you'd like a refresher on the fixed type as well as all of the other
    types we are using, please check out [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader*, or look at [https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html](https://docs.unity3d.com/Manual/SL-DataTypesAndPrecision.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can complete this optimization pass by updating the variables in
    our `surf()` function. Since we''re using texture data, it''s fine for us to use
    a `fixed4` here instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our variables optimized, we are going to take advantage of
    a built-in `Lighting` function variable so that we can control how lights are
    processed by this shader. By doing this, we can greatly reduce the number of lights
    the shader processes. Modify the `#pragma` statement in your shader with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can optimize this further by sharing UVs between the normal map and diffuse
    texture. To do this, we simply change the UV lookup in our `UnpackNormal()` function
    to use `_MainTex` UVs instead of the UVs of `_NormalMap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have removed the need for the normal map UVs, we need to make sure that
    we remove the normal map UV code from the `Input` `struct`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can further optimize this shader by telling the shader that it
    only works with certain renderers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of our optimization passes show us that we really don''t notice
    a difference in the visual quality, but we have reduced the amount of time it
    takes for this shader to be drawn to the screen. You will learn about finding
    out how much time it takes for a shader to render in the next recipe, but the
    idea to focus on here is that we achieve the same result with fewer data. So keep
    this in mind when creating your shaders. The following screenshot shows us the
    final result of our shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen the ways in which we can optimize our shaders, let's dive
    in a bit deeper and really understand how all of these techniques work, why we
    should use them, and look at a couple of other techniques that you can try for
    yourself in your own shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first focus our attention on the size of the data each of our variables
    is storing when we declare them. If you are familiar with programming, then you
    will understand that you can declare values or variables with different sizes
    of types. This means that a float actually has a maximum size in memory. The following
    description will describe these variable types in much more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Float**: A float is a full 32-bit precision value and is the slowest of the
    three'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: different types we see here. It also has its corresponding values of `float2`,
    `float3`, and `float4`, which allow us to store multiple floats in one variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Half**: The half variable type is a reduced 16-bit floating point value and
    is suitable for store UV values and color values and much faster than using a
    float value. As with the float type, it has its corresponding values, which are
    `half2`, `half3`, and `half4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fixed**: A fixed value is the smallest in size of the three types, but can
    be used for lighting calculations and colors and has the corresponding values
    of `fixed2`, `fixed3`, and `fixed4`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on working with array types for shaders, check out the
    *Using packed arrays* recipe from [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08),
    *Surface Shaders and Texture Mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: Our second phase of optimizing our simple shader was to declare the `noforwardadd`
    value to our `#pragma` statement. This is basically a switch that automatically
    tells Unity that any object with this particular shader receives only per-pixel
    light from a single directional light. Any other lights that are calculated by
    this shader will be forced to be processed as per-vertex lights using *spherical
    harmonic* values produced internally by Unity. This is especially obvious when
    we place another light in the scene to light our sphere object because our shader
    is doing a per-pixel operation using the normal map.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is great, but what if you wanted to have a bunch of directional lights
    in the scene and control over which of these lights is used for the main per-pixel
    light? Well, if you notice, each light has a Render Mode drop-down. If you click
    on this drop-down, you will see a couple of flags that can be set. These are Auto,
    Important, and Not Important. By selecting a light, you can tell Unity that a
    light should be considered more as a per-pixel light than a per-vertex light,
    by setting its render mode to Important and vice versa. If you leave a light set
    to Auto, then you will let Unity decide the best course of action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Place another light in your scene and remove the texture that is currently
    in the main texture for our shader. You will notice that the second point light
    does not react with the normal map, only the directional light that we created
    first. The concept here is that you save on per-pixel operations by just calculating
    all extra lights as vertex lights, and save performance by just calculating the
    main directional light as a per-pixel light. The following diagram visually demonstrates
    this concept as the point light is not reacting with the normal map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we did a bit of cleaning up and simply told the normal map texture
    to use the main texture's UV values, and we got rid of the line of code that pulled
    in a separate set of UV values specifically for the normal map. This is always
    a nice way to simplify your code and clean up any unwanted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also declared `exclude_pass: prepass` in our `#pragma` statement so that
    this'
  prefs: []
  type: TYPE_NORMAL
- en: shader wouldn't accept any custom lighting from the deferred renderer. This
    means that we can really use this shader effectively in the forward renderer only,
    which is set in the main camera's settings.
  prefs: []
  type: TYPE_NORMAL
- en: By taking a bit of time, you will be amazed at how much a shader can be optimized.
    You have seen how we can pack grayscale textures into a single RGBA texture as
    well as use lookup textures to fake lighting. There are many ways in which a shader
    can be optimized, which is why it is always an ambiguous question to ask in the
    first place, but knowing these different optimization techniques, you can cater
    your shaders to your game and target platform, ultimately resulting in very streamlined
    shaders and a nice steady frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling your shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how we can reduce the overhead that our shaders might take,
    let's take a look at how to find problematic shaders in a scene where you might
    have a lot of shaders or a ton of objects, shaders, and scripts, all running at
    the same time. To find a single object or shader among a whole game can be quite
    daunting, but Unity provides us with its built-in Profiler. This allows us to
    actually see, on a frame-by-frame basis, what is happening in the game, and each
    item that is being used by the GPU and CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Profiler, we can isolate items such as shaders, geometry, and general
    rendering items using its interface to create blocks of profiling jobs. We can
    filter out items until we are looking at the performance of just a single object.
    This then lets us see the effects on the CPU and GPU that the object has while
    it is performing its functions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look through the different sections of the Profiler and learn how
    to debug our scenes and, most importantly, our shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use our Profiler by getting a few assets ready and launching the Profiler
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the scene from the last recipe and launch the Unity Profiler from
    Window | Profiler or *Ctrl* + *7*. Feel free to drag and drop or move it so you
    can see it well. I personally put it at the same spot as the Inspector tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's also duplicate our sphere a couple more times to see how that affects
    our rendering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Profiler tab, click on the Deep Profile option to get additional information
    about the project and then play your game!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the Profiler, we will take a look at some of the UI elements of this
    window. Before we hit Play, let''s take a look at how to get the information we
    need from the Profiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, click on the larger blocks in the Profiler window called GPU Usage,
    CPU Usage, and Rendering. You will find these blocks on the left-hand side of
    the upper window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using these blocks, we can see different data specific to those major functions
    of our game. The CPU Usage is showing us what most of our scripts are doing, as
    well as physics and overall rendering. The GPU Usage block is giving us detailed
    information about the elements that are specific to our lighting, shadows, and
    render queues. Finally, the Rendering block is giving us information about the
    drawcalls and amount of geometry we have in our scene at any one frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you do not see the GPU Usage option, click on Add Profiler | GPU. It is possible
    that it may not show up if your graphics card drivers are not up to date.
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on each of these blocks, we can isolate the type of data we see
    during our profiling session.
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on the tiny colored blocks in one of these Profile blocks and hit
    Play, or *Ctrl* + *P*, to run the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This lets us dive down even deeper into our profiling session so that we can
    filter out what is being reported back to us. While the scene is running, uncheck
    all of the boxes, except for Opaque in the GPU Usage block. Notice that we can
    now see just how much time is being used to render the objects that are set to
    the Render Queue of Opaque:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another great function of the Profiler window is the action of clicking and
    dragging in the graph view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will automatically pause your game so that you can further analyze a certain
    spike in the graph to find out exactly which item is causing the performance problem.
    Click and drag around in the graph view to pause the game and see the effect of
    using this functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Turning our attention now towards the lower half of the Profiler window, you
    will notice that there is a dropdown item available when we have the GPU Block
    selected. We can expand this to get even more detailed information about the current
    active profiling session and, in this case, more information about what the camera
    is currently rendering and how much time it is taking up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the button that says No Details and changes the option to Show
    Related Objects, you can see what objects are being used in the functions being
    called.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a complete look at the inner workings of what Unity is processing
    in this particular frame. In this case, we can see that our three spheres with
    our optimized shader are taking roughly 0.066 milliseconds to draw to the screen,
    they are taking up fifteen drawcalls, and this process is taking 8.4% of the GPU's
    time in every frame (the numbers will likely be different depending on what hardware
    you have for your computer). It's this type of information we can use to diagnose
    and solve performance issues with regard to shaders. Let's conduct a test to see
    the effects of adding one more texture to our shader and blending two diffuse
    textures together using a `lerp` function. You will see the effects in the Profiler
    pretty clearly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `Properties` block of your shader with the following code to give
    us another texture to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s feed our texture to `CGPROGRAM`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to update our `surf()` function accordingly so that we blend
    our diffuse textures together:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once you save your modifications in your shader and return to Unity's editor,
    we can run our game and see the increase in milliseconds of our new shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach a new texture inside of your `Blend Texture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Press Play to start the game again with the Profiler turned on. Press Play
    once you have returned to Unity and let''s take a look at the results in our Profiler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see now that the amount of time to render our Opaque Shaders in this
    scene is taking 0.069 milliseconds, up from 0.066 milliseconds. By adding another
    texture and using the `lerp()` function, we increased the render time for our
    spheres. While it's a small change, imagine having 20 shaders all working in different
    ways on different objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using the information given here, you can pinpoint areas that are causing performance
    decreases more quickly and solve these issues using the techniques from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it's completely out of the scope of this book to describe how this tool
    actually works internally, we can surmise that Unity has given us a way to view
    the computer's performance while our game is running. Basically, this window is
    tied very tightly to the CPU and GPU to give us real-time feedback of how much
    time is being taken for each of our scripts, objects, and render queues. Using
    this information, we have seen that we can track the efficiency of our shader
    writing to eliminate problem areas and code.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that games running with the Profiler open, as well as
    from within the editor in general, will make the game slightly slower than it
    would be when compiled and running in a normal situation. You might even see the
    Editor in the Profilers list of CPU expenses.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also possible to profile specifically for mobile platforms. Unity provides
    us with a couple of extra features when the Android or iOS build target is set
    in the Build Settings. We can actually get real-time information from our mobile
    devices while the game is running. This becomes very useful because you are able
    to profile directly on the device itself instead of profiling directly in your
    editor. To find out more about this process, refer to Unity''s documentation at
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html](http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html).
    [](http://docs.unity3d.com/Documentation/Manual/MobileProfiling.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying our shaders for mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen quite a broad set of techniques for making really optimized
    shaders, let's take a look at writing a nice, high-quality shader targeted for
    a mobile device. It is actually quite easy to make a few adjustments to the shaders
    we have written so that they run faster on a mobile device. This includes elements
    such as using the `approxview` or `halfasview Lighting` function variables. We
    can also reduce the amount of textures we need and even apply better compression
    for the textures we are using. By the end of this recipe, we will have a nicely
    optimized normal-mapped, Specular Shader for use in our mobile games.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, let''s get a fresh new scene and fill it with some objects
    to apply our `MobileShader`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and fill it with a default sphere and single directional
    light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material (`MobileMat`) and shader (`MobileShader`), and assign
    the shader to the material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, assign the material to our sphere object in our scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When completed, you should have a scene similar to the one in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will write a mobile-friendly shader from scratch and discuss
    the elements that make it more mobile friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first populate our `Properties` block with the textures required. In
    this case, we are going to use a single `_Diffuse` texture with the gloss map
    in its alpha channel, `Normal map`, and a slider for specular intensity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next task is to set up our `#pragma` declarations. This will simply turn
    certain features of the Surface Shader on and off, ultimately making the shader
    cheaper or more expensive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line should be on one line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, remove the `#pragma target 3.0` line, as we are not using any of the features
    of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then need to make the connection between our `Properties` block and `CGPROGRAM`.
    This time, we are going to use the fixed variable type for our specular intensity
    slider in order to reduce its memory usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order for us to map our textures to the surface of our object, we need to
    get some UVs. In this case, we are going to get only one set of UVs to keep the
    amount of data in our shader down to a minimum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to fill in our `Lighting` function using a few of the new
    input variables that are available to us when using the new `#pragma` declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we complete the shader by creating the `surf()` function and processing
    the final color of our surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When finished with the code portion of this recipe, save your shader and return
    to the Unity editor to let the shader compile. If no errors occurred, assign some
    properties for the Base and Normal Map properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a few point lights and some copies of the new object and you should see
    a result similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's begin the description of this shader by explaining what it does and
    doesn't do. First, it excludes the deferred lighting pass. This means that if
    you created a `Lighting` function that was connected to the deferred renderer's
    `prepass`, it wouldn't use that particular `Lighting` function and would look
    for the default `Lighting` function like the ones that we have been creating thus
    far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: This particular shader does not support *lightmapping* by Unity's internal light-mapping
    system. This just keeps the shader from trying to find light maps for the object
    that the shader is attached to, making the shader more performance-friendly because
    it is not having to perform the lightmapping check.
  prefs: []
  type: TYPE_NORMAL
- en: We included the `noforwardadd` declaration so that we process only per-pixel
    textures with a single directional light. All other lights are forced to become
    per-vertex lights and will not be included in any per-pixel operations you might
    do in the `surf()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are using the `halfasview` declaration to tell Unity that we aren't
    going to use the main `viewDir` parameter found in a normal `Lighting` function.
    Instead, we are going to use the half vector as the view direction and process
    our specular with this. This becomes much faster for the shader to process as
    it will be done on a per-vertex basis. It isn't completely accurate when it comes
    to simulating specular in the real world, but visually, on a mobile device, it
    looks just fine and the shader is more optimized.
  prefs: []
  type: TYPE_NORMAL
- en: It's techniques like these that make a shader more efficient and cleaner, codewise.
    Always make sure that you are using only the data you need while weighing this
    against your target hardware and the visual quality that the game requires. In
    the end, a cocktail of these techniques is what ultimately makes up your shaders
    for your games.
  prefs: []
  type: TYPE_NORMAL
