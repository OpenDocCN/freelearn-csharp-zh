<html><head></head><body>
<div class="chapter" title="Chapter&#xA0;3.&#xA0; Basic Functions">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03"/>
 Chapter 3.  Basic Functions</h1>
</div>
</div>
</div>
<p>In this chapter, I'll cover the core element of the program code built with the functional paradigm, that is, <span class="strong">
<strong>function</strong>
</span>
 . The notion of a function is ubiquitous indeed. In the world around us, it may mean plenty of things, from purpose of something to dependency and to work in a certain manner. But here, I will consider it through the prism of computer programming, where a function generally means a method of computing results based on inputs. This examination is going to include the following:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">The notion of a function, the function definition and type signature, pure functions, referential transparency, and side effects</li>
<li class="listitem">Function parameters and arguments: a special type <code class="literal">unit</code>
 , the parameter number and type, the return value and type, currying, partial function application</li>
<li class="listitem">Higher-order functions, functions as arguments and return values, anonymous functions, functions as data type constituents, and functions as interfaces</li>
<li class="listitem">Closures, mutable values, and reference cells</li>
<li class="listitem">Type inference and inferred versus explicit types of function components</li>
<li class="listitem">Recursive function basics</li>
<li class="listitem">Operators as functions</li>
<li class="listitem">Composing functions and combinators</li>
</ul>
</div>
<p>As my ultimate goal is to make you embrace the REPL-based development style and spirit inherent to idiomatic F#, I'm going to run each and every mentioned feature through FSI in order to demonstrate the cause and effect.</p>
<div class="section" title="The notion of function in F#">
<div class="titlepage">
<div>
<div>
<h1 class="title" id="toc_1"><a id="ch03lvl1sec22"/>
 The notion of function in F#</h1>
</div>
</div>
</div>
<p>Let's begin with an intuitive definition of a function that many of us heard in school algebra class: function is a relationship that for each valid input yields a single consistent result. Such definition is a good enough to reflect both the commonality and the difference of functions and relations. In mathematics, a function is a relation, although not each relation is a function, as a relation may represent multiple results for the same single input. In the following figure, relation <span class="strong">
<strong>Rij</strong>
</span>
 on the left side is just fine for the representation of a function, as any item from set <span class="strong">
<strong>I</strong>
</span>
 maps to the one and only one item of set <span class="strong">
<strong>J</strong>
</span>
 . However, relation <span class="strong">
<strong>Rxy</strong>
</span>
 on the right side of the same figure cannot represent a function as at least one item of <span class="strong">
<strong>X</strong>
</span>
 exists, which maps to more than one item of <span class="strong">
<strong>Y</strong>
</span>
 , which is indicated by red mapping arrows.</p>
<div class="mediaobject"><img src="Image00006.jpg" alt="The notion of function in F#"/>
<div class="caption">
<p>Relations and functions</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Another very important matter is the mapping consistency. Any function, when being repeatedly given the same input must yield the same result.</p>
<p>Following our intuition, a function in programming languages, including F#, represents a computation where the result is determined by performing a transformation of a valid input. As with any concrete computation, it consumes some memory and certain time to complete and carries some kind of behavior. And the behavior, the way of the computation, and the manner of the transformation in turn is determined by the function definition.</p>
<div class="section" title="The function definition">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch03lvl2sec53"/>
 The function definition</h2>
</div>
</div>
</div>
<p>In general, the F# function carries a name, has a parameter(s), returns a result of some type, and has a body. The following figure illustrates the coupling of these components. A function resembles an opaque box performing some transformation of the input to the output. It hides the specific details of how the transformation is exactly performed, declaring only the purpose and the signature to the world, in other words, types of input and output. The function may be turned to a white transparent box if its definition is available, ripping the opaque box apart and revealing the details of implementation. However the definition may or may not be available; the latter case is typical for libraries and modules (remember the hiding of moving parts). I intentionally used input in place of parameter(s); I'll later show that functions of multiple parameters can be presented with functions of just a single parameter:</p>
<div class="mediaobject"><img src="Image00007.jpg" alt="The function definition"/>
<div class="caption">
<p>Function components and the purpose</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>These function components are fastened together in a language syntax by binding a function value as shown in the following pseudocode:</p>
<pre class="programlisting">let function-name parameter-list [: return-type] = body-expression 
</pre>
<p>The preceding binding is not the only way of defining functions in F#; it may carry a few additional elements for special cases. I'll cover these missing details later.</p>
<p>Using the preceding syntax, we may, for example, define the F# function for the computing of the area of a circle of the given radius, as shown in the following code (<code class="literal">Ch3_1.fsx</code>
 ):</p>
<pre class="programlisting">let circleArea radius = System.Math.PI * radius * radius 
</pre>
<p>Here, <code class="literal">System.Math.PI</code>
 is a field of the .NET <code class="literal">System.Math</code>
 class representing the ratio of the circumference of a circle to its diameter.</p>
<p>Executing the function defined as such with the argument value <code class="literal">5.0</code>
 for the radius parameter in FSI yields the following result:</p>
<pre class="programlisting">&gt; circleArea 5.0;; 
val it : float = 78.53981634 
&gt; 
</pre>
<p>It is worth noting that F# does not introduce any keyword to return the function result. The result is just the value of the last expression calculated within the function.</p>
</div>
<div class="section" title="The function type signature">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch03lvl2sec54"/>
 The function type signature</h2>
</div>
</div>
</div>
<p>Let's enter the sole name of the <code class="literal">circleArea</code>
 function into FSI, as shown in the following code:</p>
<pre class="programlisting">&gt; circleArea;; 
val it : (float -&gt; float) = &lt;fun:it@7&gt; 
</pre>
<p>The FSI response represents the <code class="literal">circleArea</code>
 type signature, (<code class="literal">float -&gt; float</code>
 ), which means that it is a function that takes the argument of type <code class="literal">float</code>
 and returns the result of type <code class="literal">float</code>
 . This function type signature is very simple. As we dive deeper , we'll examine more complex examples of function signatures. I'll show you that reading and understanding them is an absolutely essential skill for a functional programmer.</p>
<p>Another detail that an attentive reader may have already spotted is this: how did the F# compiler jump to the conclusion that the type of <code class="literal">radius</code>
 is <code class="literal">float</code>
 ? For now, just take my word that the compiler derived this following a deterministic procedure named <code class="literal">type inference</code>
 . It plays an outstanding role in decreasing the amount of bugs in the F# code and also attributes to code succinctness. F# implements a very specific manner of statically inferring types called <span class="strong">
<strong>Hindley-Milner type inference algorithm</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a>
 ). I will devote substantial attention to the inferring of types later in the chapter.</p>
</div>
<div class="section" title="Pure functions">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch03lvl2sec55"/>
 Pure functions</h2>
</div>
</div>
</div>
<p>A computer function implementation may or may not have this key property of the more abstract function notion: the consistency of repeatedly returning the same result when being given the same argument(s). The <code class="literal">circleArea</code>
 function defined previously, apparently carries this property. It does not depend on anything beyond its arguments and definition and does not change anything around beyond simply returning an idempotent result. Functions that have these useful properties are considered <span class="strong">
<strong>pure</strong>
</span>
 , or <span class="strong">
<strong>referentially transparent</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Referential_transparency">https://en.wikipedia.org/wiki/Referential_transparency</a>
 ); otherwise, they depend on something or have side effects and are hence <span class="strong">
<strong>impure</strong>
</span>
 .</p>
<p>Let me demonstrate a simple impure function, in the following code (<code class="literal">Ch3_1.fsx</code>
 ):</p>
<pre class="programlisting">let opaque arg = 
  System.DateTime.Now.Second * (if arg % 2 = 0 then 2 else 1) 
</pre>
<p>Running the preceding code in FSI yields the following result:</p>
<pre class="programlisting">&gt; opaque 15;; 
val it : int = 46 
&gt; opaque 15;; 
val it : int = 49 
&gt; opaque 16;; 
val it : int = 112 
&gt; opaque 16;; 
val it : int = 6 
</pre>
<p>So, the <code class="literal">opaque</code>
 impurity gets apparent from simply observing its subsequent calls with repeated arguments.</p>
</div>
</div>
</div>


<div class="section" title="Function parameters and arguments">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec23"/>
 Function parameters and arguments</h1>
</div>
</div>
</div>
<p>In our sample function definition given by the following code (<code class="literal">Ch3_1.fsx</code>
 ):</p>
<pre class="programlisting">let circleArea radius = 
  System.Math.PI * radius * radius 
</pre>
<p>The <code class="literal">radius</code>
 identifier represents the function <span class="strong">
<strong>parameter</strong>
</span>
 , that is, the name for a value that is expected to be transformed by the function. The value supplied for the parameter upon the function use represents the function <span class="strong">
<strong>argument</strong>
</span>
 , as shown when we apply our function in the following code line:</p>
<pre class="programlisting">circleArea 15.0 
</pre>
<p>
<code class="literal">15.0</code>
 is the function's argument in the preceding line.</p>
<div class="section" title="The tuples preview">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch03lvl2sec56"/>
 The tuples preview</h2>
</div>
</div>
</div>
<p>At this point, in order to reveal the further details about function parameters, a certain notion would be required, which logically belongs to a completely different language facility, specifically to data types. I'm talking about <span class="strong">
<strong>tuples</strong>
</span>
 . As it doesn't seem feasible to build an ideally straight storyline, I will provide a necessary preview here and then revisit the subject of tuples in later chapters.</p>
<p>A <span class="strong">
<strong>tuple</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233200.aspx">https://msdn.microsoft.com/en-us/library/dd233200.aspx</a>
 ) is an immutable F# data type that represents a parenthesis enclosed, comma separated, ordered grouping of arbitrary values. That is, grouping assumes at least a pair of values. Types of these values are completely arbitrary, and it does not matter whether they are the same or not.</p>
<p>An example of a tuple is as follows:</p>
<pre class="programlisting">let dateParts = (2016,"Feb",29) 
</pre>
<p>The constituent value of a tuple can be represented by an expression as well, as shown in the following code:</p>
<pre class="programlisting">let (perimeter,area) = 
  (System.Math.PI * 2. * r, System.Math.PI * r * r) 
</pre>
<p>I will wrap up this brief preview by covering what the tuple type signature looks like. It is built from types of constituents following the established order and separated by the <code class="literal">*</code>
 symbol. So following this arrangement, the type of tuple <code class="literal">dateParts</code>
 shown in the preceding code is <code class="literal">int*string*int</code>
 .</p>
</div>
<div class="section" title="Special type unit">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch03lvl2sec57"/>
 Special type unit</h2>
</div>
</div>
</div>
<p>There is just another component of the functions realm, which comes from the distinction between computer programming functions and functions of mathematics. This is the special type with the sole purpose of denoting the absence of a parameter and/or result, namely <code class="literal">unit</code>
 . This type is the simplest imaginable and has just a single value, represented by just a pair of brackets that have nothing in between. The following is the representation:</p>
<pre class="programlisting">() 
</pre>
<p>Nevertheless, <code class="literal">unit</code>
 plays the important role of the absence indicator. This absence may manifest itself as shown in the following function definition, which can be a poor man's generator of random numbers between 0 and 1000 (<code class="literal">Ch3_1.fsx</code>
 ):</p>
<pre class="programlisting">let getNextRandom () = (%) System.DateTime.Now.Ticks 1000L 
</pre>
<p>If you consider the preceding binding, then having <code class="literal">()</code>
 after <code class="literal">getNextRandom</code>
 is the only way to disambiguate the function binding that denotes the calculation process from just a value binding denoting the result of a single calculation.</p>
<p>Indeed, if I run both binding variants using FSI, the difference should be memorable: without a <code class="literal">unit</code>
 parameter, <code class="literal">getNextRandom</code>
 is bound to just an immutable <code class="literal">int64</code>
 value; otherwise, it is bound to a function that has the (<code class="literal">unit -&gt; int64</code>
 ) signature, and after being repeatedly called, it returns a different result each time. The following screenshot captures this distinction:</p>
<div class="mediaobject"><img src="Image00008.jpg" alt="Special type unit"/>
<div class="caption">
<p>The argument unit differentiates between the value and function bindings</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The similarly interesting case has place when <code class="literal">unit</code>
 is a value of expression returned from a function. Intuition should prompt you that if a function returns nothing, or rather <code class="literal">()</code>
 , then its purpose could be to induce a side effect. Let's slightly change the definition of <code class="literal">getNextRandom</code>
 as shown in the following code (<code class="literal">Ch3_1.fsx</code>
 ):</p>
<pre class="programlisting">let getNextRandom () = 
  printfn "%d" ((%) System.DateTime.Now.Ticks 1000L) 
</pre>
<p>Now, the function signature turns to (<code class="literal">unit -&gt; unit</code>
 ), and calling it, just outputs a random number between 0 and 999, returning the result of type <code class="literal">unit</code>
 .</p>
</div>
<div class="section" title="Currying and partial function application">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch03lvl2sec58"/>
 Currying and partial function application</h2>
</div>
</div>
</div>
<p>Let's define a simple function, <code class="literal">myPrintFunC</code>
 , which takes a <code class="literal">string</code>
 and an <code class="literal">int</code>
 as parameters and returns <code class="literal">unit</code>
 as shown in the following code:</p>
<pre class="programlisting">let myPrintFunC header value = printfn "%s %d" header value 
</pre>
<p>The type of <code class="literal">myPrintFunC</code>
 is (<code class="literal">string -&gt; int -&gt; unit</code>
 ).</p>
<p>Another, almost similar, simple function is <code class="literal">myPrintFunT</code>
 , which also takes a <code class="literal">string</code>
 and an <code class="literal">int</code>
 as parameters and returns <code class="literal">unit</code>
 , but the parameters are tupled as shown in the following code:</p>
<pre class="programlisting">let myPrintFunT (header,value) = printfn "%s %d" header value 
</pre>
<p>The type of <code class="literal">myPrintFunT</code>
 is (<code class="literal">string*int -&gt; unit</code>
 ).</p>
<p>Applying <code class="literal">myPrintFunC</code>
 <code class="literal">"The Answer is" 42</code>
 outputs <code class="literal">The Answer is 42</code>
 . Similarly, applying <code class="literal">myPrintFunT ("The Answer is", 42)</code>
 outputs <code class="literal">The Answer is 42</code>
 too. So what's the fuss about?</p>
<p>The fundamental distinction is in the manner in which these functions accept their arguments: arguments of <code class="literal">myPrintFunC</code>
 are curried, but arguments of <code class="literal">myPrintFunT</code>
 are tupled.</p>
<p>Because of being familiar with tuples, you should not be surprised that <code class="literal">let t = ("The Answer is", 42)</code>
 in <code class="literal">myPrintFunT</code>
 outputs the same result: <code class="literal">The Answer is 42</code>
 . The signature of <code class="literal">myPrintFunT</code>
 prompted us of the single function parameter of the type <code class="literal">string*int</code>
 tuple.</p>
<p>The case of <code class="literal">myPrintFunC</code>
 is more interesting. The arrow <code class="literal">-&gt;</code>
 in its signature is the right associative operation, so I can rewrite its signature as (<code class="literal">string -&gt; (int -&gt; unit)</code>
 ), correct? But wait a minute; isn't (<code class="literal">int -&gt; unit</code>
 ) representing a function that takes the <code class="literal">int</code>
 parameter and returns <code class="literal">unit</code>
 ? Yes, it does. So, getting back to <code class="literal">myPrintFunC</code>
 , why can't I consider it as a function that takes the <code class="literal">string</code>
 parameter and returns a new interim function, in turn taking the <code class="literal">int</code>
 parameter and returning <code class="literal">unit</code>
 ? In the end, functions are first-class entities in F#, so a returned value can be of the function type. Now let's turn back to the following code:</p>
<pre class="programlisting">(myPrintFunC "The Answer is") 42 
</pre>
<p>This still returns <code class="literal">The Answer is 42</code>
 . And in order to make the mechanics fully transparent, let's play the preceding transformation step by step in FSI:</p>
<div class="mediaobject"><img src="Image00009.jpg" alt="Currying and partial function application"/>
<div class="caption">
<p>Partial function application</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>As the preceding screenshot illustrates, the <code class="literal">myPrintFunC</code>
 function is originally defined as having two parameters. When it is applied just to the first argument, it returns another function, <code class="literal">interimFun</code>
 , which has just one parameter that, if in turn is applied to the second argument, returns exactly the same result as the original function applied to both arguments. As may be expected, the result is <code class="literal">The Answer is 42</code>
 ; the fans of Douglas Adams already knew this.</p>
<p>My congratulations to you; you just grasped one of the utterly important techniques of functional programming, namely, <span class="strong">
<strong>partial function application</strong>
</span>
 . Partial application is achieved by simply omitting one or more trailing function arguments.</p>
<p>So, <span class="strong">
<strong>currying</strong>
</span>
 is built on the principle of partial function application. Any function definition of multiple parameters in a curried form is just a syntactic sugar for the process of currying, implicitly transforming the original definition to a composition of functions, each comprising one parameter. Currying is the default feature of F#; it makes partial function application available anytime.</p>
</div>
<div class="section" title="The number and the type of function parameters and return values">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch03lvl2sec59"/>
 The number and the type of function parameters and return values</h2>
</div>
</div>
</div>
<p>I want to reiterate the earlier findings in relation to the F# functions parameters and return value in order to leave you with a very simple mental model, that is:</p>
<div class="note" title="Note">
<h3 class="title" id="toc_5"><a id="note3"/>
 Note</h3>
<p>All F# functions have a single parameter and return a single result.</p>
<p>Functions without parameters and/or without a return value fit this model using a <code class="literal">unit</code>
 value in place of the omitted entities.</p>
<p>Functions with multiple parameters and multiple return values may fit the preceding model by making the parameters and return values into a single tuple each.</p>
<p>Functions that have multiple parameters in a curried form fit the singular parameter model via a recurrent transformation into a function, taking the first argument and returning the new function that has this argument partially applied.</p>
</div>
<p>Further fine grain details to the preceding principle come from the .NET side, when we deal with not only pristine F# functions, but also with static and instance methods of .NET libraries and our custom types. These will be covered in later chapters.</p>
</div>
</div>


<div class="section" title="Higher-order functions">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec24"/>
 Higher-order functions</h1>
</div>
</div>
</div>
<p>I've mentioned on many occasions that functions are first-class entities in F# because they can be used as arguments for other functions or can be returned from other functions as results. This is exactly the indication of higher-order functions. A higher-order function may have another function as a parameter, it may return another function as a result, or it may perform both these things.</p>
<p>All functions are considered function values in F#; this treatment allows you to not make any distinction between functions and other kinds of values in any context where values are used. I will cover some such contexts here, namely an argument to another function, a value returned from a function, and a part of a data structure.</p>
<div class="section" title="Anonymous functions">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch03lvl2sec60"/>
 Anonymous functions</h2>
</div>
</div>
</div>
<p>In some situations, it makes sense to have the ability of defining a function that does not carry the explicit name. Typically, such an ability is nice to have for functions that are the subject of manipulation by higher-order functions. A concise way to set arguments or results that does not involve a full blown function definition is required. Why is that? The first consideration that comes to my head is that the name may be needed for the future reference. If a function is defined by the name and then this name is referred multiple times from other locations of the program code, then this function that has a name makes perfect sense. On the contrary, if the function is defined as an argument of a higher-order function and is never used outside this single occurrence, then the name is redundant. Another consideration is the use of function values; for example, using a function as an argument to another function may not require any name for the former.</p>
<p>The syntax to define an anonymous function is as follows:</p>
<pre class="programlisting">fun parameter-list -&gt; expression 
</pre>
<p>Here, <code class="literal">parameter-list</code>
 represents tupled or curried parameter names, optionally carrying explicit parameter types. Note that anonymous functions defined with the <code class="literal">fun</code>
 keyword represent a <span class="strong">
<strong>lambda expression</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233201.aspx">https://msdn.microsoft.com/en-us/library/dd233201.aspx</a>
 ). A lambda expression has the value represented by the anonymous function. Realizing this tidbit is important in order to understand the first-class treatment of functions in F#.</p>
</div>
<div class="section" title="Functions as arguments">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch03lvl2sec61"/>
 Functions as arguments</h2>
</div>
</div>
</div>
<p>Functions as arguments is perhaps the most common use of functions in functional programs. Typical F# libraries are implemented as highly optimized sets of higher-order functions that can be tuned for any concrete task by providing specific functions as arguments. For example, a square scalar matrix 5 x 5 with main diagonal elements of 1s may be created using the <code class="literal">Array2D.init</code>
 library function. <span class="strong">
<strong>Array2D.init</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee353720.aspx">https://msdn.microsoft.com/en-us/library/ee353720.aspx</a>
 ) is a higher-order function that has a signature of (<code class="literal">int-&gt;int-&gt;(int-&gt;int-&gt;'T)-&gt;'T[,]</code>
 ), where the inner part of the signature represents the so-called <span class="strong">
<strong>initializer</strong>
</span>
 or the function that sets the individual elements of the matrix based on their indices. The following anonymous function for initializing the elements of a diagonal matrix according to their indices can be used:</p>
<pre class="programlisting">fun x y -&gt; if x = y then 1 else 0 
</pre>
<p>The following screenshot demonstrates the achievement of this task in FSI by plugging the preceding function into the expression (<code class="literal">Ch3_2.fsx</code>
 ) as follows:</p>
<pre class="programlisting">Array2D.init 5 5 (fun x y -&gt; if x = y then 1 else 0) 
</pre>
<p>Observe the sought-for matrix being built and shown:</p>
<div class="mediaobject"><img src="Image00010.jpg" alt="Functions as arguments"/>
<div class="caption">
<p>Using an anonymous function as an argument to a higher-order function</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
<div class="section" title="Functions as return values">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_3"><a id="ch03lvl2sec62"/>
 Functions as return values</h2>
</div>
</div>
</div>
<p>As I mentioned in the function definition section, the function return value is just the value of the last expression. In order to return a function, we may use as the last expression of the host function: either an anonymous function definition, or a partial function application.</p>
<p>Let's look into this matter by performing a harder exercise. Quite frequently, it helps to have a function that allows you to accurately measure the duration of the execution of an arbitrary calculation wrapped into some other function. Furthermore, it is also helpful to have the information about the environment baked into measurement results.</p>
<p>So, I'm going to implement a higher-order function, <code class="literal">stopWatchGenerator</code>
 , which takes another function, <code class="literal">f</code>
 , with parameter, <code class="literal">x</code>
 , as its own arguments and returns a function value represented by an anonymous function with exactly the same signature. This anonymous function just wraps the calculation (<code class="literal">f x</code>
 ) with this calculation duration measurement taken with millisecond precision. It communicates the measured duration to the output device, accompanying it with the name of the main executable file. So, for 32-bit FSI, it would be just [<code class="literal">fsi</code>
 ]; for 64-bit FSI, it would be [<code class="literal">fsiAnyCPU</code>
 ]; and for a custom executable, it would be the name of the executable file. Sometimes, such utility can be pretty helpful, right?</p>
<p>The implementation is given in the following code (<code class="literal">Ch3_3.fsx</code>
 ):</p>
<pre class="programlisting">let stopWatchGenerator (f:('a-&gt;'b)) (x: 'a) : (('a-&gt;'b)-&gt;'a-&gt;'b) = 
  let whoRunsMe = 
    System 
    .Diagnostics 
    .Process 
    .GetCurrentProcess() 
    .MainModule 
    .FileName 
    |&gt; System.IO.Path.GetFileNameWithoutExtension 
    |&gt; sprintf "[%s]:" in 
  fun f x -&gt; 
    let stopWatch = System.Diagnostics.Stopwatch() in 
    try 
      stopWatch.Start() 
      f x 
    finally 
      printf "Took %dms in %s\n" 
      stopWatch.ElapsedMilliseconds 
      whoRunsMe 
 
let whatItTakes f x = (stopWatchGenerator f x) f x 
</pre>
<p>Please note that I intentionally put explicit types for <code class="literal">stopWatchGenerator</code>
 arguments <code class="literal">f</code>
 , which is the function taking the argument of generic type <code class="literal">'a</code>
 and returning the result of generic type <code class="literal">'b</code>
 , and <code class="literal">x</code>
 , which is the value of type <code class="literal">'a</code>
 , and for the <code class="literal">stopWatchGenerator</code>
 return type, which is the function taking two curried arguments of types <code class="literal">('a-&gt;'b)</code>
 and <code class="literal">'a</code>
 and returning the result of type <code class="literal">'b</code>
 .</p>
<p>Does your head begin spinning yet? This is fine, please stay assured that you will get accustomed to these seemingly complicated manipulations and will soon find them as easy as apple pie.</p>
<p>The function <code class="literal">stopWatchGenerator</code>
 returns the sought anonymous function using the <code class="literal">fun</code>
 lambda expression, which creates the instance of .NET <code class="literal">System.Diagnostics.Stopwatch()</code>
 and wraps its start and take readings around the evaluation of the target expression (<code class="literal">f x</code>
 ).</p>
<p>The function <code class="literal">whatItTakes</code>
 is just a convenient abbreviation for the arrangement with function evaluation shadow timing.</p>
<p>The following screenshot shows two examples of using the generated function:</p>
<div class="mediaobject"><img src="Image00011.jpg" alt="Functions as return values"/>
<div class="caption">
<p>A function returning another function in action</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>The first use case checks how much time is required in order to produce and add together the first 10 million positive numbers as shown in the following code:</p>
<pre class="programlisting">&gt; whatItTakes (fun x -&gt; seq {1L .. x} |&gt; Seq.sum) 10000000L;; 
Took 242ms in [fsianycpu]: 
val it : int64 = 50000005000000L 
&gt; 
</pre>
<p>The second use case demonstrates a way of calculating the pi with certain precision by applying the <span class="strong">
<strong>
<span class="strong">
<strong>Gregory series</strong>
</span>
</strong>
</span>
 (<a class="ulink" href="http://mathworld.wolfram.com/GregorySeries.html">http://mathworld.wolfram.com/GregorySeries.html</a>
 ) method, using an arbitrary series length as shown in the following code:</p>
<pre class="programlisting">&gt; whatItTakes (fun cutoff -&gt; 
  (Seq.initInfinite (fun k -&gt; (if k%2 = 0 then - 1.0 else  1.0)/((float k) * 2.0 - 1.0)) 
  |&gt; Seq.skip 1 
  |&gt; Seq.take cutoff 
  |&gt; Seq.sum) * 4.0) 2000000;; 
Took 361ms in [fsianycpu]: 
val it : float = 3.141592154 
&gt; 
</pre>
<p>As the results indicate, the Gregory series is not the greatest formula for the calculation of pi; nevertheless, it can serve the purpose of demonstrating the power of function values.</p>
</div>
<div class="section" title="Functions as data type constituents">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_4"><a id="ch03lvl2sec63"/>
 Functions as data type constituents</h2>
</div>
</div>
</div>
<p>Now, you may come up with a crafty question: "Values of primitive types may be combined into more complex types; for example, a handful of <code class="literal">int</code>
 values can be stored in an <code class="literal">int</code>
 array. If functions are really first-class values, they should allow a similar kind of composition as well. How about constructing an array of functions?"</p>
<p>My answer is: "Sure, why not?" Let's consider the following function definition (<code class="literal">Ch3_4.fsx</code>
 ):</p>
<pre class="programlisting">let apply case arg = 
  if case = 0 then 
    sin arg 
  elif case = 1 then 
    cos arg 
  elif case = 2 then 
    asin arg 
  elif case = 3 then 
    acos arg 
  else 
    arg 
</pre>
<p>The function <code class="literal">apply</code>
 takes two arguments, and if the first one, <code class="literal">case</code>
 , is in the range of <code class="literal">0</code>
 to <code class="literal">3</code>
 , it applies the corresponding math library trigonometry function to the second argument, <code class="literal">arg</code>
 . Otherwise, it just returns the <code class="literal">arg</code>
 value unchanged, just a dull no-brainer implementation. Let's spice it up by arranging the functions into the array as shown in the following code:</p>
<pre class="programlisting">let apply' case arg = 
  try 
    [|sin; cos; asin; acos|].[case] arg 
  with 
    | :?System.IndexOutOfRangeException -&gt; arg 
</pre>
<p>I've used the F# <code class="literal">try...with</code>
 construction in order to sift instances of case values that require the specific function application from those that return just the <code class="literal">arg</code>
 echo.</p>
<p>This is achieved with the <code class="literal">[|sin; cos; asin; acos|]</code>
 construction that has the (<code class="literal">float -&gt; float</code>
 ) <code class="literal">[]</code>
 signature. This means exactly what was expected, or an array of functions of the same type (taking the single argument of type <code class="literal">float</code>
 and returning a result of type <code class="literal">float</code>
 ). Each array element position is tied with the specific function instance with the help of the <code class="literal">[case]</code>
 indexer, or <code class="literal">[|sin; cos; asin; acos|]</code>
 <code class="literal">.[0]</code>
 yields <code class="literal">sin</code>
 , <code class="literal">[|sin; cos; asin; acos|]</code>
 <code class="literal">.[1]</code>
 yields <code class="literal">cos</code>
 , and so on. The value of the <code class="literal">[|sin; cos; asin; acos|].[case]</code>
 expression is a function where the case value is in the valid range of <code class="literal">0</code>
 to <code class="literal">3</code>
 . As such, it can be applied to <code class="literal">arg</code>
 , yielding the corresponding result. The <code class="literal">case</code>
 value out of the valid range entails the <code class="literal">System.IndexOutOfRangeException</code>
 exception and is caught and processed by simply returning the echoed value of <code class="literal">arg</code>
 . I must admit that abusing the exception mechanism the way it is done above is awful coding practice, but please forgive me for using it within the toy example while demonstrating some totally unrelated feature.</p>
</div>
<div class="section" title="Functions are interfaces">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_5"><a id="ch03lvl2sec64"/>
 Functions are interfaces</h2>
</div>
</div>
</div>
<p>In the light of the dual nature of F# being a functional-first language and at the same time supporting an object-oriented type system of .NET, it is worth taking a look at the relationship between functions and interfaces. The original <span class="strong">
<strong>Gang of Four book</strong>
</span>
 (<a class="ulink" href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610">http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610</a>
 ) points to the following principle of reusable object-oriented design in its introduction:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Program to an interface, not an implementation.</em>
</span>
</p>
</blockquote>
</div>
<p>From this standpoint, a function is the quintessence of an interface. While in the object-oriented world, an interface must be explicitly declared prior to one of its implementations may be substituted by another, in the functional programming realm, this declaration is excessive. As long as two or more functions have the same signatures, they may be used interchangeably in the code. Function signature is the equivalent of the interface.</p>
<p>My previous example with the array of functions clearly demonstrates how the change of implementation can be achieved as simply as through changing the array element index value.</p>
</div>
</div>


<div class="section" title="Closures">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec25"/>
 Closures</h1>
</div>
</div>
</div>
<p>As I already mentioned, the function result depends on parameters. Is this dependency exhaustive? Certainly not. The function definition exists in a lexical context and is free to use some entities from this context in the course of the transformation of arguments into the result. Let's consider the following code example (<code class="literal">Ch3_5.fsx</code>
 ):</p>
<pre class="programlisting">let simpleClosure = 
  let scope = "old lexical scope" 
  let enclose() = 
    sprintf "%s" scope 
  let scope = "new lexical scope" 
  sprintf "[%s][%s]" scope (enclose()) 
</pre>
<p>The preceding <code class="literal">enclose()</code>
 function does not have any parameters except <code class="literal">unit</code>
 . However, the result that's returned depends on the free value <code class="literal">scope</code>
 that was in the lexical scope at the time of the function definition. Let <code class="literal">scope</code>
 value be bound to the <code class="literal">"old lexical scope"</code>
 value. This value gets captured, "closed" by the <code class="literal">enclose()</code>
 definition. Together, the contextual part and the definition form the special entity named <span class="strong">
<strong>closure</strong>
</span>
 . This process is schematically presented in the following figure:</p>
<div class="mediaobject"><img src="Image00012.jpg" alt="Closures"/>
<div class="caption">
<p>A sample of a closure</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Because they're closed, the free values do not change. In the following sample, the value <code class="literal">scope</code>
 is later shadowed by the new value, <code class="literal">"new lexical scope"</code>
 . However, this does not change the value captured within the closure. This is reflected in the following figure, which shows the running of the last example in FSI, where both old and new scopes coexist:</p>
<div class="mediaobject"><img src="Image00013.jpg" alt="Closures"/>
<div class="caption">
<p>A simple closure in action</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Here, I provide another example of closure, demonstrating this time the capturing and updating of the state in the closure created by the anonymous function definition (<code class="literal">Ch3_5.fsx</code>
 ):</p>
<pre class="programlisting">let trackState seed = 
  let state = ref seed in 
  fun () -&gt; incr state; (!state, seed) 
</pre>
<p>In this snippet, the <code class="literal">trackState</code>
 function captures its own argument into a closure accompanied by the anonymous function, which increments the local counter hidden in this closure on each invocation. The upcoming figure illustrates two independent closures, <code class="literal">counter1()</code>
 and <code class="literal">counter2()</code>
 , created off separate <code class="literal">trackState</code>
 invocations with different seeds tracking their own state:</p>
<div class="mediaobject"><img src="Image00014.jpg" alt="Closures"/>
<div class="caption">
<p>Closures representing objects</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>This sample highlights how closures can be used to represent inner fields even if the language does not really support objects. In this respect, as one of programming fables goes, <span class="strong">
<strong>closures are a poor man's objects</strong>
</span>
 (<a class="ulink" href="http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent">http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent</a>
 ) indeed.</p>
<div class="section" title="Mutable values">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch03lvl2sec65"/>
 Mutable values</h2>
</div>
</div>
</div>
<p>In the spirit of the functional-first language, F# values are immutable by default. However, the language offers facilities for the use of mutable values.</p>
<p>Mutable variables can be created using the <code class="literal">let mutable</code>
 syntax of value binding and the <code class="literal">&lt;-</code>
 assignment operator to mutate the earlier bound values. Mutable values bound with <code class="literal">let mutable</code>
 are stored on the stack.</p>
<p>Until F# v4.0, it was not allowed to write code capturing mutable values in closures, but beginning with the  v4.0 version of the language, this limitation has been lifted.</p>
</div>
<div class="section" title="Reference cells">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_2"><a id="ch03lvl2sec66"/>
 Reference cells</h2>
</div>
</div>
</div>
<p>An alternative facility for mutable values is reference cells inherited from OCaml. These values are allocated on the heap using the <code class="literal">let</code>
 binding with the special <code class="literal">ref</code>
 function. The underlying value of a reference cell is accessed with the help of dereference operator <code class="literal">!</code>
 . The referenced value can be mutated by the special assignment operator <code class="literal">:=</code>
 .</p>
<p>There is a subtle difference between mutable values and reference cells: mutable values are copied <span class="emphasis">
<em>by value</em>
</span>
 while reference cells are copied <span class="emphasis">
<em>by reference</em>
</span>
 . Let me offer you the code snippet illuminating this matter (<code class="literal">Ch3_6.fsx</code>
 ):</p>
<pre class="programlisting">let mutable x = "I'm x" 
let mutable y = x 
y &lt;- "I'm y" 
sprintf "%s|%s" x y 
 
let rx = ref "I'm rx" 
let ry = rx 
ry := "I'm ry" 
sprintf "%s|%s" !rx !ry 
</pre>
<p>The following figure demonstrates by running the preceding code snippet in FSI how this difference manifests itself: mutable values <code class="literal">x</code>
 and <code class="literal">y</code>
 are independent, so changing <code class="literal">y</code>
 value from being identical to <code class="literal">x</code>
 value to something different does not anyhow affect <code class="literal">x</code>
 ; their values stay different.</p>
<p>However, <code class="literal">rx</code>
 and <code class="literal">ry</code>
 reference the same object, so changing the underlying object via the <code class="literal">ry</code>
 reference simultaneously changes the previous object referenced by <code class="literal">rx</code>
 to the same one that <code class="literal">ry</code>
 references:</p>
<div class="mediaobject"><img src="Image00015.jpg" alt="Reference cells"/>
<div class="caption">
<p>The difference between mutable and ref values</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
</div>
</div>


<div class="section" title="Type inference">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec26"/>
 Type inference</h1>
</div>
</div>
</div>
<p>I have already outlined type inference earlier in the chapter. It is a feature of F# (as well as many other languages: C#, to begin with) that stems from its property of being statically typed. By following the natural code flow direction from top to bottom and from left to right, the F# compiler is capable of deriving types of values present in the code, including function types. This ability, in turn, allows you to omit explicit type declarations from the F# code. In the end, the code can be written faster, is quite succinct, and if it compiles, is consistent type-wise.</p>
<p>Relying on type inference is not mandatory when writing the F# code. Adding an explicit declaration to the code may be especially meaningful in the following scenarios:</p>
<div class="itemizedlist">
<ul class="itemizedlist">
<li class="listitem">When the types cannot be inferred and the compiler prompts for the explicit declaration</li>
<li class="listitem">If the code's author believes that providing explicit type declaration in some cases may simplify the code understanding and improve its readability</li>
</ul>
</div>
<p>The most obvious way of inferring the value type is during binding based on the type of the expression to the right of the <code class="literal">=</code>
 sign as shown in the following code (<code class="literal">Ch3_7.fsx</code>
 ):</p>
<pre class="programlisting">let s = "I'm a string" 
let dict = 
  System.Collections.Generic.Dictionary&lt;string, string list&gt;() 
</pre>
<p>For <code class="literal">s</code>
 , this is the type of literal on the right-hand side, or <code class="literal">string</code>
 . For <code class="literal">dict</code>
 , this is the <code class="literal">Dictionary&lt;string, string list&gt;</code>
 type of instance constructed on the right-hand side of the binding. In cases like the preceding one, adding explicit declarations of <code class="literal">s</code>
 and <code class="literal">dict</code>
 would just be adding unnecessary noise to the code.</p>
<p>Another rather obvious case is inferring a function signature based on its body definition in certain situations as shown in the following code (<code class="literal">Ch3_7.fsx</code>
 ):</p>
<pre class="programlisting">let gameOutcome isWin = "you " + if isWin then "win" else "loose" 
</pre>
<p>Here, as <code class="literal">isWin</code>
 is used after <code class="literal">if</code>
 this fact allows the F# compiler to deduce its type as <code class="literal">bool</code>
 ; the return type is apparently <code class="literal">string</code>
 , so the signature of the <code class="literal">gameOutcome</code>
 function can be inferred as (<code class="literal">bool-&gt;string</code>
 ). Simple, right?</p>
<p>Not that simple case when type inference fails may be illustrated by the following (quite naive) snippet (<code class="literal">Ch3_7.fsx</code>
 ):</p>
<pre class="programlisting">let truncator limit s = 
  if s.Length &gt; limit then 
    s.Substring(0, limit) 
  else 
    s 
</pre>
<p>Here, the F# compiler complains about <code class="literal">s.Length</code>
 and <code class="literal">s.Substring</code>
 with the following message:</p>
<div class="blockquote">
<blockquote class="blockquote">
<p>
<span class="emphasis">
<em>Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.</em>
</span>
</p>
</blockquote>
</div>
<p>Changing the function definition to <code class="literal">let truncator limit (s: string) =</code>
 makes the F# compiler happy again.</p>
<p>Besides, if I would not be that naive and take at least some effort to check arguments for corner cases, as shown in the slightly enhanced definition in the following code (<code class="literal">Ch3_7.fsx</code>
 ):</p>
<pre class="programlisting">let truncator' limit s = 
  if not (System.String.IsNullOrEmpty s) &amp;&amp; s.Length &gt; limit then 
    s.Substring(0, limit) 
  else 
    s 
</pre>
<p>Then, the compiler can infer a type of <code class="literal">s</code>
 as <code class="literal">string</code>
 from its use as the argument of the <code class="literal">System.String.IsNullOrEmpty</code>
 library function; the explicit type declaration is not required again.</p>
<p>Type inference gains more importance in the area of statically constrained generic types. Let's consider a slightly more loaded example of the <code class="literal">logAndTrash</code>
 function, which takes an <code class="literal">ss</code>
 disposable collection, scribbles each <code class="literal">s</code>
 item as a separate text line into .NET <code class="literal">StringBuilder</code>
 , disposes the collection, and returns the eventual <code class="literal">StringBuilder</code>
 value for later consumption elsewhere as shown in the following code (<code class="literal">Ch3_7.fsx</code>
 ):</p>
<pre class="programlisting">let logAndTrash ss = 
  let log = System.Text.StringBuilder() 
  for s in ss do 
    sprintf "%A" s|&gt; log.AppendLine |&gt; ignore 
  (ss :&gt; System.IDisposable).Dispose() 
  log 
</pre>
<p>It is very nice of the F# compiler to infer a rather complicated signature of <code class="literal">logAndTrash</code>
 function that literally reads as follows:</p>
<pre class="programlisting">'a -&gt; System.Text.StringBuilder 
  when 'a :&gt; seq&lt;'b&gt; and 'a :&gt; System.IDisposable 
</pre>
<p>Or, in plain words, this is a function taking a value of generic type <code class="literal">'a</code>
 and returning an instance of <code class="literal">StringBuilder</code>
 , where <code class="literal">'a</code>
 must be a sequence of any generic type <code class="literal">'b</code>
 and at the same time be disposable.</p>
<p>Summing up the cases of type inference illustrated by the code examples given earlier I offer you the following take-away tip.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_1"><a id="tip4"/>
 Tip</h3>
<p>Types of values, functions, and generics with constraints in F# may be unambiguously inferred in many code contexts, including-but not limited to-literals, constructed instances, usage in certain expression parts, signatures of library or custom functions or methods.</p>
</div>
</div>


<div class="section" title="Recursive function basics">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec27"/>
 Recursive function basics</h1>
</div>
</div>
</div>
<p>In this chapter, I want to introduce you to the basics of recursive functions, leaving more detailed consideration for the more advanced contexts. At this point, I want to show how the F# default treatment of functions as non-recursive differs from a forced one when the function is explicitly declared recursive using the <code class="literal">let</code>
 binding modifier, <code class="literal">rec</code>
 .</p>
<p>Take a look at the following far-fetched snippet (<code class="literal">Ch3_8.fsx</code>
 ):</p>
<pre class="programlisting">let cutter s = 
  let cut s = 
    printfn "imitator cut: %s" s 
  let cut (s: string) = 
    if s.Length &gt; 0 then 
      printfn "real cut: %s" s 
      cut s.[1..] 
    else 
      printfn "finished cutting" 
  cut s 
</pre>
<p>The <code class="literal">cutter</code>
 function here provides a non-empty string that's supposed to cut it from the left-hand side, symbol by symbol, until the argument is gone. Within the <code class="literal">cutter</code>
 body, there are two definitions of the <code class="literal">cut</code>
 internal function, of which the second definition apparently shadows the first. Also, it's important that within the second <code class="literal">cut</code>
 definition, it calls itself with the argument shortened from the left-hand side by one character, which is a clear case of <span class="strong">
<strong>recursion</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Recursion">https://en.wikipedia.org/wiki/Recursion</a>
 ).</p>
<p>The following screenshot shows the preceding code being fed to FSI and executed yielding some output:</p>
<div class="mediaobject"><img src="Image00016.jpg" alt="Recursive function basics"/>
<div class="caption">
<p>Default non-recursive scoping of function definition</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>However, apparently, this code did not work as intended, as for the purpose of self-reference, the second instance of the <code class="literal">cut</code>
 definition is not lexically complete when <code class="literal">cut s.[1..]</code>
 occurs. The second <code class="literal">cut</code>
 definition did not shadow the first imitator instance of the <code class="literal">cut</code>
 definition, so the single output from the second (real) <code class="literal">cut</code>
 is followed by the single output from the imitator <code class="literal">cut</code>
 , and the computation is complete at this point. Oops, this is quite far from the intended output!</p>
<p>Things have changed dramatically in the following screenshot, where the second definition of <code class="literal">cut</code>
 is peppered with the <code class="literal">rec</code>
 modifier:</p>
<div class="mediaobject"><img src="Image00017.jpg" alt="Recursive function basics"/>
<div class="caption">
<p>Forced recursive scoping of the function definition</p>
</div>
</div>
<p style="clear: both; height: 1em;"/>
<p>Now, the second definition of <code class="literal">cut</code>
 immediately shadows the first one, allowing the second inner <code class="literal">cut</code>
 function to really call itself, which reflects the changed output; now, the implementation behaves as conceived: all performed cutting is real.</p>
<p>So, for now, you should be able to grasp that the <code class="literal">rec</code>
 modifier makes a function value available for referral immediately, without waiting until the function definition is lexically complete, thus enabling functions refer to themselves.</p>
</div>


<div class="section" title="Operators as functions">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec28"/>
 Operators as functions</h1>
</div>
</div>
</div>
<p>What is an operator, thinking abstractly? It can be seen as a function of one or two arguments that just have a concise name represented by a single symbol or a very few symbols. F# heartily supports this abstraction. For example, take a look at the following expression:</p>
<pre class="programlisting">(%) 10 3 = 10 % 3 
</pre>
<p>Here, on the left-hand side of the equality sign (<code class="literal">=</code>
 ), the <code class="literal">(%)</code>
 function is called with the arguments <code class="literal">10</code>
 and <code class="literal">3</code>
 . On the right-hand side of the equality sign (<code class="literal">=</code>
 ) just a <code class="literal">10 % 3</code>
 expression is present. Evaluating the whole expression in FSI shows its value as <code class="literal">true</code>
 because sub expressions on the left and right of the equality sign (<code class="literal">=)</code>
 are indeed identical.</p>
<p>Furthermore, the equality sign (<code class="literal">=</code>
 ) itself is also an operator. Evaluating the equality sign (<code class="literal">=</code>
 ) itself in FSI with the following expression <code class="literal">(=);;</code>
 will reveal the following function signature:</p>
<pre class="programlisting">('a -&gt; 'a -&gt; bool) when 'a : equality 
</pre>
<p>The preceding signature means that (<code class="literal">=</code>
 ) is simply a function that takes two arguments of generic type <code class="literal">'a</code>
 supporting equality and returns a <code class="literal">bool</code>
 value.</p>
<div class="note" title="Note">
<h3 class="title" id="toc_1"><a id="note5"/>
 Note</h3>
<p>For the description of F# core operators, refer to <span class="strong">
<strong>Core.Operators Module (F#)</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/ee353754.aspx">https://msdn.microsoft.com/en-us/library/ee353754.aspx</a>
 ). Those of you who want to define your own operators, which is not a bad thing if done in moderation, I recommend <span class="strong">
<strong>
<span class="strong">
<strong>Operator Overloading (F#)</strong>
</span>
</strong>
</span>
 (<a class="ulink" href="https://msdn.microsoft.com/en-us/library/dd233204.aspx">https://msdn.microsoft.com/en-us/library/dd233204.aspx</a>
 ).</p>
</div>
</div>


<div class="section" title="Function composition">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec29"/>
 Function composition</h1>
</div>
</div>
</div>
<p>Function composition is perhaps the most fundamental skill to be mastered by a functional programmer. However simple it may sound, this is about combining some functions into a more powerful combination. This may sound close to the higher-order functions I have covered earlier, and it is close indeed. Function composition is just concentrating upon building chains of function applications that allow more powerful data transformations from the bunch of less complicated ones.</p>
<div class="section" title="Combinators">
<div class="titlepage">
<div>
<div>
<h2 class="title" id="toc_1"><a id="ch03lvl2sec67"/>
 Combinators</h2>
</div>
</div>
</div>
<p>How exactly does the function composition take place if, by definition, the functions considered the basis for composition are just sort of black boxes that can only consume arguments and produce results? This is correct; functions, arguments, and the single operation of an application are all that's required for composition (remember minimizing the moving parts). Still, composition is performed by functions as well. The function that somehow applies just its parameters or values (some of them may be function values) in order to produce results without involving any external context is named <span class="strong">
<strong>combinator</strong>
</span>
 . There is an entire branch of applied math, that is, <span class="strong">
<strong>Combinatory logic</strong>
</span>
 (<a class="ulink" href="https://en.wikipedia.org/wiki/Combinatory_logic">https://en.wikipedia.org/wiki/Combinatory_logic</a>
 ) that is concerned, in particular, with the learning of combinators. This may take very capricious forms; those of you who want to delve deeper, I recommend that you Google the <span class="emphasis">
<em>idiot bird combinator</em>
</span>
 string and follow the links.</p>
<div class="section" title="The id combinator">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_2"><a id="ch03lvl3sec0"/>
 The id combinator</h3>
</div>
</div>
</div>
<p>The simplest representative of combinators is <code class="literal">id</code>
 . Entering <code class="literal">(id);;</code>
 into FSI reveals this function signature <code class="literal">('a -&gt; 'a)</code>
 . In other words, this combinator takes any value and simply returns it without any transformation.</p>
</div>
<div class="section" title="Forward pipe |&gt;">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_3"><a id="ch03lvl3sec1"/>
 Forward pipe |&gt;</h3>
</div>
</div>
</div>
<p>This combinator is the workhorse of idiomatic F#. Entering <code class="literal">(|&gt;);</code>
 ; into FSI reveals this function signature <code class="literal">('a -&gt; ('a -&gt; 'b) -&gt;'b)</code>
 . In other words, this combinator applies its second argument, which is a function <code class="literal">('a -&gt; 'b)</code>
 , to its first argument <code class="literal">'a</code>
 , yielding the result <code class="literal">'b</code>
 .</p>
<p>Also, it may seem that the order cannot be that important; however, it is important indeed. One of the factors involved is type inference, which works better for the piped function composition (remember left to right).</p>
</div>
<div class="section" title="Backward pipe &lt;|">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_4"><a id="ch03lvl3sec2"/>
 Backward pipe &lt;|</h3>
</div>
</div>
</div>
<p>Entering <code class="literal">(&lt;|);</code>
 ; into FSI reveals this function signature: <code class="literal">(('a -&gt; 'b) -&gt; 'a -&gt; 'b)</code>
 . In other words, this combinator applies its first argument <code class="literal">('a -&gt; 'b)</code>
 to the second <code class="literal">'a</code>
 , yielding the result <code class="literal">'b</code>
 . At first glance, this combinator may seem excessive. However, an important case when it becomes useful is in eliminating the need for parentheses around the argument and improving the readability of the code in the end.</p>
</div>
<div class="section" title="Forward composition &gt;&gt;">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_5"><a id="ch03lvl3sec3"/>
 Forward composition &gt;&gt;</h3>
</div>
</div>
</div>
<p>This combinator composes functions together. Entering <code class="literal">(&gt;&gt;);;</code>
 into FSI reveals this function signature <code class="literal">(('a -&gt; 'b) -&gt; ('b -&gt; 'c) -&gt; 'a -&gt; 'c)</code>
 . In other words, having two functions and an argument, it applies the first function to the argument and the second function to the result of the first application.</p>
</div>
<div class="section" title="Backward composition ">
<div class="titlepage">
<div>
<div>
<h3 class="title" id="toc_6"><a id="ch03lvl3sec4"/>
 Backward composition </h3>
</div>
</div>
</div>
<p>This combinator composes functions together as well, but it does that differently. Entering <code class="literal">(&lt;&lt;);</code>
 ; into FSI reveals this function signature <code class="literal">(('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b)</code>
 . In other words, having two functions and an argument, it applies the second function to the argument and then the first function to the result of the first application. Sometimes, such an application order can be convenient for improved readability or other reasons.</p>
</div>
</div>
</div>


<div class="section" title="Summary">
<div class="titlepage">
<div>
<div>
<h1 class="title"><a id="ch03lvl1sec30"/>
 Summary</h1>
</div>
</div>
</div>
<p>I expect that this chapter moved your intuition in the direction of a handful of notions the functional-first nature of F# is based upon.</p>
<p>Recognizing and distilling these cornerstones from any relevant code context, you are now ready to absorb the main contents. In the next chapter, I'll turn to the cornerstone of F# programming techniques that is present in literally every data transformation, that is, <span class="emphasis">
<em>Pattern Matching</em>
</span>
 .</p>
</div>
</body></html>