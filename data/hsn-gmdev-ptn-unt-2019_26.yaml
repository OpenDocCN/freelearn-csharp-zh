- en: Spatial Partition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间划分
- en: In this chapter, we are going to review the Spatial Partition pattern; the concept
    of spatial partitioning is prevalent in computer graphics and is used for organizing
    the objects in a virtual space in an optimal way. This approach is also valid
    for the management of GameObjects placed inside of a Unity scene. By implementing
    the core principles of the Spatial Partition pattern, we can divide a large environment
    that's filled to the brim with two-dimensional or three-dimensional objects, and
    still be able to maintain a degree of consistent performance. As you will see
    in this chapter, this pattern is one of the core ingredients that make the production
    of large AAA open-world games possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾空间划分模式；空间划分的概念在计算机图形学中很普遍，用于以最佳方式组织虚拟空间中的对象。这种方法也适用于管理Unity场景中放置的GameObject。通过实现空间划分模式的核心原则，我们可以将充满二维或三维对象的大型环境划分为两部分，同时仍然能够保持一定程度的性能一致性。正如您在本章中将会看到的，这种模式是使大型AAA开放世界游戏制作成为可能的核心成分之一。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the basic principles behind the Spatial Partition pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾空间划分模式背后的基本原理
- en: We will implement a mini game in which a predator hunts prey in a scene
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现一个迷你游戏，其中捕食者在场景中猎捕猎物
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on, and you will need to have a basic understanding of
    Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的，您需要对Unity和C#有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concept:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: LINQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ
- en: If you are unfamiliar with this concept, please review it before moving forward.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉这个概念，请在继续之前进行复习。
- en: LINQ is a very powerful query language that's somewhat similar to SQL; it can
    be a time saver when you want to simply iterate through a data structure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ是一种非常强大的查询语言，与SQL有些相似；当您想简单地遍历数据结构时，它可以节省时间。
- en: 'The code files from this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际运行情况：
- en: '[http://bit.ly/2FAyWCf](http://bit.ly/2FAyWCf)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2FAyWCf](http://bit.ly/2FAyWCf)'
- en: An overview of the Spatial Partition pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间划分模式的概述
- en: 'Game programmers are often faced with the problem of finding a way to quickly
    locate the specific entities in a scene that are closest to a reference point,
    for example, the player character. In Unity, there are many approaches to solving
    this problem, such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏程序员经常面临的问题是如何快速定位场景中与参考点最近的特定实体，例如玩家角色。在Unity中，有许多解决这个问题的方法，如下所示：
- en: Implement a ray casting system that will scan the area around the player character
    and report the locations of specific entities.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个射线投射系统，该系统将扫描玩家角色周围的区域，并报告特定实体的位置。
- en: Use Unity's API features, such as the `GameObject.Find()` function, to locate
    specific entities in the scene, and then compare their coordinates to those of
    the player character.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity的API功能，例如`GameObject.Find()`函数，在场景中定位特定实体，然后比较它们的坐标与玩家角色的坐标。
- en: The first option is valid, but if we have a complex three-dimensional environment,
    it might be difficult to locate all of the entities that we are looking for, because
    they might be behind other objects and cannot be intersected by the ray. The second
    option might not be ideal performance-wise, because we will need to iterate through
    a list that includes every entity in the scene until we find every instance of
    a specific type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是有效的，但如果我们的三维环境复杂，可能很难定位我们正在寻找的所有实体，因为它们可能被其他对象遮挡，无法被射线相交。第二个选项在性能方面可能不是最佳选择，因为我们可能需要遍历包含场景中每个实体的列表，直到找到特定类型的每个实例。
- en: 'We can resolve this type of technical challenge by using the Spatial Partition
    pattern; it was designed for this purpose. One thing that we need to address first
    is the name of this pattern. The term **Spatial Partition** can be misleading:
    we are not organizing or modifying the virtual space that we are partitioning.
    We are doing the opposite; we are removing space from the equation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用空间分区模式来解决这种类型的技术挑战；它是为此目的而设计的。我们需要首先解决的问题是这个模式的名字。术语**空间分区**可能会误导：我们不是在组织或修改我们正在分区的虚拟空间。我们做的是相反的；我们在方程中移除空间。
- en: We achieve this by putting three-dimensional objects that are in a scene into
    a flat data structure that efficiently represents, in the memory, the distance
    between those objects in relation to each other without having to do calculations
    on the exact coordinates. This approach permits us to do fast and straightforward
    calculations to find the entities that are the closest to or farthest from a reference
    point.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将场景中的三维物体放入一个平面数据结构中来实现这一点，该数据结构在内存中有效地表示这些物体之间的距离，而无需对精确坐标进行计算。这种方法允许我们快速直接地计算找到最接近或最远离参考点的实体。
- en: 'In other words, we are sub-dividing a virtual space into a structure that''s
    easier to analyze. An example of a universal structure that''s easy to represent
    in memory (and that is often used to divide space into individual containers)
    is a fixed grid. In the following diagram, you can see a visual representation
    of this concept. The grid contains squares, which we will call **cells**. Those
    cells include **units**. Those units can be anything—a specific type of enemy
    character or hidden loot boxes spread out across a vast map:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们正在将虚拟空间细分成一个更容易分析的结构。一个易于在内存中表示的通用结构（通常用于将空间划分为单个容器）是一个固定网格。在以下图中，您可以看到这个概念的可视表示。网格包含正方形，我们将它们称为**单元格**。这些单元格包含**单位**。这些单位可以是任何东西——一个特定的敌人角色类型或散布在广阔地图上的隐藏宝藏箱：
- en: '![](img/159db14d-2aec-488b-8a74-63cad602f3eb.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/159db14d-2aec-488b-8a74-63cad602f3eb.png)'
- en: Now, let's imagine that this grid is superimposed on the enormous open-world
    map of an RPG video game. Each cell (square) represents a virtual 2x2 km area.
    We know that our player character has spawned in a specific cell (square) on the
    map, but we want to offer him the option to quickly travel to an area that's filled
    with level-2 monsters that he can fight. By using a Spatial Partition, we can
    easily calculate for the nearest entities of a specific type in the memory without
    having to scan the entire three-dimensional environment.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象这个网格叠加在一个大型开放世界地图的RPG视频游戏上。每个单元格（正方形）代表一个虚拟的2x2平方公里区域。我们知道我们的玩家角色在地图上的一个特定单元格（正方形）中出生，但我们想给他提供快速前往一个充满他可以战斗的2级怪物的区域的选择。通过使用空间分区，我们可以轻松地计算内存中特定类型的最近实体，而无需扫描整个三维环境。
- en: The results of the calculations can suggest to us a nearby cell (square) that
    contains the largest grouping of enemies of level 2\. With this information, we
    can move our player character into a random position inside of the suggested cell
    (square), so that he can loot the area. As you will see in the next sections,
    Spatial Partitioning simplifies the process of managing entities that reside in
    complex two-dimensional and three-dimensional spaces.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果可以向我们建议一个包含2级敌人最大群体的附近单元格（正方形）。有了这个信息，我们可以将我们的玩家角色移动到建议单元格（正方形）内的随机位置，以便他可以掠夺该区域。正如您将在下一节中看到的那样，空间分区简化了管理位于复杂二维和三维空间中的实体的过程。
- en: Benefits and drawbacks
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: The drawbacks of this pattern are quite limited (and are non-existent in most
    cases) because it's so easy to use.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点相当有限（在大多数情况下并不存在），因为它非常容易使用。
- en: 'The benefits are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 优点如下：
- en: '**Reusable**: We can use the Spatial Partition pattern to optimize the way
    that we manage anything that''s formed of entities spread out in two-dimensional
    or three-dimensional space (for example, user interfaces).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：我们可以使用空间分区模式来优化我们管理由二维或三维空间中的实体组成的事物的方式（例如，用户界面）。'
- en: '**Simplification**: A Spatial Partition makes it easier to implement code that
    calculates spatial relationships between objects. It''s very beneficial for those
    that are not good with math.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化**：空间分区使得实现计算对象之间空间关系的代码变得更加容易。这对数学能力不强的人来说非常有用。'
- en: 'The drawbacks are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是：
- en: '**Not very dynamic**: Spatial Partitioning can lose all of its optimization
    benefits if you are trying to manage entities that are continually moving in space
    over an extended area. So, if you have a scene that''s full of objects bouncing
    around at full speed, you will need to continuously update the data structure
    that contains the collection of entities and their grid positions. In that case,
    this process can be resource-intensive and not worth the effort.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不太动态**：如果你试图管理在广阔区域内不断移动的实体，空间划分可能会失去其所有的优化优势。因此，如果你有一个场景中充满了以全速弹跳的物体，你需要不断地更新包含实体及其网格位置的集合的数据结构。在这种情况下，这个过程可能会消耗大量资源，不值得付出努力。'
- en: The most important skill that a game programmer should acquire is mathematics.
    Being knowledgeable about design patterns is necessary to get into the industry,
    but it's not as important as a deep understanding of advanced mathematics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏程序员应该掌握的最重要技能是数学。了解设计模式对于进入行业是必要的，但它并不像对高级数学的深入理解那样重要。
- en: Use case example
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: Imagine that we need to quickly prototype a straightforward mini game that simulates
    a non-player predator character hunting for prey on a map. The process of spawning
    the entities (prey and predator) in the environment is not complicated; actually,
    it is quite simple. However, how are we going to know if our predator is close
    to potential prey and move him toward it?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要快速原型化一个简单的迷你游戏，该游戏模拟一个非玩家捕食者角色在地图上狩猎猎物。在环境中生成实体（猎物和捕食者）的过程并不复杂；实际上，它相当简单。然而，我们如何知道我们的捕食者是否接近潜在的猎物并将其移动到那里呢？
- en: 'Consider the following possible solutions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下可能的解决方案：
- en: We could query every object in the scene and compare their coordinates with
    those of the predator.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以查询场景中的每个物体，并将它们的坐标与捕食者的坐标进行比较。
- en: We could implement a ray cast system that scans every object in the proximity
    of the predator, in order to spot potential prey.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以实现一个射线投射系统，扫描捕食者附近的每个物体，以发现潜在的猎物。
- en: These solutions could potentially work, but they could be burdensome to implement
    in a short time. However, with the Spatial Partition pattern, we can avoid this
    lengthy process by making sure that all the entities in our scene get contained
    in a data structure that organizes the prey and predator by their relative positions.
    As you will see in our code example, writing this implementation is quite fast
    and useful, especially when you are in a rush and want to sketch out some basic
    AI navigation behaviors in code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案可能有效，但它们在短时间内实施可能会很繁琐。然而，使用空间划分模式，我们可以通过确保场景中的所有实体都包含在一个按相对位置组织猎物和捕食者的数据结构中来避免这个过程。正如你将在我们的代码示例中看到的那样，编写这个实现非常快且有用，尤其是在你匆忙并想在代码中草拟一些基本的AI导航行为时。
- en: Code example
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'The following code example might look very rudimentary, but it can easily be
    expanded to implement more complex use cases. In a way, it''s a foundation that
    we will be able to build on:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例可能看起来非常基础，但它可以很容易地扩展以实现更复杂的使用案例。从某种意义上说，它是一个我们将能够在此基础上构建的基础：
- en: 'Let''s start by implementing the core element of our pattern, the `Grid`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从实现我们模式的核心元素`Grid`开始：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing that you should take note of is the `AddToRandomnPosition()`
    function, in which we are adding units to squares in the grid with a `Random.Range()`
    call. We are doing this for two reasons. We want to test our `Grid` implementation
    quickly, so we are simulating having the entities spread out in an environment
    at random positions. We also want to showcase how we can use Spatial Partitioning
    in combination with a spawn system to manage the spawning of entities within a
    specific optimized grid space. In other words, we can partition the virtual space
    of our scene in the memory, even before initializing the things that will inhabit
    it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意的第一件事是`AddToRandomnPosition()`函数，在其中我们通过`Random.Range()`调用将单位添加到网格中的方块。我们这样做有两个原因。我们想快速测试我们的`Grid`实现，所以我们模拟了实体在随机位置的环境中分散。我们还想展示我们如何结合使用空间划分和生成系统来管理特定优化网格空间内的实体生成。换句话说，我们可以在初始化将占据它的东西之前，在内存中对场景的虚拟空间进行划分。
- en: Another function to analyze is `FindClosest()`; note that we are using two LINQ
    queries. The first query extracts a list of grid positions from a list of units.
    With the second one, we are querying this list to find the nearest cell in relation
    to a reference unit. For those that have never worked with LINQ, it's a built-in
    C# query language that permits finding and extracting elements in a collection
    with a single line of code. It's an excellent tool to use when you need to prototype
    and quickly write implementations that use data structures and collections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要分析的功能是`FindClosest()`；请注意，我们使用了两个LINQ查询。第一个查询从一个单位列表中提取网格位置列表。第二个查询是查询这个列表，以找到相对于参考单位最近的单元格。对于那些从未使用过LINQ的人来说，它是一种内置的C#查询语言，允许使用一行代码在集合中查找和提取元素。当你需要原型设计和快速编写使用数据结构和集合的实现时，这是一个非常出色的工具。
- en: 'Now, we need a way for our units to register themselves into a specific cell
    of the `Grid`. Let''s start by implementing an interface to manage our unit types:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法让我们的单位将自己注册到`Grid`的特定单元格中。让我们首先实现一个接口来管理我们的单位类型：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's quite a straightforward interface; the `GetGridPosition()` function returns
    the grid position of a `Unit`. A question that might arise is, why are we not
    implementing a function that will return the actual location of a `Unit` in the
    scene? It's because, in Unity, if a GameObject has a `Transform` component attached
    to it, we can directly ask this component to return its position inside of a three-dimensional
    scene. In other words, we are using Unity's API to do the heavy lifting for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的接口；`GetGridPosition()`函数返回`Unit`的网格位置。可能出现的疑问是，为什么我们不实现一个返回`Unit`在场景中实际位置的函数？这是因为，在Unity中，如果一个GameObject附加了`Transform`组件，我们可以直接要求这个组件返回它在三维场景中的位置。换句话说，我们正在使用Unity的API为我们做繁重的工作。
- en: 'We are going to implement two types of units for our code example; let''s start
    with the `Prey`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们的代码示例实现两种类型的单位；让我们从`Prey`开始：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next up is our `Predator` class; he hunts our `Prey`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的`Predator`类；他猎捕我们的`Prey`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that both our `Predator` and `Prey` have two primary responsibilities,
    linking their positions into a specific cell of the grid and returning that cell
    number if requested.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的`Predator`和`Prey`都有两个主要职责，将它们的位置链接到网格中的特定单元格，并在需要时返回该单元格编号。
- en: 'Finally, our `Client` class, which we are using to spawn `Prey` on the `Grid`
    and unleash the `Predator` upon them, is as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的`Client`类，我们使用它来在`Grid`上生成`Prey`并释放`Predator`，如下所示：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it; note that we never had to deal with the actual three-dimensional
    coordinates of objects to find their relative positions. We are avoiding a lot
    of unnecessary calculations by dividing the space into a grid and containing the
    objects within it. We are reducing the complexity by compartmentalizing it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了；请注意，我们从未需要处理对象的实际三维坐标来找到它们的相对位置。通过将空间划分为网格并将对象包含在其中，我们避免了大量的不必要的计算。我们通过分块来降低复杂性。
- en: Of course, in our code example, we went with the easy route and avoided calculating
    the relative positions of our `Units` before adding them to a specific square
    in the `Grid`, but this can easily be added if need be. The most important takeaway
    is that we should always avoid doing complex calculations on the entities in a
    three-dimensional space if we can merely partition and manage them inside of a
    data structure that we can easily search and manipulate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的代码示例中，我们选择了简单的方法，在将`Units`添加到`Grid`中的特定方格之前，避免了计算它们的相对位置，但如果需要的话，这可以很容易地添加。最重要的启示是，如果我们可以在一个可以轻松搜索和操作的数据结构中分区和管理它们，我们就应该始终避免在三维空间中的实体上进行复杂的计算。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a simple approach to learning a pattern that offers
    a solution to a very complex problem, which is how to organize the objects in
    a space optimally. We now have a tool that we can use to build open-world games
    and a quick solution for prototyping a game in which grids are a central component
    (for example, a puzzle game).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们采取了一种简单的方法来学习一个提供复杂问题解决方案的模式，即如何在空间中优化组织对象。我们现在有一个可以用来构建开放世界游戏和快速原型化以网格为中心的游戏（例如，解谜游戏）的工具。
- en: 'In the final chapter of this book, we are going to review a subject that''s
    the complete opposite of what we just explored: anti-patterns, the antithesis
    of design patterns.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，我们将回顾一个与我们刚刚探讨的内容完全相反的主题：反模式，它是设计模式的对立面。
- en: Practice
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In our code example, we implemented a straightforward use case of the Spatial
    Partition pattern. However, we limited ourselves to two-dimensional space; as
    a practical exercise, I would recommend expanding upon this basic example and
    organizing objects in a three-dimensional space. As inspiration, I would recommend
    observing the design of a Rubik's Cube. Note that it's composed of a collection
    of mini cubes; each can be considered a cell in a group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们实现了一个关于空间划分模式的直接应用案例。然而，我们仅限于二维空间；作为一个实际练习，我建议在此基础上扩展这个基本示例，并在三维空间中组织对象。作为灵感，我建议观察魔方的结构设计。注意，它由一系列小立方体组成；每个小立方体都可以被视为一个组中的单元格。
- en: Further reading
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mathematics for 3D Game Programming and Computer Graphics*by Eric Lengyel: [https://www.mathfor3dgameprogramming.com](https://www.mathfor3dgameprogramming.com/)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《三维游戏编程与计算机图形学中的数学》* 由 Eric Lengyel 编著：[https://www.mathfor3dgameprogramming.com](https://www.mathfor3dgameprogramming.com/)'
