- en: Navigation Meshes and Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: NPC to travel to destination while avoiding obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC to seek or flee from a moving object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-and-click move to object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-and-click move to tile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point-and-click raycast with user-defined higher-cost Navigation Areas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC to follow waypoints in sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling object group movement through flocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a movable NavMesh Obstacle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides **Navigation Meshes** and Artificial Intelligence (AI) Agents
    that can plan pathways and move objects along those calculated paths. **Pathfinding**
    is a classic AI task, and Unity has provided game developers with fast and efficient
    **Pathfinding** components that work out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Having objects that can automatically plot and follow paths from their current
    location to a desired destination point (or a moving object) provides the components
    to many different kinds of interactive game characters and mechanics. For example,
    we can create point-and-click games by clicking on a location or object, towards
    which we wish one or more characters to travel. Or, we can have enemies that "wake
    up" when our player's character is nearby, and move towards (seek) our player,
    perhaps then going into combat or dialogue mode once they are within a short distance
    of our player's character.
  prefs: []
  type: TYPE_NORMAL
- en: Or, objects can collectively flock together, moving as a swarm towards a common
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores ways to exploit Unity's navigation-based AI components
    to control game character **Pathfinding** and movement.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the core of Unity''s navigation system are two concepts/components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigation Meshes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Mesh Agents**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Navigation **Mesh** defines the areas of the world that are navigable. It
    is usually represented as a set of polygons (2D shapes), so that a path to a destination
    is plotted as the most efficient sequence of adjacent polygons to follow, taking
    into account the need to avoid non-navigable obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: The **Agent** is the object that needs to calculate (plot) a path through the
    mesh from its current position to its desired destination position. **NavMesh
    Agents** have properties such as a stopping distance, so they aim to arrive at
    a point a certain distance from the target coordinates, and auto braking, so they
    gradually slow down as they get close to their destination.
  prefs: []
  type: TYPE_NORMAL
- en: A **Navigation Mesh** can be made up of **Areas** that have different "costs."
    The default cost for an area is 1\. However, to make a more realistic path calculation
    by AI Agent controlled characters, we might want to model the additional effort
    it takes to travel through water, or mud, or up a steep slope. Therefore, Unity
    allows us to define custom Areas, with names that we choose (such as Water or
    Mud), and associated costs, such as 2 (that is, water is twice as tiring to travel
    through).
  prefs: []
  type: TYPE_NORMAL
- en: Different navigable areas can be connected via **NavMesh Links:**
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/class-NavMeshLink.html](https://docs.unity3d.com/Manual/class-NavMeshLink.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run-Time Nav Mesh Obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most efficient way for games to work with **Navigation Meshes** is to pre-calculate
    the costs of polygons in the game world; this is known as **Baking** and is performed
    at **Design-Time**, before we run the game.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes there will be features in the game that we wish to use to
    influence navigation decisions and route planning differently at different times
    in the game, that is, dynamic Run-Time navigation obstacles. Unity provides a
    **NavMesh Obstacle** component, which can be added to GameObjects, and has features
    such as "carving out" (temporarily removing) areas of a **NavMesh** to force AI-Agents
    to recalculate paths that avoid areas blocked by GameObjects with **NavMesh Obstacle**
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Source of further information about Unity and AI navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some **NavMesh** features (such as **NavMesh Links** and dynamic mesh baking
    at **Run-Time**) are not part of the standard Unity installation and require additional
    installation. Learn more about these components, their APIs, and how to install
    them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html](https://docs.unity3d.com/Manual/NavMesh-BuildingComponents-API.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn more about Unity **NavMeshes** from the Unity Technologies tutorial,
    which is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes](http://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/navmeshes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn lots about computer-controlled moving GameObjects from the classic paper
    entitled **Steering Behaviors For Autonomous Characters** by Craig W. Reynolds,
    presented at the GDC-99 (Game Developer''s Conference):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the Unity development community have been asking for 2D **NavMeshes**
    for some years now, they''ve not yet been released as a core feature. There is
    a lot of online information about how to write your own **Pathfinding** system
    that would work in 2D. A good thread with plenty of links can be found at **TIGForums**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://forums.tigsource.com/index.php?topic=46325.0](https://forums.tigsource.com/index.php?topic=46325.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to add **NavMesh Agents** to control characters
    and how to work with your game environment to specify and bake **Navigation Meshes**
    for a scene. Some recipes explore how to create point-and-click style games, where
    you indicate where you want a character to navigate to by clicking on an object
    or point in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: You'll create "swarms" of objects that move and flock together, and you'll also learn
    to add **NavMesh Obstacle** components to moving GameObjects, forcing AI agents
    to dynamically recalculate their paths at **Run-Time** due to objects moving in
    their way.
  prefs: []
  type: TYPE_NORMAL
- en: NPC to travel to destination while avoiding obstacles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of Unity's **NavMeshAgent** has greatly simplified the coding
    for NPC (Non-Player Character) and enemy agent behaviors. In this recipe, we'll
    add some wall obstacles (scaled cubes), and generate a **NavMesh** so that Unity
    knows not to try to walk through walls. We'll then add a **NavMeshAgent** component
    to our NPC GameObject, and tell it to head to a stated destination location by
    intelligently planning and following a path, while avoiding the wall obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Navigation panel is visible, then the Scene panel displays the blue-shaded
    walkable areas, as well as unshaded, non-walkable areas at the edge of the terrain
    and around each of the two wall objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/048040cc-d5f7-4f63-a674-d305ba4c62e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The required Terrain TextureSandAlbedo can be found in the 15_01 folder. Alternatively,
    you can go to Assets |Import Package | Environments, deselect everything, and
    then locate and tick this asset: Assets/Environment/TerrainAssets/SurfaceTextures/SandAlbedo.psd'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make an NPC to travel to a destination while avoiding obstacles, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new, empty 3D project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new 3D Terrain, choose menu: Create | 3D Object | Terrain. With this
    new Terrain GameObject selected in the Hierarchy, in its Inspector properties
    set its size to 30 x 20, and its position to (-15, 0, -10) so we have this GameObject
    centered at (0,0,0).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Texture paint this terrain with the SandAlbedo texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Capsule named Capsule-destination at (-12, 0, 8). This will be the
    target destination for our NPC self-navigating GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a sphere named Sphere-arrow that is positioned at (2, 0.5, 2). Scale
    it to (1,1,1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second sphere named Sphere-small. Scale it to (0.5, 0.5, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Hierarchy, child Sphere-small to Sphere-arrow and position it at (0,
    0, 0.5):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5fbaa0f-cc6c-4038-b19c-0245d10cd029.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Inspector panel, add a new NavMeshAgent to Sphere-arrow. Do this by
    choosing menu: Add Component | Navigation | Nav Mesh Agent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the Stopping Distance property of the NavMeshAgent component to 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fce3dcbe-0bba-4392-9583-b76fd15ba6dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `ArrowNPCMovement` C# script-class, and add an instance-object to
    the Sphere-arrow GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that Sphere-arrow is selected in the Inspector panel. For the ArrowNPCMovement
    scripted component, drag Capsule-destination over the Target Go variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Cube named Cube-wall at (-6, 0, 0), and scale it to (1, 2, 10).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another 3D Cube named Cube-wall2 at (-2, 0, 6), and scale it to (1, 2,
    7).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Display the Navigation panel by choosing menu: Window | Navigation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A great place to dock the Navigation panel is next to the Inspector panel since
    you will never be using the Inspector and Navigation panels at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Hierarchy panel, select both of the Cube-wall objects (we select the
    objects that are not supposed to be a part of the walkable parts of our scene),
    and then in the Navigation panel, click the **Object** button and check the Navigation
    Static checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6c23855-9001-4ce4-a621-e9d37cc79a66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Inspector, click on the Bake button at the top for baking options. Then, click
    on the Bake button at the bottom-right to create your Navigation Mesh asset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c2537923-7f65-4e30-a5ef-9379e266c76a.png)'
  prefs: []
  type: TYPE_IMG
- en: When the Navigation panel is displayed, you'll see a blue tint on the parts
    of the Scene that are areas for a NavMeshAgent to consider for its navigation
    paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run your game. You will see the Sphere-arrow GameObject automatically move
    towards the Capsule-destination GameObject, following a path that avoids the two
    wall objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NavMeshAgent component that we added to Sphere-arrow GameObject does most
    of the work for us. NavMeshAgents need two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A destination location to head towards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ANavMesh component of the terrain with walkable/non-walkable areas, so that
    it can plan a path by avoiding obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created two obstacles (the Cube-wall objects), and these were selected when
    we created the NavMesh for this scene in the Navigation panel. When the Navigation
    panel is displayed, at the same time in the Scene panel (and the Game panel with
    Gizmos enabled), we see walkable areas forming a blue navigation mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The blue areas are the default NavMesh Area. See, later in this chapter,
    a recipe for different, custom named, costed, color-coded NavMesh Areas.'
  prefs: []
  type: TYPE_NORMAL
- en: The location for our NPC object to travel towards is the position of the Capsule-destination
    GameObject at (-12, 0, 8); but, of course we could just move this object in the
    Scene panel at Design-Time, and its new position would be the destination when
    we run the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ArrowNPCMovement` C# script class has two variables: one is a reference
    to the destination GameObject, and the second is a reference to the NavMeshAgent
    component of the GameObject, in which our instance of the `ArrowNPCMovement` class
    is also a component. When the scene starts, the NavMeshAgent sibling component
    is found via the `Start()` method, and the `HeadForDestination()` method is called,
    which sets the destination of the NavMeshAgent to the position of the destination
    GameObject.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the NavMeshAgent has a target to head towards, it will plan a path there
    and will keep moving until it arrives (or gets within the Stopping Distance if
    that parameter has been set to a distance greater than zero).
  prefs: []
  type: TYPE_NORMAL
- en: In the Scene panel, if you select the GameObject that contains the NavMeshAgent
    and choose the Show Avoidance Gizmo, then you can see the candidate local target
    positions the agent is considering. The lighter the squares are, the better a
    position ranks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The darker red the squares are, the less desirable the position; so, dark red
    squares indicate positions to avoid, since they might, for instance, cause the
    agent to collide with a NavMesh Static obstacle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e9d87d2-7baf-448c-afca-5c874029bf90.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that the object with the NavMeshAgent component is selected in the Hierarchy
    panel at **Run-Time** to be able to see this navigation data in the Scene panel.
  prefs: []
  type: TYPE_NORMAL
- en: NPC to seek or flee from a moving object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than a destination that is fixed when the scene starts, let's allow the
    Capsule-destination object to be moved by the player while the scene is running.
    In every frame, we'll get our NPC arrow to reset the NavMeshAgent's destination
    to wherever Capsule-destination has been moved to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make an NPC seek or flee from a moving object, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector, add a Rigid Body Physics component to GameObject Capsule-destination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, for the Capsule-destination GameObject, check the Freeze Position
    constraint for the Y axis in the Constraints options of the RigidBody component.
    This will prevent the object moving in the Y-axis due to collisions when being
    moved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `SimplePlayerControl` C# script-class, and add an instance-object
    as a component to the Capsule-destination GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `ArrowNPCMovement` C# script-class so that we call the `HeadForDestintation()`
    method every frame, that is, from `Update()`, rather than just once in `Start()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SimplePlayerControl` script-class detects arrow key presses and translates
    them into a force to apply to move the Capsule-destination GameObject in the desired
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method of the `ArrowNPCMovement` script-class makes the NavMeshAgent
    update its path **every** frame, based on the current position of the Capsule-destination
    GameObject. As the user moves Capsule-destination, so the NavMeshAgent calculates
    a new path to the object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Debug Ray to show a source-to-destination line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's useful to use a visual Debug Ray to show us the straight line from the
    NPC with the NavMeshAgent to the current destination it is trying to navigate
    towards. Since this is a common thing we may wish to do for many games, it's useful
    to create a static method in a general-purpose class, and then the ray can be
    drawn with a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a Debug Ray to draw a source-to-destination line, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `UsefulFunctions.cs` C# script-class, containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a statement at the end of the `HeadForDestination()` method in the `NPCMovement` C#
    script-class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see a yellow line in the Scene panel when the scene is running.
    We can also see this in the Game panel if the Gizmos option is selected (top-right
    of the Game panel title bar):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37bd623b-435e-468e-9e93-6040dfc9c966.png)'
  prefs: []
  type: TYPE_IMG
- en: Constantly updating NavMeshAgent destination to flee from Player's current location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we want an AI-controlled NPC character to move **away**
    from another character, rather than go towards it. For example, an enemy with
    very low health might run away, and so gain time to regain its health before fighting
    again. Or, a wild animal might flee from any other character moving near it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instruct our NavMeshAgent to flee from the player''s location, we need to
    replace the `ArrowNPCMovement` C# script class with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is a public variable, `runAwayDistance`. When the distance to the enemy
    is less than the value of this `runAwayDistance` variable, then we'll instruct
    the computer-controlled object to flee in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method caches a reference to the NavMeshAgent component.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update()` method calculates whether the distance to the enemy is within
    `runAwayDistance`, and if so, it calls the `FleeFromTarget(...)` method, which
    passes the location of the enemy as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `FleeFromTarget(...)` method calculates a point that is the `runAwayDistance` in
    Unity units away from the Player's cube, in a direction that is directly away
    from the computer-controlled object. This is achieved by subtracting the enemy
    position vector from the current transform's position.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `HeadForDestintation(...)` method is called, passing the flee-to
    position, which results in the NavMeshAgent being told to set the location as
    its new destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity units are arbitrary, since they are just numbers on a computer. However,
    in most cases, it simplifies things to think of distances in terms of meters (1
    Unity unit = 1 meter), and mass in terms of kilograms (1 Unity unit = 1 kilogram).
    Of course, if your game is based on a microscopic world, or pan-galactic space
    travel, then you need to decide what each Unity unit corresponds to for your game
    context. For further discussion of units in Unity, check out this post about Unity
    measurements: [http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487](http://forum.unity3d.com/threads/best-units-of-measurement-in-unity.284133/#post-1875487).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debug Ray shows the point the NPC is aiming for, whether it be to flee
    away from the player''s character, or to catch up and maintain a constant distance
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/875ba89b-7b33-43f8-a4d6-0eae3ae64f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Maintain constant distance from target ("lurking" mode!)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is simple to adapt the previous code to have an NPC try to maintain a constant
    distance from a target object. It involves always moving towards a point that
    is `runAwayDistance` away from the target, regardless of whether this point is
    towards or away from the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remove the `If` statement in the `Update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, with this variation, it might be better to have the method named something
    like `MoveTowardsConstantDistancePoint()` rather than `FleeFromTarget()`, since
    our NPC is sometimes fleeing and sometimes following.
  prefs: []
  type: TYPE_NORMAL
- en: Point-and-click move to object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to choose the destination for our Sphere-arrow GameObject is by
    the user clicking on an object on the screen, and then the Sphere-arrow GameObject
    moving to the location of the clicked object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e088434d-ad3e-48e6-a2aa-1f47e15c30ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create an object-based point-and-click mini-game, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Inspector, add the Player Tag to the Sphere-arrow GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the two 3D Cubes and the 3D Capsule-destination from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `ClickMeToSetDestination` C# script-class containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Add instance-objects of the `ClickMeToSetDestination` C# script-class as components
    to your 3D Cube, Sphere, and Cylinder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Scene. When you click on one of the 3D objects, the Sphere-arrow GameObject
    should navigate towards the clicked object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `OnMouseDown()` method of the `ClickMeToSetDestination` C# script-class
    changes the destination of the NavMeshAgent in the Sphere-arrow GameObject to
    be the position of the clicked 3D object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method of the `ClickMeToSetDestination` C# script-class gets a
    reference to the NavMeshAgent component of the GameObject tagged Player (that
    is, the Sphere-arrow GameObject).
  prefs: []
  type: TYPE_NORMAL
- en: Each time a different object is clicked, the NavMeshAgent inside the Sphere-arrow
    GameObject is updated to make the GameObject move towards the position of the
    clicked object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mouse-over yellow highlight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good UX (**User Experience**) feedback technique is to visually indicate to
    the user when an object can be interacted with via the mouse. A common way to
    do this is to present an audio or visual effect when the mouse is moved over an
    interactable object.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a Material with a yellow color, which can make an object appear
    yellow while the mouse is over it, and then return to its original material when
    the mouse is moved away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `MouseOverHighlighter` C# `script-class` with the following contents.
    Then, add an instance-object as a component to each of the three 3D GameObjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, when running the game, when your mouse is over one of the three objects,
    that object will be highlighted yellow. If you click on the mouse button when
    the object is highlighted, the Sphere-arrow GameObject will make its way up to
    (but stop just before) the clicked object.
  prefs: []
  type: TYPE_NORMAL
- en: Point-and-click move to tile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rather than clicking specific objects to indicate the target for our AI-controlled
    agent, we can create a grid of 3D Plane (tile) objects to allow the player to
    click any tile to indicate a destination for the AI-controller character. So,
    any location can be clicked, rather than only one of a few specific objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75c0c4bd-eb2c-4547-bf06-7f611705fb5d.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared a red-outlined black square Texture image
    named square_outline.png in a folder named Textures in the `15_04` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a point-and-click game making GameObjects to a selected tile, do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete your 3D Cube, Sphere, and Cylinder GameObjects from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new 3D Plane object, scaled to (0.1, 0.1, 0.1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material with the Texture image square_outline.png provided (black
    square with a red outline). Apply this Material to your 3D Plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance-object of the `ClickMeToSetDestination` script-class as a component
    to your 3D Plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project panel, create a new empty Prefab named tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate your Prefab tile with the properties of your 3D Plane GameObject by
    dragging the plane GameObject over your Prefab tile (it should change from white
    to blue to indicate the Prefab now has the properties of your GameObject).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete your 3D Plane GameObject from the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `TileManager` C# script-class containing the following, and add
    an instance-object as a component to the Main Camera GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Select the Main Camera in the Hierarchy, and in the Inspector for the Tile Manager
    (Script) component, populate the Prefab Clickable Tile public property with your
    Prefab tile from the Project panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You should now be able to click on any of the small square tiles
    to set the destination of the NavMeshAgent controlled Sphere-arrow GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a Prefab, containing the properties of a 3D Plane named tile, which
    contained a component instance-object of the `ClickMeToSetDestination` C# script-class.
  prefs: []
  type: TYPE_NORMAL
- en: The `TileManager` script class loops to create 50 x 50 instances of this tile
    Gameobject in the Scene.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the game, if you click on the mouse button when the mouse pointer
    is over a tile, the NavMeshAgent inside the Sphere-arrow GameObject is set to
    that tile's position. So, the Sphere-arrow GameObject will move towards, but stop
    just before reaching, the clicked tile position.
  prefs: []
  type: TYPE_NORMAL
- en: The **Y** value of 0.01 means the plane will be just above the Terrain, so we
    avoid any kind of Moire interference pattern due to meshes at the same location.
    By subtracting `rows/2` and `cols/2` for the **X** and **Z** positions, we center
    our grid of tiles at (0, Y, 0).
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some details that you don't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Yellow debug-ray to show destination of AI-agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can show a debug ray from a moving object to its destination tile by creating
    the `MouseOverHighlighter` C# script-class with the following contents. We then
    add an instance-object as a component to the NavMeshAgent controlled Sphere-arrow
    GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Point-and-click Raycast with user-defined higher-cost Navigation Areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than indicating a desired destination by clicking an object or tile,
    we can use Unity's built-in `Physics.Raycast(...)` method to identify which Vector3
    (x,y,z) position relates to the object surface in the game.
  prefs: []
  type: TYPE_NORMAL
- en: This involves translating from the 2D (x,y) screen position to an imagined 3D
    "ray" from the user's point of view, through the screen, into the game world,
    and identifying which object (polygon) it **hits** first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe uses `Physics.Raycast` to set the position of the location clicked
    on as the new destination for a NavMeshAgent controller object. The actual route
    followed can be influenced by defining Navigation Mesh Areas of different costs.
    For example, walking through mud or swimming through water can have a higher cost,
    since they would take longer, so the AI NavMeshAgent can calculate the lowest-cost
    route, which may not be the shortest distance route in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baf3c66d-d516-42c3-aff4-84fb0eb05523.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a point-and-click game using a Raycast, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the Tile Manager (Script) component from the Main Camera GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new 3D Sphere, named Sphere-destination, scaled to (0.5, 0.5, 0.5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Material that is red in color, and assign this material to the Sphere-destination GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new `MoveToClickPoint` C# script-class containing the following, and
    add an instance-object as a component to the Sphere-arrow GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for
    the MoveToClickPoint (Script) component, populate the Sphere Destination public
    property with your red Sphere-destination GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You should now be able to click anywhere on the Terrain to set
    the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you
    click, the red Sphere-destination GameObject should be positioned at this new
    destination point, towards which the Sphere-arrow GameObject will navigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You created a small red 3D Sphere named Sphere-destination.
  prefs: []
  type: TYPE_NORMAL
- en: There is one public variable for the `MoveToClickPoint` scripted component of
    the Sphere-arrow GameObject. This public `sphereDestination` variable has been
    linked to the red Sphere-destination GameObject in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two private variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`navMeshAgent`: This will be set to refer to the NavMeshAgent component of
    the Sphere-arrow GameObject, so its destination can be reset when appropriate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hit`: This is a `RaycastHit` object, which is passed in as the object to be
    set by `Physics.Raycast(...)`. Various properties of this object are set after
    a Raycast has been created, including the position in the scene where the Raycast
    hit the surface of an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Start()` method caches a reference to the NavMesh component of the Sphere-arrow
    GameObject, and also moves the Sphere-destination GameObject to the current object's
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Each frame, in the `Update()` method, a Ray is created based on the Main Camera
    and the (2,y) point clicked on the screen. This Ray is passed as a parameter to
    the `FireRayCast(...)` method. If that method returns true, then the position
    of the object hit is extracted and passed to the `ProcessRayHit(...)` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `FireRayCast(...)` method receives a Ray object. It uses `Phyics.Raycast(...)`
    to determine whether the Raycast collides with part of an object in the scene.
    If the Raycast hits something, the properties of the `RaycastHit hit` object are
    updated. A true/false for whether `Physics.Raycast(...)` hit a surface is returned
    by this method.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the user clicks on the screen, the corresponding object in the scene
    is identified with the Raycast, the red sphere is moved there, and the NavMeshAgent
    begins to navigate towards that location.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about the Unity Raycast C# script-class at [https://docs.unity3d.com/ScriptReference/RaycastHit.html.](https://docs.unity3d.com/ScriptReference/RaycastHit.html.)
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: More intelligent pathfinding by setting different costs for custom-defined navigation
    areas such as Mud and Water
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create objects whose meshes are defined as more expensive for NavMeshAgents
    to travel across, helping AI-agent behavior be more realistic in terms of choosing
    faster paths that avoid Water, Mud, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom NavMesh Area (we''ll pretend it''s mud) with a higher travelling
    cost, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Navigation panel, reveal the areas by clicking the Areas button. Then,
    define a new area named Mud with a cost of 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0d0a0568-05f0-4116-aff1-f59577632589.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new 3D Cylinder named Cylinder-mud, positioned at (0, -4.9, 0) and
    scaled to (5,5,5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the Cylinder-mud GameObject is selected in the Hierarchy, and that the
    Navigation panel is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Navigation panel, click the Object button, check Navigation Static,
    and choose Mud from the Navigation Area drop-down list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c68362d4-149c-45df-9624-ac853d490a85.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click the Bake button to show the NavigationBake sub-panel, and then in
    this sub-panel click the Bake button to regenerate the Navigation Mesh with the
    new object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you click to move the Sphere-arrow GameObject near the edge of the
    Cylinder-mud area, then, say, click on the opposite side, you''ll see the NavMeshAgent
    make the Sphere-arrow GameObject follow a semi-circular (lowest cost) path around
    the edge of the Cylinder-mud area, rather than follow a direct line (as the crow
    flies) path *through* the higher cost mud area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c20833a-cb82-4d40-9e15-d446f2ce068a.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving UX by updating a "gaze" cursor each frame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's nice to know where our destination will be set to **before** we click the
    mouse. So, let's add a yellow sphere to show the 'candidate' destination for where
    our Raycast is hitting a surface, updated each frame as we move the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to create a second, yellow sphere. We also need to create a Layer
    to ignore; otherwise, if we move the yellow sphere to the point where a Raycast
    hits a surface, then in the next frame our Raycast will hit the surface of our
    yellow sphere - moving it closer and closer to us each frame!
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve UX by updating a "gaze" cursor each frame, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new yellow Material named m_yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second 3D Sphere, named Sphere-destination-candidate and textured with
    m_yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Layer, UISpheres.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Layer for both Sphere-destination and Sphere-destination-candidate GameObjects to
    LayerUISpheres.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `MoveToClickPoint` C# script-class as follows to add a new public
    variable, `sphereDestinationCandidate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `MoveToClickPoint` C# script-class as follows to add an Else-clause
    **to the logic in the** `ProcessRayHit(...)`** method, so that if the mouse is**
    not clicked, then the yellow sphereDestinationCandidate object is moved to where
    the Raycast hit a surface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `MoveToClickPoint` C# script-class as follows, so that a `LayerMask`
    is created to ignore Layer UISpheres, and passed as a parameter when `Physics.Raycast(...)`
    is invoked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Select the Sphere-arrow GameObject in the Hierarchy, and in the Inspector for
    the MoveToClickPoint (Script) component, populate the Sphere Destination Candidate public
    property with your yellow Sphere-destination-candidate GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the scene. You should now be able to click anywhere on the Terrain to set
    the destination of the NavMeshAgent controlled Sphere-arrow GameObject. As you
    click, the red Sphere-destination GameObject should be positioned at this new
    destination point, towards which the Sphere-arrow GameObject will navigate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have set a `LayerMask` using the `~LayerMask.GetMask("UISpheres") `statement,
    which means every layer apart from the named one. This is passed to the `Raycast(...)`
    method, so that our red and yellow Spheres are ignored when casting the ray and
    looking to see which surface the ray hits first.
  prefs: []
  type: TYPE_NORMAL
- en: NPC NavMeshAgent to follow waypoints in a sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waypoints are often used as a guide to make autonomously moving NPCs and enemies
    follow a path in a general way, but be able to respond with other directional
    behaviors, such as flee or seek, if friends/predators/prey are sensed nearby.
    The waypoints are arranged in a sequence, so that when the character reaches or
    gets close to a waypoint, it will then select the next waypoint in the sequence
    as the target location to move towards. This recipe demonstrates an arrow object
    moving towards a waypoint, and then when it gets close enough, it will choose
    the next waypoint in the sequence as the new target destination. When the last
    waypoint has been reached, it again starts heading towards the first waypoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Unity''s NavMeshAgent has simplified coding NPC behavior, our work in
    this recipe basically becomes finding the position of the next waypoint and then
    telling the NavMeshAgent that this waypoint is its new destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a12d87-0083-436f-9144-ade4dbd9850d.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the yellow brick texture image that you need
    in a folder named Textures in the `1362_08_06` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To instruct an object to follow a sequence of waypoints, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of the `ArrowNPCMovement` C# script class with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a new 3D Capsule object named Capsule-waypoint-0 at (-12, 0, 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy Capsule-waypoint-0, name the copy Capsule-waypoint-3, and position this
    copy at (8, 0, -8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to add some intermediate waypoints numbered 1 and 2 later on. This
    is why our second waypoint here is numbered 3, in case you were wondering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `WaypointManager` C# script class with the following contents, and
    add an instance-object as a component to the Sphere-arrow GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that Sphere-arrow is selected in the Inspector for the `WaypointManager`
    scripted component. Drag Capsule-waypoint-0 and Capsule-waypoint-3 over the public
    variable projectiles called Way Point 0 and Way Point 3, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, run your game. The arrow object will first move towards one of the waypoint
    capsules, then when it gets close to it, it will slow down, turn around, head
    towards the other waypoint capsule, and keep doing that continuously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NavMeshAgent component that we added to the Sphere-arrow GameObject does
    most of the work for us. NavMeshAgent needs two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A destination location to head towards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A NavMesh, so that it can plan a path and avoid obstacles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We created two possible waypoints as the locations for our NPC to move towards:
    Capsule-waypoint-0 and Capsule-waypoint-3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# script class called `WaypointManager` has one job: to return a reference
    to the next waypoint that our NPC should head towards. There are two variables,
    `wayPoint0` and `wayPoint3`, which reference the two waypoint GameObjects in our
    scene. The `NextWaypoint(...)` method takes a single parameter named current,
    which is a reference to the current waypoint that the object is moving towards
    (or `null`). This method''s task is to return a reference to the next waypoint
    that the NPC should travel towards. The logic for this method is simple: if current
    refers to waypoint0, then we''ll return `waypoint3`; otherwise, we''ll return
    `waypoint0`. Note that if we pass this method `null`, then we''ll get `waypoint0`
    back (so, it is our default first waypoint).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrowNPCMovement` C# script class has three variables. One is a reference
    to the destination GameObject named `targetGo`. The second is a reference to the
    `NavMeshAgent` component of the GameObject in which our instance of the class
    called `ArrowNPCMovement` is also a component. The third variable, called `waypointManager`,
    is a reference to the sibling scripted component, an instance of our `WaypointManager`
    script class.
  prefs: []
  type: TYPE_NORMAL
- en: When the scene starts via the `Start()` method, the NavMeshAgent and WaypointManager
    sibling components are found, and the `HeadForDestination()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `HeadForDestination()` method first sets the variable called `targetGO`
    to refer to the GameObject that is returned by a call to the `NextWaypoint(...)`
    of the scripted component called WaypointManager (that is, `targetGo` is set to
    refer to either Capsule-waypoint-0 or Capsule-waypoint-3). Next, it instructs
    the `NavMeshAgent` to make its destination the position of the `targetGO` GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Each frame method called `Update()` is called. A test is made to see whether
    the distance from the NPC arrow object is close to the destination waypoint. If
    the distance is smaller than twice the stopping distance set in our NavMeshAgent,
    then a call is made to `WaypointManager.NextWaypoint(...)` to update our target
    destination to be the next waypoint in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are some details that you won't want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays of waypoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a separate `WaypointManager` C# script-class to simply swap between Capsule-waypoint-0
    and Capsule-waypoint-3 may have seemed to be a bit heavy duty and a case of over-engineering,
    but this was actually a very good move. An instance-object of the `WaypointManager` script-class has
    the job of returning the next waypoint. It is now very straightforward to add
    the more sophisticated approach of having an array of waypoints, without us having
    to change any code in the `ArrowNPCMovement` C# script-class. We can choose a
    random waypoint to be the next destination; for example, see the *Choosing destinations
    - find nearest (or a random) spawnpoint *recipe in [Chapter 14](eb0ea442-6350-4a86-9e16-708b80d8762f.xhtml),
    *Choosing and Controlling Positions*. Or, we can have an array of waypoints and
    choose the next one in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our game so that it works with an array of waypoints to be followed in
    sequence, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy Capsule-waypoint-0, name the copy Capsule-waypoint-1, and position this
    copy at (0, 0, 8).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make four more copies (named Capsule-waypoint-1, 2, 4, 5), and position them
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Capsule-waypoint-1: Position = (-2, 0, 8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capsule-waypoint-2: Position = (8, 0, 8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capsule-waypoint-4: Position = (-2, 0, -8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capsule-waypoint-5: Position = (-12, 0, -8)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replace the `WaypointManager` C# script-class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that Sphere-arrow is selected. In the Inspector panel for the `WaypointManager`
    scripted component, set the size of the Waypoints array to 6\. Now, drag in all
    six capsule waypoint objects called Capsule-waypoint-0/1/2/3/4/5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. Now, the Sphere-arrow GameObject will first move towards waypoint
    0 (top left), and then follow the sequence around the terrain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can make it look as if the Sphere is following a yellow brick road.
    Import the provided yellow brick texture, add this to your terrain, and paint
    the texture to create an oval-shaped path between the waypoints. You may also
    uncheck the Mesh Renderer component for each waypoint capsule, so that the user
    does not see any of the waypoints, just the arrow object following the yellow
    brick road.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `NextWaypoint(...)` method, first we check in case the array is empty,
    in which case an error is logged. Next, the array index for the current `waypoint`
    GameObject is found (if present in the array). Finally, the array index for the
    next waypoint is calculated using a modulus operator to support a cyclic sequence,
    returning to the beginning of the array after the last element has been visited.
  prefs: []
  type: TYPE_NORMAL
- en: Increased flexibility with a WayPoint class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than forcing a GameObject to follow a single rigid sequence of locations,
    we can make things more flexible by defining a `WayPoint` class where each waypoint
    GameObject has an array of possible destinations, and each of these has its own
    array. In this way, a digraph (directed graph) can be implemented, of which a
    linear sequence is just one possible instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve our game and make it work with a digraph of waypoints, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the scripted `WayPointManager` component from the Sphere-arrow GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `ArrowNPCMovement` C# script-class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `WayPoint` C# script-class containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Select all six GameObjects called Capsule-waypoint -0/1/2/3/4/5 and add to them
    an instance-object component of the `WayPoint` C# class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Sphere-arrow GameObject and add to it an instance-object component
    of the `WayPoint` C# class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the Sphere-arrow GameObject is selected. In the Inspector panel
    for the ArrowNPCMovement scripted component, drag Capsule-waypoint-0 into the
    `Waypoint` public variable slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to link Capsule-waypoint-0 to Capsule-waypoint-1, Capsule-waypoint-1
    to Capsule-waypoint -2, and so on. Select Capsule-waypoint-0, set its Waypoints
    array size to 1, and drag in Capsule-waypoint-1\. Next, select Capsule-waypoint-1,
    set its Waypoints array size to 1, and drag in Capsule-waypoint-2\. Continue in
    this way until you finally link Capsule-waypoint-5 back to Capsule-waypoint-0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a much more flexible game architecture, allowing GameObjects to
    randomly select one of several different paths at each waypoint reached. In this
    recipe variation, we have implemented a waypoint sequence, since each waypoint
    has an array of just one linked waypoint. However, if you change the array size
    to 2 or more, you will then be creating a graph of linked waypoints, adding random
    variations in the sequence of waypoints that a computer controlled character follows
    for any given run of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling object group movement through flocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A realistic, natural-looking flocking behavior (for example birds, antelope,
    or bats) can be created through creating collections of objects with the following
    four simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation**: Avoid getting too close to neighbors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid obstacles**: Turn away from an obstacle immediately ahead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alignment**: Move in the general direction the flock is heading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion**: Move towards a location in the middle of the flock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each member of the flock acts independently, but needs to know about the current
    heading and location of the members of its flock. This recipe shows you how to
    create a scene with two flocks of cubes: one flock of green cubes and one flock
    of yellow cubes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things simple, we''ll not worry about separation in our recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3900a762-31ec-41ad-8a49-9d631f9d5401.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created in the first recipe. So, make a copy of this project, open it, and then
    follow the steps for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The required script to control movement of the red Cube (`PlayerControl.cs`)
    is provided in the `15_07` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make a group of objects flock together, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Material in the Project panel and name it m_green with the Main Color
    tinted green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Material in the Project panel and name it m_yellow with Main Color
    tinted yellow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 3D Cube GameObject named Cube-drone at (0,0,0). Drag the m_yellow Material
    into this object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Navigation | NavMeshAgent component to Cube-drone. Set the Stopping Distance
    property of the NavMeshAgent component to 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a Physics RigidBody component to Cube-drone with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mass is 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag is 0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Drag is 0.05
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Gravity and Is Kinematic are both unchecked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constraints Freeze Position: check the Y-axis'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the following `Drone` C# script-class, and add an instance-object as
    a component to the Cube-drone GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create a new empty **Prefab** named dronePrefabYellow, and from the Hierarchy
    panel, drag your Cube-boid GameObject into this Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag the m_green Material into the Cube-boid GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty Prefab named dronePrefabGreen, and from the Hierarchy panel,
    drag your Cube-drone GameObject into this Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Cube-drone GameObject from the Scene panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the following `Swarm` C# script-class, and add an instance-object as
    a component to the Main Camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With Main Camera selected in the Hierarchy panel, drag dronePrefabYellow from
    the Project panel over the Drone Prefab public variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With Main Camera selected in the Hierarchy panel, add a second instance-object
    of the `Swarm` script-class to this GameObject, and then drag dronePrefabGreen from
    the Project panel over the Drone Prefab public variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new 3D Cube named wall-left with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (-15, 0.5, 0)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale: (1, 1, 20)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate the wall-left object by naming the new object wall-right, and change
    the position of wall-right to (15, 0.5, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new 3D Cube named wall-top with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (0, 0.5, 10)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale: (31, 1, 1)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate the wall-top object by naming the new object wall-bottom, and change
    the position of wall-bottom to (0, 0.5, -10).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new 3D Sphere named Sphere-obstacle with the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Position: (5, 0, 3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scale: (10, 3, 3)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Hierarchy panel, select the Sphere-obstacle GameObject. Then in the Navigation
    panel, check the Navigation Static checkbox. Then, click on the Bake button at
    the bottom of the Navigation panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a red 3D Cube for the player to control, making it red by adding Materialm_red
    to it and making it large by setting its scale to (3,3,3). Now, add an instance-object
    of the `PlayerControl` C# script-class provided as a component to this GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Swarm class contains three variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`droneCount`: It is an integer referencing the number of the Swarm class members
    created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dronePrefab`: It references the Prefab to be cloned to create swarm members'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`drones`: A list of objects that reference drones; a list of all the scripted
    `Drone` components inside all the `Swarm` objects that have been created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upon creation, as the scene starts, the Swarm script class's `Awake()` method
    loops to create `droneCount` swarm members by repeatedly calling the `AddDrone()`
    method. This method instantiates a new GameObject from the prefab, and then sets
    the `newDrone` variable to be a reference to the Drone scripted object inside
    the new `Swarm` class member. In each frame, the `FixedUpdate()` method loops
    through the list of `Drone` objects by calling their `SetTargetPosition(...)`
    method, and passes in the `Swarm` center location and the average of all the swarm
    member velocities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of this `Swarm` class is made up of two methods: one (`SwarmCenterAverage`)
    returns a `Vector3` object representing the average position of all the `Drone`
    objects, and the other (`SwarmMovementAverage`) returns a `Vector3` object representing
    the average velocity (movement force) of all the `Drone` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SwarmMovementAverage()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the general direction that the swarm is moving in?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is known as alignment: a swarm member attempting to move in the same direction
    as the swarm average'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SwarmCenterAverage()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the center position of the swarm?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is known as cohesion: a swarm member attempting to move towards the center
    of the swarm'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The core work is undertaken by the `Drone` class. Each drone's `Start(...)`
    method finds and caches a reference to its NavMeshAgent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each drone''s `UpdateVelocity(...)` method takes as input two `Vector3` arguments:
    `swarmCenterAverage` and `swarmMovementAverage`. This method then calculates the
    desired new velocity for this `Drone` by simply adding the two vectors, and then
    uses the result (a `Vector3` location) to update the NavMeshAgent''s target location.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the flocking models in modern computing owe much to the work of Craig
    Reynolds in the 1980s. Learn more about Craig and his boids program at [http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)](http://en.wikipedia.org/wiki/Craig_Reynolds_(computer_graphics)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a movable NavMesh Obstacle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we want a moving object to slow down or prevent an AI NavMeshAgent controlled
    character passing through an area of our game. Or, perhaps we want something like
    a door or drawbridge to sometimes permit travel, and not at other times. We can't
    "bake" these objects into the NavMesh at Design-Time, since we want to change
    them during Run-Time.
  prefs: []
  type: TYPE_NORMAL
- en: While computationally more expensive (that is, they slow down your game more
    that static non-navigable objects), NavMesh Obstacles are components that can
    be added to GameObjects, and these components can be enabled and disabled like
    any other component.
  prefs: []
  type: TYPE_NORMAL
- en: A special property of NavMesh Obstacles is that they can be set to "carve out"
    areas of the NavMesh, causing NavMeshAgents to then recalculate routes that avoid
    these carved out parts of the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you''ll create a player-controlled red Cube, which you can
    move to obstruct an AI NavMeshAgent controlled character. Also, if your cube stays
    in one place for a half-second or longer, it will carve out part of the NavMesh
    around it, and so cause the NavMeshAgent to stop bumping into the obstacle, and
    calculate and follow a path that avoids it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/78f156e6-4080-48b0-8eb5-8b829f2dbba4.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe adds to the first recipe in this chapter, so make a copy of that
    project folder and do your work for this recipe with that copy.
  prefs: []
  type: TYPE_NORMAL
- en: The required script to control the movement of the red Cube (`PlayerControl.cs`)
    is provided in the `15_08` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a movable NavMesh Obstacle, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Material in the Project panel, and name it m_green with the Main Color
    tinted green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a red 3D Cube for the player to control, named Cube-player, making it
    red by added Material m_red to it and making it large by setting its scale to
    (3,3,3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an instance of the provided `PlayerControl` C# script-class as a component
    to this GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Inspector, add a Navigation | NavMesh Obstacle component to Cube-player and
    check its Carve property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. You can move the player-controlled red Cube to get in the way
    of the moving Sphere-arrow GameObject. After the NavMesh Obstacles Time-to-stationary
    time of half a second, if you have Gizmos displayed, you'll see the carving out
    of the NavMesh, so that the area occupied by Cube-player, and a little way around
    it, is removed from the NavMesh, and the Sphere-arrow GameObject will then recalculate
    a new route, avoiding the carved out area where Cube-player is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At Run-Time, the AI NavMeshAgent controlled Sphere-arrow GameObject heads towards
    the destination point, but stops when the player-controlled red Cube is in its
    way. Once the Cube is stationary for 0.5 seconds or more, the NavMesh is carved
    out, so that the AI NavMeshAgent controlled **Sphere-arrow** GameObject no longer
    even attempts to plan a path through the space occupied by the cube, and recalculates
    a new path completely avoiding the obstacle, even if it means back-tracking and
    heading away from the target for part of its path.
  prefs: []
  type: TYPE_NORMAL
