- en: Anti-Patterns and Misconceptions on Dependency Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于依赖注入的反模式和误解
- en: Patterns show us the proper way to implement Dependency Injection. In the last
    chapter, we got an insight into every pattern available in the DI Ecosystem and
    explored their usage, their pros, their cons, and which one to select when. If
    these patterns are followed correctly, we achieve a loosely coupled architecture
    which will be easier to unit test.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模式向我们展示了实现依赖注入的正确方式。在上一章中，我们深入了解到了DI生态系统中每个模式的使用、它们的优点、缺点，以及何时选择哪一个。如果正确遵循这些模式，我们就能实现一个松耦合的架构，这将更容易进行单元测试。
- en: However, while applying these patterns, we generally neglect some principles,
    which leads us to problems in the future. That might happen either to the ignorance
    about pattern' behavior or simply due to laziness.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在应用这些模式时，我们通常忽视了一些原则，这可能导致我们未来遇到问题。这可能是由于对模式行为的无知，或者简单地由于懒惰。
- en: At that point, a pattern becomes an anti-pattern, as it does not solve the problem;
    rather it gives birth to more bugs and maintenance becomes a headache.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，一个模式变成了反模式，因为它没有解决问题；相反，它产生了更多的错误，维护变成了头疼的问题。
- en: After reading this chapter, don't worry if you find anti-patterns in your project
    because we will learn the steps to refactor each anti-pattern to a proper Pattern
    by selecting any technique from the patterns we discussed in the last chapter.
    If you directly came to this chapter, I suggest you complete the previous chapter
    (which covers everything you should know about DI Patterns in detail) first before
    moving ahead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，如果你在项目中发现了反模式，请不要担心，因为我们将学习如何通过选择上一章中讨论的任何技术来将每个反模式重构为合适的模式。如果你直接来到这一章，我建议你首先完成上一章（其中详细介绍了你应该知道的关于依赖注入模式的全部内容），然后再继续前进。
- en: In this chapter, we will talk about such scenarios in projects with examples
    to understand how a pattern can behave as an anti-pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过示例讨论这样的场景，以了解模式如何表现为反模式。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: When DI becomes an anti-pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当DI成为反模式时
- en: DI anti-patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI反模式
- en: Identifying anti-patterns in the project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目中识别反模式
- en: Problems anti-patterns introduce to apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式给应用带来的问题
- en: Solutions and refactoring steps for each type of anti-pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种反模式的解决方案和重构步骤
- en: When does Dependency Injection become an anti-pattern?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时依赖注入成为反模式？
- en: 'We are heading towards exploring anti-patterns followed by developers in projects
    with DI in place. However, have you envisaged the scenario where DI itself becomes
    an anti-pattern! Yes, it can be an anti-pattern sometimes. The cases are listed
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索在具有DI的项目中开发者遵循的反模式。然而，你有没有想过DI本身成为反模式的场景！是的，有时它可以成为反模式。以下列出了这些情况：
- en: Suppose we have a controller that is depending on a `Service` for some database
    operation. For instance, `UsersController` would need an `IUsersService` type
    as a dependency for `User` table-related operations. We configured `UsersService`
    for the dependency and it got registered with the container. Now, help yourself
    a little bit and ask the following question.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个控制器依赖于`Service`进行某些数据库操作。例如，`UsersController`需要一个`IUsersService`类型的依赖项来进行`User`表相关的操作。我们为依赖项配置了`UsersService`，并且它已经注册到容器中。现在，请稍微帮助自己，并问以下问题。
- en: '*Are you going to change the dependency to any other implementation of* **`IUsersService`***? *If
    your answer is *No*, then hold back and think a bit. The reason is, if you won''t
    change the implementation for the dependency either dynamically through code or
    configurations, then DI is not going to play an important role. For example, if
    you save data to a database/XML/text file, you might have different implementations
    and swapping is needed in certain conditions, then DI will definitely come in
    handy. But if you only save to the database and nothing else, there is no necessity
    to have extra codes for injecting dependencies. It does not make much sense.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*你打算将依赖项更改为任何其他`IUsersService`* **的实现吗**？*如果你的答案是*否，那么请稍作思考。原因是，如果你不会通过代码或配置动态地更改依赖项的实现，那么依赖注入就不会发挥重要作用。例如，如果你将数据保存到数据库/XML/文本文件，你可能会有不同的实现，并且在某些条件下需要交换，那么依赖注入肯定会派上用场。但是，如果你只保存到数据库而没有其他操作，就没有必要添加额外的代码来注入依赖项。这样做没有太多意义。'
- en: '*Are you going to need a dependency as soon as you start the app? *DI recommends
    that we register everything at one place called the Composition Root. However,
    imagine a `Service` called `CompanyService` whose instance is needed only when
    I want to add a `User` to a company. For example, see the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*你一启动应用程序就需要依赖项吗？*依赖注入建议我们在一个称为组合根（Composition Root）的地方注册所有内容。然而，想象一下一个名为`CompanyService`的`Service`，它的实例只有在我想将`User`添加到公司时才需要。例如，看看以下代码：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Normally we have admins in a company who manages user records. Imagine a scenario,
    where the admin is logged in and wants to assign a few users to a certain company.
    In this case, there is a `boolean` coming from the model named `AddUserToCompany`.
    If that is `true`, we need to assign the user to the company. This means a lazy
    instantiation and it is looking pretty good.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们公司有管理员负责管理用户记录。想象一下这样的场景，管理员登录后想要将一些用户分配给特定的公司。在这种情况下，有一个从名为`AddUserToCompany`的模型中来的`boolean`值。如果它是`true`，我们需要将用户分配给公司。这意味着懒加载实例化，看起来相当不错。
- en: So, here, it's meant to get a `CompanyService` instance quickly and work with
    it. However, if you have chosen DI, then the `CompanyService` instance stays in
    the container (because you register it at the Composition Root) till you actually
    use it inside the code, which often does not happen. Sometimes, it doesn't happen
    at all if the user logged in as a normal user and not an admin.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，它的意思是快速获取`CompanyService`实例并与之工作。然而，如果你选择了DI，那么`CompanyService`实例将保留在容器中（因为你将其注册在组合根中），直到你实际上在代码中使用它，这通常不会发生。有时，如果登录的用户是普通用户而不是管理员，这种情况根本不会发生。
- en: This is just a small example. You can visualize a complex application with these
    types of scenarios that might create a nasty impact with DI in place. Sometimes
    it's better to have lazy instantiation instead of having them in a container which
    consumes memory space unnecessarily.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子。你可以想象一个复杂的应用程序，这些类型的场景可能会在DI中产生不良影响。有时，懒加载比在容器中占用不必要的内存空间更好。
- en: Like a pattern, if DI is selected unnecessarily or used incorrectly, that leads
    to an anti-pattern itself. If you are never going to inject different dependencies
    for one implementation, then no need to use DI. Let's now explore anti-patterns,
    which we might encounter while using DI in the project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果DI被不必要地选择或使用不当，它本身就会导致反模式。如果你永远不会为一种实现注入不同的依赖项，那么就没有必要使用DI。现在让我们探索在使用项目中的DI时可能会遇到的反模式。
- en: Anti-patterns
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: 'There are four major types of anti-pattern found in projects where DI is implemented
    and those are listed as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现依赖注入（DI）的项目中，可以发现四种主要的反模式，如下列出：
- en: Control Freak
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制狂
- en: Bastard Injection
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶魔注入
- en: Constrained Construction
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制性构造
- en: Service Locator
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器
- en: Let's analyze each type and see how to avoid them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析每种类型，看看如何避免它们。
- en: Control Freak
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制狂
- en: Control Freak is opposite to Inversion of Control. When a class holds its dependencies
    and tries to manage them itself without any interference from others, it will
    be tagged as a **Control Freak**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 控制狂与控制反转（Inversion of Control）相反。当一个类持有其依赖项并试图在没有他人干扰的情况下自己管理它们时，它将被标记为**控制狂**。
- en: 'The following diagram shows Control Freak at a glance:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了控制狂的概览：
- en: '![](img/bb44cae7-c5fc-46ae-9bed-747d3b101475.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb44cae7-c5fc-46ae-9bed-747d3b101475.png)'
- en: When we said that *it tries to manage the dependencies itself*, what do we mean
    by that? Remember in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object
    Lifetime*, if a class wants to manage a dependency, that means it wants to instantiate
    it, then manage its lifetime and kill or dispose of it as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说它试图自己管理依赖项时，我们指的是什么？记住在[第6章](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml)，*对象生命周期*中，如果一个类想要管理一个依赖项，这意味着它想要实例化它，然后管理其生命周期，以及杀死或处理它。
- en: Instantiation, yes, that is done by our well-known keyword `new`.  The class
    instantiates every dependency with the `new` keyword inside it, then works with
    the objects and disposes of them through a `destructor` or `finalizer`. As a result,
    it is creating a tightly coupled system as soon as it does so. Moreover, it makes
    unit testing difficult.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化，是的，这是通过我们熟知的关键字`new`完成的。类使用`new`关键字在内部实例化每个依赖项，然后与对象一起工作，并通过`析构函数`或`终结器`来处理它们。因此，一旦这样做，它就创建了一个紧密耦合的系统。此外，它还使得单元测试变得困难。
- en: 'The class either creates the object itself or asks some other class to do so
    on its behalf. Let''s understand the scenario with an example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该类要么自己创建对象，要么代表其他类执行此操作。让我们通过一个例子来理解这个场景：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing that instantly comes into play is `new SqlEmplyeeRepository()`.
    Now, this service is tightly coupled with `SqlEmployeeRepository`. Suppose you
    want to use another repository class instead of this, then we have to change the
    service code and recompile. There is no such plugin point to say *I am providing
    you with this repository, please use it*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 立即发挥作用的第一件事是`new SqlEmplyeeRepository()`。现在，这个服务与`SqlEmployeeRepository`紧密耦合。假设你想使用另一个仓库类来替代它，那么我们必须更改服务代码并重新编译。没有这样的插件点来说明“我提供给你这个仓库，请使用它”。
- en: Problem
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To fix this problem, the developer might think of different patterns, which
    eventually complicates the scene. We can see the following types of factory used
    commonly:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，开发者可能会考虑不同的模式，这最终会使情况复杂化。我们可以看到以下类型的工厂被普遍使用：
- en: Concrete Factory
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体工厂
- en: Abstract Factory
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Static Factory
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态工厂
- en: Concrete Factory
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体工厂
- en: 'Creating `EmployeeRepositoryFactory` is another excuse (and a lazy approach)
    to have a `Create()` method that will create a `SqlEmployeeRepository` instance
    by the `new` keyword:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`EmployeeRepositoryFactory`是拥有一个`Create()`方法的另一个借口（以及一种懒惰的方法），这个方法将通过`new`关键字创建一个`SqlEmployeeRepository`实例：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We removed this block from `EmployeeService` but added another class which
    is working very similar to the previous one. We can then use the factory as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`EmployeeService`中移除了这个块，但添加了另一个与之前非常相似的新类。然后我们可以这样使用工厂：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the `EmployeeService` constructor, we use the `new` keyword to get a
    factory instance and then call `Create()` to get the `SqlEmployeeRepository` instance
    and assign it to the `repository` variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EmployeeService`构造函数中，我们使用`new`关键字获取工厂实例，然后调用`Create()`方法来获取`SqlEmployeeRepository`实例，并将其分配给`repository`变量。
- en: Did we achieve anything useful? Not at all. We just added another bunch of code
    to the `Service`, doing the same thing (using the `new` keyword to instantiate)
    in an indirect way through the factory. Basically, the factory uses the same `new`
    keyword to instantiate the `SqlEmployeeRepository` class. That is what we wanted
    to avoid, but we could not achieve this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否实现了什么有用的东西？完全没有。我们只是在`Service`中添加了另一堆代码，以间接的方式（通过工厂）做了同样的事情（使用`new`关键字实例化）。基本上，工厂使用相同的`new`关键字来实例化`SqlEmployeeRepository`类。这正是我们想要避免的，但我们没有实现这一点。
- en: Abstract Factory
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Abstract Factory behaves as an encapsulating component that encapsulates complex
    logic including dependencies associated with it. It can transfer the control from
    the consumer because it does not totally allow the consumer to control the lifetime
    of objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂作为一个封装组件，封装了包括与其相关的依赖在内的复杂逻辑。因为它不完全允许消费者控制对象的生存周期，所以它可以从消费者那里转移控制权。
- en: 'A Derived Factory is responsible for the creation and management of the required
    repository instead of the initially designed factory. Consider the following code
    snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 派生工厂负责创建和管理所需的仓库，而不是最初设计的工厂。考虑以下代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That means we are trying to hide which repository will be served. We are trying
    to achieve loose coupling by hiding the actual supplied type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们试图隐藏将要服务的仓库是哪一个。我们试图通过隐藏实际提供的类型来实现松耦合。
- en: 'In order to assign the `repository` variable, we have to inherit this class
    and create one child of it returning `SqlEmployeeRepository`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配`repository`变量，我们必须继承这个类并创建一个子类，返回`SqlEmployeeRepository`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Basically, we decoupled the instantiation of the `repository` from the main
    service. The same question again arises. Did we achieve anything useful? I don''t
    think so. That is because this new architecture  again achieved at the cost of
    one instantiation inside the `EmployeeService `(with the `new` keyword):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将`repository`的实例化与主服务解耦了。同样的问题再次出现。我们是否实现了什么有用的东西？我不这么认为。这是因为这种新的架构再次以在`EmployeeService`（使用`new`关键字）内部的一个实例化为代价：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although you were able to hide the `SqlEmplyeeRepository` from the factory by
    making it abstract, you made no change to the way things are handled inside the
    `EmployeeService` constructor. You are now instantiating `SqlEmployeeService`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你能够通过将其抽象化来隐藏`SqlEmplyeeRepository`从工厂中，但你没有改变在`EmployeeService`构造函数内部处理事情的方式。你现在正在实例化`SqlEmployeeService`。
- en: Static Factory
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂
- en: 'The next approach is to avoid factory instantiation by introducing the `static`
    pattern. Consider the following code snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是通过引入`static`模式来避免工厂实例化。考虑以下代码片段：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This would prevent us from creating an object and using it directly. Let''s
    see how:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止我们创建一个对象并直接使用它。让我们看看如何：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Horray! We finally removed the `new` keyword. Alright, looks like we are done.
    Oh, wait! We still have `SqlEmployeeRepository` instantiated using `new` inside `Create()`.
    But there is a simple solution to reading this type of repository from the `config`
    or something:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 哈雷！我们终于移除了`new`关键字。好吧，看起来我们完成了。哦，等等！我们仍然在`Create()`方法中使用`new`创建了`SqlEmployeeRepository`实例。但是，有一个简单的解决方案可以从`config`或类似的地方读取这种类型的存储库：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It looks promising at first glance, but it is actually something else. All
    classes become tightly coupled. This is depicted in the following diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初看似乎很有希望，但实际上并非如此。所有类都变得紧密耦合。这如下面的图中所示：
- en: '![](img/f36aaab7-6112-4fb2-814c-497ae3b09222.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f36aaab7-6112-4fb2-814c-497ae3b09222.png)'
- en: '`EmployeeService` depends upon the `EmployeeRepositoryFactory` for the `EmployeeRepository`
    instance, which means that clients of the service need to refer to the factory,
    repository, and then the types of repository such as `SqlEmployeeRepository` and `AzureEmployeeRepository`
    returned by `CreateSql()` and `CreateAzure()`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeService`依赖于`EmployeeRepositoryFactory`以获取`EmployeeRepository`实例，这意味着服务的客户端需要引用工厂、存储库以及`CreateSql()`和`CreateAzure()`返回的存储库类型，如`SqlEmployeeRepository`和`AzureEmployeeRepository`。'
- en: These concrete classes got coupled, which can't produce a flexible design resulting
    in bad days for upcoming programmers of the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具体类之间产生了耦合，这不能产生灵活的设计，导致应用程序的后续程序员日子不好过。
- en: Solution
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'We have already explored patterns in the last chapter. The best fit for Control
    Freak issues is Constructor Injection. Consider the following code snippet:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中探讨了模式。对于控制狂问题，构造函数注入是最合适的。考虑以下代码片段：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this way, you abstracted out the concrete repository and also inserted the
    dependency through the constructor. More refactoring can be applied by introducing
    a factory class, which will be responsible for generating the repository.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你抽象出了具体的存储库，并且通过构造函数插入了依赖。通过引入一个工厂类，可以进一步进行重构，该工厂类将负责生成存储库。
- en: Now using the DI Containers, you can register either the factory interface or
    the repository interface and resolve as required so that the dependency will be
    available for the service.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用DI容器注册工厂接口或存储库接口，并按需解析，以便依赖项对服务可用。
- en: Control Freak is the most commonly found anti-pattern implemented in projects.
    While developers consider using DI in their project, they find it difficult sometimes
    and they are attracted to controlling the object creation instead of any other
    component doing it for them. The outcome will be awesome if they just ignore being
    a control freak and go with the DI flow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 控制狂是最常见的一种反模式，在项目中实现。当开发者在他们的项目中考虑使用DI时，他们有时会发现这很困难，并且他们被控制对象创建而不是其他组件为他们做这件事所吸引。如果他们只是忽略成为控制狂，并跟随DI流程，结果将会很棒。
- en: The next anti-pattern is Bastard Injection. However, before going to that, we
    need to understand a manual approach to dependency management called **Poor Man's
    DI**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个反模式是“混蛋注入”。然而，在进入那个之前，我们需要了解一种名为“穷人DI”的手动依赖管理方法**Poor Man's DI**。
- en: Poor Man's DI
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 穷人DI
- en: Poor Man's DI; the name sounds very interesting, doesn't it! When you yourself
    try to take care of the registrations of dependencies at commonplace (which otherwise
    can be denoted as the Composition Root) instead of using a library (specifically
    a DI Container), that technique can be defined as Poor Man's DI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 穷人DI；这个名字听起来非常有趣，不是吗！当你自己尝试在普通场合（否则可以称为组合根）处理依赖项的注册，而不是使用库（特别是DI容器）时，这种技术可以定义为穷人DI。
- en: The approach
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'Let''s find out how this can be done with a quick code example. Suppose `EmployeeService`
    has a dependency of the `EmployeeRepository` type, which we can directly provide
    into the constructor, shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速的代码示例来看看如何实现。假设`EmployeeService`依赖于`EmployeeRepository`类型的依赖项，我们可以直接将其提供到构造函数中，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Consider this console app example, where `EmployeeService` is instantiated inside
    the `Main` method. It looks simple and beautiful. But it is not that effective
    if the dependency nesting runs deep.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'What if `EmployeeRepository` again needs some other dependency and then another
    one and so on. You might end up doing something like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it becomes ugly and not so maintainable. Then you might think of simplifying
    this structure to some extent by introducing a default constructor for each class.
    So, the following is what you will do for `Service` and `Repository`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can do the same thing to all the nested classes. We added default constructors
    for all the classes; these a call internally to the parameterized constructors
    with a default dependency instance. It will definitely, reduce the code. Check
    the following reduced code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now there is no need to pass any dependency to these constructors. Moreover,
    if you pass any dependency of the expected type, that will also work because a
    parameterized constructor also exists. That means we got a very flexible structure
    for the class and we also reduced the instantiation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we tried to make the instantiation flexible, testable, and simple, we
    did not realize the following disadvantages with this approach:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: A concrete reference was created in the default constructor when we did `new
    EmployeeRepository()`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default dependency instance is tied with all the classes using the `new`
    operator. But the whole point of the dependency injection technique is to reduce
    the `new` keywords in the app.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also violated another principle in registering all dependencies in one place
    known as the Composition Root. Now, we have Composition Roots everywhere across
    the app in all classes. This is bad.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the situation of having 10 classes using the same dependency; now it
    would be very problematic to instantiate everything with the same `new` keyword
    again and again.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have any facility to manage the lifetime of the dependencies created
    like this using the `new` keyword. You have to manually dispose of everything
    which can become a headache in a fully fledged application. Moreover, if you want
    to reuse one instance, you need to carefully deal with that. This might lead to
    inconsistent behavior and wrong data.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how do we deal with this? Let's find out.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, using a DI Container to register the dependencies solves the problem.
    We can remove the default constructor that is actually creating a tight coupling
    with the required types:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The registration of dependencies can be restricted to one place unlike Poor
    Man's DI, where you instantiate concrete classes here and there.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the registrations inside the Composition Root using a DI Container, we
    can make use of the facility to configure the app to use different types of dependency
    using different configuration options.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get cleaner code for deeply nested dependencies.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a dependency to be used by many classes, it's just a matter of registering
    it to the container and sitting back and relaxing.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要让许多类使用依赖项，只需将其注册到容器中，然后放松即可。
- en: You can manage the lifetime of dependencies as you like. The instance can behave
    as a `Singleton` , `Transient` , or `Scoped` as you configure them.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以按自己的意愿管理依赖项的生命周期。实例可以表现为`Singleton`、`Transient`或`Scoped`，具体取决于你的配置。
- en: It's recommended to use a DI Container to register and resolve dependencies
    instead of manually managing them in the Composition Root. So, the default constructor
    approach is denoted as Bastard Injection. In the next section, we will explore
    this a bit more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用DI容器来注册和解析依赖项，而不是在组合根中手动管理它们。因此，默认构造函数方法被称为恶劣注入。在下一节中，我们将对此进行更多探讨。
- en: Bastard Injection
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恶劣注入
- en: Usually, classes have more than one constructor. You might have a situation
    where you have referred to some class from another assembly in your default constructor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类有多个构造函数。你可能会有这样的情况，在默认构造函数中从另一个组件引用了某个类。
- en: 'The following diagram shows how one class has two constructors: one default
    and one parameterized. The parameterized constructor handles the injection and
    makes the `ISomeClass` implementation available for the class to operate on. Thus,
    the default constructor that is creating an instance of `SomeClass` becomes unnecessary:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了如何一个类有两个构造函数：一个是默认的，另一个是参数化的。参数化构造函数处理注入并使`ISomeClass`实现可用于类操作。因此，创建`SomeClass`实例的默认构造函数变得不再必要：
- en: '![](img/6b599f09-8916-4f3f-85ac-54710d8b7933.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b599f09-8916-4f3f-85ac-54710d8b7933.png)'
- en: Problem
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'For simplicity, let''s consider the same example: `EmployeeService`, which
    needs a repository to work with:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们考虑同一个例子：`EmployeeService`，它需要一个仓库来工作：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There is a default constructor which ensures repository availability by creating
    an instance of `SqlEmployeeRepository`. The default repository is referred from
    another assembly, obviously, as the service and repository don't stay in one assembly
    together. That's why the default can be denoted as a **Foreign Default**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个默认构造函数，它通过创建一个`SqlEmployeeRepository`的实例来确保仓库的可用性。显然，默认仓库是从另一个组件中引用的，因为服务和仓库通常不会位于同一个组件中。这就是为什么默认构造函数可以被标记为**外部默认**。
- en: While we thought of having a default repository just because we wanted to make
    the service usable as soon as it is instantiated, unknowingly we designed a tightly
    coupled system between the service and repository.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑只为了使服务在实例化后即可使用而设置一个默认仓库时，我们不知不觉中设计了一个服务和仓库之间紧密耦合的系统。
- en: Solution
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Bastard Injection is bad just because of this Foreign Default. Also, it might
    be depending on something we don't even need inside the class. From the preceding
    example, it's quite clear that, if we use a DI Container, it will automatically
    wire up the resolved dependency to the other parameterized constructor. However,
    if we have these kinds of default constructor, then DI Container might get confused
    while selecting which one to target. Having just one constructor for injection
    ensures a smooth operation with the container.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 恶劣注入之所以不好，仅仅是因为这个外部默认。此外，它可能依赖于我们甚至不需要在类中的某些东西。从前面的例子中可以看出，如果我们使用DI容器，它将自动将解析的依赖项连接到其他参数化构造函数。然而，如果我们有这种类型的默认构造函数，那么DI容器在选择目标时可能会感到困惑。只有一个构造函数用于注入确保与容器的顺畅操作。
- en: When you encounter a default constructor generating coupling with a Foreign
    Default, you can consider eliminating that, as you decide to apply Constructor
    Injection. Having one constructor for DI is enough because it is the responsibility
    of the DI Container to make sure that Foreign Default is in place whenever the
    service is requested.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到默认构造函数与外部默认产生耦合时，你可以考虑消除它，因为当你决定应用构造函数注入时。有一个构造函数用于DI就足够了，因为确保外部默认在服务请求时始终就绪是DI容器的责任。
- en: While you refactor the code and remove the default constructor, the compiler
    might complain. In that case, you need to move instantiation codes to the Composition
    Root. If the referred dependency is a *Local Default* (it resides inside the same
    assembly), then we still need to remove that constructor, because constructor
    ambiguity leads to an increase in the complexity of *Auto-Wiring*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重构代码并移除默认构造函数时，编译器可能会报错。在这种情况下，你需要将实例化代码移动到组合根。如果所引用的依赖项是*局部默认值*（它位于同一程序集内），那么我们仍然需要移除该构造函数，因为构造函数歧义会导致*自动装配*复杂性的增加。
- en: If you remember, we have already discussed local defaults in [Chapter 8](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml),
    *Patterns - Dependency Injection*. The easiest way to handle local defaults is
    to introduce *Property Injection*. The default constructor can be converted to
    a writable property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们已经在[第8章](795befd2-857f-40d2-ba05-cb2921168bcc.xhtml)中讨论了局部默认值，*模式 -
    依赖注入*。处理局部默认值的最简单方法就是引入*属性注入*。默认构造函数可以被转换为一个可写属性。
- en: Constrained Construction
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束构造
- en: Here comes yet another type of *Anti-Pattern,* that tries to hijack the constructor.
    So, the developer forces the dependency's constructor to have a particular signature,
    which creates the problem. The reason behind this might be the intention of defining
    the dependencies in external configuration files to achieve late binding.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，还有一种类型的*反模式*，试图劫持构造函数。因此，开发者迫使依赖项的构造函数具有特定的签名，这导致了问题。背后的原因可能是为了通过外部配置文件定义依赖项以实现后期绑定。
- en: Late binding can be referred to as reading the type of repository (the derived
    class of the repository) and connection string from the configuration file to
    instantiate some repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 后期绑定可以指从配置文件中读取存储库类型（存储库的派生类）和连接字符串以实例化某些存储库。
- en: 'Having a late binding technique not only helps to isolate code from the dependency
    but also makes sure that the code is not recompiled if the configuration is updated.
    Using a commonplace or application root to define all dependencies doesn''t expose
    any problem, but recompiling is a must when we want to update dependencies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有后期绑定技术不仅有助于将代码与依赖项隔离，而且确保在配置更新时代码不会被重新编译。使用通用或应用程序根来定义所有依赖项不会暴露任何问题，但当我们想要更新依赖项时，重新编译是必须的：
- en: '![](img/b26c2b49-2055-4fa7-93d7-8a9bab80c914.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b26c2b49-2055-4fa7-93d7-8a9bab80c914.png)'
- en: Problem
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Imagine two repositories `EmployeeRepository` and `StaffRepository` used in
    an application. Both have constructors and you will pass the type of repository
    and connection string to both of them in order to create the repositories using
    these params. This is bad as you will now fetch the repository type and connection
    string from the config which might create issues if the `config`, does not have
    the required keys.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有两个在应用程序中使用的存储库`EmployeeRepository`和`StaffRepository`。它们都有构造函数，你将传递存储库类型和连接字符串给它们，以便使用这些参数创建存储库。这是不好的，因为你现在将从配置中获取存储库类型和连接字符串，如果`config`没有所需的键，可能会引发问题。
- en: 'Now after you fetch the repository type name from the `config`, you have to
    create a `System.Type` instance using that name:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经从`config`中获取了存储库类型名称，你必须使用该名称创建一个`System.Type`实例：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Activator.CreateInstance` is used to call the constructor of the given type.
    The second param in this method is passed to the constructor of the type provided
    in the first param.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activator.CreateInstance`用于调用给定类型的构造函数。此方法中的第二个参数传递给第一个参数中提供的类型的构造函数。'
- en: 'Suppose the type in the `config` is `SqlEmployeeRepository`. Basically, it
    assumes the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`config`中的类型是`SqlEmployeeRepository`。基本上，它假设以下内容：
- en: '`SqlEmployeeRepository` derives from `EmployeeRepository`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SqlEmployeeRepository`继承自`EmployeeRepository`'
- en: The implementation should contain a constructor that can take a connection string
    as a parameter
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应该包含一个可以接受连接字符串作为参数的构造函数
- en: These are the constraints, actually.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上就是约束。
- en: 'From the object construction perspective, it might look perfect, but there
    are disadvantages. For instance, think of constructing the repositories with the
    same dependency such as a single context. With the `Activator.CreateInstance`,
    we can no doubt create instances of the type specified to it, which in our case
    will create instances of `EmployeeRepository` and `StaffRepository`. But we can
    never assign a single context to both of them, as everyone will create their individual
    context based on their constructors. The following diagram depicts what I want
    to convey:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象构建的角度来看，它可能看起来很完美，但也有一些缺点。例如，考虑使用相同依赖项（如单个上下文）构建存储库。使用 `Activator.CreateInstance`，我们可以无疑地创建指定类型的实例，在我们的例子中，这将创建
    `EmployeeRepository` 和 `StaffRepository` 的实例。但我们无法将单个上下文分配给它们中的任何一个，因为每个人都会根据他们的构造函数创建他们自己的上下文。以下图表描述了我想要传达的内容：
- en: '![](img/1f2672df-330e-436b-be6f-604db85e0e54.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f2672df-330e-436b-be6f-604db85e0e54.png)'
- en: 'Sharing of context can only happen if someone from the outside provides that
    to each of them instead of their creating the context themselves:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当外部人员为它们中的每一个提供上下文，而不是它们自己创建上下文时，才能共享上下文：
- en: '![](img/c9fddb65-626d-49b7-b507-867a49852a70.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9fddb65-626d-49b7-b507-867a49852a70.png)'
- en: Sharing a single dependency across the classes becomes difficult in this situation.
    More than one instance of the same dependency will be created, which is unnecessary.
    This would consume memory and resources as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在类之间共享单个依赖项变得困难。将创建多个相同依赖项的实例，这是不必要的。这将消耗内存和资源。
- en: A single instance of a particular dependency should be carefully chosen while
    designing. If not handled with care, there might be an adverse effect on the application
    running in different threads. If you remember, we have already discussed the Singleton
    Lifetime in [Chapter 6](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml), *Object Lifetime, *where
    we talked about the pattern's benefits and usage.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时应该仔细选择特定依赖项的单个实例。如果没有妥善处理，可能会对在不同线程中运行的应用程序产生不利影响。如果您还记得，我们已经在 [第 6 章](72113d11-0af8-431f-91d0-ced4cb35af21.xhtml)
    中讨论了 Singleton Lifetime，*对象生命周期*，我们讨论了该模式的优点和用法。
- en: The Someone can be considered to be a Factory which we are going to explore
    next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将某人视为一个工厂，这是我们接下来将要探讨的。
- en: Solution
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: A DI container comes to the rescue at the composition root to overcome these
    difficulties and resolve all the dependencies in one go. Thus, the injection can
    take place and everything works smoothly. There is no need to have individual
    constructors for the dependencies with connection strings.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: DI 容器在组合根处提供帮助，以克服这些困难并一次性解决所有依赖项。因此，注入可以发生，一切运行顺利。不需要为具有连接字符串的依赖项提供单独的构造函数。
- en: Even without a DI Container, we can formulate our solution differently. Abstract
    Factory comes into the play when we think of centralizing the dependency construction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有 DI 容器，我们也可以以不同的方式制定我们的解决方案。当我们想到集中依赖项构建时，抽象工厂就派上用场了。
- en: First of all, the Factory, Service, and Repository should be in different assemblies.
    There is a strong reason behind that. We will explore it shortly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，工厂、服务和存储库应该位于不同的程序集中。这背后有一个强有力的原因。我们将很快探讨它。
- en: Instead of creating every dependency object inside the *Global asax* for ASP.NET
    app using `Activator.CreateInstance`, we will design in a different way so that
    there will be no need to recompile the app every time you want to use different
    types of repositories.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 应用程序中，我们不会使用 `Activator.CreateInstance` 在 *Global asax* 内部创建每个依赖对象，而是将设计成不同的方式，这样就不需要每次想要使用不同类型的存储库时都重新编译应用程序。
- en: 'We will design a Factory named `EmployeeServiceFactory` implementing `IEmployeeServiceFactory` using
    a particular repository. This factory will be responsible for creating the service.
    `Service` would look something like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个名为 `EmployeeServiceFactory` 的工厂，该工厂实现 `IEmployeeServiceFactory` 并使用特定的存储库。这个工厂将负责创建服务。`Service`
    可能看起来像以下这样：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`EmployeeServiceFactory` contains a `CreateService()` method to create the
    service it is responsible for (`EmployeeService` in this case).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeServiceFactory` 包含一个 `CreateService()` 方法来创建它所负责的服务（在本例中为 `EmployeeService`）。'
- en: It's important to isolate the Factory from the app and `DataAccess` to remove
    coupling. So, the Factory should be in a different assembly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将工厂与应用程序和 `DataAccess` 隔离是很重要的，以消除耦合。因此，工厂应该位于不同的程序集。
- en: 'You can store the assembly-qualified type name for a factory in a `.config`
    file. `Activator.CreateInstance` can then be used to create an instance of the
    `IEmployeeServiceFactory` implementation (that you will define in the config)
    because that has a default constructor:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`.config`文件中存储工厂的合格类型名称。然后可以使用`Activator.CreateInstance`来创建`IEmployeeServiceFactory`实现（你将在配置中定义）的实例，因为它有一个默认构造函数：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With `employeeFactory` now you can fire `CreateService()`, which will return
    the `EmployeeService` instance by using the related repository `EmployeeRepository`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了`employeeFactory`，你可以调用`CreateService()`，这将通过相关的存储库`EmployeeRepository`返回`EmployeeService`实例。
- en: If you decide to use another type of dependency for the service instead of `EmployeeRepository`,
    then you can update the related key in the `config`. But before that, you need
    to add another factory in the factory assembly to implement `IEmployeeServiceFactory` and
    operate on the new configured repository. In this way, you recompile the factory
    assembly without compiling the application again and everything works as expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用除`EmployeeRepository`之外的其他类型作为服务的依赖项，那么你可以更新`config`中的相关键。但在那之前，你需要向工厂程序集添加另一个工厂来实现`IEmployeeServiceFactory`并操作新的配置存储库。这样，你重新编译工厂程序集，而不需要重新编译应用程序，一切按预期工作。
- en: Service Locator
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器
- en: 'If you remember, in the *Control Freak* section, we discussed Static Factories.
    With certain modifications, a Static Factory can behave as a Service Locator.
    As the name suggests, it will locate or find your required service:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，在*控制狂*部分，我们讨论了静态工厂。通过某些修改，静态工厂可以表现得像服务定位器。正如其名所示，它将定位或找到你所需的服务：
- en: '![](img/eb58b76b-a22f-41d5-bc18-e7063e0a4694.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb58b76b-a22f-41d5-bc18-e7063e0a4694.png)'
- en: '*Service Locator* is very useful in many cases, which is why developers consider
    it to be a pattern. But it has many disadvantages. That''s why we are listing
    this in this chapter instead of the previous one.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务定位器*在许多情况下非常有用，这就是为什么开发者认为它是一个模式。但它有很多缺点。这就是为什么我们把它列在本章而不是上一章。'
- en: I am not going to discourage you from using this technique, but I would like
    to shed some light on its pros and cons. This will definitely help you to make
    better design decisions according to your application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会阻止你使用这种技术，但我想揭示一些其优缺点。这肯定有助于你根据你的应用程序做出更好的设计决策。
- en: 'Some noticeable properties of Locator include the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器的一些显著特性包括以下内容：
- en: The important logic behind *Locator* is that it allows dependencies or services
    to be injected into it easily
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定位器*背后的重要逻辑是它允许依赖项或服务轻松地注入其中'
- en: A Static Factory, when configured with services or dependencies, is usually
    considered a *Service Locator*
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当配置了服务或依赖项时，静态工厂通常被认为是*服务定位器*
- en: The configuration of a Service Locator can happen at the Composition Root
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器的配置可以在组合根处进行
- en: Service Locator configuration can be managed through code or reading-related
    settings from config
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务定位器的配置可以通过代码或读取相关的配置设置来管理
- en: A DI Container looks like a *S*ervice Locator. The principal duty of a Locator
    or Container in the DI Context is to resolve the dependency graph before every
    other operation starts. Ideally, resolving the graph should only happen at the
    Composition Root for proper implementation. The problem starts when you ask for
    dependencies or services in the application directly using the Locator or Container,
    instead of injecting them to the consumer. In this case, Locator will be tagged
    as an anti-pattern.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入容器看起来像*服务定位器*。在DI上下文中，定位器或容器的主要职责是在其他操作开始之前解决依赖图。理想情况下，解决图应该只在组合根处发生，以实现正确的实现。问题开始于你直接在应用程序中使用定位器或容器请求依赖项或服务，而不是将它们注入到消费者中。在这种情况下，定位器将被标记为反模式。
- en: 'The Locator Process can be defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器过程可以定义为如下：
- en: '**While registering a service, Locator stores one instance of it in a Dictionary**: The
    registration is normally done using an interface. You basically inform the Locator
    about an interface and its concrete implementation. For example, you would say
    *Serve `EmployeeService` if `IEmployeeService` is requested, Serve `StudentService`
    if `IStudentService` is demanded*.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在注册服务时，定位器将一个实例存储在字典中**：注册通常使用接口完成。你基本上告诉定位器一个接口及其具体实现。例如，你会说*如果请求`EmployeeService`则提供`EmployeeService`，如果需要`IStudentService`则提供`StudentService`*。'
- en: '**Locator receives the request to serve one instance of a service registered
    by its interface**: So, when some code in your application wants to work with
    a `Student` entity, it will ask the Locator for an `IStudentInterface` implementation.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定位器接收请求以提供其接口注册的服务的一个实例**：所以，当你的应用程序中的某些代码想要与`Student`实体一起工作时，它会向定位器请求一个`IStudentInterface`实现。'
- en: '**Locator searches for the instance from the stored instances and then returns
    that to the client: **As you have already trained the Locator, it will just return
    the requested implementation of the interface by checking all the stored instances.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定位器从存储的实例中搜索实例，然后将其返回给客户端**：正如你已经训练过的定位器，它将只通过检查所有存储的实例来返回请求的接口实现。'
- en: Design
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: 'A simple Service Locator would resemble the following class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的服务定位器可能类似于以下类：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Register` method stores the service in the dictionary and `GetService`
    returns. We can use the locator to get the instance of a particular type:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`方法将服务存储在字典中，`GetService`方法返回。我们可以使用定位器来获取特定类型的实例：'
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you have registered the service beforehand using the `Register` method, then
    you can get it from the dictionary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用`Register`方法预先注册了服务，那么你可以从字典中获取它。
- en: Advantages
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点
- en: 'Of course, the pattern has some advantages:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个模式也有一些优点：
- en: It supports late binding by altering the registration codes.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过更改注册代码来支持后期绑定。
- en: It adopts program against interfaces so that we can develop code in parallel
    and we can replace modules as per our requirements.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它采用基于接口的程序，这样我们就可以并行开发代码，并且可以按照我们的要求替换模块。
- en: Separation of concerns can be achieved. We can write maintainable code, though
    it is not so easy.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以实现关注点的分离。我们可以编写可维护的代码，尽管这并不容易。
- en: Don't get fooled by the advantages. It might look perfectly fine to you, but
    there are many disadvantages with this approach.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这些优势所迷惑。这可能看起来对你来说非常完美，但这种方法有很多缺点。
- en: Problem
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Service Locator acts as a proper pattern; however, you have to live with the
    following issues:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定位器作为一个合适的模式；然而，你必须忍受以下问题：
- en: Code reusability
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码可重用性
- en: 'It hampers the reusability of the class as dependencies are not centralized
    anymore with Locator. They might be scattered throughout the class by the Locator''s `GetService`
    method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 它阻碍了类的可重用性，因为依赖关系不再由定位器集中管理。它们可能通过定位器的`GetService`方法散布在整个类中：
- en: '![](img/a995e4f8-b337-47e6-9b84-2d9a7e91033c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a995e4f8-b337-47e6-9b84-2d9a7e91033c.png)'
- en: '`EmployeeService` now depends upon both `EmployeeRepository` and `ServiceLocator`.
    Ideally, it should just rely upon the repository to follow the DI principle.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeService`现在依赖于`EmployeeRepository`和`ServiceLocator`。理想情况下，它应该只依赖于存储库来遵循DI原则。'
- en: With both these dependencies in place, if someone wants to reuse `EmployeeService`,
    then they have to refer to both of them. If `ServiceLocator` stays in a different
    assembly, then the assembly reference is also required, which draws a very inefficient
    design. You will definitely agree with me if I say that it is a tightly coupled
    architecture.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个依赖项都存在，如果有人想要重用`EmployeeService`，那么他们必须引用这两个依赖项。如果`ServiceLocator`位于不同的程序集，那么还需要程序集引用，这会导致一个非常低效的设计。如果你说我这是一个紧密耦合的架构，你一定会同意我的观点。
- en: 'Moreover, the consumer of the service won''t be able to identify the dependencies
    while instantiating the service. That is because Locator is used internally inside
    the constructor or the methods and not exposed, unlike the DI strategy:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，服务的消费者在实例化服务时无法识别依赖关系。这是因为定位器在构造函数或方法内部使用，而不是像DI策略那样公开：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you might argue, Why would the developer would try to know what's inside
    because the dependencies are internally handled inside the default constructor?
    But what will happen if you forgot to register the dependency to Locator? Don't
    say that you won't forget. Most likely it will happen because, while you instantiate
    the class, the dependency's existence is not clear through the constructor. Therefore,
    if the class is not telling you what it depends on, you won't be so careful in
    finding and registering it, which would throw up unexpected exceptions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会争辩，开发者为什么要试图了解内部的内容，因为依赖关系是在默认构造函数内部处理的吗？但是如果你忘记将依赖关系注册到定位器中会发生什么？不要说你不会忘记。很可能发生这种情况，因为在你实例化类的时候，依赖关系的存在并不能通过构造函数来明确。因此，如果类没有告诉你它依赖于什么，你在寻找和注册它时就不会那么小心，这可能会导致意外的异常。
- en: I know what you are thinking now; apparently, the service is a type of Control
    Freak, isn't it? It is taking control of the dependencies using Locator.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你现在在想什么；显然，服务是一种控制狂，不是吗？它正在使用定位器来控制依赖项。
- en: The needy class means the class that depends on someone else. It no longer follows
    DI because the dependency is not injected; rather, it is fetched from Locator's `static` dictionary.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 需求类（needy class）指的是依赖于他人的类。它不再遵循DI，因为依赖项不是注入的；而是从定位器的`static`字典中获取的。
- en: Another problem is clearly identifiable when the developer wants to add more
    dependencies to the class that has already adopted the Locator Pattern. Either
    you follow the same principle to introduce more dependencies or remove the Service
    Locator pattern and implement DI. Compilation errors are a certainty in both these
    cases.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在开发者想要向已经采用定位器模式的类添加更多依赖项时可以清楚地识别出来。您要么遵循相同的原理引入更多依赖项，要么移除服务定位器模式并实现DI。在这两种情况下，编译错误是肯定的。
- en: For all the preceding reasons, Service Locator is considered an anti-pattern.
    Let's talk about a robust solution to address this anti-pattern.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有上述原因，服务定位器被认为是一种反模式。让我们谈谈解决这种反模式的稳健解决方案。
- en: Solution
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: As usual, Constructor Injection is the best fit and comes to mind first when
    we decide to refactor Service Locator codes. Complete removal of Service Locator
    can be achieved through Constructor Injection.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，构造函数注入（Constructor Injection）是最合适的选择，当我们决定重构服务定位器（Service Locator）代码时，首先想到的就是它。通过构造函数注入可以完全移除服务定位器。
- en: Refactoring steps
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构步骤
- en: 'In most cases, Locator is used everywhere in the code base to get an instance
    of the dependency. Follow these steps to refactor it towards DI:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，定位器（Locator）在代码库的各个地方被用来获取依赖项的实例。按照以下步骤重构它以实现DI：
- en: Identify all the Locator calls in the code base.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别代码库中所有的定位器（Locator）调用。
- en: Introduce a member variable to the class to hold the dependency, if that is
    not present.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类中没有，引入一个成员变量来持有依赖项。
- en: Mark the field `readonly` so that it can't be modified outside the constructor.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字段标记为`readonly`，这样它就不能在构造函数外部被修改。
- en: Assign the field inside the constructor using the Locator. Now the Locator call
    is in one place.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数内部使用定位器分配字段。现在定位器调用只在一个地方。
- en: Add a constructor parameter for the dependency.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为依赖项添加一个构造函数参数。
- en: Remove Locator from the constructor block and directly assign the constructor
    parameter to the `readonly` field.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从构造函数块中移除定位器，并直接将构造函数参数分配给`readonly`字段。
- en: Identify all the instantiation made to the class and move the wiring to a Composition
    Root.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别对类的所有实例化调用，并将连接（wiring）移动到组合根（Composition Root）。
- en: 'After all these steps, the same `EmployeeService` with the Constructor Injection
    Pattern can be designed, shown as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些步骤后，使用构造函数注入模式（Constructor Injection Pattern）的相同`EmployeeService`可以被设计出来，如下所示：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The service now asks its consumers to provide a dependency of type `IEmployeeRepository`
    implementation, which was not happening before.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务要求其消费者提供一个`IEmployeeRepository`实现的依赖项，之前并没有发生这种情况。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The last chapter illustrated ways to implement DI. When we don't implement patterns
    correctly, we end up with a bad design for our app. We learned about mistakes
    we regularly make while implementing DI.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一章介绍了实现依赖注入（DI）的方法。当我们没有正确实现模式时，我们的应用程序设计就会变得糟糕。我们了解到了在实现DI过程中经常犯的错误。
- en: Before moving on to DI anti-patterns, we discussed why and when we can consider
    DI as an anti-pattern itself!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续讨论DI反模式之前，我们讨论了为什么以及何时我们可以将DI本身视为反模式！
- en: Then we moved ahead and touched upon all those common anti-patternscaused by
    misconceptions regarding Dependency Injection. We explored Control Freak, Bastard
    Injection, Constrained Construction, and (the most important) Service Locator.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续前进，讨论了所有由对依赖注入（Dependency Injection）的误解引起的常见反模式。我们探讨了控制狂（Control Freak）、糟糕的注入（Bastard
    Injection）、约束构造（Constrained Construction）和（最重要的）服务定位器（Service Locator）。
- en: Control Freak is the easiest one to discover. Whenever you see any class using
    the `new` keyword to instantiate its dependencies, that means it is trying to
    manage them without any external module controlling it. This is bad and should
    be avoided in the DI ecosystem.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 控制狂（Control Freak）是最容易发现的。每当您看到任何类使用`new`关键字来实例化其依赖项时，这意味着它试图在没有外部模块控制的情况下管理它们。这是不好的，在DI生态系统中应该避免这样做。
- en: This is the most dangerous one, which we should address first while refactoring.
    Other patterns are less damaging than this because it has a direct impact on loose
    coupling. Composition Root should be the place to instantiate everything needed
    for the application and then every possible dependency will be available by injection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是其中最危险的一个，我们在重构时应该首先解决。其他模式比这个危害小，因为它对松耦合有直接影响。组合根（Composition Root）应该是实例化应用程序所需的一切的地方，然后通过注入，所有可能的依赖项都将可用。
- en: Bastard Injection can be seen with Foreign Defaults which is unnecessary from
    the DI point of view. We can easily move to Constructor Injection by removing
    codes related to Foreign Defaults.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 恶魔注入（Bastard Injection）可以通过外部默认值（Foreign Defaults）观察到，从依赖注入（DI）的角度来看，这是不必要的。我们可以通过移除与外部默认值相关的代码，轻松地过渡到构造函数注入（Constructor
    Injection）。
- en: On the other hand, Constrained Construction imposes restrictions on constructors
    to support late binding of services by taking types from configuration files,
    which in turn creates tight coupling. Adopting a DI Container or one Abstract
    Factory would help to eliminate constraints.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，约束构造（Constrained Construction）通过对构造函数施加限制，通过从配置文件中获取类型来支持服务的后期绑定，这反过来又创建了紧密耦合。采用依赖注入容器（DI
    Container）或一个抽象工厂（Abstract Factory）将有助于消除这些限制。
- en: Last but not the least, we discussed Service Locator, which is arguably a proper
    Pattern. However, we explored its pros and cons and came to the conclusion that
    it is an anti-pattern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们讨论了服务定位器（Service Locator），这可以说是正确的设计模式。然而，我们探讨了它的优缺点，并得出结论，它是一个反模式。
- en: If you have reached this point, that means you have now have grasped the ways
    to implement DI and what to avoid. In the next chapter, we will be discussing
    more realistic problems in projects and how to deal with them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这个阶段，这意味着你现在已经掌握了实现依赖注入的方法以及要避免的事项。在下一章中，我们将讨论项目中更现实的问题以及如何处理这些问题。
