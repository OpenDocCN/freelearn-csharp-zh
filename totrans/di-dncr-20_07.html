<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interception</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">We have already discussed two pillars of the DI ecosystem in the previous two chapters. </span><span class="koboSpan" id="kobo.2.2">Those pillars provided us with ways to identify dependencies, register them and then manage their lifetimes as required. </span><span class="koboSpan" id="kobo.2.3">In this chapter, we are going to cover something different which addresses the architectural problem of DI.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.3.1">An application without security, logging, caching, transaction management, and so on seems very incomplete. </span><span class="koboSpan" id="kobo.3.2">When we write codes to cover up all these functionalities for the app, we might end up writing repetitive codes in each module all around the application. </span><span class="koboSpan" id="kobo.3.3">Even if Dependency Injection has an existence in our application, solving the purpose of managing the requirements of a class and trying to provide all the types needed for logging, or others as mentioned previously, violates SRP and DRY. </span><span class="koboSpan" id="kobo.3.4">Thus, we need a different approach to solve this problem and that is </span><strong><span class="koboSpan" id="kobo.4.1">Interception</span></strong><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">Simply put, Interception will help us dynamically inject blocks of code wherever required.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Now, you might have a question regarding when and how we can inject this code. </span><span class="koboSpan" id="kobo.6.2">Let's hold on to the </span><em><span class="koboSpan" id="kobo.7.1">how</span></em><span class="koboSpan" id="kobo.8.1"> for now and focus on the </span><em><span class="koboSpan" id="kobo.9.1">when</span></em><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">We will discuss the </span><em><span class="koboSpan" id="kobo.11.1">how</span></em><span class="koboSpan" id="kobo.12.1"> soon. </span><span class="koboSpan" id="kobo.12.2">To answer </span><em><span class="koboSpan" id="kobo.13.1">when</span></em><span class="koboSpan" id="kobo.14.1">, the injection can be done before or after, or it can even totally replace the actual method execution.</span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will understand what Interception is and how it can be implemented. </span><span class="koboSpan" id="kobo.15.2">We will find out possible techniques to interrupt the flow of execution. </span><span class="koboSpan" id="kobo.15.3">Definitely, we will discuss why we even need </span><em><span class="koboSpan" id="kobo.16.1">Interception</span></em><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Patterns and principles of Interception in .NET Core is the next thing we are going to illustrate. </span><span class="koboSpan" id="kobo.18.2">We will even extend the concept of Interception in ASP.NET MVC Core using filters and middleware.</span></p>
<p><span class="koboSpan" id="kobo.19.1">We will cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Cross-cutting concerns and aspects</span></li>
<li><strong><span class="koboSpan" id="kobo.21.1">Aspect-oriented programming</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><strong><span class="koboSpan" id="kobo.23.1">AOP</span></strong><span class="koboSpan" id="kobo.24.1">): Its types, advantages, disadvantages, and process</span></li>
<li><span class="koboSpan" id="kobo.25.1">Demos of each type of AOP</span></li>
<li><span class="koboSpan" id="kobo.26.1">Interception adoption in ASP.NET Core MVC using filters and middleware</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Introducing Interception</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this section, I will introduce you to </span><em><span class="koboSpan" id="kobo.3.1">Interception</span></em><span class="koboSpan" id="kobo.4.1"> along with the connection it has with the </span><em><span class="koboSpan" id="kobo.5.1">Dependency Injection</span></em><span class="koboSpan" id="kobo.6.1">.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.7.1">Interception</span><span><span class="koboSpan" id="kobo.8.1"> </span></span><span class="koboSpan" id="kobo.9.1">is</span><span><span class="koboSpan" id="kobo.10.1"> </span></span><span class="koboSpan" id="kobo.11.1">another</span><span><span class="koboSpan" id="kobo.12.1"> </span></span><span class="koboSpan" id="kobo.13.1">important pillar. </span><span><span class="koboSpan" id="kobo.14.1">Interception is the process through which we can easily intercept the call between a consumer and a service in order to execute certain codes before or after the service is invoked.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">The following diagram shows what happens with and without the Interception process:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img height="156" width="212" src="assets/280c7e04-d3e5-4578-b67b-515d13b3436c.png"/></span></div>
<p><span><span class="koboSpan" id="kobo.17.1">If we consider the preceding request as a call that comes to the index action of a controller named </span></span><kbd><span class="koboSpan" id="kobo.18.1">CompanyController</span></kbd><span><span class="koboSpan" id="kobo.19.1"> and before the company details are served to the client, we can run a few bookkeeping tasks </span></span><span><span class="koboSpan" id="kobo.20.1">such as</span></span> <em><span class="koboSpan" id="kobo.21.1">Who requested the company details?</span></em><span><span class="koboSpan" id="kobo.22.1">,</span></span> <em><span class="koboSpan" id="kobo.23.1">When was the call </span></em><em><span class="koboSpan" id="kobo.24.1">made?</span></em><span><span class="koboSpan" id="kobo.25.1">, </span><em><span class="koboSpan" id="kobo.26.1">I</span></em></span><em><span class="koboSpan" id="kobo.27.1">s the user authorized</span></em> <em><span class="koboSpan" id="kobo.28.1">to receive the company details?</span></em><span><span class="koboSpan" id="kobo.29.1">, and so on. </span><span class="koboSpan" id="kobo.29.2">For all these tasks, we have to stop the flow in the controller to do all these operations, and after we are done, we can again resume the main task of returning data. </span><span class="koboSpan" id="kobo.29.3">But all these tasks can't be written inside the controller action, because the main responsibility of the action is to return the company details. </span><span class="koboSpan" id="kobo.29.4">If we write everything inside the action method, it would violate</span></span><span class="koboSpan" id="kobo.30.1"> SRP.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The decorator</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's find out by a class that requires basic logging as a part of its operations. </span><span class="koboSpan" id="kobo.2.2">A </span><kbd><span class="koboSpan" id="kobo.3.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.4.1"> might have a method to assign a </span><kbd><span class="koboSpan" id="kobo.5.1">User</span></kbd><span class="koboSpan" id="kobo.6.1"> to a </span><kbd><span class="koboSpan" id="kobo.7.1">Company</span></kbd><span class="koboSpan" id="kobo.8.1">.</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    public void AssignUserToCompany(int userId, int companyId)</span><br/><span class="koboSpan" id="kobo.10.1">    {</span><br/><span class="koboSpan" id="kobo.11.1">      // Database operation to assign User to Company.</span><br/><span class="koboSpan" id="kobo.12.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.13.1">Now, a client asks you to log some important information while this operation takes place, just for bookkeeping and future reference. </span><span class="koboSpan" id="kobo.13.2">The information could be the start time of the operation, end time of the operation, who requested for the operation, exceptions if any, and so on. </span><span class="koboSpan" id="kobo.13.3">The instant solution that comes to your mind might look something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    public void AssignUserToCompany(int userId, int companyId)</span><br/><span class="koboSpan" id="kobo.15.1">    {</span><br/><strong><span class="koboSpan" id="kobo.16.1">      _logger.Log("Assign to User started.");</span></strong><br/><span class="koboSpan" id="kobo.17.1">      // Database operation to assign User to Company.</span><br/><strong><span class="koboSpan" id="kobo.18.1">      _logger.Log("Assign to User ended.");</span></strong><br/><span class="koboSpan" id="kobo.19.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.20.1">Notice the bold lines. </span><kbd><span class="koboSpan" id="kobo.21.1">ILogger</span></kbd><span class="koboSpan" id="kobo.22.1"> can be injected to the repository through a constructor for log operations. </span><span class="koboSpan" id="kobo.22.2">We can also put </span><kbd><span class="koboSpan" id="kobo.23.1">try...catch</span></kbd><span class="koboSpan" id="kobo.24.1"> block and log exceptions. </span><span class="koboSpan" id="kobo.24.2">Everything looks good, but don't you think the class is doing more than what it is intended for and that we are violating the </span><strong><span class="koboSpan" id="kobo.25.1">Single Responsibility Principle</span></strong><span class="koboSpan" id="kobo.26.1"> (</span><strong><span class="koboSpan" id="kobo.27.1">SRP</span></strong><span class="koboSpan" id="kobo.28.1">). </span><span class="koboSpan" id="kobo.28.2">Therefore, let's think of another solution. </span><span class="koboSpan" id="kobo.28.3">How about the following?</span></p>
<pre><span class="koboSpan" id="kobo.29.1">    public class </span><strong><span class="koboSpan" id="kobo.30.1">LoggingCompanyRepository : CompanyRepository</span></strong><br/><span class="koboSpan" id="kobo.31.1">    { </span><br/><span class="koboSpan" id="kobo.32.1">      private readonly CompanyRepository _companyReposiory;</span><br/><strong><span class="koboSpan" id="kobo.33.1">      private readonly ILogger _logger;</span></strong><br/><span class="koboSpan" id="kobo.34.1">      public LoggingCompanyRepository(CompanyRepository </span><br/><span class="koboSpan" id="kobo.35.1">         companyRepository, ILogger logger)</span><br/><span class="koboSpan" id="kobo.36.1">      {</span><br/><span class="koboSpan" id="kobo.37.1">        this._companyReposiory = companyRepository ??</span><br/><span class="koboSpan" id="kobo.38.1">           throw new ArgumentNullException("companyRepository");</span><br/><span class="koboSpan" id="kobo.39.1">        this._logger = logger ?? </span><span class="koboSpan" id="kobo.39.2">throw new </span><br/><span class="koboSpan" id="kobo.40.1">           ArgumentNullException("logger");</span><br/><span class="koboSpan" id="kobo.41.1">     }</span><br/><span class="koboSpan" id="kobo.42.1">     public override void AssignUserToCompany(int userId,</span><br/><span class="koboSpan" id="kobo.43.1">         int companyId)</span><br/><span class="koboSpan" id="kobo.44.1">     {</span><br/><strong><span class="koboSpan" id="kobo.45.1">        _logger.Log("Assign to User started.");</span></strong><br/><span class="koboSpan" id="kobo.46.1">        _companyReposiory.AssignUserToCompany(userId, </span><br/><span class="koboSpan" id="kobo.47.1">            companyId);</span><br/><strong><span class="koboSpan" id="kobo.48.1">        _logger.Log("Assign to User ended.");</span></strong><br/><span class="koboSpan" id="kobo.49.1">     }</span><br/><span class="koboSpan" id="kobo.50.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.51.1">We introduced a decorated </span><kbd><span class="koboSpan" id="kobo.52.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.53.1"> named as </span><kbd><span class="koboSpan" id="kobo.54.1">LoggingCompanyRepository</span></kbd><span class="koboSpan" id="kobo.55.1">, which is managing the logging part. </span><span class="koboSpan" id="kobo.55.2">It is initialized by taking repository and logger dependencies and executing the method as needed with log entries. </span><span class="koboSpan" id="kobo.55.3">Following the Decorator Pattern, the new class tries to coordinate the work between the repository and logger.</span></p>
<p><span class="koboSpan" id="kobo.56.1">The final task would be to compose the decorator, which has the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.57.1">We can create the instances of </span><kbd><span class="koboSpan" id="kobo.58.1">SqlCompanyRepository</span></kbd><span class="koboSpan" id="kobo.59.1"> and </span><kbd><span class="koboSpan" id="kobo.60.1">SqlLogger</span></kbd><span class="koboSpan" id="kobo.61.1"> which derive from related abstractions.</span></li>
<li><span class="koboSpan" id="kobo.62.1">Then, we create the instance of the decorator by injecting these dependencies.</span></li>
<li><span class="koboSpan" id="kobo.63.1">We return the </span><kbd><span class="koboSpan" id="kobo.64.1">CompanyService</span></kbd><span class="koboSpan" id="kobo.65.1"> instance with the decorated repository.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.66.1">Refer to the following code for these steps:</span></p>
<pre><span class="koboSpan" id="kobo.67.1">    public ICompanyService ResolveCompanyService()</span><br/><span class="koboSpan" id="kobo.68.1">    {</span><br/><span class="koboSpan" id="kobo.69.1">      CompanyRepository companyRepository = new </span><br/><span class="koboSpan" id="kobo.70.1">          SqlCompanyRepository("ConnectionString");</span><br/><span class="koboSpan" id="kobo.71.1">      Controllers.ILogger logger = new SqlLogger();</span><br/><span class="koboSpan" id="kobo.72.1">      CompanyRepository loggingCompanyRepository = </span><strong><span class="koboSpan" id="kobo.73.1">new </span><br/><span class="koboSpan" id="kobo.74.1">          LoggingCompanyRepository(companyRepository, logger);</span></strong><br/><span class="koboSpan" id="kobo.75.1">      return new CompanyService(loggingCompanyRepository);</span><br/><span class="koboSpan" id="kobo.76.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.77.1">This is what Interception is all about. </span><span class="koboSpan" id="kobo.77.2">We are able to interrupt the call made to </span><kbd><span class="koboSpan" id="kobo.78.1">AssignUserToCompany</span></kbd><span class="koboSpan" id="kobo.79.1"> of the concrete class </span><kbd><span class="koboSpan" id="kobo.80.1">SqlCompanyRepository</span></kbd><span class="koboSpan" id="kobo.81.1"> because the </span><kbd><span class="koboSpan" id="kobo.82.1">Service</span></kbd><span class="koboSpan" id="kobo.83.1"> is now composed of a decorator with the concrete class, instead of the direct code block. </span><span class="koboSpan" id="kobo.83.2">When you call the method, it would first go to the decorator's method and then call the concrete class method.</span></p>
<p><span class="koboSpan" id="kobo.84.1">The following diagram explains the flow:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.85.1"><img height="171" width="393" src="assets/216a1091-ff1a-4ed5-8bc4-65a81ac9da54.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Patterns and principles for Interception</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You must be getting a hint that I want you to taste the DI from the perspective of not only injecting dependencies, but also managing and maintaining code for a good architecture. </span><span class="koboSpan" id="kobo.2.2">We explored the Decorator Pattern in the last section, which enabled us to decorate the concrete implementation with a little additional code without even touching any classes in the application. </span><span class="koboSpan" id="kobo.2.3">This forms the basis of Interception.</span></p>
<p><span class="koboSpan" id="kobo.3.1">With Interception, we clearly followed SOLID principles of Software Design. </span><span class="koboSpan" id="kobo.3.2">The moment we started designing the decorator class, that class played a vital role in the SRP. </span><kbd><span class="koboSpan" id="kobo.4.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.5.1"> is managing the database part and the </span><kbd><span class="koboSpan" id="kobo.6.1">LoggingCompanyRepository</span></kbd><span class="koboSpan" id="kobo.7.1"> takes the responsibility for logging.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The </span><strong><span class="koboSpan" id="kobo.9.1">Liskov Substitution Principle</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong><span class="koboSpan" id="kobo.11.1">LSP</span></strong><span class="koboSpan" id="kobo.12.1">) demands that the consumer should not feel the change of any implementations of the dependency. </span><span class="koboSpan" id="kobo.12.2">We achieved this by the decorator implementing the same abstraction that the </span><kbd><span class="koboSpan" id="kobo.13.1">Service</span></kbd><span class="koboSpan" id="kobo.14.1"> demanded, which is </span><kbd><span class="koboSpan" id="kobo.15.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.16.1"> so that we would be able to replace the original one </span><kbd><span class="koboSpan" id="kobo.17.1">SqlCompanyRepository</span></kbd><span class="koboSpan" id="kobo.18.1"> with the decorator one </span><kbd><span class="koboSpan" id="kobo.19.1">LoggingCompanyRepository</span></kbd><span class="koboSpan" id="kobo.20.1">, without any breakage to the service codes.</span></p>
<p><span><span class="koboSpan" id="kobo.21.1">As we were doing all the preceding steps, we did not change any class for implementing the decorator. </span><span class="koboSpan" id="kobo.21.2">Instead, we extended, which strongly followed the</span></span><span class="koboSpan" id="kobo.22.1"> Open/Closed Principle. </span><span class="koboSpan" id="kobo.22.2">Th</span><span><span class="koboSpan" id="kobo.23.1">ere is no such necessity to touch the </span><kbd><span class="koboSpan" id="kobo.24.1">Service</span></kbd><span class="koboSpan" id="kobo.25.1"> class or the consumer.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">The principles behind the Interception following SOLID gives us a hint as to how the Decorator Pattern is closely related to DI, since DI supports Interception. </span><span class="koboSpan" id="kobo.26.2">The Decorator Pattern is the fundamental building block of the concept, but the way we implemented it does not solve the architectural problems in hand. </span><span class="koboSpan" id="kobo.26.3">Let's analyze the </span><span><span class="koboSpan" id="kobo.27.1">associated </span></span><span class="koboSpan" id="kobo.28.1">benefits and problems.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Benefits of the Decorator approach</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With the Decorator approach, we achieved many benefits. </span><span class="koboSpan" id="kobo.2.2">Refer to the following list:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">The </span><kbd><span class="koboSpan" id="kobo.4.1">Service</span></kbd><span class="koboSpan" id="kobo.5.1"> does not know what repository it is receiving. </span><span class="koboSpan" id="kobo.5.2">Notice that </span><kbd><span class="koboSpan" id="kobo.6.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">LoggingCompanyRespository</span></kbd><span class="koboSpan" id="kobo.9.1"> are both declared as </span><span><kbd><span class="koboSpan" id="kobo.10.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.11.1"> instances.</span></span></li>
<li><span><span class="koboSpan" id="kobo.12.1">Just because the types are the same, there is no need to do any changes to the </span></span><kbd><span class="koboSpan" id="kobo.13.1">Service</span></kbd> <span><span class="koboSpan" id="kobo.14.1">class. </span><span class="koboSpan" id="kobo.14.2">Moreover, we added logging behavior to the </span><kbd><span class="koboSpan" id="kobo.15.1">CompanyRepository</span></kbd><span class="koboSpan" id="kobo.16.1"> class without even changing it. </span><span class="koboSpan" id="kobo.16.2">It supports the</span></span><span class="koboSpan" id="kobo.17.1"> Open/Closed principle. </span><span><span class="koboSpan" id="kobo.18.1">All classes are intact.</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">We were able to intercept the concrete </span><kbd><span class="koboSpan" id="kobo.20.1">SqlCompanyRepository</span></kbd><span class="koboSpan" id="kobo.21.1"> methods in order to have log entries. </span><span class="koboSpan" id="kobo.21.2">Thus, we did not violate the SRP of the repository.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.22.1">However, we did not realize a few problems with this approach. </span><span class="koboSpan" id="kobo.22.2">This structure would lead us to a bad architecture in the long run. </span><span class="koboSpan" id="kobo.22.3">Let's find out why.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.23.1">Instead of dealing with the instances manually, always use DI Container to resolve the dependencies. </span><span class="koboSpan" id="kobo.23.2">We will see how we can work with DI Container for Interception in a while.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problems of the Decorator approach</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In a typical project, we will have many of these repositories and services. </span><span class="koboSpan" id="kobo.2.2">We will definitely encounter the following problems:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Imagine the number of lines of codes you would have to write to compose the decorators in order to do Interceptions for hundreds of classes</span></li>
<li><span class="koboSpan" id="kobo.4.1">The next thing is very important, which is actually the basis of our topic in discussion. </span><span class="koboSpan" id="kobo.4.2">What if you have to log in a thousand methods of those hundred classes. </span><span class="koboSpan" id="kobo.4.3">This is common and we need it in almost every method. </span><span class="koboSpan" id="kobo.4.4">Think of the work involved and the size of your app.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.5.1">Due to all these, we will end up going for a different approach for intercepting calls to methods using Aspects. </span><span class="koboSpan" id="kobo.5.2">DI Containers make it easy for us to design aspects and attach Interceptors. </span><span class="koboSpan" id="kobo.5.3">Let's move on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aspect-oriented programming</span></h1>
                </header>
            
            <article>
                
<p><strong><span class="koboSpan" id="kobo.2.1">Object-oriented programming</span></strong><span class="koboSpan" id="kobo.3.1"> (</span><strong><span class="koboSpan" id="kobo.4.1">OOP</span></strong><span class="koboSpan" id="kobo.5.1">) deals with techniques to solve real-world problems with underlying object models. </span><span class="koboSpan" id="kobo.5.2">To design a software, we need to adopt OOP along with good design methodologies in order to make it maintainable, consistent and reliable. </span><span class="koboSpan" id="kobo.5.3">There are many such patterns or problems we will encounter during the application development which are of design decisions, that can neither be solved by OOP practices nor with procedural approaches.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In this chapter, we will address one design decision that can be managed easily by Aspects. </span><span class="koboSpan" id="kobo.6.2">To clarify, we can consider a simple example which is very often seen in codes and that is </span><strong><span class="koboSpan" id="kobo.7.1">logging</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">We do logging in almost every method. </span><span class="koboSpan" id="kobo.8.3">This means you are repeating codes everyday violating the </span><strong><span class="koboSpan" id="kobo.9.1">DRY</span></strong><span class="koboSpan" id="kobo.10.1"> (</span><strong><span class="koboSpan" id="kobo.11.1">Don't Repeat Yourself</span></strong><span class="koboSpan" id="kobo.12.1">) principle.</span></p>
<p><span class="koboSpan" id="kobo.13.1">The following diagram shows you the repeated codes of logging commonly found in your codes:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="189" width="352" src="assets/3d5d05ef-62f3-4930-99ba-0d81f67aec70.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">If I tell you that we can package those logging lines into one modular piece of code and just ask all the methods that need logging, to just import that while running, what would be your reaction? </span><span class="koboSpan" id="kobo.15.2">Yes, that is what an aspect is all about. </span><span class="koboSpan" id="kobo.15.3">So, we can write an aspect to manage logging. </span><span class="koboSpan" id="kobo.15.4">The pattern we follow in order to implement an aspect in our app is known as </span><strong><span class="koboSpan" id="kobo.16.1">Aspect-oriented programming</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><strong><span class="koboSpan" id="kobo.18.1">AOP</span></strong><span class="koboSpan" id="kobo.19.1">)</span><em><span class="koboSpan" id="kobo.20.1">.</span></em><span class="koboSpan" id="kobo.21.1"> It</span><em><span class="koboSpan" id="kobo.22.1"> </span></em><span class="koboSpan" id="kobo.23.1">aims to separate or modularise these repeated codes from the core functionality.</span></p>
<p><span class="koboSpan" id="kobo.24.1">The following is a sneak peak of the solution with an aspect called </span><kbd><span class="koboSpan" id="kobo.25.1">LoggingAspect</span></kbd><span class="koboSpan" id="kobo.26.1">, which packages all the logging codes inside it and is attached to the methods as an attribute above the method (written like </span><kbd><span class="koboSpan" id="kobo.27.1">[LoggingAspect]</span></kbd><span class="koboSpan" id="kobo.28.1">). </span><span class="koboSpan" id="kobo.28.2">Don't worry about the rules for how the logging lines are applied to the methods at the particular location such as </span><em><span class="koboSpan" id="kobo.29.1">start</span></em><span class="koboSpan" id="kobo.30.1"> or </span><em><span class="koboSpan" id="kobo.31.1">end</span></em><span class="koboSpan" id="kobo.32.1"> for now. </span><span class="koboSpan" id="kobo.32.2">We will learn all these soon, which are the concepts behind AOP:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.33.1"><img height="179" width="406" src="assets/1715faca-ea25-4ace-bdbb-b785b0910fab.png"/></span></div>
<p><span class="koboSpan" id="kobo.34.1">When we follow AOP in our application, we can easily attach these modules automatically to our methods. </span><span class="koboSpan" id="kobo.34.2">Thus, developers have all the freedom to only focus on the business logic or core concerns inside the methods, instead of worrying about all the repetitive code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Cross-cutting concerns</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><strong><span class="koboSpan" id="kobo.3.1">concern</span></strong><span class="koboSpan" id="kobo.4.1"> can be defined as a part of a system providing some specific functionality. </span><span class="koboSpan" id="kobo.4.2">If you consider a typical example of saving a user in your system, it may have a business logic something like the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">Validate all fields of user for proper datatype, </span><kbd><span class="koboSpan" id="kobo.6.1">null</span></kbd><span class="koboSpan" id="kobo.7.1"> values, and so on.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Check for the user existence in the system by a unique value such as </span><kbd><span class="koboSpan" id="kobo.9.1">Email</span></kbd><span class="koboSpan" id="kobo.10.1"> or </span><kbd><span class="koboSpan" id="kobo.11.1">UserName</span></kbd><span class="koboSpan" id="kobo.12.1">.</span></li>
<li><span class="koboSpan" id="kobo.13.1">If a user does not exist, create the user, otherwise update the user.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.14.1">All these steps are denoted as </span><strong><span class="koboSpan" id="kobo.15.1">Business Logic</span></strong><span class="koboSpan" id="kobo.16.1">, which might be different in different applications since it depends on your requirements and design. </span><span class="koboSpan" id="kobo.16.2">So, our </span><kbd><span class="koboSpan" id="kobo.17.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.18.1"> method's principal duty is to perform all these steps, which can be defined as a </span><strong><span class="koboSpan" id="kobo.19.1">Main Concern</span></strong><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">However, in a typical application, these are not the only things that happen inside a </span><kbd><span class="koboSpan" id="kobo.22.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.23.1"> method. </span><span class="koboSpan" id="kobo.23.2">You might have to do the following during saving a user:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.24.1">Check whether the logged-in user is authorized to save the user.</span></li>
<li><span class="koboSpan" id="kobo.25.1">Log in text/database that </span><kbd><span class="koboSpan" id="kobo.26.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.27.1"> started.</span></li>
<li><span class="koboSpan" id="kobo.28.1">[Perform the </span><em><span class="koboSpan" id="kobo.29.1">Business Logic</span></em><span class="koboSpan" id="kobo.30.1"> (all the steps previously defined) ] - Main Concern.</span></li>
<li><span class="koboSpan" id="kobo.31.1">Log in text/database that the </span><kbd><span class="koboSpan" id="kobo.32.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.33.1"> method succeeded.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.34.1">Steps 1, 2, and 3 are the steps which are secondary and don't align with the Main Concern. </span><span class="koboSpan" id="kobo.34.2">But these steps can't be ignored. </span><span class="koboSpan" id="kobo.34.3">Moreover, these particular steps are performed in almost every method of the application.</span></p>
<p><span class="koboSpan" id="kobo.35.1">While our method is trying to run the Main Concern, these guys try to interfere and cut the execution and do something else. </span><span class="koboSpan" id="kobo.35.2">That's why they are known as </span><strong><span class="koboSpan" id="kobo.36.1">Cross-Cutting Concerns</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">These concerns are located throughout the application and affect the entire architecture. </span><span class="koboSpan" id="kobo.37.3">Have a look at the following diagram where the arrows indicate the Main Concern and the rectangular areas represent the Cross-Cutting Concerns:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.38.1"><img height="150" width="337" src="assets/ae91997c-b0ae-47a3-b12b-9fee783f0f59.jpg"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aspect</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In simple words, when we see some repetitive patterned codes throughout our app, that's the clue for us to consider them as Cross-Cutting Concerns. These are the code patches, which do not fit with the Main Concern inside the method in execution.</span></p>
<p><span class="koboSpan" id="kobo.3.1">When I say </span><em><span class="koboSpan" id="kobo.4.1">aspect</span></em><span class="koboSpan" id="kobo.5.1"> in the programming paradigm, it basically states the behavioral pattern independent of the actual task/concern at hand. </span><span class="koboSpan" id="kobo.5.2">So, when you package the Cross-Cutting Concerns into one modular piece that can be injected to the methods, you actually design an aspect.</span></p>
<p><span class="koboSpan" id="kobo.6.1">For instance, we want to log at certain lines inside many methods:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    public void SaveUser(User user)
    {
      Log.Debug("SaveUser started");   
      try
      {
        // Service call to save the user.
      </span><span class="koboSpan" id="kobo.7.2">}
      catch(Exception ex)
      {
        Log.Error(ex, "Exception in SaveUser Method");
        throw;
      }
      finally
      {
          Log.Debug("SaveUser Method completed.");
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.8.1">Clearly, </span><kbd><span class="koboSpan" id="kobo.9.1">Log</span></kbd><span class="koboSpan" id="kobo.10.1"> class methods help us to log debug steps and exceptions inside a method. </span><span class="koboSpan" id="kobo.10.2">This particular pattern can be seen often at many places in the app. </span><span class="koboSpan" id="kobo.10.3">That is what a </span><span><span class="koboSpan" id="kobo.11.1">Cross-Cutting Concern</span></span><span class="koboSpan" id="kobo.12.1"> is. </span><span class="koboSpan" id="kobo.12.2">The actual task at hand for the </span><kbd><span class="koboSpan" id="kobo.13.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.14.1"> method is to update the user details such as </span><kbd><span class="koboSpan" id="kobo.15.1">UserName</span></kbd><span class="koboSpan" id="kobo.16.1">, </span><kbd><span class="koboSpan" id="kobo.17.1">Email</span></kbd><span class="koboSpan" id="kobo.18.1">, </span><kbd><span class="koboSpan" id="kobo.19.1">Password</span></kbd><span class="koboSpan" id="kobo.20.1">, and so on, but this method also takes the responsibility to log some lines into files, which violates the SRP. </span><span class="koboSpan" id="kobo.20.2">Also, when these kinds of patterns are repeated across the project, it does not follow the DRY principle.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Look at the following diagram, which depicts logging as a common paradigm across layers of the application:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.22.1"><img height="137" width="277" src="assets/23be4d3a-508f-4637-b303-3d1741f67b18.png"/></span></div>
<p><span class="koboSpan" id="kobo.23.1">So, here, AOP comes to our rescue which encapsulates this pattern to log the start, log the end, and log the exception, and then wrap it around the </span><kbd><span class="koboSpan" id="kobo.24.1">SaveUser</span></kbd><span class="koboSpan" id="kobo.25.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Another common scenario is wrapping our database operations with a </span><kbd><span class="koboSpan" id="kobo.27.1">Transaction</span></kbd><span class="koboSpan" id="kobo.28.1"> block consisting of </span><kbd><span class="koboSpan" id="kobo.29.1">Begin Transaction</span></kbd><span class="koboSpan" id="kobo.30.1">, and </span><kbd><span class="koboSpan" id="kobo.31.1">Commit/Rollback Transaction</span></kbd><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">How about having someone else handling that part for us, while we concentrate on the core codes to operate on the database?</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.33.1">Cross-cutting concerns can be commonly found in the application where you log steps, handle exceptions, manage cache, access control, and so on. </span><span class="koboSpan" id="kobo.33.2">For example, while handling exceptions, you wrap your code using a </span><kbd><span class="koboSpan" id="kobo.34.1">try..catch</span></kbd><span class="koboSpan" id="kobo.35.1"> block so that you are able to operate on that exception found (log to text file/database or send email to admin, and so on). </span><span class="koboSpan" id="kobo.35.2">This particular pattern is needed inside every method. </span><span class="koboSpan" id="kobo.35.3">Now we need to find out a way to ask (more specifically wrap) every method that we need for exception handling, instead of adding the </span><kbd><span class="koboSpan" id="kobo.36.1">try..catch</span></kbd><span class="koboSpan" id="kobo.37.1"> lines inside it. </span><span class="koboSpan" id="kobo.37.2">Thus, that wrapped modular piece can be termed as an aspect, which eventually wraps all methods instructed to it to perform the exception handling, instead of the methods themselves doing the same.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aspect characteristics</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">When we try to encapsulate these Cross-Cutting Concerns to create aspects, we actually make sure they follow some characteristics:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Wrapper:</span></strong><span class="koboSpan" id="kobo.4.1"> All these aspects will be a wrapper around some business functionalities.</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Single Responsibility Principle (SRP): </span></strong><span class="koboSpan" id="kobo.6.1">The wrapper is concerned only about one particular task. </span><span class="koboSpan" id="kobo.6.2">For example, logging will only do the task of logging and nothing else.</span></li>
<li><strong><span class="koboSpan" id="kobo.7.1">Decorator Pattern: </span></strong><span class="koboSpan" id="kobo.8.1">The aspect then attached with the existing functions with the Decorator Pattern.
</span><ul>
<li><strong><span class="koboSpan" id="kobo.9.1">Open Close Principle: </span></strong><span class="koboSpan" id="kobo.10.1">When these repetitive codes were in business functions and we if needed any change in them in the future, then we would have to change the business function as it contains those pieces, which violates the Open Close Principle. </span><span class="koboSpan" id="kobo.10.2">Now, when we isolated those pieces to a module, the business functions became </span><em><span class="koboSpan" id="kobo.11.1">Open</span></em><span class="koboSpan" id="kobo.12.1"> for extension, but </span><em><span class="koboSpan" id="kobo.13.1">Close</span></em><span class="koboSpan" id="kobo.14.1"> to change.</span></li>
</ul>
</li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">Refer to the following diagram for a pictorial explanation:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img height="218" width="412" src="assets/1b1bffb1-1fbd-416e-8c42-fd5c4b1815b5.png"/></span></div>
<div class="packt_infobox"><span class="koboSpan" id="kobo.17.1">AOP is not a competitor of OOP. </span><span class="koboSpan" id="kobo.17.2">Both are totally different. </span><span class="koboSpan" id="kobo.17.3">One is not a replacement for the other. </span><span><span class="koboSpan" id="kobo.18.1">With all these characteristics, AOP helps us to maintain a good structure for the project, hence resulting in a good OOP practice.</span></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advantages</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let me summarise the important advantages of AOP:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Increases modularity:</span></strong><span class="koboSpan" id="kobo.4.1"> Common functionality is centralized into independent modules and is attached those modules or aspects at many places in the app. </span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">Manages Cross-Cutting Concerns:</span></strong><span class="koboSpan" id="kobo.6.1"> The concerns which are scattered comes to one place which can be managed easily without making any code change to the actual business codes.</span></li>
<li><strong><span class="koboSpan" id="kobo.7.1">Better architecture: </span></strong><span class="koboSpan" id="kobo.8.1">Separation of these concerns into singly responsible aspects helps us to architect and organise business needs without unnecessarily repeating ourselves in the codes.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Aspect attached locations</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are basically three locations where an Aspect can be attached to a method:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">On Start:</span></strong><span class="koboSpan" id="kobo.4.1"> When we want an aspect to execute immediately before the underlying function execution.</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">On Error: </span></strong><span class="koboSpan" id="kobo.6.1">Obviously, an aspect at this location will run only if an exception occurs in the method. </span></li>
<li><strong><span class="koboSpan" id="kobo.7.1">On Success:</span></strong><span class="koboSpan" id="kobo.8.1"> Runs immediately after the method execution. </span><span class="koboSpan" id="kobo.8.2">However, it is limited to the functions which don't throw exceptions.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Types of AOP</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are two techniques in AOP:</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.3.1">Interceptors:</span></strong><span class="koboSpan" id="kobo.4.1"> Dynamic, which attaches the interceptors during runtime</span></li>
<li><strong><span class="koboSpan" id="kobo.5.1">IL Code Weaving:</span></strong><span class="koboSpan" id="kobo.6.1"> Static, which runs after compilation and inserts code into the assembly</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">Static (post-compilation) ones </span><span><span class="koboSpan" id="kobo.8.1">include</span></span><span class="koboSpan" id="kobo.9.1"> Fody, SheepAspect, Mono.Cecil, and PostSharp. </span><span class="koboSpan" id="kobo.9.2">S</span><span><span class="koboSpan" id="kobo.10.1">tatic might be faster, but we get more flexibility in a dynamic one, as we can change the code dynamically.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Applying the aspects to the code depends on the framework used. </span><span class="koboSpan" id="kobo.11.2">There are different techniques to attach the aspects such as writing attributes, XML configuration, and fluent interfaces.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Investigating Interception</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To intercept means to prevent something or someone from reaching an </span><span><span class="koboSpan" id="kobo.3.1">intended </span></span><span class="koboSpan" id="kobo.4.1">destination.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Interception </span><span><span class="koboSpan" id="kobo.6.1">(a programming paradigm), helps us to design aspects and inject cross-cutting concerns wherever demanded at the runtime. </span><span class="koboSpan" id="kobo.6.2">Using an</span></span><span class="koboSpan" id="kobo.7.1"> Interceptor, w</span><span><span class="koboSpan" id="kobo.8.1">e can easily intercept the calls to methods and properties in a class. </span><span class="koboSpan" id="kobo.8.2">To achieve this, we usually end up using</span></span><span class="koboSpan" id="kobo.9.1"> an </span><strong><span class="koboSpan" id="kobo.10.1">Inversion Of Control</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong><span class="koboSpan" id="kobo.12.1">IoC</span></strong><span class="koboSpan" id="kobo.13.1">) </span><span><span class="koboSpan" id="kobo.14.1">container.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">IoC provides the class functionality and then wraps it with our requested interceptor. </span><span class="koboSpan" id="kobo.15.2">Suppose somewhere in the code you ask for a class (say </span><kbd><span class="koboSpan" id="kobo.16.1">Student</span></kbd><span class="koboSpan" id="kobo.17.1">) to the IoC container of a specific type (say </span><kbd><span class="koboSpan" id="kobo.18.1">IStudent</span></kbd><span class="koboSpan" id="kobo.19.1">), which has an aspect for logging, then the IoC container would be able to provide the class (</span><kbd><span class="koboSpan" id="kobo.20.1">Student</span></kbd><span class="koboSpan" id="kobo.21.1">) with an interceptor decorated with it for the aspect demanded.</span></p>
<p><span class="koboSpan" id="kobo.22.1">Interceptors are managed by external components that create dynamic decorators dealing with wrapping the aspects around your existing business components.</span></p>
<p><span class="koboSpan" id="kobo.23.1">The main advantage of Interceptors is that they are not bound by the compilation process and don't modify our assemblies post-build. </span><span class="koboSpan" id="kobo.23.2">In other words, it's just the configurations for IoC containers, which you can easily take to another project instead of taking the DLLs and compiling them again.</span></p>
<p><span class="koboSpan" id="kobo.24.1">However, Interceptors are configurable to work either at runtime or compile time.</span></p>
<p><span class="koboSpan" id="kobo.25.1">Unity, Ninject, Spring.NET, Castle Windsor, LinFu, Autofac, LOOM.NET, Seasar, and so on are some IoC containers </span><span><span class="koboSpan" id="kobo.26.1">that allow injecting Interception at compile time or runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">These IoC containers use a Dynamic Proxy to create in-memory decorators that wrap your existing code. </span><span class="koboSpan" id="kobo.27.2">Those Dynamic Proxies are responsible for code execution. </span><span class="koboSpan" id="kobo.27.3">Thus, it allows execution of the wrapper aspect as well as the underlying code being wrapped.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Interception process</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Interception process can be depicted as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="243" width="274" src="assets/8dfd86a3-37b0-4b8c-abab-fd43c45fcb5e.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">Here is what happens:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.5.1">The calling code asks IoC container about the type it is looking for. </span><span class="koboSpan" id="kobo.5.2">For example, the </span><kbd><span class="koboSpan" id="kobo.6.1">IExampleInterface</span></kbd><span class="koboSpan" id="kobo.7.1"> type.</span></li>
<li><span class="koboSpan" id="kobo.8.1">IoC container now tries to match the concrete implementation of the type requested, which it can return back to the calling code that is </span><kbd><span class="koboSpan" id="kobo.9.1">Example</span></kbd><span class="koboSpan" id="kobo.10.1"> class. </span><span class="koboSpan" id="kobo.10.2">While it is doing this, it recognizes that the type is already configured to use an interceptor.</span></li>
<li><span class="koboSpan" id="kobo.11.1">Instead of directly returning to the calling code, the IoC container now sends the Interceptor and the implementation class for the requested type to the Dynamic Proxy.</span></li>
<li><span class="koboSpan" id="kobo.12.1">The Dynamic Proxy now takes the concrete class and wraps it with the interceptor. </span><span class="koboSpan" id="kobo.12.2">Then it generates a class implementing the type initially requested with an instance of the concrete class given by the IoC container and the interceptor. </span><span class="koboSpan" id="kobo.12.3">After that, it returns back that implementation of the requested type to the IoC container. </span><span class="koboSpan" id="kobo.12.4">That is the </span><kbd><span class="koboSpan" id="kobo.13.1">Interceptor</span></kbd><span class="koboSpan" id="kobo.14.1"> class.</span></li>
<li><span class="koboSpan" id="kobo.15.1">The IoC container now sends back the </span><kbd><span class="koboSpan" id="kobo.16.1">Interceptor</span></kbd><span class="koboSpan" id="kobo.17.1"> class generated by Dynamic Proxy to the calling code.</span></li>
<li><span class="koboSpan" id="kobo.18.1">Calling code executes the returned class which in turn runs the interceptor and the underlying code of the concrete class </span><kbd><span class="koboSpan" id="kobo.19.1">Example</span></kbd><span class="koboSpan" id="kobo.20.1">.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Castle Windsor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Castle Windsor is an Inversion of Control Container. </span><span class="koboSpan" id="kobo.2.2">This library is a part of the open source project known as the </span><strong><span class="koboSpan" id="kobo.3.1">Castle Project</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">The Castle Project (</span><a href="http://www.castleproject.org/"><span class="koboSpan" id="kobo.5.1">http://www.castleproject.org/</span></a><span class="koboSpan" id="kobo.6.1">) provides reusable libraries for many purposes. </span><span class="koboSpan" id="kobo.6.2">Castle has many components and Windsor is the DI CONTAINER component of the Castle Project. </span><span class="koboSpan" id="kobo.6.3">However, it can be used independently of other Castle components.</span></p>
<p><span class="koboSpan" id="kobo.7.1">We have many other libraries available on the market such as Microsoft Unity, Autofac, Ninject, and so on. Each framework offers slightly different advantages and features. </span><span class="koboSpan" id="kobo.7.2">However, at the bottom, they implement the same for most of the core concepts, including Type Registration, Resolution, and Injection. </span><span class="koboSpan" id="kobo.7.3">You can, no doubt use any of these to apply Interception in your application.</span></p>
<p><span class="koboSpan" id="kobo.8.1">There is no such logic as to why we are going to use Castle Windsor though. </span><span class="koboSpan" id="kobo.8.2">Using this tool, we can easily attach Interceptors to our codes. </span><span class="koboSpan" id="kobo.8.3">We will see that in a moment.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Demonstration for using the Castle Windsor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's start to implement one Interceptor using the </span><kbd><span class="koboSpan" id="kobo.3.1">Nuget</span></kbd><span class="koboSpan" id="kobo.4.1"> package </span><span class="packt_screen"><span class="koboSpan" id="kobo.5.1">Castle Windsor</span></span><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">First of all, create a Console App, go to </span><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">Nuget Package Manager</span></span><span class="koboSpan" id="kobo.8.1"> and install the </span><span class="packt_screen"><span class="koboSpan" id="kobo.9.1">Castle Windsor</span></span><span><span class="koboSpan" id="kobo.10.1"> package</span></span><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">After successful installation, your </span><span class="packt_screen"><span class="koboSpan" id="kobo.12.1">Project Reference</span></span><span class="koboSpan" id="kobo.13.1"> will look like the following:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="421" width="275" src="assets/bb4c6919-282d-4667-869f-45ff7e086a2f.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">So, it installs </span><kbd><span class="koboSpan" id="kobo.16.1">Castle.Core</span></kbd><span class="koboSpan" id="kobo.17.1"> and </span><kbd><span class="koboSpan" id="kobo.18.1">Castle.Windsor</span></kbd><span class="koboSpan" id="kobo.19.1">. </span><span class="koboSpan" id="kobo.19.2">Now we are ready to create an Interceptor.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating an Interceptor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will do a simple Logging Interceptor which will log steps as well as exceptions for us. </span><span class="koboSpan" id="kobo.2.2">Let's name that </span><kbd><span class="koboSpan" id="kobo.3.1">LoggingInterceptor.cs</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">To qualify as an Interceptor, the class should implement the </span><kbd><span class="koboSpan" id="kobo.5.1">Interceptor</span></kbd><span class="koboSpan" id="kobo.6.1"> interface. </span><span class="koboSpan" id="kobo.6.2">The only method inside this interface is </span><kbd><span class="koboSpan" id="kobo.7.1">Intercept</span></kbd><span class="koboSpan" id="kobo.8.1"> which takes </span><kbd><span class="koboSpan" id="kobo.9.1">IInvocation</span></kbd><span class="koboSpan" id="kobo.10.1"> as an argument.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The following code block illustrates what I said:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">    using Castle.DynamicProxy;
    using System;
    namespace ConsolePacktApp
    {
      public class LoggingInterceptor : IInterceptor
      {
        public void Intercept(IInvocation invocation)
        {
          invocation.Proceed();
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.13.1">The call </span><kbd><span class="koboSpan" id="kobo.14.1">invocation.Proceed()</span></kbd><span class="koboSpan" id="kobo.15.1"> just calls the underlying method which is supposed to be intercepted. </span><span class="koboSpan" id="kobo.15.2">That means, when any method which is registered to use this interceptor, it will come to this method, which in turn, calls the same method from here with the </span><kbd><span class="koboSpan" id="kobo.16.1">Proceed()</span></kbd><span class="koboSpan" id="kobo.17.1">.</span></p>
<p><span class="koboSpan" id="kobo.18.1">To investigate the actual benefit of having an interceptor, we will add more codes here in the following block:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    using Castle.DynamicProxy;
    using System;
    namespace ConsolePacktApp
    {
      public class LoggingInterceptor : IInterceptor
      {
        public void Intercept(IInvocation invocation)
        {
            try
            {
                Console.WriteLine("Log Interceptor Starts");
                invocation.Proceed();
                Console.WriteLine("Log Interceptor Success");
            }
            catch (Exception e)
            {
                Console.WriteLine("Log Interceptor Exception");
                throw;
            }
            finally
            {
                Console.WriteLine("Log Interceptor Exit");
            }
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.20.1">Next is to design an interface and a concrete class:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    using System;</span><br/><span class="koboSpan" id="kobo.22.1">    namespace ConsolePacktApp
    {
      public interface IExample
      {
        void PrintName(string FirstName, string LastName);
      }
    
      public class Example : IExample
      {
        public void PrintName(string FirstName, string LastName)
        {
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.23.1">So, the </span><kbd><span class="koboSpan" id="kobo.24.1">PrintName()</span></kbd><span class="koboSpan" id="kobo.25.1"> method prints the name using </span><kbd><span class="koboSpan" id="kobo.26.1">FirstName</span></kbd><span class="koboSpan" id="kobo.27.1"> and </span><kbd><span class="koboSpan" id="kobo.28.1">LastName</span></kbd><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">We will intercept this method and try to add log steps using an interceptor.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Attaching an Interceptor</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The most important part now is </span><kbd><span class="koboSpan" id="kobo.3.1">ExampleRegistration</span></kbd><span class="koboSpan" id="kobo.4.1">, which implements the interface </span><kbd><span class="koboSpan" id="kobo.5.1">IRegistration</span></kbd><span class="koboSpan" id="kobo.6.1"> of </span><kbd><span class="koboSpan" id="kobo.7.1">Castle.MicroKernel.Registration</span></kbd><span class="koboSpan" id="kobo.8.1"> namespace.</span></p>
<p><span class="koboSpan" id="kobo.9.1">This is the place where we register </span><kbd><span class="koboSpan" id="kobo.10.1">LoggingInterceptor</span></kbd><span class="koboSpan" id="kobo.11.1"> (refer to the first comment in the following code block) and then declare that </span><kbd><span class="koboSpan" id="kobo.12.1">Example</span></kbd><span class="koboSpan" id="kobo.13.1">, class which will be intercepted by </span><kbd><span class="koboSpan" id="kobo.14.1">LoggingInterceptor</span></kbd><span class="koboSpan" id="kobo.15.1"> (refer to the second comment):</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    using Castle.MicroKernel.Registration;
    using Castle.MicroKernel;
    using Castle.Core;
    namespace ConsolePacktApp
    {
      public class ExampleRegistration : </span><strong><span class="koboSpan" id="kobo.17.1">IRegistration</span></strong><span class="koboSpan" id="kobo.18.1">
      {
        public void Register(IKernelInternal kernel)
        {</span><br/>            <strong><span class="koboSpan" id="kobo.19.1">// 1. </span><span class="koboSpan" id="kobo.19.2">Interceptor Registration</span></strong>
            <strong><span class="koboSpan" id="kobo.20.1">kernel.Register(
                Component.For&lt;LoggingInterceptor&gt;()
                    .ImplementedBy&lt;LoggingInterceptor&gt;());</span></strong>
<br/>            <strong><span class="koboSpan" id="kobo.21.1">// 2. </span><span class="koboSpan" id="kobo.21.2">Interceptor attached with Example Class.</span></strong>
            <strong><span class="koboSpan" id="kobo.22.1">kernel.Register(
                Component.For&lt;IExample&gt;()
                .ImplementedBy&lt;Example&gt;()
                .Interceptors(InterceptorReference.ForType&lt;LoggingInterceptor&gt;</span><br/><span class="koboSpan" id="kobo.23.1">                   ()).Anywhere);</span></strong><span class="koboSpan" id="kobo.24.1">
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">Last but not the least, the </span><kbd><span class="koboSpan" id="kobo.26.1">main</span></kbd><span class="koboSpan" id="kobo.27.1"> method:</span></p>
<pre><span class="koboSpan" id="kobo.28.1">    using Castle.Windsor;
    using System;
    namespace ConsolePacktApp
    {
      class Program
      {
        private static IWindsorContainer _container;
        static void Main(string[] args)
        {
            _container = new WindsorContainer();
            _container.Register(new ExampleRegistration());

            var example = _container.Resolve&lt;IExample&gt;();

            try
            {
                example.PrintName("Gobinda", "Dash");   
            }
            catch (Exception ex)
            {
            }

            Console.ReadKey();
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.29.1">We take an </span><kbd><span class="koboSpan" id="kobo.30.1">IWindsorContainer</span></kbd><span class="koboSpan" id="kobo.31.1"> instance. </span><span class="koboSpan" id="kobo.31.2">First, we register our </span><kbd><span class="koboSpan" id="kobo.32.1">ExampleRegistration</span></kbd><span class="koboSpan" id="kobo.33.1"> class which contains our target method and interceptor configurations. </span><span class="koboSpan" id="kobo.33.2">Then, </span><kbd><span class="koboSpan" id="kobo.34.1">_container.Resolve()</span></kbd><span class="koboSpan" id="kobo.35.1"> helps us to get the required instance implementing </span><kbd><span class="koboSpan" id="kobo.36.1">IExample</span></kbd><span class="koboSpan" id="kobo.37.1">.</span></p>
<p><span class="koboSpan" id="kobo.38.1">As we have already defined that </span><kbd><span class="koboSpan" id="kobo.39.1">Example</span></kbd><span class="koboSpan" id="kobo.40.1"> is the class implementing </span><kbd><span class="koboSpan" id="kobo.41.1">IExample</span></kbd><span class="koboSpan" id="kobo.42.1"> in the </span><kbd><span class="koboSpan" id="kobo.43.1">Register()</span></kbd><span class="koboSpan" id="kobo.44.1"> method of the </span><kbd><span class="koboSpan" id="kobo.45.1">ExampleRegistration</span></kbd><span class="koboSpan" id="kobo.46.1"> class, one instance of </span><kbd><span class="koboSpan" id="kobo.47.1">Example</span></kbd><span class="koboSpan" id="kobo.48.1"> class is created. </span><span class="koboSpan" id="kobo.48.2">Then, we have a </span><kbd><span class="koboSpan" id="kobo.49.1">PrintName()</span></kbd><span class="koboSpan" id="kobo.50.1"> call inside the </span><kbd><span class="koboSpan" id="kobo.51.1">try</span></kbd><span class="koboSpan" id="kobo.52.1"> block.</span></p>
<p><span class="koboSpan" id="kobo.53.1">Time to run the app and see the output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img height="100" width="303" src="assets/6d2113fb-eda5-4e43-ac81-c3c26325555b.png"/></span></div>
<p><span class="koboSpan" id="kobo.55.1">Clearly, before printing the name, the first thing that executes is the log </span><span class="packt_screen"><span class="koboSpan" id="kobo.56.1">Starts</span></span><span class="koboSpan" id="kobo.57.1"> message. </span><span class="koboSpan" id="kobo.57.2">Secondly, the actual method execution which prints the name. </span><span class="koboSpan" id="kobo.57.3">After that, as we expected, the </span><span class="packt_screen"><span class="koboSpan" id="kobo.58.1">Success</span></span><span class="koboSpan" id="kobo.59.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.60.1">Exit</span></span><span class="koboSpan" id="kobo.61.1"> messages. </span><span class="packt_screen"><span class="koboSpan" id="kobo.62.1">Exit</span></span><span class="koboSpan" id="kobo.63.1"> means it exited from the interceptor.</span></p>
<p><span class="koboSpan" id="kobo.64.1">Obviously, we did not get any exception, so that message got skipped.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Now, let's try to see that. </span><span class="koboSpan" id="kobo.65.2">The modified </span><kbd><span class="koboSpan" id="kobo.66.1">Example</span></kbd><span class="koboSpan" id="kobo.67.1"> class will be like the following with a </span><kbd><span class="koboSpan" id="kobo.68.1">throw new Exception()</span></kbd><span class="koboSpan" id="kobo.69.1"> code line:</span></p>
<pre><span class="koboSpan" id="kobo.70.1">    using System;
    namespace ConsolePacktApp
    {
      public class Example : IExample
      {
        public void PrintName(string FirstName, string LastName)
        {
            </span><strong><span class="koboSpan" id="kobo.71.1">throw new Exception();</span></strong><span class="koboSpan" id="kobo.72.1">
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.73.1">Forcefully, we are throwing one exception before the </span><kbd><span class="koboSpan" id="kobo.74.1">Console.WriteLine</span></kbd><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">We will see the following output when we run this:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.76.1"><img height="85" width="279" src="assets/5317171d-e369-4988-a854-624bf766e51a.png"/></span></div>
<p><span class="koboSpan" id="kobo.77.1">Interestingly, we don't see the </span><span class="packt_screen"><span class="koboSpan" id="kobo.78.1">Success</span></span><span class="koboSpan" id="kobo.79.1"> log message, but the </span><span class="packt_screen"><span class="koboSpan" id="kobo.80.1">Exit</span></span><span class="koboSpan" id="kobo.81.1"> message is printed and the actual execution of the method which was printing the name did not happen either. </span><span class="koboSpan" id="kobo.81.2">That is because the </span><span class="packt_screen"><span class="koboSpan" id="kobo.82.1">Exit</span></span><span class="koboSpan" id="kobo.83.1"> message will definitely get printed no matter what happens to the calling code as that is inside the </span><kbd><span class="koboSpan" id="kobo.84.1">finally</span></kbd><span class="koboSpan" id="kobo.85.1"> block of the interceptor.</span></p>
<p><span class="koboSpan" id="kobo.86.1">We manually threw an exception before the actual code execution to print the name, which resulted in printing the exception log message along with </span><span class="packt_screen"><span class="koboSpan" id="kobo.87.1">Start</span></span><span class="koboSpan" id="kobo.88.1"> and </span><span class="packt_screen"><span class="koboSpan" id="kobo.89.1">Exit</span></span><span class="koboSpan" id="kobo.90.1">.</span></p>
<div class="packt_infobox">
<p><span class="koboSpan" id="kobo.91.1">Multiple Interceptors can be attached to a single class. </span><span class="koboSpan" id="kobo.91.2">There are two types of interceptor registrations, coded as follows. </span><span class="koboSpan" id="kobo.91.3">You can use either the following:</span></p>
<kbd><span class="koboSpan" id="kobo.92.1">     kernel.Register(</span><br/><span class="koboSpan" id="kobo.93.1">
       Component.For()</span><br/><span class="koboSpan" id="kobo.94.1">
      .ImplementedBy()</span><br/><span class="koboSpan" id="kobo.95.1">
      .Interceptors&lt;LoggingInterceptor,</span><br/><span class="koboSpan" id="kobo.96.1">
          AnotherInterceptor&gt;());</span></kbd>
<p><span class="koboSpan" id="kobo.97.1">Or you can use this one:</span></p>
<kbd><span class="koboSpan" id="kobo.98.1">    kernel.Register(</span><br/><span class="koboSpan" id="kobo.99.1">
     Component.For&lt;IExample&gt;()</span><br/><span class="koboSpan" id="kobo.100.1">
     .ImplementedBy&lt;Example&gt;()</span><br/><span class="koboSpan" id="kobo.101.1">
     .Interceptors(new InterceptorReference[] {</span><br/><span class="koboSpan" id="kobo.102.1">
     InterceptorReference.ForType&lt;LoggingInterceptor&gt;(),</span><br/><span class="koboSpan" id="kobo.103.1">
     InterceptorReference.ForType&lt;AnotherInterceptor&gt;() }).Anywhere);</span></kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Intermediate Language (IL) Weaving</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this type of AOP, the aspects are attached to the underlying code after the application has been compiled. </span><span class="koboSpan" id="kobo.2.2">This post-compilation process alters the assemblies at the IL level so that the aspect hook points are called where they are configured.</span></p>
<p><span class="koboSpan" id="kobo.3.1">If I explain in simple words, it is a process by which the aspect codes are interjected into the original code after compilation, but that happens only to the IL code (original source code remains intact) and packaged into the assemblies. </span><span class="koboSpan" id="kobo.3.2">Your original code will be intact. </span><span class="koboSpan" id="kobo.3.3">However, along with your code, the aspect blocks will be included and the assembly gets the modified code. </span><span class="koboSpan" id="kobo.3.4">Unlike Interception, where the codes are interjected at the runtime, this process is static and codes are included beforehand.</span></p>
<p><span class="koboSpan" id="kobo.4.1">The most widely used tool for weaving is PostSharp, which we will demo in a while. </span><span class="koboSpan" id="kobo.4.2">Others include LOOM.NET, Fody, SheepAspect, Mono.Cecil, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">IL Weaving process</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Since I explained the process, let's see that in action in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="320" width="292" src="assets/3600f40b-ce25-455e-9e7a-3c1e55138211.png"/></span></div>
<p><span class="koboSpan" id="kobo.4.1">Simple, isn't it! </span><span class="koboSpan" id="kobo.4.2">Now that we understand how the process goes along, it's time to get our hands dirty on some real code and try it out.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating an aspect</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before starting up, we need to add the </span><kbd><span class="koboSpan" id="kobo.3.1">Nuget</span></kbd><span class="koboSpan" id="kobo.4.1"> package named as PostSharp to the project.</span></p>
<p><span class="koboSpan" id="kobo.5.1">To create an aspect, we need to design the class which would inherit from the </span><kbd><span class="koboSpan" id="kobo.6.1">OnMethodBoundaryAspect</span></kbd><span class="koboSpan" id="kobo.7.1"> aspect class, which is an abstract class inside the </span><kbd><span class="koboSpan" id="kobo.8.1">PostSharp.Aspects</span></kbd><span class="koboSpan" id="kobo.9.1"> namespace. </span><span class="koboSpan" id="kobo.9.2">This can be seen in the following code block:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    using PostSharp.Aspects;
    using System;
    namespace ConsolePacktApp
    {
      [Serializable]
      class LoggingWeaverAspect : OnMethodBoundaryAspect
      {
        public override void OnEntry(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnEntry");
        }

        public override void OnExit(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnExit");
        }

        public override void OnException(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnException");
        }

        public override void OnSuccess(MethodExecutionArgs args)
        {
            Console.WriteLine("Inside OnSuccess");
        }
      }
    }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.11.1">OnMethodBoundaryAspect</span></kbd><span class="koboSpan" id="kobo.12.1"> helps to write code which can execute before or after a method execution or in the case of an exception. </span><span class="koboSpan" id="kobo.12.2">As you can see from the previous class, we are overriding the </span><kbd><span class="koboSpan" id="kobo.13.1">OnEntry</span></kbd><span class="koboSpan" id="kobo.14.1">, </span><kbd><span class="koboSpan" id="kobo.15.1">OnExit</span></kbd><span class="koboSpan" id="kobo.16.1">, </span><kbd><span class="koboSpan" id="kobo.17.1">OnException</span></kbd><span class="koboSpan" id="kobo.18.1"> and </span><kbd><span class="koboSpan" id="kobo.19.1">OnSucess</span></kbd><span class="koboSpan" id="kobo.20.1"> methods. </span><span class="koboSpan" id="kobo.20.2">There are other aspect classes which can solve the different purposes.</span></p>
<p><span class="koboSpan" id="kobo.21.1">Update the </span><kbd><span class="koboSpan" id="kobo.22.1">main</span></kbd><span class="koboSpan" id="kobo.23.1"> method as follows:</span></p>
<pre><span class="koboSpan" id="kobo.24.1">    static void Main(string[] args)
    {
      try
      {
        Example example = new Example();
        example.PrintName("Gobinda", "Dash");
      }
      catch
      {
      }
      Console.ReadKey();
    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">Now, when you run the app, nothing happens. </span><span class="koboSpan" id="kobo.25.2">We get a confirmation if we can see the generated assembly codes.</span></p>
<div class="packt_infobox">
<p><span class="koboSpan" id="kobo.26.1">ILSpy is the open-source .NET assembly browser and decompiler. You can download it from </span><a href="http://ilspy.net/"><span class="koboSpan" id="kobo.27.1">http://ilspy.net/</span></a><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">This will help us see the actual codes packaged inside the assemblies.</span></p>
</div>
<p><span class="koboSpan" id="kobo.29.1">When you run the ILSpy </span><span><span class="koboSpan" id="kobo.30.1">application and then select the assembly of our app, it will look something like the following:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img src="assets/c9afb9af-a342-460e-a017-2037ad8ce301.png"/></span></div>
<p><span class="koboSpan" id="kobo.32.1">You can see the </span><kbd><span class="koboSpan" id="kobo.33.1">Example</span></kbd><span class="koboSpan" id="kobo.34.1"> class has code intact. </span><span class="koboSpan" id="kobo.34.2">No other code got inserted into the assembly. </span><span><span class="koboSpan" id="kobo.35.1">That's because we have not yet attached the</span></span><span class="koboSpan" id="kobo.36.1"> Weaver w</span><span><span class="koboSpan" id="kobo.37.1">ith our </span><kbd><span class="koboSpan" id="kobo.38.1">Example</span></kbd><span class="koboSpan" id="kobo.39.1"> class. </span><span class="koboSpan" id="kobo.39.2">Let's do that next.</span></span></p>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.40.1">If you encounter a PostSharp license error while building the app, that means you have to purchase one license. </span><span class="koboSpan" id="kobo.40.2">You can also use the free license, which has certain limitations. </span><span class="koboSpan" id="kobo.40.3">You can find the download page at </span><a href="https://www.postsharp.net/essentials"><span class="koboSpan" id="kobo.41.1">https://www.postsharp.net/essentials</span></a><span class="koboSpan" id="kobo.42.1">.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Attaching the aspect</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Attaching the aspect is very easy. </span><span class="koboSpan" id="kobo.2.2">You can simply add the weaver as an attribute to the classes you want to wrap the aspect to.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Notice the bold line above the </span><kbd><span class="koboSpan" id="kobo.4.1">PrintName</span></kbd><span class="koboSpan" id="kobo.5.1"> method in the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    using System;
    namespace ConsolePacktApp
    {
      public class Example : IExample
      {
        </span><strong><span class="koboSpan" id="kobo.7.1">[LoggingWeaverAspect]</span></strong><span class="koboSpan" id="kobo.8.1">
        public void PrintName(string FirstName, string LastName)
        {
            Console.WriteLine($"Name is {FirstName} {LastName}");
        }
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.9.1">We attributed the </span><kbd><span class="koboSpan" id="kobo.10.1">[LoggingWeaverAspect]</span></kbd><span class="koboSpan" id="kobo.11.1"> around the </span><kbd><span class="koboSpan" id="kobo.12.1">Example</span></kbd><span class="koboSpan" id="kobo.13.1"> class. </span><span class="koboSpan" id="kobo.13.2">Now, let's run it and see the output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="133" width="305" src="assets/14e6bbc1-bd8f-4254-baa1-d27cc33bd5ff.png"/></span></div>
<p><span class="koboSpan" id="kobo.15.1">Have a look at the assembly code as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img src="assets/02849973-1275-4e45-9366-8391ef64d4da.png"/></span></div>
<p><span class="koboSpan" id="kobo.17.1">The red boxes here indicate the code which was inserted</span><span><span class="koboSpan" id="kobo.18.1"> into the assembly</span></span><span class="koboSpan" id="kobo.19.1"> after you built the application. </span><span class="koboSpan" id="kobo.19.2">Since we had one </span><kbd><span class="koboSpan" id="kobo.20.1">OnException</span></kbd><span class="koboSpan" id="kobo.21.1"> in the weaver aspect, </span><span><span class="koboSpan" id="kobo.22.1">the </span></span><kbd><span class="koboSpan" id="kobo.23.1">PrintName()</span></kbd><span><span class="koboSpan" id="kobo.24.1"> method now contains a </span></span><kbd><span class="koboSpan" id="kobo.25.1">try...catch</span></kbd><span class="koboSpan" id="kobo.26.1"> </span><span><span class="koboSpan" id="kobo.27.1">block. </span><span class="koboSpan" id="kobo.27.2">Finally, </span></span><kbd><span class="koboSpan" id="kobo.28.1">OnEntry</span></kbd><span class="koboSpan" id="kobo.29.1"> is at the beginning and </span><kbd><span class="koboSpan" id="kobo.30.1">OnExit</span></kbd><span class="koboSpan" id="kobo.31.1"> is inside. </span><span class="koboSpan" id="kobo.31.2">After the </span><kbd><span class="koboSpan" id="kobo.32.1">Console.Writeline()</span></kbd><span class="koboSpan" id="kobo.33.1">, we can see the </span><kbd><span class="koboSpan" id="kobo.34.1">OnSuccess</span></kbd><span class="koboSpan" id="kobo.35.1"> call. </span></p>
<p><span class="koboSpan" id="kobo.36.1">If we get an exception before the actual execution of the method (before </span><kbd><span class="koboSpan" id="kobo.37.1">Console.WriteLine()</span></kbd><span class="koboSpan" id="kobo.38.1"> in this case), we will see the following output without the </span><span class="packt_screen"><span class="koboSpan" id="kobo.39.1">success</span></span><span class="koboSpan" id="kobo.40.1"> message:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.41.1"><img height="131" width="286" src="assets/e1e66995-aca1-4118-b724-0d483ae8322e.png"/></span></div>
<p><span class="koboSpan" id="kobo.42.1">Now that we've had a sneak peek at the concepts, let's explore how Interception is implemented in .NET Core.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Interception in ASP.NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">ASP.NET Core implements the concept of Interception to interrupt the calls to controller actions and request-response pipeline. </span><span class="koboSpan" id="kobo.2.2">We can do this by different techniques known as filters and middleware. </span><span class="koboSpan" id="kobo.2.3">We will discuss each one with examples next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Filters</span></h1>
                </header>
            
            <article>
                
<p><span><span class="koboSpan" id="kobo.2.1">Filters allow ASP.NET Core to intercept action methods. </span><span class="koboSpan" id="kobo.2.2">You can configure one global filter which would run every time one controller action is requested, or have individual unique filters for some action methods.</span></span></p>
<p><span class="koboSpan" id="kobo.3.1">The filters would implement one of the filter interface residing in the </span><kbd><span class="koboSpan" id="kobo.4.1">Microsoft.AspNet.Mvc.Filters</span></kbd><span class="koboSpan" id="kobo.5.1"> namespace. </span><span class="koboSpan" id="kobo.5.2">Let's see a simple filter skeleton as follows:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">    using Microsoft.AspNetCore.Mvc.Filters;</span><br/><span class="koboSpan" id="kobo.7.1">    namespace FiltersAndMiddlewares.Filters</span><br/><span class="koboSpan" id="kobo.8.1">    {</span><br/><span class="koboSpan" id="kobo.9.1">      public class SomeFilter : IActionFilter</span><br/><span class="koboSpan" id="kobo.10.1">      {</span><br/><span class="koboSpan" id="kobo.11.1">        public void OnActionExecuted(ActionExecutedContext context)</span><br/><span class="koboSpan" id="kobo.12.1">        {</span><br/><span class="koboSpan" id="kobo.13.1">          // Do something.</span><br/><span class="koboSpan" id="kobo.14.1">        }</span><br/><br/><span class="koboSpan" id="kobo.15.1">        public void OnActionExecuting(ActionExecutingContext context)</span><br/><span class="koboSpan" id="kobo.16.1">        {</span><br/><span class="koboSpan" id="kobo.17.1">          // Do something.</span><br/><span class="koboSpan" id="kobo.18.1">        }</span><br/><span class="koboSpan" id="kobo.19.1">      }</span><br/><span class="koboSpan" id="kobo.20.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">As you can see in the preceding example, </span><kbd><span class="koboSpan" id="kobo.22.1">SomeFilter</span></kbd><span class="koboSpan" id="kobo.23.1"> implements </span><kbd><span class="koboSpan" id="kobo.24.1">IActionFilter</span></kbd><span class="koboSpan" id="kobo.25.1">. </span><span class="koboSpan" id="kobo.25.2"> </span><span><kbd><span class="koboSpan" id="kobo.26.1">OnActionExecuting</span></kbd><span class="koboSpan" id="kobo.27.1"> and  </span></span><kbd><span class="koboSpan" id="kobo.28.1">OnActionExecuted</span></kbd><span class="koboSpan" id="kobo.29.1">, as the names suggest, would run when an action is being executed and completes execution respectively.</span></p>
<p><span class="koboSpan" id="kobo.30.1">If you recall the principle of Interception (which says that the </span><em><span class="koboSpan" id="kobo.31.1">process by which we can run some code before or after the method which is being executed or totally replace that</span></em><span class="koboSpan" id="kobo.32.1">), you will notice that these </span><kbd><span class="koboSpan" id="kobo.33.1">IActionFilter</span></kbd><span class="koboSpan" id="kobo.34.1"> methods also follow the principle and are intended to intercept the calls to a controller action method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Global filter</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Suppose you want to create an interceptor which would intercept all the action methods. </span><span class="koboSpan" id="kobo.2.2">Sounds like a common or globally declared code block that can be termed as a </span><strong><span class="koboSpan" id="kobo.3.1">Global filter</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Registering a filter to the MVC filters using the service collection inside </span><kbd><span class="koboSpan" id="kobo.5.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.6.1"> would make a filter globally executable or interceptable.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Refer to the following code, which is the only line to convert a normal filter to a Global filter except the definition of the filter, which of course you need to code:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">    services.AddMvc(mvc =&gt; mvc.Filters.AddService(</span><br/><span class="koboSpan" id="kobo.9.1">        typeof(SomeGlobalFilter)));</span></pre>
<p><kbd><span class="koboSpan" id="kobo.10.1">SomeGlobalFilter</span></kbd><span class="koboSpan" id="kobo.11.1"> can also be injected with dependencies. </span><span class="koboSpan" id="kobo.11.2">The following code block can be considered as a Global filter, where </span><kbd><span class="koboSpan" id="kobo.12.1">ISomeService</span></kbd><span class="koboSpan" id="kobo.13.1"> is injected using the most popular Constructor Injection Pattern:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    using FiltersAndMiddlewares.Interfaces;</span><br/><span class="koboSpan" id="kobo.15.1">    using Microsoft.AspNetCore.Mvc.Filters;</span><br/><span class="koboSpan" id="kobo.16.1">    namespace FiltersAndMiddlewares.Filters</span><br/><span class="koboSpan" id="kobo.17.1">    {</span><br/><span class="koboSpan" id="kobo.18.1">      public class SomeGlobalFilter : IActionFilter</span><br/><span class="koboSpan" id="kobo.19.1">      {</span><br/><strong><span class="koboSpan" id="kobo.20.1">        public SomeGlobalFilter(ISomeService service)</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">        {</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">            // Do something with the service.</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">        }</span></strong><br/><br/><span class="koboSpan" id="kobo.24.1">        public void OnActionExecuted(ActionExecutedContext context)</span><br/><span class="koboSpan" id="kobo.25.1">        {</span><br/><span class="koboSpan" id="kobo.26.1">            // Do something.</span><br/><span class="koboSpan" id="kobo.27.1">        }</span><br/><br/><span class="koboSpan" id="kobo.28.1">        public void OnActionExecuting(ActionExecutingContext context)</span><br/><span class="koboSpan" id="kobo.29.1">        {</span><br/><span class="koboSpan" id="kobo.30.1">            // Do something.</span><br/><span class="koboSpan" id="kobo.31.1">        }</span><br/><span class="koboSpan" id="kobo.32.1">      }</span><br/><span class="koboSpan" id="kobo.33.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.34.1">Did you notice one thing? </span><span class="koboSpan" id="kobo.34.2">The parameterized constructor in </span><kbd><span class="koboSpan" id="kobo.35.1">SomeGlobalFilter</span></kbd><span class="koboSpan" id="kobo.36.1"> is injected with the dependency of type </span><kbd><span class="koboSpan" id="kobo.37.1">ISomeService</span></kbd><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">Not optional though, but it can be done if we need any of the required dependency in filters. </span><span class="koboSpan" id="kobo.38.3">Imagine, if we need to add a log entry in the database whenever an action starts execution, something like a bookkeeping of what events occur in what sequence. </span><span class="koboSpan" id="kobo.38.4">To achieve this, we can inject a service and then use its methods to operate on the database.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Attributes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Another way to attach filters is to write attributes for required actions. </span><span class="koboSpan" id="kobo.2.2">When you do global, it applies to all the actions. </span><span class="koboSpan" id="kobo.2.3">However, if we want to attach to certain actions only, then we can write attributes. </span><span class="koboSpan" id="kobo.2.4">Let's take a look at an action method which is attributed with </span><kbd><span class="koboSpan" id="kobo.3.1">SomeFilter</span></kbd><span class="koboSpan" id="kobo.4.1">:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="154" width="493" src="assets/e7f41471-53db-4914-bf27-962f70922f23.png"/></span></div>
<p><span class="koboSpan" id="kobo.6.1">The compiler is complaining. </span><span class="koboSpan" id="kobo.6.2">If you hover, it will say </span><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">SomeFilter is not an attribute class</span></span><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">It actually expects the </span><kbd><span class="koboSpan" id="kobo.9.1">SomeFilter</span></kbd><span class="koboSpan" id="kobo.10.1"> like as follows:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    public class SomeFilterAttribute : </span><strong><span class="koboSpan" id="kobo.12.1">Attribute</span></strong><span class="koboSpan" id="kobo.13.1"> {}</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Notice the name of the filter which was changed to </span><kbd><span class="koboSpan" id="kobo.15.1">SomeFilterAttribute</span></kbd><span class="koboSpan" id="kobo.16.1"> and derived from </span><kbd><span class="koboSpan" id="kobo.17.1">Attribute</span></kbd><span class="koboSpan" id="kobo.18.1"> abstract class. </span><span class="koboSpan" id="kobo.18.2">This is by syntax. </span><span class="koboSpan" id="kobo.18.3">Also, attributes require parameterless constructors. </span><span class="koboSpan" id="kobo.18.4">But to intercept, we need to implement some filter interface like </span><kbd><span class="koboSpan" id="kobo.19.1">IActionFilter</span></kbd><span class="koboSpan" id="kobo.20.1">. </span></p>
<p><span class="koboSpan" id="kobo.21.1">To overcome this, we can take the help of the  </span><kbd><span class="koboSpan" id="kobo.22.1">TypeFilterAttribute</span></kbd><span class="koboSpan" id="kobo.23.1"> class which derives from the </span><kbd><span class="koboSpan" id="kobo.24.1">Attribute</span></kbd><span class="koboSpan" id="kobo.25.1"> class and takes a type through its constructor. </span><span class="koboSpan" id="kobo.25.2">Thus, the following code shows the correct pattern to use a filter as an attribute:</span></p>
<pre><strong><span class="koboSpan" id="kobo.26.1">    [TypeFilter(typeof (SomeFilter))]</span></strong><br/><span class="koboSpan" id="kobo.27.1">    public IActionResult About()</span><br/><span class="koboSpan" id="kobo.28.1">    {</span><br/><span class="koboSpan" id="kobo.29.1">      ViewData["Message"] = "Your application description page.";</span><br/><span class="koboSpan" id="kobo.30.1">      return View();</span><br/><span class="koboSpan" id="kobo.31.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.32.1">A couple of important things to note here are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.33.1">We have not registered </span><kbd><span class="koboSpan" id="kobo.34.1">SomeFilter</span></kbd><span class="koboSpan" id="kobo.35.1"> in the entry point of the app; still, it works</span></li>
<li><span class="koboSpan" id="kobo.36.1">The </span><kbd><span class="koboSpan" id="kobo.37.1">TypeFilter</span></kbd><span class="koboSpan" id="kobo.38.1"> attribute helps to create an instance of </span><kbd><span class="koboSpan" id="kobo.39.1">SomeFilter</span></kbd></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">As we are playing with .NET Core, we should get the filter instance from the service registrations, instead of creating it dynamically through </span><kbd><span class="koboSpan" id="kobo.41.1">TypeFilter</span></kbd><span class="koboSpan" id="kobo.42.1">. </span><span class="koboSpan" id="kobo.42.2">That is where the </span><kbd><span class="koboSpan" id="kobo.43.1">ServiceFilterAttribute</span></kbd><span class="koboSpan" id="kobo.44.1"> class comes onto the scene. </span><span class="koboSpan" id="kobo.44.2">Let's see how we can modify the code to use </span><kbd><span class="koboSpan" id="kobo.45.1">ServiceFilter</span></kbd><span class="koboSpan" id="kobo.46.1">:</span></p>
<pre><strong><span class="koboSpan" id="kobo.47.1">    [ServiceFilter(typeof (SomeFilter))]</span></strong><br/><span class="koboSpan" id="kobo.48.1">    public IActionResult About()</span><br/><span class="koboSpan" id="kobo.49.1">    {</span><br/><span class="koboSpan" id="kobo.50.1">      ViewData["Message"] = "Your application description page.";</span><br/><span class="koboSpan" id="kobo.51.1">      return View();</span><br/><span class="koboSpan" id="kobo.52.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.53.1">Are you sure this change will work? </span><span class="koboSpan" id="kobo.53.2">No, it won't. </span><span class="koboSpan" id="kobo.53.3">When you run the app, you will see the error captured as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.54.1"><img height="62" width="740" src="assets/c9824fd1-d0dc-45fd-8f93-65851f826231.png"/></span></div>
<p><span class="koboSpan" id="kobo.55.1">Ah, I know! </span><span class="koboSpan" id="kobo.55.2">Now you got what we missed. </span><span class="koboSpan" id="kobo.55.3">This is a very familiar exception when you are working with DI. </span><span class="koboSpan" id="kobo.55.4">As I said, </span><kbd><span class="koboSpan" id="kobo.56.1">ServiceFilter</span></kbd><span class="koboSpan" id="kobo.57.1"> finds the filter instance from the service collection; if you don't register it, it will definitely throw an exception.</span></p>
<p><span class="koboSpan" id="kobo.58.1">The following code is what you need to make it work. </span><span class="koboSpan" id="kobo.58.2">It is not mandatory to make it transient though, it depends on your scenario:</span></p>
<pre><span class="koboSpan" id="kobo.59.1">    services.AddTransient&lt;SomeFilter&gt;();</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Middleware</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Middleware, what it is known for, intercepts the pipeline of execution, and the developer can do anything before the response is served to the client. </span><span class="koboSpan" id="kobo.2.2">We will see how exactly we can implement Middlewares to intercept in the next section.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Middleware in ASP.NET core follows the Interception technique to interject aspects between request and response. </span><span class="koboSpan" id="kobo.3.2">It's basically some block of code which is registered with the application pipeline. </span><span class="koboSpan" id="kobo.3.3">The following diagram shows how </span><span class="packt_screen"><span class="koboSpan" id="kobo.4.1">Request</span></span><span class="koboSpan" id="kobo.5.1"> goes through </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Middleware</span></span><span class="packt_screen"><span class="koboSpan" id="kobo.7.1">s</span></span><span class="koboSpan" id="kobo.8.1"> one by one before </span><span class="packt_screen"><span class="koboSpan" id="kobo.9.1">Response</span></span><span class="koboSpan" id="kobo.10.1"> comes out:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.11.1"><img height="333" width="461" src="assets/933025b8-e773-4af0-9cbf-f34f38b955cb.png"/></span></div>
<p><span><span class="koboSpan" id="kobo.12.1">A large</span></span><span class="koboSpan" id="kobo.13.1"> amount of Middleware can be inserted into the pipeline. </span><span class="koboSpan" id="kobo.13.2">Each Middleware decides whether to pass the execution to the next one and can perform some logic before and after the invocation of the next component. </span><span class="koboSpan" id="kobo.13.3">These components are designed to solve specific purposes like logging, exception handling, authorizing, and so on.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Registration</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.4.1"> interface helps us register the Middleware using the </span><kbd><span class="koboSpan" id="kobo.5.1">app.Use</span></kbd><span class="koboSpan" id="kobo.6.1"> inside the </span><kbd><span class="koboSpan" id="kobo.7.1">Configure()</span></kbd><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Let's check a simple code block:</span></p>
<pre><span class="koboSpan" id="kobo.9.1">    public void Configure(IApplicationBuilder app)
    {
      var response = string.Empty;
      app.Use(async (context, next) =&gt;
      {
        response += "Inside Middleware 1\n";
        await next.Invoke();
      });
       app.Use(async (context, next) =&gt;
       {
        response += "Inside Middleware 2\n";
        await next.Invoke();
       });
       app.Run(async context =&gt;
       {
         response += "App run\n";
         await context.Response.WriteAsync(response);
       });
    }</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Execution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have two Middlewares and then </span><kbd><span class="koboSpan" id="kobo.3.1">app.Run</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">When we run this, we will see the following one:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="191" width="438" src="assets/b6ccb1b3-9b7d-4664-9e8d-964b2ce97a62.png"/></span></div>
<p class="mce-root CDPAlignLeft CDPAlign"><span class="koboSpan" id="kobo.6.1">There is a catch here. </span><span class="koboSpan" id="kobo.6.2">If you refresh the page, without building the code, the following is what you see next:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="187" width="412" src="assets/ce483d01-0a7a-4828-a190-ce4deb8b1637.png"/></span></div>
<p><span class="koboSpan" id="kobo.8.1">The reason is I have concatenated the string and when you refresh the page, it directly comes to the </span><span class="packt_screen"><span class="koboSpan" id="kobo.9.1">Middleware 1</span></span><span class="koboSpan" id="kobo.10.1"> followed by </span><span class="packt_screen"><span class="koboSpan" id="kobo.11.1">Middleware 2</span></span><span class="koboSpan" id="kobo.12.1"> and then </span><kbd><span class="koboSpan" id="kobo.13.1">app.Run</span></kbd><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">As the variable got initialised inside the </span><kbd><span class="koboSpan" id="kobo.15.1">Configure</span></kbd><span class="koboSpan" id="kobo.16.1">, it has an application scope. </span><span class="koboSpan" id="kobo.16.2">It will be appended henceforth. </span><span class="koboSpan" id="kobo.16.3">If you refresh the page again, you will see another set of the same messages getting appended to what you see in the preceding screenshot.</span></p>
<p><span class="koboSpan" id="kobo.17.1">This is the way Middlewares hijack the application pipeline and execute before the response is delivered to the client. </span><span class="koboSpan" id="kobo.17.2">Let's consider another code block:</span></p>
<pre><span class="koboSpan" id="kobo.18.1">    public void Configure(IApplicationBuilder app, IHostingEnvironment env, </span><br/><span class="koboSpan" id="kobo.19.1">       ILoggerFactory loggerFactory)
    {
     var response = string.Empty;
     app.Use(async (context, next) =&gt;
     {
        response += "Inside Middleware 1\n";
        await next.Invoke();
     });
     app.Run(async context =&gt;
     {
        response += "App run\n";
        await context.Response.WriteAsync(response);
     });
     app.Use(async (context, next) =&gt;
     {
        response += "Inside Middleware 2\n";
        await next.Invoke();
     });
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.20.1">What do you think the output will be? </span><span class="koboSpan" id="kobo.20.2">Check it out:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img height="201" width="445" src="assets/276333d2-1a54-42ed-89b6-7feaf2824c53.png"/></span></div>
<p><span class="packt_screen"><span class="koboSpan" id="kobo.22.1">Middleware 2</span></span><span class="koboSpan" id="kobo.23.1"> got missed. </span><span class="koboSpan" id="kobo.23.2">That is because we wrote </span><kbd><span class="koboSpan" id="kobo.24.1">app.Run</span></kbd><span class="koboSpan" id="kobo.25.1"> before </span><span class="packt_screen"><span class="koboSpan" id="kobo.26.1">Middleware 2</span></span><span class="koboSpan" id="kobo.27.1">. </span><kbd><span class="koboSpan" id="kobo.28.1">app.Run</span></kbd><span class="koboSpan" id="kobo.29.1"> is the exit point which terminates the pipeline. </span><span class="koboSpan" id="kobo.29.2">Anything after that won't be considered by the runtime.</span></p>
<div class="packt_infobox">
<p><span class="koboSpan" id="kobo.30.1">You can, definitely, code before and after invoke is called, as follows:</span></p>
<kbd><span class="koboSpan" id="kobo.31.1">   app.Use(async (context, next) =&gt;</span><br/><span class="koboSpan" id="kobo.32.1">
    {</span><br/><span class="koboSpan" id="kobo.33.1">
    // Do something before the next middleware is</span><br/><span class="koboSpan" id="kobo.34.1">
        invoked.</span><br/><span class="koboSpan" id="kobo.35.1">
         await next.Invoke();</span><br/><span class="koboSpan" id="kobo.36.1">
    // Do something after next middleware invocation.</span><br/><span class="koboSpan" id="kobo.37.1">
   });</span></kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Ordering</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There is a simple rule that the order in which they are registered is the order in which they will be executed. </span><span class="koboSpan" id="kobo.2.2">The ordering plays an important role while one component depends on another. </span><span class="koboSpan" id="kobo.2.3">The exception is something which may occur anytime, anywhere, within the app. </span><span class="koboSpan" id="kobo.2.4">So, we need to register it first before everything else, so that we can easily capture the exceptions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We explored what aspects are and how to determine Cross-Cutting Concerns in a typical programming scenario. </span><span class="koboSpan" id="kobo.2.2">There are specific locations where aspects can be tagged, which we illustrated next.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Aspect-oriented programming helps us to run custom logic before, after, or even replacing the method completely, where it is registered. </span><span class="koboSpan" id="kobo.3.2">We saw static as well as dynamic techniques to attach aspects with IL Weaving and Interceptors respectively. </span><span class="koboSpan" id="kobo.3.3">Interception is the technique which is more preferred over IL Weaving as it dynamically runs the registered block of code (otherwise called an aspect). </span><span class="koboSpan" id="kobo.3.4">On the other hand, IL Weaving deals with assembly update after the build process is over to insert aspect codes into the methods registered.</span></p>
<p><span class="koboSpan" id="kobo.4.1">We then got into a thorough discussion on how Interception is adopted in ASP.NET Core in the form of filters and Middlewares.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Filters can intercept the path of action method execution, which can be either be attributed to the method as required, or can be registered with service collection to label it as a Global filter. </span><span class="koboSpan" id="kobo.5.2"> One line of registration of a filter can make the filter intercept all action methods easily.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Middleware is a technique in ASP.NET Core which allows us to insert built-in/custom code chunks into the request-response pipeline.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Now that we have learned all the fundamental concepts of DI, in </span><a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank"><span class="koboSpan" id="kobo.8.1">Chapter 8</span></a><span class="koboSpan" id="kobo.9.1">, </span><em><span class="koboSpan" id="kobo.10.1">Patterns - Dependency Injection</span></em><span class="koboSpan" id="kobo.11.1">, we are going to discover different techniques/patterns to inject dependencies into the clients.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>