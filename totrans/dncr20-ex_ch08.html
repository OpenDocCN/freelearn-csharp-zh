<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Movie Booking Web App</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Movie Booking Web App</h1>
                </header>
            
            <article>
                
<p class="mce-root">So far, we have been exploring the <span>features&#160;and</span> fundamentals of ASP.NET Core 2.0. The applications we have developed are good examples to learn the concepts but do not make use of data persistence. In this chapter, we will learn to do read, write, update, and delete data operations, making use of Entity Framework Core. We will also learn how to deploy a web app in Azure and monitor its health. We will demonstrate this by developing a simple movie booking web app, where a user can book a ticket for a movie. So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing Entity Framework and&#160;Entity Framework Core</li>
<li>Getting started with Entity Framework Core</li>
<li>Movie booking app requirements</li>
<li>Designing the movie booking app</li>
<li>Coding the movie booking app</li>
<li>Deploying the movie booking app</li>
<li>Monitoring the movie booking app</li>
</ul>
<p>Let's start with an introduction to Entity Framework.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introducing Entity Framework</h1>
                </header>
            
            <article>
                
<p>So what is <strong>Entity Framework</strong> (<strong>EF</strong>)? Is it some other fancy framework that I need to learn? If these thoughts are coming to mind, get rid of them, as EF is just a set of .NET APIs for accessing data. EF is the official data access tool from Microsoft. Like most Microsoft products, it originated from Microsoft Research, and later it was adopted by the ADO.NET team as the next innovation in Microsoft's data access technology.&#160;EF has evolved over time. It had a sluggish start in 2008 when developers found it hard to digest a new way of accessing data. But with EF4 (yes, the second version of EF was 4, as it was aligned with .NET 4), it had become the norm to use EF for data accessing with .NET. Continuing the journey, it became open source in version EF6 and moved to CodePlex (<a href="http://www.codeplex.com">http://www.codeplex.com</a>). This opened up new avenues for EF. As it became open source, the community could make contributions as well. Now that CodePlex is archived, EF6 has moved to GitHub and is actively being developed.</p>
<p>EF is also referred to as an ORM. What is an ORM? An&#160;<strong>ORM</strong> stands for <strong>object-relational mapping</strong>, which broadly means mapping objects to relational tables. An ORM refers to the t<span>echnique for converting data between two incompatible&#160;</span>type systems. For example, let us consider a C# <span><strong>plain old CLR object</strong> (</span><strong>POCO</strong>) of a <kbd>Person</kbd> class. An instance of the <kbd>Person</kbd> class has the <kbd>Name</kbd>, <kbd>Id</kbd>, and&#160;<kbd>Age</kbd> properties of <kbd>string</kbd>, <kbd>int</kbd> and <kbd>int</kbd>&#160;types, respectively. In the SQL database, this data would be persisted in a table named <kbd>Person</kbd> with the columns <kbd>Name</kbd>, <kbd>Id</kbd>, <kbd>Age</kbd>, and so on. An ORM maps the <kbd>Person</kbd> POCO to the <kbd>Person</kbd> <span>database table</span>. The primary intent of an ORM<span>&#160;is to try and shield the developer from having to write optimized SQL code for this inter-conversion. An&#160;</span>ORMs are designed to reduce the friction between how data is structured in a relational database and how the classes are defined. Without an ORM, we typically need to write a lot of code to transform database results into instances of the classes. An ORM allows us to express our queries using our classes, and then an ORM builds and executes the relevant SQL for us, as well as materializing objects from the data that came back from the database. What I say here is an oversimplification and there's a lot more to an ORMs and to Entity Framework than this.&#160;Entity Framework can really enhance developer productivity and we will see this while developing the movie booking app. EF has a dedicated team at Microsoft. It has been around for almost a decade now. Rather than writing the relevant SQL to target whatever relational database you're working with, Entity Framework uses the <strong>Language-Integrated Query</strong> (<strong>LINQ</strong>) syntax that's part of the .NET framework. LINQ to Entities allows developers to use a consistent and strongly-typed query language irrespective of what database they're targeting. Additionally, LINQ to Objects is used for querying other elements of .NET, even <kbd>InMemory</kbd> objects, so developers benefit from their knowledge of LINQ.</p>
<p>Since we are working with .NET Core and want to make a cross-platform app, we cannot use Entity Framework, as it's not compatible with ASP.NET Core. Don't worry! We have solutions. Either we can compile our project against the full .NET Framework or we can use the latest and greatest version of Entity Framework called Entity Framework Core, which is a lightweight and cross-platform version of Entity Framework, rewritten from scratch to support a variety of platforms. Let's discuss Entity Framework Core.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Presenting Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>EF Core was released in June 2016 after more than 2 years of dedicated effort and following numerous alpha, beta, and even a few release candidate versions. It was originally named Entity Framework 7, but later its name was changed to Entity Framework Core. So what exactly is Entity Framework Core? The official Microsoft documentation (<a href="https://docs.microsoft.com/en-us/ef/core/">https://docs.microsoft.com/en-us/ef/core/</a>) describes Entity Framework Core as a lightweight and extensible version of Entity Framework. In other words, this is not simply an update from EF6; it's a brand new Entity Framework altogether. EF6 is still actively supported and will continue to have tweaks and fixes made to it, though for many reasons, all of the true innovation has gone into Entity Framework Core. Apart from new features that the team wanted to add to Entity Framework, there are also some critical and comprehensive themes for developing EF Core which align with ASP.NET Core and the underlying .NET Core. The idea behind developing EF Core is that it should be built from lightweight composable APIs; that is, it should be able to run on different operating systems that can host native implementations of the CoreCLR and, equally important, use modern software practices in the design, coding, and delivery of Entity Framework Core. Like EF6, EF Core is open source and available on GitHub. The source code of EF Core can be seen at <a href="https://github.com/aspnet/EntityFrameworkCore">https://github.com/aspnet/EntityFrameworkCore</a>. The EF team has a road map for the features that they are prioritizing and the order in which they will be shipped in the upcoming releases. The road map for EF Core can be seen at&#160;<a href="https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap">https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap</a>.</p>
<p>EF Core runs on .NET Core, and .NET Core runs in a lot of places, such as Windows and Linux-based systems, as we have seen in earlier chapters. It runs inside the full .NET Framework, so any version that is 4.5.1 or newer. .NET Core itself can run on the CoreCLR; that's the runtime. CoreCLR can run natively, not only on Windows, but also on Macintosh and Linux. EF Core can also be used with the <strong>Universal Windows Platform</strong> (<strong>UWP</strong>) for Windows 10, so it runs on any device or PC that can run on Windows 10. So one may be tempted to think, should I use EF Core anywhere and everywhere, just because it is supported? The answer is&#160;<em>no</em>. This is a really important point to keep in mind. EF Core is a brand new set of APIs, and so it doesn't have all of the features that you might be used to with EF 6, and while some of those features will be coming in future versions of EF Core, there are a few that will never be part of EF Core, so it's important to understand this, and hence you may not want to start every single new project with EF Core. Before using EF Core, ensure that EF Core has all the features that you need. For a comprehensive list of features that are available in EF and EF Core and for a comparison, I would highly recommend that you visit the official Microsoft documentation describing the feature comparison between EF and EF Core in depth at&#160;<a href="https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features">https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features</a>.</p>
<p>For the sake of completeness, the subset of the feature comparison containing the important features are listed in the following table:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Name of feature</strong></p>
</td>
<td>
<p><strong>EF6</strong></p>
</td>
<td>
<p><strong>EF Core</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Entity Data Model Extension</strong>&#160;(<strong>EDMX</strong>) designer support</p>
</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>
<p>Entity Data Model Wizard (for database first approach)</p>
</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>
<p>Automatic migration</p>
</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>
<p>Lazy loading of data</p>
</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>
<p>Stored procedure mapping with DbContext</p>
</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>
<p>Batch <kbd>Insert</kbd>, <kbd>Update</kbd>, <kbd>Delete</kbd> operations</p>
</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p>In-memory provider for testing</p>
</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p>Support for&#160;<strong>Inversion of Control</strong> (<strong>IoC</strong>)</p>
</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p>Field mapping</p>
</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>
<p>DbContext pooling</p>
</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>If you are overwhelmed with this comparison and feel out of place with the listed features, do not worry. EF is indeed a huge topic to learn. However, we will learn to use it from scratch to have the basic fundamentals in place. To do so, we will learn to create a simple data access console application. Once we know how to use EF Core, we can then use it in our movie booking app.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Entity Framework Core</h1>
                </header>
            
            <article>
                
<p>In this section, we will create a simple console application to perform CRUD operations using Entity Framework Core. The intent is to get started with EF Core and understand how to use it. Before we dive into coding, let us see the two development approaches that EF Core supports:</p>
<ul>
<li>Code-first</li>
<li>Database-first</li>
</ul>
<p>These two paradigms have been supported for a very long time and therefore we will just look at them at a very high level. EF Core mainly targets the code-first approach and has limited support for the database-first approach, as there is no support for the visual designer or wizard for the database model out of the box. However, there are third-party tools and extensions that support this. The list of third-party tools and extensions can be seen at&#160;<a href="https://docs.microsoft.com/en-us/ef/core/extensions/">https://docs.microsoft.com/en-us/ef/core/extensions/</a>.</p>
<p>In the code-first approach, we first write the code; that is, we first create the domain model classes and then, using these classes, EF Core APIs create the database and tables, using migration based on the convention and configuration provided. We will look at conventions and configurations a little later in this section. The following diagram illustrates the code-first approach:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fec0da35-b58c-4829-a27d-92378b1fe6df.png"/></div>
<p>In the database-first approach, as the name suggests, we have an existing database or we create a database first and then use EF Core APIs to create the domain and context classes. As mentioned, currently EF Core has limited support for it due to a lack of tooling. So, our preference will be for the code-first approach throughout our examples. The reader can discover the third-party tools mentioned previously to learn more about the EF Core database-first approach as well. The following image illustrates the database-first approach:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/07b99ff7-0e84-471c-bcf9-f631183b3754.png"/></div>
<div class="packt_infobox">We will refer to properties as scalar properties and navigation properties. Although it's an old concept, it's worth revisiting it again to gain a better understanding.&#160;<span>A property can contain primitive data (such as a string, an integer, or a Boolean value), or structured data (such as a complex type). Properties that are of a primitive type are also called <strong>scalar</strong> properties. The complex properties or properties of another non-simple type are referred to as <strong>complex</strong> or <strong>navigation</strong> properties.</span></div>
<div>
<p class="NOTE alert"><span>Now that we understand the approaches and know that we will be using the code-first approach, let's dive into coding our getting started with EF Core console app. Before we do so, we need to have SQL Express installed in our development machine. If SQL Express is not installed, download the SQL Express 2017 edition from</span> <a href="https://www.microsoft.com/en-IN/sql-server/sql-server-downloads">https://www.microsoft.com/en-IN/sql-server/sql-server-downloads</a> <span>and run the setup wizard. We will do the <span class="packt_screen">Basic</span> installation of SQL Express 2017 for our learning purposes, as shown in the following screenshot:</span></p>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e7c5ae8b-25d4-423d-81e2-230772f4f052.png"/></div>
<p>Our objective is to learn how to use EF Core and so we will not do anything fancy in our console app. We will just do simple&#160;<strong>Create&#160;Read&#160;Update&#160;Delete</strong> (<strong>CRUD</strong>) operations of a simple class called <kbd>Person</kbd>, as defined here:</p>
<pre>    public class Person<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>        public bool Gender { get; set; }<br/>        public DateTime DateOfBirth { get; set; }<br/>        public int Age<br/>        {<br/>            get<br/>            {<br/>                var age = DateTime.Now.Year - this.DateOfBirth.Year;<br/><br/>                if (DateTime.Now.DayOfYear &lt; <br/>                this.DateOfBirth.DayOfYear)<br/>                {<br/>                    age = age - 1;<br/>                }<br/><br/>                return age;<br/>            }<br/>        }       <br/>    }</pre>
<p class="mce-root">As we can see in the preceding code, the class has simple properties. To perform the CRUD operations on this class, let's create a console app by performing the following steps:</p>
<ol>
<li>Create a new .NET Core console project named <kbd>GettingStartedWithEFCore</kbd>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/35f82b30-fd0d-44d1-94b8-29bf7d83d6d7.png"/></div>
<ol start="2">
<li>Create a new folder named <kbd>Models</kbd> in the project node and add the <kbd>Person</kbd> class to this newly created folder. This will be our model entity class, which we will use for CRUD operations.</li>
<li>Next, we need to install the EF Core package. Before we do that, it's important to know that EF Core provides support for a variety of databases. A few of the important ones are:
<ul>
<li><span>SQL Server</span></li>
<li>SQLite</li>
<li>InMemory (for testing)</li>
</ul>
</li>
</ol>
<p style="padding-left: 60px">The complete and comprehensive list can be seen at&#160;<a href="https://docs.microsoft.com/en-us/ef/core/providers/">https://docs.microsoft.com/en-us/ef/core/providers/</a>. We will be working with SQL Server on Windows for our learning purposes, so let's install the SQL Server package for Entity Framework Core.&#160;<span>To do so, let's install the</span> <strong><kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd></strong> <span>package from the <span class="packt_screen">NuGet Package Manager</span> in Visual Studio 2017. Right-click on the project. Select <span class="packt_screen">Manage Nuget Packages</span> and then search for <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd>. Select the matching result and click <span class="packt_screen">Install</span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6e166ab1-fc79-462f-a408-58e7131240bc.png"/></div>
<ol start="4">
<li class="mce-root">Next, we will create a class called <kbd>Context</kbd>, as shown here:</li>
</ol>
<pre>    public class Context : DbContext<br/>    {<br/>        public DbSet&lt;Person&amp;gt; Persons { get; set; }<br/><br/>        protected override void OnConfiguring(DbContextOptionsBuilder <br/>        optionsBuilder)<br/>        {<br/>            //// Get the connection string from configuration                                                    <br/>            optionsBuilder.UseSqlServer(@"Server=.\SQLEXPRESS<br/>            ;Database=PersonDatabase;Trusted_Connection=True;");<br/>        }<br/><br/>        protected override void OnModelCreating(ModelBuilder <br/>        modelBuilder)<br/>        {<br/>             modelBuilder.Entity&lt;Person&amp;gt;<br/>             ().Property(nameof(Person.Name)).IsRequired();<br/>        }<br/>    }</pre>
<ol start="4"></ol>
<p style="padding-left: 60px" class="mce-root">The class looks quite simple, but it has the following subtle and important things to make note of:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>The <kbd>Context</kbd> class derives from <kbd>DbContext</kbd>, which resides in the <kbd>Microsoft.EntityFrameworkCore</kbd> namespace. <kbd>DbContext</kbd> is an integral part of EF Core and if you have worked with EF, you will already be aware of it. An instance of <kbd>DbContext</kbd> represents a session with the database and can be used to query and save instances of your entities. <kbd>DbContext</kbd> is a combination of the&#160;Unit Of Work and Repository Patterns. Typically, you create a class that derives from <kbd>DbContext</kbd> and contains <kbd>Microsoft.EntityFrameworkCore.DbSet</kbd>&#160;properties for each entity in the model.</li>
<li>If properties have a <kbd>public</kbd> setter, they are automatically initialized when the instance of the derived context is created.</li>
<li>It contains a property named <kbd>Persons</kbd> (plural of the model class <kbd>Person</kbd>) of type <kbd>DbSet&lt;Person&amp;gt;</kbd>. This will map to the <kbd>Persons</kbd> table in the underlying database.</li>
<li>The class overrides the&#160;<kbd>OnConfiguring</kbd>&#160;method of <kbd>DbContext</kbd> and specifies the connection string to be used with the SQL Server database. The connection string should be read from the configuration file, <kbd>appSettings.json</kbd>, but for the sake of brevity and simplicity, it's hardcoded in the preceding code.&#160;The <kbd>OnConfiguring</kbd> method allows us to select and configure the data source to be used with a context using <kbd>DbContextOptionsBuilder</kbd>. Let's look at the connection string. <kbd>Server=</kbd> specifies the server. It can be <kbd>.\SQLEXPRESS</kbd>, <kbd>.\SQLSERVER</kbd>, <kbd>.\LOCALDB</kbd>, or any other instance name based on the installation you have done. <kbd>Database=</kbd> specifies the database name that will be created. <kbd>Trusted_Connection=True</kbd> specifies that we are using integrated security or Windows authentication. An enthusiastic reader should read the official Microsoft Entity framework documentation on configuring the context at&#160;<a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext">https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext</a>.</li>
<li>&#160;The <kbd>OnModelCreating</kbd> method allows us to configure the model using the&#160;<kbd>ModelBuilder</kbd> Fluent API.&#160;This is the most powerful method of configuration and allows configuration to be specified without modifying the entity classes. The Fluent API configuration has the highest precedence and will override conventions and data annotations. The preceding code has same effect as the following data annotation has on the <kbd>Name</kbd> property in the&#160;<kbd>Person</kbd> class:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">[Required]<br/>public string Name { get; set; }</pre>
<ol start="5">
<li>The preceding point highlights the flexibility and configuration that EF Core brings to the table. EF Core uses a combination of conventions, attributes, and Fluent API statements to build a database model at runtime. All we have to do is to perform actions on the model classes using a combination of these and they will automatically be translated to appropriate changes in the database. Before we conclude this point, let's have a quick look at each of the different ways to configure a database model:
<ul>
<li><strong>EF Core conventions</strong>: The conventions in EF Core are comprehensive.&#160;<span>They are the default rules by which EF Core builds a database model based on classes. A few of the simpler yet important default conventions are listed here:</span>
<ul>
<li>EF Core creates database tables for all <kbd>DbSet&lt;TEntity&amp;gt;</kbd> properties in a <kbd>Context</kbd> class with the same name as that of the property. In the preceding example, the table name would be <kbd>Persons</kbd> based on this convention.</li>
<li>EF Core creates tables for entities that are not included as <kbd>DbSet</kbd> properties but are reachable through reference properties in the other <kbd>DbSet</kbd> entities. If the&#160;<kbd>Person</kbd> class had a complex/navigation property, EF Core would have created a table for it as well.</li>
<li>EF Core creates columns for all the scalar read-write properties of a class with the same name as the property by default. It uses the reference and collection properties for building relationships among corresponding tables in the database. In the preceding example, the scalar properties of <kbd>Person</kbd> correspond to a column in the&#160;<kbd>Persons</kbd> table.</li>
<li>EF Core assumes a property named <kbd>ID</kbd> or one that is suffixed with <kbd>ID</kbd> as a primary key. If the property is an&#160;<kbd>integer</kbd> type or <kbd>Guid</kbd> type, then EF Core also assumes it to be <kbd>IDENTITY</kbd> and automatically assigns a value when inserting the data. This is precisely what we will make use of in our example while inserting or creating a new <kbd>Person</kbd>.</li>
<li>EF Core maps the data type of a database column based on the data type of the property defined in the C# class. A few of the mappings between the C# data type to the SQL Server column data type are listed in the following table:</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<tbody>
<tr>
<td>
<div class="CDPAlignLeft CDPAlign"><strong>C# data type</strong></div>
</td>
<td><strong>SQL server data type</strong></td>
</tr>
<tr>
<td><kbd>int</kbd></td>
<td><kbd>int</kbd></td>
</tr>
<tr>
<td><kbd>string</kbd></td>
<td><kbd>nvarchar(Max)</kbd></td>
</tr>
<tr>
<td><kbd>decimal</kbd></td>
<td><kbd>decimal(18,2)</kbd></td>
</tr>
<tr>
<td><kbd>float</kbd></td>
<td><kbd>real</kbd></td>
</tr>
<tr>
<td><kbd>byte[]</kbd></td>
<td><kbd>varbinary(Max)</kbd></td>
</tr>
<tr>
<td><kbd>datetime</kbd></td>
<td><kbd>datetime</kbd></td>
</tr>
<tr>
<td><kbd>bool</kbd></td>
<td><kbd>bit</kbd></td>
</tr>
<tr>
<td><kbd>byte</kbd></td>
<td><kbd>tinyint</kbd></td>
</tr>
<tr>
<td><kbd>short</kbd></td>
<td><kbd>smallint</kbd></td>
</tr>
<tr>
<td><kbd>long</kbd></td>
<td><kbd>bigint</kbd></td>
</tr>
<tr>
<td><kbd>double</kbd></td>
<td><kbd>float</kbd></td>
</tr>
</tbody>
</table>
<p style="padding-left: 210px">There are many other conventions, and we can define custom conventions as well. For more details, please read the official Microsoft documentation at&#160;<a href="https://docs.microsoft.com/en-us/ef/core/modeling/">https://docs.microsoft.com/en-us/ef/core/modeling/</a>.</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><strong>Attributes</strong><span>: Conventions are often not enough to map the class to database objects. In such scenarios, we can use attributes called data annotation attributes to get the desired results. The <kbd>[Required]</kbd> attribute that we have just seen is an example of a data annotation attribute.&#160;</span></li>
<li><strong>Fluent API</strong>: This is the most powerful way of configuring the model and can be used in addition to or in place of attributes. The code written in the <kbd>OnModelConfiguring</kbd> method is an example of a Fluent API statement.</li>
</ul>
</li>
</ul>
<ol start="6">
<li>If we check now, there is no <kbd>PersonDatabase</kbd> database. So, we need to create the database from the model by adding a migration.<span>&#160;EF Core includes different migration commands to create or update the database&#160;</span>based&#160;<span>on the model. To do so in Visual Studio 2017, go to&#160;</span><span class="packt_screen">Tools&#160;</span><span>|&#160;</span><span class="packt_screen">Nuget Package Manager&#160;</span><span>|&#160;</span><span class="packt_screen">Package Manager Console</span><span>, as shown in the following screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6d137a6b-e4fc-44b4-b98e-690d5f6be93a.png"/></div>
<p style="padding-left: 60px">&#160;This will open the <span class="packt_screen">Package Manager Console</span> window. Select the Default Project as <kbd>GettingStartedWithEFCore</kbd> and type the following command:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>add-migration CreatePersonDatabase</strong></pre>
<p style="padding-left: 60px" class="mce-root">If you are not using Visual Studio 2017 and you are dependent on .NET Core CLI tooling, you can use the following command:</p>
<pre style="padding-left: 60px" class="mce-root"><strong>dotnet ef migrations add CreatePersonDatabase</strong></pre>
<ol start="7">
<li>We have not installed the <kbd>Microsoft.EntityFrameworkCore.Design</kbd> package, so it will give an error:</li>
</ol>
<pre style="padding-left: 60px">Your startup project 'GettingStartedWithEFCore' doesn't reference Microsoft.EntityFrameworkCore.Design. This package is required for the Entity Framework Core Tools to work. Ensure your startup project is correct, install the package, and try again. </pre>
<p style="padding-left: 60px">So let's first go to the <span class="packt_screen">NuGet Package Manager</span> and install this package. After successful installation of this package, if we run the preceding command again, we should be able to run the migrations successfully. It will also tell us the command to undo the migration by displaying the message <kbd>To undo this action, use Remove-Migration</kbd>. We should see the new files added in the <span class="packt_screen">Solution Explorer</span> in the <kbd>Migrations</kbd> folder, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="233" width="324" src="assets/3dc76353-f5e6-4551-9329-0c3f916d9afc.png"/></div>
<ol start="8">
<li>Although we have migrations applied, we have still not created a database. To create the database, we need to run the following commands.</li>
</ol>
<p style="padding-left: 60px">In Visual Studio 2017:</p>
<pre style="padding-left: 60px"><strong>update-database –verbose</strong></pre>
<p style="padding-left: 60px">In .NET Core CLI:</p>
<pre style="padding-left: 60px"><strong>dotnet ef database update</strong></pre>
<p style="padding-left: 60px" class="mce-root">If all goes well, we should have the database created with the <kbd>Persons</kbd> table (property of type <kbd>DbSet&lt;Person&amp;gt;</kbd>) in the database. Let's validate the table and database by using <span><strong>SQL Server Management Studio</strong> (</span><strong>SSMS</strong>). If SSMS is not installed in your machine, you can also use Visual Studio 2017 to view the database and table.</p>
<ol start="9">
<li class="mce-root">Let's check the created database. In Visual Studio 2017, click on the <span class="packt_screen">View</span> menu and select <span class="packt_screen">Server Explorer</span>, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="144" width="338" src="assets/d55398f1-a213-44cd-a87e-95351d283d60.png"/></div>
<ol start="10">
<li>In <span class="packt_screen">Server Explorer</span>, right-click on <span class="packt_screen">Data Connections</span> and then select <span class="packt_screen">Add Connection</span>. The <span class="packt_screen">Add Connection</span> dialog will show up. Enter <kbd>.\SQLEXPRESS</kbd> in the <span class="packt_screen">Server name</span> (since we installed SQL EXPRESS 2017) and select <kbd>PersonDatabase</kbd> as the database, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="521" width="441" src="assets/7ed2a195-3cc8-47fb-838e-6aab77eaf8bd.png"/></div>
<ol start="11">
<li>On clicking <span class="packt_screen">OK</span>, we will see the database named <kbd>PersonDatabase</kbd> and if we expand the tables, we can see the <kbd>Persons</kbd> table as well as the&#160;<kbd>_EFMigrationsHistory</kbd> table. Notice that the properties in the&#160;<kbd>Person</kbd> class that had setters are the only properties that get transformed into table columns in the <kbd>Persons</kbd> table. Notice that the <kbd>Age</kbd> property is read-only in the class we created and therefore we do not see an age column in the database table, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="307" width="365" src="assets/14616bd5-4e82-40e5-b72d-44a1d60243f2.png"/></div>
<p style="padding-left: 60px"><span>T</span><span>his is the first migration to create a database. Whenever we add or update the model classes or configurations, we need to sync the database with the model using&#160;the</span><span>&#160;</span><kbd>add-migration</kbd><span>&#160;and&#160;</span><kbd>update-database</kbd><span>&#160;commands. With this, we have our model class ready and the corresponding database created. The following image summarizes how the properties have been mapped from the C# class to the database table columns:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/897622d5-4096-4df1-9e21-f5dc1cab8a04.png"/></div>
<p style="padding-left: 60px"><span>Now, we will use the&#160;<kbd>Context</kbd>&#160;class to perform CRUD operations.</span></p>
<ol start="12">
<li class="mce-root">&#160;Let's go back to our <kbd>Main.cs</kbd> and write the following code. The code is well commented, so please go through the comments to understand the flow:</li>
</ol>
<pre>    class Program<br/>    {<br/>        static void Main(string[] args)<br/>        {<br/>            Console.WriteLine("Getting started with EF Core");<br/>            Console.WriteLine("We will do CRUD operations on Person <br/>            class.");<br/>            //// Lets create an instance of Person class.<br/><br/>            Person person = new Person()<br/>            {<br/>                Name = "Rishabh Verma",<br/>                Gender = true, //// For demo true= Male, false = <br/>                Female. Prefer enum in real cases.<br/>                DateOfBirth = new DateTime(2000, 10, 23)<br/>            };<br/><br/>            using (var context = new Context())<br/>            {<br/>                //// Context has strongly typed property named Persons <br/>                     which referes to Persons table.<br/>                //// It has methods Add, Find, Update, Remove to <br/>                     perform CRUD among many others.<br/>                //// Use AddRange to add multiple persons in once.<br/>                //// Complete set of APIs can be seen by using F12 on <br/>                     the Persons property below in Visual Studio IDE.<br/>                var personData = context.Persons.Add(person);<br/>                //// Though we have done Add, nothing has actually <br/>                     happened in database. All changes are in context <br/>                     only.<br/>                //// We need to call save changes, to persist these <br/>                     changes in the database.<br/>                context.SaveChanges();<br/><br/>                //// Notice above that Id is Primary Key (PK) and hence <br/>                     has not been specified in the person object passed <br/>                     to context.<br/>                //// So, to know the created Id, we can use the below <br/>                     Id<br/>                int createdId = personData.Entity.Id;<br/>                //// If all goes well, person data should be persisted <br/>                     in the database.<br/>                //// Use proper exception handling to discover <br/>                     unhandled exception if any. Not showing here for <br/>                     simplicity and brevity. createdId variable would <br/>                     now hold the id of created person.<br/><br/>                //// READ BEGINS<br/>                Person readData = context.Persons.Where(j =&amp;gt; j.Id == <br/>                createdId).FirstOrDefault();<br/>                //// We have the data of person where Id == createdId, <br/>                     i.e. details of Rishabh Verma.<br/>                //// Lets update the person data all together just for <br/>                     demonstarting update functionality.<br/>                //// UPDATE BEGINS<br/>                person.Name = "Neha Shrivastava";  <br/>                person.Gender = false;<br/>                person.DateOfBirth = new DateTime(2000, 6, 15);<br/>                person.Id = createdId; //// For update cases, we need <br/>                this to be specified.<br/><br/>                //// Update the person in context.<br/>                context.Persons.Update(person);<br/>                //// Save the updates.<br/>                context.SaveChanges();<br/><br/>                //// DELETE the person object.<br/>                context.Remove(readData);<br/>                context.SaveChanges();<br/>            }<br/><br/>            Console.WriteLine("All done. Please press Enter key to <br/>            exit...");<br/>            Console.ReadLine();<br/>        }<br/>    }</pre>
<p>With this, we have completed our sample app to get started with EF Core. I hope this simple example will set you up to start using EF Core with confidence and encourage you to start exploring it further. The detailed features of EF Core can be learned from the official Microsoft documentation available at<a href="https://docs.microsoft.com/en-us/ef/core/">&#160;https://docs.microsoft.com/en-us/ef/core/</a>. Now that we have an understanding of EF Core, we are ready to use it in our movie booking app. Let's check out the requirements for the movie booking app.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Movie booking app requirements</h1>
                </header>
            
            <article>
                
<p>In this section, we will discuss the requirements for developing our movie booking web app in ASP.NET Core 2.0. To keep things simple and understandable, we will create a single-screen cinema hall and not a multiplex. The requirements for our sample movie booking app are as follows.</p>
<p>As a user or a movie buff, I should be able to:</p>
<ol>
<li>See the list of movies showing in the cinema hall with timings</li>
<li>See the short description and star cast of the movie before booking</li>
<li>Select seats from the available seats</li>
<li>Book the selected seats</li>
<li>Optionally log in to the seat with Facebook/Google credentials or continue as a guest.</li>
</ol>
<p>Now that we have the requirement specifications in place, let's see the activity flow of the app and come up with a flowchart. The following is the rough flowchart of the app workflow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="464" width="227" src="assets/930aeded-ad9b-4930-8e75-1a8ac90dfaa0.png"/></div>
<p>Let's discuss this flowchart in detail:</p>
<ol>
<li><strong>Start</strong>: This is the start of the flow. The user browses the movie booking app.</li>
<li><strong>Now Showing Movie Listing</strong>: The user can see the the list of movies with timings that are shown in the cinema hall.</li>
<li><strong>Movie description</strong>: The user can optionally check out the movie description by clicking on the selected movie in the list.</li>
</ol>
<ol start="4">
<li><strong>Select movie and show</strong>: The user can select an available show.</li>
<li><strong>Choose Seat</strong>: The user can choose a seat from the available seats for the chosen show.</li>
<li><strong>Optional Login</strong>: The user can optionally log in to the web app or continue as a guest.&#160;</li>
<li><strong>Finish</strong>: We will not be implementing a payment interface, as we only intend to learn ASP.NET Core and EF Core. Upon choosing the seat and navigating ahead, we finish the flow.</li>
</ol>
<p>Now that we have an understanding of the requirements and a fair idea of what we wish to achieve, let's design the movie booking app.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing the movie booking app</h1>
                </header>
            
            <article>
                
<p>In this section, we will do a high-level design of our movie booking web app using ASP.NET Core 2.0. The high-level design of the app is pretty simple, as shown&#160;<span>in the following diagram</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="89" width="303" src="assets/97ecfe77-cb6e-44b7-a385-ac870819e1af.png"/></div>
<p>We can see that an <strong>Online user</strong> browses the <strong>Movie Booking Web app</strong>, which is an Azure web app. Ideally, there should be a service layer in between the <strong>Movie Booking Web app</strong> and the <strong>Database</strong>, to allow for a neat, extensible, modular, and layered architecture. However, for the purpose of learning, we will keep things simple and eliminate the service layer for now. The web app gets data and stores the data in the SQL Azure database. If you are worrying about the Azure web app or SQL Azure, stop doing so. We will develop the app locally development machine and deploy it in Azure, and at that time we will take care of the Azure web app and SQL Azure.</p>
<p>Based on the requirements, we need to design the following:</p>
<ol>
<li>A user interface of the movie booking web app.</li>
<li>A page to list all the movies currently being shown. We will need to design the database model to show the list of the movies currently being shown.</li>
<li>A page to display the details of the selected movie.</li>
</ol>
<ol start="4">
<li>A page to display the available seats to choose from.</li>
<li>A login/authentication module using Facebook or Gmail.</li>
</ol>
<p>For <em>Steps 2</em> to <em>4</em>, we need to do database modeling. We will use SQL Express on Windows and use EF Core, which we discussed earlier. Let's do the class design to fulfill the requirements and create the database following the code-first approach. A movie booking system is a complicated and time-consuming system to make. However, what we will make here is a very simple and limited version of a movie booking system, so that we can focus on learning fundamentals rather than on the design of the system. From the requirements, it is clear that we need to have a <kbd>Movie</kbd> class to contain the movie information and an <kbd>Auditorium</kbd> class where the movie will be shown. The information about which movie is being shown in the auditorium should be stored in a <kbd>Show</kbd> class. The auditorium has seats, so we will need a <kbd>Seat</kbd> class so that the user can choose a seat and book it using a <kbd>Booking</kbd> class to get a ticket through the&#160;<kbd>Ticket</kbd> class. It's worth reiterating that this is a an over-simplistic design to enable an easy grasp of the system the actual system; may be more complex. The following diagram shows how our classes will be designed as per the preceding analysis:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/731a4066-a800-4215-b694-17ab4db637cc.png"/></div>
<p>Since we are using EF Core, our database model will be a replica of these classes, as we saw in the earlier section on getting started with EF Core. Once we are done with these, we will have to develop a simple application that will just do CRUD operations. Now that we have a high-level architecture and class diagrams in place, let's start the coding of the web app.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Coding the movie booking app</h1>
                </header>
            
            <article>
                
<p>In this section, we will code the movie booking app, according to the requirements and design we put together in the preceding sections. We will be using the EF Core code-first approach with SQL Express. To make the coding easy to understand, we will code in a step-by-step manner. The steps are as follows:</p>
<ol>
<li>Create a new ASP.NET Core 2.0 MVC app named <kbd>MovieBooking</kbd>, as we did in the <em>Creating a simple running code</em>&#160;section of <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>.</li>
<li>If you wish to add authentication in your web app, you can click on the <span class="packt_screen">Change Authentication</span> button at the time of selecting the template, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="336" width="514" src="assets/76ff1b1c-02f3-4add-bb9b-7700825780fc.png"/></div>
<p style="padding-left: 60px">A new dialog will display, as shown <span>in the following screenshot</span>, which will offer multiple authentication options to us, as we discussed in <a href="ch03.html">Chapter 3</a>, <em>Building Our First .NET Core Game – Tic-Tac-Toe</em>. To keep things simple, you can select <span class="packt_screen">Individual User Accounts</span> and then choose <span class="packt_screen">Store user accounts in-app</span>. This will do all the boilerplate code needed to enable the app-level user registration, sign-in, and sign-out functionality. Since we have already seen how to use OpenID Connect using the Facebook authentication provider in the Let's Chat web application, we will not go deep into this part and we encourage the reader to reuse the same code and explore and extend it further.</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/3d191f83-e423-46ff-8855-36168eb41901.png"/></div>
<ol start="3">
<li>Next, we will add the <kbd>Models</kbd> folder in the project and add the classes for <kbd>Auditorium</kbd>, <kbd>Movie</kbd>, <kbd>Show</kbd>, <kbd>Seat</kbd>, <kbd>Booking</kbd>, and&#160;<kbd>Ticket</kbd>&#160;that we designed in the preceding section.</li>
<li>The code for the classes is listed next. Since the properties are self-explanatory by virtue of their naming, comments are not explicitly added, to maintain brevity:</li>
</ol>
<pre>    public class Auditorium<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Address { get; set; }<br/>        public virtual IList&lt;Seat&amp;gt; Seats { get; set; }<br/>        public int TotalSeats =&amp;gt; this.Seats == null ? 0 : <br/>        this.Seats.Count;<br/>    }<br/><br/>    public class Seat<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>    }<br/><br/>    public class Movie<br/>    {<br/>        public int Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Poster { get; set; }<br/>        public string Description { get; set; }<br/>        public string Cast { get; set; }<br/>        public string Director { get; set; }<br/>        public string Genere { get; set; }<br/>    }<br/><br/>    public class Show<br/>    {<br/>        public int Id { get; set; }<br/>        public int AuditoriumId { get; set; }<br/>        public int MovieId { get; set; }<br/>        public TimeSpan Timing { get; set; }<br/>        public IList&lt;Seat&amp;gt; AvailableSeats { get; set; }        <br/>        public IList&lt;Seat&amp;gt; BookedSeats { get; set; }<br/>        public int TotalSeats { get; set; }<br/>    }<br/><br/>    public class Ticket<br/>    {<br/>        public int ShowId { get; set; }        <br/>        public List&lt;int&amp;gt; SeatIds { get; set; }<br/>        public int Qunatity =&amp;gt; this.SeatIds == null ? 0 : <br/>        this.SeatIds.Count;<br/>    }<br/><br/>    public class Booking<br/>    {<br/>        public int Id { get; set; }<br/>        public IList&lt;Ticket&amp;gt; Tickets { get; set;}<br/>    }</pre>
<p style="padding-left: 60px" class="mce-root">With this, the models are ready.&#160;</p>
<ol start="5">
<li class="mce-root"><span>Next, we need to install EF Core packages to make use of all the EF Core benefits, so let's install the <kbd>Microsoft.EntityFrameworkCore.SqlServer</kbd>&#160;and&#160;<kbd>Microsoft.EntityFrameworkCore.Design</kbd>&#160;NuGet packages in our project from the <span class="packt_screen">NuGet Package Manager</span>. We have already done this while making the <kbd>GettingStartedWithEFCore</kbd> app.&#160;</span></li>
<li class="mce-root"><span>Now, we need to create the context class to create the database based on this model. We will create the model named <kbd>MovieBookingContext</kbd>, as shown in the following code:</span></li>
</ol>
<pre class="mce-root">    public class MovieBookingContext : DbContext<br/>    {<br/>        public DbSet&lt;Auditorium&amp;gt; Auditoriums { get; set; }        <br/>        public DbSet&lt;Movie&amp;gt; Movies { get; set; }<br/>        public DbSet&lt;Show&amp;gt; Shows { get; set; }<br/>        public DbSet&lt;Booking&amp;gt; Bookings { get; set; }<br/>        public DbSet&lt;Ticket&amp;gt; Tickets { get; set; }<br/>        public <br/>        MovieBookingContext(DbContextOptions&lt;MovieBookingContext&amp;gt; <br/>        options) : base(options)<br/>        { <br/>        }  <br/>    }</pre>
<ol start="7">
<li>Notice that&#160;<kbd>MovieBookingContext</kbd>&#160;doesn't have the&#160;<kbd>OnConfiguring</kbd> method call that we used to configure the SQL database in our last EF Core sample. This is to show a different way of configuring the database. We will read the connection string from the&#160;<kbd>appsettings.json</kbd> configuration file, which has the following configuration entry:</li>
</ol>
<pre style="padding-left: 60px">"ConnectionStrings": {<br/>    "DefaultConnection": "Server=.\\SQLEXPRESS;Database=MovieBookingDemo;Trusted_Connection=True;"<br/>  },</pre>
<ol start="8">
<li><span>Next, we will configure the database through the context by reading the configuration in the <kbd>ConfigureServices</kbd> method of&#160;</span><kbd>Startup.cs</kbd><span>, as shown in the following code:</span></li>
</ol>
<pre>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            <strong>services.AddDbContext&lt;MovieBookingContext&amp;gt;(options =&amp;gt; <br/>            options.UseSqlServer(Configuration.GetConnectionString<br/>            ("DefaultConnection")));</strong><br/>            services.AddMvc();<br/>        }</pre>
<ol start="9">
<li>After developing the context, we need to create the database. To do so, we we need to run the following commands in order. The first command will add the migration and the second command will actually create the database:</li>
</ol>
<pre style="padding-left: 60px"><strong>add-migration CreateMovieBookingDemo</strong><br/><strong>update-database -verbose</strong></pre>
<ol start="10">
<li>Now we have the database, but we do not have the necessary data in the tables to list the movie information. To do so, we can either write a script, a small EF Core-based program, or enter it manually in the table. Since this is SQL stuff, we will not go into great detail, but an aware reader should be able to insert this data in the corresponding tables correctly.&#160;</li>
<li>Next, we need to create controllers and views for the screens and wire up the data access layer. At the outset, the user should be able to see the list of shows in the home screen, so we will develop the home screen first. To do so, we will reuse the <kbd>Index</kbd> action of&#160;<kbd>HomeController.cs</kbd> as it is and modify the <kbd>Index</kbd> view to display the user interface, as shown&#160;<span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f0f66a26-3414-4da4-85fa-b82dc1db8889.png"/></div>
<ol start="9"></ol>
<p style="padding-left: 60px">There is nothing fancy here. The user interface has an image carousel, which displays the posters of the movies and the quick booking section, which lists the movies and show times. Just replace the URLs of the default carousel (which comes out of the box in the default template) with the image URLs of movie posters by searching them online through Bing.</p>
<ol start="12">
<li>To show the list of movies, we need an API returning the list of movies called as&#160;<kbd>GetMovies</kbd> API. Recall that we have added the movie data in the database already, so we have movies to be fetched. On selecting a movie, we need to fetch the available show times for the movie, so we need another API to fetch the show time based on the movie called <kbd>GetShowTimesForMovie</kbd> API. We have seen how to create APIs using the <kbd>Context</kbd> object in the <em>Getting started with Entity Framework Core</em>&#160;section. We then wire up the APIs to the controller to populate data in the view.</li>
</ol>
<ol start="13">
<li>On clicking the <span class="packt_screen">Book</span> button, the user is navigated to the seat selection page. To display the seats, we again need an API to get the available seats for a show named <kbd>GetAvailableSeatsForShow</kbd> API.</li>
<li>On clicking a movie, we can view the selected movie details. The data for this comes through the&#160;<kbd>GetMovieDetails</kbd> API.</li>
<li>Similarly, the UI and corresponding APIs are developed, as now it's just a simple app, that fetches the data from the database and displays it in the user interface.&#160;</li>
</ol>
<p>The complete source code can be seen at <span><a href="https://github.com/PacktPublishing/.NET-Core-2.0-By-Example">https://github.com/PacktPublishing/.NET-Core-2.0-By-Example</a></span>, which lists all the APIs and the view code that we discussed previously. It also has a script, that can be executed to insert the sample data into the application.&#160;</p>
<p>We will next look at deploying this app.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying the movie booking app</h1>
                </header>
            
            <article>
                
<p>We have already deployed one of our sample web apps in Azure and this is no different. The assumption here is that the reader already has an Azure subscription and is logged in with the email ID used for the subscription. If this is not the case, please go through the previous chapters where we have discussed Azure subscription at length. Let's have a look at steps to deploy our movie booking app on the cloud:&#160;</p>
<ol>
<li><span>In the Visual Studio <span class="packt_screen">Solution Explorer</span> window, r</span>ight-click on the <kbd>MovieBooking</kbd> project and then click <span class="packt_screen">Publish</span>. It will open a <span class="packt_screen">Publish</span> dialog.</li>
</ol>
<ol start="2">
<li>Select <span class="packt_screen">Create New</span> and then click <span class="packt_screen">OK</span>. It will open the <span class="packt_screen">Create App Service</span> dialog. Enter the required fields, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13ff8b9c-0e4b-4d90-a1f6-9f57f96447d8.png"/></div>
<ol start="3">
<li>After filling in all the required input, click on <span class="packt_screen">Services</span> on the left panel. It will display the following dialog:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bc5bb555-6f17-48ef-a20e-f53e94187209.png"/></div>
<ol start="4">
<li>We need a database for our app to function and the dialog shows the <span class="packt_screen">SQL Database</span> as the additional Azure resource that we need to deploy. Click on the <span class="packt_screen">+</span> icon on the right-hand side. It will open a new dialog <span class="packt_screen">Configure&#160;</span><span class="packt_screen">SQL Database</span>, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="476" width="423" src="assets/26ae03e3-88c9-4c55-9713-2c834700654b.png"/></div>
<ol start="5">
<li>Enter the required details. Make a note of the username and password as well as the database name and connection string name, as these will be used in the code. Click <span class="packt_screen">OK</span> and then click <span class="packt_screen">Create</span>. This will create the publish profile and deploy the app.</li>
</ol>
<ol start="6">
<li>However, we need to ensure that our database gets created, our intended connection string is used, and migrations are applied. To do so, in the <span class="packt_screen">Publish</span> window, click on the <span class="packt_screen">Settings</span> link, as shown <span>in the following screenshot:</span>&#160;</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="288" width="511" src="assets/1cf37f5d-47f9-4ad8-af3e-abc60e26fc78.png"/></div>
<ol start="7">
<li>The <span class="packt_screen">Publish</span> dialog will open. On the <span class="packt_screen">Settings</span> tab, ensure that for <span class="packt_screen">DefaultConnection</span>, under the <span class="packt_screen">Databases</span> section, the <span class="packt_screen">Use this connection string at runtime</span> checkbox is checked, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="400" width="505" src="assets/7edf2b7b-7c35-4751-a62f-9460078bc74e.png"/></div>
<ol start="8">
<li>If you deploy for the first time, you may also see<span>&#160;</span><span class="packt_screen">Entity Framework Migrations</span>, just like the&#160;<span class="packt_screen">Databases</span> section shown in the preceding screenshot. If so, please check<span>&#160;</span><span class="packt_screen">Apply this migration on publish</span>. Since I have already applied the migrations, I don't have it in in preceding screenshot.</li>
<li>Click <span class="packt_screen">Save</span> and then click <span class="packt_screen">Publish</span>. This will publish the web app as well as the database and migrations.</li>
</ol>
<p>With this, our web app is deployed and after successful deployment, the app will automatically be launched in the browser.&#160;The sample app can be seen at&#160;<a href="http://packtmoviebookingapp.azurewebsites.net/">http://packtmoviebookingapp.azurewebsites.net/</a>.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monitoring the movie booking app</h1>
                </header>
            
            <article>
                
<p>Coding and deploying an app is fine, but it's equally important to ensure that the app keeps running fine once it's deployed in production and end users start using it. So monitoring an app is quite important. In this section, we will learn to add Application Insights in our web app and also touch upon various out-of-the box monitoring options provided by Azure. We will start with Application Insights.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application Insights</h1>
                </header>
            
            <article>
                
<p><span>Application Insights is an extensible <strong>Application Performance Management</strong> (<strong>APM</strong>) service for web developers on multiple platforms to monitor web applications for performance, usability, and availability. It automatically detects performance issues. It includes powerful analytics tools to help us diagnose issues and to understand what users actually do with our app. How cool is that? We can find out about the most and least used features of our web app using Application Insights. We can use the actionable insights from Application Insights to continuously improve the performance and usability of the app. I have personally found Application Insights very useful in diagnosing and fixing performance issues. This is a proactive way of identifying the issue, rather than waiting for the end user to experience an issue and then reporting it. Let's start with enabling Application Insights in our movie booking web app. To do so, we need to do the following:</span></p>
<ol>
<li>In Visual Studio 2017 <span class="packt_screen">Solution Explorer</span>, expand the <kbd>MovieBooking</kbd> project and click on <span class="packt_screen">Connected Services</span>. This will display the <span class="packt_screen">Connected Services</span> page, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4681682e-ae87-4bc9-ba98-0f1ba9f23f1b.png"/></div>
<ol start="2">
<li>Click on <span class="packt_screen">Monitoring with Application Insights</span>. This will open the&#160;<span class="packt_screen">Application Insights</span>&#160;configuration screen, as shown <span>in the following screenshot</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="358" width="478" src="assets/0222fc40-c975-49c2-a38d-d822610e96db.png"/></div>
<p style="padding-left: 60px">This same screen can be reached by right-clicking on the <kbd>MovieBooking</kbd> project in <span class="packt_screen">Solution Explorer</span> and then clicking <span class="packt_screen">Add</span> | <span class="packt_screen">Application Insights Telemetry</span>, as shown <span>in the following screenshot</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9e32d207-0007-44d7-8222-8be27f93367e.png"/></div>
<ol start="3">
<li>Click on the&#160;<span class="packt_screen">Start Free</span> button. This will take us to the registration screen, shown <span>in the following screenshot</span>. Choose the <span class="packt_screen">Subscription</span> and <span class="packt_screen">Resource</span> based on your requirements. Here, I have created a new resource but you may want to reuse an existing resource. We will go with the free variant, so choose the option in which Application Insights will remain free and halt data collection after the quota of <span class="packt_screen">1 GB / Month</span> is exhausted:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="676" width="495" src="assets/7efba094-9332-4890-beb9-7b22f357900c.png"/></div>
<ol start="4">
<li>Click on <span class="packt_screen">Register</span>. This may take a while and hence show a progress bar, shown <span>in the following screenshot</span>. Look at the screenshot and we can see how powerful Application Insights is. It has <span class="packt_screen">Smart Detection</span>, <span class="packt_screen">App Map</span>, <span class="packt_screen">Analytics</span>, and <span class="packt_screen">CodeLens</span>, among other great features:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="206" width="508" src="assets/92992cb8-e8c8-4c5d-aed7-342110055388.png"/></div>
<ol start="5">
<li><span>Once the configuration is done, the progress bar will disappear. Application Insights telemetry should now be enabled in the selected project. The configuration will add the instrumentation key in&#160;<kbd>appsettings.json</kbd> as well and so, after successfully enabling Application Insights, you may get a prompt that the file has been modified. This is fine and expected, so click <span class="packt_screen">OK</span></span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="239" width="529" src="assets/fb6c148e-0080-4300-b593-542a5f24e119.png"/></div>
<ol start="4"></ol>
<p class="mce-root">We are now ready to monitor the web app after publishing it to remain in sync with the instrumentation key changes and Application Insight SDK changes that we have just done. With this, we are done with setting up Application Insights. Now, we will see how we can monitor the web app and leverage the benefits of Application Insights. We can see the telemetry data of our local debugging setup in Visual Studio itself, while the Azure portal is where we can see the insights of our deployed application.</p>
<p>In the Visual Studio <span class="packt_screen">Solution Explorer</span>, we will now have the <kbd>Application Insights</kbd> folder inside <span class="packt_screen">Connected Services</span> for our movie booking project, as shown <span>in the following screenshot</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="70" width="196" src="assets/07a76aa4-a605-46cb-a5fd-70842687218f.png"/></div>
<p>Right-click on the <span class="packt_screen">Application Insights</span> folder and we will get a number of options. A few of the important ones are shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="174" width="261" src="assets/1c8b7ec0-0542-4d8d-b399-f1b7e8e72307.png"/></div>
<p>Here are the explanations of these options:</p>
<ul>
<li><span class="packt_screen">Open Application Insights Portal</span>: This will directly open Application Insights in the Azure web portal.&#160;</li>
<li><span class="packt_screen">Application Analytics</span>: This will open the application analytics portal, where we can perform detailed analytics and filtering of data.</li>
<li><span class="packt_screen">Application Map</span>: This will open the application map for the project in the Azure portal. The a<span><span>pplication map helps us to spot performance bottlenecks or failure hotspots across all components of the distributed application.</span></span></li>
<li><span class="packt_screen">Configure Application Insights</span>: This can be used to configure Application Insights.</li>
<li><span class="packt_screen">Choose Telemetry Source</span>: This configures the app that will be used as the telemetry source. By default, the current web app will be the telemetry source.</li>
<li><span class="packt_screen">Search Live Telemetry</span>: This searches the data in the telemetry from Visual Studio or in the Azure web portal. Using this, we can also see debug telemetry data from the Visual Studio debugging.&#160;</li>
</ul>
<p>To conclude this discussion, let us see the Application Insights data that was collected while I wrote this section.&#160;T<span>he following screenshot</span>&#160;shows what it looks like for the movie booking app that we developed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="477" width="343" src="assets/9d1a814a-402e-47a4-a5f0-bcf70a63cd92.png"/></div>
<p>Application Insights is a huge topic and one section of a chapter doesn't do justice to this great and important feature. For a thorough and detailed coverage Application Insights, I would highly recommend readers to read the wonderful documentation on Application Insights at&#160;<a href="https://docs.microsoft.com/en-us/azure/application-insights/">https://docs.microsoft.com/en-us/azure/application-insights/</a>.</p>
<p>In this section, we have looked at Application Insights, which is a great monitoring tool in the developer's repertoire. However, Azure has much more to offer in terms of monitoring options and we will explore these in the next chapter, where I will also discuss how to use Application Insights telemetry data to investigate issues. With this note, we conclude this chapter.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about Entity Framework and Entity Framework Core, and understood the features of each and the differences between the two. We also learned that we should use EF Core only if EF cannot be used or there is a pressing cross-platform requirement to use EF Core. We learned how to do CRUD operations using EF Core by creating a simple app. We then developed a simple movie booking app and learned how to deploy it using Visual Studio. We also saw how we can monitor our web app by enabling Application Insights. So far, we have only seen monolithic apps where all the APIs reside in one web app. If that one web app goes down, our entire app can come to a standstill. There is a way to circumvent this by deploying the app in smaller, independent modules, called microservices. In the next chapter, we will explore microservices.</p>


            </article>

            
        </section>
    </div>
</body>
</html>