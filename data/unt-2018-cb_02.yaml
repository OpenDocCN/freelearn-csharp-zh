- en: Responding to User Events for Interactive UIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对交互式UI的用户事件做出响应
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating UI Buttons to move between scenes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI按钮在场景之间移动
- en: Animating button properties on mouse-over
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在鼠标悬停时动画化按钮属性
- en: Organizing image panels and changing panel depths via buttons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过按钮组织图像面板和更改面板深度
- en: Displaying the value of an interactive UI Slider
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示交互式UI滑块的值
- en: Displaying a countdown timer graphically with a UI Slider
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UI滑块图形化显示倒计时计时器
- en: Setting custom mouse cursors for 2D and 3D GameObjects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为2D和3D GameObject设置自定义鼠标光标
- en: Setting custom mouse cursors for UI controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为UI控件设置自定义鼠标光标
- en: Interactive text entry with an Input Field
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入字段进行交互式文本输入
- en: Toggles and radio buttons via Toggle Groups
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过切换组使用切换和单选按钮
- en: Creating text and image icon UI Dropdown menus
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文本和图像图标UI下拉菜单
- en: Displaying a radar to indicate the relative locations of objects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示雷达以指示对象的相对位置
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'Almost all the recipes in this chapter involve different interactive UI controls.
    Although there are different kinds of interactive UI controls, the basic way to
    work with them, and have scripted actions respond to user actions, is all based
    on the same idea: events triggering the execution of object method functions.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的几乎所有食谱都涉及不同的交互式UI控件。尽管有不同类型的交互式UI控件，但使用它们的基本方式以及脚本动作响应用户动作都是基于相同的概念：事件触发对象方法函数的执行。
- en: Then, for fun, and an example of a very different kind of UI, the final recipe
    demonstrates how to add to your game a sophisticated real-time communication of
    the relative positions of objects in the scene (that is, a radar!).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了娱乐和展示一种非常不同的UI类型，最后的食谱演示了如何将一个复杂的实时通信添加到游戏中，该通信显示场景中对象的相对位置（即雷达！）。
- en: The big picture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体概念
- en: 'The UI can be used for three main purposes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: UI可以用于三个主要目的：
- en: To display **static (unchanging) values**, such as the name or logo image of
    the game, or word labels such as Level and Score, that tell us what the numbers
    next to them indicate (recipes for these can be found in the [Chapter 1](920700d7-96cd-4015-b17c-ee2451bc648e.xhtml), *Displaying
    Data with Core UI Elements*).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示**静态（不变）值**，例如游戏的名称或标志图像，或者如“等级”和“得分”之类的文字标签，这些标签告诉我们它们旁边的数字表示什么（这些食谱可以在[第1章](920700d7-96cd-4015-b17c-ee2451bc648e.xhtml)，*使用核心UI元素显示数据*中找到）。
- en: To display **values that change due to our scripts**, such as timers, scores,
    or the distance from our Player character to some other object (an example of
    this is the radar recipe at the end of this chapter).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示**由于我们的脚本而变化的值**，例如计时器、得分或玩家角色与其他对象之间的距离（本章末尾的雷达食谱就是一个例子）。
- en: '**Interactive** UI controls, whose purpose is to allow the Player to communicate
    with the game scripts via their mouse or touchscreen. These are the ones we''ll
    look at in detail in this chapter.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**交互式** UI控件，其目的是允许玩家通过鼠标或触摸屏与游戏脚本进行通信。我们将在本章中详细探讨这些控件。'
- en: 'The core concept for working with Unity Interactive UI controls is the *registration
    of an object''s public method to be informed when a particular event occurs*.
    For example, we can add a UI Dropdown to a scene named DropDown 1, and then write
    a `MyScript` script class containing a `NewValueAction()` public method to do
    some action. But nothing will happen until we do two things:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中处理交互式UI控件的核心概念是将对象的公共方法注册为特定事件发生时的通知。例如，我们可以将一个UI下拉菜单添加到名为“DropDown 1”的场景中，然后编写一个包含`NewValueAction()`公共方法的`MyScript`脚本类来执行某些操作。但除非我们做两件事，否则什么都不会发生：
- en: We need to add an *instance of the script class as a component* on a GameObject
    in the scene (which we'll name `go1` for our example – although we can also add
    the script instance to the UI GameObject itself if we choose to).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在场景中的GameObject（在我们的例子中命名为`go1` - 虽然我们也可以选择将脚本实例添加到UI GameObject本身）上添加脚本类的**实例**作为组件。
- en: 'In the UI Dropdown''s properties, we need to *register the GameObject''s public
    method* of its script component to respond to the `On Value Changed` event messages:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI下拉菜单的属性中，我们需要将脚本组件的GameObject的公共方法**注册**为响应`On Value Changed`事件消息：
- en: '![](img/2e7f83bb-dd87-4eca-bb4a-f20e054e3632.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e7f83bb-dd87-4eca-bb4a-f20e054e3632.jpg)'
- en: 'The `NewValueAction()` public method of the `MyScript` script will typically
    retrieve the value selected by the user in the Dropdown and do something with
    it – for example, confirm it to the user, change the music volume, or change the
    game difficulty. The `NewValueAction()` method will be invoked (executed) each
    time GameObject go1 receives the `NewValueAction()` message. In the DropDown 1''s
    properties, we need to register GameObject go1''s scripted component MyScript''s
    `NewValueAction()` public method as an event listener for On Value Changed events.
    We need to do all this at **Design-Time** (that is, in the Unity editor before
    running the scene):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyScript`脚本的`NewValueAction()`公共方法通常将检索用户在下拉菜单中选择的值并对其进行处理——例如，向用户确认，更改音量，或更改游戏难度。每当GameObject
    go1收到`NewValueAction()`消息时，`NewValueAction()`方法将被调用（执行）。在DropDown 1的属性中，我们需要将GameObject
    go1的脚本组件MyScript的`NewValueAction()`公共方法注册为On Value Changed事件的监听器。我们需要在**设计时**（即在Unity编辑器运行场景之前）完成所有这些操作：'
- en: '![](img/3e2ebc59-b702-4b80-aec7-143f8f20b371.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e2ebc59-b702-4b80-aec7-143f8f20b371.jpg)'
- en: At **runtime** (when the scene in the built application is running), if the
    user changes the value in the drop-down menu of UI Dropdown GameObject DropDown
    1 (step 1 in the diagram), this will generate an On Value Changed event. DropDown
    1 will update its display on screen, to show the user the newly-selected value
    (step 2a). It will also send messages to all the GameObject components registered
    as listeners to **On Value Changed** events (step 2b). In our example, this will
    lead to the `NewValueAction()` method in GameObject go1's scripted component being
    executed (step 3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**运行时**（当构建的应用程序中的场景正在运行时），如果用户更改UI Dropdown GameObject DropDown 1的下拉菜单中的值（图中的步骤1），这将生成一个On
    Value Changed事件。DropDown 1将更新其屏幕上的显示，以向用户显示新选定的值（步骤2a）。它还将向所有注册为**On Value Changed**事件监听器的GameObject组件发送消息（步骤2b）。在我们的例子中，这将导致GameObject
    go1的脚本组件中的`NewValueAction()`方法被执行（步骤3）。
- en: Registering public object methods is a very common way to handle events such
    as user interaction or web communications, which may occur in different orders,
    may never occur, or may happen several times in a short period. Several software
    Design Patterns describe ways to work with these event setups, such as the *Observer
    Pattern* and the *Publisher-Subscriber* pattern (we'll learn more about this pattern
    in [Chapter 16](04f5a183-ae0b-4d73-8e78-c90fd75c9a64.xhtml), *Design Patter**ns*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注册公共对象方法是处理用户交互或网络通信等事件的一种非常常见的方式，这些事件可能按不同的顺序发生，可能永远不会发生，或者可能在短时间内发生多次。几种软件设计模式描述了如何处理这些事件设置，例如**观察者模式**和**发布-订阅**模式（我们将在第16章[设计模式](04f5a183-ae0b-4d73-8e78-c90fd75c9a64.xhtml)中了解更多关于这种模式的信息）。
- en: 'Core GameObjects, components, and concepts relating to interactive Unity UI
    development include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与交互式Unity UI开发相关的核心GameObject、组件和概念包括：
- en: '**Visual UI controls**: The visible UI controls themselves include Button,
    Image, Text, and Toggle. These are the UI controls the user sees on the screen,
    and uses their mouse/touchscreen to interact with. These are the GameObjects that
    maintain a list of object-methods that have subscribed to user-interaction events.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视觉UI控件**：可见的UI控件包括按钮、图像、文本和切换。这些是用户在屏幕上看到的UI控件，并使用鼠标/触摸屏与之交互。这些是维护已订阅用户交互事件的对象方法的列表的GameObject。'
- en: '**Interaction UI controls**: These are non-visible components that are added
    to GameObjects; examples include Input Field and Toggle Group.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互UI控件**：这些是非可见组件，它们被添加到GameObject中；例如，包括输入字段和切换组。'
- en: '**Panel**: UI objects can be grouped together (logically and physically) with
    UI Panels. Panels can play several roles, including providing a GameObject parent
    in the Hierarchy for a related group of controls. They can provide a visual background
    image to graphically relate controls on the screen, and they can also have scripted
    resize and drag interactions added, if desired.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面板**：UI对象可以使用UI Panels进行分组（逻辑上和物理上）。面板可以扮演多个角色，包括为相关控制组提供Hierarchy中的GameObject父对象。它们可以提供视觉背景图像，以图形化地关联屏幕上的控件，并且如果需要，还可以添加脚本化的调整大小和拖动交互。'
- en: '**Sibling Depth**: The bottom-to-top display order (what appears on the top
    of what) for a UI element is determined initially by their sequence in the Hierarchy.
    At **Design-Time**, this can be manually set by dragging GameObjects into the
    desired sequence in the Hierarchy. At **Run-Time**, we can send messages to the
    Rect Transforms of GameObjects to dynamically change their Hierarchy position
    (and therefore, the display order), as the game or user interaction demands. This
    is illustrated in the *Organizing images inside panels and changing panel depths
    via buttons* recipe.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟深度**：UI 元素的从下到上的显示顺序（什么出现在什么上面）最初由它们在 Hierarchy 中的顺序决定。在设计时，可以通过将 GameObjects
    拖动到 Hierarchy 中所需的顺序来手动设置。在运行时，我们可以向 GameObjects 的 Rect Transforms 发送消息，以动态更改它们的
    Hierarchy 位置（因此，显示顺序），以满足游戏或用户交互的需求。这可以在 *通过按钮组织面板内的图像和更改面板深度* 菜谱中看到。'
- en: Often, a UI element exists with most of the components that you may need for
    something in your game, but you may need to adapt it somehow. An example of this
    can be seen in the recipe that makes a UI Slider non-interactive, instead using
    it to display a red-green progress bar for the status of a countdown timer. See
    this in the *Displaying a countdown timer graphically with a UI Slider* recipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个 UI 元素已经包含了你可能需要的游戏中的大多数组件，但你可能需要对其进行某种调整。一个这样的例子可以在 *使用 UI 滑块图形显示倒计时计时器状态*
    菜谱中看到，该菜谱将 UI 滑块变为非交互式，而是用它来显示倒计时计时器的红色-绿色进度条。
- en: Creating UI Buttons to move between scenes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 UI 按钮在场景之间切换
- en: As well as scenes where the player plays the game, most games will have menu
    screens, which display to the user messages about instructions, high scores, the
    level they have reached so far, and so on. Unity provides UI Buttons to offer
    users a simple way to indicate their choices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了玩家玩游戏时的场景外，大多数游戏还会有菜单屏幕，这些屏幕向用户显示有关说明、高分、他们已经达到的水平等信息。Unity 提供了 UI 按钮，为用户提供了一种简单的方式来表示他们的选择。
- en: 'In this recipe, we''ll create a very simple game consisting of two screens,
    each with a button to load the other one, as illustrated in the screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个非常简单的游戏，由两个屏幕组成，每个屏幕都有一个按钮来加载另一个屏幕，如图所示：
- en: '![](img/873bd5cc-73d8-4132-94e1-db89a8f3c865.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/873bd5cc-73d8-4132-94e1-db89a8f3c865.png)'
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a button-navigable multi-scene game, follow these steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个按钮可导航的多场景游戏，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Save the current (empty) scene, in a new folder, `_Scenes`, naming the scene
    page1.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹 `_Scenes` 中保存当前（空）场景，命名为 scene page1。
- en: Add a **UI Text** object positioned at the top center of the scene, containing
    large white text that says Main Menu (page 1).
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景顶部中心位置添加一个 **UI 文本** 对象，包含显示“主菜单（页面 1）”的大号白色文本。
- en: 'Add a **UI Button** to the scene positioned in the middle-center of the screen.
    In the **Hierarchy**, click on the show children triangle to display the **Text**
    child of this GameObject button. Select the **Text** GameObject, and in the **Inspector** for
    the Text property of the Text (Script) component, enter the text goto page 2:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕中间位置添加一个 **UI 按钮**。在 **Hierarchy** 中，点击显示子对象三角形以显示此 GameObject 按钮的 **Text**
    子对象。选择 **Text** GameObject，并在 **Inspector** 中为 Text（脚本）组件的 Text 属性输入文本“转到页面 2”：
- en: '![](img/1c2d5b99-fa37-4e6a-935d-bfe90904ea40.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c2d5b99-fa37-4e6a-935d-bfe90904ea40.png)'
- en: Create a second scene, named page2, with UI Text = Instructions (page 2), and
    a **UI Button** with the goto page 1 text. You can either repeat the preceding
    steps, or you can duplicate the page1 scene file, naming the duplicate page2,
    and edit the UI Text and UI Button Text appropriately
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 page2 的第二个场景，UI 文本为“说明（页面 2）”，并添加一个带有“转到页面 1”文本的 **UI 按钮**。你可以重复前面的步骤，或者你可以复制
    page1 场景文件，将其命名为 page2，并相应地编辑 UI 文本和 UI 按钮文本。
- en: 'Add both scenes to the Build, which is the set of scenes that will end up in
    the actual application built by Unity. To add the scene1 to the Build, open scene
    page1, then choose menu: File | Build Settings... then click on the Add Current
    button so that the page1 scene becomes the first scene on the list of Scenes in
    the Build. Now open scene page2 and repeat the process, so both scenes have been
    added to the Build.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个场景添加到构建中，这是 Unity 构建的实际应用程序中最终将包含的场景集。要将 scene1 添加到构建中，打开 scene page1，然后选择菜单：文件
    | 构建设置... 然后点击添加当前按钮，使 page1 场景成为构建中场景列表中的第一个场景。现在打开 scene page2 并重复此过程，这样两个场景都已被添加到构建中。
- en: We cannot tell Unity to load a scene that has not been added to the list of
    scenes in the build. This makes sense since when an application is built we should
    never try to open a scene that isn't included as part of that application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能告诉Unity加载一个尚未添加到构建场景列表中的场景。这很有道理，因为当应用程序构建时，我们永远不应该尝试打开不属于该应用程序的场景。
- en: Ensure you have scene page1 open.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已经打开了场景page1。
- en: 'Create a C# script class, `SceneLoader`, in a new folder, `_Scripts`, containing
    the following code, and add an instance as a scripted component to the Main Camera:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为`_Scripts`的新文件夹中创建一个C#脚本类，名为`SceneLoader`，包含以下代码，并将其作为一个脚本组件添加到主相机中：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select the Button in the Hierarchy and click on the plus sign (+) button at
    the bottom of the **Button (Script)** component, in the **Inspector** view, to
    create a new `OnClick` event handler for this button (that is, an action to perform
    when the button is clicked).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级窗口中选择按钮，然后在**Inspector**视图的**Button (Script)**组件的底部点击加号（+）按钮，为这个按钮创建一个新的`OnClick`事件处理程序（即当按钮被点击时执行的动作）。
- en: Drag the Main Camera from the Hierarchy over the Object slot immediately below
    the menu saying Runtime Only. This means that when the Button receives an `OnClick`
    event, we can call a public method from a scripted object inside the Main Camera.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主相机从层级窗口拖动到位于“仅运行时”菜单下方立即的“对象”槽位。这意味着当按钮接收到`OnClick`事件时，我们可以从主相机内的脚本对象中调用一个公共方法。
- en: 'Select the `LoadOnClick` method from the SceneLoader drop-down list (initially
    showing No Function). Type 1 (the index of the scene we want to be loaded when
    this button is clicked) in the text box, below the method''s drop-down menu. This
    integer, 1, will be passed to the method when the button receives an `OnClick`
    event message, as shown here:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从SceneLoader下拉列表中选择`LoadOnClick`方法（最初显示为“无函数”）。在方法下拉菜单下的文本框中输入1（我们希望在点击按钮时加载的场景的索引）。这个整数1将在按钮接收到`OnClick`事件消息时传递给方法，如这里所示：
- en: '![](img/77109497-bde4-46a5-bcc2-d7ca372aa435.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77109497-bde4-46a5-bcc2-d7ca372aa435.png)'
- en: Save the current scene (page1).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存当前场景（page1）。
- en: Open page2 and follow the same steps to make the page2 button load page1\. That
    is, add an instance of the  `SceneLoader` script class to the main camera, then
    add an `OnClick` event action to the button, which calls `LoadOnClick`, and passes
    the integer 0, so scene page1 is loaded.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开page2，并按照相同的步骤来使page2按钮加载page1。也就是说，将`SceneLoader`脚本类的实例添加到主相机中，然后为按钮添加一个`OnClick`事件动作，调用`LoadOnClick`，并传递整数0，这样就可以加载场景page1。
- en: Save scene page2.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景page2。
- en: When you run the page1 scene, you will be presented with your Main Menu text
    and a button, which when clicked, makes the game load the page2 scene. On scene
    page2, you'll have a button to take you back to page1.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行page1场景时，你会看到主菜单文本和一个按钮，点击这个按钮会使游戏加载page2场景。在场景page2中，你会有一个按钮可以带你回到page1。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created two scenes, and added both of these scenes to the game's build.
    You added a UI Button, and some UI Text to each scene.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了两个场景，并将这两个场景都添加到了游戏的构建中。你为每个场景添加了一个UI按钮和一些UI Text。
- en: Note, the Build sequence of scenes is actually a scripted array, which count
    from 0, then 1, and so on, so page1 has index 0, and page2 has index 1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，场景的构建顺序实际上是一个脚本数组，从0开始计数，然后是1，依此类推，所以page1的索引是0，page2的索引是1。
- en: When a UI Button is added to the Hierarchy panel, a child UI Text object is
    also automatically created, and the content of the Text property of this UI Text
    child is the text that the user sees on the button.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个UI按钮被添加到层级面板中时，也会自动创建一个子UI Text对象，并且这个UI Text子对象的文本属性内容就是用户在按钮上看到的文本。
- en: You created a script class, and added an instance as a component to the Main
    Camera. In fact, it didn't really matter where this script instance was added,
    as long as it was in one of the GameObjects of the scene. This is necessary since
    the `OnClick` event action of a button can only execute a method (function) of
    a component in a GameObject in the scene.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个脚本类，并将其作为一个组件添加到了主相机中。实际上，这个脚本实例添加的位置并不重要，只要它在场景中的某个GameObject中即可。这是必要的，因为按钮的`OnClick`事件动作只能执行场景中GameObject组件的方法（函数）。
- en: For the button of each scene, you then added a new `OnClick` event action, which
    invokes (executes) the `LoadOnClick` method of the SceneLoader scripted component
    in the Main Camera. This method inputs the integer index of the scene in the project's
    Build settings, so that the button on the page1 scene gives integer 1 as the scene
    to be loaded, and the button for page2 gives integer 0.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个场景的按钮，你随后添加了一个新的 `OnClick` 事件动作，该动作调用（执行）主摄像机中 SceneLoader 脚本组件的 `LoadOnClick`
    方法。此方法输入场景在项目构建设置中的整数索引，因此页面1场景上的按钮给出整数 1 作为要加载的场景，而页面2的按钮给出整数 0。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details you don't want to miss.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: Color tint when mouse pointer is over the button
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标指针悬停在按钮上时的颜色渐变
- en: 'There are several ways in which we can visually inform the user that the button
    is interactive when they move their mouse cursor over it. The simplest is to add
    a Color Tint that will appear when the mouse is over the button – this is the
    default **Transition**. With the Button selected in the Hierarchy, choose a tint
    color (for example, red), for the Highlighted Color property of the Button (Script)
    component, in the Inspector tab:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以让我们在用户将鼠标光标移至按钮上时，从视觉上告知用户该按钮是交互式的。最简单的是添加一个当鼠标悬停在按钮上时出现的颜色渐变效果——这是默认的
    **过渡**。在层次结构中选择按钮（脚本）组件，在检查器选项卡中为按钮（脚本）组件的 **高亮颜色** 属性选择一个着色颜色（例如，红色）：
- en: '![](img/d23e51c5-6e25-4999-91db-d9d8079f5233.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d23e51c5-6e25-4999-91db-d9d8079f5233.png)'
- en: 'Another form of visual Transition to inform the user of an active button is
    Sprite Swap. In this case, properties for different images for Targeted/Highlighted/Pressed/Disabled
    are available in the **Inspector** panel. The default Targeted Graphic is the
    built-in Unity **Button (Image)** – this is the grey rounded rectangle default
    when GameObject buttons are created. Dragging in a very different-looking image
    for the **Highlighted** Sprite is an effective alternative to set a Color Tint.
    We have provided a `rainbow.png` image with the project for this recipe that can
    be used for the Button mouse over Highlighted Sprite. The screenshot shows the
    button with this rainbow background image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通知用户活动按钮的视觉过渡形式是 Sprite Swap。在这种情况下，**检查器** 面板中提供了针对目标/高亮/按下/禁用不同图像的属性。默认的目标图形是内置的
    Unity **按钮（图像）**——这是当创建 GameObject 按钮时的灰色圆形矩形默认值。将一个看起来非常不同的图像拖入 **高亮** Sprite
    是设置颜色渐变的有效替代方案。我们为这个菜谱提供了一个 `rainbow.png` 图像，可用于按钮鼠标悬停高亮 Sprite。截图显示了具有这种彩虹背景图像的按钮：
- en: '![](img/1b4ac2db-ba46-4d00-ab55-88fc75d4f8e0.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b4ac2db-ba46-4d00-ab55-88fc75d4f8e0.png)'
- en: Animating button properties on mouse-over
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在鼠标悬停时动画按钮属性
- en: At the end of the previous recipe, we illustrated two ways to visually communicate
    buttons to users. The Animation of button properties can be a highly effective,
    and visually interesting, way to reinforce to the user that the item their mouse
    is currently over is a clickable, active button. One common animation effect is
    for a button to get larger when the mouse is over it, and then it shrinks back
    to its original size when the mouse pointer is moved away. Animation effects are
    achieved by choosing the Animation option for the Transition property of a `Button`
    GameObject, and by creating an animation controller with triggers for the Normal,
    Highlighted, Pressed, and Disabled states.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱的末尾，我们展示了两种向用户传达按钮的方法。按钮属性的动画可以是一种非常有效且视觉上吸引人的方式，以向用户强化他们当前鼠标悬停的项是一个可点击的、活动的按钮。一个常见的动画效果是当鼠标悬停在按钮上时，按钮变大，然后当鼠标指针移开时，它又恢复到原始大小。动画效果是通过为
    `Button` GameObject 的过渡属性选择动画选项，并创建具有正常、高亮、按下和禁用状态触发器的动画控制器来实现的。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To animate a button for enlargement when the mouse is over it (the Highlighted
    state), do the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要在鼠标悬停时（高亮状态）使按钮动画放大，请执行以下操作：
- en: Create a new Unity 2D project.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Create a **UI Button**.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **UI 按钮**。
- en: In the **Inspector Button (Script)** component, set the **Transition** property
    to **Animation**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器按钮（脚本）** 组件中，将 **过渡** 属性设置为 **动画**。
- en: 'Click the **Auto Generate Animation** button (just below the **Disabled Trigger**
    property) for the **Button (Script)** component:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **自动生成动画** 按钮（位于 **禁用触发器** 属性下方）以针对 **按钮（脚本）** 组件：
- en: '![](img/84439d36-92e0-45ef-82a8-734c5ee91987.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84439d36-92e0-45ef-82a8-734c5ee91987.png)'
- en: Save the new controller (in new folder `Animations`), naming it **button-animation-controller**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的控制器（在新的文件夹`Animations`中）保存，命名为**button-animation-controller**。
- en: 'Ensure that the **Button** GameObject is selected in the Hierarchy. In the
    Animation panel, select the **Highlighted** clip from the drop-down menu:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在层次结构中选择**按钮**GameObject。在动画面板中，从下拉菜单中选择**高亮**剪辑：
- en: '![](img/fde4a896-a33a-4d1e-a0f2-29e964ec9a34.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fde4a896-a33a-4d1e-a0f2-29e964ec9a34.png)'
- en: In the **Animation** panel, click on the red record circle button, and then
    click on the **Add Property** button, choosing to record changes to the Rect Transform
    | Scale property.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**面板中，单击红色记录圆圈按钮，然后单击**添加属性**按钮，选择记录Rect Transform | 缩放属性的变化。
- en: 'Two keyframes will have been created. Delete the second one at `1:00` (since
    we don''t want a "bouncing" button):'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建两个关键帧。在`1:00`删除第二个关键帧（因为我们不希望按钮有“弹跳”效果）：
- en: '![](img/dd86535c-4ace-447d-9d88-835b54167f09.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd86535c-4ace-447d-9d88-835b54167f09.png)'
- en: Select the frame at `1:00` by clicking one of the diamonds (both turn blue when
    selected), then press the *Backspace/Delete* key.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击一个钻石（选择时两者都会变为蓝色）来选择`1:00`处的帧，然后按*退格键/删除键*。
- en: Select the first keyframe at `0:00` (the only one now!). In the Inspector, set the
    X and Y scale properties of the **Rect Transform** component to (`1.2, 1.2`).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`0:00`处的第一个关键帧（现在只有一个！）！在检查器中，将**Rect Transform**组件的X和Y缩放属性设置为`1.2, 1.2`。
- en: Click on the red record circle button for the second time to end the recording
    of the animation changes.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二次单击红色记录圆圈按钮以结束动画更改的录制。
- en: Save and run your scene, and you will see that the button smoothly animates
    to get larger when the mouse is over it, and then smoothly returns to its original
    size when the mouse has moved away.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行你的场景，你会看到当鼠标悬停在按钮上时，按钮会平滑地放大，当鼠标移开后，它会平滑地恢复到原始大小。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You have created a button, and set its Transition mode to Animation. This makes
    Unity require an Animation Controller with four states: Normal, Highlighted, Pressed,
    and Disabled. You then made Unity automatically create an Animation Controller
    with these four states.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个按钮，并将其过渡模式设置为动画。这使得Unity需要具有四个状态的动画控制器：正常、高亮、按下和禁用。然后你让Unity自动创建具有这四个状态的动画控制器。
- en: Then, you edited the Animation for the Highlighted (mouse-over) state, deleting
    the second keyframe, and making the only keyframe a version of the Button made
    larger to a scale of 1.2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你编辑了高亮（鼠标悬停）状态的动画，删除了第二个关键帧，并将唯一的关键帧设置为将按钮放大到1.2倍大小的版本。
- en: When the mouse is not over the Button, it's unchanged and Normal state settings
    are used. When the mouse moves over the Button, the Animation Controller smoothly
    in-betweens the settings of the Button to become those of its Highlighted state
    (that is, bigger). When the mouse is moved away from the Button, the Animation
    Controller smoothly in-betweens the settings of the Button to become those of
    its Normal state (that is, its original size).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标不在按钮上时，它保持不变，并使用正常状态设置。当鼠标移到按钮上时，动画控制器平滑地在按钮的设置之间过渡，变为高亮状态的设置（即变大）。当鼠标从按钮移开时，动画控制器平滑地在按钮的设置之间过渡，变为正常状态的设置（即原始大小）。
- en: 'The following web pages offer video and web-based tutorials on UI animations:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下网页提供了关于UI动画的视频和基于网页的教程：
- en: The Unity button transitions tutorial is available at[http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions.](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)
    Ray Wenderlich's great tutorial (part 2), including the button animations, is
    available at[ http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Unity按钮过渡教程可在[http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions](http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions)找到。Ray
    Wenderlich的出色教程（第二部分），包括按钮动画，可在[http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2](http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2)找到。
- en: Organizing image panels and changing panel depths via buttons
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过按钮组织图像面板和更改面板深度
- en: UI Panels are provided by Unity to allow UI controls to be grouped and moved
    together, and also to visually group elements with an Image background (if desired).
    The sibling depth is what determines which UI elements will appear above or below
    others. We can see the sibling depth explicitly in the Hierarchy, since the top-to-bottom
    sequence of UI GameObjects in the Hierarchy sets the sibling depth. So, the first
    item has a depth of 1, the second has a depth of 2, and so on. The UI GameObjects
    with larger sibling depths (further down the Hierarchy and so drawn later) appear
    above the UI GameObjects with lower sibling depths.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了UI面板，允许将UI控件分组并一起移动，并且还可以通过图像背景（如果需要）视觉上分组元素。兄弟深度决定了哪些UI元素将出现在其他元素之上或之下。我们可以在层次结构中明确看到兄弟深度，因为层次结构中UI
    GameObjects的从上到下的顺序设置了兄弟深度。因此，第一个项目深度为1，第二个项目深度为2，依此类推。具有较大兄弟深度（在层次结构中位置更低且绘制较晚）的UI
    GameObjects将出现在具有较小兄弟深度（深度较低）的UI GameObjects之上。
- en: 'In this recipe, we''ll create three UI Panels, each showing a different playing
    card image. We''ll also add four triangle arrangement buttons to change the display
    order (move to bottom, move to top, move up one, and move down one):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建三个UI面板，每个面板显示不同的扑克牌图像。我们还将添加四个三角形排列按钮来更改显示顺序（移至底部、移至顶部、向上移动一个和向下移动一个）：
- en: '![](img/1c677aba-f531-433a-9d1b-6b0df593bc21.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c677aba-f531-433a-9d1b-6b0df593bc21.png)'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you need in a folder named
    `Images` in the `02_03` folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`02_03`文件夹中的`Images`文件夹中准备了所需的图像。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create the UI Panels whose layering can be changed by clicking buttons,
    follow these steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可以通过点击按钮更改分层结构的UI面板，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: 'Create a new **UI Panel** GameObject named **Panel-jack-diamonds**. Do the
    following to this Panel:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**UI面板**GameObject，命名为**Panel-jack-diamonds**。对此面板执行以下操作：
- en: For the **Image (Script)** component, drag the `**jack_of_diamonds**` playing
    card image asset file from the **Project** panel into the **Source Image** property.
    Select the **Color** property and increase the **Alpha** value to `255` (so this
    background image of the panel is no longer partly transparent).
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**图像（脚本）**组件，将**项目**面板中的`**jack_of_diamonds**`扑克牌图像资产文件拖动到**源图像**属性。选择**颜色**属性，并将**透明度**值增加到`255`（这样面板的背景图像就不再部分透明了）。
- en: For the **Rect Transform** property, position it in the middle-center part of
    the screen, and size it with **Width** = `200` and **Height** = `300`.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**矩形变换**属性，将其放置在屏幕的中间中心部分，并使用**宽度** = `200`和**高度** = `300`进行缩放。
- en: Create a **UI Button** named **Button-move-to-front**. In the **Hierarchy**,
    child this button to **Panel-jack-diamonds**. Delete the **Text** child GameObject
    of this button (since we'll use an icon to indicate what this button does).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Button-move-to-front**的**UI按钮**。在**层次结构**中，将此按钮作为子项添加到**Panel-jack-diamonds**。删除此按钮的**文本**子GameObject（因为我们将使用图标来指示此按钮的功能）。
- en: 'With the **Button-move-to-front** GameObject selected in the **Hierarchy**,
    do the following in the Inspector:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**Button-move-to-front**GameObject后，在检查器中执行以下操作：
- en: In the **Rect Transform**, position the button top-center of the player card
    image so that it can be seen at the top of the playing card. Size the image to
    **Width** = `16` and **Height** = `16`. Move the icon image down slightly, by
    setting **Pos Y** = `-5` (to ensure we can see the horizontal bar above the triangle).
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**矩形变换**中，将按钮放置在玩家卡片图像的顶部中心，以便在扑克牌顶部可见。将图像大小调整为**宽度** = `16`和**高度** = `16`。将图标图像向下稍微移动，通过设置**Y位置**
    = `-5`（以确保我们可以看到三角形上方的水平条）。
- en: 'For the **Source Image** property of the **Image (Script)** component, select
    the arrangement triangle icon image: `icon_move_to_front`.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于**图像（脚本）**组件的**源图像**属性，选择排列三角形图标图像：`icon_move_to_front`。
- en: Add an **OnClick** event handler by clicking on the plus sign (**+**) at the
    bottom of the **Button (Script)** component.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击**按钮（脚本）**组件底部的加号（**+**）添加一个**OnClick**事件处理器。
- en: Drag **Panel-jack-diamonds** from the **Hierarchy** over to the **Object** slot
    (immediately below the menu saying **Runtime Only**).
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Panel-jack-diamonds**从**层次结构**拖动到**对象**槽（位于**仅运行时**菜单下方）。
- en: 'Select the `RectTransform.SetAsLastSibling` method from the drop-down function
    list (initially showing **No Function**):'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从下拉函数列表中选择`RectTransform.SetAsLastSibling`方法（最初显示为**无函数**）：
- en: '![](img/4254ab98-f133-4652-b80e-46b7decce6cb.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4254ab98-f133-4652-b80e-46b7decce6cb.png)'
- en: Repeat step 2; create a second Panel named **Panel-2-diamonds** with its own
    **move-to-front** button, and **Source Image** of `2_of_diamonds`. Move and position
    this new panel slightly to the right of **Panel-jack-diamonds**, allowing both
    the **move-to-front** buttons to be seen.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2；创建一个名为**Panel-2-diamonds**的第二个面板，并为其自己的**移动到前面**按钮和`2_of_diamonds`的**源图像**。将这个新面板稍微向**Panel-jack-diamonds**的右侧移动，以便两个**移动到前面**按钮都能被看到。
- en: Save your **Scene** and run the game. You will be able to click the **move-to-front**
    button on either of the cards to move that card's panel to the front. If you run
    the game with the Game panel not maximized, you'll actually see the panels changing
    order in the list of the children of the **Canvas** in the **Hierarchy**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的**场景**并运行游戏。你将能够点击任何一张卡片上的**移动到前面**按钮，将那张卡片的面板移动到前面。如果你以未最大化的游戏面板运行游戏，你实际上会看到**层次结构**中**Canvas**的子项列表中的面板顺序发生变化。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have created two **UI Panels**, each panel contains a background **Image**
    of a playing card and a **UI** **Button** whose action will make its parent panel
    move to the front. You set the **Alpha** (transparency) setting of the background
    image's **Color** to `255` (no transparency).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了两个**UI面板**，每个面板包含一张玩牌的背景**图像**和一个**UI** **按钮**，该按钮的动作将使其父面板移动到前面。你将背景图像的**颜色**的**Alpha**（透明度）设置为`255`（无透明度）。
- en: You added an `OnClick` event action to the button of each **UI** **Panel**.
    The action sends a `SetAsLastSibling` message to the **Button's** **Panel** parent.
    When the **OnClick** message is received, the clicked **Panel** is moved to the
    bottom (end) of the sequence of GameObjects in the **Canvas**, and therefore this
    **Panel** is drawn last of the **Canvas** objects, and so appears visually in
    front of all other GameObjects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你为每个**UI** **面板**的按钮添加了一个`OnClick`事件动作。该动作向按钮的**面板**父级发送`SetAsLastSibling`消息。当接收到**OnClick**消息时，被点击的**面板**被移动到GameObject序列的底部（末尾），因此这个**面板**在**Canvas**对象中最后被绘制，因此看起来在所有其他GameObject之前。
- en: The button's action illustrates how the **OnClick** function does not have to
    be the calling of a public method of a scripted component of an object, but it
    can be sending a message to one of the non-scripted components of the targeted
    GameObject. In this recipe, we send the `**SetAsLastSibling**` message to the
    **Rect Transform** of the Panel where the Button is located.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的动作说明了**OnClick**函数不必是调用对象脚本组件的公共方法，而是可以向目标GameObject的非脚本组件发送消息。在这个菜谱中，我们向按钮所在的**面板**的**Rect
    Transform**发送`**SetAsLastSibling**`消息。
- en: There's more...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details you don't want to miss.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Moving up or down by just one position, using scripted methods
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只通过一个位置上移或下移，使用脚本方法
- en: 'While the **Rect Transform** offers a useful `SetAsLastSibling` (move to front)
    and `SetAsFirstSibling` (move to back), and even `SetSiblingIndex` (if we knew
    exactly what position in the sequence to type in), there isn''t a built-in way
    to make an element move up or down just one position in the sequence of GameObjects
    in the **Hierarchy**. However, we can write two straightforward methods in C#
    to do this, and we can add buttons to call these methods, providing full control
    of the top-to-bottom arrangement of the UI controls on the screen. To implement
    four buttons (move-to-front/move-to-back/up one/down one), do the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**矩形变换**提供了有用的`SetAsLastSibling`（移动到前面）和`SetAsFirstSibling`（移动到后面），甚至`SetSiblingIndex`（如果我们知道确切的位置），但在**层次结构**中GameObject的序列中并没有内置的方法来使一个元素只向上或向下移动一个位置。然而，我们可以用C#编写两个简单的方法来做这件事，并且我们可以添加按钮来调用这些方法，从而提供对屏幕上UI控件从上到下排列的完全控制。要实现四个按钮（移动到前面/移动到后面/上移一个/下移一个），请按照以下步骤操作：
- en: 'Create a C# script class called `ArrangeActions`, containing the following
    code, and add an instance as a scripted component to each of your **Panels**:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ArrangeActions`的C#脚本类，包含以下代码，并将其作为脚本组件添加到每个面板中：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Add a second **UI Button** to each card panel, this time using the arrangement
    triangle icon image called `icon_move_to_front`, and set the **OnClick** event
    function for these buttons to `SetAsFirstSibling`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个卡片面板上添加第二个**UI按钮**，这次使用名为`icon_move_to_front`的排列三角形图标图像，并将这些按钮的**OnClick**事件函数设置为`SetAsFirstSibling`。
- en: 'Add two further **UI Buttons** to each card panel with the up and down triangle
    icon images: `icon_down_one` and `icon_up_one`. Set the **OnClick** event-handler
    function for the down-one buttons to call the `MoveDownOne()` method, and set
    the functions for the up-one buttons to call the `MoveUpOne()` method.'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个卡片面板上添加两个带有向上和向下三角形图标图像的**UI按钮**：`icon_down_one`和`icon_up_one`。将向下按钮的**OnClick**事件处理函数设置为调用`MoveDownOne()`方法，并将向上按钮的函数设置为调用`MoveUpOne()`方法。
- en: Copy one of the **UI Panels** to create a third card (this time showing the
    Ace of diamonds). Arrange the three cards so that you can see all four buttons
    for at least two of the cards, even when those cards are at the bottom (see the
    screenshot at the beginning of this recipe).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制一个**UI面板**以创建第三个卡片（这次显示红桃A）。排列三个卡片，以便至少可以看到两张卡片的四个按钮，即使这些卡片位于底部（参见本食谱开头的截图）。
- en: Save the **Scene** and run your game. You will now have full control over the
    layering of the three card panels.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存**场景**并运行你的游戏。现在，你可以完全控制三个卡片面板的分层。
- en: 'Note, we should avoid *negative* sibling depths, so we should probably test
    for the currentSiblingIndex value before subtracting 1:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们应该避免**负**兄弟深度，因此在减去1之前，我们应该测试当前兄弟索引值：
- en: '`if(currentSiblingIndex > 0)` `      panelRectTransform.SetSiblingIndex( currentSiblingIndex
    - 1 );`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(currentSiblingIndex > 0)` `      panelRectTransform.SetSiblingIndex( currentSiblingIndex
    - 1 );`'
- en: Displaying the value of an interactive UI Slider
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示交互式UI滑块的值
- en: 'This recipe illustrates how to create an interactive **UI Slider**, and execute
    a C# method each time the user changes the **UI Slider** value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱说明了如何创建一个交互式**UI滑块**，并在用户更改**UI滑块**值时执行C#方法：
- en: '![](img/05acc1b3-9377-40c3-a4a7-ba89420cb03a.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/05acc1b3-9377-40c3-a4a7-ba89420cb03a.png)'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a **UI Slider** and display its value on the screen, follow these
    steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建**UI滑块**并在屏幕上显示其值，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D项目。
- en: Add a **UI Text** GameObject to the scene with a **Font** size of `30` and placeholder
    text, such as slider value here (this text will be replaced with the slider value
    when the scene starts). Set **Horizontal-** and **Vertical- Overflow** to **Overflow**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个**UI文本**GameObject，字体大小为`30`，占位文本例如滑块值在此处（当场景开始时，此文本将被滑块值替换）。将**水平**和**垂直**溢出设置为**溢出**。
- en: 'In the **Hierarchy** add a **UI Slider **GameObject to the scene – choose menu:
    GameObject | UI | Slider.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中添加一个**UI滑块**GameObject到场景中 - 选择菜单：GameObject | UI | Slider。
- en: In the **Inspector**, modify the settings for the position of the **UI Slider**
    GameObject's **Rect Transform** to the top-middle part of the screen.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，修改**UI滑块**GameObject的**矩形变换**位置设置，使其位于屏幕的顶部中间部分。
- en: In the **Inspector**, modify settings for **Position** of the **UI Text's Rect
    Transform** to just below the slider (top, middle, then **Pos Y** = `-30`).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，修改**UI文本的矩形变换**的**位置**设置，使其位于滑块下方（顶部，中间，然后**Pos Y** = `-30`）。
- en: 'In the **Inspector**, set the **UI Slider''s Min Value** to `0`, the **Max
    Value** to `20`, and check the **Whole Numbers** checkbox:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**UI滑块的最小值**设置为`0`，将**最大值**设置为`20`，并勾选**整数**复选框：
- en: '![](img/c24362c0-a292-4e65-8b9c-952697a07e82.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c24362c0-a292-4e65-8b9c-952697a07e82.png)'
- en: 'Create a C# script class called `SliderValueToText`, containing the following
    code, and add an instance as a scripted component to the **Text** GameObject:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SliderValueToText`的C#脚本类，包含以下代码，并将其作为脚本组件添加到**文本**GameObject中：
- en: '[PRE2]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ensure that the **Text** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector**, drag the **Slider** GameObject into the public **Slider
    UI** variable slot for the **Slider Value To Text (Script)** scripted component:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**文本**GameObject。然后，在**检查器**中，将**滑块**GameObject拖动到**滑块值到文本（脚本）**脚本组件的公共**滑块UI**变量槽中：
- en: '![](img/e06acc58-c7da-40a5-aea4-42725c00ddfe.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e06acc58-c7da-40a5-aea4-42725c00ddfe.png)'
- en: 'Ensure that the **Slider** GameObject is selected in the **Hierarchy**. Then,
    in the **Inspector**, drag the **Text** GameObject into the public **None (Object)**
    slot for the **Slider (Script)** scripted component, in the section for **On Value
    Changed (Single)** - as shown in the screenshot:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**中选择了**滑块**GameObject。然后，在**检查器**中，将**文本**GameObject拖动到**滑块（脚本）**脚本组件的公共**None
    (Object)**槽中，在**单次值更改（单次）**部分，如图所示：
- en: '![](img/52ff1c10-af95-4396-94aa-eef952d24413.png)**Registering an object to
    receive UI event messages**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/52ff1c10-af95-4396-94aa-eef952d24413.png)**注册对象以接收UI事件消息**'
- en: You have now told Unity to which object a message should be sent each time the
    slider is changed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已告诉Unity每次滑块改变时应该向哪个对象发送消息。
- en: 'From the drop-down menu, select **SliderValueToText** and the `ShowSliderValue()`
    method, as shown in the following screenshot. This means that each time the slider
    is updated, the `ShowSliderValue()` method, in the scripted object, in the **Text** GameObject
    will be executed:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**SliderValueToText**和`ShowSliderValue()`方法，如图下截图所示。这意味着每次滑块更新时，脚本对象中的`ShowSliderValue()`方法，在**Text**GameObject中将被执行：
- en: '![](img/5b3df604-b62e-435b-b6a2-9b10347a1f6c.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b3df604-b62e-435b-b6a2-9b10347a1f6c.png)'
- en: When you run the **Scene**, you will now see a **UI Slider**. Below it, you
    will see a text message in the form `Slider value = <n>`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行**场景**时，您现在将看到一个**UI Slider**。在其下方，您将看到一个形式为`Slider value = <n>`的文本消息。
- en: Each time the **UI Slider** is moved, the text value shown will be (almost)
    instantly updated. The values should range from `0` (the leftmost of the slider)
    to `20` (the rightmost of the slider).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次移动**UI Slider**时，显示的文本值将（几乎）立即更新。值应从`0`（滑块的左侧）到`20`（滑块的右侧）。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a **UI Slider** GameObject, and set it to be whole numbers in the
    range of `0` ... `20`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建一个**UI Slider**GameObject，并将其设置为范围在`0`到`20`之间的整数。
- en: You have added an instance of the `SliderValueToText` C# script class to the **UI
    Text **GameObject.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将`SliderValueToText` C#脚本类的一个实例添加到**UI Text**GameObject中。
- en: The `Awake()` method caches references to the Text component in the textSliderValue
    variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()`方法将Text组件的引用缓存到textSliderValue变量中。'
- en: The `Start()` method invokes the `ShowSliderValue()` method, so that the display
    is correct when the scene begins (that is, the initial slider value is displayed).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法调用`ShowSliderValue()`方法，以确保场景开始时显示正确（即，显示初始滑块值）。'
- en: The `ShowSliderValue()` method gets the value of the slider and then updates
    the text displayed to be a message in the form of `Slider value = <n>`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowSliderValue()`方法获取滑块的值，然后更新显示的文本，使其成为形式为`Slider value = <n>`的消息。'
- en: You added the `ShowSliderValue()` method of the **SliderValueToText** scripted
    component to the **Slider** GameObject's list of **On Value Changed **event listeners.
    So, each time the slider value changes, it sends a message to call the `ShowSliderValue()`
    method, and so the new value is updated on the screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`SliderValueToText`脚本组件的`ShowSliderValue()`方法添加到**Slider**GameObject的**On
    Value Changed**事件监听器列表中。因此，每次滑块值改变时，它会发送一个消息调用`ShowSliderValue()`方法，从而在屏幕上更新新的值。
- en: Displaying a countdown timer graphically with a UI Slider
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI Slider图形显示倒计时计时器
- en: 'There are many cases where we wish to inform the player of the proportion of
    time remaining, or at the completion of some value at a point in time, for example,
    a loading progress bar, the time or health remaining compared to the starting
    maximum, or how much the player has filled up their water bottle from the fountain
    of youth. In this recipe, we''ll illustrate how to remove the interactive "handle"
    of a **UI Slider**, and change the size and color of its components to provide
    us with an easy-to-use, general purpose progress/proportion bar. In this recipe,
    we''ll use our modified **UI Slider** to graphically present to the user how much
    time remains for a countdown timer:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望通知玩家剩余时间的比例，或在某个时间点的某些值完成时，例如，一个加载进度条，剩余时间或健康与起始最大值的比较，或者玩家从青春之泉中装满水壶的程度。在这个菜谱中，我们将说明如何移除**UI
    Slider**的交互式“手柄”，并更改其组件的大小和颜色，以便我们有一个易于使用的通用进度/比例条。在这个菜谱中，我们将使用修改后的**UI Slider**来图形化地向用户展示倒计时计时器剩余的时间：
- en: '![](img/17ced000-edba-4800-9630-5d537802d356.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17ced000-edba-4800-9630-5d537802d356.png)'
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the script and images that you need in the
    folders named `_Scripts` and Images in the `02_05` folder.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`02_05`文件夹中的`_Scripts`和Images文件夹中准备了您需要的脚本和图像。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a digital countdown timer with a graphical display, follow these
    steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个带图形显示的数字倒计时计时器，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D项目。
- en: Import the `**CountdownTimer**` script and the `red_square` and `green_square`
    images to this project.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`**CountdownTimer**`脚本以及`red_square`和`green_square`图像导入到这个项目中。
- en: Add a **UI Text** GameObject to the scene with a **Font** size of `30` and placeholder
    text such as **UI S****lider** value here (this text will be replaced with the
    slider value when the scene starts). Set **Horizontal-** and **Vertical- Overflow**
    to **Overflow**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个具有 **字体大小** 为 `30` 和占位文本，如 **UI S****lider** 值在这里（此文本将在场景开始时替换为滑块值）。设置
    **水平** 和 **垂直** 溢出为 **溢出**。
- en: 'In the **Hierarchy**, add a** Slider** GameObject to the scene – choose menu:
    `GameObject | UI | Slider`.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中，将一个 **滑块** 游戏对象添加到场景中——选择菜单：`GameObject | UI | Slider`。
- en: In the **Inspector**, modify the settings for the **Position** of the** Slider**
    GameObject's **Rect Transform** to the top-middle part of the screen.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中，修改 **滑块** 游戏对象的 **矩形变换** 的 **位置** 设置为屏幕的顶部中间部分。
- en: Ensure that the **Slider** GameObject is selected in the **Hierarchy**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **层次结构** 中选择了 **滑块** 游戏对象。
- en: Deactivate the **Handle Slide Area** child GameObject (by unchecking it)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用 **滑动区域处理** 子游戏对象的激活（通过取消选中它）
- en: 'You''ll see the "drag circle" disappear in the **Game** panel (the user will
    not be dragging the slider, since we want this slider to be display-only):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在 **游戏** 面板中看到“拖动圆圈”消失（用户不会拖动滑块，因为我们希望这个滑块仅用于显示）：
- en: '![](img/cd18eb19-ba49-4761-bc8b-2059bbd0e4f2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd18eb19-ba49-4761-bc8b-2059bbd0e4f2.png)'
- en: 'Select the **Background** child:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **背景** 子项：
- en: Drag the `red_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector**
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `red_square` 图像拖动到 **检查器** 中 **图像（脚本）** 组件的 **源图像** 属性。
- en: 'Select the Fill child of the Fill Area child:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择填充区域的子项：
- en: Drag the `green_square` image into the **Source Image** property of the **Image
    (Script)** component in the **Inspector**
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `green_square` 图像拖动到 **检查器** 中 **图像（脚本）** 组件的 **源图像** 属性。
- en: 'Select the **Fill Area** child:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **填充区域** 子项：
- en: In the **Rect Transform** component, use the **Anchors** preset position of
    left-middle
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **矩形变换** 组件中，使用 **锚点** 预设位置为左中：
- en: 'Set **Width** to `155` and **Height** to `12`:'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 **宽度** 设置为 `155` 和 **高度** 设置为 `12`：
- en: '![](img/8666f436-e0d5-4ef4-84c5-61d9b833df10.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8666f436-e0d5-4ef4-84c5-61d9b833df10.png)'
- en: 'Create a C# script class called `SliderTimerDisplay` that contains the following
    code, and add an instance as a scripted component to the **Slider** GameObject:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SliderTimerDisplay` 的 C# 脚本类，包含以下代码，并将其作为脚本组件添加到 **滑块** 游戏对象中：
- en: '[PRE3]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run your game and you will see the slider move with each second, revealing more
    and more of the red background to indicate the time remaining.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的游戏，你会看到滑块每秒移动，逐渐显示更多的红色背景，以指示剩余时间。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You hid the **Handle Slide Area** child so that the **UI Slider** is for display
    only, and cannot be interacted with by the user. The **Background** color of the
    **UI Slider** was set to red, so that, as the counter goes down, more and more
    red is revealed – warning the user that the time is running out.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你隐藏了 **滑动区域处理** 子游戏对象，这样 **UI 滑块** 仅用于显示，用户无法与之交互。**UI 滑块** 的 **背景** 颜色被设置为红色，因此，随着计数器的下降，越来越多的红色被揭示——警告用户时间正在流逝。
- en: The **Fill** of the **UI Slider** was set to green, so that the proportion remaining
    is displayed in green – the more green displayed, the greater the value of the
    slider/timer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI 滑块** 的 **填充** 被设置为绿色，这样剩余的比例就显示为绿色——显示的绿色越多，滑块/计时器的值就越大。'
- en: An instance of the provided **CountdownTimer** script class was automatically
    added as a component to the Slider via `[RequireComponent(...)]`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自动将提供的 **倒计时计时器** 脚本类的一个实例添加为滑块的组件，通过 `[RequireComponent(...)]`。
- en: The `Awake()` method caches references to the **CountdownTimer** and **Slider**
    components in the `countdownTimer` and `sliderUI` variables.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()` 方法将 `countdownTimer` 和 `sliderUI` 变量中 **倒计时计时器** 和 **滑块** 组件的引用缓存起来。'
- en: The `Start()` method calls the `SetupSlider()` method and then resets the countdown
    timer to start counting down from 30 seconds.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()` 方法调用 `SetupSlider()` 方法，然后重置倒计时计时器，从 30 秒开始倒计时。'
- en: The `SetupSlider()` method sets up this slider for float (decimal) values between
    `0.0` and `1.0`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupSlider()` 方法设置此滑块用于浮点（小数）值，范围在 `0.0` 到 `1.0` 之间。'
- en: In each frame, the `Update()` method sets the slider value to the float returned
    by calling the `GetProportionRemaining()` method from the running timer. At runtime,
    Unity adjusts the proportion of red/green displayed in the Slider to match the
    slider's value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中，`Update()` 方法将滑块值设置为从运行中的计时器调用 `GetProportionRemaining()` 方法返回的浮点数。在运行时，Unity
    调整滑块中显示的红色/绿色的比例，以匹配滑块的值。
- en: Setting custom mouse cursors for 2D and 3D GameObjects
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为2D和3D GameObject设置自定义鼠标光标
- en: 'Cursor icons are often used to indicate the nature of the interaction that
    can be done with the mouse. Zooming, for instance, might be illustrated by a magnifying
    glass; shooting, on the other hand, is usually represented by a stylized target.
    In this recipe, we will learn how to implement custom mouse cursor icons to better
    illustrate your gameplay – or just to escape the Windows, macOS, and Linux default
    UI:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 光标图标通常用于指示可以使用鼠标进行的交互性质。例如，缩放可能由放大镜表示；另一方面，射击通常由一个风格化的靶子表示。在这个菜谱中，我们将学习如何实现自定义鼠标光标图标，以更好地说明你的游戏玩法——或者只是逃离Windows、macOS和Linux的默认UI：
- en: '![](img/01301f05-5a91-4ed1-bbc6-28b3a4922d95.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01301f05-5a91-4ed1-bbc6-28b3a4922d95.png)'
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the folders that you'll need in the `02_06`
    folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`02_06`文件夹中准备了你需要用到的文件夹。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make a custom cursor appear when the mouse is over a GameObject, follow
    these steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要在鼠标悬停在GameObject上时显示自定义光标，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Import the provided folder, called `Images`. Select the `unity_logo` image in
    the **Project** panel, and in the **Inspector** change the **Texture T**ype to
    **Sprite (2D and UI)**. This is because we'll use this image for a **2D Sprite**
    GameObject, and it requires this **Texture Type** (it won't work with the **Default**
    type).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的名为`Images`的文件夹。在**项目**面板中选择`unity_logo`图像，并在**检查器**中将**纹理类型**更改为**Sprite
    (2D and UI)**。这是因为我们将使用这个图像作为**2D Sprite**GameObject，它需要这种**纹理类型**（使用**默认**类型将不起作用）。
- en: Add a **2D Object | Sprite** GameObject to the scene. Name this **New Sprite**,
    if this wasn't the default name when created.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向场景添加一个**2D Object | Sprite**GameObject。如果创建时不是默认名称，请将其命名为**New Sprite**。
- en: In the **Inspector**, set the **Sprite** property of the **Sprite Renderer**
    component to the `unity_logo` image. In the GameObjects **Transform** component,
    set the scaling to `(3,3,3)`, and if necessary, reposition the **Sprite** to be
    centered in the **Game** panel when the **Scene** runs.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**Sprite**属性设置为**Sprite Renderer**组件的`unity_logo`图像。在GameObject的**Transform**组件中，设置缩放为`(3,3,3)`，并在必要时，当**场景**运行时将**Sprite**重新定位到**游戏**面板的中心。
- en: Add to the **Sprite** GameObject a `Physics 2D | Box Collider`. This is needed
    for this GameObject to receive `OnMouseEnter` and `OnMouseExit` event messages.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向**Sprite**GameObject添加一个`Physics 2D | Box Collider`。这是必要的，因为这样这个GameObject才能接收`OnMouseEnter`和`OnMouseExit`事件消息。
- en: Import the provided folder called `IconsCursors`. Select all three images in
    the **Project** panel, and in the **Inspector**, change the **Texture Type** to
    **Cursor**. This will allow us to use these images as mouse cursors without any
    errors occurring.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的名为`IconsCursors`的文件夹。在**项目**面板中选择所有三个图像，并在**检查器**中，将**纹理类型**更改为**Cursor**。这将允许我们使用这些图像作为鼠标光标而不会出现任何错误。
- en: 'Create a C# script class called `CustomCursorPointer`, containing the following
    code, and add an instance as a scripted component to the **New Sprite** GameObject:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomCursorPointer`的C#脚本类，包含以下代码，并将其作为一个脚本组件添加到**New Sprite**GameObject中：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Event methods `OnMouseEnter()` and `OnMouseExit()` have been deliberately declared
    as public. This will allow these methods to also be called from UI GameObjects
    when they receive the `OnPointerEnterExit` events.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 故意将事件方法`OnMouseEnter()`和`OnMouseExit()`声明为公共。这将允许这些方法在UI GameObject接收到`OnPointerEnterExit`事件时也能被调用。
- en: With the **New Sprite** item selected in the **Hierarchy**, drag the `CursorTarget`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector** for
    the **Customer Cursor Pointer (Script)** component.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**New Sprite**项目，将`CursorTarget`图像拖放到**Customer Cursor Pointer (Script)**组件的**检查器**中的公共**Cursor
    Texture 2D**变量槽中。
- en: Save and run the current **Scene**. When the mouse pointer moves over the Unity
    logo sprite, it will change to the custom **CursorTarget** image that you chose.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行当前**场景**。当鼠标指针移动到Unity标志sprite上时，它将更改为你选择的自定义**CursorTarget**图像。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a **Sprite** GameObject and assigned it the Unity logo image. You
    imported some cursor images, and set their **Texture** **Type** to **Cursor**,
    so they could be used to change the image for the user's mouse pointer. You added
    a **Box Collider** to the sprite GameObject so that it would receive `OnMouseEnter`
    and `OnMouseExit` event messages.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个 **Sprite** 游戏对象，并将其分配给 Unity 标志图像。您导入了一些光标图像，并将它们的 **纹理** **类型** 设置为
    **光标**，以便它们可以用来更改用户的鼠标指针的图像。您向精灵游戏对象添加了一个 **Box Collider**，以便它能够接收 `OnMouseEnter`
    和 `OnMouseExit` 事件消息。
- en: You created the `**CustomCursorPointer**` script class, and added an instance-object
    of this class to the sprite GameObject – this script tells Unity to change the
    mouse pointer when an `OnMouseEnter` message is received, that is, when the user's
    mouse pointer moves over the part of the screen where the Unity logo sprite image
    is being rendered. When an `OnMouseExit` event is received (the users mouse pointer
    is no longer over the cube part of the screen), the system is told to go back
    to the operating system's default cursor. This event should be received within
    a few milliseconds of the user's mouse exiting from the collider.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了 `**CustomCursorPointer**` 脚本类，并将其实例对象添加到精灵游戏对象中 - 此脚本告诉 Unity 在接收到 `OnMouseEnter`
    消息时更改鼠标指针，即当用户的鼠标指针移动到屏幕上正在渲染 Unity 标志精灵图像的部分时。当接收到 `OnMouseExit` 事件（用户的鼠标指针不再位于屏幕的立方体部分）时，系统被告知返回到操作系统的默认光标。此事件应在用户鼠标退出碰撞器后的几毫秒内接收到。
- en: Finally, you selected the image `CursorTarget` to be the custom mouse-pointer
    cursor image the user sees when the mouse is over the Unity logo image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您选择了图像 `CursorTarget` 作为用户在鼠标悬停在 Unity 标志图像上时看到的自定义鼠标指针图像。
- en: Setting custom mouse cursors for UI controls
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 UI 控件设置自定义鼠标光标
- en: 'The previous recipe demonstrated how to change the mouse pointer for 2D and
    3D GameObjects receiving `OnMouseEnter` and `OnMouseExit` events. Unity UI controls
    do not receive `OnMouseEnter` and `OnMouseExit` events. Instead, UI controls can
    be made to respond to `PointerEnter` and `PointerExit` events if we add a special
    **Event Trigger** component to the UI GameObject. In this recipe, we''ll change
    the mouse pointer to a custom magnifying glass cursor when it moves over a **UI
    Button** GameObject:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的菜谱演示了如何更改接收 `OnMouseEnter` 和 `OnMouseExit` 事件的 2D 和 3D 游戏对象的鼠标指针。Unity UI
    控件不会接收 `OnMouseEnter` 和 `OnMouseExit` 事件。相反，如果我们在 UI 游戏对象中添加一个特殊的 **事件触发器** 组件，UI
    控件可以响应 `PointerEnter` 和 `PointerExit` 事件。在这个菜谱中，我们将当鼠标移动到 **UI 按钮** 游戏对象上时，将鼠标指针更改为自定义放大镜光标。
- en: '![](img/21b28fb7-a234-420a-a718-912a3c5f0b93.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b28fb7-a234-420a-a718-912a3c5f0b93.png)'
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll use the same asset files as for the previous recipe,
    and its `CustomCursorPointer` C# script class, all of which can be found in the
    `02_07` folder.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用与上一个菜谱相同的资产文件和 `CustomCursorPointer` C# 脚本类，所有这些都可以在 `02_07` 文件夹中找到。
- en: How to do it...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To set a custom mouse pointer when the mouse moves over a UI control GameObject,
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要在鼠标移动到 UI 控件游戏对象上时设置自定义鼠标指针，
- en: 'do the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: Create a new Unity 2D project.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: Import the provided `IconsCursors` folder. Select all three images in the **Project**
    panel, and in the **Inspector** change the **Texture Type** to **Cursor**. This
    will allow us to use these images as mouse cursors without any errors occurring.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 `IconsCursors` 文件夹。在 **项目** 面板中选择所有三个图像，然后在 **检查器** 中将 **纹理类型** 更改为 **光标**。这将使我们能够使用这些图像作为鼠标光标而不会出现任何错误。
- en: Import the provided `_Scripts` folder, containing the `CustomCursorPointer` C# script
    class.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的 `_Scripts` 文件夹，其中包含 `CustomCursorPointer` C# 脚本类。
- en: Add a **UI Button** GameObject to the scene, leaving this named as **Button**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个 **UI 按钮** 游戏对象，保留其名称为 **按钮**。
- en: Add an instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CustomCursorPointer` C# 脚本类的实例添加到 **按钮** 游戏对象中。
- en: With the **Button** GameObject selected in the **Hierarchy**, drag the `CursorZoom`
    image into the public **Cursor Texture 2D** variable slot in the **Inspector** for
    the **Customer Cursor Pointer (Script)** component.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 中选择 **按钮** 游戏对象后，将 `CursorZoom` 图像拖放到 **检查器** 中 **Customer Cursor
    Pointer (Script)** 组件的公共 **Cursor Texture 2D** 变量槽中。
- en: 'In the **Inspector**, add an **Event Triggers** component to GameObject **Button**.
    Choose menu: Add Component | Event | Event Trigger.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 中，为 **按钮** 游戏对象添加一个 **事件触发器** 组件。选择菜单：添加组件 | 事件 | 事件触发器。
- en: Add a **PointerEnter** event to your **Event Trigger** component, click on the
    plus (**+**) button to add an event handler slot, and drag GameObject **Button**
    into the **Object** slot.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**事件触发器**组件中添加一个**PointerEnter**事件，点击加号（**+**）按钮以添加事件处理程序槽，并将GameObject **按钮**拖入**对象**槽中。
- en: 'From the **Function** drop-down menu, choose **CustomCursorPointer** and then
    choose the `OnMouseEnter` method:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**函数**下拉菜单中选择**CustomCursorPointer**，然后选择`OnMouseEnter`方法：
- en: '![](img/ca3871d1-3bfa-4acf-9a95-b3b2be861d1f.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca3871d1-3bfa-4acf-9a95-b3b2be861d1f.png)'
- en: Add a **Pointer Exit** event to your **Event Trigger** component, and make it
    call the `OnMouseExit()` method from **CustomCursorPointer** when this event is
    received.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**事件触发器**组件中添加一个**Pointer Exit**事件，并在接收到此事件时调用**CustomCursorPointer**的`OnMouseExit()`方法。
- en: Save and run the current **Scene**. When the mouse pointer moves over the **UI ****Button**,
    it will change to the custom `**CursorZoom**` image that you chose.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行当前**场景**。当鼠标指针移至**UI按钮**上时，它将变为您选择的自定义`**CursorZoom**`图像。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have imported some cursor images, and set their **Texture Type** to **Cursor**,
    so they could be used to change the image for the user's mouse pointer. You also
    created a **UI Button** GameObject and added to it an **Event Triggers** component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您已导入了一些光标图像，并将它们的**纹理类型**设置为**光标**，以便它们可以用于更改用户鼠标指针的图像。您还创建了一个**UI按钮**GameObject，并为其添加了一个**事件触发器**组件。
- en: You added an instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject, and selected the magnifying-glass-style `CursorZoom` image.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将`CustomCursorPointer` C#脚本类的实例添加到**按钮**GameObject中，并选择了放大镜风格的`CursorZoom`图像。
- en: You created a **PointerEnter** event, and linked it to invoke the `OnMouseEnter`
    method of the instance of the `CustomCursorPointer` script in the **Button** GameObject (which
    changes the mouse pointer image to the custom mouse cursor).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个**PointerEnter**事件，并将其链接到调用**按钮**GameObject中`CustomCursorPointer`脚本的`OnMouseEnter`方法（这将鼠标指针图像更改为自定义鼠标光标）。
- en: You created a **PointerExit** event, and linked it to invoke the `OnMouseExit`
    method of the instance of the `CustomCursorPointer` C# script class to the **Button**
    GameObject (which resets the mouse cursor back to the system default).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个**PointerExit**事件，并将其链接到调用`CustomCursorPointer` C#脚本类的实例的`OnMouseExit`方法，将其链接到**按钮**GameObject（这将鼠标光标重置为系统默认值）。
- en: Essentially, you have redirected **PointerEnter/Exit** events to invoke the
    **OnMouseEnter/Exit** methods of the `CustomCursorPointer` C# script class so
    we can manage custom cursors for 2D, 3D, and UI GameObjects with the same scripting
    methods.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您已将**PointerEnter/Exit**事件重定向以调用`CustomCursorPointer` C#脚本类的**OnMouseEnter/Exit**方法，这样我们就可以使用相同的脚本方法来管理2D、3D和UI
    GameObjects的自定义光标。
- en: Interactive text entry with an Input Field
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入字段的交互式文本输入
- en: 'While often we just wish to display non-interactive text messages to the user,
    there are times (such as name entry for high scores) where we want the user to
    be able to enter text or numbers into our game. Unity provides the UI Input Field
    component for this purpose. In this recipe, we''ll create an Input Field that
    prompts the user to enter their name:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常只想向用户显示非交互式文本消息，但在某些情况下（如输入高分时的名字），我们希望用户能够将文本或数字输入到我们的游戏中。Unity为此提供了UI输入字段组件。在此配方中，我们将创建一个输入字段，提示用户输入他们的名字：
- en: '![](img/b3f06f63-a811-466f-8a4c-e418768a5568.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3f06f63-a811-466f-8a4c-e418768a5568.png)'
- en: Having interactive text on the screen isn't of much use unless we can *retrieve*
    the text entered to use in our game logic, and we may need to know each time the
    user changes the text content and act accordingly. This recipe adds an event-handler
    C# script that detects each time the user has completed editing the text, and
    updates an extra message on screen confirming the newly-entered content.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们能够*检索*输入的文本以用于游戏逻辑，否则在屏幕上显示交互式文本并没有多大用处，我们可能还需要知道每次用户更改文本内容时，并据此采取行动。此配方添加了一个事件处理程序C#脚本，它检测每次用户完成文本编辑，并在屏幕上更新一条额外的消息以确认新输入的内容。
- en: How to do it...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create an interactive text input box to the user, follow these steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个交互式文本输入框供用户使用，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: In the **Inspector**, change the background of the **Main Camera** to solid
    white.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**主摄像机**的背景更改为纯白色。
- en: Add a **UI Input Field** to the **Scene**. Position this to the top-center of
    the screen.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**UI输入字段**添加到**场景**中。将其定位在屏幕的顶部中央。
- en: Add a **UI Text** GameObject to the scene, naming it **Text-prompt**. Position
    this to the left of **Input Field**. Change the **Text** property of this GameObject
    to Name:.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加一个**UI Text**游戏对象，命名为**Text-prompt**。将其放置在**Input Field**的左侧。将此游戏对象的**Text**属性更改为Name:。
- en: Create a new **UI Text** GameObject named **Text-display**. Position this to
    the right of the **Input Text** control, and color its text red.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**UI Text**游戏对象，命名为**Text-display**。将其放置在**Input Text**控制的右侧，并将文本颜色设置为红色。
- en: Delete all of the content of the **Text** property of this new GameObject (so
    initially the user won't see any text on screen for this GameObject).
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除这个新游戏对象**Text**属性的**所有内容**（因此最初用户不会看到此游戏对象屏幕上的任何文本）。
- en: 'Add an instance of the `DisplayChangedTextContent` C# script class to the **Text-display**
    GameObject:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`DisplayChangedTextContent`C#脚本类的一个实例添加到**Text-display**游戏对象中：
- en: '[PRE5]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With **Text-display** selected in the **Hierarchy**, from the **Project** panel
    drag the **Input Field** GameObject into the public **Input Field **variable of
    the **Display Changed Content (Script)** component:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**Text-display**，从**Project**面板将**Input Field**游戏对象拖入**Display
    Changed Content (Script)**组件的公共**Input Field **变量中：
- en: '![](img/68735db8-5fcd-4255-a441-65c6354d8caf.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68735db8-5fcd-4255-a441-65c6354d8caf.png)'
- en: With **Input Field** selected in the **Hierarchy**, add an **End Edit (String)**
    event to the list of event handlers for the **Input Field (Script)** component.
    Click on the plus (**+**) button to add an event-handler slot, and drag the **Text-display**
    GameObject into the **Object** slot.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**Input Field**，将**End Edit (String)**事件添加到**Input Field (Script)**组件的事件处理程序列表中。点击加号（**+**）按钮添加事件处理程序槽，并将**Text-display**游戏对象拖入**Object**槽。
- en: From the **Function** drop-down menu, choose **DisplayChangedTextContent** and
    then choose the `DisplayNewValue` method.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Function**下拉菜单中选择**DisplayChangedTextContent**，然后选择`DisplayNewValue`方法。
- en: Save and run the **Scene**. Each time the user types in new text and then presses
    Tab or Enter, the End Edit event will fire, and you'll see a new content text
    message displayed in red on the screen.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行**Scene**。每次用户输入新文本然后按下Tab或Enter键时，End Edit事件都会触发，您将在屏幕上看到一条新的内容文本消息以红色显示。
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core of interactive text input in Unity is the responsibility of the **Input
    Field** component. This needs a reference to a **UI Text** GameObject. To make
    it easier to see where the text can be typed, **Text Input** (as do Buttons) include
    a default rounded rectangle image, with a white background.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中交互式文本输入的核心是**Input Field**组件的责任。这需要一个对**UI Text**游戏对象的引用。为了更容易看到文本可以输入的位置，**Text
    Input**（就像按钮一样）包括一个默认的圆角矩形图像，背景为白色。
- en: 'There are usually three **Text** GameObjects involved with the user text input:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有三个**Text**游戏对象与用户文本输入相关：
- en: 'The static prompt text, in our recipe, displaying to the user the text Name:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态提示文本，在我们的配方中显示给用户文本Name:。
- en: The faint placeholder text, reminding users where and what they should type.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡化的占位文本，提示用户在哪里以及应该输入什么。
- en: The editable text object (with the font and color settings) that is actually
    displayed to the user, showing the characters as they type.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际显示给用户的可编辑文本对象（带有字体和颜色设置），显示用户输入的字符。
- en: You created an **Input Field** GameObject, which automatically provides two
    child **Text** GameObjects, named **Placeholder** and **Text**. These represent
    the faint placeholder text, and the editable text, which you renamed **Text-input**.
    You then added a third **Text** GameObject, **Text-prompt**, containing text Name:.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了一个**Input Field**游戏对象，它自动提供了两个子**Text**游戏对象，分别命名为**Placeholder**和**Text**。这些代表淡化的占位文本和可编辑文本，您将其重命名为**Text-input**。然后您添加了第三个**Text**游戏对象，**Text-prompt**，其中包含文本Name:。
- en: The built-in scripting that is part of **Input Field** components does lots
    of work for us. At runtime, a **Text****-Input** Input Caret GameObject is created –
    displaying the blinking vertical line to inform the user where their next letter
    will be typed. When there is no text content, the faint placeholder text will
    be displayed. As soon as any characters have been typed, the placeholder will
    be hidden and the characters typed will appear in black text. Then, if all the
    characters are deleted, the placeholder will appear again.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**Input Field**组件内置的脚本为我们做了很多工作。在运行时，会创建一个**Text****-Input**输入光标游戏对象——显示闪烁的垂直线以告知用户下一个字母将输入的位置。如果没有文本内容，将显示淡化的占位文本。一旦输入了任何字符，占位符将被隐藏，输入的字符将以黑色文本显示。然后，如果所有字符都被删除，占位符将再次出现。'
- en: You then added a red fourth **Text** GameObject **Text-display**, to confirm
    to the user what they last entered in the **Input Field**. You created the `DisplayChangedTextContent` C#
    script class, and added an instance as a component of the **Text-display** GameObject.
    You linked the **Input** **Field** GameObject to the **Input Field** public variable of
    the scripted component (so the script can access the text content entered by the
    user).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您添加了一个红色的第四个**文本**GameObject **Text-display**，以确认用户在**输入字段**中最后输入的内容。您创建了`DisplayChangedTextContent`C#脚本类，并将其作为组件添加到**Text-display**GameObject中。您将**输入****字段**GameObject链接到脚本组件的**输入字段**公共变量（因此脚本可以访问用户输入的文本内容）。
- en: You registered an **End Edit** event handler of the **Input Field**, so that
    each time the user finished editing text (by pressing *Enter*), the `DisplayNewValue()`
    method of your `DisplayChangedTextContent` scripted object is invoked (executed),
    and the red text content of **Text-display** updated to tell the user what the
    newly edited text contained.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您注册了**输入字段**的**结束编辑**事件处理程序，以便每次用户完成文本编辑（通过按*Enter*键）时，您的`DisplayChangedTextContent`脚本对象的`DisplayNewValue()`方法被调用（执行），并将**Text-display**的红色文本内容更新，以告诉用户新编辑的文本内容。
- en: There's more...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details you don't want to miss.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节您不要错过。
- en: Limiting the type of content that can be typed
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制可以输入的内容类型
- en: 'The **Content Type** of the **Input Field (Script)**, can be set (restricted)
    to several specific types of text input, including email addresses, integer or
    decimal numbers only, or the password text (where an asterisk is displayed for
    each entered character). Learn more about Input Fields on the Unity Manual page:
    [https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入字段（脚本）**的**内容类型**可以设置为（限制）几种特定的文本输入类型，包括电子邮件地址、仅整数或小数数字，或密码文本（每个输入字符都显示为星号）。有关输入字段的更多信息，请参阅
    Unity 手册页面：[https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html)。'
- en: Toggles and radio buttons via Toggle Groups
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过切换组使用切换和单选按钮
- en: Users make choices, and often, these choices have *one of two* options (for
    example, sound on or off), or sometimes *one of several* possibilities (for example,
    difficulty level as easy/medium/hard). Unity **UI Toggles** allows users to turn
    options on and off; and when combined with **Toggle Groups**, they restrict choices
    to one of the group of items. In this recipe, we'll first explore the basic Toggle,
    and a script to respond to a change in values. Then, we'll extend the example
    to illustrate **Toggle Groups**, and styling these with round images to make them
    look more like traditional radio buttons.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 用户做出选择，通常，这些选择有两种选项（例如，声音开或关），或者有时有几种可能性（例如，难度级别为简单/中等/困难）。Unity **UI 切换**允许用户打开和关闭选项；当与**切换组**结合使用时，它们将选择限制为组中的某个项目。在本示例中，我们将首先探索基本的切换，以及一个响应值变化的脚本。然后，我们将扩展示例以说明**切换组**，并使用圆形图像进行样式化，使其看起来更像传统的单选按钮。
- en: 'The screenshot shows how the button''s status changes are logged in the **Console**
    panel when the scene is running:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了当场景运行时，按钮状态变化在**控制台**面板中的记录方式：
- en: '![](img/bacaea1e-3e22-4edc-9941-a46ce48400a8.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bacaea1e-3e22-4edc-9941-a46ce48400a8.png)'
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you'll need in a folder named
    `UI Demo Textures` in the `02_09` folder.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，我们在`02_09`文件夹中的`UI Demo Textures`文件夹中准备了您需要的图像。
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To display an on/off UI Toggle to the user, follow these steps:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要向用户显示开/关 UI 切换，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 2D 项目。
- en: In the **Inspector**, change the Background color of the **Main Camera** to
    white.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**主相机**的背景颜色更改为白色。
- en: Add **UI Toggle** to the scene.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI 切换**添加到场景中。
- en: For the **Label** child of the **Toggle** GameObject, set the **Text** property
    to First Class.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**切换**GameObject的**标签**子项，将**文本**属性设置为“First Class”。
- en: 'Add an instance of the C# script class called `ToggleChangeManager` to the **Toggle**
    GameObject:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`ToggleChangeManager`的 C# 脚本类实例添加到**切换**GameObject中：
- en: '[PRE6]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the **Toggle** GameObject selected, add an **On Value Changed** event to
    the list of event handlers for the **Toggle (Script)** component, click on the
    plus (**+**) button to add an event-handler slot, and drag **Toggle** into the
    **Object** slot.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**切换**GameObject后，将**On Value Changed**事件添加到**切换 (脚本)**组件的事件处理程序列表中，点击加号（**+**）按钮添加事件处理程序槽，并将**切换**拖入**对象**槽。
- en: From the **Function** drop-down menu, choose **ToggleChangeManager** and then
    choose the `PrintNewToggleValue` method.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Function** 下拉菜单中选择 **ToggleChangeManager**，然后选择 `PrintNewToggleValue` 方法。
- en: Save and run the **Scene**. Each time you check or uncheck the **Toggle** GameObject,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the new Boolean true/false
    value of the **Toggle**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行 **Scene**。每次检查或取消检查 **Toggle** GameObject 时，**On Value Changed** 事件都会触发，你将看到我们的脚本在
    **Console** 窗口中打印出新的布尔值（真/假）的文本消息。
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create a Unity **UI Toggle** GameObject, it comes with several child
    GameObjects automatically – **Background**, **Checkmark**, and the text **Label**.
    Unless we need to style the look of a **Toggle** in a special way, all that is
    needed is simply to edit the text **Label** so that the user knows what option
    or feature this **Toggle** is going to turn on/off.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 Unity **UI Toggle** GameObject 时，它会自动包含几个子 GameObject —— **Background**、**Checkmark**
    和文本 **Label**。除非我们需要以特殊方式设计 **Toggle** 的外观，否则只需要简单地编辑文本 **Label**，以便用户知道这个 **Toggle**
    将会开启/关闭哪个选项或功能。
- en: The `Awake()` method of the `ToggleChangeManager` C# class caches a reference
    to the **Toggle** component in the GameObject where the script instance is located.
    When the game is running, each time the user clicks on the **Toggle** to change
    its value, an **On Value Changed** event is fired. We then register the `PrintNewToggleValue()` method,
    which is to be executed when such an event occurs. This method retrieves, and
    then prints out to the **Console** panel, the new Boolean true/false value of
    the **Toggle**.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleChangeManager` C# 类的 `Awake()` 方法在脚本实例所在的 GameObject 中缓存了对 **Toggle**
    组件的引用。当游戏运行时，每次用户点击 **Toggle** 来更改其值时，都会触发一个 **On Value Changed** 事件。然后我们注册了 `PrintNewToggleValue()`
    方法，该方法将在此类事件发生时执行。此方法检索，然后打印到 **Console** 面板，**Toggle** 的新布尔值（真/假）。'
- en: There's more...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are some details that you don't want to miss.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不应该错过。
- en: Adding more Toggles and a Toggle Group to implement mutually-exclusive radio
    buttons
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多 Toggles 和 Toggle Group 以实现互斥的单选按钮
- en: Unity **UI Toggles** are also the base components if we wish to implement a
    group of mutually-exclusive options in the style of *radio buttons*. We need to
    group related radio button **UI Toggles** together, so when one turns on, all
    the others in the group turn off.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Unity **UI Toggles** 也是实现一组互斥选项的基础组件，这些选项的风格类似于 *单选按钮*。我们需要将相关的单选按钮 **UI Toggles**
    组合在一起，这样当其中一个开启时，组中的其他所有选项都会关闭。
- en: 'We also need to change the visual look if we want to adhere to the usual style
    of radio buttons as circles, rather than the square **UI Toggle** default images:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要遵循通常的圆形单选按钮样式，而不是默认的方形 **UI Toggle** 图像，我们也需要更改视觉外观：
- en: '![](img/38859625-98f2-41a4-8890-2feb6140fa9c.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38859625-98f2-41a4-8890-2feb6140fa9c.png)'
- en: 'To create a group of related toggles in the visual style of radio buttons,
    do the following to the project you just created:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要在创建的项目中创建一组以单选按钮视觉风格相关的切换，请执行以下操作：
- en: Import the `UI Demo Textures` folder into the project.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UI Demo Textures` 文件夹导入到项目中。
- en: Remove the C# script class `ToggleChangeManager` component from the **Toggle**
    GameObject.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Toggle** GameObject 中移除 C# 脚本类 `ToggleChangeManager` 组件。
- en: Rename the **Toggle** GameObject as **Toggle-easy**.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Toggle** GameObject 重命名为 **Toggle-easy**。
- en: Select the **Canvas** GameObject, and in the **Inspector** add a **UI | Toggle
    Group** component.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Canvas** GameObject，然后在 **Inspector** 中添加一个 **UI | Toggle Group** 组件。
- en: With the **Toggle-easy** GameObject selected, in the **Inspector** drag the
    **Canvas** GameObject into the **Toggle Group** property of the **Toggle (Script)**
    component.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择 **Toggle-easy** GameObject 时，在 **Inspector** 中将 **Canvas** GameObject 拖动到
    **Toggle (Script)** 组件的 **Toggle Group** 属性。
- en: Change the **Label** text to **Easy**, and tag this GameObject with a new tag
    called `Easy`.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Label** 文本更改为 **Easy**，并给这个 GameObject 添加一个名为 `Easy` 的新标签。
- en: Select the **Background** child GameObject of **Toggle-easy**, and in the `Image
    (Script)` component, drag the `UIToggleBG` image into the **Source Image** property
    (a circle outline).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Toggle-easy** 的 **Background** 子 GameObject，并在 `Image (Script)` 组件中，将 `UIToggleBG`
    图像拖动到 **Source Image** 属性（一个圆形轮廓）。
- en: Ensure that the **Is On** property of the **Toggle (Script)** component is checked,
    and then select the **Checkmark** child GameObject of **Toggle-easy.** In the
    **Image (Script)** component, drag the `UIToggleButton` image into the **Source
    Image** property (a filled circle).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保检查**Toggle（脚本）**组件的**Is On**属性，然后选择**Toggle-easy**的**Checkmark**子GameObject。在**Image（脚本）**组件中，将`UIToggleButton`图像拖动到**Source
    Image**属性（一个实心圆）中。
- en: Of the three choices (easy, medium, and hard) that we'll offer to the user,
    we'll set the easy option to be the one that is supposed to be initially selected.
    Therefore, we need its Is On property to be checked, which will lead to its checkmark
    image being displayed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供给用户的三个选项（简单、中等和困难）中，我们将简单选项设置为默认选中项。因此，我们需要检查其Is On属性，这将导致其勾选图像被显示。
- en: To make these Toggles look more like radio buttons, the background of each is
    set to the circle outline image of `UIToggleBG`, and the checkmark (which displays
    the Toggles that are on) is filled with the circle image called `UIToggleButton`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些切换看起来更像单选按钮，每个切换的背景都设置为`UIToggleBG`的圆形轮廓图像，而勾选标记（显示处于开启状态的切换）则填充了名为`UIToggleButton`的圆形图像。
- en: Duplicate the **Toggle-easy** GameObject, naming the copy **Toggle-medium**.
    Set its **Rect Transform** property **Pos Y** to `-25` (so, this copy is positioned
    below the easy option), and uncheck the **Is On** property of the **Toggle (Script)**
    component. Tag this copy with a new tag called `Medium`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Toggle-easy**GameObject，将副本命名为**Toggle-medium**。将**Rect Transform**属性的**Pos
    Y**设置为`-25`（因此，这个副本位于简单选项下方），并取消选中**Toggle（脚本）**组件的**Is On**属性。给这个副本添加一个新的标签名为`Medium`。
- en: Duplicate the **Toggle-medium** GameObject, naming the copy **Toggle-hard**.
    Set its **Rect Transform** property **Pos Y** to `-50` (so this copy is positioned
    below the medium option). Tag this copy with a new tag called `Hard`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Toggle-medium**GameObject，将副本命名为**Toggle-hard**。将**Rect Transform**属性的**Pos
    Y**设置为`-50`（因此，这个副本位于中等选项下方）。给这个副本添加一个新的标签名为`Hard`。
- en: 'Add an instance of the `RadioButtonManager` C# script class to the **Canvas**
    GameObject:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RadioButtonManager`C#脚本类的一个实例添加到**画布**GameObject中：
- en: '[PRE7]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Select the **Toggle-easy** GameObject in the **Project** panel. Now do the
    following:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中选择**Toggle-easy**GameObject。现在执行以下操作：
- en: Since we based this on the **First Class** toggle, there is already an **On
    Value Changed** event to the list of event handlers for the **Toggle (Script)**
    component. Drag the **Canvas** GameObject in the target object slot (under the
    drop-down showing **Runtime Only**).
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们基于**第一类**切换功能，因此已经有一个**值改变时**事件添加到了**切换（脚本）**组件的事件处理器列表中。将**画布**GameObject拖动到目标对象槽中（在显示**仅运行时**的下拉菜单下）。
- en: From the **Function** drop-down menu, choose **RadioButtonManager**, and then
    choose the `PrintNewGroupValue` method.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从**函数**下拉菜单中选择**RadioButtonManager**，然后选择`PrintNewGroupValue`方法。
- en: 'In the **Toggle** parameter slot, which is initially **None (Toggle)**, drag
    the **Toggle-easy** GameObject. Your **On Value** **Changed** settings in the
    Inspector should look as shown in the following screenshot:'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Toggle**参数槽中，它最初是**None (Toggle)**，拖动**Toggle-easy**GameObject。您的**On Value
    Changed**设置在检查器中应如下所示：
- en: '![](img/65dd1ee8-292b-4ff6-b111-c2de1efdb65e.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65dd1ee8-292b-4ff6-b111-c2de1efdb65e.png)'
- en: Do the same for the **Toggle-medium** and **Toggle-hard** GameObjects – so each
    Toggle object calls the `PrintNewGroupValue(...)` method of a C# scripted component
    called `RadioButtonManager` in the **Canvas** GameObject, passing itself as a
    parameter.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Toggle-medium**和**Toggle-hard**GameObject也执行相同的操作——这样每个切换对象都会调用**画布**GameObject中名为`RadioButtonManager`的C#脚本组件的`PrintNewGroupValue(...)`方法，并将自身作为参数传递。
- en: Save and run the **Scene**. Each time you check one of the three radio buttons,
    the **On Value Changed** event will fire, and you'll see a new text message printed
    into the **Console** window by our script, stating the tag of whichever **Toggle**
    (radio button) was just set to true (**Is On**).
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行**场景**。每次您选中三个单选按钮之一时，**值改变时**事件都会触发，您将看到我们的脚本在**控制台**窗口中打印出一条新的文本消息，指出刚刚设置为true（**Is
    On**）的**Toggle**（单选按钮）的标签。
- en: By adding a **Toggle Group** component to the **Canvas**, and having each **Toggle**
    GameObject link to it, the three radio buttons can tell the **Toggle Group** when
    they have been selected, and the other member of the group are then deselected.
    If you had several groups of radio buttons in the same scene, one strategy is
    to add the **Toggle Group** component to one of the **Toggles**, and have all
    the others link to that one.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向**画布**添加**切换组**组件，并让每个**切换**GameObject链接到它，三个单选按钮可以告诉**切换组**它们已被选中，然后组中的其他成员将被取消选中。如果你在同一场景中有多个单选按钮组，一种策略是将**切换组**组件添加到一个**切换**上，并让所有其他切换都链接到这个切换。
- en: We store the current radio button value (the last one switched On) in the currentDifficulty
    class property. Since variables declared outside a method are remembered, we could,
    for example, add a public method, such as `GetCurrentDifficulty()`, which could
    tell other scripted objects the current value, regardless of how long it's been
    since the user last changed their option.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前单选按钮的值（最后被切换为开启的那个）存储在`currentDifficulty`类的属性中。由于在方法外部声明的变量会被记住，例如，我们可以添加一个公共方法，如`GetCurrentDifficulty()`，它可以将当前值告诉其他脚本对象，无论用户上次更改选项有多久。
- en: Creating text and image icon UI Dropdown menus
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文本和图像图标UI下拉菜单
- en: In the previous recipe, we created radio-style buttons with a **Toggle Group**,
    to present the user with a choice of one of many options. Another way to offer
    a range of choices is with a drop-down menu. Unity provides the **UI Dropdown**
    control for such menus. In this recipe, we'll offer the user a drop-down choice
    for the suit of a deck of cards (hearts, clubs, diamonds, or spades).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们使用**切换组**创建了单选按钮，向用户展示多个选项中的一个。提供一系列选择的一种另一种方式是使用下拉菜单。Unity提供了**UI下拉菜单**控件来实现此类菜单。在这个配方中，我们将为用户提供一个下拉菜单，用于选择一副扑克牌的花色（红心、梅花、方块或黑桃）。
- en: Note, the **UI Dropdown** created by default includes a scrollable area, in
    case there isn't space for all the options. We'll learn how to remove the GameObjects
    and components, to reduce complexity when such a feature is not required.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认创建的**UI下拉菜单**包含一个可滚动区域，以防没有足够的空间显示所有选项。我们将学习如何删除GameObject和组件，以减少在不需要此类功能时的复杂性。
- en: 'Then we''ll learn how to add icon images with each menu option, as shown in
    the screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习如何为每个菜单选项添加图标图像，如图表所示：
- en: '![](img/0b3d3774-ac65-4916-a0af-a9eceab985e2.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b3d3774-ac65-4916-a0af-a9eceab985e2.png)'
- en: Getting ready
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the image that you need in a folder named
    Images in the `02_10` folder.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们在`02_10`文件夹中的Images文件夹中准备了你需要的图像。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a **UI Dropdown** control GameObject, follow these steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个**UI下拉菜单**控制GameObject，请按照以下步骤操作：
- en: Create a new Unity 2D project.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity 2D项目。
- en: Add **UI Dropdown** to the scene.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI下拉菜单**添加到场景中。
- en: In the **Inspector**, for the **Dropdown (Script)** component, change the list
    of **Options** from Option A, Option B, and Option C to Hearts, Clubs, Diamonds,
    and Spades. You'll need to click the plus (**+**) button to add space for the
    fourth option of **Spades**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，对于**下拉菜单（脚本）**组件，将**选项**列表从“选项A”、“选项B”和“选项C”更改为“红心”、“梅花”、“方块”和“黑桃”。你需要点击加号（**+**）按钮为第四个选项“黑桃”添加空间。
- en: 'Add an instance of the C# script class called `DropdownManager` to the **Dropdown**
    GameObject:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为`DropdownManager`的C#脚本类实例添加到**下拉菜单**GameObject中：
- en: '[PRE8]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the **Dropdown** GameObject selected, add an **On Value Changed** event
    to the list of event handlers for the **Dropdown** **(Script)** component, click
    on the plus (**+**) button to add an event-handler slot, and drag **Dropdown**
    into the **Object** slot.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**下拉菜单**GameObject后，将一个**值改变**事件添加到**下拉菜单**（脚本）组件的事件处理程序列表中，点击加号（**+**）按钮添加事件处理程序槽，并将**下拉菜单**拖入**对象**槽中。
- en: From the **Function** drop-down menu, choose **DropdownManager** and then choose
    the `PrintNewValue` method.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**函数**下拉菜单中选择**DropdownManager**，然后选择`PrintNewValue`方法。
- en: 'Save and run the **Scene**. Each time you change the **Dropdown**, the **On
    Value Changed** event will fire, and you''ll see a new text message printed into
    the **Console** window by our script, stating the **Integer** index of the chosen
    **Dropdown** value (`0` for the first item, `1` for the second item and so on):'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行**场景**。每次更改**下拉菜单**时，**值改变**事件都会触发，你将看到我们的脚本在**控制台**窗口中打印出一条新的文本消息，指出所选**下拉菜单**值的**整数**索引（第一个选项为`0`，第二个选项为`1`，依此类推）：
- en: '![](img/85e24ad8-f22a-49c2-9711-d97c913cfc3b.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85e24ad8-f22a-49c2-9711-d97c913cfc3b.png)'
- en: 'Select the **Template** child GameObject of the **Dropdown** in the **Project**
    panel, and in its **Rect Transform** reduce its height to `50`. When you run the
    **Scene**, you should see a scrollable area, since not all options fit within
    the **Template''s** height:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**面板中选择**Dropdown**的**Template**子GameObject，并在其**Rect Transform**中将其高度减少到`50`。当你运行**Scene**时，你应该看到一个可滚动区域，因为不是所有选项都适合在**Template**的高度内：
- en: '![](img/2ba11998-516a-47aa-ac44-bf08d8837fa5.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba11998-516a-47aa-ac44-bf08d8837fa5.png)'
- en: Delete the **Scrollbar** child of the **Template** GameObject, and remove the
    **Scroll Rect (Script)** component of the **Template** GameObject. When you run
    the **Scene** now, you'll only see the first two options (**Hearts** and **Clubs**),
    with no way to access the other two options. When you are sure your **Template's**
    height is sufficient for all its options, you can safely remove these scrollable
    options to simplify the GameObjects in your scene.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**Template** GameObject的**Scrollbar**子组件，并移除**Template** GameObject的**Scroll
    Rect (Script)**组件。当你现在运行**Scene**时，你将只能看到前两个选项（**Hearts**和**Clubs**），无法访问其他两个选项。当你确定你的**Template**的高度足以容纳所有选项时，你可以安全地移除这些可滚动选项，以简化场景中的GameObject。
- en: How it works...
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you create a Unity **UI DropDown** GameObject, it comes with several components
    and child GameObjects automatically – **Label**, **Arrow**, and **Template** (and
    **ViewPort** and **Scrollbar**, and so on). **Dropdowns** work by duplicating
    the **Template** GameObject for each of the **Options** listed in the **Dropdown
    (Script)** component. Both **Text** and **Sprite** image values can be given for
    each option. The properties of the **Template** GameObject are used to control
    the visual style and behavior of the **Dropdown's** thousands of possible settings.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个Unity **UI DropDown** GameObject时，它会自动包含几个组件和子GameObject，例如 **Label**、**Arrow**和**Template**（以及**ViewPort**和**Scrollbar**等）。**Dropdowns**通过为**Dropdown
    (Script)**组件中列出的每个**Options**复制的**Template** GameObject来工作。每个选项都可以提供**Text**和**Sprite**图像值。**Template**
    GameObject的属性用于控制**Dropdown**的成千上万种可能的视觉样式和行为。
- en: You first replaced the default options (Option A, Option B, and so on) in the
    **Dropdown (Script)** component. You then created a C# script class, `DropdownManager`,
    that when attached to your **Dropdown**, and having its `PrintNewValue` method
    registered for **On Value Changed** events, means that we can see the **Integer**
    index of the option each time the user changes their choice. Item index values
    start counting at zero (as with many computing items), so `0` for the first item,
    `1` for the second item, and so on.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先替换了**Dropdown (Script)**组件中的默认选项（选项A、选项B等）。然后你创建了一个C#脚本类，`DropdownManager`，当它附加到你的**Dropdown**上，并且其`PrintNewValue`方法注册了**On
    Value Changed**事件，这意味着我们可以在用户更改选择时看到每个选项的**Integer**索引。项目索引值从零开始计数（如许多计算项目一样），所以第一个选项是`0`，第二个选项是`1`，依此类推。
- en: Since the default **Dropdown** GameObject created includes a **Scroll Rect (Script)**
    component and a **Scrollbar** child GameObject, when you reduced the height of
    the **Template**, you could still scroll through the options. You then removed
    these items so that your **Dropdown** had no scrolling feature anymore.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认创建的**Dropdown** GameObject包含一个**Scroll Rect (Script)**组件和一个**Scrollbar**子GameObject，当你减小**Template**的高度时，你仍然可以滚动选项。然后你移除了这些项目，这样你的**Dropdown**就不再有滚动功能了。
- en: There's more...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details you don't want to miss.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Adding images to a Dropdown control
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图片添加到下拉控制
- en: 'There are two pairs of items Unity uses to manage how **Text** and **Images**
    are displayed:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用两对项目来管理**Text**和**Images**的显示：
- en: The **Caption Text** and **Image** GameObjects are used to control how the currently-selected
    item for the **Dropdown** is displayed – the part of the **Dropdown** we always
    see, whether the **Dropdown** is being interacted with or not.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Caption Text**和**Image** GameObjects用于控制**Dropdown**当前选中项的显示方式——无论**Dropdown**是否被交互，我们总是能看到的部分。'
- en: The **Item Text** and **Image** GameObjects are part of the **Template** GameObject,
    and they define how each option is displayed as a row when the **Dropdown** menu
    items are being displayed – the rows displayed when the user is actively working
    with the **Dropdown** GameObject.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Item Text**和**Image** GameObjects是**Template** GameObject的一部分，它们定义了当**Dropdown**菜单项被显示时，每个选项如何作为一行显示——当用户积极与**Dropdown**
    GameObject交互时显示的行。'
- en: So we have to add an **Image** in two places (**Caption** and **Template** Item),
    in order to get a **Dropdown** working fully with image icons for each option.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须在两个地方（**标题**和**模板**项）添加一个**图像**，以便使**下拉菜单**能够完全使用图像图标为每个选项工作。
- en: 'To add a **Sprite** image with each **Text** item in the **Dropdown**, do the
    following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在**下拉菜单**中为每个**文本**项添加**精灵**图像，请按照以下步骤操作：
- en: Import the provided `Images` folder.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的`Images`文件夹。
- en: In the **Inspector**, for the **Dropdown (Script)** component, for each item
    in the list of **Options** **Hearts**, **Clubs**, **Diamonds**, and **Spades**,
    drag the associated **Sprite** image from the `card_suits` folder in the **Project** panel (`hearts.png`
    for **Hearts**, and so on).
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，对于**Dropdown (脚本)**组件，对于列表中的每个**选项** **Hearts**、**Clubs**、**Diamonds**和**Spades**，从**项目**面板中的`card_suits`文件夹（**Hearts**为`hearts.png`等）拖动相关的**精灵**图像。
- en: Add a **UI Image** in the **Project** panel, and child this **Image** to the
    **Dropdown** GameObject.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中添加一个**UI 图像**，并将此**图像**作为**下拉菜单**游戏对象的子对象。
- en: Drag the `hearts.png` Image from the **Project** panel into the **Source Image**
    property of the **Image (Script)** for the **Image** GameObject. Size this Image
    to `25` x `25` in the **Rect Transform**, and drag it over the letter "**H**"
    in "**Hearts**" in the **Label** GameObject.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`hearts.png`图像从**项目**面板拖动到**Image (脚本)**组件的**源图像**属性中，对于**图像**游戏对象。在**矩形变换**中将此图像的大小调整为`25`
    x `25`，并将其拖动到**标签**游戏对象的“**Hearts**”中的“**H**”字母上。
- en: Move the **Label** GameObject to the right of the hearts image.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**游戏对象移动到心形图像的右侧。
- en: With **Dropdown** Selected in the **Project** panel, drag the **Image** GameObject
    into the **Caption Image** property of the **Dropdown (Script)** component.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中**选择**下拉菜单，将**图像**游戏对象拖动到**Dropdown (脚本)**组件的**标题图像**属性中。
- en: Enable the **Template** GameObject (usually it is disabled).
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**模板**游戏对象（通常它是禁用的）。
- en: Duplicate the **Image** GameObject child of **Dropdown**, and name the copy
    **Item Image**. Child this **Image** in between the **Item** **Background** and
    **Item Checkmark** GameObjects that are in **Dropdown-Template-Content-Item**
    (the **Item Image** needs to appear below the white **Item Background Image**,
    otherwise it will be covered by the background and not be visible).
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**下拉菜单**的**图像**游戏对象子对象，并将其命名为**项目图像**。将此**图像**放在**Dropdown-Template-Content-Item**中的**项目**
    **背景**和**项目勾选标记**游戏对象之间（**项目图像**需要出现在白色的**项目背景图像**下方，否则它将被背景覆盖而不可见）。
- en: Since items in the **Dropdown** are slightly smaller, resize Item Image to be
    `20` x `20` in its **Rect Transform**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**下拉菜单**中的项略小，请将项目图像的大小调整到其在**矩形变换**中的`20` x `20`。
- en: Position **Item Image** over the "**O**" of "**Option A**" of **Item Text**,
    and then move **Item Text** to the right so that the icon and text are not on
    top of each other.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**项目图像**放置在**项目文本**的“**Option A**”中的“**O**”上方，然后将**项目文本**向右移动，以便图标和文本不在同一位置。
- en: 'With **Dropdown** Selected in the **Project** panel, drag the **Item Image**
    GameObject into the **Item Image** property of the D**ropdown (Script)** component:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中**选择**下拉菜单，将**项目图像**游戏对象拖动到**Dropdown (脚本)**组件的**项目图像**属性中：
- en: '![](img/7688bad7-9deb-4c0b-a0b7-3ad351c1acaa.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7688bad7-9deb-4c0b-a0b7-3ad351c1acaa.png)'
- en: Disable the **Template** GameObject, then run the scene to see your **Dropdown**
    with icon images for each menu option.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**模板**游戏对象，然后运行场景以查看带有图标图像的每个菜单选项的**下拉菜单**。
- en: Unity UI Dropdowns are powerful interface components – learn more about these
    controls from the Unity Manual at [https://docs.unity3d.com/Manual/script-Dropdown.html.](https://docs.unity3d.com/Manual/script-Dropdown.html)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI **下拉菜单**是强大的界面组件 - 在Unity手册中了解更多关于这些控件的信息，请参阅[https://docs.unity3d.com/Manual/script-Dropdown.html.](https://docs.unity3d.com/Manual/script-Dropdown.html)
- en: Displaying a radar to indicate the relative locations of objects
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示雷达以指示对象的相对位置
- en: A radar displays the locations of other objects relative to the player, usually
    based on a circular display, where the center represents the player, and each
    graphical blip indicates how far away and what relative direction objects are
    to the player. Sophisticated radar displays will display different categories
    of objects with different colored or shaped blip icons.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 雷达显示其他对象相对于玩家的位置，通常基于圆形显示，其中中心代表玩家，每个图形点表示对象距离玩家有多远以及相对方向。复杂的雷达显示将以不同颜色或形状的点图标显示不同类别的对象。
- en: 'In the screenshot, we can see two red square blips, indicating the relative
    position of the two red cube GameObjects tagged Cube near the player, and a yellow
    circle blip indicating the relative position of the yellow sphere GameObject tagged
    Sphere. The green circle radar background image gives the impression of an aircraft
    control tower radar or something similar:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中，我们可以看到两个红色的方块标记，指示玩家附近两个标记为Cube的红色立方体GameObject的相对位置，以及一个黄色圆圈标记指示标记为Sphere的黄色球体GameObject的相对位置。绿色的圆形雷达背景图像给人一种飞机控制塔雷达或类似的感觉：
- en: '![](img/c0653d19-56ae-44d5-87ab-51d345421ca2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0653d19-56ae-44d5-87ab-51d345421ca2.png)'
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared the images that you need in a folder named
    Images in `02_11`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`02_11`文件夹中准备了一个名为Images的文件夹，其中包含了您需要的图像。
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a radar to show the relative positions of the objects, follow these
    steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个雷达以显示对象的相对位置，请按照以下步骤操作：
- en: 'Create a new 3D project, with a textured **Terrain**. Import the **Environment**
    standard asset package contents, by choosing menu: Assets | Import Package | Environment.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目，包含一个带有纹理的**地形**。通过选择菜单：资产 | 导入包 | 环境，导入**环境**标准资产包的内容。
- en: Create a terrain by navigating to the Create | 3D Object | Terrain menu.
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到创建 | 3D对象 | 地形菜单创建一个地形。
- en: 'Size the **Terrain** 20 x 20, positioned at `(-10, 0, -10)` - so that its center
    is at `(0, 0, 0)`:'
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**地形**的大小设置为20 x 20，放置在`(-10, 0, -10)`的位置——这样其中心就在`(0, 0, 0)`：
- en: '![](img/53fd93f2-6896-4a29-8a4c-b4ff879ed5a9.png)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/53fd93f2-6896-4a29-8a4c-b4ff879ed5a9.png)'
- en: 'Texture paint your **T****errain** with the **SandA****lbedo** option, as shown
    in the screenshot. You need to select the **Paintbrush** tool in the **Terrain**
    component, then click the **Edit Textures** button, and select the **SandAlbedo**
    texture from the imported **Environme****nt** assets:'
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**沙色**选项纹理绘制你的**地形**，如图所示。您需要在**地形**组件中选择**画笔**工具，然后点击**编辑纹理**按钮，并从导入的**环境**资产中选择**SandAlbedo**纹理：
- en: '![](img/d917b712-db0a-4e2e-a6ae-ef16ce9b5d2f.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d917b712-db0a-4e2e-a6ae-ef16ce9b5d2f.png)'
- en: Import the provided folder `Images`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的文件夹`Images`。
- en: Create a 3D Cube GameObject at **Position** `(2, 0.5, 2)`. Create a Tag `Cube`
    and tag this GameObject with this new tag. Texture this GameObject with the red
    image called `icon32_square_yellow`, by dragging image `icon32_square_yellow`
    from the **Project** panel over this GameObject in the **Hierarchy** panel.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**位置**`(2, 0.5, 2)`创建一个3D立方体GameObject。创建一个名为`Cube`的标签，并将这个GameObject标记为这个新标签。使用从**项目**面板拖拽的红色图像`icon32_square_yellow`，将这个GameObject纹理化为这个图像。
- en: Duplicate the **cube** GameObject, and move this new cube to **Position** `(6,
    0.5, 2)`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**立方体**GameObject，并将这个新立方体移动到**位置**`(6, 0.5, 2)`。
- en: Create a 3D Sphere GameObject at Position `(0, 0.5, 4)`. Create a Tag with the
    name `Sphere` and tag this GameObject with this new tag. Texture this GameObject
    with the red image called `icon32_square_yellow`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**位置**`(0, 0.5, 4)`创建一个3D球体GameObject。创建一个名为`Sphere`的标签，并将这个GameObject标记为这个新标签。使用名为`icon32_square_yellow`的红色图像对这个GameObject进行纹理化。
- en: Import the **Characters** standard asset package into your project.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**角色**标准资产包导入到您的项目中。
- en: From the `Standard Assets` folder in the **Project** panel, drag the prefab
    `ThirdPersonController` into the **Scene** and position it at `(0, 1, 0)`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板的`Standard Assets`文件夹中，将预制件`ThirdPersonController`拖拽到**场景**中，并将其放置在`(0,
    1, 0)`的位置。
- en: Tag this **ThirdPersonController** GameObject as `Player` (selecting this built-in
    tag means that the camera we'll add will automatically track this player object,
    without us having to manually set the target for the camera).
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**第三人称控制器**GameObject标记为`Player`（选择这个内置标签意味着我们将添加的摄像机将自动跟踪这个玩家对象，而无需我们手动设置摄像机的目标）。
- en: Remove the **Main Camera** GameObject.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**主摄像机**GameObject。
- en: Import the **Cameras** standard asset package into your project.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**摄像机**标准资产包导入到您的项目中。
- en: From the `Standard Assets` folder in the **Project** panel, drag the prefab
    `Multi-PurposeCameraRig` into the **Scene**.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板的`Standard Assets`文件夹中，将预制件`Multi-PurposeCameraRig`拖拽到**场景**中。
- en: In the **Hierarchy** panel, add a UI | RawImage GameObject to the scene named
    **RawImage-radar**.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，向场景添加一个UI | 原始图像GameObject，命名为**RawImage-radar**。
- en: Ensure that the **RawImage-radar** GameObject is selected in the **Hierarchy**
    panel. From the `Images` folder in the **Project** panel, drag the `radarBackground`
    image into the **Raw Image (Script)** public property **Texture**.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 **Hierarchy** 面板中选择 **RawImage-radar** GameObject。从 **Project** 面板中的 `Images`
    文件夹，将 `radarBackground` 图像拖入 **Raw Image (Script)** 的公共属性 **Texture**。
- en: In **Rect Transform**, position **RawImage-radar** at the top-left using the
    **Anchor Presets** item. Then set both width and height to `200` pixels.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Rect Transform** 中，使用 **Anchor Presets** 项将 **RawImage-radar** 定位于左上角。然后设置宽度和高度均为
    `200` 像素。
- en: Create a new **UI RawImage** named **RawImage-blip**. Assign it the `yellowCircleBlackBorder` Texture
    image file from the **Project** panel. In the **Project** panel, create a new
    empty prefab asset file named `blip-sphere`, and drag the **RawImage-blip** GameObject
    into this prefab to store all its properties.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **UI RawImage**，命名为 **RawImage-blip**。将其分配为从 **Project** 面板中的 `yellowCircleBlackBorder`
    纹理图像文件。在 **Project** 面板中，创建一个新的空预制资产文件，命名为 `blip-sphere`，并将 **RawImage-blip**
    GameObject 拖入此预制以存储所有其属性。
- en: Set the texture of GameObject **RawImage-blip** to `redSquareBlackBorder` from
    the **Project** panel. In the **Project** panel, create a new empty prefab asset
    file named `blip-cube`, and drag the **RawImage-blip** GameObject into this prefab
    to store all its properties.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GameObject **RawImage-blip** 的纹理设置为从 **Project** 面板中的 `redSquareBlackBorder`。在
    **Project** 面板中，创建一个新的空预制资产文件，命名为 `blip-cube`，并将 **RawImage-blip** GameObject
    拖入此预制以存储所有其属性。
- en: Delete the **RawImage-blip** GameObject from the **Hierarchy**.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 中删除 **RawImage-blip** GameObject。
- en: 'Create a C# script class called `Radar`, containing the following code, and
    add an instance as a scripted component to the **RawImage-radar** GameObject:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Radar` 的 C# 脚本类，包含以下代码，并将其实例作为脚本组件添加到 **RawImage-radar** GameObject
    中：
- en: '[PRE9]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run your game. You will see two red squares and one yellow circle on the radar,
    showing the relative positions of the red cubes and yellow sphere. If you move
    too far away, the blips will disappear.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的游戏。你将在雷达上看到两个红色方块和一个黄色圆圈，显示红色方块和黄色球体的相对位置。如果你移动得太远，标记点将消失。
- en: How it works...
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A radar background is displayed on the screen. The center of this circular image
    represents the position of the player's character. You have created two prefabs;
    one for red square images to represent each red cube found within the radar distance,
    and one for yellow circles to represent yellow sphere GameObjects.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上显示雷达背景。此圆形图像的中心代表玩家角色的位置。你创建了两个预制，一个用于表示雷达范围内找到的每个红色方块的红方形图像，另一个用于表示黄色球体的黄色圆形GameObject。
- en: 'The `Radar` C# script class has been added to the radar **UI Image** GameObject.
    This class defines four public variables:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radar` C# 脚本类已添加到雷达 **UI Image** GameObject 中。此类定义了四个公共变量：'
- en: '**insideRadarDistance**: This value defines the maximum distance in the scene
    that an object may be from the player to still be included on the radar (objects
    further than this distance will not be displayed on the radar).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**insideRadarDistance**：此值定义了场景中对象可能离玩家多远，仍然可以包含在雷达上（距离超过此距离的对象将不会显示在雷达上）。'
- en: '**blipSizePercentage**: This public variable allows the developer to decide
    how large each blip will be, as a proportion of the radar''s image.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**blipSizePercentage**：此公共变量允许开发者决定每个标记点的大小，作为雷达图像的比例。'
- en: '**rawImageBlipCube** and **rawImageBlipSphere**: These are references to the
    prefab UI RawImages that are to be used to visually indicate the relative distance
    and position of cubes and spheres on the radar.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rawImageBlipCube** 和 **rawImageBlipSphere**：这些是对预制 UI RawImages 的引用，用于在雷达上视觉上指示方块和球体的相对距离和位置。'
- en: Since there is a lot happening in the code for this recipe, each method will
    be described in its own section.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此菜谱的代码中有很多内容，每个方法将在自己的部分中进行描述。
- en: The Start() method
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Start() 方法
- en: The `Start()` method first caches a reference to the **Raw Image** of the radar
    background image. Then it caches a reference to the **Transform** component of
    the player's character (tagged as `Player`). This allows the scripted object to
    know about the position of the Player's character in each frame. Next, the width
    and height of the radar image are cached – so, the relative positions for blips
    can be calculated, based on the size of this background radar image. Finally,
    the size of each blip (`blipWidth` and `blipHeight`) is calculated, using the
    `blipSizePercentage` public variable.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`方法首先缓存雷达背景图像的**原始图像**的引用。然后缓存玩家角色（标记为`Player`）的**变换**组件的引用。这使得脚本对象能够知道玩家角色在每个帧中的位置。接下来，缓存雷达图像的宽度和高度，因此可以根据这个背景雷达图像的大小计算雷达标记的相对位置。最后，使用`blipSizePercentage`公共变量计算每个雷达标记的大小（`blipWidth`和`blipHeight`）。'
- en: The Update() method
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Update()方法
- en: The `Update()` method calls the `RemoveAllBlips()` method, which removes any
    old **RawImage** UI GameObjects of cubes and spheres that might currently be displayed.
    If we didn't remove old blips before creating the new ones, then you'd see "tails"
    behind each blip as new ones are created in different positions – which could
    actually be an interesting effect.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`方法调用`RemoveAllBlips()`方法，该方法移除任何可能当前显示的立方体和球体的旧**原始图像**UI GameObject。如果我们不在创建新标记之前移除旧标记，那么你会在新标记在不同位置创建时看到每个标记后面的“尾巴”——这实际上可能是一个有趣的效果。'
- en: Next, the `FindAndDisplayBlipsForTag(...)` method is called twice. First, for
    the objects tagged `Cube`, to be represented on the radar with the `rawImageBlipCube`
    prefab and then again for objects tagged `Sphere`, to be represented on the radar
    with the `rawImageBlipSphere` prefab. As you might expect, most of the hard work
    for the radar is to be performed by the `FindAndDisplayBlipsForTag(...)` method.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用了两次`FindAndDisplayBlipsForTag(...)`方法。首先，为了在雷达上用`rawImageBlipCube`预制体表示标记为`Cube`的对象，然后再次为标记为`Sphere`的对象调用，用`rawImageBlipSphere`预制体在雷达上表示。正如你所预期的，雷达的大部分工作将由`FindAndDisplayBlipsForTag(...)`方法来完成。
- en: This code is a simple approach to creating a radar. It is very inefficient to
    make repeated calls to `FindGameObjectWithTag("Blip")` for every frame from the
    `Update()` method. In a real game, it would be much better to cache all created
    blips in something such as a `List` or `ArrayList`, and then simply loop through
    that list each time.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是创建雷达的简单方法。从`Update()`方法中为每一帧重复调用`FindGameObjectWithTag("Blip")`是非常低效的。在真实游戏中，将所有创建的雷达标记缓存到`List`或`ArrayList`等数据结构中会更好，然后每次只需简单地遍历这个列表。
- en: The FindAndDisplayBlipsForTag(...) method
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用FindAndDisplayBlipsForTag(...)方法。
- en: 'This method inputs two parameters: the string tag for the objects to be searched
    for, and a reference to the `RawImage` prefab to be displayed on the radar for
    any such tagged objects within the range.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法输入两个参数：要搜索的对象的字符串标记，以及要在雷达上显示的任何此类标记对象范围内的`RawImage`预制体的引用。
- en: 'First, the current position of the player''s character is retrieved from the
    cached player **Transform** variable. Next, an array is constructed, referring
    to all GameObjects in the scene that have the provided tag. This array of GameObjects
    is looped through, and for each GameObject, the following actions are performed:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从缓存的玩家**变换**变量中检索玩家角色的当前位置。接下来，构建一个数组，引用场景中具有提供的标记的所有GameObject。遍历这个GameObject数组，并对每个GameObject执行以下操作：
- en: The position of the target GameObject is retrieved.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取目标GameObject的位置。
- en: The distance from this target position to the player's position is calculated.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算从目标位置到玩家位置的距离。
- en: If this distance is within the range (less than or equal to `insideRadarDistance`),
    then the `CalculateBlipPositionAndDrawBlip(...)` method is called.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个距离在范围内（小于或等于`insideRadarDistance`），则调用`CalculateBlipPositionAndDrawBlip(...)`方法。
- en: The CalculateBlipPositionAndDrawBlip (...) method
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CalculateBlipPositionAndDrawBlip (...)方法
- en: 'This method inputs three parameters: the position of the player, the position
    of the target, and a reference to the prefab of the blip to be drawn.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法输入三个参数：玩家的位置，目标的位置，以及要绘制的雷达标记预制体的引用。
- en: 'Three steps are now required to get the blip for this object to appear on the
    radar:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要三个步骤来使此对象的雷达标记出现在雷达上：
- en: The normalized position of the target is calculated by calling `NormalizedPosition(...)`
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标的归一化位置是通过调用`NormalizedPosition(...)`来计算的。
- en: The position of the blip on the radar is calculated from this normalized position
    by calling `CalculateBlipPosition(...)`
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `CalculateBlipPosition(...)` 从这个归一化位置计算出雷达上小图标的位置。
- en: The `RawImage` blip is displayed by calling `DrawBlip(...)` and passing the
    blip position and the reference to the RawImage prefab that is to be created there
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RawImage` 小图标通过调用 `DrawBlip(...)` 并传递小图标位置以及要创建在该位置的 `RawImage` 预制件的引用来显示。'
- en: The NormalisedPosition(...) method
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NormalisedPosition(...) 方法
- en: The `NormalizedPosition(...)` method inputs the player's character position
    and the target GameObject position. It has the goal of outputting the relative
    position of the target to the player, returning a **Vector3** object with a triplet
    of X, Y, and Z values. Note that since the radar is only 2D, we ignore the Y-value
    of target GameObjects. So, the Y-value of the **Vector3** object returned by this
    method will always be `0`. So, for example, if a target was at exactly the same
    location as the player, the returned X, Y, Z **Vector3** object would be `(0,
    0, 0)`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`NormalizedPosition(...)` 方法输入玩家的角色位置和目标 GameObject 位置。它的目标是输出目标相对于玩家的相对位置，返回一个包含
    X、Y 和 Z 值的三元组的 **Vector3** 对象。请注意，由于雷达是二维的，我们忽略目标 GameObject 的 Y 值。因此，此方法返回的 **Vector3**
    对象的 Y 值始终为 `0`。例如，如果目标正好位于玩家所在的位置，返回的 X、Y、Z **Vector3** 对象将是 `(0, 0, 0)`。'
- en: Since we know that the target GameObject is no further from the player's character
    than `insideRadarDistance`, we can calculate a value in the `-1 ... 0 ... +1`
    range for the X and Z axis by finding the distance on each axis from the target
    to the player, and then dividing it by `insideRadarDistance`. An X-value of `-1`
    means that the target is fully to the left of the player (at a distance that is
    equal to insideRadarDistance), and +1 means it is fully to the right. A value
    of 0 means that the target has the same X position as the player's character.
    Likewise, for `-1 ... 0 ... +1` values in the Z-axis (this axis represents how
    far, in front or behind us an object, is located, which will be mapped to the
    vertical axis in our radar).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '由于我们知道目标 GameObject 不比玩家的角色远于 `insideRadarDistance`，我们可以通过找到每个轴上目标到玩家的距离，然后除以
    `insideRadarDistance` 来计算 `-1 ... 0 ... +1` 范围内的 X 和 Z 轴值。X 值为 `-1` 表示目标完全在玩家左侧（距离等于
    `insideRadarDistance`），+1 表示它完全在右侧。值为 0 表示目标具有与玩家角色相同的 X 位置。同样，对于 Z 轴的 `-1 ...
    0 ... +1` 值（这个轴表示一个对象在我们前方或后方有多远，这将被映射到我们的雷达中的垂直轴）。 '
- en: Finally, this method constructs and returns a new **Vector3** object, with the
    calculated X and Z normalized values, and a Y-value of zero.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，此方法构建并返回一个新的 **Vector3** 对象，包含计算出的 X 和 Z 的归一化值，以及 Y 值为零。
- en: '**The normalized position**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化位置**'
- en: A normalized value is one that has been simplified in some way, so the context
    has been abstracted away. In this recipe, what we are interested in is where an
    object is relative to the player. So, our normal form is to get a value of the
    X and Z position of a target in the `-1` to `+1` range for each axis. Since we
    are only considering GameObject within our `insideRadarDistance` value, we can
    map these normalized target positions directly onto the location of the radar
    image in our UI.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化值是指以某种方式简化的值，因此上下文已被抽象化。在这个菜谱中，我们感兴趣的是对象相对于玩家的位置。因此，我们的正常形式是获取目标在 `-1` 到
    `+1` 范围内的 X 和 Z 位置值，对于每个轴。由于我们只考虑 `insideRadarDistance` 值内的 GameObject，我们可以直接将这些归一化目标位置映射到我们
    UI 中雷达图像的位置。
- en: The CalculateBlipPosition(...) method
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CalculateBlipPosition(...)` 方法'
- en: 'First, we calculate `angleToTarget`: the angle from `(0, 0, 0)` to our normalized
    target position.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算 `angleToTarget`：从 `(0, 0, 0)` 到我们的归一化目标位置的角。
- en: 'Next, we calculate `anglePlayer`: the angle the player''s character is facing.
    This recipe makes use of the yaw angle of the rotation, which is the rotation
    about the Y-axis, that is, the direction that a character controller is facing.
    This can be found in the Y component of a GameObject''s `eulerAngles` component
    of its transform. You can imagine looking from above and down at the character
    controller, and see what direction they are facing – this is what we are trying
    to display graphically with the radar.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算 `anglePlayer`：玩家角色面向的角度。这个菜谱使用了旋转的偏航角，即围绕 Y 轴的旋转，也就是说，角色控制器面向的方向。这可以在
    GameObject 的 transform 组件的 `eulerAngles` 组件的 Y 分量中找到。你可以想象从上方向下看角色控制器，看看它们面向的方向——这就是我们试图通过雷达图形显示的方向。
- en: Our desired radar angle (the `angleRadarDegrees` variable) is calculated by
    subtracting the player's direction angle from the angle between the target and
    player, since a radar displays the relative angle from the direction that the
    player is facing, to the target object. In mathematics, an angle of zero indicates
    an east direction. To correct this, we need to also subtract `90` degrees from
    the angle.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的雷达角度（`angleRadarDegrees`变量）是通过从目标与玩家之间的角度中减去玩家的方向角度来计算的，因为雷达显示的是从玩家面向的方向到目标对象的相对角度。在数学上，零角度表示东方方向。为了纠正这一点，我们还需要从这个角度中减去`90`度。
- en: 'The angle is then converted into radians, since this is required for the Unity
    trigonometry methods. We then multiply the `Sin()` and `Cos()` results by our
    normalized distances to calculate the X and Y values, respectively (see the following
    diagram):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将角度转换为弧度，因为这是Unity三角函数方法所必需的。然后我们将`Sin()`和`Cos()`的结果乘以我们的归一化距离，分别计算出X和Y值（见以下图表）：
- en: '![](img/0a325868-bf9e-4c56-8f79-8b4bd53b460d.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a325868-bf9e-4c56-8f79-8b4bd53b460d.png)'
- en: In this figure, alpha is the angle between player and target object, "a" is
    the adjacent side, "h" is the hypotenuse, and "o" is the side opposite the angle.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，alpha是玩家与目标对象之间的角度，“a”是邻边，“h”是斜边，“o”是与角度相对的边。
- en: Our final position values need to be expressed as pixel lengths, relative to
    the center of the radar. So, we multiply our `blipX` and `blipY` values by half
    the width and the height of the radar; note that we multiply only with half the
    width, since these values are relative to the center of the radar. We then add
    half the width and height of the radar image to the blipX/Y values. So, these
    values are now positioned relative to the center.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的位置值需要以像素长度表示，相对于雷达的中心。因此，我们将`blipX`和`blipY`值乘以雷达宽度和高度的一半；注意我们只乘以宽度的一半，因为这些值是相对于雷达中心的。然后我们将雷达图像宽度和高度的一半加到blipX/Y值上。因此，这些值现在相对于中心定位。
- en: Finally, a new **Vector2** object is created and returned, passing back these
    final calculated X and Y pixel values for the position of our blip icon.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建并返回一个新的**Vector2**对象，返回这些最终计算的X和Y像素值，用于我们闪烁图标的位置。
- en: The DrawBlip() method
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DrawBlip()`方法'
- en: The `DrawBlip()` method takes the input parameters of the position of the blip
    (as a **Vector2** X, Y pair), and the reference to the **RawImage** prefab to
    be created at that location on the radar.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawBlip()`方法接受闪烁位置（作为一个**Vector2** X, Y对）的输入参数，以及要创建在雷达上该位置的**RawImage**预制件的引用。'
- en: A new GameObject is created (Instantiated) from the prefab, and is parented
    to the **radar** GameObject (of which the scripted object is also a component).
    A reference is retrieved from the **Rect Transform** of the new **RawImage** GameObject
    that has been created for the blip. Calls to the Unity **RectTransform** method
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 从预制件中创建（实例化）一个新的GameObject，并将其作为父对象添加到**radar**GameObject（脚本对象也是其组件）。从新创建的**RawImage**GameObject的**Rect
    Transform**中检索引用。调用Unity的**RectTransform**方法
- en: '`SetInsetAndSizeFromParentEdge(...)`  result in the blip GameObject being positioned
    at the provided horizontal and vertical locations over the radar image, regardless
    of where in the Game panel the background radar image has been located.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetInsetAndSizeFromParentEdge(...)`  导致闪烁GameObject被定位在雷达图像提供的水平和垂直位置上，无论背景雷达图像在游戏面板中的位置如何。'
- en: There's more...
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details you don't want to miss.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Adapt for object heights and opaque obstacles
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应对象高度和不透明障碍物
- en: This radar script scans 360 degrees all around the player, and only considers
    straight line distances in the X-Z plane. So, the distances in this radar are
    not affected by any height difference between the player and target GameObjects.
    The script can be adapted to ignore targets whose height is more than some threshold
    different to the player's height.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 此雷达脚本在玩家周围扫描360度，并且只考虑X-Z平面上的直线距离。因此，此雷达中的距离不受玩家和目标GameObject之间任何高度差异的影响。该脚本可以修改为忽略高度与玩家高度差异超过某个阈值的对象。
- en: Also, as presented, this recipe radar sees through *everything*, even if there
    are obstacles between the player and the target. The recipe can be extended to
    not show obscured targets through the use of the Ray Casting techniques. See the
    Unity scripting reference for more details about ray-casting: [http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如所展示的，这种配方雷达能够穿透*一切*，即使玩家和目标之间存在障碍。该配方可以通过使用光线投射技术来扩展，以避免显示被遮挡的目标。有关光线投射的更多详细信息，请参阅Unity脚本参考：[http://docs.unity3d.com/ScriptReference/Physics.Raycast.html](http://docs.unity3d.com/ScriptReference/Physics.Raycast.html).
