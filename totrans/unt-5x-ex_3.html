<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Project B – the Space Shooter</h1></div></div></div><p>This chapter enters new territory now as we begin development work on our second game, which is a twin-stick space shooter. The twin-stick genre simply refers to any game in which the player input for motion spans two dimensions or axes, typically one axis for movement and one for rotation. Example twin-stick games include <em>Zombies Ate My Neighbors</em> and <em>Geometry Wars</em>. Our game will rely heavily on coding in C#, as we'll see. The primary purpose of this is to demonstrate by example just how much can be achieved with Unity procedurally (that is, via script), even without using the editor and level-building tools. We'll still use these tools to some extent but not as much here, and that's a deliberate and not an accidental move. Consequently, this chapter assumes that you have not only completed the game project created in the previous two chapters, but also have a good, basic knowledge of C# scripting generally, though not necessarily in Unity. So, let's roll up our sleeves, if we have any, and get stuck in making a twin-stick shooter. This chapter covers the following important topics as well as others:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spawning and prefabs</li><li class="listitem" style="list-style-type: disc">Twin-stick controls and axial movement</li><li class="listitem" style="list-style-type: disc">Player controllers and shooting mechanics</li><li class="listitem" style="list-style-type: disc">Basic enemy movement and AI</li></ul></div><div><div><h3 class="title"><a id="note14"/>Note</h3><p>Remember to see the game created here, and its related work, in abstract terms, that is, as general tools and concepts with multiple applications. For your own projects, you may not want to make a twin-stick shooter, and that's fine. I cannot possibly know every kind of game that you want to make. However, it's important to see the ideas and tools used here as being transferrable, as being the kind of things you can creatively use for your own games. Being able to see this is very important when working with Unity or any engine.</p></div></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Looking ahead – the completed project</h1></div></div></div><p>Before getting stuck in <a id="id176" class="indexterm"/>with the twin-stick shooter game, let's see what the completed project looks like and how it works. See <em>Figure 3.1</em>. The game to be created will contain one scene only. In this scene, the player controls a spaceship that can shoot oncoming enemies. The directional keyboard arrows, and WASD, move the spaceship around the level, and it will always turn to face the mouse pointer. Clicking the left mouse button will fire ammo.</p><div><img src="img/B05118_03_01.png.jpg" alt="Looking ahead – the completed project"/><div><p>Figure 3.1: The completed twin-stick shooter game</p></div></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>The completed <code class="literal">TwinStickShooter</code> project, as discussed in this chapter and the next, can be found in the book companion files in the <code class="literal">Chapter03/TwinStickShooter folder</code>.</p><p>Most assets for this game (including sound and textures) were sourced from the freely accessible site, <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. Here, you can find many game assets available <a id="id177" class="indexterm"/>through the public domain or creative common licenses or other licenses.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Getting started with a space shooter</h1></div></div></div><p>To get started, create <a id="id178" class="indexterm"/>a blank Unity 3D project without any packages or specific assets. Details about creating new projects can be found in <a class="link" href="ch01.html" title="Chapter 1. The Coin Collection Game – Part 1">Chapter 1</a>, <em>The Coin Collection Game – Part 1</em>. We'll be coding everything from scratch this time around. Once a project is generated, create some basic folders to structure and organize the project assets from the outset. This is very important to keep track of your files as you work. Create folders for <code class="literal">Textures</code>, <code class="literal">Scenes</code>, <code class="literal">Materials</code>, <code class="literal">Audio</code>, <code class="literal">Prefabs</code>, and <code class="literal">Scripts</code>. See <em>Figure 3.2</em>:</p><div><img src="img/B05118_03_02.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.2: Create folders for structure and organization</p></div></div><p>Next, our game will depend on some graphical and audio assets. These are included in the book companion files in the <code class="literal">Chapter03/Assets</code> folder, but can also be downloaded online from <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. Let's start with textures for the player spaceship, enemy spaceships, and star-field background. Drag and drop <code class="literal">Textures</code> from Windows Explorer or Finder to the Unity <strong>Project</strong> panel in the <code class="literal">Textures</code> folder. Unity imports and configures the <a id="id179" class="indexterm"/>textures automatically. <em>See Figure 3.3</em>:</p><div><img src="img/B05118_03_03.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.3: Importing Texture assets for the spaceship, enemies, star background, and ammo</p></div></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Use of the provided assets is optional. You can create your own if you prefer. Just drag and drop your own textures in place of the included assets, and you can still follow along with the tutorial just fine.</p></div></div><p>By default, Unity imports image files as regular textures for use on 3D objects, and it assumes that their pixel dimensions are a power-2 size (4, 8, 16, 32, 64, 128, 256, and so on). If the size is not actually one of these, then Unity will up-scale or down-scale the texture to the nearest valid size. This is not appropriate behavior, however, for a 2D top-down space shooter game in which imported textures should appear at their native (imported) size without any scaling or automatic adjustment. To fix this, select all the imported textures and, from the <strong>Object Inspector</strong>, change their <strong>Texture Type</strong> from <strong>Texture</strong> to <strong>Sprite (2D and UI)</strong>. Once changed, click on the <strong>Apply</strong> button to update the settings and the <a id="id180" class="indexterm"/>textures will retain their imported dimensions. See <em>Figure 3.4</em>:</p><div><img src="img/B05118_03_04.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.4: Changing the Texture type for imported textures</p></div></div><p>After changing the <strong>Texture Type</strong> setting to <strong>Sprite (2D and UI)</strong>, also remove the check mark from the <strong>Generate Mip Maps</strong> box, in case this box is enabled. This will prevent Unity from automatically downgrading the quality of textures based on their distance from the camera in the scene. This ensures that your textures retain their highest quality. More information on <a id="id181" class="indexterm"/>2D texture settings and Mip Maps can be found at the online Unity documentationat <a class="ulink" href="http://docs.unity3d.com/Manual/class-TextureImporter.html">http://docs.unity3d.com/Manual/class-TextureImporter.html</a>. <em>See Figure 3.5</em>:</p><div><img src="img/B05118_03_05.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.5: Removing MipMapping from imported textures</p></div></div><p>Now you can easily drag and drop your textures to the scene adding them as sprite objects. You can't drag and drop them from the <strong>Project</strong> panel to the viewport, but you can drag and drop them from the <strong>Project</strong> panel to the <strong>Hierarchy</strong> panel. When you do this, the texture will automatically be added as a sprite object in the <strong>Scene</strong>. We'll make frequent use of this <a id="id182" class="indexterm"/>feature as we work at creating spaceship objects. See <em>Figure 3.6</em>:</p><div><img src="img/B05118_03_06.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.6: Adding sprites to the scene</p></div></div><p>Next, let's import music and sound effects, which are also included in the book companion files in the <code class="literal">Chapter03/Assets/Audio</code> folder. These assets were downloaded from <a class="ulink" href="http://OpenGameArt.org">OpenGameArt.org</a>. To import the audio, simply drag and drop the files from Windows Explorer or Mac Finder to the <strong>Project</strong> panel. When you do this, Unity automatically imports and configures the assets. You can give the audio a test from within the Unity <a id="id183" class="indexterm"/>Editor by pressing play on the preview toolbar from the <strong>Object Inspector</strong>. See <em>Figure 3.7</em>:</p><div><img src="img/B05118_03_07.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.7: Previewing audio from the Object Inspector</p></div></div><p>As with texture files, Unity imports audio files using a set of default parameters. These parameters are typically suitable for short sound effects such as footsteps, gunshots, and explosions, but for longer tracks such as music, they can be problematic, causing long level-loading times. To fix this, select the music track in the <strong>Project</strong> panel, and from the <strong>Object Inspector</strong>, disable the <strong>Preload Audio Data</strong> checkbox. From the <strong>Load Type</strong> drop-down box, select the <strong>Streaming</strong> option. This ensures that the music track is streamed as opposed to loaded wholly in memory at level startup. See <em>Figure 3.8</em>:</p><div><img src="img/B05118_03_08.png.jpg" alt="Getting started with a space shooter"/><div><p>Figure 3.8: Configuring music tracks for streaming</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Creating a player object</h1></div></div></div><p>We've now <a id="id184" class="indexterm"/>imported most assets for the twin-stick shooter and we're ready to create a player spaceship object, that is, the object that the player will control and move around. Creating this might seem a trivial matter of simply dragging and dropping the relevant player sprite from the <strong>Project</strong> panel to the scene, but things are not so simple. The player is a complex object with many different behaviors, as we'll see. For this reason, more care needs to be taken about creating the player. To get started, create an empty game object in the scene by navigating to <strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu and name the object, <code class="literal">Player</code>. See <em>Figure 3.9</em>:</p><div><img src="img/B05118_03_09.png.jpg" alt="Creating a player object"/><div><p>Figure 3.9: Starting to create the player</p></div></div><p>The newly created object may or may not be centered at the world origin of <em>(0, 0, 0)</em> and its rotation properties may not be consistently <code class="literal">0</code> across <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong>. To ensure a completely zeroed transform, you could manually set the values to <code class="literal">0</code> by entering them directly in the <strong>Transform</strong> component for the object in the <strong>Object Inspector</strong>. However, you can set them all to <code class="literal">0</code> automatically by clicking on the cog icon at the top left corner of the <strong>Transform</strong> component and selecting <strong>Reset</strong> from the context menu. See <em>Figure 3.10</em>:</p><div><img src="img/B05118_03_10.png.jpg" alt="Creating a player object"/><div><p>Figure 3.10: Resetting the Transform component</p></div></div><p>Next, drag and drop the <code class="literal">Player</code> drop ship sprite (in the <code class="literal">Textures</code> folder) from the <strong>Project</strong> panel to the <strong>Hierarchy</strong> panel, making it a child of the empty player object. Then, rotate the drop ship sprite by <code class="literal">90</code> degrees in <strong>X</strong> and <code class="literal">-90</code> degrees in <strong>Y</strong>. This makes the sprite oriented in the <a id="id185" class="indexterm"/>direction of its parent's forward vector and also flattened on the ground plane. The game camera will take a top-down view. See <em>Figure 3.11</em>:</p><div><img src="img/B05118_03_11.png.jpg" alt="Creating a player object"/><div><p>Figure 3.11: Aligning the Player ship</p></div></div><p>You can confirm that the ship sprite has been aligned correctly in relation to its parent by selecting the <code class="literal">Player</code> object and viewing the blue forward vector arrow. The front of the ship sprite and the blue forward vector should be pointing in the same direction. If they're not, then continue to rotate the sprite by 90 degrees until they're in alignment. This will be important later when coding player movement to make the ship travel in the direction it's looking. See <em>Figure 3.12</em>:</p><div><img src="img/B05118_03_12.png.jpg" alt="Creating a player object"/><div><p>Figure 3.12: The blue arrow is called the forward vector</p></div></div><p>Next, the <code class="literal">Player</code> object should react to physics, that is, the <code class="literal">Player</code> object is solid and affected by physical forces. It must collide with other solids and also take damage from enemy ammo when <a id="id186" class="indexterm"/>hit. To facilitate this, two additional components should be added to the <code class="literal">Player</code> object, specifically, a <strong>Rigidbody</strong> and <strong>Collider</strong>. To do this, select the <code class="literal">Player</code> object (not the <code class="literal">Sprite</code> object) and navigate to <strong>Component</strong> | <strong>Physics</strong> | <strong>Rigidbody</strong> from the application menu. Then, choose <code class="literal">Component</code> | <strong>Physics</strong> | <strong>Capsule Collider</strong> from the menu. This adds both a <strong>Rigidbody</strong> and <strong>Collider</strong>. See <em>Figure 3.13</em>:</p><div><img src="img/B05118_03_13.png.jpg" alt="Creating a player object"/><div><p>Figure 3.13: Adding a Rigidbody and Capsule Collider to the Player object</p></div></div><p>The <strong>Collider</strong> component is used to approximate the volume of the object and the <strong>Rigibody</strong> component uses the <strong>Collider</strong> to determine how physical forces should be applied realistically. Let's adjust <strong>Capsule Collider</strong> a little because the default settings typically do not match up with the <code class="literal">Player</code> sprite as intended. Specifically, adjust the <strong>Direction</strong>, <strong>Radius</strong>, and <strong>Height</strong> values until <strong>Capsule</strong> encompasses the <code class="literal">Player</code> sprite and represents the <a id="id187" class="indexterm"/>volume of the player. See <em>Figure 3.14</em>:</p><div><img src="img/B05118_03_14.png.jpg" alt="Creating a player object"/><div><p>Figure 3.14: Adjusting the spaceship Capsule Collider</p></div></div><p>By default, the <code class="literal">Rigidbody</code> component is configured to approximate objects that are affected by gravity and fall to the ground, bumping into and reacting to other solids in the scene. This is not appropriate for a spaceship that flies around. Consequently, the <code class="literal">Rigidbody</code> should be adjusted. Specifically, remove the <strong>Use Gravity</strong> check mark to prevent the object from falling to the ground. Additionally, enable the <strong>Freeze Position</strong> <strong>Y</strong> checkbox and the <strong>Freeze Rotation</strong> <strong>Z</strong> checkbox to prevent the spaceship moving and rotating around axes that are undesirable in a 2D top-down game. See <em>Figure 3.15</em>:</p><div><img src="img/B05118_03_15.png.jpg" alt="Creating a player object"/><div><p>Figure 3.15: Configuring the Rigidbody component for the player spaceship</p></div></div><p>Excellent work! We've now configured the player spaceship object successfully. Of course, it still doesn't move or do anything specific in the game. This is simply because we haven't added any <a id="id188" class="indexterm"/>code yet. That's something we'll turn to next—making the player object respond to user input.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Player input</h1></div></div></div><p>The <code class="literal">Player</code> object is <a id="id189" class="indexterm"/>now created in the scene, configured with both <strong>Rigidbody</strong> and <strong>Collider</strong> components. However, this object doesn't respond to player controls. In a twin-stick shooter, the player provides input on two axes and can typically shoot a weapon. This often means that keyboard WASD buttons guide player movements up, down, left, and right. In addition, mouse movement controls the direction in which the player is looking and aiming and the left mouse button typically fires a weapon. This is the control scheme required for our game. To implement this, we'll need to create a <code class="literal">PlayerController</code> script file. Right-click on the <code class="literal">Scripts</code> folder of the <strong>Project</strong> panel and create a new C# script file named <code class="literal">PlayerController.cs</code>. See <em>Figure 3.16</em>:</p><div><img src="img/B05118_03_16.png.jpg" alt="Player input"/><div><p>Figure 3.16: Creating a player controller C# script file</p></div></div><p>In the <code class="literal">PlayerController.cs</code> script file, the following code (as shown in <em>Code Sample 3.1</em>) should be featured. Comments follow this sample:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class PlayerController : MonoBehaviour
{
  //------------------------------
  private Rigidbody ThisBody = null;
  private Transform ThisTransform = null;
  
  public bool MouseLook = true;
  <strong>public string HorzAxis = "Horizontal";</strong>
  <strong>public string VertAxis = "Vertical";</strong>
  <strong>public string FireAxis = "Fire1";</strong>
  public float MaxSpeed = 5f;

  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisBody = GetComponent&lt;Rigidbody&gt;();
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void FixedUpdate ()
  {
    //Update movement
    <strong>float Horz = Input.GetAxis(HorzAxis);</strong>
    <strong>float Vert = Input.GetAxis(VertAxis);</strong>
    Vector3 MoveDirection = new Vector3(Horz, 0.0f, Vert);
    <strong>ThisBody.AddForce</strong>(MoveDirection.normalized * MaxSpeed);
    
    //Clamp speed
    ThisBody.velocity = new Vector3(Mathf.Clamp(ThisBody.velocity.x, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.y, -MaxSpeed, MaxSpeed),
      Mathf.Clamp(ThisBody.velocity.z, -MaxSpeed, MaxSpeed));
    
    //Should look with mouse?
    <strong>if(MouseLook)</strong>
    {
      //Update rotation - turn to face mouse pointer
      Vector3 MousePosWorld = Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, 0.0f));
        MousePosWorld = new Vector3(MousePosWorld.x, 0.0f, MousePosWorld.z);
      //Get direction to cursor
      Vector3 LookDirection = MousePosWorld - ThisTransform.position;
      
      //FixedUpdate rotation
      <strong>ThisTransform.localRotation</strong> = Quaternion.LookRotation(LookDirection.normalized,Vector3.up);
    }

  }
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Code Sample 3.1</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">PlayerController</code> class should be attached to the <code class="literal">Player</code> object in the scene. Overall, it accepts input from the player and will control the movement of the spaceship.</li><li class="listitem" style="list-style-type: disc">The <a id="id190" class="indexterm"/><code class="literal">Awake</code> function is called once when the object is created at the level start. During this function, two components are retrieved, namely, the <strong>Transform</strong> component for controller player rotation and the <strong>Rigidbody</strong> component for controller player movement. The <strong>Transform</strong> component can be used to control player movement through the <strong>Position</strong> property, but this ignores collisions and solid objects. The <strong>Rigidbody</strong> component, in contrast, prevents the player object from passing through other solids.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">FixedUpdate</code> function is called once on each update of the physics system, which is a fixed number of times per second. <code class="literal">FixedUpdate</code> differs from <code class="literal">Update</code>, which is called once per frame and can vary on a per second basis as the frame rate fluctuates. If you ever need to control an object through the physics system, using components such as <strong>Rigidbody</strong>, then you should always do so in <code class="literal">FixedUpdate</code> and not <code class="literal">Update</code>. This is a Unity convention that you should remember for best results.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Input.GetAxis</code> function is called on each <code class="literal">FixedUpdate</code> to read the axial input data from an input device, such as the keyboard or gamepad. This function reads from two named axes, <code class="literal">Horizontal</code> (left-right) and <code class="literal">Vertical</code> (up-down). These work in a normalized space of <em>-1</em> to <em>1</em>. This means that when the left key is pressed and held down, the <code class="literal">Horizontal</code> axis returns <em>-1</em> and, when the right key is being pressed and held down, the <code class="literal">Horizontal</code> axis returns <em>1</em>. A value of <em>0</em> indicates that either no relevant key is being pressed or both left and right are being pressed together, canceling each other out. A similar principle applies for the <code class="literal">Vertical</code> axis. Up refers to <em>1</em>, down to <em>-1</em>, and no keypress relates to <em>0</em>. More information on the <code class="literal">GetAxis</code> function can be found <a id="id191" class="indexterm"/>online in the Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Input.GetAxis.html">http://docs.unity3d.com/ScriptReference/Input.GetAxis.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Rigidbody.AddForce</code> function is used to apply a physical force to the <code class="literal">Player</code> object, moving it in a specific direction. <code class="literal">AddForce</code> encodes a velocity, moving the object in a specific direction by a specific strength. The direction is encoded in the <code class="literal">MoveDirection</code> vector, which is based on player input from both the <code class="literal">Horizontal</code> and <code class="literal">Vertical</code> axes. This direction is multiplied by our maximum speed to ensure that the object travels as fast as needed. For more <a id="id192" class="indexterm"/>information on <code class="literal">AddForce</code>, see the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html">http://docs.unity3d.com/ScriptReference/Rigidbody.AddForce.html</a>.</li><li class="listitem" style="list-style-type: disc">The <a id="id193" class="indexterm"/><code class="literal">Camera.ScreenToWorldPoint</code> function is used to convert the screen position of the mouse cursor in the game window into a position in the game world, giving the player a target destination to look at. This code is responsible for making the player look at the mouse cursor always. However, as we'll see soon, some further tweaking is required to make this code work properly. For <a id="id194" class="indexterm"/>more information on <code class="literal">ScreenToWorldPoint</code>, see the Unity online documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html">http://docs.unity3d.com/ScriptReference/Camera.ScreenToWorldPoint.html</a>.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Configuring the game camera</h1></div></div></div><p>The preceding <a id="id195" class="indexterm"/>code allows you to control the <code class="literal">Player</code> object, but there are some problems. One of them is that the player doesn't seem to face the position of the mouse cursor, even though our code is designed to achieve this behavior. The reason is that the camera, by default, is not configured as it needs to be for a top-down 2D game. We'll fix this in this section. To get started, the scene camera should have a top-down view of the scene. To achieve this, switch the <strong>Scene</strong> viewport to a top-down 2D view by clicking on the <strong>ViewCube</strong>, the up arrow in the top right corner of the <strong>Scene</strong> viewport. This switches your viewport to a top view. See <em>Figure 3.17</em>:</p><div><img src="img/B05118_03_17.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.17: The viewcube can change the viewport perspective</p></div></div><p>You can see <a id="id196" class="indexterm"/>that the viewport is in a top view because the viewcube will list <strong>Top</strong> as the current view. See <em>Figure 3.18</em>:</p><div><img src="img/B05118_03_18.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.18: Top view in the Scene viewport</p></div></div><p>From here, you can have the scene camera conform to the viewport camera exactly, giving you an instant top-down view for your game. To do this, select the <strong>Camera</strong> in the <strong>Scene</strong> (or from the <strong>Hierarchy</strong> panel) and then choose <strong>GameObject</strong> | <strong>Align With View</strong> from the application menu. See <em>Figure 3.19</em>:</p><div><img src="img/B05118_03_19.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.19: Aligning the camera to the Scene viewport</p></div></div><p>This makes your <a id="id197" class="indexterm"/>game look much better than before, but there's still a problem. When the game is running, the spaceship still doesn't look at the mouse cursor as intended. This is because the camera is a <strong>Perspective</strong> camera and the conversion between a screen point and world point is leading to unexpected results. We can fix this by changing the camera to an <strong>Orthographic</strong> camera, which is a truly 2D camera that allows no perspective distortion. To do this, select the <strong>Camera</strong> in the scene, and from the <strong>Object Inspector</strong>, change the <strong>Projection</strong> setting from <strong>Perspective</strong> to <strong>Orthographic</strong>:</p><div><img src="img/B05118_03_20.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.20: Changing the Camera to Orthographic mode</p></div></div><p>Every orthographic camera has a <strong>Size</strong> field in the <strong>Object Inspector</strong>, which is not present for perspective cameras. This field controls how many units in the world view correspond to pixels on the screen. We want a 1:1 ratio or relationship between world units to pixels in order to ensure that our textures appear at the correct size and cursor movement has the intended effect. The <a id="id198" class="indexterm"/>target resolution for our game will be Full HD, which is 1920 x 1080, and this has an aspect ratio of 16:9. For this resolution, the orthographic <strong>Size</strong> should be <code class="literal">5.4</code>. The reasons for this value are beyond the scope of this book, but the formula to arrive at it is <em>screen height (in pixels) / 2 / 100</em>. Therefore, <em>1080 / 2 / 100 = 5.4</em>. See <em>Figure 3.21</em>:</p><div><img src="img/B05118_03_21.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.21: Changing orthographic size for a 1:1 pixel-to-screen ratio</p></div></div><p>Finally, make sure that your <strong>Game</strong> tab view is configured to display the game at a <strong>16:9</strong> aspect ratio. If it isn't, click on the aspect drop-down list at the top left corner of the <strong>Game</strong> view and choose the <strong>16:9</strong> option. See <em>Figure 3.22</em>:</p><div><img src="img/B05118_03_22.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.22: Displaying the game at a 16:9 aspect ratio</p></div></div><p>Now try running the game, and you have a player spaceship that moves based on WASD input and also turns to face the mouse cursor. Great work! See <em>Figure 3.23</em>. The game is really taking <a id="id199" class="indexterm"/>shape. However, there's lots more work to do.</p><div><img src="img/B05118_03_23.png.jpg" alt="Configuring the game camera"/><div><p>Figure 3.23: Turning to face the cursor!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Bounds locking</h1></div></div></div><p>On previewing the <a id="id200" class="indexterm"/>game thus far, the spaceship probably looks too large. We can fix this easily by changing the scale of the <code class="literal">Player</code> object. I've used a value of <code class="literal">0.5</code> for the <strong>X</strong>, <strong>Y</strong>, and <strong>Z</strong> axes. See <em>Figure 3.24</em>. However, even with a more sensible scale, a problem remains. Specifically, it's possible to move the player outside the boundaries of the screen without limit. This means that the player can fly off into the distance, out of view, and never be seen again. Instead, the camera should remain still and the player movement should be limited to the camera view or bounds so that it never exits the view.</p><div><img src="img/B05118_03_24.png.jpg" alt="Bounds locking"/><div><p>Figure 3.24: Rescaling the player</p></div></div><p>There are different ways to achieve bounds locking, most of which involve scripting. One way is to simply clamp the positional values of the <code class="literal">Player</code> object between a specified range, a minimum and maximum. Consider <em>Code Sample 3.2</em> for a new C# class called <code class="literal">BoundsLock</code>. This <a id="id201" class="indexterm"/>script file should be attached to the player.</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class BoundsLock : MonoBehaviour 
{
  //------------------------------
  private Transform ThisTransform = null;
  public Vector2 HorzRange = Vector2.zero;
  public Vector2 VertRange = Vector2.zero;
  //------------------------------
  // Use this for initialization
  void Awake ()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void <strong>LateUpdate</strong> () 
  {
    //Clamp position
    ThisTransform.position = new Vector3(Mathf.Clamp(ThisTransform.position.x, HorzRange.x, HorzRange.y),
    ThisTransform.position.y,
    Mathf.Clamp(ThisTransform.position.z, VertRange.x, VertRange.y));
  }
  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Code Sample 3.2</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id202" class="indexterm"/><code class="literal">LateUpdate</code> function is always called after all the <code class="literal">FixedUpdate</code> and <code class="literal">Update</code> calls, allowing an object to modify its position before it's rendered to the screen. More information <a id="id203" class="indexterm"/>on <code class="literal">LateUpdate</code> can be found at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html">http://docs.unity3d.com/ScriptReference/MonoBehaviour.LateUpdate.html</a>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Mathf.Clamp</code> function ensures that a specified value is capped between a minimum and maximum range.</li><li class="listitem" style="list-style-type: disc">To use the <code class="literal">BoundsLock</code> script, simply drag and drop the file to the <code class="literal">Player</code> object and specify minimum and maximum values for its position. These values are specified in world position coordinates and can be determined by temporarily moving the <code class="literal">Player</code> object to the camera extremes and recording its position from the <strong>Transform</strong> component:</li></ul></div><div><img src="img/B05118_03_25.png.jpg" alt="Code Sample 3.2"/><div><p>Figure 3.25: Setting Bounds Lock</p></div></div><p>Now take the game for a test run by pressing play on the toolbar. The player spaceship should remain in view and be unable to move offscreen. Splendid!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Health</h1></div></div></div><p>Both the player <a id="id204" class="indexterm"/>spaceship and enemies need health. Health is a measure of a character's presence and legitimacy in the scene, typically scored as a value between 0-100. 0 means death and 100 means full health. Now, although health is, in many respects, specific to each instance, (The player has a unique health bar and each enemy has theirs.) there are nevertheless so many things in common, in terms of behavior, between player and enemy health that it makes sense to code health as a separate component and class that can be attached to all objects that need health. Consider <em>Code Sample 3.3</em>, which should be attached to the player and all enemies or objects that need health. Comments follow:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
//------------------------------
public class Health : MonoBehaviour
{
  public GameObject DeathParticlesPrefab = null;
  private Transform ThisTransform = null;
  public bool ShouldDestroyOnDeath = true;
  //------------------------------
  void Start()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  <strong>public float HealthPoints</strong>
  {
    get
    {
      return _HealthPoints;
    }

    set
    {
      _HealthPoints = value;

      <strong>if(_HealthPoints &lt;= 0)</strong>
      {
        <strong>SendMessage</strong>("Die", SendMessageOptions.DontRequireReceiver);

        if(DeathParticlesPrefab != null)
          Instantiate(DeathParticlesPrefab, ThisTransform.position, ThisTransform.rotation);

        if(ShouldDestroyOnDeath)
          Destroy(gameObject);
      }
    }
  }
  //------------------------------
  <strong>[SerializeField]</strong>
  private float _HealthPoints = 100f;
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Code Sample 3.3</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id205" class="indexterm"/><code class="literal">Health</code> class maintains object health through a <code class="literal">private</code> variable, <code class="literal">_HealthPoints</code>, which is accessed through a C# property, <code class="literal">HealthPoints</code>. This property features both <code class="literal">get</code> and <code class="literal">set</code> accessors to return and set the <code class="literal">Health</code> variable.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">_HealthPoints</code> variable is declared as <code class="literal">SerializedField</code>, allowing its value to be visible in the <strong>Inspector</strong>. This helps us see the value of the player's health during runtime and debug and test the effects of our code.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Health</code> class is an example of event-driven programming. This is because the class could have continually checked the status of object health during an <code class="literal">Update</code> function; checking to see whether the object had died by its health falling below <em>0</em>. Instead, the check for death is made during the C# property <code class="literal">set</code> method. This makes sense because <code class="literal">set</code> is the only place where health will ever change. This means that Unity is saved from a lot of work in each frame. That's great performance saving!</li><li class="listitem" style="list-style-type: disc"><code class="literal">Health</code> class uses the <code class="literal">SendMessage</code> function. This function lets you call any other public function on any component attached to the object by specifying the function name as a string. In this case, a function called <code class="literal">Die</code> will be executed on every component attached to the object (if such a function exists). If no function of a matching name exists, then nothing happens for that component. This is a quick and easy way to run customized behavior on an object in a type-agnostic way without using any polymorphism. The disadvantage is that <code class="literal">SendMessage</code> internally uses a process called <code class="literal">Reflection</code>, which is slow and performance-prohibitive. For this reason, <code class="literal">SendMessage</code> should be used infrequently only for death events and similar events, but not frequently, such as every frame. More information on <code class="literal">SendMessage</code> can <a id="id206" class="indexterm"/>be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">http://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html</a>.</li><li class="listitem" style="list-style-type: disc">When health falls below <em>0</em>, triggering a death condition, the code will instantiate a death particle system to show an effect on death if a particle system is specified (more on this shortly).</li></ul></div><p>When the <a id="id207" class="indexterm"/>
<code class="literal">Health</code> script is attached to the player spaceship, it appears as a component in the <strong>Inspector</strong>. It contains a field for a <strong>Death Particles Prefab</strong>. This is an optional field (it can be null), specifying a particle system to be spawned when the object dies. This lets you create explosions or blood splatter effects easily when objects die. See <em>Figure 3.26</em>:</p><div><img src="img/B05118_03_26.png.jpg" alt="Code Sample 3.3"/><div><p>Figure 3.26: Attaching the Health script</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Death and particles</h1></div></div></div><p>In this <a id="id208" class="indexterm"/>twin-stick shooter game, both the player and enemies are spaceships. When they're destroyed, they should explode in a fiery ball. This is really the only kind of effect that would be believable. To achieve explosions, we can use a particle system. This simply refers to a special kind of object that features two main parts, namely, a <strong>Hose</strong> (or <strong>Emitter</strong>) and <strong>Particles</strong>. The emitter refers to the part that spawns or generates new particles into the world and the particles are many small <a id="id209" class="indexterm"/>objects or pieces that, once spawned, move and travel along their own trajectories. In short, particle systems are ideal to create rain, snow, fog, sparkles, and explosions. We can create our own Particle Systems from scratch using the menu option, <strong>GameObject</strong> | <strong>Particle System</strong>, or we can use any premade particle system included with Unity. Let's use some of the premade particle systems. To do this, import the <code class="literal">ParticleSystems</code> package to the project by navigating to <strong>Assets</strong> | <strong>Import Package</strong> | <strong>ParticleSystems</strong> from the application menu. See <em>Figure 3.27</em>:</p><div><img src="img/B05118_03_27.png.jpg" alt="Death and particles"/><div><p>Figure 3.27: Importing Particle Systems to the project</p></div></div><p>After the <strong>Import</strong> dialog appears, leave all settings at their defaults, and simply click on <strong>Import</strong> to import the complete package, including all particle systems. The <code class="literal">ParticleSystems</code> will be added to the <strong>Project</strong> panel in the <code class="literal">Standard Assets</code> | <code class="literal">ParticleSystems</code> | <code class="literal">Prefabs</code> folder. See <em>Figure 3.28</em>. You can test each of the particle systems by <a id="id210" class="indexterm"/>simply dragging and dropping each prefab to the scene. Note that you can only preview a particle system in the <strong>Scene</strong> viewport while it is selected.</p><div><img src="img/B05118_03_28.png.jpg" alt="Death and particles"/><div><p>Figure 3.28: Particle Systems imported to the Project panel</p></div></div><p>Notice from <em>Figure 3.28</em> that an <strong>Explosion</strong> system is included among the default assets, which is great news! To test, we can just drag and drop the explosion to the scene, press play on the toolbar, and see the explosion in action. Good! We're almost done, but there's still a bit more work. We've now seen that an appropriate particle system is available and we could just drag and drop this system to the <strong>Death Particles Prefab</strong> slot in the <strong>Health</strong> component in the <strong>Inspector</strong>. This will work technically: when a player or enemy dies, the explosion system will be spawned, creating an explosion effect. However, the particle system will never be destroyed! This is problematic because, on each enemy death, a new particle system will be spawned. This raises the possibility that, after many deaths, the scene will be full of disused particle systems. We don't want this; it's bad for performance and memory usage to have a scene full of unused objects lingering around. To fix this, we'll modify the explosion system slightly, creating a new and modified prefab that'll suit our needs. To <a id="id211" class="indexterm"/>create this, drag and drop the existing explosion system anywhere to the scene and position it at the world origin. See <em>Figure 3.29</em>:</p><div><img src="img/B05118_03_29.png.jpg" alt="Death and particles"/><div><p>Figure 3.29: Adding an Explosion system to the scene for modification</p></div></div><p>Next, we must refine the particle system to destroy itself soon after instantiation. By making a prefab from this arrangement, each and every generated explosion will eventually destroy itself. To make an object destroy itself after a specified interval, we'll create a new C# script. I'll name this script <code class="literal">TimeDestroy.cs</code>. Refer the following code in <em>Code Sample 3.4</em>:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class TimedDestroy : MonoBehaviour 
{
  public float DestroyTime = 2f;

  //------------------------------
  // Use this for initialization
  void Start ()
  {
    Invoke("Die", DestroyTime);
  }
  
  
  void Die () 
  {
    Destroy(gameObject);
  }
  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Code Sample 3.4</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id212" class="indexterm"/><code class="literal">TimeDestroy</code> class simply destroys the object to which it's attached after a specified interval (<code class="literal">DestroyTime</code>) has elapsed.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Invoke</code> function is called in the <code class="literal">Start</code> event. Invoke will execute a function of the specified name once, and only once, after a specified interval has elapsed. The interval is measured in seconds.</li><li class="listitem" style="list-style-type: disc">Like <code class="literal">SendMessage</code>, the <code class="literal">Invoke</code> function relies on <code class="literal">Reflection</code>. For this reason, it should be used sparingly for best performance.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Die</code> function will be executed by <code class="literal">Invoke</code> after a specified interval to destroy the <code class="literal">gameobject</code> (such as a particle system).</li></ul></div><p>Now, drag and drop the <code class="literal">TimedDestroy</code> script file to the explosion particle system in the scene and then press play on the toolbar to test that the code works and the object is destroyed after the specified interval, which can be adjusted from the <strong>Inspector</strong>. See <em>Figure 3.30</em>:</p><div><img src="img/B05118_03_30.png.jpg" alt="Code Sample 3.4"/><div><p>Figure 3.30: Adding a TimeDestroy script to an explosion Particle System</p></div></div><p>The <code class="literal">TimeDestroy</code> script should remove the explosion particle system after the delay expires. So let's <a id="id213" class="indexterm"/>create a new and separate prefab from this modified version. To do this, rename the explosion system in the <strong>Hierarchy</strong> panel to <code class="literal">ExplosionDestroy</code>, and then drag and drop the system from the <strong>Hierarchy</strong> to the <strong>Project</strong> panel in the <code class="literal">Prefabs</code> folder. Unity automatically creates a new prefab, representing the modified particle system. See <em>Figure 3.31</em>:</p><div><img src="img/B05118_03_31.png.jpg" alt="Code Sample 3.4"/><div><p>Figure 3.31: Create a timed explosion prefab</p></div></div><p>Now, drag and drop the newly created prefab from the <strong>Project</strong> panel to the <strong>Death Particle System</strong> slot on the <strong>Health</strong> component for the <strong>Player</strong> in the <strong>Object Inspector</strong>. This ensures <a id="id214" class="indexterm"/>that the prefab is instantiated when the player dies. See <em>Figure 3.32</em>:</p><div><img src="img/B05118_03_32.png.jpg" alt="Code Sample 3.4"/><div><p>Figure 3.32: Configuring the health script</p></div></div><p>If you run the game now, you'll see that you cannot initiate a player death event to test the particle system generation. Nothing exists in the scene to destroy or damage the player, and you cannot manually set the <strong>Health</strong> points to <code class="literal">0</code> from the <strong>Inspector</strong> in a way that is detected by the C# property <code class="literal">set</code> function. For now, however, we can insert some test death functionality into the <code class="literal">Health</code> script that triggers an instant kill when the spacebar is pressed. Refer to <em>Code Sample 3.5</em> for the modified <code class="literal">Health</code> script:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Health : MonoBehaviour
{
  public GameObject DeathParticlesPrefab = null;
  private Transform ThisTransform = null;
  public bool ShouldDestroyOnDeath = true;
  //------------------------------
  void Start()
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  public float HealthPoints
  {
    get
    {
      return _HealthPoints;
    }

    set
    {
      _HealthPoints = value;

      if(_HealthPoints &lt;= 0)
      {
        SendMessage("Die", SendMessageOptions.DontRequireReceiver);

        if(DeathParticlesPrefab != null)
          Instantiate(DeathParticlesPrefab, ThisTransform.position, ThisTransform.rotation);

        if(ShouldDestroyOnDeath)Destroy(gameObject);
      }
    }
  }
  //------------------------------
  <strong>void Update()</strong>
  <strong>{</strong>
    <strong>if(Input.GetKeyDown(KeyCode.Space))</strong>
      <strong>HealthPoints = 0;</strong>
  <strong>}</strong>
  //------------------------------
  [SerializeField]
  private float _HealthPoints = 100f;
}
//------------------------------</pre></div><p>On running the game now, with the modified <code class="literal">Health</code> script, you can trigger an instant player death by <a id="id215" class="indexterm"/>pressing the spacebar key on the keyboard. When you do this, the player object is destroyed and the particle system is generated until the timer destroys that too. Excellent work! We now have a playable, controllable player character that supports health and death functionality. Things are looking good. See <em>Figure 3.33</em>:</p><div><img src="img/B05118_03_33.png.jpg" alt="Code Sample 3.4"/><div><p>Figure 3.33: Trigger the Explosion particle system</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Enemies</h1></div></div></div><p>The next step is to <a id="id216" class="indexterm"/>create something for the player to shoot and destroy, which can also destroy us, namely, enemy characters. These take the form of roaming spaceships that will be spawned into the scene at regular intervals and will follow the player, drawing nearer and nearer. Essentially, each enemy represents a complex of multiple behaviors working together and these should be implemented as separate scripts. Let's <a id="id217" class="indexterm"/>consider them in turn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Health</strong>: Each enemy supports health functionality. They begin the scene with a specified amount of health and will be destroyed when that health falls below <em>0</em>. We already have a <code class="literal">Health</code> script created to handle this behavior.</li><li class="listitem" style="list-style-type: disc"><strong>Movement</strong>: Each enemy will constantly be in motion, traveling in a straight line along a forward trajectory. That is, each enemy will continually travel forward in the direction it is looking.</li><li class="listitem" style="list-style-type: disc"><strong>Turning</strong>: Each enemy will rotate and turn toward the player even when the player moves. This ensures that the enemy always faces the player and, in combination with the movement functionality, will always be traveling toward the player.</li><li class="listitem" style="list-style-type: disc"><strong>Scoring</strong>: Each enemy rewards the player with a score value when destroyed. Thus, the death of an enemy will increase the player score.</li><li class="listitem" style="list-style-type: disc"><strong>Damage</strong>: Each enemy causes damage to the player on collision. Enemies cannot shoot but will harm the player on proximity.</li></ul></div><p>Now that we've identified the range of behaviors applicable to an enemy, let's create an enemy in the scene. We'll make one specific enemy, create a prefab from that, and use it as the basis to instantiate many enemies. Start by selecting the player character in the scene and duplicate the object with <em>Ctrl</em> + <strong>D</strong> or select <strong>Edit</strong> | <strong>Duplicate</strong> from the application menu. This <a id="id218" class="indexterm"/>initially creates a second player. See <em>Figure 3.34</em>:</p><div><img src="img/B05118_03_34.png.jpg" alt="Enemies"/><div><p>Figure 3.34: Duplicating the Player object</p></div></div><p>Rename the object to <code class="literal">Enemy</code> and ensure that it is not tagged as <code class="literal">Player</code>, as there should be one and only one object in the scene with the <code class="literal">Player</code> tag, namely, the real player. In addition, temporarily disable the <code class="literal">Player</code> game object, allowing us to focus more clearly on the <code class="literal">Enemy</code> object in the <strong>Scene</strong> tab. See <em>Figure 3.35</em>:</p><div><img src="img/B05118_03_35.png.jpg" alt="Enemies"/><div><p>Figure 3.35: Removing a Player tag from the enemy, if applicable</p></div></div><p>Select the sprite child object of the duplicated enemy, and from the <strong>Object Inspector</strong>, click on the <strong>Sprite</strong> field of the <strong>Sprite Renderer</strong> component to pick a new sprite. Pick one of the darker imperial ships for the enemy character, and the sprite will update for the object in the <a id="id219" class="indexterm"/>viewport. See <em>Figure 3.36</em>:</p><div><img src="img/B05118_03_36.png.jpg" alt="Enemies"/><div><p>Figure 3.36: Selecting a sprite for the Sprite Renderer component</p></div></div><p>After changing the sprite to an enemy character, you may need to adjust the rotation values to align the sprite to the parent forward vector, ensuring that the sprite is looking in the same direction as the forward vector. See <em>Figure 3.37</em>:</p><div><img src="img/B05118_03_37.png.jpg" alt="Enemies"/><div><p>Figure 3.37: Adjusting enemy sprite rotation</p></div></div><p>Now, select the parent object for the enemy and remove the <strong>Rigidbody</strong>, <strong>PlayerController</strong>, and <code class="literal">BoundsLock</code> components, but keep the <strong>Health</strong> component as the enemy should support health. See <em>Figure 3.38</em>. In addition, feel free to resize the <strong>Capsule Collider</strong> <a id="id220" class="indexterm"/>component to better approximate the <code class="literal">Enemy</code> object.</p><div><img src="img/B05118_03_38.png.jpg" alt="Enemies"/><div><p>Figure 3.38: Adjusting enemy sprite rotation</p></div></div><p>Let's start coding the enemy, focusing on movement. Specifically, the enemy should continually move in the forward direction at a specified speed. To achieve this, create a new script file named <code class="literal">Mover.cs</code>. This should be attached to the <code class="literal">Enemy</code> object. The code for this class is included in <em>Code Sample 3.6</em>.</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Mover : MonoBehaviour
{
  //------------------------------
  private Transform ThisTransform = null;
  public float MaxSpeed = 10f;
  //------------------------------
  // Use this for initialization
  void Awake () 
  {
    ThisTransform = GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void Update () 
  {
    ThisTransform.position += ThisTransform.forward * MaxSpeed * Time.deltaTime;
  }
  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec15"/>Code Sample 3.6</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id221" class="indexterm"/><code class="literal">Mover</code> script moves an object at a specified speed (<code class="literal">MaxSpeed</code> per second) along its forward vector. To do this, it uses the <strong>Transform</strong> component.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function is responsible for updating the position of the object. In short, it multiplies the forward vector by the object speed and adds this to its existing position to move the object further along its line of sight. The <code class="literal">Time.deltaTime</code> value is used to make the motion frame rate independent—moving the object per second as opposed to per frame. More information on <a id="id222" class="indexterm"/><code class="literal">deltaTime</code> can be found in the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Time-deltaTime.html">http://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</li></ul></div><p>Press play on the toolbar to test run your code. It's always good practice to frequently test code like this. Your enemy may move too slow or too fast. If so, stop playback to exit game mode, and select the enemy in the scene. From the <strong>Object Inspector</strong>, adjust the <strong>Max Speed</strong> value of the <strong>Mover</strong> component. See <em>Figure 3.39</em>:</p><div><img src="img/B05118_03_39.png.jpg" alt="Code Sample 3.6"/><div><p>Figure 3.39: Adjusting enemy speed</p></div></div><p>In addition to moving in a straight line, the enemy should also continually turn to face the player wherever they move. To achieve this, we'll need another script file that works similarly to the player controller script. While the player turns to face the cursor, the enemy turns to face the player. This functionality should be encoded in a new script file called <a id="id223" class="indexterm"/>
<code class="literal">ObjFace.cs</code>. This script should be attached to the enemy. See <em>Code Sample 3.7</em>:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class ObjFace : MonoBehaviour
{
  //------------------------------
  public Transform ObjToFollow = null;
  public bool FollowPlayer = false;
  private Transform ThisTransform = null;
  //------------------------------
  // Use this for initialization
  void Awake () 
  {
    //Get local transform
    ThisTransform = GetComponent&lt;Transform&gt;();

    //Should face player?
    if(!FollowPlayer)return;

    //Get player transform
    GameObject PlayerObj = GameObject.<strong>FindGameObjectWithTag</strong>("Player");
    if(PlayerObj != null)
      ObjToFollow = PlayerObj.GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Update is called once per frame
  void Update ()
  {
    //Follow destination object
    if(ObjToFollow==null)return;

    //Get direction to follow object
    Vector3 DirToObject = ObjToFollow.position - ThisTransform.position;

    if(DirToObject != Vector3.zero)
      ThisTransform.localRotation = <strong>Quaternion.LookRotation</strong>(DirToObject.normalized,Vector3.up);
  }
  //------------------------------
}
//------------------------------</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Code Sample 3.7</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id224" class="indexterm"/><code class="literal">ObjFace</code> script will always rotate an object so that its forward vector points towards a destination point in the scene.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">Awake</code> event, the <code class="literal">FindGameObjectWithTag</code> function is called to retrieve a reference to the one and only object in the scene tagged as a player, which should be the player spaceship. The player represents the default look-at destination for an enemy object.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Update</code> function is called automatically once per frame and will generate a displacement vector from the object location to the destination location, and this represents the direction in which the object should be looking. The <code class="literal">Quaternion.LookRotation</code> function accepts a direction vector and will rotate an object to align the forward vector with the supplied direction. This keeps the object looking towards the destination. More information on <a id="id225" class="indexterm"/><code class="literal">LookRotation</code> can be found at the online Unity documentation at <a class="ulink" href="http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html">http://docs.unity3d.com/ScriptReference/Quaternion.LookRotation.html</a>.</li></ul></div><p>This is looking excellent! However, before testing this code, make sure that the <code class="literal">Player</code> object in the scene is tagged as <strong>Player</strong>, is enabled, and the enemy is offset away from the player. Be sure to enable the <strong>Follow Player</strong> checkbox from the <strong>Obj Face</strong> component in the <strong>Object Inspector</strong>. When you do this, the enemy will always turn to face the player. See <em>Figure 3.40</em>:</p><div><img src="img/B05118_03_40.png.jpg" alt="Code Sample 3.7"/><div><p>Figure 3.40: Enemy spaceship moving towards the player</p></div></div><p>Now, if and when the enemy finally collides with the player, it should deal out damage and <a id="id226" class="indexterm"/>potentially kill the player. To achieve this, a collision between the enemy and player must be detected. Let's start by configuring the enemy. Select the <strong>Enemy</strong> object, and from the <strong>Object Inspector</strong>, enable the <strong>Is Trigger</strong> checkbox in the <strong>Capsule Collider</strong> component. This changes the <strong>Capsule Collider</strong> component to allow a true intersection between the player and enemy and prevent Unity from blocking the collision. See <em>Figure 3.41</em>:</p><div><img src="img/B05118_03_41.png.jpg" alt="Code Sample 3.7"/><div><p>Figure 3.41: Changing the Enemy Collider to a trigger</p></div></div><p>Next, we'll create a script that detects collisions and will continually deal out damage to the player as and when they occur and for as long as the collision state remains. Refer to the following <a id="id227" class="indexterm"/>code (<code class="literal">ProxyDamage.cs</code>), which should be attached to the enemy character:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class ProxyDamage : MonoBehaviour
{
  //------------------------------
  //Damage per second
  public float DamageRate = 10f;
  //------------------------------
  void OnTriggerStay(Collider Col)
  {
    Health H = Col.gameObject.GetComponent&lt;Health&gt;();

    if(H == null)return;

    H.HealthPoints -= DamageRate * Time.deltaTime;
  }
  //------------------------------
}
//------------------------------</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Code Sample 3.8</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id228" class="indexterm"/><code class="literal">ProxyDamage</code> script should be attached to an enemy character and it will deal out damage to any colliding object with a <code class="literal">Health</code> component.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnTriggerStay</code> event is called once every frame for as long as an intersection state persists. During this function, the <code class="literal">HealthPoints</code> value of the <code class="literal">Health</code> component is reduced by the <code class="literal">DamageRate</code> (which is measured as damage per second).</li></ul></div><p>After attaching the <code class="literal">ProxyDamage</code> script to an enemy, use the <strong>Object Inspector</strong> to set the <strong>Damage Rate</strong> of the <strong>Proxy Damage</strong> component. This represents how much health should be reduced on the player, per second, during a collision. For a challenge, I've set the value to <code class="literal">100</code> health points. See <em>Figure 3.42</em>:</p><div><img src="img/B05118_03_42.png.jpg" alt="Code Sample 3.8"/><div><p>Figure 3.42: Setting the Damage Rate for a Proxy Damage component</p></div></div><p>Now let's give things a test run. Press play on the toolbar and attempt a collision between the player <a id="id229" class="indexterm"/>and enemy. After one second, the player should be destroyed. Things are coming along well. However, we'll need more than one enemy to make things challenging.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Enemy spawning</h1></div></div></div><p>To make the level fun and <a id="id230" class="indexterm"/>challenging, we'll need more than simply one enemy. In fact, for a game that's essentially endless, we'll need to continually add enemies. These should be added gradually over time. Essentially, we'll need either regular or intermittent spawning of enemies, and this section will add that functionality. Before we can do this, however, we'll need to make a prefab from the enemy object. This can be achieved easily. Select the enemy in the <strong>Hierarchy</strong> panel and then drag and drop it to the <strong>Project</strong> panel in the <code class="literal">Prefabs</code> folder. This creates an <code class="literal">Enemy</code> prefab. See <em>Figure 3.43</em>:</p><div><img src="img/B05118_03_43.png.jpg" alt="Enemy spawning"/><div><p>Figure 3.43: Creating an Enemy prefab</p></div></div><p>Now, we'll make a new script (<code class="literal">Spawner.cs</code>) that spawns new enemies in the scene over time within a specified radius from the player spaceship. This script should be attached to a new, empty game <a id="id231" class="indexterm"/>object in the scene. See <em>Code Sample 3.9</em>:</p><div><pre class="programlisting">//------------------------------
using UnityEngine;
using System.Collections;
//------------------------------
public class Spawner : MonoBehaviour
{
  public float MaxRadius = 1f;
  public float Interval = 5f;
  public GameObject ObjToSpawn = null;
  private Transform Origin = null;
  //------------------------------
  void Awake()
  {
  Origin = GameObject.FindGameObjectWithTag("Player").GetComponent&lt;Transform&gt;();
  }
  //------------------------------
  // Use this for initialization
  void Start () 
  {
    <strong>InvokeRepeating("Spawn", 0f, Interval);</strong>
  }
  //------------------------------
  void Spawn () 
  {
    if(Origin == null)return;

    Vector3 SpawnPos = Origin.position + <strong>Random.onUnitSphere *</strong> MaxRadius;
    SpawnPos = new Vector3(SpawnPos.x, 0f, SpawnPos.z);
    Instantiate(ObjToSpawn, SpawnPos, Quaternion.identity);
  }
  //------------------------------
}
//------------------------------</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Code Sample 3.9</h2></div></div></div><p>The following points summarize the code sample:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id232" class="indexterm"/><code class="literal">Spawner</code> class will spawn instances of <code class="literal">ObjToSpawn</code> (a prefab) on each interval of <code class="literal">Interval</code>. The interval is measured in seconds. The spawned objects will be created within a random radius from a center point, <code class="literal">Origin</code>.</li><li class="listitem" style="list-style-type: disc">During the <code class="literal">Start</code> event, the <code class="literal">InvokeRepeating</code> function is called to continually execute the <code class="literal">Spawn</code> function on every interval to spawn a new enemy.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Spawn</code> function will create instances of the enemy in the scene at a random radius from an origin point. Once spawned, the enemy will behave as normal, heading toward the player for an attack.</li></ul></div><p>The <code class="literal">Spawner</code> class is a global behavior that applies scene-wide. It does not depend on the player specifically, nor on any specific enemy. For this reason, it should be attached to an empty game object. Create one of these by selecting <strong>GameObject</strong> | <strong>Create Empty</strong> from the application menu. Name this <code class="literal">Spawner</code> and attach the <code class="literal">Spawner</code> script to it. See <em>Figure 3.44</em>:</p><div><img src="img/B05118_03_44.png.jpg" alt="Code Sample 3.9"/><div><p>Figure 3.44: Creating an empty game object</p></div></div><p>Once added to the scene, from the <strong>Object Inspector</strong>, drag and drop the <code class="literal">Enemy</code> prefab to the <strong>Obj To Spawn</strong> field in the <strong>Spawner</strong> component. Set the <strong>Interval</strong> to <code class="literal">2</code> seconds and increase the <strong>Max Radius</strong> to <code class="literal">5</code>. See <em>Figure 3.45</em>:</p><div><img src="img/B05118_03_45.png.jpg" alt="Code Sample 3.9"/><div><p>Figure 3.45: Configuring the Spawner for Enemy objects</p></div></div><p>Now (drum roll), let's try the level. Press play on the toolbar and take the game for a test run. You <a id="id233" class="indexterm"/>should now have a level with a fully controllable player character surrounded by a growing army of tracking enemy ships! Excellent work! See <em>Figure 3.46</em>:</p><div><img src="img/B05118_03_46.png.jpg" alt="Code Sample 3.9"/><div><p>Figure 3.46: Spawned enemy objects moving toward the player</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Summary</h1></div></div></div><p>Good job on getting this far! The space shooter is really taking shape now, featuring a controllable player character that relies on native physics, twin-stick mechanics, enemy ships, and a scene-wide spawner for enemies. All these ingredients together still don't make a game: we can't shoot, we can't increase the score, and we can't destroy enemies. These issues will need to be addressed, along with other technical issues that we'll certainly encounter. Nevertheless, we now have a solid foundation for moving further, and in <a id="id234" class="indexterm"/>the next chapter, we'll complete the shooter.</p></div></body></html>