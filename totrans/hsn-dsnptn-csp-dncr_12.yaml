- en: Functional Programming Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter ([Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml),
    *Concurrent Programming in .NET Core*) introduced concurrent programming in .NET
    Core, and the aim of the chapter was to take advantage of `async`/`await` and
    parallelism, to make our program more performant.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get a taste of functional programming, using the C#
    language. We will also dive deeper into the concepts that show you how to leverage
    C# in .NET Core to perform functional programming. The aim of this chapter is
    to help you understand what functional programming is and how we can use it using
    the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming was inspired by mathematics, and it solves problems in
    a functional way. In mathematics, we have formulas and, in functional programming,
    we use math in the form of various functions. The best part of functional programming
    is that it helps to implement concurrency seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inventory application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategy patterns and functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains various code examples to explain the concepts of functional
    programming. The code is kept simple and is just for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter9).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run and execute the code, the prerequisites are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 (a Visual Studio 2017 update 3 or later can also be used
    to run the application).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL server (the Express Edition is used in this chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Visual Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run these code examples, you need to install Visual Studio 2017 (or a later
    version such as 2019). To do so, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Visual Studio from the following download link, which includes installation
    instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple versions are available for the Visual Studio installation. Here, we
    are using Visual Studio for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Download .NET Core for Windows at [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you do not have SQL Server installed, you need to follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For troubleshooting and more information, refer to the following link: [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple terms, **functional programming** is an approach to symbolic computation
    that is done in the same way as solving mathematical problems. Any functional
    programming is based on mathematical functions and its coding style. Any language
    that supports functional programming works for solutions for the following two
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What does it need to solve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does it solve it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional programming is not a new invention. This language has existed in
    the industry for a long time. The following are some well-known programming languages
    that support functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Haskell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erlang
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clojure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lisp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCaml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2005, Microsoft released the first version of F# (pronounced *EffSharp—*[https://fsharp.org/](https://fsharp.org/)).
    This is a functional programming language that has a lot of good features that
    any functional programming should have. In this chapter, we are not going to discuss
    much F#, but we will be discussing functional programming and its implementation
    using the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pure functions are the ones that strengthen functional programming by saying
    that they''re pure. These functions work on two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The end result/output will always remain the same for the provided parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They will not impact the behavior of the program or the execution path of the
    application, even when they are being called a hundred times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example from our FlixOne inventory application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have a `PriceCalc` class with two extension methods: `Discount`
    and `PriceAfterDiscount`. These functions could be called pure functions; both
    the `PriceCalc` function and the `PriceAfterDiscount` function are meeting the
    criteria to be `Pure` function; the `Discount` method will calculate the discount
    based on the current price and discount. In this case, the output of the method
    will never change for the supplied parameter values. In this way, the product
    with a price of `190.00` and a discount of `10.00` will be calculated in this
    way: `190.00 * 10.00 /100`, and this will return `19.00`. Our next method—`PriceAfterDiscount`—with
    the same parameter values will calculate `190.00 - 19.00` and return the value
    of `171.00`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One more important point in functional programming is that functions are pure
    and convey complete information (also called **functional honesty**). Consider
    the `Discount` method from the previous code; this is a pure function that is
    also honest. So, if someone accidentally supplies a negative discount or a discount
    that is more than its actual price (more than 100%), will this function remain
    pure and honest? To handle this scenario, our mathematics function should be written
    in such a way that if someone enters `discount <= 0 or discount > 100`, then the
    system will not entertain it. Consider the following code with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `Discount` function has a parameter type named `ValidDiscount`,
    which validates the input we have discussed. In this way, our function is now
    an honest function.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are as simple as functional programming, but working with functional
    programming still requires a lot of practice. In the upcoming sections, we will
    discuss advanced concepts of functional programming, including functional programming
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, where we are checking whether the discount value
    is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we have a field named `_validDiscount`. Let''s
    look at what this is doing: `Func` accepts `decimal` as an input and returns `bool`
    as an output. From its name, you can see that `field` stores only valid discounts.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Func` is a type of delegate that points to a method of one or more arguments
    and returns a value. The general declaration of `Func` is `Func<TParameter, TOutput>`,
    where `TParameter` is the input parameter of any valid datatype and `TOutput`
    is the return value of any valid datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet, where we are using the `_validDiscount`
    field in a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the `FilterOutInvalidDiscountRates` method. This
    method is self-explanatory and indicates that we are filtering out invalid discount
    rates. Let's analyze the code now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FilterOutInvalidDiscountRates` method returns a collection of `DiscountViewModel`
    class for the products that have a valid discount. The following code is of our
    `DiscountViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `DiscountViewModel` class contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductId`: This represents the ID of a product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductName`: This represents the name of a product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Price`: This contains the actual price of the product. The actual price is
    before any discount, taxes, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Discount`: This contains the percentage of a discount such as 10 or 3\. A
    valid discount rate should not be negative, equal to zero, or more than 100% (in
    other words, it should not be more than the actual cost of the product).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Amount`: This contains the product value after any discount, taxes, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's jump back to our `FilterOutInavlidDiscountRates` method and take
    a look at `viewModels.Select(x => x.Discount).Where(_vallidDiscount)`. Here, you
    might notice that we are selecting discount rates from our `viewModels` list.
    This list contains discount rates that are valid as per the `_validDiscount` field.
    In the next line, our method is returning records with valid discount rates.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, these functions are also known as **first-class functions**.
    These are the functions whose values can be used as an input or output for any
    other function. They can also be assigned to variables or stored in collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to Visual Studio and open the `FlixOne` inventory application. From here,
    run the application and you will see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a92e6211-c9db-44ae-8dde-6c0cff7213f5.png)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot is the Product Listing page that is showing all the
    available products. This is a simple page; you can also call it the Product Listing
    dashboard, where you'll find all the products. From Create New Product, you can
    add a new product, and Edit will give you the facility to update an existing product.
    In addition, the Details page will show the complete details of a specific product.
    By clicking Delete, you can remove the existing product from the listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to our `DiscountViewModel` class. We have the option to have multiple
    discount rates for a product with a business rule, which establishes that only
    one discount rate is active at a time. To view all the discount rates for a product,
    click on a discount rate from the preceding screen (Product Listing). This will
    show the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70619b88-ea6e-4cbd-814b-22c43ab44ae0.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screen is Product Discount Listing that shows the discount listing
    for the product name Mango. This has two discount rates, but only the Seasonal
    Discount rate is active. You might have noticed the remarks column; this is marked
    as an invalid discount rate because, as per `_validDiscount`—which is discussed
    in the previous section—this discount rate does not match the criteria for a valid
    discount rate.
  prefs: []
  type: TYPE_NORMAL
- en: '`Predicate` is also a delegate type, similar to `Func` delegates. This represents
    a method that validates the set of criteria. In other words, `Predicate` returns
    the type of `Predicate <T>`, where `T` is a valid datatype. It works if the criteria
    matches and returns a value of type `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, where we are validating the Product Name to be
    valid as sentence case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are using the `Predicate` keyword, and this analyzes
    the condition to validate `ProductName` using `TitleCase` keyword. If the criteria
    matches, the result will be `true`. If not, the result will be `false`. Consider
    the following code snippet, where we are using `_isProductNameTitleCase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the `FilterOutInvalidProductNames` method. The
    aim of this method is to pick the products with a valid product name (a `TitleCase`
    product name only).
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our inventory application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to enhance an inventory management application to manage its growing collection
    of products. This is not a new application, as we have already started the development
    of this application and discussed the initial stage in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns - Basics Part 1*, where we have started developing
    a console-based inventory system. From time to time, stakeholders will review
    the application and try to meet end users' requirements. The enhancement is important,
    as this application will be used by both staff (to manage the inventory) and by
    customers (to browse and create new orders). The application will need to be scalable,
    and is an essential system for the business.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a technical book, we will mostly discuss the various technical observations
    from the development team's perspective and discuss the patterns and practices
    used to implement the inventory management application.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a need to enhance the application, and this cannot be achieved in one
    day. This will require a lot of meetings and discussions. Over the course of several
    meetings, the business and the development teams discussed the requirements of
    the new enhancements to the inventory management system. Progress toward defining
    a clear set of requirements was slow, and the vision of the final product was
    not clear. The development team decided to pare down the enormous list of requirements
    to just enough functionality so that a key individual could start to record some
    inventory information. This would allow for simple inventory management and provide
    a basis that the business could extend upon. We will work on the requirement and
    take a **Minimal Viable Product** (**MVP**) approach.
  prefs: []
  type: TYPE_NORMAL
- en: MVP is the smallest set of features of an application that can still be released
    and have enough value for a user base.
  prefs: []
  type: TYPE_NORMAL
- en: 'After several meetings and discussions between management and business analysts,
    a list of requirements was produced to enhance our `FlixOne` web application.
    The high-level requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of pagination**: Currently, all page listings are not paginated.
    It is really challenging to view items with large page counts by scrolling down
    or scrolling up the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discount Rates**: Currently, there is no provision to add or see the various
    discount rates for a product. The business rules for discount rates are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product can have more than one discount rate.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A product can only have one active discount rate.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A valid discount rate should not be a negative value and should not be more
    than 100%.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Back to FlixOne
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed what is required in order to enhance
    an application. In this section, we will implement these requirements. Let''s
    first revisit the file structure of our project. Take a look at the following
    snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb23aa69-1daf-4775-b51f-5afe3c7d9bc9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous snapshot is depicting our FlixOne web application, having a folder
    structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wwwroot**: This is the folder that comes with static contents, such as CSS
    and jQuery files, which are required for the UI project. This folder comes with
    the default template provided by Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common**: This contains all the common files and operations related to business
    rules and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contexts**: This contains `InventoryContext`, which is a `DBContext` class
    that provides `Entity Framework Core` capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers**: This contains all the controller classes of our `FlixOne`
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migration**: This contains the `InventoryModel` snapshot and initially created
    entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Models:** This contains data models, `ViewModels`, that are required for
    our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence:** This contains the `InventoryRepository` and its operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views**: This contains all the views/screens of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code contains an `IHelper` interface that is holding two methods.
    We will implement this interface in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Helper` class implements the `IHelper` interface. In this class, we have
    two main, and important, methods: one is to check for a valid discount and the
    other is to check for a valid `ProductName` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we use this functionality in our application, we should add this to
    our `Startup.cs` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have a written statement, `services.AddTransient<IHelper,
    Helper>();`. With this, we are adding a transient service to our application.
    We have already discussed the *Inversion of control* section in [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml),
    *Implementing Design Patterns - .Net Core*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code, where we are using the `IHelper` class by taking
    leverage of Inversion of control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code contains the `InventoryRepository` class, where we can see
    the use of a proper **Dependency Injection** (**DI**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the `GetDiscountBy` method of the `InventoryRepository`
    class that is a returning collection of the discount model for the `active` or
    `de-active` records. Consider the following code snippet that is used for the
    `DiscountViewModel` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code that uses a collection of `DiscountViewModel` is filtering
    out the products that do not have a valid discount as per the business rule we
    discussed previously. The `GetValidDiscountProducts` method returns the collection
    of `DiscountViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we forget to define `IHelper` in our project `startup.cs` file, we will
    meet an exception, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18dae3fc-bf2b-4296-be43-c0447ffc8d47.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot is clearly saying that the `IHelper` service is not
    resolved. In our case, we will not face this exception, as we have already added
    `IHelper` to the `Startup` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, we have added helper methods to fulfill our new requirement for
    discount rates and to validate them. Now, let''s add a controller and subsequent
    action methods. To do so, add a new `DiscountController` controller from Solution
    Explorer. After this, our `FlixOne` web solution will look similar to the following
    snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c9cb2fd-c823-4cd2-bcac-143a3fd6ff2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding snapshot, we can see that our `Controller` folder now has
    one additional controller, which is `DiscountController`. The following code is
    from `DiscountController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application and, from the main screen, click on Products and then
    click on Product Discount Listing. From here, you will get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b228c14a-47b4-427b-9f13-b4bff9507521.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding snapshot is depicting Product Discount Listing for all the available
    products. The Product Discount Listing has a lot of records; therefore, it requires
    scrolling up or scrolling down to view items on the screen. To handle this difficult
    situation, we should implement paging.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy pattern and functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the first four chapters of this book, we discussed patterns and practices
    a lot. The strategy pattern is one of the important patterns of **Gang of Four**
    (**GoF**) patterns. This falls under the behavioral patterns category and is also
    known as a policy pattern. This is a pattern that is usually implemented with
    the help of classes. This is also an easier one to implement using functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Jump back to the *Understanding functional programming* section of this chapter
    and reconsider the paradigm of functional programming. Higher-order functions
    are one of the important paradigms of functional programming; using this, we can
    easily implement a strategy pattern in a functional way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Higher-order functions** (**HOFs**) are the functions that take parameters
    as functions. They can also return functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code that shows the implementation of HOFs in functional
    programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a simple implementation of the `Where` clause, in which
    we used `LINQ Query`. In this, we are iterating a collection and returning an
    item if it meets the criteria. The preceding code can be further simplified. Consider
    the following code for a more simplified version of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `SimplifiedWhere` method produces the same result as the
    previously discussed `Where` method. This method is criteria-based and has a strategy
    to return results, and this criterion executes at runtime. We can easily call
    the preceding function in a subsequent method to take advantage of functional
    programming. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We have a method called `GetProductsAbovePrice`. In this method, we are providing
    the price. This method is self-explanatory, and it works on a collection of `ProductViewModel`
    with a criteria to list the products that have a product price that is more than
    the parameter price. In our `FlixOne` inventory application, you can find further
    scope to implement functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming is all about functions and, predominantly, mathematical
    functions. Any language that supports functional programming always works on the
    solution with two main questions: what needs to be solved and how can this be
    solved? We saw functional programming and its easy implementation using the C#
    programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about `Func`, `Predicate`, LINQ, `Lambda`, anonymous functions,
    closures, expression trees, currying, closures, and recursion. Finally, we looked
    into the implementation of the strategy pattern using functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter ([Chapter 10](84b551c9-fcee-4017-bea5-31c803184e9f.xhtml),
    *Reactive Programming Patterns and Techniques*), we will discuss reactive programming
    as well as its model and principles. We will also discuss **reactive extensions**.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is referential transparency in functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a pure function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
