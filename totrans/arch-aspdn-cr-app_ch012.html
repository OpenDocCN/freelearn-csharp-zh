<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>11 Structural Patterns</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="12">11 Structural Patterns</h1>

<h2 data-number="12.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file47.png" style="width:10em"/></p>
<p>This chapter explores four design patterns from the well-known Gang of Four (GoF). We use Structural patterns to build and organize complex object hierarchies in a maintainable fashion. They allow us to dynamically add behaviors to existing classes, whether we designed the initial system this way or as an afterthought that emerges out of necessity later in the program’s lifecycle. Structural patterns promote reusability and enhance the overall flexibility of the system.In this chapter, we cover the following topics:</p>
<ul>
<li>Implementing the Decorator design pattern</li>
<li>Implementing the Composite design pattern</li>
<li>Implementing the Adapter design pattern</li>
<li>Implementing the Façade design pattern</li>
</ul>
<p>The first two patterns help us extend a class dynamically and efficiently manage a complex object structure. The last two help us adapt an interface to another or shield a complex system with a simple interface.Let's dive into unlocking the power of structural patterns!</p>


<h2 data-number="12.2">Implementing the Decorator design pattern</h2>
<p>The Decorator Pattern allows us to dynamically add new functionality to an object by wrapping it with one or more decorator objects. This pattern follows the Open-Closed principle, allowing us to add additional behaviors to an object at runtime without modifying its original code. This pattern enables us to separate responsibilities into multiple smaller pieces. It is a simple but powerful pattern. In this section, we explore how to implement this pattern in the traditional way and how to leverage an open-source tool named <strong>Scrutor</strong> to help us create powerful dependency injection-ready decorators.</p>

<h3 data-number="12.2.1">Goal</h3>
<p>The decorator aims to extend an existing object at runtime without changing its code. Moreover, the decorated object should remain unaware of the decoration process, making this approach an excellent fit for complex or long-lasting systems that necessitate evolution. This pattern fits systems of all sizes.</p>
<blockquote>
<p>I often use this pattern to add flexibility and create adaptability to a program for next to no cost. In addition, small classes are easier to test, so the Decorator pattern adds ease of testability into the mix, making it worth mastering.</p>
</blockquote>
<p>The Decorator pattern makes it easier to encapsulate responsibilities into multiple classes, instead of packing multiple responsibilities inside a single class. Having multiple classes with a single responsibility makes the system easier to manage.</p>


<h3 data-number="12.2.2">Design</h3>
<p>A <strong>decorator</strong> class must implement and use the interface the <strong>decorated</strong> class implements. Let’s see this step by step, starting with a non-decorated class design:</p>
<figure>
<img alt="Figure 11.1: A class diagram representing the ComponentA class implementing the IComponent interface" src="img/file48.png"/><figcaption aria-hidden="true">Figure 11.1: A class diagram representing the ComponentA class implementing the IComponent interface</figcaption>
</figure>
<p>In the preceding diagram, we have the following components:</p>
<ul>
<li>A client that calls the <code>Operation()</code> method of the <code>IComponent</code> interface.</li>
<li><code>ComponentA</code>, which implements the <code>IComponent</code> interface.</li>
</ul>
<p>This translates into the following sequence diagram:</p>
<figure>
<img alt="Figure 11.2: A sequence diagram showing a consumer calling the Operation method of the ComponentA class" src="img/file49.png"/><figcaption aria-hidden="true">Figure 11.2: A sequence diagram showing a consumer calling the Operation method of the ComponentA class</figcaption>
</figure>
<p>Now, say that we want to add a behavior to <code>ComponentA</code>, but only in some cases. In other cases, we want to keep the initial behavior. To do so, we could choose the Decorator pattern and implement it as follows:</p>
<figure>
<img alt="Figure 11.3: Decorator class diagram" src="img/file50.png"/><figcaption aria-hidden="true">Figure 11.3: Decorator class diagram</figcaption>
</figure>
<p>Instead of modifying the <code>ComponentA</code> class, we created <code>DecoratorA</code>, which also implements the <code>IComponent</code> interface. This way, the <code>Client</code> object can use an instance of <code>DecoratorA</code> instead of <code>ComponentA</code> and leverage the new behavior without impacting the other consumers of <code>ComponentA</code>. Then, to avoid rewriting the whole component, an implementation of the <code>IComponent</code> interface (say <code>ComponentA</code>) is injected when creating a new <code>DecoratorA</code> instance (constructor injection). This new instance is stored in the <code>component</code> field and used by the <code>Operation()</code> method (implicitly using the <strong>Strategy</strong> pattern).We can translate the updated sequence like so:</p>
<figure>
<img alt="Figure 11.4: Decorator sequence diagram" src="img/file51.png"/><figcaption aria-hidden="true">Figure 11.4: Decorator sequence diagram</figcaption>
</figure>
<p>In the preceding diagram, instead of calling <code>ComponentA</code> directly, <code>Client</code> calls <code>DecoratorA</code>, which in turn calls <code>ComponentA</code>. Finally, <code>DecoratorA</code> does some postprocessing by calling its private method, <code>AddBehaviorA()</code>.</p>
<blockquote>
<p>Nothing from the Decorator pattern limits us from doing preprocessing, postprocessing, wrapping the decorated class’s call (the <code>Operation</code> method in this example) with some logic (like an <code>if</code> statement or a <code>try</code>-<code>catch</code>), or all of that combined. The use of adding a postprocessing behavior is only an example.</p>
</blockquote>
<p>To show you how powerful the Decorator pattern is before we jump into the code, know this: we can chain decorators! Since our decorator depends on the interface (not the implementation), we could inject another decorator, let’s call it <code>DecoratorB</code>, inside <code>DecoratorA</code> (or vice versa). We could then create a long chain of rules that decorate one another, leading to a very powerful yet simple design.Let’s take a look at the following class diagram, which represents our chaining example:</p>
<figure>
<img alt="Figure 11.5: Decorator class diagram, including two decorators" src="img/file52.png"/><figcaption aria-hidden="true">Figure 11.5: Decorator class diagram, including two decorators</figcaption>
</figure>
<p>Here, we created the <code>DecoratorB</code> class, which looks very similar to <code>DecoratorA</code> but has a private <code>AddBehaviorB()</code> method instead of <code>AddBehaviorA()</code>.</p>
<blockquote>
<p>How we implement the decorator logic is irrelevant to the pattern, so I excluded the <code>AddBehaviorA()</code> method from <em>Figure 9.3</em> to show you only the pattern. However, I added it to <em>Figure 9.5</em> to clarify the idea behind having a second decorator.</p>
</blockquote>
<p>Let’s take a look at the sequence diagram for this:</p>
<figure>
<img alt="Figure 11.6: Sequence diagram of two nested decorators" src="img/file53.png"/><figcaption aria-hidden="true">Figure 11.6: Sequence diagram of two nested decorators</figcaption>
</figure>
<p>With this, we are beginning to see the power of decorators. In the preceding diagram, we can assess that the behaviors of <code>ComponentA</code> have been changed twice without <code>Client</code> knowing about it. All those classes are unaware of the next <code>IComponent</code> in the chain. They don’t even know that they are being decorated. They only play their role in the plan—that’s all.It is also important to note that the decorator’s power resides in its dependency on the interface, not on an implementation, making it reusable. Based on that fact, we could swap <code>DecoratorA</code> and <code>DecoratorB</code> to invert the order the new behaviors are applied without touching the code itself. We could also apply the same decorator (say <code>DecoratorC</code>) to multiple <code>IComponent</code> implementations, like decorating both <code>DecoratorA</code> and <code>DecoratorB</code>. A decorator could even decorate itself.Let’s now dig into some code.</p>


<h3 data-number="12.2.3">Project – Adding behaviors</h3>
<p>Let's implement the previous example to help visualize the Decorator pattern, which adds some arbitrary behaviors. Each <code>Operation()</code> method returns a string that is then outputted to the response stream. It is not fancy but visually shows how the pattern works.First, let’s look at the <code>IComponent</code> interface:</p>
<div><pre><code>public interface IComponent
{
    string Operation();
}</code></pre>
</div>
<p>The <code>IComponent</code> interface only states that an implementation should have an <code>Operation()</code> method that returns a <code>string</code>.Next, let’s look at the <code>ComponentA</code> class:</p>
<div><pre><code>public class ComponentA : IComponent
{
    public string Operation()
    {
        return "Hello from ComponentA";
    }
}</code></pre>
</div>
<p>The <code>Operation()</code> method of the <code>ComponentA</code> class returns a literal string.Now that we described the first pieces, let’s look at the consumer:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;IComponent, ComponentA&gt;();
var app = builder.Build();
app.MapGet("/", (IComponent component) =&gt; component.Operation());
app.Run();</code></pre>
</div>
<p>In the <code>Program.cs</code> file above, we register <code>ComponentA</code> as the implementation of <code>IComponent</code>, with a singleton lifetime. We then inject an <code>IComponent</code> implementation when an HTTP request hits the <code>/</code> endpoint. The delegate then calls the <code>Operation()</code> method and outputs the result to the response.At this point, running the application results in the following response:</p>
<div><pre><code>Hello from ComponentA</code></pre>
</div>
<p>So far, it's pretty simple; the client calls the endpoint, the container injects an instance of the <code>ComponentA</code> class into the endpoint delegate, then the endpoint returns the results of <code>Operation</code> method to the client.Next, we add the first decorator.</p>

<h4 data-number="12.2.3.1">DecoratorA</h4>
<p>Here, we want to modify the response without touching the code of the <code>ComponentA</code> class. To do so, we chose to create a decorator named <code>DecoratorA</code> that wraps the <code>Operation()</code> result into a <code>&lt;DecoratorA&gt;</code> tag:</p>
<div><pre><code>public class DecoratorA : IComponent
{
    private readonly IComponent _component;
    public DecoratorA(IComponent component)
    {
        _component = component ?? throw new ArgumentNullException(nameof(component));
    }
    public string Operation()
    {
        var result = _component.Operation();
        return $"&lt;DecoratorA&gt;{result}&lt;/DecoratorA&gt;";
    }
}</code></pre>
</div>
<p><code>DecoratorA</code> implements and depends on the <code>IComponent</code> interface. It uses the injected <code>IComponent</code> implementation in its <code>Operation()</code> method and wraps its result in an HTML-like (XML) tag.Now that we have a decorator, we need to tell the IoC container to send an instance of <code>DecoratorA</code> instead of <code>ComponentA</code> when injecting an <code>IComponent</code> interface.<code>DecoratorA</code> should decorate <code>ComponentA</code>. More precisely, the container should inject an instance of the <code>ComponentA</code> class into the <code>DecoratorA</code> class.To achieve this, we could register it as follows:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IComponent&gt;(serviceProvider =&gt; new DecoratorA(new ComponentA()));</code></pre>
</div>
<p>Here, we are telling ASP.NET Core to inject an instance of <code>DecoratorA</code> that decorates an instance of <code>ComponentA</code> when injecting an <code>IComponent</code> interface. When we run the application, we should see the following result in the browser:</p>
<div><pre><code>&lt;DecoratorA&gt;Hello from ComponentA&lt;/DecoratorA&gt;</code></pre>
</div>
<blockquote>
<p>You may have noticed a few <code>new</code> keywords there, but even though it is not very elegant, we can manually create new instances in the composition root without jeopardizing our application’s health. We learn how to get rid of some of them later with the introduction of Scrutor.</p>
</blockquote>
<p>Next, let’s create the second decorator.</p>


<h4 data-number="12.2.3.2">DecoratorB</h4>
<p>Now that we have a decorator, it is time to create a second decorator to demonstrate the power of chaining decorators.<strong>Context</strong>: we need another content wrapper but don’t want to modify existing classes. To achieve this, we concluded that creating a second decorator would be perfect, so we created the following <code>DecoratorB</code> class:</p>
<div><pre><code>public class DecoratorB : IComponent
{
    private readonly IComponent _component;
    public DecoratorB(IComponent component)
    {
        _component = component ?? throw new ArgumentNullException(nameof(component));
    }
    public string Operation()
    {
        var result = _component.Operation();
        return $"&lt;DecoratorB&gt;{result}&lt;/DecoratorB&gt;";
    }
}</code></pre>
</div>
<p>The preceding code is similar to <code>DecoratorA</code>, but the XML tag is <code>DecoratorB</code> instead. The important part is that the decorator depends on and implements the <code>IComponent</code> interface and doesn’t depend on a concrete class. This is what gives us the flexibility of decorating any <code>IComponent</code>, and this is what enables us to chain decorators.To complete this example, we need to update our composition root like this:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IComponent&gt;(serviceProvider =&gt; new DecoratorB(new DecoratorA(new ComponentA())));</code></pre>
</div>
<p>Now, <code>DecoratorB</code> decorates <code>DecoratorA</code>, which decorates <code>ComponentA</code>. When running the application, you see the following output:</p>
<div><pre><code>&lt;DecoratorB&gt;&lt;DecoratorA&gt;Hello from ComponentA&lt;/DecoratorA&gt;&lt;/DecoratorB&gt;</code></pre>
</div>
<p>And voilà! These decorators allowed us to modify the behavior of <code>ComponentA</code> without impacting the code. However, our composition root is beginning to get messy as we instantiate multiple dependencies inside each other, making our application harder to maintain. Moreover, the code is becoming harder to read. Furthermore, the code would be even harder to read if the decorators were also depending on other classes.</p>
<blockquote>
<p>We can use decorators to change the behavior or state of an object. We can be very creative with decorators; for example, you could create a class that queries remote resources over HTTP and then decorate that class with a small component that manages a memory cache of the results, limiting the round trip to the remote server. You could create another decorator that monitors the time needed to query those resources and then log that to Application Insights—so many possibilities.</p>
</blockquote>
<p>Next, we eliminate the <code>new</code> keywords and clean up our composition root.</p>



<h3 data-number="12.2.4">Project – Decorator using Scrutor</h3>
<p>This update aims to simplify the composition of the system we just created. To achieve this, we use <strong>Scrutor</strong>, an open-source library that allows us to do just that, among other things.We first need to install the Scrutor NuGet package using Visual Studio or the CLI. When using the CLI, run the following command:</p>
<div><pre><code>dotnet add package Scrutor</code></pre>
</div>
<p>Once Scrutor is installed, we can use the <code>Decorate</code> extension method on the <code>IServiceCollection</code> to add decorators.By using Scrutor, we can update the following messy line:</p>
<div><pre><code>builder.Services.AddSingleton&lt;IComponent&gt;(serviceProvider =&gt; new DecoratorB(new DecoratorA(new ComponentA())))</code></pre>
</div>
<p>And convert it into these three more elegant lines:</p>
<div><pre><code>builder.Services
    .AddSingleton&lt;IComponent, ComponentA&gt;()
    .Decorate&lt;IComponent, DecoratorA&gt;()
    .Decorate&lt;IComponent, DecoratorB&gt;()
;</code></pre>
</div>
<p>In the preceding code, we registered <code>ComponentA</code> as the implementation of <code>IComponent</code>, with a singleton lifetime, just like the first time.Then, by using Scrutor, we told the IoC container to override that first binding and to decorate the already registered <code>IComponent</code> (<code>ComponentA</code>) with an instance of <code>DecoratorA</code> instead. Then, we overrode the second binding by telling the IoC container to return an instance of <code>DecoratorB</code> that decorates the last known binding of <code>IComponent</code> instead (<code>DecoratorA</code>).The result is the same as we did previously, but the code is now more elegant. On top of that improved readability, this lets the container create the instances instead of us using the <code>new</code> keyword, adding more flexibility and stability to our system.As a reminder, the IoC container serves the equivalent of the following <code>instance</code> when an <code>IComponent</code> interface is requested:</p>
<div><pre><code>var instance = new DecoratorB(new DecoratorA(new ComponentA()));</code></pre>
</div>
<p>Why am I talking about elegance and flexibility? This code is a simple example, but if we add other dependencies to those classes, it could quickly become a complex code block that could become a maintenance nightmare, very hard to read, and have manually managed lifetimes. Of course, if the system is simple, you can always instantiate the decorators manually without loading an external library.</p>
<blockquote>
<p>Whenever possible, keep your code simple. Using Scrutor is one way to achieve this. Code simplicity helps in the long run as it is easier to read and follow, even for someone else reading it. Consider that someone will most likely read your code one day.</p>
<blockquote>
<p>Moreover, adding any external dependency to a project should be considered carefully. Remember that you must keep the dependency up to date, so having too many can take maintenance time. The library's author can also stop maintaining it, and the library will become outdated. The library may introduce breaking changes forcing you to update your code. And so on.</p>
</blockquote>
<blockquote>
<p>Furthermore, there is the security aspect to consider. Supply chain attacks are not uncommon. If you work in a regulated place, you may have to go through a cybersecurity vetting process, etc.</p>
</blockquote>
<blockquote>
<p>Besides those general tips, I’ve been using Scrutor for many years; I find it very stable and don’t remember any breaking changes that caused me issues.</p>
</blockquote>
</blockquote>
<p>To ensure both programs behave the same, with or without Scrutor, let’s explore the following integration test that runs for both projects, ensuring their correctness:</p>
<div><pre><code>namespace Decorator.IntegrationTests;
//...
[Fact]
public async Task Should_return_a_double_decorated_string()
{
    // Arrange
    var client = _webApplicationFactory.CreateClient();
    // Act
    var response = await client.GetAsync("/");
    // Assert
    response.EnsureSuccessStatusCode();
    var body = await response.Content.ReadAsStringAsync();
    Assert.Equal(
        "Operation: &lt;DecoratorB&gt;&lt;DecoratorA&gt;Hello from ComponentA&lt;/DecoratorA&gt;&lt;/DecoratorB&gt;",
        body
    );
}</code></pre>
</div>
<p>The preceding test sends an HTTP request to one of the applications running in memory and compares the server response to the expected value. Since both projects should have the same output, we reuse this test in both the <code>DecoratorPlainStartupTest</code> and <code>DecoratorScrutorStartupTest</code> classes. They are empty and only routes the test to the correct program. Here’s an example of the Visual Studio Test Explorer:</p>
<figure>
<img alt="Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator integration tests." src="img/file54.png"/><figcaption aria-hidden="true">Figure 11.7: A Visual Studio Explorer screenshot displaying the Decorator integration tests.</figcaption>
</figure>
<blockquote>
<p>You can also do assembly scanning using Scrutor (<a href="https://adpg.link/xvfS">https://adpg.link/xvfS</a>), which allows you to perform automatic dependency registration. This is outside the scope of this chapter, but it is worth looking into. Scrutor allows you to use the built-in IoC container for more complex scenarios, postponing the need to replace it with a third-party one.</p>
</blockquote>


<h3 data-number="12.2.5">Conclusion</h3>
<p>The Decorator pattern is one of our toolbox's simplest yet most powerful design patterns. It augments existing classes without modifying them. A decorator is an independent block of logic that we can use to create complex and granular object trees that fit our needs.We also explored the Scrutor open-source library to assist us in registering our decorator with the container.The Decorator pattern helps us stay in line with the <strong>SOLID</strong> principles (and vice versa), as follows:</p>
<ul>
<li><strong>S</strong>: The Decorator pattern suggests creating small classes to add behaviors to other classes, segregating responsibilities, and fostering reuse.</li>
<li><strong>O</strong>: Decorators add behaviors to other classes without modifying them, which is literally the definition of the OCP.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: By following the ISP, creating decorators for your specific needs should be easy. However, implementing the Decorator pattern may become difficult if your interfaces are too complex. Having a hard time creating a decorator is a good indicator that something is wrong with the design—a code smell. A well-segregated interface should be easy to decorate.</li>
<li><strong>D</strong>: Depending on abstractions is the key to the Decorator’s power.</li>
</ul>
<p>Next, we explore the Composite pattern, which helps us manage complex objects’ structures differently than the decorator does.</p>



<h2 data-number="12.3">Implementing the Composite design pattern</h2>
<p>The Composite design pattern is another structural GoF pattern that helps us manage complex object structures.</p>

<h3 data-number="12.3.1">Goal</h3>
<p>The goal behind the Composite pattern is to create a hierarchical data structure where you don’t need to differentiate groups from single components, making the traversal and manipulation of the hierarchy easy for its consumers.</p>
<blockquote>
<p>You could think of the Composite pattern as a way of building a graph or a tree with self-managing nodes.</p>
</blockquote>


<h3 data-number="12.3.2">Design</h3>
<p>The design is straightforward; we have <em>components</em> and <em>composites</em>. Both implement a common interface that defines the shared operations. The <em>components</em> are single nodes, while the <em>composites</em> are collections of <em>components</em>. Let’s take a look at a diagram:</p>
<figure>
<img alt="Figure 11.7: Composite class diagram" src="img/file55.png"/><figcaption aria-hidden="true">Figure 11.7: Composite class diagram</figcaption>
</figure>
<p>In the preceding diagram, <code>Client</code> depends on an <code>IComponent</code> interface and is unaware of the underlying implementation—it could be an instance of a <code>Component</code> or a <code>Composite</code>; it does not matter. Then, we have two implementations:</p>
<ul>
<li><code>Component</code> represents a single element; a leaf.</li>
<li><code>Composite</code> represents a collection of <code>IComponent</code>. The <code>Composite</code> object uses its children to manage the hierarchy’s complexity by delegating part of the process to them.</li>
</ul>
<p>Those three pieces put together create the Composite design pattern. Considering that it is possible to add instances of the <code>Composite</code> and <code>Component</code> classes as children of other <code>Composite</code> objects, it is possible to create complex, non-linear, and self-managed data structures with next to no effort.</p>
<blockquote>
<p>You are not limited to one type of component and one type of composite; you can create as many implementations of the <code>IComponent</code> interface as you need. Then, you can even mix and match them to create a non-linear tree.</p>
</blockquote>


<h3 data-number="12.3.3">Project – BookStore</h3>
<p><strong>Context</strong>: We built a program in the past to support a bookstore. However, the store is going so well that our little program is not enough anymore. Our fictional company now owns multiple stores. They want to divide those stores into sections and manage book sets and single books. After a few minutes of gathering information and asking them questions, we realize they can have sets of sets, subsections, and think of creating sub-stores, so we need a flexible design.We have decided to use the Composite pattern to solve this problem. Here’s our class hierarchy:</p>
<figure>
<img alt="Figure 11.8: the BookStore project composite class hierarchy" src="img/file56.png"/><figcaption aria-hidden="true">Figure 11.8: the BookStore project composite class hierarchy</figcaption>
</figure>
<p>Due to the complexity of our class hierarchy and the uncertainty of a project in an early stage, we decided that a factory would be adequate to create our class hierarchy, showcase our design, and validate it with the customer. Here’s the high-level design:</p>
<figure>
<img alt="Figure 11.9: high-level design of the BookStore project" src="img/file57.png"/><figcaption aria-hidden="true">Figure 11.9: high-level design of the BookStore project</figcaption>
</figure>
<p>We decided to aim for the smallest possible interface to get the ball rolling. Since we want to know how many items are available in any part of the store and what type of component we are interacting with, we created the following interface:</p>
<div><pre><code>namespace Composite.Models;
public interface IComponent
{
    int Count { get; }
    string Type { get; }
}</code></pre>
</div>
<p>The <code>Count</code> property allows us to calculate how many items are available under the corporation, a store, a section, a set, or any other composite component we create in the future. The <code>Type</code> property forces each component to display its type linearly.</p>
<blockquote>
<p>We can create such a minimal interface because we are not executing any operations on the data structure but counting the elements, then serializing it to JSON. The serializer will take care of navigating the class hierarchy for us. In another context, the minimal subset of properties might be more than this. For example, in this case, we could have added a <code>Name</code> property to the interface, but the book's name is its title, so I decided not to include it.</p>
</blockquote>
<p>Next, let’s create our composite structure, starting with the <code>Book</code> class (the <em>Component</em>):</p>
<div><pre><code>namespace Composite.Models;
public class Book : IComponent
{
    public Book(string title)
    {
        Title = title ?? throw new ArgumentNullException(nameof(title));
    }
    public string Title { get; }
    public string Type =&gt; "Book";
    public int Count { get; } = 1;
}</code></pre>
</div>
<p>The preceding <code>Book</code> class implements the interface by always returning a count of 1 because it is a single book, a leaf in the tree. The <code>Type</code> property is also hard-coded. As a book, the class requires a title upon construction that it stores in the <code>Title</code> property (not inherited and only available to <code>Book</code> instances).</p>
<blockquote>
<p>In a real scenario, we’d have more properties, like the ISBN and author, but doing so here would just clutter the example. We are not designing a real bookstore but learning about the Composite pattern.</p>
</blockquote>
<p>Next, let’s create our composite component, the <code>BookComposite</code> class:</p>
<div><pre><code>using System.Collections;
using System.Collections.ObjectModel;
namespace Composite.Models;
public abstract class BookComposite : IComponent
{
    protected readonly List&lt;IComponent&gt; children = new();
    public BookComposite(string name)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
    }
    public string Name { get; }
    public virtual string Type =&gt; GetType().Name;
    public virtual int Count 
        =&gt; children.Sum(child =&gt; child.Count);
    public virtual IEnumerable Children 
        =&gt; new ReadOnlyCollection&lt;IComponent&gt;(children);
    public virtual void Add(IComponent bookComponent)
    {
        children.Add(bookComponent);
    }
    public virtual void Remove(IComponent bookComponent)
    {
        children.Remove(bookComponent);
    }
}</code></pre>
</div>
<p>The <code>BookComposite</code> class implements the following shared features:</p>
<ul>
<li>Children management (highlighted in the code).</li>
<li>Setting the <code>Name</code> property of the composite object and forcing the classes inheriting it to set a name upon construction.</li>
<li>Automatically finds and sets the <code>Type</code> name of its derived class.</li>
<li>Counting the number of children (and, implicitly, the children’s children).</li>
<li>Exposing the children through the <code>Children</code> property and ensuring consumers can’t modify the collection from the outside by returning a <code>ReadOnlyCollection</code> object.</li>
</ul>
<blockquote>
<p>Using the LINQ <code>Sum()</code> extension method in the <code>children.Sum(child =&gt;</code> <code>child.Count());</code> expression allowed us to replace a more complex <code>for</code> loop and an accumulator variable.</p>
<blockquote>
<p>Adding the <code>virtual</code> modifier to the <code>Type</code> property allows sub-types to override the property in case their type’s name does not reflect the type that should be displayed in the program.</p>
</blockquote>
</blockquote>
<p>Now, we can start implementing the other classes of our complex composite hierarchy and assign a responsibility to each class, showing how flexible the Composite pattern is.The following classes inherit from the <code>BookComposite</code> class:</p>
<ul>
<li>The <code>Corporation</code> class represents the corporation that owns multiple stores. However, it is not limited to owning stores; a corporation could own other corporations, stores, or any other <code>IComponent</code>.</li>
<li>The <code>Store</code> class represents a bookstore.</li>
<li>The <code>Section</code> class represents a section of a bookstore, an aisle, or a category of books.</li>
<li>The <code>Set</code> class represents a book set, such as a trilogy.</li>
</ul>
<p>These can be composed of any <code>IComponent</code>, making this an ultra-flexible data structure. Let’s look at the code for these <code>BookComposite</code> sub-types, starting with the <code>Corporation</code> class:</p>
<div><pre><code>namespace Composite.Models;
public class Corporation : BookComposite
{
    public Corporation(string name, string ceo)
        : base(name)
    {
        CEO = ceo;
    }
    public string CEO { get; }
}</code></pre>
</div>
<p>The corporation contributes a CEO to the model because someone has to manage the place.Next, we look at the <code>Store</code> class:</p>
<div><pre><code>namespace Composite.Models;
public class Store : BookComposite
{
    public string Location { get; }
    public string Manager { get; }
    public Store(string name, string location, string manager)
        : base(name)
    {
        Location = location;
        Manager = manager;
    }
}</code></pre>
</div>
<p>On top of the <code>BookComposite</code> members, a store has a manager and a location.Now, the <code>Section</code> class does not add anything, but we can use it as a flexible organizer:namespace Composite.Models;</p>
<div><pre><code>public class Section : BookComposite
{
    public Section(string name) : base(name) { }
}</code></pre>
</div>
<p>Finally, the <code>Set</code> class allows creating the book set upon construction through the books parameter:</p>
<div><pre><code>namespace Composite.Models;
public class Set : BookComposite
{
    public Set(string name, params IComponent[] books)
        : base(name)
    {
        foreach (var book in books)
        {
            Add(book);
        }
    }
}</code></pre>
</div>
<p>Composing a set of books upon creation of the instance will be convenient later when we assemble the tree.Next, let’s explore the last part of the program that helps encapsulate the data structure’s creation: the factory.</p>
<blockquote>
<p>The factory is not part of the Composite pattern, but now that we know what a factory is, we can use one to encapsulate the creation logic of our data structure and talk about it.</p>
</blockquote>
<p>The factory interface looks like the following:</p>
<div><pre><code>public interface ICorporationFactory
{
    Corporation Create();
}</code></pre>
</div>
<p>The default concrete implementation of the <code>ICorporationFactory</code> interface is the <code>DefaultCorporationFactory</code> class. It creates a large non-linear data structure with sections, subsections, sets, and subsets. This whole structure is defined using our composite model in the <code>DefaultCorporationFactory</code> class. Due to its large size, let’s start with the class’s skeleton and its <code>Create</code> method:</p>
<div><pre><code>using Composite.Models;
namespace Composite.Services;
public class DefaultCorporationFactory : ICorporationFactory
{
    public Corporation Create()
    {
        var corporation = new Corporation(
            "Boundless Shelves Corporation",
            "Bosmang Kapawu"
        );
        corporation.Add(CreateTaleTowersStore());
        corporation.Add(CreateEpicNexusStore());
        return corporation;
    }
    // ...
}</code></pre>
</div>
<p>In the preceding <code>Create</code> method, we create the corporation, add two stores, then return the result.The <code>CreateTaleTowersStore</code> and <code>CreateEpicNexusStore</code> methods create a store, set their name, address, and manager, and create three sections each:</p>
<div><pre><code>private IComponent CreateTaleTowersStore()
{
    var store = new Store(
        "Tale Towers",
        "125 Enchantment Street, Storyville, SV 72845",
        "Malcolm Reynolds"
    );
    store.Add(CreateFantasySection());
    store.Add(CreateAdventureSection());
    store.Add(CreateDramaSection());
    return store;
}
private IComponent CreateEpicNexusStore()
{
    var store = new Store(
        "Epic Nexus",
        "369 Parchment Plaza, Novelty, NV 68123",
        "Ellen Ripley"
    );
    store.Add(CreateFictionSection());
    store.Add(CreateFantasySection());
    store.Add(CreateAdventureSection());
    return store;
}</code></pre>
</div>
<p>Both stores share two sections (have the same books; highlighted code), each with a unique section. If we look at the <code>CreateFictionSection</code> method, it adds an imaginary book and a subsection:</p>
<div><pre><code>private IComponent CreateFictionSection()
{
    var section = new Section("Fiction");
    section.Add(new Book("Some alien cowboy"));
    section.Add(CreateScienceFictionSection());
    return section;
}</code></pre>
</div>
<p>The <code>CreateScienceFictionSection</code> method adds an invented book and the Star Wars book set composed of three trilogies (a set of sets):</p>
<div><pre><code>private IComponent CreateScienceFictionSection()
{
    var section = new Section("Science Fiction");
    section.Add(new Book("Some weird adventure in space"));
    section.Add(new Set(
        "Star Wars",
        new Set(
            "Prequel trilogy",
            new Book("Episode I: The Phantom Menace"),
            new Book("Episode II: Attack of the Clones"),
            new Book("Episode III: Revenge of the Sith")
        ),
        new Set(
            "Original trilogy",
            new Book("Episode IV: A New Hope"),
            new Book("Episode V: The Empire Strikes Back"),
            new Book("Episode VI: Return of the Jedi")
        ),
        new Set(
            "Sequel trilogy",
            new Book("Episode VII: The Force Awakens"),
            new Book("Episode VIII: The Last Jedi"),
            new Book("Episode IX: The Rise of Skywalker")
        )
    ));
    return section;
}</code></pre>
</div>
<p>Now, if we look at this part of the data structure, we have the following:</p>
<figure>
<img alt="Figure 11.10: The Fiction section of the Epic Nexus store data" src="img/file58.png"/><figcaption aria-hidden="true">Figure 11.10: The Fiction section of the Epic Nexus store data</figcaption>
</figure>
<p>In the big scheme of things, the whole organizational structure, down to the section level (without the books and sets), looks like this:</p>
<figure>
<img alt="Figure 11.11: the composite hierarchy without the books and sets" src="img/file59.png"/><figcaption aria-hidden="true">Figure 11.11: the composite hierarchy without the books and sets</figcaption>
</figure>
<blockquote>
<p>I omitted to publish the whole data structure, including the books, as an image because it is too large and would be hard to read. Rest assured, the content itself is unimportant, and the section we are studying is enough to understand the flexibility the composite pattern brings to the design.</p>
</blockquote>
<p>As we explore this, we can see how flexible the design is. We can create almost any organizational structure we want.Now, let’s look at the <code>Program.cs</code> file and register our dependencies and an endpoint to query the data structure:</p>
<div><pre><code>using Composite.Services;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;ICorporationFactory, DefaultCorporationFactory&gt;();
var app = builder.Build();
app.MapGet(
    "/",
    (ICorporationFactory corporationFactory)
        =&gt; corporationFactory.Create()
);
app.Run();</code></pre>
</div>
<p>The preceding code registers the factory that creates the corporation data structure with the container and an endpoint to serve it.When we execute the code, we get the full data structure or the corporation. For brevity reasons, the following JSON represents the fiction section, excluding the books:</p>
<div><pre><code>{
  "ceo": "Bosmang Kapawu",
  "name": "Boundless Shelves Corporation",
  "type": "Corporation",
  "count": 43,
  "children": [
    {
      "location": "369 Parchment Plaza, Novelty, NV 68123",
      "manager": "Ellen Ripley",
      "name": "Epic Nexus",
      "type": "Store",
      "count": 25,
      "children": [
        {
          "name": "Fiction",
          "type": "Section",
          "count": 11,
          "children": [
            {
              "name": "Science Fiction",
              "type": "Section",
              "count": 10,
              "children": [
                {
                  "name": "Star Wars",
                  "type": "Set",
                  "count": 9,
                  "children": [
                    {
                      "name": "Prequel trilogy",
                      "type": "Set",
                      "count": 3,
                      "children": []
                    },
                    {
                      "name": "Original trilogy",
                      "type": "Set",
                      "count": 3,
                      "children": []
                    },
                    {
                      "name": "Sequel trilogy",
                      "type": "Set",
                      "count": 3,
                      "children": []
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}</code></pre>
</div>
<blockquote>
<p>The value of the <code>count</code> fields reflect the total count. In this case, there is no book so the count should be 0. If you run the program and play with the preprocessor symbols define in the <code>DefaultCorporationFactory.cs</code> file (<code>ADD_BOOKS</code>, <code>ADD_SETS</code>, and <code>ONLY_FICTION</code>), you will end up with different number.</p>
</blockquote>
<p>The Composite pattern allowed us to render a complex data structure in a small method call. Since each component autonomously handles itself, the Composite pattern removes the burden of managing this complexity from the consumer.I encourage you to play around with the existing data structure so that you understand the pattern. You could also try adding a <code>Movie</code> class to manage movies; a bookstore must diversify its activities. You could also differentiate movies from books so that customers are not confused. The bookstores could have physical and digital books as well.If you are still looking for more, try building a new application from scratch and use the Composite pattern to create, manage, and display a multi-level menu structure or a file system API.</p>


<h3 data-number="12.3.4">Conclusion</h3>
<p>The Composite pattern effectively builds, manages, and maintains complex non-linear data structures. Its power is primarily in its self-management capabilities. Each node, component, or composite is responsible for its own logic, leaving little to no work for the composite’s consumers. Of course, a more complex scenario would have led to a more complex interface.Using the Composite pattern helps us follow the <strong>SOLID</strong> principles in the following ways:</p>
<ul>
<li><strong>S</strong>: It helps divide multiple elements of a complex data structure into small classes to split responsibilities.</li>
<li><strong>O</strong>: By allowing us to “mix and match” different implementations of <code>IComponent</code> interface, the Composite pattern allows us to extend the data structure without impacting the other existing classes. For example, you could create a new class that implements <code>IComponent</code> and start using it immediately without modifying any other component classes.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The Composite pattern may violate the ISP when single items implement operations that only impact the collections, like the <code>Add</code> and <code>Remove</code> methods, but we have not done this here.</li>
<li><strong>D</strong>: The Composite pattern actors depend solely on <code>IComponent</code> which invert the dependency flow.</li>
</ul>
<p>Next, we move to a different type of structural pattern that adapts one interface to another.</p>



<h2 data-number="12.4">Implementing the Adapter design pattern</h2>
<p>The Adapter pattern is another structural design pattern that allows two incompatible interfaces to work together without modifying their existing code. This pattern introduces a wrapper class called the <em>Adapter</em>, which bridges the gap between the interfaces.</p>

<h3 data-number="12.4.1">Goal</h3>
<p>The Adapter design pattern is applicable when we want to use an existing class, but its interface is incompatible with what we want to use it for. Instead of refactoring the class, which could introduce bugs or errors in the existing codebase or even cascade changes to other parts of the system, we can use an <em>Adapter</em> class to make the class's interface compatible with the <em>Target</em> interface. The Adapter pattern is handy when we cannot change the <em>Adaptee’s</em> code or do not want to change it.</p>


<h3 data-number="12.4.2">Design</h3>
<p>You can think of the adapter as a power outlet’s universal adapter; you can connect a North American device to a European outlet by connecting it to the adapter and then to the power outlet. The Adapter design pattern does precisely that but for APIs.Let’s start by looking at the following diagram:</p>
<figure>
<img alt="Figure 11.12: Adapter class diagram" src="img/file60.png"/><figcaption aria-hidden="true">Figure 11.12: Adapter class diagram</figcaption>
</figure>
<p>In the preceding diagram, we have the following actors:</p>
<ul>
<li>The <code>ITarget</code> interface holds the contract we want (or have) to use.</li>
<li>The <code>Adaptee</code> class represents the concrete component we want to use that does not conform to <code>ITarget.</code></li>
<li>The <code>Adapter</code> class adapts the <code>Adaptee</code> class to the <code>ITarget</code> interface.</li>
</ul>
<p>There is a second way of implementing the Adapter pattern that implies inheritance. If you can go for composition, go for it, but if you need access to <code>protected</code> methods or other internal states of <code>Adaptee</code>, you can go for inheritance instead, like this:</p>
<figure>
<img alt="Figure 11.13: Adapter class diagram inheriting the Adaptee" src="img/file61.png"/><figcaption aria-hidden="true">Figure 11.13: Adapter class diagram inheriting the Adaptee</figcaption>
</figure>
<p>The actors are the same, but instead of composing the <code>Adapter</code> class with the <code>Adaptee</code> class, the <code>Adapter</code> class inherits from the <code>Adaptee</code> class. This design makes the <code>Adapter</code> class become both an <code>Adaptee</code> and an <code>ITarget</code>.Let’s explore how this looks in code.</p>


<h3 data-number="12.4.3">Project – Greeter</h3>
<p><strong>Context</strong>: We’ve programmed a highly sophisticated greeting system that we want to reuse in a new program. However, its interface does not match the new design, and we cannot modify it because other systems use that greeting system.To fix this problem, we decided to apply the Adapter pattern. Here is the code of the external greeter (<code>ExternalGreeter</code>) and the new interface (<code>IGreeter</code>) used in the new system. This code must not directly modify the <code>ExternalGreeter</code> class to prevent any breaking changes from occurring in other systems:</p>
<div><pre><code>public interface IGreeter
{
    string Greeting();
}
public class ExternalGreeter
{
    public string GreetByName(string name)
    {
        return $"Adaptee says: hi {name}!";
    }
}</code></pre>
</div>
<p>Next is how the external greeter is adapted to meet the latest requirements:</p>
<div><pre><code>public class ExternalGreeterAdapter : IGreeter
{
    private readonly ExternalGreeter _adaptee;
    public ExternalGreeterAdapter(ExternalGreeter adaptee)
    {
        _adaptee = adaptee ?? throw new ArgumentNullException(nameof(adaptee));
    }
    public string Greeting()
    {
        return _adaptee.GreetByName("ExternalGreeterAdapter");
    }
}</code></pre>
</div>
<p>In the preceding code, the actors are as follows:</p>
<ul>
<li>The <code>IGreeter</code> interface represents the <em>Target</em> and is the interface that we must use.</li>
<li>The <code>ExternalGreeter</code> class represents the <em>Adaptee</em> and is the external component that already contains all the logic that someone programmed and tested. That code could be in an external assembly or installed from a NuGet package.</li>
<li>The <code>ExternalGreeterAdapter</code> class represents the <em>Adapter</em> and is where the adapter does its job. In this case, the <code>Greeting</code> method calls the <code>GreetByName</code> method of the <code>ExternalGreeter</code> class, which implements the greeting logic.</li>
</ul>
<p>Now, we can call the <code>Greeting</code> method and get the result of the <code>GreetByName</code> call. With this in place, we can reuse the existing logic through the <code>ExternalGreeterAdapter</code> class.</p>
<blockquote>
<p>We can also test <code>IGreeter</code> consumers by mocking the <code>IGreeter</code> interface without dealing with the <code>ExternalGreeterAdapter</code> class.</p>
</blockquote>
<p>In this case, the “complex logic” is pretty simple, but we are here for the Adapter pattern, not for imaginary business logic. Now, let’s take a look at the consumer:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services.AddSingleton&lt;ExternalGreeter&gt;();
builder.Services.AddSingleton&lt;IGreeter, ExternalGreeterAdapter&gt;();
var app = builder.Build();
app.MapGet("/", (IGreeter greeter) =&gt; greeter.Greeting());
app.Run();</code></pre>
</div>
<p>In the preceding code, we composed our application by registering the <code>ExternalGreeterAdapter</code> class as a singleton bound to the <code>IGreeter</code> interface. We also informed the container to provide a single instance of <code>ExternalGreeter</code> class whenever requested (in this case, we inject it into the <code>ExternalGreeterAdapter</code> class).Then, the consumer (<em>Client</em> in the class diagrams) is the highlighted endpoint where the <code>IGreeter</code> interface is injected as a parameter. Then, the delegate calls the <code>Greeting</code> method on that injected instance and outputs the greeting message to the response.The following diagram represents what’s happening in this system:</p>
<figure>
<img alt="Figure 11.14: Greeter system sequence diagram" src="img/file62.png"/><figcaption aria-hidden="true">Figure 11.14: Greeter system sequence diagram</figcaption>
</figure>
<p>And voilà! We’ve adapted the <code>ExternalGreeterAdapter</code> class to the <code>IGreeter</code> interface with little effort.</p>


<h3 data-number="12.4.4">Conclusion</h3>
<p>The Adapter pattern is another simple pattern that offers flexibility. With it, we can use older or non-conforming components without rewriting them. Of course, depending on the <em>Target</em> and <em>Adaptee</em> interfaces, you may need to put more or less effort into writing the code of the <em>Adapter</em> class.Now, let’s learn how the Adapter pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: The Adapter pattern has only one responsibility: make an interface work with another interface.</li>
<li><strong>O</strong>: The Adapter pattern allows us to modify the <em>Adaptee’s</em> interface without the need to modify its code.</li>
<li><strong>L</strong>: Inheritance is not much of a concern regarding the Adapter pattern, so this principle does not apply once again. If <em>Adapter</em> inherits from <em>Adaptee</em>, the goal is to change its interface, not its behavior, which should conform to the LSP.</li>
<li><strong>I</strong>: We can view the <em>Adapter</em> class as a facilitator to the ISP, with the <em>Target</em> interface as the ultimate destination. The Adapter pattern relies on the design of the <em>Target</em> interface but doesn't directly influence it. Per this principle, our primary focus should be to design the <em>Target</em> interface in a manner that abides by the ISP.</li>
<li><strong>D</strong>: The Adapter pattern introduces only an implementation of the <em>Target</em> interface. Even if the <em>Adapter</em> depends on a concrete class, it breaks the direct dependency on that external component by adapting it to the <em>Target</em> interface.</li>
</ul>
<p>Next, we explore the last structural pattern of the chapter that teaches foundational concepts.</p>



<h2 data-number="12.5">Implementing the Façade design pattern</h2>
<p>The Façade pattern is a structural pattern that simplifies the access to a complex system. It is very similar to the Adapter pattern, but it creates a wall (a façade) between one or more subsystems. The big difference between the adapter and the façade is that instead of adapting an interface to another, the façade simplifies the use of a subsystem, typically by using multiple classes of that subsystem.</p>
<blockquote>
<p>We can apply the same idea to shielding one or more programs, but in this case, we call the façade a gateway—more on that in <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>.</p>
</blockquote>
<p>The Façade pattern is extremely useful and can be adapted to multiple situations.</p>

<h3 data-number="12.5.1">Goal</h3>
<p>The Façade pattern aims to simplify the use of one or more subsystems by providing an interface that is easier to use than the subsystems themselves, shielding the consumers from that complexity.</p>


<h3 data-number="12.5.2">Design</h3>
<p>Imagine a system with a multitude of complex classes. Direct interaction between the consuming code and these classes can become problematic due to coupling, complexity, and low code readability and maintainability. The Facade design pattern offers a solution by providing a unified interface to a set of APIs in a subsystem, making it easier to use.The Facade class contains references to the objects of the complex subsystem and delegates client requests to the appropriate subsystem object. From a client's perspective, it only interacts with a single, simplified interface represented by the Facade. Behind the scenes, the Facade coordinates with the subsystem's components to fulfill the client's request.We could create multiple diagrams representing a multitude of subsystems, but let’s keep things simple. Remember that you can replace the single subsystem shown in the following diagram with as many subsystems as you need to adapt:</p>
<figure>
<img alt="Figure 11.15: A class diagram representing a Façade object that hides a complex subsystem" src="img/file63.png"/><figcaption aria-hidden="true">Figure 11.15: A class diagram representing a Façade object that hides a complex subsystem</figcaption>
</figure>
<p>The <em>Façade</em> plays the intermediary between the <em>Client</em> and the subsystem, simplifying its usage. Let’s see this in action as a sequence diagram:</p>
<figure>
<img alt="Figure 11.16: A sequence diagram representing a Façade object that interacts with a complex subsystem" src="img/file64.png"/><figcaption aria-hidden="true">Figure 11.16: A sequence diagram representing a Façade object that interacts with a complex subsystem</figcaption>
</figure>
<p>In the preceding diagram, the <em>Client</em> calls the <em>Façade</em> once, while the <em>Façade</em> places multiple calls against different classes.There are multiple ways of implementing a façade:</p>
<ul>
<li><strong>Opaque façades</strong>: In this form, the <code>Façade</code> class is inside the subsystem. All other classes of the subsystem have an <code>internal</code> visibility modifier. This way, only the classes inside the subsystem can interact with the other internal classes, forcing the consumers to use the <code>Façade</code> class.</li>
<li><strong>Transparent façades</strong>: In this form, the classes can have a <code>public</code> modifier, allowing the consumers to use them directly or to use the <code>Façade</code> class. This way, we can create the <code>Façade</code> class inside or outside the subsystem.</li>
<li><strong>Static façades</strong>: In this form, the <code>Façade</code> class is <code>static</code>. We can implement a static façade as opaque or transparent.</li>
</ul>
<blockquote>
<p>I recommend using static façades as a last resort because <code>static</code> elements limit flexibility and testability.</p>
</blockquote>
<p>We look at some code next.</p>


<h3 data-number="12.5.3">Project – The façades</h3>
<p>In this example, we play with the following C# projects:</p>
<ul>
<li>The <em>OpaqueFacadeSubSystem</em> class library showcases an <strong>opaque façade</strong>.</li>
<li>The <em>TransparentFacadeSubSystem</em> class library showcases a <strong>transparent façade</strong>.</li>
<li>The <em>Facade</em> project is a REST API that consumes the façades. It exposes two endpoints to access the <em>OpaqueFacadeSubSystem</em> project, and two others that target the <em>TransparentFacadeSubSystem</em> project.</li>
</ul>
<p>Let’s start with the class libraries.</p>
<blockquote>
<p>To follow the SOLID principles, adding some interfaces representing the elements of the subsystem seemed appropriate. In subsequent chapters, we explore how to organize our abstractions to be more reusable, but for now, both abstractions and implementations are in the same assembly.</p>
</blockquote>

<h4 data-number="12.5.3.1">Opaque façade</h4>
<p>In this assembly, only the façade is public; all the other classes are internal, which means they are hidden from the external world. In most cases, this is not ideal; hiding everything makes the subsystem less flexible and harder to extend.However, you may want to control access to your internal APIs in some scenarios. This may be because they are not mature enough and you don’t want any third party to depend on them, or for any other reasons you deem appropriate for your specific use case.Let’s start by taking a look at the following subsystem code:</p>
<div><pre><code>// An added interface for flexibility
public interface IOpaqueFacade
{
    string ExecuteOperationA();
    string ExecuteOperationB();
}
// A hidden component
internal class ComponentA
{
    public string OperationA() =&gt; "Component A, Operation A";
    public string OperationB() =&gt; "Component A, Operation B";
}
// A hidden component
internal class ComponentB
{
    public string OperationC() =&gt; "Component B, Operation C";
    public string OperationD() =&gt; "Component B, Operation D";
}
// A hidden component
internal class ComponentC
{
    public string OperationE() =&gt; "Component C, Operation E";
    public string OperationF() =&gt; "Component C, Operation F";
}
// The opaque façade using the other hidden components
public class OpaqueFacade : IOpaqueFacade
{
    private readonly ComponentA _componentA;
    private readonly ComponentB _componentB;
    private readonly ComponentC _componentC;
    // Using constructor injection
    internal OpaqueFacade(ComponentA componentA, ComponentB componentB, ComponentC componentC)
    {
        _componentA = componentA ?? throw new ArgumentNullException(nameof(componentA));
        _componentB = componentB ?? throw new ArgumentNullException(nameof(componentB));
        _componentC = componentC ?? throw new ArgumentNullException(nameof(componentC));
    }
    public string ExecuteOperationA()
    {
        return new StringBuilder()
            .AppendLine(_componentA.OperationA())
            .AppendLine(_componentA.OperationB())
            .AppendLine(_componentB.OperationD())
            .AppendLine(_componentC.OperationE())
            .ToString();
    }
    public string ExecuteOperationB()
    {
        return new StringBuilder()
            .AppendLine(_componentB.OperationC())
            .AppendLine(_componentB.OperationD())
            .AppendLine(_componentC.OperationF())
            .ToString();
    }
}</code></pre>
</div>
<p>The <code>OpaqueFacade</code> class is coupled with <code>ComponentA</code>, <code>ComponentB</code>, and <code>ComponentC</code> directly. There was no point in extracting any <code>internal</code> interfaces since the subsystem is not extensible anyway. We could have done this to offer some kind of internal flexibility, but in this case, there was no advantage.Besides this coupling, <code>ComponentA</code>, <code>ComponentB</code>, and <code>ComponentC</code> define two methods each, which return a string describing their source. With that code in place, we can observe what is happening and how the final result was composed.<code>OpaqueFacade</code> also exposes two methods, each composing a different message using the underlying subsystem’s components. This is a classic use of a façade; the façade queries other objects more or less complicatedly and then does something with the results, taking away the caller’s burden of knowing the subsystem.Since the members use the <code>internal</code> visibility modifier, we can’t directly register the dependencies with the IoC container from the program. To solve this problem, the subsystem can register its dependencies by adding an extension method. The following extension method is accessible by the consuming application:</p>
<div><pre><code>public static class StartupExtensions
{
    public static IServiceCollection AddOpaqueFacadeSubSystem(this IServiceCollection services)
    {
        services.AddSingleton&lt;IOpaqueFacade&gt;(serviceProvider
            =&gt; new OpaqueFacade(new ComponentA(), new ComponentB(), new ComponentC()));
        return services;
    }
}</code></pre>
</div>
<p>The preceding code manually creates the dependencies and adds a binding to the <code>IOpaqueFacade</code> interface so the system can use it. This hides everything but the interface from the consumer.Before exploring the REST API, we look at the transparent façade implementation.</p>


<h4 data-number="12.5.3.2">Transparent façade</h4>
<p>The transparent façade is the most flexible type of façade and is exceptionally suitable for a system that leverages dependency injection. The implementation is similar to the opaque façade, but the <code>public</code> visibility modifier changes how consumers can access the class library elements. For this system, it was worth adding interfaces to allow the consumers of the subsystem to extend it when needed.First, let’s take a look at the abstractions:</p>
<div><pre><code>namespace TransparentFacadeSubSystem.Abstractions
{
    public interface ITransparentFacade
    {
        string ExecuteOperationA();
        string ExecuteOperationB();
    }
    public interface IComponentA
    {
        string OperationA();
        string OperationB();
    }
    public interface IComponentB
    {
        string OperationC();
        string OperationD();
    }
    public interface IComponentC
    {
        string OperationE();
        string OperationF();
    
}</code></pre>
</div>
<p>The API of this subsystem is the same as the opaque façade. The only difference is how we can use and extend the subsystem (from a consumer standpoint). The implementations are mostly the same as well, but the classes implement the interfaces and are <code>public</code>; the highlighted elements represent those changes:</p>
<div><pre><code>namespace TransparentFacadeSubSystem
{
    public class ComponentA : IComponentA
    {
        public string OperationA() =&gt; "Component A, Operation A";
        public string OperationB() =&gt; "Component A, Operation B";
}
    public class ComponentB : IComponentB
    {
        public string OperationC() =&gt; "Component B, Operation C";
        public string OperationD() =&gt; "Component B, Operation D";
    }
    public class ComponentC : IComponentC
    {
        public string OperationE() =&gt; "Component C, Operation E";
        public string OperationF() =&gt; "Component C, Operation F";
    }
    public class TransparentFacade : ITransparentFacade
    {
        private readonly IComponentA _componentA;
        private readonly IComponentB _componentB;
        private readonly IComponentC _componentC;
    public TransparentFacade(IComponentA componentA, IComponentB
componentB, IComponentC componentC)
    {
        _componentA = componentA ?? throw new ArgumentNullException(nameof(componentA));
        _componentB = componentB ?? throw new ArgumentNullException(nameof(componentB));
        _componentC = componentC ?? throw new ArgumentNullException(nameof(componentC));
    }
        public string ExecuteOperationA()
        {
            return new StringBuilder()
                .AppendLine(_componentA.OperationA())
                .AppendLine(_componentA.OperationB())
                .AppendLine(_componentB.OperationD())
                .AppendLine(_componentC.OperationE())
                .ToString();
            }
        public string ExecuteOperationB()
        {
            return new StringBuilder()
                .AppendLine(_componentB.OperationC())
                .AppendLine(_componentB.OperationD())
                .AppendLine(_componentC.OperationF())
                .ToString();
        }
    }
}</code></pre>
</div>
<p>To simplify the use of the subsystem, we create the following extension method as a good practice that makes consuming the subsystem easier. Everything that we define in that method can be overridden from the composition root (which is not the case for the opaque façade):</p>
<div><pre><code>public static class StartupExtensions
{
    public static IServiceCollection AddTransparentFacadeSubSystem(this IServiceCollection services)
    {
        services.AddSingleton&lt;ITransparentFacade, TransparentFacade&gt;();
        services.AddSingleton&lt;IComponentA, ComponentA&gt;();
        services.AddSingleton&lt;IComponentB, ComponentB&gt;();
        services.AddSingleton&lt;IComponentC, ComponentC&gt;();
        return services;
    }
}</code></pre>
</div>
<p>All the <code>new</code> elements are gone and have been replaced by simple dependency registration (singleton lifetimes, in this case). These little differences give us the tools to reimplement any part of the subsystem if we want to, as we cover soon.</p>
<blockquote>
<p>We can register bindings in the transparent façade extension method because classes and interfaces are <code>public</code>. The container needs a public constructor to do its work.</p>
<blockquote>
<p>In the opaque façade, we had to define the constructor of the <code>OpaqueFacade</code> class as <code>internal</code> because the type of its parameters (<code>ComponentA</code>, <code>ComponentB</code>, and <code>ComponentC</code>) are internal, making it impossible to leverage the container. Changing the visibility modifier of the opaque façade constructor from <code>internal</code> to <code>public</code> would have yielded a <em>CS0051 Inconsistent accessibility</em> error.</p>
</blockquote>
</blockquote>
<p>Besides those differences, the transparent façade plays the same role as the opaque façade, outputting the same result.We consume those two façades next.</p>


<h4 data-number="12.5.3.3">The program</h4>
<p>Now, let’s analyze the consumer, an ASP.NET Core application that forwards HTTP requests to the façades and return the result as their response.The first step is to register the dependencies like this:</p>
<div><pre><code>var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddOpaqueFacadeSubSystem()
    .AddTransparentFacadeSubSystem()
;</code></pre>
</div>
<blockquote>
<p>With these extension methods, the application root is so clean that it is hard to know that we registered two subsystems against the IoC container. This is a good way of keeping your code organized and clean, especially when you’re building class libraries.</p>
</blockquote>
<p>Now that everything has been registered, the second thing we need to do is route those HTTP requests to the façades. Let’s take a look at the code first:</p>
<div><pre><code>var app = builder.Build();
app.MapGet(
    "/opaque/a",
    (IOpaqueFacade opaqueFacade)
        =&gt; opaqueFacade.ExecuteOperationA()
); 
app.MapGet(
    "/opaque/b",
    (IOpaqueFacade opaqueFacade)
        =&gt; opaqueFacade.ExecuteOperationB()
);
app.MapGet(
    "/transparent/a",
    (ITransparentFacade transparentFacade)
        =&gt; transparentFacade.ExecuteOperationA()
);
app.MapGet(
    "/transparent/b",
    (ITransparentFacade transparentFacade)
        =&gt; transparentFacade.ExecuteOperationB()
);
app.Run();</code></pre>
</div>
<p>In the preceding block, we define four routes. Each route dispatches the request to one of the façade’s methods (highlighted code) using the façade that is injected in its delegate.If you run the program and navigate to the <code>/transparent/a</code> endpoint, the page should display the following:</p>
<div><pre><code>Component A, Operation A
Component A, Operation B
Component B, Operation D
Component C, Operation E</code></pre>
</div>
<p>What happened is located inside the delegates. It uses the injected <code>ITransparentFacade</code> service and calls its <code>ExecuteOperationA()</code> method, and then outputs the <code>result</code> variable to the response stream.Now, let’s define how <code>ITransparentFacade</code> is composed:</p>
<ul>
<li><code>ITransparentFacade</code> is an instance of <code>TransparentFacade</code>.</li>
<li>We inject <code>IComponentA</code>, <code>IComponentB</code>, and <code>IComponentC</code> in the <code>TransparentFacade</code> class.</li>
<li>These dependencies are instances of <code>ComponentA</code>, <code>ComponentB</code>, and <code>ComponentC</code>, respectively.</li>
</ul>
<p>Visually, the following flow happens:</p>
<figure>
<img alt="Figure 11.17: A representation of the call hierarchy that occurs when the consumer executes the ExecuteOperationA method" src="img/file65.png"/><figcaption aria-hidden="true">Figure 11.17: A representation of the call hierarchy that occurs when the consumer executes the ExecuteOperationA method</figcaption>
</figure>
<p>In the preceding diagram, we can see the shielding that’s done by the façade and how it has made the consumer’s life easier: one call instead of four.</p>
<blockquote>
<p>One of the hardest parts of using dependency injection is its abstractness. If you are not sure how all those parts are assembled, add a breakpoint into Visual Studio (let’s say, on the <code>var result = transparentFacade.ExecuteOperationA()</code> line) and run the application in debug mode. From there, <strong>Step Into</strong> each method call. That should help you figure out what is happening. Using the debugger to find the concrete types and their states can help find details about a system or diagnose bugs.</p>
<blockquote>
<p>To use <strong>Step Into</strong>, you can use the following button or hit <strong>F11</strong>:</p>
</blockquote>
</blockquote>
<figure>
<img alt="Figure 11.18: The Visual Studio Step Into (F11) button" src="img/file66.png"/><figcaption aria-hidden="true">Figure 11.18: The Visual Studio Step Into (F11) button</figcaption>
</figure>
<p>Calling the other endpoints lead to similar results. As a reference, here’s the result from the other endpoints.Here’s the result for the <code>/transparent/b</code> endpoint:</p>
<div><pre><code>Component B, Operation C
Component B, Operation D
Component C, Operation F</code></pre>
</div>
<p>Here’s the results for the <code>/opaque/a</code> endpoint:</p>
<div><pre><code>Component A, Operation A
Component A, Operation B
Component B, Operation D
Component C, Operation E</code></pre>
</div>
<p>Here’s the result for the <code>/opaque/b</code> endpoint:</p>
<div><pre><code>Component B, Operation C
Component B, Operation D
Component C, Operation F</code></pre>
</div>
<p>Next, let’s update some results without changing the component’s code.</p>


<h4 data-number="12.5.3.4">Flexibility in action</h4>
<p>As discussed, the transparent façade adds more flexibility. Here, we explore this flexibility in action.<strong>Context</strong>: We want to change the behavior of the <code>TransparentFacade</code> class. At the moment, the result of the <code>transparent/b</code> endpoint looks like this:</p>
<div><pre><code>Component B, Operation C
Component B, Operation D
Component C, Operation F</code></pre>
</div>
<p>To demonstrate we can extend and change the subsystem without altering the it, let’s change the output to the following:</p>
<div><pre><code>Flexibility
Design Pattern
Component C, Operation F</code></pre>
</div>
<p>Because the <code>ComponentB</code> class provides the first two lines, we must replace it with a new implementation of the <code>IComponentB</code> interface. Let’s call this class <code>UpdatedComponentB</code>:</p>
<div><pre><code>using TransparentFacadeSubSystem.Abstractions;
namespace Facade;
public class UpdatedComponentB : IComponentB
{
    public string OperationC() =&gt; "Flexibility";
    public string OperationD() =&gt; "Design Pattern";
}</code></pre>
</div>
<p>The preceding code does exactly what we want. However, we have to tell the IoC container about it, like this:</p>
<div><pre><code>builder.Services
    .AddOpaqueFacadeSubSystem()
    .AddTransparentFacadeSubSystem()
    .AddSingleton&lt;IComponentB, UpdatedComponentB&gt;()
;</code></pre>
</div>
<p>If you run the program, you should see the desired result!</p>
<blockquote>
<p>Adding a dependency for a second time makes the container resolves that dependency, thus overriding the first one. However, both registrations remain in the services collection; for example, calling <code>GetServices&lt;IComponentB&gt;()</code> on <code>IServiceProvider</code> would return two dependencies. Do not confuse the <code>GetServices()</code> and <code>GetService()</code> methods (plural versus singular); one returns a collection while the other returns a single instance. That single instance is always the last that has been registered.</p>
</blockquote>
<p>That’s it! We updated the system without modifying it. This is what dependency injection can do for you when designing a program around it.</p>


<h4 data-number="12.5.3.5">Alternative façade patterns</h4>
<p>One alternative would be to create a <em>hybrid between a transparent façade and an opaque façade</em> by exposing the abstractions using the <code>public</code> visibility modifier (all of the interfaces) while keeping the implementations hidden under an <code>internal</code> visibility modifier. This hybrid design offers the right balance between <strong>control and flexibility</strong>.Another alternative would be to create <em>a façade outside of the subsystem</em>. In the previous examples, we created the façades inside the class libraries, but this is not mandatory; the façade is just a class that creates an accessible wall between your system and one or more subsystems. It should be located wherever you see fit. Creating external façades like this would be especially useful when you do not control the source code of the subsystem(s), such as if you only have access to the binaries. This could also be used to create project-specific façades over the same subsystem, giving you extra flexibility without cluttering your subsystems with multiple façades, shifting the maintenance cost from the subsystems to the client applications that use them.This one is more of a note than an alternative: you do not need to create an assembly per subsystem. I did it because it helped me explain different concepts in the examples, but you could create multiple subsystems in the same assembly. You could even create a single assembly that includes all your subsystems, façades, and the client code (all in a single project).</p>
<blockquote>
<p>Whether talking about subsystems or REST APIs, layering APIs is an excellent way to create low-level functionalities that are atomic but harder to use while providing a higher-level API to access them through the façade, leading to a better consumer experience.</p>
</blockquote>



<h3 data-number="12.5.4">Conclusion</h3>
<p>The Façade pattern is handy for simplifying consumers’ lives, allowing us to hide subsystems’ implementation details behind a wall. There are multiple flavors to it; the two most prominent ones are:</p>
<ul>
<li>The <strong>transparent façade</strong>, which increases flexibility by exposing at least part of the subsystem(s)</li>
<li>The <strong>opaque façade</strong>, which controls access by hiding most of the subsystem(s)</li>
</ul>
<p>Now, let’s see how the <strong>transparent façade</strong> pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: A well-designed <strong>transparent façade</strong> serves this exact purpose by providing a cohesive set of functionalities to its consumers by hiding overly complex subsystems or internal implementation details.</li>
<li><strong>O</strong>: A well-designed <strong>transparent façade</strong> and its underlying subsystem’s components can be extended without direct modification, as we saw in the <em>Flexibility in action</em> section.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: By exposing a façade that uses different smaller objects implementing small interfaces, we could say that the segregation is done at both the façade and the component levels.</li>
<li><strong>D</strong>: The Façade pattern does not specify anything about interfaces, so it is up to the developers to enforce this principle by using other patterns, principles, and best practices.</li>
</ul>
<p>Finally, let’s see how the <strong>opaque façade</strong> pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: A well-designed <strong>opaque façade</strong> serves this exact purpose by providing a cohesive set of functionalities to its clients by hiding overly complex subsystems or internal implementation details.</li>
<li><strong>O</strong>: By hiding the subsystem, the <strong>opaque façade</strong> limits our ability to extend it. However, we could implement a <strong>hybrid façade</strong> to help with that.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The <strong>opaque façade</strong> does not help nor diminish our ability to apply the ISP.</li>
<li><strong>D</strong>: The Façade pattern does not specify anything about interfaces, so it is up to the developers to enforce this principle by using other patterns, principles, and best practices.</li>
</ul>



<h2 data-number="12.6">Summary</h2>
<p>In this chapter, we covered multiple fundamental GoF structural design patterns. They help us extend our systems from the outside without modifying the actual classes, leading to a higher degree of cohesion by composing our object graph dynamically.We started with the Decorator pattern, a powerful tool that allows us to dynamically add new functionality to an object without altering its original code. Decorators can also be chained, allowing even greater flexibility (decorating other decorators). We learned that this pattern adheres to the Open-Closed principle and promotes the separation of responsibilities into smaller, manageable pieces.We also used an open-source tool named Scrutor that simplifies the decorator pattern usage by extending the built-in ASP.NET Core dependency injection system. Then, we covered the Composite pattern, which allows us to create complex, non-linear, and self-managed data structures with minimal effort. That hierarchical data structure where groups and single components are indistinguishable makes the hierarchy's traversal and manipulation easier. We use this pattern to build graphs or trees with self-managing nodes.After that, we covered the Adapter pattern, which allows two incompatible interfaces to work together without modifying their code. This pattern is very helpful when we need to adapt the components of external systems that we have no control over, do not want to change, or can’t change.Finally, we dug into the Façade pattern, similar to the Adapter pattern, but at the subsystem level. It allows us to create a wall in front of one or more subsystems, simplifying its usage. It could also be used to hide the implementation details of a subsystem from its consumers.The next chapter explores two GoF behavioral design patterns: the Template method and the Chain of Responsibility design pattern.</p>


<h2 data-number="12.7">Questions</h2>
<p>Here are a few revision questions:</p>
<ol>
<li>What is the main advantage of the Decorator pattern?</li>
<li>Can we decorate a decorator with another decorator?</li>
<li>What is the primary goal of the Composite design pattern?</li>
<li>Can we use the Adapter pattern to migrate an old API to a new system in order to adapt its APIs before rewriting it?</li>
<li>What is the primary responsibility of the Adapter pattern?</li>
<li>What is the difference between the Adapter and the Façade patterns?</li>
<li>What is the main difference between an Opaque façade and a Transparent façade?</li>
</ol>


<h2 data-number="12.8">Further reading</h2>
<ul>
<li>To learn more about Scrutor, please visit <a href="https://adpg.link/xvfS">https://adpg.link/xvfS</a></li>
</ul>


<h2 data-number="12.9">Answers</h2>
<ol>
<li>The Decorator pattern allows us to dynamically add new functionality to an object at runtime without modifying its original code, promoting flexibility, testability, and manageability.</li>
<li>Yes, we can decorate decorators by depending only on interfaces because they are just another implementation of the interface, nothing more.</li>
<li>The Composite design pattern aims to simplify handling complex structures by treating individual and group elements indistinguishably.</li>
<li>Yes, we could use an adapter for this.</li>
<li>The Adapter pattern's primary responsibility is to adapt one interface to work with another interface that is incompatible to use directly.</li>
<li>The Adapter and Façade design patterns are almost the same but are applied to different scenarios. The Adapter pattern adapts an API to another API, while the Façade pattern exposes a unified or simplified API, hiding one or more complex subsystems.</li>
<li>An Opaque façade hides most of the subsystem (<code>internal</code> visibility), controlling access to it, while a Transparent façade exposes at least part of the subsystem (<code>public</code> visibility), increasing flexibility.</li>
</ol>


</body>
</html>
