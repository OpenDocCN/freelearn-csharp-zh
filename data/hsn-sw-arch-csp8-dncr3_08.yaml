- en: Interacting with Data in C# - Entity Framework Core
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 中与数据交互 - Entity Framework Core
- en: 'As we mentioned in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, software
    systems are organized into layers, and each layer communicates with the previous
    and next layers through interfaces that don''t depend on how the layer is implemented.
    When the software is a Business/Enterprise system, it usually contains at least
    three layers: the data layer, the business layer, and the presentation layer.
    In general, the interface that''s offered by each layer and the way the layer
    is implemented depends on the application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 5 章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中提到的，*将微服务架构应用于企业应用程序*，软件系统被组织成层，并且每一层通过不依赖于层实现方式的接口与前一层和后一层进行通信。当软件是业务/企业系统时，它通常至少包含三个层：数据层、业务层和表示层。一般来说，每一层提供的接口以及层的实现方式取决于应用程序。
- en: However, it turns out that the functionalities offered by data layers are quite
    standard, since they just map data from a data storage subsystem into objects
    and vice versa. This leads to the conceptions of general-purpose frameworks for
    implementing data layers in a substantially declarative way. These tools are called
    **Object-Relational Mapping** (**ORM**) tools since they are data storage subsystems
    based on relational databases. However, they also work well with the modern non-relational
    storages classified as NoSQL databases (such as MongoDB and Azure Cosmos DB) since
    their data model is closer to the target object model than a pure relational model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结果证明数据层提供的功能相当标准化，因为它们只是将数据从数据存储子系统映射到对象，反之亦然。这导致了在相当声明式的方式下实现数据层的通用框架的概念。这些工具被称为
    **对象关系映射**（**ORM**）工具，因为它们是基于关系数据库的数据存储子系统。然而，它们与现代非关系存储（如 MongoDB 和 Azure Cosmos
    DB）也很好地协同工作，因为它们的数据模型比纯关系模型更接近目标对象模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding ORM basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ORM 基础知识
- en: Configuring Entity Framework Core
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Entity Framework Core
- en: Entity Framework Core migrations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core 迁移
- en: Querying and updating data with Entity Framework Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 查询和更新数据
- en: Deploying your data layer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的数据层
- en: Understanding Entity Framework Core advanced features – global filters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Entity Framework Core 高级功能 - 全局过滤器
- en: This chapter describes ORMs and how to configure them, and then focuses on Entity
    Framework Core, the ORM included in .NET Core.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了 ORM 以及如何对其进行配置，然后重点介绍了 Entity Framework Core，它是 .NET Core 中包含的 ORM。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2017 or 2019 free Community Edition or better
    with all the database tools installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要 Visual Studio 2017 或 2019 免费社区版或更高版本，并安装所有数据库工具。
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case. You will find the code for this chapter at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将通过基于 WWTravelClub 书籍用例的实用示例进行说明。您可以在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)找到本章的代码。
- en: Understanding ORM basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ORM 基础知识
- en: ORMs map relational DB tables into in-memory collections of objects where object
    properties correspond to DB table fields. Types from C#, such as Booleans, numeric
    types, and strings, have corresponding DB types. If GUIDs are not available in
    the mapped database, while single characters are mapped to DB single-character
    strings, then types such as GUIDs are mapped to their equivalent string representations.
    All date and time types are mapped either to C# `DateTime` when date/time contains
    no time zone information or to `DateTimeOffset` when date/time also contains explicit
    time zone information. Any DB time duration is mapped to a `TimeSpan`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 将关系数据库表映射到内存中的对象集合，其中对象属性对应于数据库表字段。来自 C# 的类型，如布尔值、数值类型和字符串，有对应的数据库类型。如果映射的数据库中没有
    GUID，而单个字符映射到数据库的单字符字符串，那么像 GUID 这样的类型则映射到它们的等效字符串表示。所有日期和时间类型要么映射到 C# 的 `DateTime`（当日期/时间不包含时区信息时），要么映射到
    `DateTimeOffset`（当日期/时间也包含显式时区信息时）。任何数据库时间长度都映射到 `TimeSpan`。
- en: Since the string properties of most object-oriented languages have no length
    limits associated with them (while DB string fields usually have length limits),
    the DB limits are taken into account in the DB mapping configuration. In general,
    when the mapping between DB types and object-oriented language types need options
    to be specified, these options are declared in the mapping configuration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数面向对象语言的字符串属性没有与之关联的长度限制（而数据库字符串字段通常有长度限制），因此在数据库映射配置中考虑了数据库限制。一般来说，当需要指定数据库类型和面向对象语言类型之间的映射选项时，这些选项在映射配置中声明。
- en: 'The way the whole configuration is defined depends on the specific ORM. Entity
    Framework Core offers three options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 整个配置的定义方式取决于具体的ORM。Entity Framework Core提供了三种选项：
- en: Data annotations (property attributes)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据注释（属性属性）
- en: Name conventions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定
- en: Fluent configuration interface based on configuration objects and methods
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于配置对象和方法的流畅配置接口
- en: While the fluent interface can be used to specify any configuration option,
    the data annotations and name conventions can be used for a smaller subset of
    them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然流畅式接口可以用来指定任何配置选项，但数据注释和命名约定可以用于其中较小的一部分。
- en: Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on)
    with DB-specific adapters called **providers** or **connectors**. Entity Framework
    Core has providers for most of the available DB engines.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ORM都适应特定的数据库类型（Oracle、MySQL、SQL Server等），并使用称为**提供程序**或**连接器**的数据库特定适配器。Entity
    Framework Core为大多数可用的数据库引擎提供了提供程序。
- en: A complete list of providers can be found at [https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/)找到提供程序的完整列表。
- en: Adapters are necessary for the differences in DB types, for the way transactions
    are handled, and for all the other features that are not standardized by the SQL
    language.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器对于数据库类型之间的差异、事务处理方式以及SQL语言未标准化的所有其他功能都是必要的。
- en: Relations among tables are represented with object pointers. For instance, in
    a one-to-many relationship, the class that's mapped to the *one* side of the relationship
    contains a collection that is populated with the related objects on the *many*
    side of the relationship. On the other hand, the class mapped to the *many* side
    of the relationship has a simple property that is populated with the uniquely
    related object on the *one* side of the relationship.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表之间的关系用对象指针表示。例如，在一对多关系中，映射到关系一方的类包含一个集合，该集合填充了关系多方相关的对象。另一方面，映射到关系多方的类有一个简单的属性，该属性填充了关系一方唯一相关的对象。
- en: The whole database (or just a part of it) is represented by an in-memory cache
    class that contains a property for each collection that's mapped to a DB table.
    First, the query and update operations are performed on an instance of an in-memory
    cache class, and then this instance is synchronized with the database. The in-memory
    cache class that's used by Entity Framework Core is called `DBContext` and it
    also contains the mapping configuration. More specifically, the application-specific
    in-memory cache class is obtained by inheriting `DBContext` and adding it to all
    the mapped collections and all the necessary configuration information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据库（或其一部分）由一个内存缓存类表示，该类包含映射到数据库表的每个集合的属性。首先，在内存缓存类的实例上执行查询和更新操作，然后与此实例同步数据库。Entity
    Framework Core使用的内存缓存类称为`DBContext`，它还包含映射配置。更具体地说，通过继承`DBContext`并向所有映射集合和所有必要的配置信息添加，可以获得特定于应用程序的内存缓存类。
- en: Summing up, `DBContext` subclass instances contain partial snapshots of the
    DB that are synchronized with the database to get/update the actual data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`DBContext`子类实例包含与数据库同步的数据库的部分快照，以获取/更新实际数据。
- en: DB queries are performed with a query language made of method calls on the collections
    of the in-memory cache class. The actual SQL is created and executed during the
    synchronization stage. For instance, Entity Framework Core performs **Language
    Integrated Queries** (**LINQ**) on the collections mapped to the DB tables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库查询是通过在内存缓存类集合上调用方法来执行的查询语言。实际的SQL是在同步阶段创建和执行的。例如，Entity Framework Core在映射到数据库表的集合上执行**语言集成查询**（**LINQ**）。
- en: 'In general, LINQ queries produce `IEnumerable` instances, that is, collections
    whose elements are not computed when `IEnumerable` is created at the end of the
    query, but when you actually attempt to retrieve the collection elements from
    `IEnumerable`. This works as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，LINQ查询生成`IEnumerable`实例，即元素在查询结束时创建`IEnumerable`时并未计算，而是在你实际尝试从`IEnumerable`检索集合元素时计算。其工作原理如下：
- en: LINQ queries that start from a mapped collection of a `DBContext` create a specific
    subclass of `IEnumerable` called `IQueryable`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DBContext`的映射集合开始的LINQ查询创建一个名为`IQueryable`的特定`IEnumerable`子类。
- en: An `IQueryable` contains all the information that's needed to issue a query
    to the database, but the actual SQL is produced and executed when the first element
    of the `IQueryable` is retrieved.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IQueryable` 包含发出数据库查询所需的所有信息，但实际的SQL是在检索`IQueryable`的第一个元素时生成和执行的。'
- en: Thus, in the case of Entity Framework Core, the synchronization with the database
    is performed when an element is actually retrieved from the final `IQueryable`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，在Entity Framework Core的情况下，数据库同步是在从最终的`IQueryable`检索元素时执行的。
- en: Typically, each Entity Framework query ends with a `ToList` or `ToArray` operation
    that transforms the `IQueryable` into a list or array, thereby causing the actual
    execution of the query on the database.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，每个Entity Framework查询都以`ToList`或`ToArray`操作结束，该操作将`IQueryable`转换为列表或数组，从而在数据库上实际执行查询。
- en: In case the query is expected to return just a single element or no element
    at all, we typically execute a `FirstOrDefault` operation that returns a single
    element, if any, or `null`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果预期查询将仅返回单个元素或根本不返回任何元素，我们通常执行一个`FirstOrDefault`操作，该操作返回一个元素（如果有的话），或者返回`null`。
- en: Also, updates, deletions, and additions of new entities to a DB table are performed
    by mimicking these operations on a `DBContext` collection property that represents
    the database table. However, entities may only be updated or deleted this way
    after they have been loaded in that memory collection by means of a query. An
    update query requires the in-memory representation of the entity to be modified
    as needed, while a delete query requires the in-memory representation of the entity
    to be removed from its in-memory mapped collection. In Entity Framework Core,
    the removal operation is performed by calling the `Remove(entity)` method of the
    collection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对DB表的新实体进行更新、删除和添加操作是通过模拟在表示数据库表的`DBContext`集合属性上执行这些操作来完成的。然而，实体只能通过查询将其加载到内存集合中后以这种方式更新或删除。更新查询需要根据需要修改实体的内存表示，而删除查询则需要从其内存映射集合中删除实体的内存表示。在Entity
    Framework Core中，通过调用集合的`Remove(entity)`方法执行删除操作。
- en: The addition of a new entity has no further requirements. It is enough to add
    the new entity to the in-memory collection. Updates, deletes, and additions that
    are performed on various in-memory collections are actually passed to the database
    with an explicit call to a DB synchronization method. For instance, Entity Framework
    Core passes all the changes that are performed on a `DBContext` instance to the
    database when you call the `DBContext.SaveChanges()` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新实体没有其他要求。只需将新实体添加到内存集合中即可。在内存集合上执行的各种更新、删除和添加操作实际上是通过显式调用DB同步方法传递给数据库的。例如，当你调用`DBContext.SaveChanges()`方法时，Entity
    Framework Core会将`DBContext`实例上执行的所有更改传递到数据库。
- en: Changes that are passed to the database during a synchronization operation are
    executed in a single transaction. Moreover, for ORMs, such as Entity Framework
    Core, that have an explicit representation of transactions, a synchronization
    operation is executed in the scope of a transaction, since it uses that transaction
    instead of creating a new one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步操作期间传递给数据库的更改将在单个事务中执行。此外，对于具有显式事务表示的ORM，例如Entity Framework Core，同步操作是在事务的作用域内执行的，因为它使用该事务而不是创建一个新的。
- en: The remaining sections in this chapter explain how to use Entity Framework Core,
    along with some example code based on this book's WWTravelClub use case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分解释了如何使用Entity Framework Core，以及一些基于本书WWTravelClub用例的示例代码。
- en: Configuring Entity Framework Core
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Entity Framework Core
- en: Since Database handling is confined within a dedicated application layer, it
    is good practice to define your Entity Framework Core (`DBContext`) in a separate
    library. Accordingly, we need to define a .NET Core class library project. As
    we discussed in the *Book use case – .NET Core in action, Main Types of .NET Core
    projects* section of [Chapter 2](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml),
    *Functional and Nonfunctional Requirements*, we have two different kinds of library
    projects: **.NET** **Standard** and **.NET Core**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库处理被限制在专用应用程序层内，将Entity Framework Core (`DBContext`)定义在单独的库中是一种良好的做法。相应地，我们需要定义一个.NET
    Core类库项目。正如我们在[第2章](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml)，*功能和非功能需求*部分的*书籍用例
    - .NET Core的实际应用，.NET Core项目的类型*中讨论的，我们有两种不同类型的库项目：**.NET** **Standard** 和 **.NET
    Core**。
- en: While .NET Core libraries are tied to a specific .NET Core version, .NET Standard
    2.0 libraries have a wide range of applications since they work with any .NET
    version greater than 2.0 and also with the classical .NET Framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET Core库与特定的.NET Core版本相关联，但.NET Standard 2.0库具有广泛的应用范围，因为它们可以与任何大于2.0的.NET版本以及经典的.NET
    Framework一起工作。
- en: However, the `Microsoft.EntityFrameworkCore` package (which we need in our DB
    layer) depends just on .NET Standard 2.0\. It is designed to work with a specific
    .NET Core version (its version numbers are the same as the .NET Core versions).
    Therefore, if we define our DB layer as .NET Standard 2.0, the specific `Microsoft.EntityFrameworkCore` package
    that we add as a dependency may conflict with another version of the same library
    contained in another system component that's tied to a specific .NET Core version.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Microsoft.EntityFrameworkCore`包（我们在数据库层需要它）仅依赖于.NET Standard 2.0。它被设计为与特定的.NET
    Core版本一起工作（其版本号与.NET Core版本相同）。因此，如果我们定义我们的数据库层为.NET Standard 2.0，我们添加作为依赖项的特定`Microsoft.EntityFrameworkCore`包可能与另一个系统组件中包含的同一库的另一个版本发生冲突，该组件与特定的.NET
    Core版本相关联。
- en: 'Since our library is not a general-purpose library (it''s just a component
    of a specific application), it is preferable to tie it to a specific .NET Core
    version than to track its version dependencies in the whole design of our application.
    Therefore, let''s choose a .NET Core library project for the latest .NET Core
    version installed on our machine. Our .NET Core library project can be created
    and prepared as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的库不是通用库（它只是特定应用程序的一个组件），我们更倾向于将其绑定到特定的.NET Core版本，而不是在整个应用程序设计中跟踪其版本依赖关系。因此，让我们选择一个.NET
    Core库项目，用于安装在我们机器上的最新.NET Core版本。我们的.NET Core库项目可以创建和准备如下：
- en: Open Visual Studio and define a new solution named `WWTravelClubDB` and then
    select Class Library (.NET Core) for the latest .NET Core version available.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，定义一个名为`WWTravelClubDB`的新解决方案，然后选择适用于最新.NET Core版本的类库 (.NET Core)。
- en: We must install all Entity Framework Core-related dependencies. The simplest
    way to have all the necessary dependencies installed is to add the NuGet package
    for the provider of the database engine we are going to use – in our case, SQL
    Server – as we mentioned in [Chapter 4](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml),
    *Deciding on the Best Cloud-Based Solution*. In fact, any provider will install
    all the required packages since it has all of them as dependencies. So, let's
    add the latest stable version of `Microsoft.EntityFrameworkCore.SqlServer`. If
    you plan to use several database engines, you can also add other providers since
    they can work side by side. Later in this chapter, we will install other NuGet
    packages that contain tools that we need to process our Entity Framework Core.
    Then, we will explain how to install further tools that are needed to process
    Entity Framework Core's configuration.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须安装所有与Entity Framework Core相关的依赖项。安装所有必需依赖项的最简单方法是将我们打算使用的数据库引擎提供者的NuGet包添加到项目中——在我们的例子中，是SQL
    Server——正如我们在[第4章](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml)，*选择最佳云解决方案*中提到的。实际上，任何提供者都会安装所有所需的包，因为它将它们作为依赖项。因此，让我们添加`Microsoft.EntityFrameworkCore.SqlServer`的最新稳定版本。如果你打算使用多个数据库引擎，你也可以添加其他提供者，因为它们可以并行工作。在本章的后面部分，我们将安装其他包含我们需要的工具的NuGet包，然后我们将解释如何安装进一步处理Entity
    Framework Core配置所需的工具。
- en: Let's rename the default `Class1` class to `MainDBContext`. This was automatically
    added to the class library.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将默认的`Class1`类重命名为`MainDBContext`。这被自动添加到类库中。
- en: 'Now, let''s replace its content with the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码替换其内容：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We inherit from `DbContext` and we are required to pass `DbContextOptions` to
    the `DBContext` constructor. `DbContextOptions` contains creation options such
    as the database connection string, which depend on the target DB engine.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`DbContext`继承，并且必须将`DbContextOptions`传递给`DBContext`构造函数。`DbContextOptions`包含创建选项，如数据库连接字符串，这些选项取决于目标数据库引擎。
- en: All the collections that have been mapped to database tables will be added as
    properties of `MainDBContext`. The mapping configuration will be defined inside
    of the overridden `OnModelCreating` method with the help of the `ModelBuilder`
    object passed as a parameter.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有已映射到数据库表中的集合都将作为`MainDBContext`的属性添加。映射配置将在重写的`OnModelCreating`方法中定义，该方法通过参数传递的`ModelBuilder`对象来实现。
- en: The next step is the creation of all the classes that represent all the DB table
    rows. These are called **entities**. We need an entity class for each DB table
    we want to map. Let's create a `Models` folder in the project root for all of
    them. The next subsection explains how to define all the required entities.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建所有代表数据库表行的类。这些被称为**实体**。我们需要为每个想要映射的数据库表创建一个实体类。让我们在项目根目录下创建一个`Models`文件夹来存放所有这些类。下一个小节将解释如何定义所有必需的实体。
- en: Defining DB entities
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据库实体
- en: 'DB design, like the whole application design, is organized in iterations. Let''s
    suppose that, in the first iteration, we need a prototype with two database tables:
    one for all the travel packages and another one for all the locations referenced
    by the packages. Each package covers just one location, while a single location
    may be covered by several packages, so the two tables are connected by a one-to-many
    relationship.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计，就像整个应用程序设计一样，是有组织的迭代过程。让我们假设在第一次迭代中，我们需要一个包含两个数据库表的原型：一个用于所有旅行套餐，另一个用于所有由套餐引用的位置。每个套餐只覆盖一个位置，而单个位置可能被多个套餐覆盖，因此两个表通过一对一的关系连接。
- en: 'So, let''s start with the location database table. As we mentioned at the end
    of the previous section, we need an entity class to represent the rows of this
    table. Let''s call `Destination` the entity class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从位置数据库表开始。正如我们在上一节末尾提到的，我们需要一个实体类来表示这个表的行。让我们将实体类命名为`Destination`：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the DB fields must be represented by read/write C# properties. Suppose that
    each destination is something like a town or a region that can be defined by just
    its name and the country it is in, and that all the relevant information is contained
    in its `Description`. In future iterations, we will probably add several more
    fields. `Id` is an auto-generated key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据库字段都必须由可读/写的C#属性表示。假设每个目的地就像一个城镇或地区，可以通过其名称和所在国家来定义，并且所有相关信息都包含在其`Description`中。在未来的迭代中，我们可能会添加更多字段。`Id`是一个自动生成的键。
- en: 'However, now, we need to add information about how all the fields are mapped
    to DB fields. In Entity Framework Core, all the primitive types are mapped automatically
    to DB types by the DB engine-specific provider that''s used (in our case, SQL
    Server provider). Our only preoccupations are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，我们需要添加有关所有字段如何映射到数据库字段的信息。在Entity Framework Core中，所有原始类型都由特定于数据库引擎的提供程序自动映射到数据库类型（在我们的情况下是SQL
    Server提供程序）。我们唯一关心的是以下内容：
- en: '**Length limits on the string**: They can be taken into account by applying
    adequate `MaxLength` and `MinLength` attributes to each string property. All the
    attributes that are useful for the entity''s configuration are contained in the `System.ComponentModel.DataAnnotation`
    and `System.ComponentModel.DataAnnotations.Schema` namespaces. Therefore, it''s
    good practice to add both of them to all the entity definitions.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串长度限制**：可以通过为每个字符串属性应用适当的`MaxLength`和`MinLength`属性来考虑。所有对实体配置有用的属性都包含在`System.ComponentModel.DataAnnotation`和`System.ComponentModel.DataAnnotations.Schema`命名空间中。因此，将它们都添加到所有实体定义中是一个好的实践。'
- en: '**Specifying which fields are obligatory and which ones are optional**: By
    default, all the reference types (such as all the strings) are assumed to be optional,
    while all the value types (numbers and GUIDs, for instance) are assumed to be
    obligatory. If we want a reference type to be obligatory, then we must decorate
    it with the `Required` attribute. However, if we want a `T` value type property
    to be optional, then we must replace it with `T?`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪些字段是必需的，哪些是可选的**：默认情况下，所有引用类型（如所有字符串）都被假定为可选的，而所有值类型（如数字和GUID）都被假定为必需的。如果我们想使一个引用类型成为必需的，那么我们必须用`Required`属性来装饰它。然而，如果我们想使`T`值类型属性成为可选的，那么我们必须用`T?`来替换它。'
- en: '**Specifying which property represents the primary key**: The key may be specified
    by decorating a property with the `Key` attribute. However, if no `Key` attribute
    is found, a property named `Id` (if there is one) is taken as the primary key.
    In our case, there is no need for the `Key` attribute. If the primary key is composed
    of several properties, it is enough to add the `Key` attribute to all of them.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪个属性代表主键**：键可以通过使用 `Key` 属性来指定。然而，如果没有找到 `Key` 属性，则将名为 `Id` 的属性（如果有的话）视为主键。在我们的案例中，不需要
    `Key` 属性。如果主键由多个属性组成，只需将 `Key` 属性添加到所有这些属性上即可。'
- en: Since each destination is on the *one* side of a one-to-many relationship, it
    must contain a collection for the related package entities; otherwise, we will
    not be able to refer to the related entities in the clauses of our LINQ queries.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个目的地在一对多关系的一侧，它必须包含一个相关包实体的集合；否则，我们无法在我们的 LINQ 查询子句中引用相关实体。
- en: 'Putting everything together, the final version of the `Destination` class is
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切整合，`Destination` 类的最终版本如下：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the `Description` property has no length limits, it will be implemented
    with a SQL Server `ntext` field of indefinite length. We can write the code for
    the `Package` class in a similar way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Description` 属性没有长度限制，它将使用不定长度的 SQL Server `ntext` 字段实现。我们可以用类似的方式编写 `Package`
    类的代码：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each package has a duration in days, as well as optional start and stop dates
    in which the package offer is valid. `MyDestination` connects packages with their
    destinations in the many-to-one relationship that they have with the `Destination`
    entity, while `DestinationId` is the external key of the same relation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都有持续的天数，以及可选的开始和结束日期，这些日期是包优惠有效的日期。`MyDestination` 通过与 `Destination` 实体之间的一对多关系将包与其目的地连接起来，而
    `DestinationId` 是同一关系的外部键。
- en: While it is not obligatory to specify the external key, it is good practice
    to do so since this is the only way to specify some properties of the relationship.
    For instance, in our case, since `DestinationId` is an `int` (value type), it
    is obligatory. Therefore, the relationship here is one-to-many and not (0, 1)-to-many.
    Defining `DestinationId` as `int?`, instead of `int`, would turn the one-to-many
    relationship into a (0, 1)-to-many relationship.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然指定外部键不是强制性的，但这是一个好的实践，因为这是指定关系某些属性的唯一方式。例如，在我们的案例中，由于 `DestinationId` 是一个
    `int`（值类型），这是强制性的。因此，这里的关系是一对多，而不是（0，1）到多。将 `DestinationId` 定义为 `int?`，而不是 `int`，将使一对多关系变为（0，1）到多关系。
- en: In the next section, we will explain how to define the in-memory collection
    that represents the database tables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何定义表示数据库表的内存集合。
- en: Defining the mapped collections
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义映射的集合
- en: 'Once we have defined all the entities that are object-oriented representations
    of the database rows, we need to define the in-memory collections that represent
    the database tables themselves. As we mentioned in the *ORM basics* section, all
    the database operations are mapped to the operations on these collections (the
    *Querying and updating data with Entity Framework Core* section of this chapter
    explains *how*). It is enough to add a `DbSet<T>` collection property to our `DBContext`
    for each entity, `T`. Usually, the name of each of these properties is obtained
    by pluralizing the entity name. Thus, we need to add the following two properties
    to our `MainDBContext`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有表示数据库行面向对象的实体，我们需要定义表示数据库表的内存集合。正如我们在 *ORM 基础* 小节中提到的，所有数据库操作都映射到这些集合的操作上（本章的
    *使用 Entity Framework Core 查询和更新数据* 小节解释了 *如何*）。对于每个实体 `T`，我们只需要在我们的 `DBContext`
    中为每个实体添加一个 `DbSet<T>` 集合属性。通常，这些属性的名称是通过将实体名称复数化得到的。因此，我们需要向我们的 `MainDBContext`
    添加以下两个属性：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Up until now, we've translated database stuff into properties, classes, and
    data annotations. However, Entity Framework needs further information to interact
    with a database. The next subsection explains how to provide them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据库内容转换为属性、类和数据注释。然而，Entity Framework 需要更多信息才能与数据库交互。下一小节将解释如何提供这些信息。
- en: Completing the mapping configuration
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成映射配置
- en: 'The mapping configuration information that we couldn''t specify in the entity
    definitions must be added in the `OnModelCreating DBContext` method. Each configuration
    information relative to an entity, `T`, starts with `builder.Entity<T>()` and
    continues with a call to a method that specifies that kind of constraint. Further
    nested calls specify further properties of the constraint. For instance, our one-to-many
    relationship may be configured as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体定义中无法指定的映射配置信息必须在 `OnModelCreating DBContext` 方法中添加。每个与实体 `T` 相关的配置信息从 `builder.Entity<T>()`
    开始，然后通过调用指定该类型约束的方法继续。进一步嵌套的调用指定约束的进一步属性。例如，我们的多对一关系可以配置如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The two sides of the relationship are specified through the navigation properties
    that we added to our entities. `HasForeignKey` specifies the external key. Finally,
    `OnDelete` specifies what to do with packages when a destination is deleted. In
    our case, it performs a cascade delete of all the packages related to that destination.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的两侧通过我们添加到实体的导航属性来指定。`HasForeignKey` 指定外部键。最后，`OnDelete` 指定在删除目标时对包的处理。在我们的例子中，它执行与该目标相关的所有包的级联删除。
- en: 'The same configuration can be defined by starting from the other side of the
    relationship, that is, starting with `builder.Entity<Package>()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的配置可以从关系的另一端开始定义，即从 `builder.Entity<Package>()` 开始：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only difference is that the previous statement's `HasMany`-`WithOne` methods
    are replaced by the `HasOne`-`WithMany` methods since we started from the other
    side of the relationship.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，由于我们从关系的另一端开始，所以之前的 `HasMany`-`WithOne` 方法被 `HasOne`-`WithMany` 方法所取代。
- en: 'The `ModelBuilder builder` object allows us to specify database indexes with
    something such as the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelBuilder builder` 对象允许我们使用如下方式指定数据库索引：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Multi-property indexes are defined as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 多属性索引的定义如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we add all the necessary configuration information, then our `OnModelCreating`
    method will look as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加所有必要的配置信息，那么我们的 `OnModelCreating` 方法将如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once you've configured Entity Framework Core, we can use all the configuration
    information we have to create the actual database and put all the tools we need
    in place in order to update the database's structure as the application evolves.
    The next section explains how.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 Entity Framework Core，我们就可以使用所有配置信息来创建实际的数据库，并将所有需要的工具放置到位，以便随着应用程序的发展更新数据库的结构。下一节将解释如何操作。
- en: Entity Framework Core migrations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework Core 迁移
- en: Now that we've configured Entity Framework and defined our application-specific
    `DBContext` subclass, we can use the Entity Framework Core design tools to generate
    the physical database and create the database structure snapshot that's needed
    by Entity Framework Core to interact with the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 Entity Framework 并定义了我们的应用程序特定的 `DBContext` 子类，我们可以使用 Entity Framework
    Core 设计工具生成物理数据库并创建 Entity Framework Core 与数据库交互所需的数据库结构快照。
- en: 'Entity Framework Core design tools must be installed in each project that needs
    them as NuGet packages. There are two equivalent options:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 设计工具必须作为 NuGet 包安装在每个需要它们的项目中。有两个等效选项：
- en: '**Tools that work in any Windows console**: These are available through the `Microsoft.EntityFrameworkCore.Design` NuGet
    package. All Entity Framework Core commands are in `dotnet ef .....` format since
    they are contained in the `ef` command line''s .NET Core application.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在任何 Windows 控制台中工作的工具**：这些通过 `Microsoft.EntityFrameworkCore.Design` NuGet
    包提供。所有 Entity Framework Core 命令都在 `dotnet ef ......` 格式中，因为它们包含在 .NET Core 命令行应用程序的
    `ef` 命令中。'
- en: '**Tools that are specific to the Visual Studio** Package Manager Console: These
    are contained in the `Microsoft.EntityFrameworkCore.Tools` NuGet package. They
    don''t need the `dotnet ef` prefix since they can only be launched from the Package
    Manager Console inside of Visual Studio.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio 特定的工具**：这些包含在 `Microsoft.EntityFrameworkCore.Tools` NuGet 包中。由于它们只能从
    Visual Studio 内部的包管理器控制台启动，因此不需要 `dotnet ef` 前缀。'
- en: 'Entity Framework Core''s design tools are used within the design/update procedure.
    This procedure is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 的设计工具在设计/更新过程中使用。该过程如下：
- en: We modify `DBContext` and Entities' definitions as needed.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据需要修改 `DBContext` 和实体的定义。
- en: We launch the design tools to ask Entity Framework Core to detect and process
    all the changes we made.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动设计工具，要求 Entity Framework Core 检测和处理我们所做的所有更改。
- en: Once launched, the design tools update the database structure snapshot and generate
    a new *migration*, that is, a file containing all the instructions we need in
    order to modify the physical database to reflect all the changes we made.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，设计工具将更新数据库结构快照并生成一个新的*迁移*，即包含所有我们需要修改物理数据库以反映所有更改的指令的文件。
- en: We launch another tool to update the database with the newly created migration.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们推出另一个工具来更新数据库，以包含新创建的迁移。
- en: We test the newly configured DB layer and, if new changes are necessary, we
    go back to *step 1*.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试新配置的DB层，如果需要新的更改，我们将返回到*步骤1*。
- en: When the data layer is ready, it is deployed in staging or production, where
    all the migrations are applied once more to the actual staging/production database.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据层准备就绪时，它将在预发布或生产环境中部署，此时所有迁移将再次应用到实际的预发布/生产数据库中。
- en: This is repeated several times in the various software project iterations and
    during the lifetime of the application. If we operate on an already existing database,
    we need to configure `DBContext` and its models to reflect the existing structure
    of all the tables we want to map. Then, we call the design tools with an `IgnoreChanges`
    option so that they generate an empty migration. Also, this empty migration must
    be passed to the physical database so that it can synchronize a database structure
    version associated with the physical database with the version that's been recorded
    in the database snapshot. This version is important because it determines which
    migrations must be applied to a database and which ones have already been applied.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这在各个软件项目迭代和应用程序的生命周期中重复多次。如果我们操作的是已经存在的数据库，我们需要配置`DBContext`及其模型以反映我们想要映射的所有表的现有结构。然后，我们使用`IgnoreChanges`选项调用设计工具，以便它们生成一个空迁移。此外，这个空迁移必须传递到物理数据库，以便它可以同步与物理数据库关联的数据库结构版本与数据库快照中记录的版本。这个版本很重要，因为它决定了哪些迁移必须应用到数据库以及哪些已经应用。
- en: 'The whole design process needs a test/design database and, if we operate on
    an existing database, the structure of this test/design database must reflect
    the actual database – at least in terms of the tables we want to map. To enable
    design tools so that we can interact with the database, we must define the `DbContextOptions`
    options that they pass to the `DBContext` constructor. These options are important
    at design time since they contain the connection string of the test/design database.
    The design tools can be informed about our `DbContextOptions` options if we create a
    class that implements the `IDesignTimeDbContextFactory<T>` interface, where `T`
    is our `DBContext` subclass:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 整个设计过程需要一个测试/设计数据库，如果我们操作的是现有数据库，则该测试/设计数据库的结构必须反映实际数据库——至少在我们想要映射的表方面。为了使设计工具能够与数据库交互，我们必须定义它们传递给`DBContext`构造函数的`DbContextOptions`选项。这些选项在设计时很重要，因为它们包含测试/设计数据库的连接字符串。如果我们创建一个实现`IDesignTimeDbContextFactory<T>`接口的类，其中`T`是我们的`DBContext`子类，设计工具就可以了解我们的`DbContextOptions`选项：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`connectionString` will be used by Entity Framework to create a new database
    in the local SQL Server instance that''s been installed in the development machine
    and connects with Windows credentials. You are free to change it to reflect your
    needs.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectionString`将由Entity Framework用于在开发机器上安装的本地SQL Server实例中创建一个新的数据库，并通过Windows凭据进行连接。你可以自由地更改它以反映你的需求。'
- en: 'Now, we are ready to create our first migration! Let''s get started:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好创建我们的第一个迁移了！让我们开始吧：
- en: Let's go to the Package Manager Console and ensure that WWTravelClubDB is selected
    as our default project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到包管理控制台，并确保WWTravelClubDB被选为我们的默认项目。
- en: 'Now, type `Add-Migration initial` and press *Enter* to issue this command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入`Add-Migration initial`并按*Enter*键来执行此命令：
- en: '![](img/d81b11a6-78ee-4f9f-b286-002c0b88ddb1.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d81b11a6-78ee-4f9f-b286-002c0b88ddb1.png)'
- en: '`initial` is the name we gave our first migration. So, in general, the command
    is `Add-Migration <migration name>`. When we operate on an existing database,
    we must add the `-IgnoreChanges` option to the first migration (and just to that)
    so that an empty migration is created. References to the whole set of commands
    can be found in the *Further reading* section.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial`是我们给第一个迁移取的名字。所以，一般来说，命令是`Add-Migration <迁移名称>`。当我们操作现有数据库时，我们必须将`-IgnoreChanges`选项添加到第一个迁移（仅添加到该迁移）以创建一个空迁移。有关所有命令的引用可以在*进一步阅读*部分找到。'
- en: If, after having created the migration, but before having applied the migration
    to the database, we realize we made some errors, we can undo our action with the
    `Remove-Migration` command. If the migration has already been applied to the database,
    the simplest way to correct our error is to make all the necessary changes to
    the code and then apply another migration.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在创建迁移之后但在将迁移应用到数据库之前，我们意识到我们犯了错误，我们可以使用`Remove-Migration`命令撤销我们的操作。如果迁移已经应用到数据库，纠正我们的错误的最简单方法是对代码进行所有必要的更改，然后应用另一个迁移。
- en: 'As soon as the `Add-Migration` command is executed, a new folder appears in
    our project:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行了`Add-Migration`命令，我们的项目中就会出现一个新的文件夹：
- en: '![](img/bb865a32-ee95-460d-ab24-c9b86ee779a6.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb865a32-ee95-460d-ab24-c9b86ee779a6.png)'
- en: '`20190205102637_initial.cs` is our migration expressed in an easy to understand
    language.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`20190205102637_initial.cs`是我们用易于理解的语言表达的迁移。'
- en: You may review the code to verify that everything is okay and you may also modify
    the migration content (only if you are enough of an expert to do it reliably).
    Each migration contains an `Up` method and a `Down` method. The `Up` method implies
    the migration, while the `Down` method undoes its changes. Accordingly, the `Down`
    method contains the reverse actions of all the actions included in the `Up` method
    in reverse order.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以审查代码以验证一切是否正常，并且您也可以修改迁移内容（只有当您足够专业才能可靠地完成时）。每个迁移都包含一个`Up`方法和一个`Down`方法。`Up`方法表示迁移，而`Down`方法则撤销其更改。因此，`Down`方法包含`Up`方法中包含的所有操作的逆序操作。
- en: '`20190205102637_initial.Designer.cs` is the Visual Studio designer code you
    *mustn''t* modify, while `MainDBContextModelSnapshot.cs` is the overall database
    structure snapshot. If you add further migrations, new migration files and their
    designer counterparts will appear and the unique `MainDBContextModelSnapshot.cs`
    database structure snapshot will be updated to reflect the database''s overall
    structure.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`20190205102637_initial.Designer.cs`是您*必须不*修改的Visual Studio设计器代码，而`MainDBContextModelSnapshot.cs`是整体数据库结构快照。如果您添加了更多的迁移，新的迁移文件及其设计器对应文件将出现，并且唯一的`MainDBContextModelSnapshot.cs`数据库结构快照将被更新以反映数据库的整体结构。'
- en: The same command can be issued in a Windows console by typing `dotnet ef migrations
    add initial`. However, this command must be issued from within the project's root
    folder (not from within the solution's root folder).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Windows控制台中通过输入`dotnet ef migrations add initial`来发出相同的命令。然而，此命令必须从项目的根目录（而不是从解决方案的根目录）发出。
- en: Migrations can be applied to the database by typing `Update-Database` in the
    Package Manager Console. The equivalent Windows console command is `dotnet ef
    database update`. Let's try using this command to create the physical database!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在包管理器控制台中输入`Update-Database`来将迁移应用到数据库。等效的Windows控制台命令是`dotnet ef database
    update`。让我们尝试使用这个命令来创建物理数据库！
- en: The next subsection explains how to create database stuff that Entity Framework
    is unable to create automatically. After that, in the next section, we will use
    Entity Framework's configuration and the database we generated with `dotnet ef
    database update` to create, query, and update data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了如何创建Entity Framework无法自动创建的数据库内容。之后，在下一节中，我们将使用Entity Framework的配置以及我们使用`dotnet
    ef database update`生成的数据库来创建、查询和更新数据。
- en: Understanding stored procedures and direct SQL commands
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解存储过程和直接SQL命令
- en: Some database structures can't be generated automatically by the Entity Framework
    Core commands and declarations we described previously. For instance, Entity Framework
    Core can't generate automatically stored procedures. Stored procedures such as
    generic SQL strings can be included manually in the `Up` and `Down` methods through
    the `migrationBuilder.Sql("<sql scommand>")` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库结构不能通过我们之前描述的Entity Framework Core命令和声明自动生成。例如，Entity Framework Core不能自动生成存储过程。如通用SQL字符串之类的存储过程可以通过`migrationBuilder.Sql("<sql
    scommand>")`方法手动包含在`Up`和`Down`方法中。
- en: The safest way to do this is by adding a migration without performing any configuration
    changes so that the migration is empty when it's created. Then, we can add the
    necessary SQL commands to the empty `Up` method of this migration and their converse
    commands in the empty `Down` method. It is good practice to put all the SQL strings
    in the properties of resource files (`.resx` files).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最安全的方式是添加一个不执行任何配置更改的迁移，这样在创建时迁移是空的。然后，我们可以将必要的 SQL 命令添加到这个迁移的空 `Up` 方法中，以及它们的逆命令在空
    `Down` 方法中。将所有 SQL 字符串放在资源文件（`.resx` 文件）的属性中是一种良好的做法。
- en: Now, you are ready to interact with the database through Entity Framework Core.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好通过 Entity Framework Core 与数据库进行交互了。
- en: Querying and updating data with Entity Framework Core
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 查询和更新数据
- en: 'To test our DB layer, we need to add a console project based on the same .NET
    Core version as our library to the solution. Let''s get started:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的数据库层，我们需要将一个基于与我们的库相同 .NET Core 版本的控制台项目添加到解决方案中。让我们开始吧：
- en: Let's call the new console project `WWTravelClubDBTest`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新的控制台项目命名为 `WWTravelClubDBTest`。
- en: Now, we need to add our data layer as a dependency of the console project by
    right-clicking on the *References* node of the console project and selecting *Add
    reference*.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过在控制台项目的 *References* 节点右键单击并选择 *Add reference* 来将我们的数据层作为控制台项目的依赖项添加。
- en: 'Remove the content of the `Main` static method in the `program.cs` file and
    start by writing the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `program.cs` 文件中的 `Main` 静态方法中删除内容，并开始编写以下内容：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, add the following namespaces at the top of the file:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文件顶部添加以下命名空间：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we have finished preparing our test project, we can experiment with
    queries and data updates. Let''s start by creating some database objects, that
    is, some destinations and packages. Follow these steps to do so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了测试项目的准备工作，我们可以尝试查询和数据更新。让我们首先创建一些数据库对象，即一些目的地和包。按照以下步骤操作：
- en: 'First, we must create an instance of our `DBContext` subclass with an appropriate
    connection string. We can use the same `LibraryDesignTimeDbContextFactory` class
    that''s used by the design tools to get it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须使用适当的连接字符串创建我们的 `DBContext` 子类的一个实例。我们可以使用设计工具使用的相同 `LibraryDesignTimeDbContextFactory`
    类来获取它：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'New rows can be created by simply adding class instances to the mapped collections
    of our `DBContext` subclass. If a `Destination` instance has packages associated
    with it, we can simply add them to its `Packages` property:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过简单地将类实例添加到我们 `DBContext` 子类的映射集合中来创建新行。如果一个 `Destination` 实例与包相关联，我们可以简单地将其添加到其
    `Packages` 属性中：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is no need to specify primary keys since they are auto-generated and will
    be filled in by the database. In fact, after the `SaveChanges()` operation synchronizes
    our context with the actual DB, the `firstDestination.Id` property has a non-zero
    value. The same is true for the primary keys of `Package`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要指定主键，因为它们是自动生成的，将由数据库填充。实际上，在 `SaveChanges()` 操作同步我们的上下文与实际数据库后，`firstDestination.Id`
    属性有一个非零值。对于 `Package` 的主键也是如此。
- en: 'When we declare that an entity (in our case, a `Package`) is a child of another
    entity (in our case, a `Destination`) by inserting it in a father entity collection
    (in our case, the `Packages` collection), there is no need to explicitly set its
    external key (in our case, `DestinationId`) since it is inferred automatically
    by Entity Framework Core. Once created and synchronized with the `firstDestination` database,
    we can add further packages in two different ways:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过将其插入父实体集合（在我们的例子中是 `Packages` 集合）来声明一个实体（在我们的例子中是 `Package`）是另一个实体（在我们的例子中是
    `Destination`）的子实体时，没有必要显式设置其外键（在我们的例子中是 `DestinationId`），因为 Entity Framework
    Core 会自动推断它。一旦创建并与 `firstDestination` 数据库同步，我们可以通过两种不同的方式添加更多包：
- en: Create a `Package` class instance, set its `DestinationId` external key to `firstDestination.Id`
    and add it to `context.Packages`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `Package` 类实例，将其 `DestinationId` 外键设置为 `firstDestination.Id`，并将其添加到 `context.Packages`
- en: Create a `Package` class instance, with no need to set its external key, and
    then add it to the `Packages` collection of its father `Destination` instance.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个不需要设置外键的 `Package` 类实例，然后将其添加到其父 `Destination` 实例的 `Packages` 集合中。
- en: The latter option is the only possibility when a child entity (`Package`) is
    added with its father entity (`Destination`) and the father entity has an auto-generated
    principal key since, in this case, the external key isn't available at the time
    we perform the additions. In most of the other circumstances, the former option
    is simpler since the second option requires the father `Destination` entity to
    be loaded in memory, along with its `Packages` collection, that is, together with
    all the packages associated with the `Destination` object (by default, connected
    entities aren't loaded by queries).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种选项是唯一的选择，当添加具有其父实体（`Destination`）的子实体（`Package`）且父实体具有自动生成的主键时，在这种情况下，外部键在我们执行添加操作时不可用。在大多数其他情况下，前一种选项更简单，因为第二种选项需要将父`Destination`实体及其`Packages`集合加载到内存中，即与所有与`Destination`对象关联的套餐一起（默认情况下，通过查询不会加载连接的实体）。
- en: 'Now, let''s say we want to modify the *Florence* destination and give a 10%
    increment to all `Florence` packages prices. How do we proceed? Follow these steps
    to find out how:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想修改*佛罗伦萨*目的地，并将所有`佛罗伦萨`套餐的价格提高10%。我们该如何操作？按照以下步骤了解如何进行：
- en: 'First, we need to load the entity into memory with a query, modify it, and
    call `SaveChanges()` to synchronize our changes with the database. If we want
    to modify, say, just its description, a query such as the following is enough:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过查询将实体加载到内存中，修改它，并调用`SaveChanges()`来同步我们的更改与数据库。如果我们只想修改，比如描述，以下查询就足够了：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to load all the related destination packages that are not loaded by
    default. This can be done with the `Include` clause, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要加载所有默认未加载的相关目的地套餐。这可以通过`Include`子句完成，如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After that, we can modify the description and package prices, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以修改描述和套餐价格，如下所示：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, we've performed queries whose unique purpose is to update the retrieved
    entities. Next, we will explain how to retrieve information that will be shown
    to the user and/or be used by complex business operations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行了查询，其唯一目的是更新检索到的实体。接下来，我们将解释如何检索将显示给用户以及/或用于复杂业务操作的信息。
- en: Returning data to the presentation layer
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据返回到表示层
- en: 'To keep the layers separated and to adapt queries to the data that''s actually
    needed by each *use case*, DB entities aren''t sent as they are to the presentation
    layer. Instead, the data is projected into smaller classes that contain the information
    that''s needed by the *use case*. These are implemented by the presentation layer''s
    caller method. Objects that move data from one layer to another are called **Data
    Transport Objects** (**DTOs**). As an example, let''s create a DTO containing
    the summary information that is worth showing when returning a list of packages
    to the user (we suppose that, if needed, the user can get more details by clicking
    the package they are interested in):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持层之间的分离，并使查询适应每个*用例*实际需要的数据，数据库实体不会直接发送到表示层。相反，数据被投影到包含*用例*所需信息的更小的类中。这些类由表示层的调用方法实现。在将数据从一个层移动到另一个层的对象被称为**数据传输对象**（**DTOs**）。例如，让我们创建一个包含当向用户返回套餐列表时值得显示的摘要信息的DTO（我们假设如果需要，用户可以通过点击他们感兴趣的套餐来获取更多详细信息）：
- en: 'Let''s add a DTO to our WWTravelClubDBTest project that contains all the information
    that needs to be shown in a list of packages:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的WWTravelClubDBTest项目中添加一个DTO，其中包含需要在套餐列表中显示的所有信息：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We don't need to load entities in memory and then copy their data into the DTO,
    but database data can be projected directly into the DTO, thanks to the LINQ `Select`
    clause. This minimizes how much data is exchanged with the database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在内存中加载实体并将它们的数据复制到DTO中，但数据库数据可以直接投影到DTO中，这得益于LINQ的`Select`子句。这最小化了与数据库交换的数据量。
- en: 'As an example, we can populate our DTOs with a query that checks all the packages
    that are available around the 10th of August:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们可以使用查询来填充我们的DTOs，该查询检查所有在8月10日左右可用的套餐：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `Select` clause, we can also navigate to any related entities to get
    the data we need. For instance, the preceding query navigates to the related `Destination`
    entity to get the `Package` destination name.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Select`子句中，我们还可以导航到任何相关实体以获取所需的数据。例如，前面的查询导航到相关的`Destination`实体以获取`Package`的目的地名称。
- en: Now, right-click on the WWTravelClubDBTest project in the Solution Explorer
    and set it as the start project. Then, run the solution.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在解决方案资源管理器中右键单击 WWTravelClubDBTest 项目，将其设置为启动项目。然后，运行解决方案。
- en: The programs stop at each `Console.ReadKey()` method, waiting for you to hit
    any key. This way, you have time to analyze the output that's produced by all
    the code snippets that we added to the `Main` method.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序在每个 `Console.ReadKey()` 方法处停止，等待您按任意键。这样，您就有时间分析所有代码片段产生的输出，这些代码片段都已添加到 `Main`
    方法中。
- en: Now, we will learn how to handle operations that can't be efficaciously mapped
    to the immediate operations in the in-memory collections that represent the database
    tables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何处理无法有效地映射到表示数据库表的内存集合的即时操作的运算。
- en: Issuing direct SQL commands
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出直接 SQL 命令
- en: 'Not all database operations can be executed efficiently by querying the database
    with LINQ and updating in-memory entities. For instance, counter increments can
    be performed more efficiently with a single SQL instruction. Moreover, some operations
    can be executed with acceptable performance if we define adequate stored procedures/SQL
    commands. In these cases, we are forced to either issue direct SQL commands to
    the database or call database stored procedures from our Entity Framework code.
    There are two possibilities: SQL statements that perform database operations but
    do not return entities, and SQL statements that do return entities.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据库操作都可以通过使用 LINQ 查询数据库并在内存中更新实体来高效执行。例如，计数器增加可以通过单个 SQL 指令更高效地执行。此外，如果我们定义了适当的存储过程/SQL
    命令，一些操作可以以可接受的性能执行。在这些情况下，我们被迫直接向数据库发出 SQL 命令或从我们的 Entity Framework 代码中调用数据库存储过程。有两种可能性：执行数据库操作但不返回实体的
    SQL 语句，以及返回实体的 SQL 语句。
- en: 'SQL commands that don''t return entities can be executed with the `DBContext`
    method, as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回实体的 SQL 命令可以使用 `DBContext` 方法执行，如下所示：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Parameters can be referenced in the string as `{0}, {1}, ..., {n}`. Each `{m}`
    is filled with the object contained at the `m` index of the `parameters` array,
    which is converted from a .NET type into the corresponding SQL type. The method
    returns the number of affected rows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以在字符串中以 `{0}, {1}, ..., {n}` 的形式引用。每个 `{m}` 都会被填充到 `parameters` 数组的 `m` 索引处的对象，该对象从
    .NET 类型转换为相应的 SQL 类型。该方法返回受影响的行数。
- en: 'SQL commands that return collections of entities must be issued through the
    `FromSqlRaw` method of the mapped collection associated with those entities:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回实体集合的 SQL 命令必须通过与这些实体关联的映射集合的 `FromSqlRaw` 方法发出：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Thus, for instance, a command that returns `Package` instances would look something
    like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，返回 `Package` 实例的命令可能看起来像这样：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'SQL strings and parameters work like this in the `ExecuteSqlRaw` method. The
    following is a simple example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ExecuteSqlRaw` 方法中，SQL 字符串和参数是这样工作的。以下是一个简单的示例：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is good practice to put all the SQL strings in resource files and encapsulate
    all the `ExecuteSqlRaw` and `FromSqlRaw` calls inside the public methods that
    you defined in your `DBContext` subclasses, in order to keep the dependence from
    a specific database inside of your Entity Framework Core-based data layer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有 SQL 字符串放入资源文件中，并将所有 `ExecuteSqlRaw` 和 `FromSqlRaw` 调用封装在您在 `DBContext` 子类中定义的公共方法内，是一种良好的实践，这样可以保持您的
    Entity Framework Core 数据层内部对特定数据库的依赖。
- en: Handling transactions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事务
- en: 'All the changes that are made to a `DBContext` instance are passed in a single
    transaction at the first `SaveChanges` call. However, sometimes, it is necessary
    to include queries and updates in the same transaction. In these cases, we must
    handle the transaction explicitly. Several entity Framework Core commands can
    be included in a transaction if we put them inside a `using` block associated
    with a transaction object:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `DBContext` 实例所做的所有更改都在第一次 `SaveChanges` 调用中以单个事务传递。然而，有时有必要在同一个事务中包含查询和更新。在这些情况下，我们必须显式处理事务。如果我们将几个实体
    Framework Core 命令放入与事务对象关联的 `using` 块中，那么这些命令可以包含在一个事务中：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, `context` is an instance of our `DBContext` subclass.
    Inside of the `using` block, the transaction can be aborted and committed by calling
    its `Rollback` and `Commit` methods. Any `SaveChanges` calls that are included
    in the transaction block use the transaction they are already in, instead of creating
    new ones.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`context`是我们`DBContext`子类的一个实例。在`using`块内部，可以通过调用其`Rollback`和`Commit`方法来中止和提交事务。任何包含在事务块中的`SaveChanges`调用都将使用它们已经所在的交易，而不是创建新的交易。
- en: Deploying your data layer
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署你的数据层
- en: When your database layer is deployed in production or in staging, usually, an
    empty database already exists, so you must apply all the migrations in order to
    create all the database objects. This can be done by calling `context.Database.Migrate()`.
    The `Migrate` method applies the migrations that haven't been applied to the databases
    yet, so it may be called safely several times during the application's lifetime. `context`
    is an instance of our `DBContext` class that must be passed through a connection
    string with enough privileges to create tables and to perform all the operations
    included in our migrations. Thus, typically, this connection string is different
    from the string we will use during normal application operations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的数据库层在生产或预发布环境中部署时，通常已经存在一个空数据库，因此你必须应用所有迁移以创建所有数据库对象。这可以通过调用`context.Database.Migrate()`来完成。`Migrate`方法应用尚未应用到数据库中的迁移，因此它可以在应用程序的生命周期中安全地多次调用。`context`是我们`DBContext`类的一个实例，必须通过一个具有足够权限创建表和执行我们迁移中包含的所有操作的连接字符串来传递。因此，通常，此连接字符串与我们在正常应用程序操作中使用的字符串不同。
- en: During the deployment of a web application on Azure, we are given the opportunity
    to check migrations with a connection string we provide. We can also check migrations
    manually by calling the `context.Database.Migrate()` method when the application
    starts. This will be discussed in detail in [Chapter 13](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml),
    *Presenting ASP.NET Core MVC*, which is dedicated to ASP.NET MVC Web applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Web应用程序部署到Azure的过程中，我们有机会使用我们提供的连接字符串来检查迁移。我们还可以在应用程序启动时通过调用`context.Database.Migrate()`方法手动检查迁移。这将在第13章[展示ASP.NET
    Core MVC](003ee8cb-5995-4364-8772-73d73df29cf8.xhtml)中详细讨论，该章节专门介绍ASP.NET MVC
    Web应用程序。
- en: For desktop applications, we can apply migrations during the installation of
    the application and of its subsequent updates.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面应用程序，我们可以在应用程序安装及其后续更新期间应用迁移。
- en: At the first application installation and/or in subsequent application updates,
    we may need to populate some tables with initial data. For Web applications this
    operation can be performed at application start, while for desktop application
    this operation can be included in the installation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次应用程序安装和/或后续应用程序更新时，我们可能需要用初始数据填充一些表。对于Web应用程序，此操作可以在应用程序启动时执行，而对于桌面应用程序，此操作可以包含在安装过程中。
- en: 'Database tables can be populated with Entity Framework Core commands. First,
    though, we need to verify whether the table is empty in order to avoid adding
    the same table rows several times. This can be done with the `Any()` LINQ method,
    as shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Entity Framework Core命令填充数据库表。首先，我们需要验证表是否为空，以避免多次添加相同的表行。这可以通过以下代码中的`Any()`
    LINQ方法来完成：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's take a look at a few advanced features that Entity Framework Core has
    to share.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Entity Framework Core要分享的一些高级功能。
- en: Understanding Entity Framework Core advanced feature – global filters
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Entity Framework Core高级功能——全局过滤器
- en: Global filters were introduced at the end of 2017\. They enable techniques such
    as soft delete and multi-tenant tables that are shared by several users, where
    each user just *sees* its records.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 全局过滤器是在2017年底引入的。它们使诸如软删除和多租户表等技术成为可能，这些技术被多个用户共享，其中每个用户只需*看到*自己的记录。
- en: 'Global filters are defined with the `modelBuilder` object, which is available
    in the `DBContext OnModelCreating` method. The syntax for this method is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 全局过滤器是通过`modelBuilder`对象定义的，该对象在`DBContext.OnModelCreating`方法中可用。此方法的语法如下：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For instance, if we add an `IsDeleted` property to our `Package` class, we
    may soft delete a Package without removing it from the database by defining the
    following filter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们向我们的`Package`类添加一个`IsDeleted`属性，我们可以通过定义以下过滤器来对Package进行软删除，而不从数据库中删除它：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, filters contain `DBContext` properties. Thus, for instance, if we
    add a `CurrentUserID` property to our `DBContext` subclass (whose value is set
    as soon as a `DBContext` instance is created), then we can add a filter like the
    following one to all the entities that refer to a user ID:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过滤器包含`DBContext`属性。因此，例如，如果我们向我们的`DBContext`子类（其值在创建`DBContext`实例时设置）添加一个`CurrentUserID`属性，那么我们可以向所有引用用户ID的实体添加如下过滤器：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the preceding filter in place, the currently logged user can only access
    the documents they own (the ones that have their `UserId`). Similar techniques
    are very useful in the implementation of multi-tenant applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置上述过滤器后，当前登录的用户只能访问他们拥有的文档（具有其`UserId`的文档）。类似的技术在多租户应用程序的实现中非常有用。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the essentials of ORM basics and why they are
    so useful. Then, we described Entity Framework Core. In particular, we discussed
    how to configure the database mappings with class annotations and other declarations
    and commands that are included in `DBContext` subclasses.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了ORM基础知识的要点以及为什么它们如此有用。然后，我们描述了Entity Framework Core。特别是，我们讨论了如何使用类注解和其他包含在`DBContext`子类中的声明和命令来配置数据库映射。
- en: Then, we discussed how to automatically create and update the physical database
    structure with the help of migrations, as well as how to query and pass updates
    to the database through Entity Framework Core. Finally, we learned how to pass
    direct SQL commands and transactions through Entity Framework Core, as well as
    how to deploy a data layer based on Entity Framework Core.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何使用迁移自动创建和更新物理数据库结构，以及如何通过Entity Framework Core查询和传递数据库更新。最后，我们学习了如何通过Entity
    Framework Core传递直接SQL命令和事务，以及如何基于Entity Framework Core部署数据层。
- en: This chapter also reviewed some of the advanced features that had been introduced
    in the latest Entity Framework Core releases.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还回顾了最新Entity Framework Core版本中引入的一些高级功能。
- en: In the next chapter, we will discuss how Entity Framework Core can be used with
    NoSQL data models and the various types of storage options that are available
    in the cloud and, in particular, in Azure.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用Entity Framework Core与NoSQL数据模型结合，以及云中（特别是Azure中）可用的各种存储选项。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does Entity Framework Core adapt to several different database engines?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core如何适应几个不同的数据库引擎？
- en: How are primary keys declared in Entity Framework Core?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Entity Framework Core中如何声明主键？
- en: How is a string field's length declared in Entity Framework Core?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Entity Framework Core中如何声明字符串字段的长度？
- en: How are indexes declared in Entity Framework Core?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Entity Framework Core中如何声明索引？
- en: How are relations declared in Entity Framework Core?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Entity Framework Core中如何声明关系？
- en: What are the two important migration commands?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个重要的迁移命令是什么？
- en: By default, are related entities loaded by LINQ queries?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，LINQ查询是否加载相关实体？
- en: Is it possible to return database data in a class instance that isn't a database
    entity? If yes, how?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以在一个不是数据库实体的类实例中返回数据库数据？如果是，如何操作？
- en: How are migrations applied in production and staging?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移如何在生产环境和预览环境中应用？
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details about migrations commands can be found at [https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)
    and in the other links contained there.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于迁移命令的详细信息可以在[https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)和其他链接中找到。
- en: More details about Entity Framework Core can be found in the official Microsoft
    documentation: [https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Entity Framework Core的详细信息可以在官方Microsoft文档中找到：[https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/).
- en: An exhaustive set of examples of complex LINQ queries can be found here: [https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b.](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在这里找到复杂LINQ查询的详尽示例：[https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b.](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)
