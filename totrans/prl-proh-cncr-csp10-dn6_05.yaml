- en: '*Chapter 4*: User Interface Responsiveness and Threading'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main reasons to introduce threading concepts to a project is the
    desire to keep an application responsive to user input. Accessing data through
    services, a database, or the filesystem can introduce delays, and the **user interface**
    (**UI**) should remain responsive. The real-world examples in this chapter will
    provide valuable options for ensuring UI responsiveness in your .NET client applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging background threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the UI thread without exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how to take advantage of parallelism
    and concurrency to keep your client applications responsive and performant.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows users:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by discussing how background threads can be used to perform
    non-critical tasks without impacting UI performance.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging background threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18552_01_ePub.xhtml#_idTextAnchor014), we learned how to create
    background threads and discussed some of their uses. Background threads have a
    lower priority than the primary thread of the process and other thread pool threads.
    In addition, active background threads will not prevent the user or the system
    from terminating the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that background threads are perfect for tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing log and analytics data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring network or filesystem resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data into the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not use background threads for critical application operations such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Saving application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing database transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good rule to follow when deciding whether some work can be processed by a
    background thread is to ask yourself whether abruptly interrupting the work to
    close the application would risk the data integrity of the system. So, how do
    you know whether you are creating a background or foreground thread?
  prefs: []
  type: TYPE_NORMAL
- en: Which threads are background threads?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned that a thread can be explicitly created as a background thread
    by setting its `IsBackground` property to `true`. All other threads created by
    calling a `Thread` constructor are foreground threads by default. The application’s
    primary (or main) thread is a foreground thread. All `ThreadPool` threads are
    background threads. This includes all asynchronous operations started by the **Task
    Parallel Library** (**TPL**).
  prefs: []
  type: TYPE_NORMAL
- en: So, if all task-based operations such as `async` methods are executing on background
    threads, should you avoid using them for saving important application data? Will
    .NET allow your application to close while these `async` / `await` operations
    are in process? If there is a foreground thread awaiting an `async` operation,
    the application will not terminate until the operation is complete. If you do
    not use `await`, or you start an operation on the thread pool with `Task.Run`,
    it is possible for the application to terminate normally before the actions have
    finished.
  prefs: []
  type: TYPE_NORMAL
- en: The great thing about using `await` with your `async` methods is the flexibility
    you gain in controlling the flow of execution while keeping the UI responsive.
    Let’s discuss `async` and `await` in client applications and create an example
    of a **Windows Presentation Foundation** (**WPF**) application that loads data
    from multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: Using async, await, tasks, and WhenAll
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `async` and `await` in your code is the easiest way to introduce some
    background work using `ThreadPool`. An asynchronous method must be decorated with
    the `async` keyword and will return a `System.Threading.Tasks.Task` type instead
    of a `void` return.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Async` methods return `Task` so the calling method can await the result of
    the method. If you were to create an `async` method with a `void` return type,
    it could not be awaited, and the calling code would continue processing subsequent
    code before the `async` method had completed. It is important to note that only
    event handlers should be declared as `async` with a `void` return type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the method returns `string`, then the `async` equivalent will return a `Task<string>`
    generic type. Let’s look at examples of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you call an `async` method, there are two common patterns to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can await the call and set the return type to a variable of the
    type returned inside the method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second option is to use `Task` variables when invoking the methods and
    await them later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using this second method, the application can execute some synchronous work
    while the two `async` methods continue to run on background threads. Once the
    synchronous work is complete, the application will await the two `async` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put our `async` knowledge to work in a more realistic sample project.
    In this example, we will create a new Windows client application with `async`
    methods. We will simulate slow service calls to fetch the data in these methods
    by injecting non-blocking delays with `Task.Delay`. Each method will take several
    seconds to return its data, but the UI will remain responsive to user input:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new WPF project in Visual Studio. Name the project `AwaitWithWpf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add two new classes to the project named `Order` and `MainViewModel`. Your
    solution should now look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The AwaitWithWpf solution in Visual Studio ](img/Figure_4.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The AwaitWithWpf solution in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `MVVM Toolkit` on the `Microsoft.Toolkit.Mvvm` package to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project ](img/Figure_4.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Adding the Microsoft.Toolkit.Mvvm package to the project
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the `MainViewModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The MVVM Toolkit is an open source MVVM library that is part of the **Windows
    Community Toolkit** maintained by Microsoft. If you are unfamiliar with the MVVM
    pattern or the MVVM Toolkit, you can read more about them on Microsoft Docs: [https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction](https://docs.microsoft.com/windows/communitytoolkit/mvvm/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `Order` class and add the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will provide a few properties to display for each order when the order
    list is populated on `MainWindow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will start to build the `MainViewModel` implementation. The first step
    is to add a list of orders to bind to the UI and a command to execute when we
    want to load the orders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s review a few of the properties of the `MainViewModel` class before moving
    on to the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: The `MainViewModel` class inherits from the `ObservableObject` type provided
    by the MVVM Toolkit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This base class implements the `INotifyPropertyChanged` interface, which is
    used by WPF data binding to notify the UI when data-bound property values change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Orders` property will provide the list of orders to the UI through WPF
    data binding. Calling `SetProperty` on the `ObservableObject` base sets the value
    of the `_orders` backing variable and triggers a property change notification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LoadOrderDataCommand` property will be executed by a button on `MainWindow`.
    In the constructor, the property is being initialized as a new `AsyncRelayCommand`
    that calls `LoadOrderDataAsync` when the command is invoked by the UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don’t forget to add the necessary `using` statements to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s create two `async` methods to load order data. One will create
    current orders and the other will create a list of archived orders. These are
    differentiated by the `IsArchived` property on the `Order` class. Each method
    uses `Task.Delay` to simulate a service call across a slow internet or network
    connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create a synchronous `ProcessOrders` method that combines the
    two lists of orders and updates the `Orders` property with the full dataset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step in building the `MainViewModel` class is the most important.
    Add the following implementation to the `LoadOrderDataAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls `GetCurrentOrdersAsync` and `GetArchivedOrdersAsync` and captures
    each in a `Task<List<Order>>` variable. You could simply await each call and store
    the returned orders in `List<Order>` variables. However, that would mean the second
    method would not start executing until the first one completed. By awaiting `Task.WhenAll`
    instead, the methods can execute in parallel on background threads.
  prefs: []
  type: TYPE_NORMAL
- en: If your methods all return the same data type, you can capture the results of
    `Task.WhenAll` in an array of the return type. In our case, we are receiving the
    two lists of orders in an array of `List<Order>` and passing the two array values
    to `ProcessOrders`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s move on to the `MainWindow.xaml.cs` code-behind file. Add the following
    code to set `DataContext` of `MainWindow` in the constructor after the call to
    `InitializeComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`DataContext` is the source for all `Binding` references in the XAML for `MainWindow`.
    We will create the XAML for our UI in the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last file to update is `MainWindow.xaml`. Open the XAML file and start
    by adding two rows to `Grid`. The first row will contain another `Grid` containing
    `Button` and `TextBox`. The second row will contain `ListView` to display the
    list of orders. We’ll create a template for the orders in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: I have highlighted the two data binding instances in the XAML markup. The `Command`
    of `Button` is bound to the `LoadOrderDataCommand` property, and `ItemsSource`
    of `ListView` is bound to the `Orders` property. Setting `ItemsSource` will make
    the properties of the `Order` class available to the members of `ListView.ItemTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add `ItemTemplate` to `ListView` next. Defining `DataTemplate` within
    `ItemTemplate` defines the structure of each item within `ListView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each `Order` instance will render as a `StackPanel` containing three horizontally
    aligned `StackPanel` elements, displaying labels and values for the `OrderId`,
    `CustomerName`, and `IsArchived` data-bound properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re ready to run the application and see how things work. After the program
    starts, click the `ListView`. While you wait, try typing some text into the box
    to the right of the `async`/`await` and the `Task.WhenAll` method. Once the data
    has finished loading, you should see a list of twelve orders in the scrollable
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application ](img/Figure_4.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Viewing a list of orders in the AsyncWithWpf application
  prefs: []
  type: TYPE_NORMAL
- en: In a real production application, the implementations of the two `async` methods
    would be replaced by service calls to fetch data from a database or web services.
    Regardless of how long it takes to return and populate the data, other parts of
    the UI will remain responsive to user input. One change you would want to make
    is adding an indicator to the UI to inform the user that data is being loaded.
    You should also disable the `LoadOrderDataAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: The example illustrates the benefits of using `async` and `await` in a Windows
    application. These `async` calls are using `ThreadPool` within the TPL. Let’s
    look at some other ways to leverage `ThreadPool` in a Windows application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other ways to use `ThreadPool` threads in a .NET application. Let’s
    discuss a situation where you want to accomplish the same result that was achieved
    with `async` and `await` in the previous example, but the methods to fetch the
    order data are not marked as `async`. One option is to update the methods to be
    `async`. If that code is not within your control to change, you have some other
    options available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThreadPool` class has a method called `QueueUserWorkItem`. This method
    accepts a method to call and queues it for execution on the thread pool. We could
    use it with our project like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are a few problems with using this method. The primary issue is that there
    is no return value to get the list of orders from the method call. You could work
    around this issue with some wrapper methods that update a shared thread-safe collection
    such as the `BlockingCollection`. That isn’t a great design, and there is a better
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QueueUserWorkItem` method was more commonly used before the introduction
    of the TPL. In today’s task-based world, you can use `Task.Run` to execute a synchronous
    method as `async`. Let’s update our WPF project to use `Task.Run`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only file that needs to be modified to use `Task.Run` is `MainViewModel`.
    Start by updating `GetCurrentOrdersAsync` and `GetArchivedOrdersAsync` to no longer
    be `async` methods. They should also be renamed as `GetCurrentOrders` and `GetArchivedOrders`
    so consumers are aware that they are not `async` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The changes are minimal, and I have highlighted them in the preceding source
    code. The `async` modifier has been removed from the method declarations, the
    methods have been renamed and they no longer return tasks, and `Task.Delay` in
    each method has been updated to `Thread.Sleep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will update the `LoadOrderDataAsync` method to call the synchronous
    methods with `Task.Run`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No other changes are necessary. `Task.Run` will return the same `Task<List<Order>>`
    type, which can still be used with `Task.WhenAll` to wait for their completion.
  prefs: []
  type: TYPE_NORMAL
- en: Run the program, and it should work exactly as it did before. The UI remains
    responsive while the order data is loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is an excellent way to start incorporating `async` and `await` into existing
    code, but always use caution when adding threading to your applications. In this
    application, the two methods being called do not access any shared data. So, there
    was no need to think about thread safety. If these methods were updating a private
    collection of orders, you would need to introduce a locking mechanism or use a
    thread-safe collection for the orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to a discussion of the UI thread, there is one other `Task`
    method to discuss. The `Task.Factory.StartNew` method is similar in use to `Task.Run`.
    In fact, you can use them in the same way. This code uses `Task.Run` to get a
    `Task` with the current orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the same thing with `Task.Factory.StartNew`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you should use `Task.Run`. It is a newer method and is simply
    a shortcut meant to simplify the most common use cases. The `Task.Factory.StartNew`
    method has some additional overloads for specific uses. This example uses `StartNew`
    to call `GetCurrentOrders` with some optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting option we have provided here is `TaskCreationOptions.AttachedToParent`.
    What this does is it links the task completion of the calling method to that of
    the child, `GetCurrentOrders`. The default behavior is for their completions to
    be unlinked. For a complete list of available overloads and their uses, you can
    review Microsoft Docs here: [https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew](https://docs.microsoft.com/dotnet/api/system.threading.tasks.taskfactory.startnew).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Stephen Toub* of the .NET team has a blog post where he discusses `Task.Run`
    versus `Task.Factory.StartNew` and why you might want to choose each option. You
    can read his post on the *.NET Parallel Programming* blog here: [https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to discuss when you will need to write code to explicitly
    update the UI thread from a background thread.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the UI thread without exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with managed threading in .NET applications, there are many pitfalls
    that developers must learn to avoid. One of the common mistakes developers make
    is writing code that updates a UI control in a Windows application from a non-UI
    thread. This kind of error will not be detected by the compiler. Developers will
    receive a runtime error indicating that a control created on the main thread cannot
    be modified on another thread.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you avoid these runtime errors? The best way to avoid them is by
    not updating UI controls from background threads at all. WPF helps avoid the problem
    with the MVVM pattern and data binding. Binding updates are automatically marshaled
    to the UI thread by .NET. You can safely update properties in your `ViewModel`
    classes from a background thread without causing errors at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are updating UI controls directly in your code, either in a WinForms
    application or in the code-behind file of a WPF control, you can use an `Invoke`
    call to *push* the execution to the main thread. The implementation is slightly
    different between WinForms and WPF. Let’s start with a WPF example. If you have
    a method performing some work on a background thread, and it needs to update the
    `Text` property of a `TextBox` on a WPF window, you could wrap the code in an
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Dispatcher.Invoke` will push the execution to the main thread. Keep in mind
    that if the main thread is busy with other work, your background thread will wait
    here for this action to complete. If your background worker wants to fire and
    forget this action, you can use `Dispatcher.BeginInvoke` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we want to update `usernameTextBox`, but this time, we are working
    with a WinForms project. The same invocation can be accomplished by using `Form`
    or `UserControl` executing the code. This example is a WinForms application with
    two buttons. Clicking one button will call the `UpdateUsername` method. The other
    button will call `Task.Run(UpdateUsername)`, putting it on a background thread.
    To determine whether `Invoke` is needed to access the main thread, you check the
    Boolean `InvokeRequired` read-only property. It may not be required if the thread
    pool chose to run `Task` on the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `usernameTextBox` will display the name **John Doe** successfully regardless
    of which button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Updating a control on a WinForms form ](img/Figure_4.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Updating a control on a WinForms form
  prefs: []
  type: TYPE_NORMAL
- en: Like WPF, WinForms has a `BeginInvoke` method if the background code does not
    need to wait for the main thread update to complete. `BeginInvoke` can also accept
    an `EndInvoke` delegate that will receive a callback when the main thread invocation
    has completed.
  prefs: []
  type: TYPE_NORMAL
- en: This section provided a great start on using .NET managed threading in your
    Windows client applications. Let’s finish up with a summary of what we learned
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some useful techniques for improving client application
    performance. We started by exploring some different uses of `async` and `await`
    in the ViewModel of a WPF application. In that project, we saw that awaiting `Task.WhenAll`
    does not block the main thread, which keeps the UI responsive to user input. We
    discussed how `Task.Run` and `Task.Factory.StartNew` can be used to call synchronous
    code from asynchronous code, making it easier to introduce managed threading to
    existing applications. We finished up the chapter by learning some techniques
    to update the UI thread from other threads without causing exceptions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be feeling more comfortable using `async`, `await`, and the TPL
    in your code after reading this chapter. Try taking what you have learned here
    and start adding some `async` code to your own client applications. For additional
    reading on `async` and `await`, you can check out this C# article on Microsoft
    Docs: [https://docs.microsoft.com/dotnet/csharp/async](https://docs.microsoft.com/dotnet/csharp/async).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive even deeper into using `async`, `await`, and
    the TPL. We will take some of the concepts from this chapter and expand on them
    while introducing some best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type should every `async` method return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method can be used to await multiple tasks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method to start a new task accepts `TaskDispatcher` as one of the parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When calling an `async` method, what type of thread will execute the task?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method should be used in a WPF application when updating a user control
    from a background thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method should be used on a WinForms control to execute an action on the
    main thread but not wait for the method to complete?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In WinForms, how can you check whether calling `Invoke` is necessary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
