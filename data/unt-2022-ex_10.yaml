- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Polishing the Player’s Actions and Enemy Behavior
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛光玩家的动作和敌人行为
- en: In [*Chapter 6*](B18347_06.xhtml#_idTextAnchor116), we added a ranged weapon
    shooting mechanic in an optimized way using Unity’s new **object** **pooling**
    **API**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B18347_06.xhtml#_idTextAnchor116) 中，我们以优化的方式使用 Unity 的新 **对象** **池化**
    **API** 添加了远程武器射击机制。
- en: In this chapter, we will continue to add some much-needed polish to the player
    character with visual effects! We’ll also create some enemy **non-player character**
    (**NPC**) variants and finish up the chapter by introducing enemy behavior through
    a state pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续为玩家角色添加一些必要的视觉抛光，并使用视觉效果！我们还将创建一些敌人 **非玩家角色** (**NPC**) 变体，并通过状态模式介绍敌人行为，以结束本章。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Polishing with **Shader Graph** and **Trail Renderer**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Shader Graph** 和 **Trail Renderer** 进行抛光
- en: Enemy Prefabs and variants – Configuring with **Scriptable** **Objects** (**SOs**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人预制件和变体 – 使用 **可脚本化** **对象** (**SOs**) 进行配置
- en: Implementing basic enemy behavior using a **finite state** **machine** (**FSM**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **有限状态** **机** (**FSM**) 实现基本敌人行为
- en: By the end of this chapter, you’ll be able to quickly add some visual effect
    polish to the game’s sprites using a custom shader and make several enemy variants
    configured with varying properties and simple state-based behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够快速使用自定义着色器和后处理效果为游戏精灵添加一些视觉抛光，并制作具有不同属性和简单基于状态行为的几个敌人变体。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Download the assets from the following GitHub link to follow along in this chapter
    with the same artwork created for the project in the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下 GitHub 链接下载资产，以跟随本章中的相同艺术品，该艺术品是为书中项目创建的。
- en: To follow along with your own artwork, you’ll need to create similar artwork
    using Adobe Photoshop or a graphics program that can export layered Photoshop
    PSD/PSB files (e.g., Gimp, MediBang Paint, Krita, and Affinity Photo).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随自己的艺术品，你需要使用 Adobe Photoshop 或能够导出分层 Photoshop PSD/PSB 文件的图形程序（例如 Gimp、MediBang
    Paint、Krita 和 Affinity Photo）创建类似的艺术品。
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上下载完整项目：[https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)。
- en: Polishing with Shader Graph and Trail Renderer
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shader Graph 和 Trail Renderer 进行抛光
- en: To really sell the game experience to the player, we can employ some easy-to-execute
    visual polish. Thankfully, Unity provides visual effect features through some
    built-in components and includes relevant features as part of its render pipeline.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正向玩家推销游戏体验，我们可以采用一些易于执行的视觉抛光。幸运的是，Unity 通过一些内置组件提供视觉效果功能，并将其作为其渲染管道的一部分包含在内。
- en: Here, we’ll look at adding a few simple effects to the player, bullet projectile,
    and the overall visual look.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨为玩家、子弹弹道和整体视觉外观添加一些简单效果。
- en: Enabling post-processing
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用后处理
- en: 'To take advantage of any of the effects we’ll be implementing in this section,
    we’ll first want to enable **post-processing** as it applies to the **Universal
    RP** (**URP**) (reminder: this is the render pipeline we are working with).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用本节中我们将要实现的效果，我们首先需要启用 **后处理**，因为它适用于 **通用渲染管线** (**URP**)（提醒：这是我们正在工作的渲染管道）。
- en: Specifically, the effects we’ll be making will use **high dynamic range** (**HDR**)
    color values that will work with a post-processing bloom effect to make our 2D
    lights and parts of our sprite assets glow.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将制作的效果将使用 **高动态范围** (**HDR**) 颜色值，这些值将与后处理泛光效果一起工作，使我们的 2D 灯光和精灵资产的部分发光。
- en: HDR color | Unity documentation
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HDR 颜色 | Unity 文档
- en: HDR color values offer a wider range of luminosity than standard colors, resulting
    in more accurate depictions of color and brightness, more vibrant colors, improved
    support for bloom and glow effects, and reduced banding.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HDR 颜色值提供了比标准颜色更宽的亮度范围，从而实现了对颜色和亮度的更准确描述，更鲜艳的颜色，改进了对泛光和发光效果的支持，以及减少了带状效应。
- en: 'High dynamic range: [https://docs.unity3d.com/Manual/HDR.xhtml](https://docs.unity3d.com/Manual/HDR.xhtml)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 高动态范围：[https://docs.unity3d.com/Manual/HDR.xhtml](https://docs.unity3d.com/Manual/HDR.xhtml)
- en: For a look at what’s to come in the following sections, as seen in *Figure 7**.1*,
    we’ll apply **Vignette** to the screen and add **Bloom** to make the white parts
    of the bullet sprite glow (exaggerated for clarity).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看接下来章节中将要展示的内容，如图7.1所示，我们将对屏幕应用**渐晕**，并添加**辉光**以使子弹精灵的白色部分发光（为了清晰起见，进行了夸张处理）。
- en: 'Note that we can’t make the bullet glow with **Bloom** alone, so we’ll cover
    how to accomplish this, plus **Vignette**, in the following sections:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法仅使用**辉光**使子弹发光，因此我们将介绍如何实现这一点，以及**渐晕**，在接下来的章节中：
- en: '![Figure 7.1 – Post-processing effects applied to the scene](img/B18347_07_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 应用到场景的后期处理效果](img/B18347_07_1.jpg)'
- en: Figure 7.1 – Post-processing effects applied to the scene
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 应用到场景的后期处理效果
- en: A word of caution
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: Some post-processing effects are performance-heavy and are not suitable for
    all distribution platforms (mobile in particular), so pay attention to your **frames
    per second** (**FPS**) stats when adding new effects!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后期处理效果性能密集，并不适合所有分发平台（尤其是移动平台），因此在添加新效果时请注意您的**每秒帧数**（**FPS**）统计数据！
- en: 'To enable post-processing in our game, follow these steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏中启用后期处理，请按照以下步骤操作：
- en: For the camera in the current scene, select **Main Camera** in the **Hierarchy**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于当前场景中的相机，在**层次结构**中选择**主相机**。
- en: Under the **Rendering** section (refer to *Figure 7**.1*), enable **Post Processing**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**渲染**部分（参见图7.1），启用**后期处理**。
- en: For `Assets/Settings` folder and select the `UniversalRP` asset.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Assets/Settings`文件夹，选择`UniversalRP`资产。
- en: Under the **Quality** section, enable **HDR**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**质量**部分下，启用**HDR**。
- en: 'Now that we have post-processing enabled, we can start adding **volume overrides**
    that will work with the effects we’ll be adding to our objects. To do that, we’ll
    need to add a volume to our scene and add the volume overrides by following these
    steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启用了后期处理，我们可以开始添加**体积覆盖**，这些覆盖将与我们将添加到对象中的效果一起工作。为此，我们需要在我们的场景中添加一个体积，并按照以下步骤添加体积覆盖：
- en: From the **Scene Hierarchy**, use the **Create** menu and select **Volume**
    | **Global Volume**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**场景层次结构**中，使用**创建**菜单并选择**体积** | **全局体积**。
- en: With the `Global Volume` object still selected, in the Inspector, on the `Volume`
    component’s `Volume Profile` asset. This will create an asset file named `Global
    Volume Profile` in a subfolder with the same name as your scene.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Global Volume`对象的情况下，在检查器中，在`Volume`组件的`Volume Profile`资产上。这将在一个与场景同名的子文件夹中创建一个名为`Global
    Volume Profile`的资产文件。
- en: With a profile assigned, we now see a new **Add Override** button (refer to
    *Figure 7**.1*). Click it and select **Post Processing** | **Vignette**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配了配置文件后，我们现在可以看到一个新的**添加覆盖**按钮（参见图7.1）。点击它并选择**后期处理** | **渐晕**。
- en: Click the checkbox to the left of **Intensity** to enable it, then raise the
    value to see the *screen-edge-darkening* effect in both **Scene** and **Game**
    views.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**强度**左侧的复选框以启用它，然后提高数值以在**场景**和**游戏**视图中看到**屏幕边缘变暗**效果。
- en: Now, repeat adding another override, but this time select `1` – pixels in the
    scene with a brightness lower than this value will not have the effect applied
    by URP. The default value is `0.9` (which is great in most cases), but I’ve decided
    to give almost any object the potential to contribute glow to the overall look,
    so I raised it slightly.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重复添加另一个覆盖，但这次选择`1` – 场景中亮度低于此值的像素将不会应用URP的效果。默认值是`0.9`（在大多数情况下都很棒），但我决定几乎让任何对象都有可能为整体外观贡献发光效果，所以我稍微提高了它。
- en: Enable `1.15` to make things glow pretty good as an initial visual check, but
    I will be dialing this down later, I’m sure.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用`1.15`以使事物看起来发光，作为一个初始的视觉检查，但我肯定会在稍后降低这个值。
- en: Additional reading | Unity documentation
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Post-processing and full-screen effects: [https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 后期处理和全屏效果：[https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PostProcessingOverview.xhtml)
- en: 'Post-processing in the Universal Render Pipeline: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在通用渲染管线中的后期处理：[https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/integration-with-post-processing.xhtml)
- en: Now that things look more cinematic and have the potential to emit some cool
    glow effects, let’s finally set up our bullet Prefab sprite!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情看起来更电影化，并且有可能发出一些酷炫的光效，让我们最终设置我们的子弹Prefab精灵！
- en: Applying glow to the bullet with Shader Graph
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Shader Graph为子弹应用发光
- en: You previously saw how we added a secondary texture to a sprite when we added
    sprite Normal maps in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079) (for giving
    a pseudo-3D effect to sprites).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您之前看到我们如何在[*第4章*](B18347_04.xhtml#_idTextAnchor079)中为精灵添加二级纹理，当时我们添加了精灵法线图（为了给精灵提供伪3D效果）。
- en: We’ll now use a `1`, which will be possible by using an HDR color value).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用一个`1`，这将通过使用HDR颜色值来实现）。
- en: 'In *Figure 7**.2*, you can see the artwork for the bullet as well as the bullet’s
    **emission map** – a black-and-white image where the white areas define parts
    that will be emissive:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图7**.2中，您可以看到子弹的艺术作品以及子弹的**发射图**——一个黑白图像，其中白色区域定义了将发出光的部分：
- en: '![Figure 7.2 – Emission map for bullet sprite](img/B18347_07_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 子弹精灵的发射图](img/B18347_07_2.jpg)'
- en: Figure 7.2 – Emission map for bullet sprite
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 子弹精灵的发射图
- en: 'As you can see from the screenshot, we’ve created an emission map named `bullet1_emission`
    that represents only the swirly lines of the bullet sprite. Going back to the
    `bullet 1` sprite, select it so that we can add the emission map as a secondary
    texture by following these steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，我们创建了一个名为`bullet1_emission`的发射图，它仅代表子弹精灵的螺旋线条。回到`bullet 1`精灵，选择它，以便我们可以通过以下步骤将其作为二级纹理添加：
- en: In the sprite’s **Import Options** section in the Inspector, click the **Sprite**
    **Editor** button.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中精灵的**导入选项**部分，点击**精灵编辑器**按钮。
- en: Select **Secondary Textures** from the **Sprite Editor** drop-down menu (top-left
    corner of the window).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**精灵编辑器**下拉菜单中选择**二级纹理**（窗口的左上角）。
- en: In the **Secondary Texture** dialog, click the plus (**+**) button to add a
    new texture.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**二级纹理**对话框中，点击加号（**+**）按钮以添加新的纹理。
- en: Enter `_Emission` in the **Name** field.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中输入`_Emission`。
- en: Drag the **bullet1_emission** sprite from the **Project** window into the **Texture**
    field.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**bullet1_emission**精灵从**项目**窗口拖到**纹理**字段。
- en: Click the **Apply** button to save the changes (or simply close the window and
    choose **Save**).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**按钮以保存更改（或者简单地关闭窗口并选择**保存**）。
- en: As a refresher, you can refer to [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    *Figure 4**.2*, for an example of the **Secondary** **Texture** dialog.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，您可以参考[*第4章*](B18347_04.xhtml#_idTextAnchor079)，*图4**.2，以查看**二级****纹理**对话框的示例。
- en: With our sprite ready to go, we can move on to creating a new shader for applying
    our effect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的精灵准备就绪后，我们可以继续创建一个新的着色器来应用我们的效果。
- en: Creating a new Shader Graph 2D material
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的Shader Graph 2D材质
- en: Creating custom shaders used to be complicated by hand-coding them in a special
    shader language, but **Shader Graph** allows custom shaders to be authored visually
    in real time using a node-based system, making the process more accessible to
    artists and developers alike.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义着色器过去通常是通过手动在特殊的着色器语言中编码来变得复杂，但**Shader Graph**允许通过基于节点的系统实时以可视化的方式创建自定义着色器，使这个过程对艺术家和开发者都更加易于访问。
- en: We’ll use **Shader Graph** to create and connect nodes visually to build out
    our emission shader. Note that this shader can be the basis for any number of
    materials we can use to make different sprites with emission maps glow!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Shader Graph**来创建和连接节点，以可视化的方式构建我们的发射着色器。请注意，这个着色器可以成为我们制作不同带有发射图的精灵所需的任何数量材料的基石！
- en: Additional reading | Unity documentation
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 附加阅读 | Unity文档
- en: 'Getting started with Shader Graph: [https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml](https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Shader Graph入门：[https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml](https://docs.unity3d.com/Packages/com.unity.shadergraph%4014.0/manual/Getting-Started.xhtml)
- en: 'Let’s go ahead and create this glow shader now with the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建这个发光着色器：
- en: First, create a new `root` folder in the `Assets/Shaders`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Assets/Shaders`中创建一个新的`root`文件夹。
- en: Create a shader graph in the new folder by using the `SpriteEmission_Unlit`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中使用`SpriteEmission_Unlit`创建一个着色器图。
- en: Now, open the **Shader Editor** by clicking the **Open Shader Editor** button
    in the Inspector or double-clicking on the asset.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在检查器中点击**打开着色器编辑器**按钮或双击资产来打开**着色器编辑器**。
- en: 'The custom sprite shader we’re going to create is actually pretty simple and
    will only require a few nodes, as seen in the completed shader in the following
    screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的自定义精灵着色器实际上非常简单，只需要几个节点，如以下截图中的完成着色器所示：
- en: '![Figure 7.3 – Shader Graph sprite emission shader](img/B18347_07_3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 着色器图精灵发射着色器](img/B18347_07_3.jpg)'
- en: Figure 7.3 – Shader Graph sprite emission shader
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 着色器图精灵发射着色器
- en: 'Let’s construct this shader by following these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤构建这个着色器：
- en: 'First, starting in the **Blackboard** (*A* in *Figure 7**.3*) using the plus
    (**+**) button, add the following properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从**黑板**（图7.3中的*A*）使用加号（**+**）按钮添加以下属性：
- en: '`MainTex` and `_MainTex` (these fields are assigned in the **Graph Inspector**
    indicated by *B* in *Figure 7**.3*), then drag in the bullet sprite as the **Default**
    texture'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`主纹理` 和 `_MainTex`（这些字段在**图检器**中分配，如图7.3中的*B*所示），然后拖入子弹精灵作为**默认**纹理'
- en: Note that it is essential that **Reference** is spelled correctly since this
    is what the shader uses internally for the texture reference
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，**参考**的拼写必须正确，因为这是着色器内部用于纹理引用的部分
- en: '`Emission` and `_Emission` (note this is what we previously used as the name
    for the emission map secondary texture in the **Sprite Editor**), then drag in
    the **Bullet Emission Map** sprite as the **Default** texture'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`发射` 和 `_Emission`（注意这是我们之前在**精灵编辑器**中用作发射图次级纹理名称的部分），然后拖入**子弹发射图**作为**默认**纹理'
- en: '`Color` and `_Color`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`颜色` 和 `_Color`'
- en: These properties will be exposed in the Inspector so that we can assign values.
    `_MainTex` and `_Emission` will be obtained from the sprite.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性将在**检查器**中公开，以便我们可以分配值。`_MainTex`和`_Emission`将从精灵中获取。
- en: 'Next, create and connect the nodes that make up this simple shader:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建并连接构成这个简单着色器的节点：
- en: Right-click anywhere and select **Create Node** from the pop-up menu (or just
    press the spacebar).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击任何位置，从弹出菜单中选择**创建节点**（或者直接按空格键）。
- en: Start typing to search for the desired node to add. In our case, start typing
    `sample texture 2d` and select it from the list under **Input** | **Texture**.
    Let’s add two of these texture nodes – we’ll need one for **MainTex** and one
    for **Emission** (refer to *Figure 7**.3* as a reference).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始键入以搜索要添加的节点。在我们的例子中，开始键入`sample texture 2d`，并从**输入**|**纹理**下的列表中选择它。让我们添加两个这样的纹理节点——我们需要一个用于**主纹理**，一个用于**发射**（参考图7.3）。
- en: 'Let’s complete the **MainTex** path first. Create an **Add** node next and
    then make the following connections:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先完成**主纹理**路径。创建一个**加**节点，然后执行以下连接：
- en: '**MainTex(T2)** à **[SampleTexture2D] Texture(T2)** | **RGBA(4)** à **[Add]
    A(4)** | **Out(4)** à **[****Fragment] SpriteColor(4)**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**主纹理(T2)** à **[采样纹理2D] 纹理(T2)** | **RGBA(4)** à **[加] A(4)** | **输出(4)**
    à **[片段] 精灵颜色(4)**'
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A node is indicated as **[Node]**, connecting lines are shown by à (clicking
    and dragging on the little circles on the nodes), and input/output is displayed
    by | (input on the left side, output on the right side).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 节点表示为**[节点**]，连接线通过à（在节点上的小圆圈上点击和拖动）显示，输入/输出通过|（输入在左侧，输出在右侧）显示。
- en: 'Complete the **Emission** path next by using the second **SampleTexture2D**
    node we previously added. Create a **Multiply** node and make the following connections:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过使用我们之前添加的第二个**采样纹理2D**节点来完成**发射**路径。创建一个**乘**节点，并执行以下连接：
- en: '**Emission(T2)** à **[SampleTexture2D] Texture(T2)** | **R(1)** à **[Multiply]
    A(4)** | **Out(4)** à**[Add] A(4)**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**发射(T2)** à **[采样纹理2D] 纹理(T2)** | **R(1)** à **[乘] A(4)** | **输出(4)** à **[加]
    A(4)**'
- en: 'Finally, we’ll finish up the shader by connecting the **Color** property:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将通过连接**颜色**属性来完成着色器：
- en: '**Color(4)** à **[Multiply] B(4)** | **Out(4)** à **[****Add] B(4)**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色(4)** à **[乘] B(4)** | **输出(4)** à **[加] B(4)**'
- en: Downloading the completed shader graph
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成的着色器图
- en: 'For the completed sprite emission shader, visit the project GitHub repo here:
    [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完成的精灵发射着色器，请访问项目GitHub仓库：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Unity%20Project/Assets/Shaders)
- en: Before we can apply our fancy new emission shader to our bullet Prefab, we’ll
    have to create a new **material** based on this shader – that’s how it works.
    Rendering in Unity (and most digital content creation software) is performed with
    materials, shaders, and textures, each contributing their part to what the end
    user sees on screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够将我们花哨的新发射着色器应用到子弹预制件之前，我们必须基于这个着色器创建一个新的**材质** – 这就是它的运作方式。在Unity（以及大多数数字内容创建软件）中，渲染是通过材质、着色器和纹理来完成的，每个都为最终用户在屏幕上看到的图像贡献了它们的部分。
- en: Additional reading | Unity documentation
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: 'Graphics: [https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图形：[https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Graphics.xhtml)
- en: 'Create a new material based on this new shader graph we just created by right-clicking
    on the shader asset named `SpriteEmission_Unlit` in the `Assets/Shaders` folder
    of the **Project** window, then follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在**项目**窗口的`Assets/Shaders`文件夹中名为`SpriteEmission_Unlit`的着色器资产上右键单击，创建一个基于我们刚刚创建的新着色器图的材质，然后按照以下步骤操作：
- en: Go to `Bullet 1`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Bullet 1`。
- en: Then, create a new folder at `Assets/Materials` and move the material into that
    folder.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Assets/Materials`中创建一个新的文件夹，并将材质移动到该文件夹中。
- en: Assign the material to the bullet sprite by first opening the `Bullet 1` Prefab
    (either in the scene or in **Prefab Mode**).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先打开`Bullet 1`预制件（无论是在场景中还是在**预制件模式**中）来将材质分配给子弹精灵。
- en: With the bullet sprite visible in the scene view, drag the `Bullet 1` material
    from the **Project** window and onto the sprite. Unity provides a visual indicator
    for what the new material would look like if applied to the sprite before you
    commit to releasing the mouse button (a pretty neat trick; this also works the
    same for assigning materials to 3D objects).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景视图中，当子弹精灵可见时，从**项目**窗口拖动`Bullet 1`材质到精灵上。Unity在您释放鼠标按钮之前提供了一种视觉指示，以显示新材质应用于精灵后的外观（这是一个相当巧妙的技巧；这同样适用于将材质分配给3D对象）。
- en: 'Now, this is where the magic happens. Select the `bullet1` sprite in the **Hierarchy**
    to show its Inspector, expand the **Material** section at the bottom, and then
    click on the color picker (note that you should exit **Prefab Mode** because post-processing
    is not visible there). Then, do the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这里是魔法发生的地方。选择**层次**中的`bullet1`精灵以显示其检查器，展开底部的**材质**部分，然后点击颜色选择器（注意您应该退出**预制件模式**，因为在那里看不到后处理）。然后，执行以下操作：
- en: Set the **Color** field to an appropriate glow color and then kick up the **Intensity**
    value for the desired amount of glow (as seen in *Figure 7**.4*, but remember
    that the post-processing **Bloom** effect’s **Intensity** value is also at work
    here).
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**颜色**字段设置为适当的发光颜色，然后提高**强度**值以达到所需的发光量（如图*图7.4*所示，但请记住，后处理**光晕**效果的**强度**值也在这里起作用）。
- en: 'This is the final result of our efforts:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的最终成果：
- en: '![Figure 7.4 – Bullet material HDR color setting](img/B18347_07_4.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 子弹材质HDR颜色设置](img/B18347_07_4.jpg)'
- en: Figure 7.4 – Bullet material HDR color setting
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 子弹材质HDR颜色设置
- en: We are looking good – yay!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看起来不错 – 哈哈！
- en: Bonus activity
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励活动
- en: Add a material based on the **SpriteEmission_Unlit** shader for both the player
    character and weapon!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为玩家角色和武器添加基于**SpriteEmission_Unlit**着色器的材质！
- en: As you can see from our simple shader, it doesn’t take much effort to pump up
    the visuals of your games in Unity! For another quick win on the game’s visuals,
    let’s add a subtle light effect to the player character to make it pop out in
    the environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的简单着色器中看到的那样，在Unity中提升游戏视觉效果并不需要太多努力！为了在游戏视觉效果上取得另一个快速胜利，让我们为玩家角色添加一个微妙的光效，使其在环境中脱颖而出。
- en: Adding a 2D light to the player
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向玩家添加2D灯光
- en: This is a very quick and easy effect to add but with a huge payoff. All we’re
    going to do here is add a **2D light** as a child of **Player**. With the light
    parented to **Player** – and within the **Prefab** **Hierarchy** – it will be
    *attached* to the object.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常快速且简单的效果，但效果巨大。我们在这里要做的只是将**2D灯光**作为**玩家**的子对象添加。当灯光与**玩家**相关联，并且位于**预制件****层次**中时，它将被**附加**到对象上。
- en: 'Use these steps to add the light:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤添加灯光：
- en: Right-click on the root object of the `Player` Prefab in the scene.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中右键单击`Player`预制件的根对象。
- en: Working with Prefabs
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与预制件一起工作
- en: 'A reminder for working with Prefabs: if you add the **Light** object in **Prefab
    Mode** (by double-clicking on the Prefab in the **Project** window), you won’t
    be able to visualize changes to the light settings. You can, however, enter the
    **Prefab Isolation** mode in the scene by clicking the chevron icon (*>*) in the
    **Hierarchy** window and still be able to visualize changes. Lastly, you can modify
    the Prefab directly in the scene but just remember to apply **Overrides** to save
    changes to the Prefab.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用预制件的提醒：如果你在**预制模式**（通过在**项目**窗口中双击预制件）中添加**光**对象，你将无法可视化光设置的变化。然而，你可以通过在**场景**中点击**层次结构**窗口中的箭头图标（*>）进入**预制件隔离**模式，仍然能够可视化变化。最后，你可以在场景中直接修改预制件，但请记住应用**覆盖**以保存对预制件的更改。
- en: From the menu, select **Light** | **Spot** **Light 2D**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**光** | **聚光灯 2D**。
- en: 'Adjust the values to your liking. Referring to *Figure 7**.5*, these are the
    settings I used:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整到您喜欢的值。参考*图7**.5*，这是我使用的设置：
- en: Positioned the light on the chest of the character
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将灯光放置在角色的胸部
- en: '`0.6`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.6`'
- en: '`1.5` (*Inner*), `7` (*Outer*)'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.5`（*内*），`7`（*外*）'
- en: '`0.01` (just add a touch here for a small contribution to the environment lighting)'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.01`（在这里添加一点以对环境照明做出微小贡献）'
- en: '`3` (*Distance*)'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`（*距离*）'
- en: 'The before and after can be seen in *Figure 7**.5*. Notice how the player pops
    out of the environment on the right, whereas things look rather flat on the left:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前后对比可以在*图7**.5*中看到。注意玩家如何在右侧从环境中弹出，而左侧的东西看起来相当平坦：
- en: '![Figure 7.5 – Making the player pop out with a 2D light](img/B18347_07_5.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 使用2D光使玩家突出显示](img/B18347_07_5.jpg)'
- en: Figure 7.5 – Making the player pop out with a 2D light
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 使用2D光使玩家突出显示
- en: That was easy! Let’s gain another quick win with an additional visual effect
    that is simple to add!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！让我们通过添加一个简单易加的额外视觉效果来获得另一个快速胜利！
- en: Polishing is easy with Trail Renderer
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用尾迹渲染器进行抛光很容易
- en: The `Trail Renderer` component creates, well, a trail following a moving object.
    It’s a great way to add more impactful movement to things, and it can be as subtle
    or over the top as you wish by adjusting only a few settings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trail Renderer`组件创建了一个跟随移动对象的尾迹。这是一个为事物添加更多影响性移动的好方法，通过调整几个设置，它可以变得既微妙又夸张。'
- en: We’ll get right to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接进入正题。
- en: Adding a trail to Prefabs
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为预制件添加尾迹
- en: 'Follow these steps to add a trail to our bullet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为我们的子弹添加尾迹：
- en: Open the **Bullet 1** Prefab for editing.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Bullet 1**预制件进行编辑。
- en: Open the **Create** menu and add **Effects** | **Trail** (parented to the root
    as a sibling of the **bullet1** sprite).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**创建**菜单，添加**效果** | **尾迹**（作为**bullet1**精灵的兄弟添加到根节点）。
- en: 'Adjust the values to give a nice trailing effect! Here are the values I used
    as a starting point:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整值以获得良好的尾迹效果！以下是我用作起始点的值：
- en: '`(0.0, 0.2)`, `(0.5, 0.0)` – using this curve will ensure that the trail doesn’t
    extend to be too long'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0.0, 0.2)`, `(0.5, 0.0)` – 使用此曲线将确保尾迹不会延伸得太长'
- en: '`0.2`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.2`'
- en: '`35` to `0`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`35`到`0`'
- en: '`Package/Universal RP/Runtime/Materials`)'
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Package/Universal RP/Runtime/Materials`)'
- en: '**Lighting** = **Off** (cast shadows)'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**照明** = **关闭**（投射阴影）'
- en: 'These settings, and the results, can be seen in *Figure 7**.6*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置和结果可以在*图7**.6*中看到：
- en: '![Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab](img/B18347_07_6.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 在子弹预制件上可视化尾迹渲染器组件](img/B18347_07_6.jpg)'
- en: Figure 7.6 – Visualizing Trail Renderer component on bullet Prefab
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 在子弹预制件上可视化尾迹渲染器组件
- en: Don’t forget that you’ll also have to set the `Bullet 1` Prefab’s sprite renderer,
    the ground, and foreground/background sorting layers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记你还需要设置`Bullet 1`预制件的精灵渲染器、地面以及前景/背景排序层。
- en: Clearing trails for pooled Prefabs
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除池化预制件的尾迹
- en: The `Trail Renderer` component creates a trail of polygons behind the bullet
    GameObject (that’s how the trail is rendered), which will still be there even
    if the GameObject is deactivated in the scene.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Trail Renderer`组件在子弹GameObject后面创建了一个多边形尾迹（这就是尾迹渲染的方式），即使GameObject在场景中被停用，尾迹仍然存在。'
- en: 'That’s a problem for us because that’s exactly what we’re doing with object
    pooling: deactivating the GameObject projectile when it’s returned to the pool.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说是个问题，因为这正是我们使用对象池所做的事情：当GameObject项目返回池中时，将其停用。
- en: Fortunately, the `Trail Renderer` component provides a `Clear()` method for
    clearing the trail. All we need to do is call this method when we initialize the
    projectile, and voilà! Problem solved.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`Trail Renderer` 组件提供了一个 `Clear()` 方法来清除轨迹。我们只需要在初始化弹道时调用此方法，voilà！问题解决。
- en: 'Add the following code to the `ProjectileBase` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ProjectileBase` 类中：
- en: '[PRE0]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we’re simply using `TryGetComponent<TrailRenderer>()` to see if a `TrailRenderer`
    component has been added to the GameObject and only returning a reference to it,
    with an `out` parameter, if it exists. If the component does not exist, then an
    allocation will not be made, unlike with `GetComponent()`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用 `TryGetComponent<TrailRenderer>()` 来检查是否已将 `TrailRenderer` 组件添加到
    GameObject 中，并且只有在存在的情况下才返回其引用，使用 `out` 参数。如果组件不存在，则不会进行分配，这与 `GetComponent()`
    不同。
- en: We use an `if` statement to evaluate the `bool` return value from `TryGetComponent()`,
    so only if we have a `Trail Renderer` component on the projectile will the `Clear()`
    method be called (essentially, resetting it).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `if` 语句来评估 `TryGetComponent()` 的 `bool` 返回值，因此只有当弹道上有 `Trail Renderer`
    组件时，才会调用 `Clear()` 方法（本质上，重置它）。
- en: Additional reading | Unity documentation
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**Component.TryGetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Component.TryGetComponent**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Component.TryGetComponent.xhtml)'
- en: In this section, we learned how to enable post-processing and add effect overrides
    such as **Vignette** and **Bloom**, making our bullet glow and our player pop
    with light. We finished up with an easy-peasy trail effect on our bullet as well!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何启用后处理并添加如 **Vignette** 和 **Bloom** 这样的效果覆盖，使我们的子弹发光，玩家在光中脱颖而出。我们还完成了子弹上的简单轨迹效果！
- en: Next, we’ll add a configurable enemy character and variants of the same.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个可配置的敌人角色及其变体。
- en: Enemy Prefabs and variants – Configuring with SOs
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人预制件和变体 – 使用 SO 配置
- en: Instead of a GameObject that has to live in a scene, we can create a file-based
    asset that can be referenced from any GameObject, including Prefabs, anywhere
    in the game, called an SO.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是必须存在于场景中的 GameObject，我们可以创建一个基于文件的资产，可以从任何 GameObject（包括预制件）引用，任何游戏中的任何地方，称为
    SO。
- en: This being a single asset reference means no additional allocations are needed,
    and the same values are used no matter how many objects in the scene are spawned
    that reference it. Pretty cool!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个单个资产引用，因此不需要额外的分配，无论场景中有多少对象引用它，都使用相同的值。非常酷！
- en: An SO, as a small and efficient data container, also allows the separation of
    data from the code that consumes it. Data can be updated from backend cloud systems
    without recompiling the code or building a new distribution of the entire game.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SO（可脚本化对象）作为一个小型高效的数据容器，还允许将数据与其消耗数据的代码分离。数据可以从后端云系统中更新，而无需重新编译代码或构建整个游戏的新版本。
- en: Being able to respond to data changes for games in production – where an issue
    affecting players may need to be solved quickly – is an excellent application
    of SOs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 能够对生产中的游戏数据进行响应 – 在玩家可能需要快速解决问题的场合 – 是 SO 的一个优秀应用。
- en: Others have used SOs for middleware components and even fully decoupled event
    systems that are designer-friendly because they allow configuration at design
    time in the Editor (that is, a developer is not required to wire up new events
    between objects, and so on).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他开发者已经使用 SO 用于中间件组件，甚至完全解耦的事件系统，这些系统对设计师友好，因为它们允许在编辑器中设计时进行配置（也就是说，开发者不需要在对象之间连接新事件等）。
- en: Unity has also built complete game architecture based on SOs in its *Open Projects*
    development program. And there would be something amiss if I didn’t mention Ryan
    Hipple’s (Schell Games) now infamous *Game Architecture with Scriptable Objects*
    talk at Unite Austin 2017 (link provided in the *Additional material – Unity documentation*
    callout box), where he describes how SOs can be used for building more extensible
    systems and data patterns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还在其 *Open Projects* 开发计划中基于 SO 构建了完整的游戏架构。而且，如果不提一下 Ryan Hipple（Schell
    Games）在 2017 年 Unite Austin 上现在臭名昭著的 *使用 Scriptable Objects 构建游戏架构* 讲座，那就有些不完整了（在
    *额外材料 – Unity 文档* 提示框中提供了链接），他在讲座中描述了如何使用 SO 构建更可扩展的系统和数据模式。
- en: Additional material | Unity documentation
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 额外材料 | Unity 文档
- en: 'ScriptableObject: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptableObject：[https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ScriptableObject.xhtml)
- en: 'Open Projects: [https://unity.com/open-projects](https://unity.com/open-projects)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 打开项目：[https://unity.com/open-projects](https://unity.com/open-projects)
- en: 'Unite Austin 2017 - Game Architecture with Scriptable Objects: [https://youtu.be/raQ3iHhE_Kk](https://youtu.be/raQ3iHhE_Kk)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Unite Austin 2017 - 使用Scriptable Objects进行游戏架构：[https://youtu.be/raQ3iHhE_Kk](https://youtu.be/raQ3iHhE_Kk)
- en: With that bit of introduction out of the way, we’ll go on now to create our
    first SO and use it to configure the traits of our enemies.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分介绍完成之后，我们将继续创建我们的第一个SO并使用它来配置敌人的特性。
- en: Creating an enemy Prefab with configurations
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建具有配置的敌人Prefab
- en: 'An SO is created in a similar way to a `MonoBehaviour` script with some exceptions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与`MonoBehaviour`脚本类似，SO的创建方式有一些例外：
- en: The SO must inherit from `ScriptableObject` instead of `MonoBehaviour`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SO必须继承自`ScriptableObject`而不是`MonoBehaviour`。
- en: It cannot be attached to a GameObject (as a component). Instead, it is saved
    as a file asset and referenced by components as a field exposed in the Inspector.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能附加到GameObject（作为组件）。相反，它作为文件资产保存，并由组件作为在检查器中公开的字段引用。
- en: It does not receive all of the same Unity message events that a `MonoBehaviour`
    script does (missing, most notably, are `Start()`, `Update()`, and `FixedUpdate()`).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会接收到与`MonoBehaviour`脚本相同的所有Unity消息事件（最明显的是缺少`Start()`、`Update()`和`FixedUpdate()`）。
- en: It can create new custom assets based on the `ScriptableObject` class by using
    `CreateAssetMenu`. In contrast, `MonoBehaviour` can only be configured in the
    scene and saved as a Prefab (it can then be edited in the **Prefab Mode**).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过使用`CreateAssetMenu`创建基于`ScriptableObject`类的新自定义资产。相比之下，`MonoBehaviour`只能在场景中进行配置并保存为Prefab（然后可以在**Prefab模式**中编辑）。
- en: 'The *script template* for a new enemy configuration data SO asset would look
    like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 新的敌人配置数据SO资产的**脚本模板**看起来像这样：
- en: '[PRE1]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see the `[CreateAssetMenu()]` attribute that will create a new
    menu entry in the Editor to facilitate making new file assets based on this `EnemyConfigData`
    SO.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到`[CreateAssetMenu()]`属性，它将在编辑器中创建一个新的菜单项，以便基于此`EnemyConfigData` SO创建新的文件资产。
- en: 'Going to the **Project** window and selecting **Create** | **ScriptableObjects**
    | **EnemyConfigData**, we can create multiple enemy configuration assets:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**项目**窗口并选择**创建** | **ScriptableObjects** | **EnemyConfigData**，我们可以创建多个敌人配置资产：
- en: '![Figure 7.7 – Create ScriptableObjects asset menu](img/B18347_07_7.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 – 创建ScriptableObjects资产菜单](img/B18347_07_7.jpg)'
- en: Figure 7.7 – Create ScriptableObjects asset menu
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 创建ScriptableObjects资产菜单
- en: The member fields declared for `Speed`, `AttackRange`, `FireRange`, and so on
    provide configurable data for different types of enemies. There aren’t any currently
    defined in the previous code, but you can also create methods (for encapsulating
    fields, returning calculations, helper methods, and ticks as examples).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的`Speed`、`AttackRange`、`FireRange`等成员字段为不同类型的敌人提供了可配置的数据。在之前的代码中尚未定义，但您也可以创建方法（例如封装字段、返回计算、辅助方法和计时器）。
- en: Create a new script named `EnemyConfigData` in a new `Assets/Scripts/Data` folder
    using the preceding `ScriptableObject` template.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`Assets/Scripts/Data`文件夹中使用前面的`ScriptableObject`模板创建一个名为`EnemyConfigData`的新脚本。
- en: Regarding the adventure game, and referring to our **Game Design Document**
    (**GDD**) in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), *Table 4.3*, we’ll
    introduce two kinds of enemy characters (including the dull and uninteresting
    *maintenance robot*).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于冒险游戏，并参考我们的**游戏设计文档**（**GDD**）中的[*第4章*](B18347_04.xhtml#_idTextAnchor079)，*表4.3*，我们将介绍两种敌人角色（包括无聊且无趣的*维护机器人*）。
- en: 'Go ahead and create two enemy configuration data assets named `Enemy A Config`
    and `Enemy B Config` in a new `Assets/Data` folder with some default values assigned
    to give each robot unique characteristics, as seen in the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`Assets/Data`文件夹中创建两个名为`Enemy A Config`和`Enemy B Config`的敌人配置数据资产，并分配一些默认值，以赋予每个机器人独特的特征，如下面的截图所示：
- en: '![Figure 7.8 – Multiple assets for enemy configurations](img/B18347_07_8.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8 – 敌人配置的多个资产](img/B18347_07_8.jpg)'
- en: Figure 7.8 – Multiple assets for enemy configurations
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 敌人配置的多个资产
- en: As you can also conclude from the preceding screenshot, the evil alien plant
    entity has had its way with the maintenance robots, which are now under its control!
    No – not that exactly, but I’ve already imported and set up the enemy actors we’ll
    be applying the configuration data to.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从前面的截图中得出结论，邪恶的外星植物实体已经控制了维护机器人，它们现在处于其控制之下！不，不是那个确切的意思，但我已经导入并设置了我们将应用配置数据的敌人演员。
- en: The process to import, rig, create a Prefab, add **inverse kinematics**(**IK**),
    and then add animation is the same workflow we performed for the player character.
    To revisit this workflow, return to the *Setting up the player character with
    PSD Importer* section of [*Chapter 5*](B18347_05.xhtml#_idTextAnchor096).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 导入、绑定、创建预制件、添加**逆运动学**（**IK**）以及添加动画的过程与我们为玩家角色执行的工作流程相同。要回顾此工作流程，请返回到[*第5章*](B18347_05.xhtml#_idTextAnchor096)中的*使用PSD导入器设置玩家角色*部分。
- en: Go ahead and create Prefabs of the two enemies – **Enemy A** and **Enemy B**
    – using the artwork provided in the GitHub project repo; create your own, or cheat
    and download the already completed enemy Prefabs from the project repo (preferably,
    don’t choose this last option, as you’ll need the practice).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请创建两个敌人的预制件 – **Enemy A**和**Enemy B** – 使用GitHub项目仓库中提供的美工；创建自己的，或者作弊并从项目仓库中下载已经完成的敌人预制件（最好不选择最后一个选项，因为您需要练习）。
- en: Adventure game 2D art assets
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险游戏2D艺术资产
- en: 'To follow along in this chapter, download the art assets from the project GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，请从以下项目GitHub仓库下载艺术资产：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch5/Art-Assets)
- en: 'Whew! Now that we have enemy Prefabs, we can add a component that will utilize
    the enemy configuration data. Create a new script named `EnemyController` in the
    `Assets/Scripts` folder – note that we’re back to creating a `MonoBehaviour` script
    now:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！现在我们有了敌人预制件，我们可以添加一个将利用敌人配置数据的组件。在`Assets/Scripts`文件夹中创建一个新的名为`EnemyController`的脚本
    – 注意我们现在又回到了创建`MonoBehaviour`脚本：
- en: '[PRE2]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By now, this simple script should make a lot of sense to you. We added a field
    declaration named `_config` and of the type `EnemyConfigData`. We gave it an explicit
    protection keyword of `private` for the accessor so that no other script can reach
    it but added the `[SerializeField]` attribute so that we can make an assignment
    in the Inspector.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这个简单的脚本应该对您来说已经很有意义了。我们添加了一个名为`_config`的字段声明，类型为`EnemyConfigData`。我们为访问器提供了一个显式的保护关键字`private`，以便没有其他脚本可以访问它，但添加了`[SerializeField]`属性，这样我们就可以在检查器中进行赋值。
- en: 'To achieve the configuration in the following screenshot, drag the `EnemyConfigData`
    script to the `Enemy B` Prefab (on the root object), then drag the `Enemy B Config
    ScriptableObject` asset in the `Assets/Data` folder to the `EnemyController` component.
    We’ve just added variable configuration data to our enemy! Repeat for `Enemy A`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现以下截图中的配置，请将`EnemyConfigData`脚本拖动到`Enemy B`预制件（在根对象上），然后将`Assets/Data`文件夹中的`Enemy
    B Config ScriptableObject`资产拖动到`EnemyController`组件。我们刚刚为我们的敌人添加了变量配置数据！对`Enemy
    A`重复此操作：
- en: '![Figure 7.9 – Enemy B configuration](img/B18347_07_9.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图7.9 – **Enemy B**配置](img/B18347_07_9.jpg)'
- en: Figure 7.9 – Enemy B configuration
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – **Enemy B**配置
- en: To quickly access the `ScriptableObject` asset for editing the values, double-click
    on the `ScriptableObject` asset reference assigned to the **Config** field. Alternatively,
    you can open a **Focused Inspector** by right-clicking on the asset in the **Project**
    window and selecting **Properties**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速访问用于编辑值的`ScriptableObject`资产，请双击分配给**Config**字段的`ScriptableObject`资产引用。或者，您可以通过在**项目**窗口中右键单击资产并选择**属性**来打开**聚焦检查器**。
- en: This way, you can view and edit the data without the Inspector changing to other
    selected objects/assets as you work (an example of this can be seen in *Figure
    7**.8* with both of the enemy configurations open).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以在工作时不改变检查器到其他选定的对象/资产的情况下查看和编辑数据（这种例子可以在*图7.8*中看到，其中两个敌人配置都打开了）。
- en: Opening a **Focused Inspector** is also an alternative to locking the Inspector
    to a single object, which you can do by clicking the little lock icon at the top
    right of the **Inspector** window (as shown in *Figure 7**.9*).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**聚焦检查器**也是锁定检查器到单个对象的另一种方法，您可以通过点击**检查器**窗口右上角的锁形图标来实现（如图7.9所示）。
- en: Now that we have our enemy characters, let’s see how to easily add some variation
    by extending upon these base Prefabs with Prefab Variants!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了敌人角色，让我们看看如何通过扩展这些基础预制体来使用预制体变体轻松添加一些变化！
- en: Creating an enemy variant for alternate enemy types
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用于替代敌人类型的敌人变体
- en: When Unity finally added native support for **Nested Prefabs** (circa Unity
    2018.3), it also included a great new feature called **Prefab Variants**, which
    are extremely useful for having a unique set of variations that are all based
    on the same basic Prefab properties.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Unity 最终添加了对 **嵌套预制体**（大约在 Unity 2018.3）的原生支持时，它还包含了一个名为 **预制体变体** 的出色新功能，这对于拥有基于相同基本预制体属性的唯一变体集非常有用。
- en: A base Prefab will have all the basic behaviors required by the object, and
    then several variations can be created that override properties to make changes
    to the behavior or appearance of the object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 基础预制体将包含对象所需的所有基本行为，然后可以创建几个变体来覆盖属性，以改变对象的行为或外观。
- en: In our case, using an enemy Prefab as an example, assigning a unique set of
    configuration values through an `EnemyConfigData` asset overrides the base Prefab.
    This may also include changes in color, artwork, or components.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，以敌人预制体为例，通过 `EnemyConfigData` 资产分配一组独特的配置值覆盖了基础预制体。这还可能包括颜色、艺术品或组件的变化。
- en: We accomplish varying the configuration data by creating additional `EnemyConfigData`
    assets for each of the different enemy characteristics we’re looking to have in
    the game.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为游戏中想要拥有的不同敌人特性创建额外的 `EnemyConfigData` 资产来改变配置数据。
- en: Additional reading | Unity documentation
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '*Prefab* *Variants*: [https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*预制体变体*: [https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/PrefabVariants.xhtml)'
- en: Creating a Prefab Variant
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制体变体
- en: Let’s create a variation of the `Enemy B` Prefab with an increased difficulty
    level for the player by making it move faster, shoot further, and have a quicker
    rate of fire by shortening the cooldown period.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使其移动更快、射击更远以及通过缩短冷却时间来提高射速，为玩家创建一个 `Enemy B` 预制体的变体，以增加难度级别。
- en: 'To do that, let’s take these steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们按照以下步骤操作：
- en: 'First, we’ll duplicate the `Enemy B Config EnemyConfigData` asset file in the
    `Assets/Data` folder:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 `Assets/Data` 文件夹中的 `Enemy B Config EnemyConfigData` 资产文件进行复制：
- en: Click on the `Enemy B Config` asset in the `Enemy B` `Config Difficult`.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Enemy B Config` 资产在 `Enemy B` 的 `Config Difficult` 中。
- en: On the new asset, adjust the values for `70`, `60`, and `60`, respectively).
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新资产上，分别调整 `70`、`60` 和 `60` 的值）。
- en: Now, change to the `Assets/Prefabs` folder.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `Assets/Prefabs` 文件夹。
- en: Right-click on the `Enemy B` Prefab, then select `Enemy` `B Difficult`.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Enemy B` 预制体，然后选择 `Enemy B Difficult`。
- en: With the new variant selected and the `Assets/Data` folder and drag the `Enemy
    B Config Difficult` asset to the `EnemyController` component.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择新变体并处于 `Assets/Data` 文件夹中时，将 `Enemy B Config Difficult` 资产拖动到 `EnemyController`
    组件。
- en: We now have an `Enemy B` Prefab with different SO configuration data assigned
    to it, but the remainder of the enemy object is exactly the same since we only
    overrode the field assignment.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `Enemy B` 预制体，分配了不同的 SO 配置数据，但由于我们只覆盖了字段分配，所以敌人对象的其余部分完全相同。
- en: '*Figure 7**.10* shows what our new enemy Prefab variant looks like in the Editor
    with the difficult enemy configuration SO data assigned: *A* is the difficult
    enemy Prefab, *B* shows that this Prefab has a `Base` Prefab it is a variant of,
    and *C* shows the SO **Config** field assignment override:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7.10* 展示了在编辑器中分配了困难敌人配置 SO 数据后我们的新敌人预制体变体看起来像什么：*A* 是困难敌人预制体，*B* 显示这个预制体有一个
    `Base` 预制体，它是其变体，*C* 显示 SO **配置** 字段的重写分配：'
- en: '![Figure 7.10 – Difficult Enemy B Prefab Variant setup](img/B18347_07_10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 困难敌人 B 预制体变体设置](img/B18347_07_10.jpg)'
- en: Figure 7.10 – Difficult Enemy B Prefab Variant setup
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 困难敌人 B 预制体变体设置
- en: We can repeat this process for creating different types of enemies or any other
    type of Prefab that we’ll use in the game. Think about maybe having the maintenance
    robots start the game without any plant infestation and then gradually build up
    the infestation as the game progresses. We can use Prefab Variants for the different
    stages by simply overriding the art assets. Prefab Variants can make progressive
    changes to art easy to achieve!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复此过程来创建不同类型的敌人或任何其他类型的Prefab，我们将在游戏中使用。想想看，维护机器人可能开始游戏时没有任何植物侵害，然后随着游戏的进行逐渐建立侵害。我们可以通过简单地覆盖艺术资产来使用Prefab变体实现不同阶段的变化。Prefab变体可以使艺术上的渐进式变化变得容易实现！
- en: By using the SO to override the configuration data, we have separated the data
    from the Prefab asset (including various components, art assets, sound, effects,
    and so on). The SO data is a small object that can be updated outside of having
    to edit the Prefab, which makes things more accessible to designers and non-programmers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用SO来覆盖配置数据，我们将数据与Prefab资产（包括各种组件、艺术资产、声音、效果等）分离。SO数据是一个小的对象，可以在不编辑Prefab的情况下进行更新，这使得设计师和非程序员更容易访问。
- en: Also, if only the data needs to change, then it’s a tiny update that can be
    pushed to games in production without having to push the entire Prefab asset.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果只有数据需要更改，那么这只是一个微小的更新，可以在不推送整个Prefab资产的情况下推送到正在生产的游戏中。
- en: From this section, having a set of enemies with unique variations is great,
    but it would be even better if they had some behavior based on their configuration
    data!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，拥有一组具有独特变化的敌人很好，但如果它们基于其配置数据具有一些行为那就更好了！
- en: The next section will look at adding behavior to the enemy robots.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨为敌人机器人添加行为。
- en: Implementing basic enemy behavior using an FSM
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FSM实现基本敌人行为
- en: In [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), we briefly introduced the
    State Pattern, so we’ll now look at how to implement this design pattern for keeping
    the state of our enemy characters. Expressly, using an FSM, we can declare the
    fixed set of states (that is, finite) our enemy can be in at any given time –
    and the FSM is only going to do precisely these things.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18347_02.xhtml#_idTextAnchor041)中，我们简要介绍了状态模式，因此现在我们将探讨如何实现此设计模式以保持我们敌人角色的状态。具体来说，使用FSM，我们可以声明敌人可以在任何给定时间处于的固定状态集（即有限）——FSM只会做这些事情。
- en: The first implementation of our FSM will not adhere to SOLID principles very
    well, but it will hopefully be a simple enough introduction that will make sense
    practically. We can also use it as an example to point out any flaws with the
    approach and later refactor it to something better.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们FSM的第一个实现可能不太符合SOLID原则，但它希望足够简单，以便在实践中有意义。我们还可以将其用作一个例子，指出该方法中的任何缺陷，并在以后将其重构为更好的东西。
- en: I should note that maybe we won’t refactor it later… sometimes a simple approach
    is all that is required, and refactoring for the sake of refactoring is just wasted
    effort where that time could be better spent on tightening up the core game mechanic
    instead, for example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，也许我们以后不会重构它……有时候，简单的方法就足够了，仅仅为了重构而重构只是浪费了本可以更好地用于加强核心游戏机制的时间，例如。
- en: Additional reading | Programming patterns
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | 编程模式
- en: 'Finite state machine explained: [https://www.freecodecamp.org/news/finite-state-machines/](https://www.freecodecamp.org/news/finite-state-machines/)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机解释：[https://www.freecodecamp.org/news/finite-state-machines/](https://www.freecodecamp.org/news/finite-state-machines/)
- en: Let’s start by having a look at which states – or behaviors – we want for our
    enemy characters.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们希望我们的敌人角色具有哪些状态或行为。
- en: State Model
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模型
- en: 'Referring back to our GDD in [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079),
    *Table 4.1*, where we loosely defined the behaviors of our enemy during engagement
    with the player, we can derive the following minimum states being required: **Idle**,
    **Patrol**, **Attack**, **Dead**.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的GDD在[*第4章*](B18347_04.xhtml#_idTextAnchor079)中的*表4.1*，其中我们大致定义了敌人与玩家交战时的行为，我们可以推导出以下所需的最小状态：**空闲**、**巡逻**、**攻击**、**死亡**。
- en: 'Now, we can take those states and design a UML state diagram for our enemy
    behaviors. Conditions for determining when to change between the states are also
    defined:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设计一个UML状态图来表示我们的敌人行为。确定何时在状态之间切换的条件也定义了：
- en: '![Figure 7.11 – Enemy behavior State Model](img/B18347_07_11.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 敌人行为状态模型](img/B18347_07_11.jpg)'
- en: Figure 7.11 – Enemy behavior State Model
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 敌人行为状态模型
- en: 'Referring to the diagram and using the conditions to determine when to transition
    from one state to another, we can observe the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图示并使用条件来确定何时从一个状态转换到另一个状态，我们可以观察到以下情况：
- en: The default starting state is **Idle**
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的起始状态是**空闲**
- en: While in the **Idle** state, we will transition to **Patrol** when a timer expires
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**空闲**状态时，当计时器到期时，我们将转换到**巡逻**状态
- en: While in the **Patrol** state, we will transition back to **Idle** when a timer
    expires (for example, **Idle** --> **Patrol** --> **Idle** --> **Patrol**)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**巡逻**状态时，当计时器到期时，我们将返回到**空闲**状态（例如，**空闲** --> **巡逻** --> **空闲** --> **巡逻**）
- en: While in the **Idle** or **Patrol** state, we will transition to **Attack**
    when the player is in range
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**空闲**或**巡逻**状态时，当玩家在范围内时，我们将转换到**攻击**状态
- en: While in the **Attack** state, we will go back to **Patrol** when the player
    moves out of range
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当处于**攻击**状态时，当玩家移出范围时，我们将返回到**巡逻**状态
- en: We will transition from any state to **Dead** when health is zero
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当健康值为零时，我们将从任何状态转换到**死亡**状态
- en: Now that we know which states we need and which conditions change state, we
    can move on to coding up this thing!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了需要哪些状态以及哪些条件会改变状态，我们可以继续编写这个状态机了！
- en: A simple FSM pattern
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的状态机模式
- en: We’ll make our first FSM using enums for defining our finite states and code
    the state-changing logic within the `EnemyController` class. This code is similar
    to what you’ll likely run across in projects for beginners because it’s easy to
    understand and simple to work with (and, as mentioned previously, may be all that
    is required).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用枚举来定义我们的有限状态，并在`EnemyController`类中编写状态转换逻辑，以创建我们的第一个状态机。这段代码与你在初学者项目中可能遇到的内容类似，因为它易于理解且易于操作（如前所述，可能只需这些）。
- en: But it does have some limitations and drawbacks. The first one is that the state
    machine is integral to the `EnemyController` class, violating the **Single Responsibility**
    **Principle** (**SRP**).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但它确实有一些限制和缺点。第一个是状态机是`EnemyController`类的一部分，违反了**单一职责原则**（**SRP**）。
- en: 'Let’s have a look:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看：
- en: '[PRE3]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, we have defined the FSM states from our State Model in the `public
    enum State {}` declaration line. Our FSM can only be in one of these defined states.
    Then, we’ll use the `_currentState` variable to keep track of our current state.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在`public enum State {}`声明行中定义了我们的状态机状态。我们的状态机只能处于这些定义的状态之一。然后，我们将使用`_currentState`变量来跟踪我们的当前状态。
- en: Let’s skip down to the `ChangeState()` method, where we can see we’ll call it
    by passing in a `State` to set it as the current state of the FSM (that is, transition
    to a different state). In `Start()`, you can see how we call `ChangeState(State.Idle)`
    to set our initial (default) state for **Enemy** to **Idle**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到`ChangeState()`方法，在那里我们可以看到我们将通过传递一个`State`来调用它，将其设置为状态机的当前状态（即转换到不同的状态）。在`Start()`中，你可以看到我们如何调用`ChangeState(State.Idle)`来设置**敌人**的初始（默认）状态为**空闲**。
- en: Lastly, in the `Update()` method (called every frame update), we have a `switch`
    statement that has an implementation for each state declared in the `State` enum.
    When `_currentState` is equal to one of the defined enum states, we *do stuff*
    – you can relate the `switch` statement to a block of `if`, `else if`, `else if`
    statements (but it’s undoubtedly more readable for when we don’t need to test
    expressions for ranges of values or conditions).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`Update()`方法（每帧更新时调用）中，有一个`switch`语句，为`State`枚举中声明的每个状态都有一个实现。当`_currentState`等于定义的枚举状态之一时，我们将执行一些操作——你可以将`switch`语句与一系列的`if`、`else
    if`、`else if`语句相关联（但当我们不需要测试值范围或条件时，它无疑更易于阅读）。
- en: switch (C#)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: switch (C#)
- en: A **switch** statement is a *selection control* statement that tests an expression
    (similar to an **if** statement) and executes the matching block of code defined
    by the cases (and as terminated by the **break** statement). A default case can
    be defined if there is no match for the expression.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**switch**语句是一种**选择控制**语句，它测试一个表达式（类似于**if**语句）并执行由cases定义的匹配代码块（并由**break**语句终止）。如果没有匹配的表达式，可以定义一个默认情况。'
- en: I don’t necessarily have a problem with this oversimplified approach to a State
    Pattern, but the `switch` statement quickly gets ugly. With many states, it can
    start getting hard to manage, as we’ll see when we start adding conditions and
    behaviors to it, but at least it doesn’t rely on an arbitrary number of Boolean
    variables to attempt and maintain some form of state (and without having to wrangle
    two of those variables becoming true simultaneously – yikes!).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不一定反对这种对状态模式过于简化的方法，但`switch`语句很快就会变得丑陋。随着状态的增多，它可能会变得难以管理，正如我们开始向其中添加条件和行为时将会看到的那样，但至少它不依赖于任意数量的布尔变量来尝试并维护某种形式的状态（而且不需要同时处理两个变量变为真——天哪！）。
- en: One problem with the enum-based approach that breaks the *O* in SOLID (`EnemyController`
    class (that is, closed for modification). Preferably, we’d like only to change
    the affected state’s code and not touch anything else!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 基于枚举的方法有一个问题，它破坏了SOLID原则中的*O*（`EnemyController`类，即对修改封闭）。我们更希望只更改受影响状态的代码，而不触及其他任何东西！
- en: Code that functions and has nothing to do with the state should not have to
    be retested (for example, acceptance and regression testing) or, in a team environment,
    even be code reviewed while committing the modification for the state to the **version
    control** **system** (**VCS**).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与状态无关的功能代码不需要重新测试（例如，验收和回归测试），或者在团队环境中，甚至在将状态修改提交到**版本控制系统**（VCS）时也不需要进行代码审查。
- en: At the very least, this enum-based approach provides a structure that makes
    the code more readable than without it, and it’s simple to include the State Pattern
    without first having to write boilerplate code for the state machine.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，这种基于枚举的方法提供了一个结构，使得代码比没有它时更易于阅读，并且在不首先编写状态机的样板代码的情况下，很容易包含状态模式。
- en: You may be able to imagine how we could extend this State Pattern by encapsulating
    all of a particular state’s behaviors (and data) into a single class. If so, great!
    If not, no worries, since we’ll tackle refactoring this FSM later on in [*Chapter
    13*](B18347_13.xhtml#_idTextAnchor256)!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能能想象我们如何通过将特定状态的所有行为（和数据）封装到一个单独的类中来扩展这个状态模式。如果可以，太好了！如果不可以，也没关系，因为稍后我们会在[*第13章*](B18347_13.xhtml#_idTextAnchor256)中处理这个FSM的重构！
- en: Okay – with the caveats out of the way, let’s change some states!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——现在我们已经排除了所有警告，让我们改变一些状态！
- en: Changing state behaviors
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变状态的行为
- en: Now that we have our finite set of states defined and coded in our simple FSM
    pattern, you may wonder how we add in the conditions for changing state. Wonder
    no more – it’s pretty simple!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义并编码了我们的简单有限状态机（FSM）模式中的有限状态集，你可能想知道我们如何添加改变状态的条件。不用担心——这很简单！
- en: We’ll start by adding the required fields and assigning default values to evaluate
    our conditions for the first two states.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加所需的字段并分配默认值来评估前两个状态的条件。
- en: Idle and patrol behaviors
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空闲和巡逻行为
- en: Referring to the **State Model** in *Figure 7**.11*, let’s have the enemy patrol
    a path between two positions (we’ll define in the level) after remaining idle
    (stationary) for a specific time. Then, after patrolling for a particular time,
    we’ll have our enemy return to idling, and repeat the process indefinitely while
    the enemy is not attacking the player or, well, is dead.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图7.11中的**状态模型**，让我们让敌人在一个特定时间保持空闲（静止）后，在两个位置之间巡逻路径（我们将在关卡中定义）。然后，在巡逻了特定时间后，我们的敌人将返回空闲状态，并在敌人没有攻击玩家或，嗯，死亡的情况下无限重复这个过程。
- en: 'For this, let’s first add two variables to our `EnemyConfigData` SO that will
    specify our times for how long the enemy will idle and patrol:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们首先向我们的`EnemyConfigData` SO添加两个变量，将指定敌人空闲和巡逻的时间：
- en: '[PRE4]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don’t forget that you can override these default time values in the Editor by
    selecting the `Enemy B Config` asset in the `Assets/Data` folder and changing
    the values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，你可以在编辑器中通过选择“Assets/Data”文件夹中的“Enemy B Config”资产来覆盖这些默认时间值。
- en: 'Now, back in the `EnemyController` class, we’ll need a way to track when we
    changed into a state to calculate the time elapsed:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`EnemyController`类中，我们需要一种方法来跟踪我们何时进入状态，以便计算经过的时间：
- en: '[PRE5]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve added the `_timeStateStart` float variable that we set to the current
    game time in the `ChangeState()` method (which has been changed to a body block
    from an expression body). Calling the `ChangeState()` method provides a way for
    us to do things *on the state entered* rather than just setting the `_currentState`
    variable directly to the new state we’re transitioning to (which doesn’t afford
    us the option).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`_timeStateStart`浮点变量，在`ChangeState()`方法（已从表达式主体更改为主体块）中将其设置为当前游戏时间。调用`ChangeState()`方法为我们提供了一种在进入状态时进行操作的方式，而不仅仅是直接将`_currentState`变量设置为我们要过渡到的新状态（这不会给我们提供选项）。
- en: 'With the required fields and assigned values now set up, we can proceed to
    evaluate the conditions for changing to/from the **Idle** and **Patrol** states:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经设置了所需的字段和分配的值，我们可以继续评估从/到**空闲**和**巡逻**状态的转换条件：
- en: '[PRE6]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see in the preceding code, we have a new `if` block that evaluates
    the current time, `Time.time`, minus the time we transitioned into the current
    state, `_timeStateStart`. If the difference is greater than or equal to our configured
    time to remain idle, `_config.TimeIdle`, then call the `ChangeState()` method
    to transition to the **Patrol** state. Easy-peasy!
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们有一个新的`if`块，它评估当前时间`Time.time`减去我们进入当前状态的时间`_timeStateStart`。如果差异大于或等于我们配置的空闲时间`_config.TimeIdle`，则调用`ChangeState()`方法以过渡到**巡逻**状态。简单易懂！
- en: 'Similarly, we will evaluate transitioning from `_configTimePatrol` value (that
    is, how long the enemy should patrol for). And now, you may be wondering: how
    do we make the enemy character actually patrol?'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将评估从`_configTimePatrol`值（即敌人应该巡逻多长时间）过渡。现在，你可能想知道：我们如何让敌人角色真正巡逻？
- en: Implementing behavior
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现行为
- en: For the `EnemyController` class, but instead of doing that again, and getting
    too far away from Single Responsibility, let’s at least abstract the behaviors
    into their own classes.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`EnemyController`类，但为了避免重复操作并远离单一职责原则，我们至少将行为抽象成它们自己的类。
- en: We’ll therefore define behaviors via an interface so that we can swap out the
    behavior code, should we need or want to change it without modifying the class
    that implements it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将通过接口定义行为，这样我们就可以在需要或想要更改它而不修改实现它的类的情况下替换行为代码。
- en: 'So, create a new C# script named `IBehaviorPatrolWaypoints` in the `Assets/Scripts/Interfaces`
    folder and add the following interface declaration for a *patrol* *waypoints behavior*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Assets/Scripts/Interfaces`文件夹中创建一个新的C#脚本`IBehaviorPatrolWaypoints`，并为*巡逻*
    *航点行为*添加以下接口声明：
- en: '[PRE7]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we can see that we’ve declared two points in the level that will create
    the path the enemy will patrol between as `WaypointPatrolLeft` and `WaypointPatrolRight`.
    We’ll place an empty GameObject at each position in the level and assign their
    references to these fields in the Inspector.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们在关卡中声明了两个点，将创建敌人巡逻路径的`WaypointPatrolLeft`和`WaypointPatrolRight`。我们将在关卡中的每个位置放置一个空GameObject，并将它们的引用分配到检查器中的这些字段。
- en: 'To help visualize the concept of a patrol path better, referring to the following
    diagram, the dots (blue) represent the waypoints (that is, the empty GameObjects),
    and the dashed line (orange) represents the patrol path created from the waypoints:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地可视化巡逻路径的概念，参考以下图表，点（蓝色）代表航点（即空GameObject），虚线（橙色）代表由航点创建的巡逻路径：
- en: '![Figure 7.12 – Waypoints and patrol path](img/B18347_07_12.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 航点和巡逻路径](img/B18347_07_12.jpg)'
- en: Figure 7.12 – Waypoints and patrol path
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 航点和巡逻路径
- en: (Spoiler… players should hide in the square area (green) just south of the wall
    to avoid patrolling agents’ gaze. Look out!)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: （剧透…玩家应该躲在墙南方的正方形区域（绿色）中，以避免巡逻代理的视线。小心！）
- en: Back to the code, we then have an `Init()` method that will be called from the
    implementing class that will pass in (or, you might say, *inject*) the required
    dependencies the behavior needs to function as parameters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，我们接着有一个`Init()`方法，它将由实现类调用，并将传递（或者，可以说，*注入*）行为所需的功能参数。
- en: Last is the declaration for the `TickPhysics()` method that will be called by
    the implementing class’s `FixedUpdate()` method to perform the actual function
    of moving the enemy between the waypoints (using physics).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`TickPhysics()`方法的声明，该方法将由实现类的`FixedUpdate()`方法调用以执行在航点之间移动敌人的实际功能（使用物理）。
- en: 'Back in the `EnemyController` class now, let’s create a variable of type `IBehaviorPatrolWaypoints`.
    We’ll obtain the reference to an instance of it – which should exist as a sibling
    component on the `EnemyController` object – by using `TryGetComponent()`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 `EnemyController` 类，让我们创建一个 `IBehaviorPatrolWaypoints` 类型的变量。我们将通过使用 `TryGetComponent()`
    获取其实例的引用——它应该作为 `EnemyController` 对象上的兄弟组件存在。
- en: '[PRE8]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is how we can swap out behaviors with other behaviors of the same type
    without modifying the implementing class. By using Unity’s `GetComponent()` architecture
    – which allows a form of `MonoBehaviour`) that implement `IBehaviorPatrolWaypoints`
    and obtain the component instance via the interface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在不修改实现类的情况下，用相同类型的其他行为替换行为。通过使用 Unity 的 `GetComponent()` 架构——它允许一种形式的
    `MonoBehaviour` 实现 `IBehaviorPatrolWaypoints` 并通过接口获取组件实例。
- en: Composition (OOP)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 组合（OOP）
- en: '**Composition** is usually referred to as a *has-a-relationship* and is achieved
    by a class using instance variable(s) that refer to another object (of a class
    or another class). The term *combining* is also used to describe composition in
    **object-oriented programming** (**OOP**) because it deals with bringing multiple
    objects together to achieve an outcome.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**通常被称为 *具有-关系*，是通过一个类使用实例变量（变量）来引用另一个对象（一个类或另一个类）来实现的。术语 *组合* 也用于描述面向对象编程（**OOP**）中的组合，因为它涉及到将多个对象组合在一起以实现一个结果。'
- en: Since `IBehaviorPatrolWaypoints` is simply a behavior that moves the object
    it is added to between two points, and it doesn’t explicitly have to be used on
    the enemy, it can be used on any object we want to have this behavior.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `IBehaviorPatrolWaypoints` 只是一个将对象在两个点之间移动的行为，并且它不必显式地用于敌人，因此它可以用于任何我们想要具有此行为的对象。
- en: 'Okay – for the last part of implementing the behavior, we’ll need to have the
    `TickPhysics()` method tied into the `FixedUpdate()` method of the `EnemyController`
    class so that it can perform its behavioral function. And we do it like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——在实现行为的最后部分，我们需要将 `TickPhysics()` 方法与 `EnemyController` 类的 `FixedUpdate()`
    方法绑定，以便它能够执行其行为功能。我们这样做：
- en: '[PRE9]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What we have here again, same as in `Update()`, is having to check the current
    state we are in before calling the `tick` method for the current behavior to execute
    (that is, more code smell since the state check is occurring in multiple places
    in the class).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与 `Update()` 中的情况相同，是在调用当前行为的 `tick` 方法之前检查我们当前的状态（这意味着更多的代码异味，因为状态检查在类的多个地方发生）。
- en: Code smell
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味
- en: A **code smell** refers to source code that is a *quick-to-spot indicator* for
    deeper or interesting problems that may exist within the code base. These are
    not bugs nor errors but violations of fundamental principles that decrease the
    quality of the code base. By nature, they are unquantifiable and subjective to
    the developer’s experience.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码异味**指的是源代码中一个 *易于识别的指标*，表明代码库中可能存在更深层次或有趣的问题。这些不是错误也不是错误，而是违反基本原则的违规行为，这会降低代码库的质量。本质上，它们是不可量化的，并且取决于开发者的经验。'
- en: If `_currentState` is `Patrol`, then call `_behaviorPatrol?.TickPhysics()`.
    We used the `null` conditional operator (`?.`) on the behavior variable (an interface)
    in case the enemy object was not implemented with an `IBehaviorPatrolWaypoint`
    component. You may prefer, however, not to use `?.` and let it throw an error
    while playtesting in the Editor to validate the object configuration. It’s up
    to you how you prefer to work (this would commonly be referred to as *developer
    style*).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `_currentState` 是 `Patrol`，则调用 `_behaviorPatrol?.TickPhysics()`。我们在行为变量（一个接口）上使用了
    `null` 条件运算符 (`?.`)，以防敌人对象没有实现 `IBehaviorPatrolWaypoint` 组件。然而，你可能更喜欢不使用 `?.`，并在编辑器中进行游戏测试时让它抛出错误，以验证对象配置。如何工作取决于你（这通常被称为
    *开发者风格*）。
- en: Null conditional operator (?.) and Unity objects
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 空条件运算符 (?.) 和 Unity 对象
- en: 'Note that null propagation is incompatible with Unity objects because Unity
    overrides the null comparison operator (to properly return null for objects that
    were destroyed but not yet garbage collected). Your IDE should provide a warning
    when attempting to use the **?.** operator on Unity objects (if not, then get
    a new IDE). The correct approach would be to simply use a null comparison. Example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，空传播与 Unity 对象不兼容，因为 Unity 覆盖了空比较运算符（以正确返回已销毁但尚未垃圾回收的对象的 null）。当尝试在 Unity
    对象上使用 **?.** 运算符时，你的 IDE 应该提供警告（如果没有，那么就换一个新的 IDE）。正确的方法是简单地使用空比较。例如：
- en: 'NO'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'NO'
- en: '**_player?.Jump();**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**_player?.Jump();**'
- en: 'YES'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'YES'
- en: '**if (_player !=** **null)**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**if (_player !=** **null**)'
- en: '**_player.Jump();**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**_player.Jump();**'
- en: The final step for fully implementing the behavior is to create a class that
    implements `IBehaviorPatrolWaypoints` and contains the movement logic. I’ll present
    the completed code later in [*Chapter 13*](B18347_13.xhtml#_idTextAnchor256),
    when we refactor and extend upon the enemy behavior logic, but for now, I’m going
    to challenge you to create the script yourself!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完全实现行为的最后一步是创建一个实现 `IBehaviorPatrolWaypoints` 的类，并包含移动逻辑。我将在稍后的 [*第13章*](B18347_13.xhtml#_idTextAnchor256)
    中展示完成后的代码，当我们重构和扩展敌人行为逻辑时，但现在，我要挑战你创建自己的脚本！
- en: 'To give you a hint, take a look at how we added movement to the player (remember
    – use physics; don’t manipulate the transform position directly!) and start with
    this class declaration for a new component script named `PatrolWaypoints`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给你一个提示，看看我们是如何给玩家添加移动的（记住 – 使用物理；不要直接操作变换位置！）并从这个新组件脚本的类声明开始，命名为 `PatrolWaypoints`：
- en: '[PRE10]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or, you can cheat. I mean, take a peek now at the final code in the GitHub
    project files for the book here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以作弊。我的意思是，现在就看看 GitHub 项目文件中这本书的最终代码：[https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch7/Unity%20Project/Assets/Scripts/Behaviors)。
- en: 'We’ll implement every other behavior in the same fashion, adding on a new state
    conditional check within each method that requires processing for the current
    state, as well as doing the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以相同的方式实现每个其他行为，在每个需要处理当前状态的方法中添加一个新的状态条件检查，以及执行以下操作：
- en: Declaring an instance variable and using `GetComponent()` to obtain the reference
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个实例变量并使用 `GetComponent()` 获取引用
- en: Initializing the behavior instance and providing required dependencies via its
    `Init()` method
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其 `Init()` 方法初始化行为实例并提供所需的依赖项
- en: Adding a call to its `TickPhysics()` method to `FixedUpdate()` to perform its
    function
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对其 `TickPhysics()` 方法的调用添加到 `FixedUpdate()` 中以执行其功能
- en: Optimization note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 优化提示
- en: With our base class – **EnemyController**, in this case – implementing the behaviors,
    it means none of our behaviors needs to have its own **FixedUpdate()** Unity message
    event being registered and called; so, having a **tick** method being called instead
    is a bit more efficient as it reduces the interop overhead (C# code being called
    from the C++ engine code) – and it could certainly add up if we have many enemies!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基类 – **EnemyController**（在这种情况下）中实现行为，这意味着我们不需要为任何行为注册和调用其自己的 **FixedUpdate()**
    Unity 消息事件；因此，调用一个 **tick** 方法会更有效率，因为它减少了互操作开销（C# 代码从 C++ 引擎代码中调用）——如果我们有很多敌人，这肯定会有所增加！
- en: As you can see, however, this is, in fact, getting ugly with the enum-based
    State Pattern. For now, let’s continue with setting up the condition for transitioning
    to the **Attack** state.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所见，这实际上是通过基于枚举的状态模式变得有些丑陋了。现在，让我们继续设置过渡到 **攻击** 状态的条件。
- en: Behavior for attacking the player
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击玩家的行为
- en: We’ll need some additional references for the **Attack** behavior – specifically,
    the player. After all, you can’t attack what you can’t see.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些额外的引用来为 **攻击** 行为提供 – 特别是玩家。毕竟，你无法攻击你看不见的东西。
- en: In [*Chapter 4*](B18347_04.xhtml#_idTextAnchor079), we assigned the `Player`
    tag to our `Player` object in the Inspector to determine if it was the player
    that interacted with a collision event. Well, we’re going to use the tag again
    now, but differently.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第4章*](B18347_04.xhtml#_idTextAnchor079) 中，我们在检查器中为我们的 `Player` 对象分配了 `Player`
    标签，以确定是否是玩家与碰撞事件交互。嗯，我们现在将再次使用这个标签，但方式不同。
- en: We’ll use the tag as a parameter for the `FindWithTag()` method to obtain a
    reference to our `Player` object in the scene.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标签作为 `FindWithTag()` 方法的参数，以获取场景中 `Player` 对象的引用。
- en: Additional reading | Unity documentation
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity 文档
- en: '**FindWithTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindWithTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.FindWithTag.xhtml)'
- en: Instead of assigning the reference to a field exposed in the Inspector, we need
    to get the `Player` reference dynamically because our enemy Prefabs may be spawned
    into the scene at runtime. Hence, it’s impossible to make that assignment (scene
    references cannot be made in file-based assets such as Prefabs and SOs).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的敌人 Prefabs 可能会在运行时被实例化到场景中，因此我们需要动态地获取 `Player` 的引用，而不是将其分配给在检查器中公开的字段。因此，不可能进行这种分配（场景引用不能在基于文件的资产，如
    Prefabs 和 SOs 中进行）。
- en: 'Still within `EnemyController`, once we have the reference to `Player`, let’s
    check the distance to the player and change the state to **Attack** if the player
    is within our arbitrary range value:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `EnemyController` 中，一旦我们获得了 `Player` 的引用，让我们检查与玩家的距离，如果玩家在我们的任意范围值内，则将状态更改为
    **攻击**：
- en: '[PRE11]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We first declare a `_player` variable to hold the GameObject reference to the
    `Player` object. Then, in `Awake()`, we assign the player found in the scene by
    using `FindWithTag()` and passing in our previously declared string constant,
    `Tags.Player`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个 `_player` 变量来保存 `Player` 对象的 GameObject 引用。然后，在 `Awake()` 中，我们使用 `FindWithTag()`
    通过传递之前声明的字符串常量 `Tags.Player` 在场景中找到玩家。
- en: Optimization note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 优化说明
- en: '**FindWithTag()** is a slow command, but we’ll do it in **Awake()** to get
    the reference to Player before gameplay stats (i.e., caching the reference). Generally,
    you wouldn’t want to do this during gameplay because it’s slow, and definitely
    not in **Update()** since that is called every frame!'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindWithTag()** 是一个慢速命令，但我们会在 **Awake()** 中执行它，以便在游戏统计信息之前获取玩家的引用（即缓存引用）。通常，你不会想在游戏过程中这样做，因为它很慢，更不用说在
    **Update()** 中了，因为这是每帧都会调用的！'
- en: Next, we add the `IsPlayerInRange()` method for calculating the distance to
    the `Player` object using advanced trigonometric geometry mathematics! Nah – you
    can already see in the previous code that we simply use the `Vector2.Distance()`
    method and pass in the current position of both `Enemy` and `Player` to get a
    float value of the distance between them. Easy-peasy!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `IsPlayerInRange()` 方法来计算到 `Player` 对象的距离，使用高级三角几何数学！不——你已经在之前的代码中看到，我们只是使用
    `Vector2.Distance()` 方法，并传递 `Enemy` 和 `Player` 的当前位置来获取它们之间距离的浮点值。简单易懂！
- en: Previously, we used the `return` keyword to stop the code in a method from executing
    further. Here, we’re doing the same thing (sort of; in this case, it’s the last
    statement), but because the method signature for `IsPlayerInRange()` is declared
    as `bool` and not `void`, we need to return a bool value, the result of evaluating
    the distance returned from `Vector2.Distance()` being less than or equal to (`<=`)
    the specified `rangeAttack` value.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 `return` 关键字来停止方法中的代码执行。这里，我们做的是同样的事情（有点类似；在这种情况下，这是最后一个语句），但由于 `IsPlayerInRange()`
    方法的签名被声明为 `bool` 而不是 `void`，我们需要返回一个布尔值，即 `Vector2.Distance()` 返回的距离小于或等于（`<=`）指定的
    `rangeAttack` 值的结果。
- en: Question
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: Is the **EnemyController** class the best place to declare the **IsPlayerInRange()**
    method? Does this follow the SRP? If we need to change the logic for calculating
    the player distance, will it negatively affect other code?
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**EnemyController** 类是声明 **IsPlayerInRange()** 方法的最佳位置吗？这遵循 SRP 吗？如果我们需要更改计算玩家距离的逻辑，这会负面影响其他代码吗？'
- en: While you ponder that, I’ll leave it right where it is in **EnemyController**
    (for now?).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在思考这个问题时，我会把它留在 **EnemyController** 中（现在吗？）。
- en: 'And, finally, with our dependencies now in place, let’s wire up the condition
    for transitioning into and out of the **Attack** state:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着我们的依赖项现在就位，让我们连接进入和退出 **攻击** 状态的条件：
- en: '[PRE12]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we refer back to the `is [player] in range` condition and transition to the
    **Attack** state if so.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾 `is [player] in range` 条件，并在满足条件时过渡到 **攻击** 状态。
- en: 'We’ll do this by adding to our `Change state?` `if` block, so we add `IsPlayerInRange()`
    and pass in the `AttackRange` value configured for this enemy object. If within
    range, boom: `ChangeState(State.Attack)`!'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向我们的 `Change state?` `if` 块中添加 `IsPlayerInRange()` 并传递此敌人对象配置的 `AttackRange`
    值来实现这一点。如果在范围内，那么：`ChangeState(State.Attack)`！
- en: Conversely, in the `!`) to the `IsPlayerInRange()` call to reverse the result
    (the logical `not` operator returns `false` if the result is `true`) – which changes
    the evaluation from *is player in range* to *is player not* *in range*.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 `!`) 调用 `IsPlayerInRange()` 来反转结果（逻辑非运算符在结果为 `true` 时返回 `false`）——这改变了评估从
    *玩家是否在范围内* 到 *玩家不在范围内*。
- en: Not shown in the preceding code (for brevity), but the `IsPlayerInRange()` condition
    check (just as our State Model says it should).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（为了简洁）未显示，但`IsPlayerInRange()`条件检查（正如我们的状态模型所说的那样）。
- en: 'Now let’s see how we handle our final state from our State Model: the **Dead**
    state (that is, in fact, quite final).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何处理我们的状态模型中的最终状态：**死亡**状态（实际上，这确实是非常最终的）。
- en: Dead state
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 死亡状态
- en: The enemy would now be able to attack the player while in range – we’ll look
    at implementing the exact attack behavior in the following chapter, [*Chapter
    8*](B18347_08.xhtml#_idTextAnchor151), when the player attacks and immobilizes
    the infected robot enemy; however, we can, for now, provide a **Dead** state to
    handle that.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，敌人将能够在范围内攻击玩家——我们将在下一章中查看实现确切攻击行为，[*第8章*](B18347_08.xhtml#_idTextAnchor151)，当玩家攻击并使感染机器人敌人失去行动能力时；然而，现在我们可以提供一个**死亡**状态来处理这种情况。
- en: 'When we change to this state, we’ll simply destroy the **Enemy** GameObject
    like so:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们切换到这个状态时，我们将简单地像这样销毁**敌人**GameObject：
- en: '[PRE13]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using `Destroy()` like this is fine since we can still add *on-death* effects
    to the enemy using its `OnDestroy()` Unity message event.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Destroy()`这样是可以的，因为我们仍然可以使用敌人的`OnDestroy()` Unity消息事件为其添加**死亡**效果。
- en: Additional reading | Unity documentation
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 额外阅读 | Unity文档
- en: '**MonoBehaviour.OnDestroy**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**MonoBehaviour.OnDestroy**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.OnDestroy.xhtml)'
- en: The condition, however, needs to be checked outside the `switch` statement because
    we want to check for some health value becoming zero all the time – no matter
    the current state. We can do this by adding an `if` statement after the `switch`
    statement – the `switch` section is only for processing the current state!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，条件需要在`switch`语句之外进行检查，因为我们想要持续检查某些生命值变为零——无论当前状态如何。我们可以通过在`switch`语句之后添加一个`if`语句来实现这一点——`switch`部分只是为了处理当前状态！
- en: '[PRE14]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don’t worry too much about the `_health` variable at the moment; we’re going
    to implement health and damage systems in [*Chapter 8*](B18347_08.xhtml#_idTextAnchor151).
    As you can see in the preceding code, we’re simply checking if this enemy’s health
    equals or dips below zero and changing to the **Dead** state if so.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必太担心`_health`变量；我们将在[*第8章*](B18347_08.xhtml#_idTextAnchor151)中实现生命值和伤害系统。正如您在前面的代码中所看到的，我们只是检查这个敌人的生命值是否等于或低于零，如果是，就将其更改为**死亡**状态。
- en: This section introduced you to the State Pattern, a State Model UML diagram,
    and setting up a simple FSM for managing different states based on the State Model
    for our enemy characters.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您介绍了状态模式、状态模型UML图，以及根据状态模型为我们的敌人角色设置简单的有限状态机（FSM）来管理不同状态。
- en: Summary
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added some polish to the shooting and player character by
    introducing URP post-processing, **Shader Graph**, 2D lights, and the **Trail
    Renderer** effect. Phew! Having these features out of the box with Unity allows
    us to add visual quality to our games with little effort.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过引入URP后处理、**着色器图**、2D灯光和**轨迹渲染器**效果，为射击和玩家角色添加了一些润色。哇！有了Unity提供的这些功能，我们可以轻松地为我们的游戏添加视觉质量。
- en: We continued by adding some configurable enemy characters to the game by creating
    two enemy Prefabs and assigning unique configuration variables to each via the
    ScriptableObject assets. The enemy objects were then given behavior by implementing
    the State Pattern to introduce basic behavior with an FSM and evaluate conditions
    for transitioning between states.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过创建两个敌人Prefab并为每个通过ScriptableObject资产分配唯一的配置变量来向游戏中添加一些可配置的敌人角色。然后，通过实现状态模式并使用FSM引入基本行为以及评估状态间转换的条件，为敌人对象赋予行为。
- en: In the next chapter, we’ll complete the adventure game by adding health and
    damage systems for enemies that we’ll spawn into the level, implement the attack
    mechanics with additional weapon types, create a simple quest system for collecting
    key objects for solving the entryway puzzle, and introduce a new event system
    for keeping our code loosely coupled.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加敌人生命值和伤害系统来完善冒险游戏，我们将这些敌人实例化到关卡中，实现带有额外武器类型的攻击机制，创建一个简单的任务系统来收集解决入口谜题的关键对象，并引入一个新的事件系统以保持我们的代码松散耦合。
