- en: Prototype
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: The goal of using the Prototype pattern is to assist in establishing a consistent
    way of making a copy of an object, based on a Prototype. This Prototype is usually
    an **archetypal object** that we need to create several times during the lifespan
    of our application. To avoid the potential performance costs of initializing new
    objects, we can use the Prototype pattern to set up a system that's very similar
    to a photocopying machine. By implementing the Prototype pattern, we will be able
    to make copies of archetypal objects on the fly while minimizing the impact on
    the overall performance of our application. In other words, the Prototype pattern
    is a handy tool to add to our programming toolbox.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原型模式的目标是帮助建立一个基于原型的对象复制的一致方式。这个原型通常是一个**典型对象**，我们在应用程序的生命周期中需要多次创建它。为了避免初始化新对象可能带来的性能成本，我们可以使用原型模式来设置一个类似于复印机的系统。通过实现原型模式，我们可以在不降低应用程序整体性能的情况下，即时复制典型对象。换句话说，原型模式是我们编程工具箱中的一个实用工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the Prototype pattern's core concepts.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾原型模式的核心理念。
- en: We will implement a spawn system, using the Prototype pattern as our foundation.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现一个生成系统，以原型模式作为我们的基础。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is a hands-on chapter; you will need to have a basic understanding
    of Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个实践章节；你需要对Unity和C#有一个基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Composition
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，以查看代码的实际效果：
- en: '[http://bit.ly/2WviTwe](http://bit.ly/2WviTwe)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2WviTwe](http://bit.ly/2WviTwe)'
- en: An overview of the Prototype pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式概述
- en: The Prototype pattern is categorized as a **creational pattern**, meaning that
    its primary responsibility is to optimize the process of initializing objects.
    In the Unity scripting API, we usually don't use constructors; instead, we convert
    our classes to components and attach them to GameObjects. With this approach,
    the engine manages the initialization sequence of our objects into the memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式被归类为**创建型模式**，这意味着它的主要职责是优化初始化对象的过程。在Unity脚本API中，我们通常不使用构造函数；相反，我们将我们的类转换为组件并将它们附加到GameObject上。采用这种方法，引擎管理我们的对象初始化序列到内存中。
- en: In theory, the initialization overhead of objects is out of our control, because
    the engine manages this for us. This statement is true to a certain degree, but
    it doesn't take into account what happens during the lifespan of a scene. If we
    need to load a prefab dynamically during a specific moment in a scene, the engine
    will not be able to prevent a sudden drop in the framerate as it loads the entire
    entity into the memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，对象的初始化开销超出了我们的控制，因为引擎为我们管理这一点。这个说法在某种程度上是正确的，但它没有考虑到场景生命周期中发生的事情。如果我们需要在场景的特定时刻动态加载预制体，引擎将无法防止在将整个实体加载到内存中时帧率突然下降。
- en: A **prefab** is a prefabricated container of a collection of assembled GameObjects
    and components. For example, you can have a prefab for each type of character
    in your game. Prefabs are easy to load and copy into memory. They are often referred
    to as the building blocks of a game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制体**是一个由组装好的GameObject和组件组成的预制容器。例如，你可以为游戏中每种类型的角色创建一个预制体。预制体易于加载和复制到内存中。它们通常被称为游戏的构建块。'
- en: The Prototype pattern offers a simple solution to this technical hurdle; instead
    of loading up a new prefab, we copy one that's already in the memory. Similar
    to a photocopying machine, we can make any number of copies that we need from
    a single reference. This approach is valid for spawning both prefabs and individual
    components.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式为这个技术难题提供了一个简单的解决方案；我们不是加载一个新的预制件，而是复制一个已经存在于内存中的。类似于复印机，我们可以从一个单一引用中制作出我们需要的任意数量的副本。这种方法适用于生成预制件和单个组件。
- en: 'The following UML diagram is an example of a design for a spawn system that
    uses the Prototype pattern as a foundation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 图是一个使用原型模式作为基础的生成系统设计的示例：
- en: '![](img/9d2de532-49d8-4b16-9578-8add31aff2de.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2de532-49d8-4b16-9578-8add31aff2de.png)'
- en: As you can see, the core element of the Prototype pattern is the interface class
    named `ICopyable`. As its name suggests, any class that implements `ICopyable` will
    need to be able to return a copy of itself. In the preceding diagram, the `Enemy`
    class implements the `ICopyable` interface. This relationship indicates that we
    will be able to request instances of **Drone** and **Tank** without having to
    create new ones every time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，原型模式的核心元素是名为 `ICopyable` 的接口类。正如其名所示，任何实现了 `ICopyable` 的类都需要能够返回其自身的副本。在先前的图中，`Enemy`
    类实现了 `ICopyable` 接口。这种关系表明，我们将能够请求 **Drone** 和 **Tank** 的实例，而无需每次都创建新的实例。
- en: Associating a design pattern to a real-world system can help you to remember
    the definition of a specific pattern. Personally, I always compare the Prototype
    pattern to a photocopier.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计模式与实际系统关联可以帮助你记住特定模式的定义。我个人总是将原型模式与复印机相比较。
- en: Benefits and drawbacks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: Let's review a short list of the benefits and potential drawbacks related to
    the implementation of the Prototype pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下与原型模式实现相关的优点和潜在缺点的简短列表。
- en: 'The following are the benefits:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好处：
- en: '**Reduction of initialization overhead**: In theory, copying an object that''s
    already in the memory is faster than initializing a new one.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少初始化开销**：理论上，复制已经存在于内存中的对象比初始化一个新的对象要快。'
- en: '**Reusability of instances in the memory**: It''s possible to copy permutations
    of a prototype object while it is transferring from one state to another.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存中实例的可重用性**：在原型对象从一个状态转移到另一个状态的过程中，可以复制其排列组合。'
- en: '**Consistency**: There are structural benefits to letting objects copy themselves;
    it''s safer, and it offers a standard interface for the duplication process.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：让对象自我复制具有结构上的优势；这样做更安全，并且为复制过程提供了一个标准接口。'
- en: 'The following are the drawbacks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: '**Maintenance of references**: If there''s a race condition in which we always
    destroy our prototype object before making a copy of it, we will end up nullifying
    any benefits of using this pattern.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护引用**：如果在复制之前我们总是销毁原型对象，那么我们最终会消除使用此模式的所有好处。'
- en: '**Unsupported and circular references**: In some instances, objects have internal
    structures that don''t support cloning. In those cases, it might be difficult
    to use the objects in a system that implements the Prototype pattern.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不支持和不支持循环引用**：在某些情况下，对象的内部结构不支持克隆。在这些情况下，可能很难在实现原型模式的系统中使用这些对象。'
- en: In this book, we will avoid using strict computer science terminology. With
    any programming concept, there's always a scientific and practical definition.
    We will focus on the practical definitions while still considering the theoretical
    interpretations of the patterns.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将避免使用严格的计算机科学术语。对于任何编程概念，总有一个科学和实用的定义。我们将专注于实用的定义，同时仍然考虑模式的理论解释。
- en: Use case example
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: Now that you have a general understanding of the Prototype pattern, let's implement
    an actual in-game system, using the pattern as the foundation of our architecture.
    A spawn system is a perfect use case for a creational pattern like the Prototype
    pattern. Spawning enemies at the right moment is key to designing a very immersive
    experience in a video game.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对原型模式有了基本的了解，让我们实际实现一个游戏中的系统，将模式作为我们架构的基础。生成系统是原型模式这类创建型模式的一个完美用例。在正确的时间生成敌人对于设计一个非常沉浸式的游戏体验至关重要。
- en: The most critical technical issue that we need to avoid is a dip in the framerate
    during the spawning process of the enemies. That is why we are going to use the
    Prototype pattern; we will copy existing instances of specific enemies, instead
    of creating new ones each time we need to spawn them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要避免的最关键的技术问题是敌人生成过程中的帧率下降。这就是为什么我们将使用原型模式；我们将复制特定敌人的现有实例，而不是每次需要生成它们时都创建新的实例。
- en: In the next section, we will take the UML diagram that we reviewed at the beginning
    of the chapter and implement it in actual code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现我们在本章开头审查的 UML 图。
- en: Code example
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: In this section, we will implement a bare-bones spawn system for a game that
    includes drones and snipers as its main enemy types. At this point, let's make
    sure that our spawn system can return copies of a specific enemy type to a client.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个仅包含无人机和狙击手作为主要敌人类型的游戏的基本生成系统。在此阶段，让我们确保我们的生成系统能够向客户端返回特定敌人类型的副本。
- en: When we use the term **client** in this book, we mean a class that uses the
    functionality of a pattern. In our context, it's usually a `Client` class that
    permits us to test our code examples.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这本书中使用术语 **客户端** 时，我们指的是使用模式功能的一个类。在我们的上下文中，它通常是一个 `Client` 类，它允许我们测试我们的代码示例。
- en: 'Throughout this book, we will often use interfaces in our examples. They''re
    a powerful tool in object-oriented programming. They offer a simple way to declare
    an implementation contract. Refer to the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将在我们的示例中经常使用接口。它们是面向对象编程中的强大工具。它们提供了一种简单的方式来声明实现合同。参考以下步骤：
- en: 'As our first step, let''s implement an interface called `ICopyable`. We are
    going to expose a function called `Copy()`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，让我们实现一个名为 `ICopyable` 的接口。我们将公开一个名为 `Copy()` 的函数：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that our interface is named `ICopyable`; this is to avoid confusing it
    with C#'s native interface, called `ICloneable`, which is used to declare a class
    as being **cloneable**. We are not going to use this C# interface in our example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的接口名为 `ICopyable`；这是为了避免与 C# 的原生接口 `ICloneable` 混淆，后者用于声明一个类为 **可克隆**。在我们的示例中，我们不会使用这个
    C# 接口。
- en: 'Now that we have our interface, let''s implement it in a concrete class named
    `Enemy`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的接口，让我们在名为 `Enemy` 的具体类中实现它：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `Enemy` parent class is now able to return a cloned instance of itself through
    the `Copy()` function. As we mentioned previously, we didn't use the C# native
    `ICloneable` interface because we are utilizing Unity's API by using its `Instantiate()`
    function. This API function is more suitable to our context because it can persist
    the hierarchical relationships of a native Unity GameObject or component during
    the cloning process. In other words, when cloning a GameObject with `Instantiate()`,
    you are copying (cloning) its children as well. This approach is essential in
    Unity because GameObjects are often composed of multiple objects and components,
    structured in a parent-child arrangement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Enemy` 父类现在能够通过 `Copy()` 函数返回其自身的克隆实例。正如我们之前提到的，我们没有使用 C# 的原生 `ICloneable`
    接口，因为我们正在通过使用 Unity 的 `Instantiate()` 函数利用 Unity 的 API。这个 API 函数更适合我们的上下文，因为它可以在克隆过程中持续原生
    Unity GameObject 或组件的层次关系。换句话说，当使用 `Instantiate()` 克隆 GameObject 时，您也在复制（克隆）其子对象。这种方法在
    Unity 中至关重要，因为 GameObjects 通常由多个对象和组件组成，以父子结构排列。
- en: 'The next step involves implementing our two main enemies; let''s start with `Drone`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步涉及实现我们的两个主要敌人；让我们从 `Drone` 开始：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, our `Drone` class is now a child of the `Enemy` class, and because
    child objects inherit the properties of their parents in object-oriented environments,
    the `Drone` class obtains access to the `Copy()` function. This arrangement means
    that a client will be able to request a copy of a `Drone` by calling `Copy()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的 `Drone` 类现在是 `Enemy` 类的一个子类，并且因为在面向对象的环境中子对象继承其父对象的属性，`Drone` 类获得了访问
    `Copy()` 函数的权限。这种安排意味着客户端可以通过调用 `Copy()` 来请求 `Drone` 的副本。
- en: 'Now, let''s do the same for our `Sniper`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的 `Sniper` 做同样的事情：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have all of our concrete `Enemy` type classes written down, let''s
    implement our `EnemySpawner`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将所有具体的 `Enemy` 类型类写下来，让我们实现我们的 `EnemySpawner`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our spawn system is quite simple; it spawns enemies by making copies of any
    object that he receives that corresponds to the `Enemy` type. It's like a Xerox
    machine; feed it the right document, and it will make copies of it. However, there's
    one core difference; our `EnemySpawner` doesn't do the copying. It just asks the
    object that it receives to make a copy of itself, and then returns the copy to
    the client.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生成系统相当简单；它通过复制接收到的任何对应于`Enemy`类型的对象来生成敌人。就像一台复印机；给它正确的文档，它就会复制它。然而，有一个核心区别；我们的`EnemySpawner`不执行复制。它只是要求它接收到的对象复制自己，然后将复制品返回给客户端。
- en: 'To test our enemy spawn system implementation, let''s write a `Client` class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的敌人生成系统实现，让我们编写一个`Client`类：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our `Client` class is quite simple; depending on whether the player presses
    *S* or *D* on their keyboard, it will request `EnemySpawner` to return a `Drone`
    or `Sniper` instance, and then it will place it beside the previously spawned
    entity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Client`类相当简单；根据玩家是否在键盘上按下*S*或*D*，它将请求`EnemySpawner`返回一个`Drone`或`Sniper`实例，然后它将把它放在之前生成的实体旁边。
- en: 'In this book, we assume that the reader has basic Unity skills and already
    knows how to set up GameObjects and attach components to them. As a quick reminder,
    to make this code example compile and work in a Unity scene, you will need to
    do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们假设读者具备基本的Unity技能，并且已经知道如何设置GameObject以及将组件附加到它们上。作为一个快速提醒，为了使此代码示例在Unity场景中编译并工作，你需要执行以下操作：
- en: Create two GameObjects with the Drone or Sniper scripts attached to them as
    components.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个GameObject，并将Drone或Sniper脚本附加到它们作为组件。
- en: Create one GameObject with the Client (Script) attached to it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有客户端（脚本）的GameObject。
- en: In the Inspector of the Client (Script) component, set the Drone and Sniper
    GameObjects as references in the corresponding fields.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端（脚本）组件的检查器中，将Drone和Sniper GameObject设置为相应字段中的引用。
- en: 'The following screenshot displays a typical Unity scene setup for testing our
    code example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了测试我们的代码示例的典型Unity场景设置：
- en: '![](img/c3306d86-bf00-403c-9460-40dfd82887a9.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c3306d86-bf00-403c-9460-40dfd82887a9.png)'
- en: The source code and Unity project for this book are available in the GitHub
    repository at [https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的相关源代码和Unity项目可在GitHub仓库[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)中找到。
- en: We have successfully implemented the Prototype pattern while building a simple
    spawn system. This code is a solid foundation for developing a more advanced spawn
    system. The most important lesson to keep in mind is to always consider copying
    an object before creating it. This approach is a straightforward optimization
    strategy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建简单的生成系统时成功实现了原型模式。这段代码是开发更高级生成系统的坚实基础。需要记住的最重要的一课是始终考虑在创建对象之前复制它。这种方法是一种直接的优化策略。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the practical section of this book with a flexible but simple pattern.
    The overall concept behind the Prototype pattern is straightforward; instead of
    initializing new objects, we merely clone them from instances that are already
    in the memory. To maintain consistency during the cloning process, we encapsulate
    the manner in which objects clone themselves, removing this responsibility from
    the client. As a benefit, we can gain performance and consistency in the way that
    we spawn entities in our game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这本书的实践部分以一个灵活但简单的模式开始。原型模式背后的整体概念很简单；我们不是初始化新对象，而是仅仅从内存中已有的实例克隆它们。为了在克隆过程中保持一致性，我们封装了对象自我克隆的方式，将这一责任从客户端移除。作为好处，我们可以获得在游戏中生成实体的性能和一致性。
- en: In the next chapter, we will explore the Prototype pattern's close cousin, the
    Factory pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨原型模式的一个近亲，即工厂模式。
- en: Exercise
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Every time you learn a new pattern and adapt it to Unity, you should validate
    whether it is beneficial beyond making your code look structured. Unlike in other
    domains, game programmers are judged not just by their ability to write clean
    code, but also by how fast it runs. You will notice that a lot of design patterns
    sacrifice performance for consistency in structure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你学习一个新的模式并将其适应到Unity中时，你应该验证它是否在使你的代码看起来结构化之外还有益处。与其他领域不同，游戏程序员不仅被他们的编写整洁代码的能力所评判，还在于代码的运行速度。你会发现很多设计模式为了结构的一致性而牺牲了性能。
- en: As an exercise, I recommend that you compare the performance of using `Instantiate()`
    by copying an existing object in the memory to that of using `Resource.Load()`
    to load up an existing prefab of the same object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，我建议你比较使用`Instantiate()`通过复制内存中现有对象和使用`Resource.Load()`加载相同对象的现有预制件来使用`Instantiate()`的性能。
- en: To accomplish this task, you can experiment with Unity's native profiling tools.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个任务，你可以尝试使用Unity的本地分析工具。
- en: I recommend reading Unity's Profiler documentation; you can view the link in
    the *Further reading* section of this chapter. It's a good practice to profile
    your code often, especially before attempting any optimization. This approach
    will help you to avoid spending hours optimizing code that's not even executed
    that often.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议阅读Unity的分析器文档；你可以在本章的“进一步阅读”部分查看链接。经常分析你的代码是一个好习惯，尤其是在尝试任何优化之前。这种方法将帮助你避免花费数小时优化那些甚至不经常执行的代码。
- en: Further reading
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Programming Patterns* by Robert Nystrom: [http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《游戏编程模式》由Robert Nystrom著：[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)
- en: '*Unity Manual – Profiler overview: *[https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Unity手册 – 分析器概述：》[https://docs.unity3d.com/Manual/Profiler.html](https://docs.unity3d.com/Manual/Profiler.html)
