- en: Managing Game Events with the Event Bus
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件总线管理游戏事件
- en: The Event Bus acts as a central hub that manages a specific list of global events
    that objects can choose to subscribe to or publish. It's the most straightforward
    pattern related to event managing that I have in my toolbox. It reduces the process
    of assigning the role of subscriber or publisher to an object into a single line
    of code. As you can imagine, this can be beneficial when you need results quickly.
    But like most simple solutions, it has some drawbacks and limitations, which we
    will explore further on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线充当一个中心枢纽，管理一组特定的全局事件，对象可以选择订阅或发布。这是我在工具箱中与事件管理相关最直接的模式。它将分配对象作为订阅者或发布者的过程简化为单行代码。正如你可以想象的那样，当你需要快速得到结果时，这可能会很有益。但像大多数简单解决方案一样，它也有一些缺点和限制，我们将在后面的内容中进一步探讨。
- en: In the code example presented in this chapter, we will use the Event Bus to
    broadcast specific race events to components that need to listen for changes in
    the overall state of the race. But it's essential to keep in mind; I'm proposing
    using the Event Bus as a solution for managing global race events because of its
    simplicity and not its scalability. So it might not be the best solution in all
    cases, but it is one of the most straightforward patterns to implement, as we
    will see in the following sections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章提供的代码示例中，我们将使用事件总线向需要监听比赛整体状态变化的组件广播特定的比赛事件。但重要的是要记住；我提出使用事件总线作为管理全局比赛事件解决方案的原因是其简单性，而不是其可扩展性。因此，它可能不是所有情况下的最佳解决方案，但它是最直接的模式之一，我们将在接下来的章节中看到。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An overview of the Event Bus pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线模式的概述
- en: The implementation of a Race Event Bus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Race Event Bus 的实现
- en: This chapter includes simplified skeleton code examples for the sake of brevity
    and clarity. If you wish to review a complete implementation of the pattern in
    the context of an actual game project, open the `FPP` folder in the GitHub project.
    You can find the link under the *Technical requirements* section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁和清晰，本章包含简化的代码示例。如果你希望在一个实际的游戏项目中查看该模式的完整实现，请打开GitHub项目中的`FPP`文件夹。你可以在*技术要求*部分找到链接。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will also be using the following specific Unity engine API features:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用以下特定的Unity引擎API功能：
- en: '`Static`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Static`'
- en: '`UnityEvents`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityEvents`'
- en: '`UnityActions`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnityActions`'
- en: If you are unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml), *A
    Short Primer to Programming in Unity*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请查阅[第3章](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml)，《Unity编程简明指南》。
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter06)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的实际应用：
- en: '[https://bit.ly/2U7wrCM](https://bit.ly/2U7wrCM).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/2U7wrCM](https://bit.ly/2U7wrCM)。'
- en: If you find yourself having problems understanding the mechanism behind delegates,
    keep in mind that they are similar to function pointers in C/C++. In simple terms,
    a delegate points to a method. And delegates are often used to implement event
    handlers and callbacks. An action is a type of delegate that you can use with
    a method that has a void return type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己难以理解委托背后的机制，请记住，它们在C/C++中类似于函数指针。简单来说，委托指向一个方法。委托通常用于实现事件处理程序和回调。动作是一种可以与具有void返回类型的方法一起使用的委托类型。
- en: Understanding the Event Bus pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件总线模式
- en: When an event is raised by an object (publisher), it sends out a signal that
    other objects (subscribers) can receive. The signal is in the form of a notification
    that can indicate the occurrence of an action. In an event system, an object broadcasts
    an event. Only those objects that subscribe to it will be notified and choose
    how to handle it. So, we can imagine it as having a sudden burst of a radio signal
    that only those with antennas tuned to a specific frequency can detect.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象（发布者）引发事件时，它会发送一个信号，其他对象（订阅者）可以接收。该信号以通知的形式出现，可以指示动作的发生。在事件系统中，一个对象广播事件。只有订阅了该事件的那些对象才会收到通知并选择如何处理它。因此，我们可以将其想象为一种突然爆发的无线电信号，只有那些将天线调谐到特定频率的人才能检测到。
- en: The Event Bus pattern is a close cousin of the Messaging system and Publish-Subscribe
    patterns, the latter being the more accurate name for what the Event Bus does.
    The keyword in the title of this pattern is the term *bus*. In simple computing
    terms, a bus is a connection between components. In the context of this chapter,
    the components will be objects that can be publishers or listeners of events.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线模式是消息系统和发布-订阅模式的一个近亲，后者是事件总线所做事情的更准确名称。这个模式标题中的关键字是术语*总线*。在简单的计算机术语中，总线是组件之间的连接。在本章的上下文中，这些组件将是可以作为事件发布者或监听者的对象。
- en: Hence, the Event Bus is a way to connect objects through events by using a publish-subscribe
    model. It's possible to accomplish a similar model with a pattern such as the
    Observer and native C# events. However, those alternatives have some drawbacks.
    For example, in a typical implementation of the Observer pattern, a tight coupling
    might occur, as observers (listeners) and subjects (publishers) might become dependent
    and aware of each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，事件总线是通过使用发布-订阅模型通过事件连接对象的一种方式。使用观察者模式和本地C#事件等模式也可以实现类似的功能。然而，这些替代方案存在一些缺点。例如，在观察者模式的一个典型实现中，可能会发生紧密耦合，因为观察者（监听器）和主题（发布者）可能会相互依赖并意识到对方的存在。
- en: 'But the Event Bus, at least in the way we will implement it in Unity, abstracts
    and simplifies the relations between publishers and subscribers, so they are entirely
    unaware of one another. Another advantage is that it reduces the process of assigning
    the role of publisher or subscriber to a single line of code. Therefore, the Event
    Bus is a valuable pattern to learn and have in your back pocket. As you can see
    in the following diagram, it does act as a middleman between publishers and subscribers:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但事件总线，至少在我们将在Unity中实现的方式中，抽象并简化了发布者和订阅者之间的关系，因此它们彼此完全不知情。另一个优点是它减少了将发布者或订阅者角色分配给单行代码的过程。因此，事件总线是一个值得学习和拥有的宝贵模式。您可以从以下图中看到，它确实在发布者和订阅者之间充当中间人：
- en: '![](img/272dfd72-4bd9-4a96-a736-c192239f3c9a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/272dfd72-4bd9-4a96-a736-c192239f3c9a.png)'
- en: Figure 6.1 – Diagram of the Event Bus pattern
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 事件总线模式的图示
- en: 'As you can see from the diagram, there are three main ingredients:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从图中可以看出，有三个主要成分：
- en: '**Publishers**: These objects can publish specific types of events declared
    by the Event Bus to subscribers.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：这些对象可以向订阅者发布事件总线声明的特定类型的事件。'
- en: '**Event Bus**: This object is responsible for coordinating the transmission
    of events between publishers and subscribers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件总线**：此对象负责协调发布者和订阅者之间的事件传输。'
- en: '**Subscribers**: These objects register themselves as subscribers of specific
    events through the Event Bus.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：这些对象通过事件总线将自己注册为特定事件的订阅者。'
- en: Benefits and drawbacks of the Event Bus pattern
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件总线模式的优缺点
- en: 'The **benefits** of the Event Bus pattern are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线模式的**优点**如下：
- en: '**Decoupling**: The main benefit of using an event system is that it decouples
    your objects. Objects can communicate through events instead of directly referencing
    each other.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解耦**：使用事件系统的主要好处是它解耦了您的对象。对象可以通过事件进行通信，而不是直接引用彼此。'
- en: '**Simplicity**: The Event Bus offers simplicity by abstracting the mechanism
    of publishing or subscribing to an event from its clients.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：事件总线通过抽象发布或订阅事件机制，为客户端提供简单性。'
- en: 'The **drawbacks** of the Event Bus pattern are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线模式的**缺点**如下：
- en: '**Performance**: Under the hood of any event system, there''s a low-level mechanism
    that manages messaging between objects. And so there might be a slight performance
    cost when using an event system, but depending on your target platform, it could
    be minuscule.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：在任何一个事件系统的底层，都有一个管理对象间消息传递的低级机制。因此，使用事件系统可能会带来轻微的性能开销，但根据您的目标平台，这可能是微不足道的。'
- en: '**Global**: In this chapter, we implement the Event Bus with static methods
    and properties to make it easier to access from anywhere in our code. There is
    always a risk when using globally accessible variables and states as they can
    make debugging and unit testing more difficult. However, this is a very contextual
    drawback and not an absolute.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**：在本章中，我们使用静态方法和属性实现事件总线，以便更容易从代码的任何地方访问它。使用全局可访问的变量和状态总会有风险，因为它们可能会使调试和单元测试变得更加困难。然而，这是一个非常具体的问题，而不是绝对的。'
- en: UnityEvents can actually accept up to four generic-type arguments. This can
    make it possible to pass event-specific data to subscribers. Review the following
    Unity API documentation section for more details: [https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html)[.](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: UnityEvents实际上可以接受多达四个泛型类型参数。这使得将特定事件的数据传递给订阅者成为可能。请参阅以下Unity API文档部分以获取更多详细信息：[https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html](https://docs.unity3d.com/2021.2/Documentation/ScriptReference/Events.UnityEvent.html)[.](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)
- en: When to use the Event Bus
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用事件总线
- en: 'I have used the Event Bus in the past for the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我过去曾使用事件总线来完成以下任务：
- en: '**Rapid prototyping**: I use the Event Bus pattern often when rapidly prototyping
    new game mechanics or features. With this pattern, I can easily have components
    that trigger each other''s behaviors with events while keeping them decoupled.
    This pattern permits us to add and remove objects as subscribers or publishers
    with a single line of code, which is always helpful when you want to prototype
    something quickly and easily.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速原型设计**：我在快速原型设计新的游戏机制或功能时经常使用事件总线模式。使用这个模式，我可以轻松地让组件通过事件触发彼此的行为，同时保持它们解耦。这个模式允许我们通过一行代码添加和删除对象作为订阅者或发布者，这在你想快速轻松地原型设计某物时总是很有帮助。'
- en: '**Production code**: I use the Event Bus in production code if I can''t find
    a justifiable reason to implement a more sophisticated approach to managing game
    events. It''s a pattern that does the job well if you don''t need to handle complex
    event types or structures.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产代码**：如果我没有找到合理的理由来实现更复杂的管理游戏事件的方法，我会在生产代码中使用事件总线。如果你不需要处理复杂的事件类型或结构，这个模式可以很好地完成任务。'
- en: I would avoid using a globally accessible Event Bus like the one presented in
    this chapter to manage events that don't have a "global scope." For instance,
    if I have a UI component in the HUD that displays a damage alert when the player
    collides with an obstacle, it would be inefficient to publish a collision event
    through the Event Bus as it's a localized interaction between the bike and an
    object on the track. Instead, I would use something like an Observer pattern because,
    in that scenario, I only need one UI component to observe a specific change in
    the state of an object, in this case, the bike. As a rule of thumb, every time
    you have to implement a system that uses events, go through the list of known
    patterns, choose one suitable for your use case, but don't always fall back to
    the easiest one, which, in my opinion, is the Event Bus.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我会避免使用本章中展示的类似的全局可访问事件总线来管理没有“全局范围”的事件。例如，如果我有一个在HUD中显示伤害警报的UI组件，当玩家与障碍物碰撞时，通过事件总线发布碰撞事件将是不高效的，因为这仅仅是自行车与赛道上的物体之间的局部交互。相反，我会使用类似观察者模式的东西，因为在那种情况下，我只需要一个UI组件来观察对象状态的一个特定变化，在这种情况下，是自行车。作为一个经验法则，每次你必须实现一个使用事件系统的系统时，都要通过已知模式的列表，选择一个适合你用例的模式，但不要总是退回到最简单的一个，在我看来，那就是事件总线。
- en: Managing global race events
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理全球赛车活动
- en: 'The project we are working on is a racing game, and most races are structured
    in stages. The following is a shortlist of typical racing stages:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发的项目是一款赛车游戏，大多数比赛都分为几个阶段。以下是一些典型的赛车阶段简短列表：
- en: '**Countdown**: At this stage, the bike is stopped behind the start line while
    a countdown timer is running down.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**倒计时**：在这个阶段，自行车停在起跑线后，同时倒计时计时器正在运行。'
- en: '**Race start**: Once the clock hits zero, the green light signal is turned
    on, and the bike moves forward on the track.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事开始**：一旦时钟达到零，绿灯信号被点亮，自行车开始在赛道上前进。'
- en: '**Race finish**: The moment the player crosses the finish line, the race is
    over.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事结束**：当玩家通过终点线的那一刻，赛事就结束了。'
- en: 'In between the start and finish of the race, certain events can be triggered
    that could change the current state of the race:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在赛事的开始和结束之间，可能会触发某些事件，这些事件可能会改变赛事的当前状态：
- en: '**Race pause**: The player could pause the game while still racing.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事暂停**：玩家可以在比赛过程中暂停游戏。'
- en: '**Race quit**: The player could quit the race at any time.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事退出**：玩家可以在任何时候退出赛事。'
- en: '**Race stop**: The race could stop suddenly if the player is involved in a
    fatal crash.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事停止**：如果玩家参与致命碰撞，赛事可能会突然停止。'
- en: So we want to broadcast a notification that signals the occurrence of each stage
    of the race and any other important event in between that will change the overall
    state of the race. This approach will permit us to trigger specific behaviors
    of components that need to behave in certain ways depending on the current context
    of the race.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望广播一个通知，以表示赛事每个阶段的发生以及任何其他在赛事过程中发生的重要事件，这些事件将改变赛事的整体状态。这种方法将允许我们触发特定组件的特定行为，这些组件需要根据赛事的当前上下文以特定方式行为。
- en: 'For example, here are some components that will get updated depending on a
    specific state of the race:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一些将根据赛事的特定状态进行更新的组件：
- en: '**HUD**: The race status indicator will change depending on the context of
    the race **HUD** (**heads-up display**).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD**：赛事状态指示器将根据赛事的上下文改变**HUD**（**抬头显示**）。'
- en: '**RaceTimer**: The race timer will only start at the start of the race and
    stops when the player crosses the finish line.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赛事计时器**：赛事计时器仅在赛事开始时启动，并在玩家通过终点线时停止。'
- en: '**BikeController**: The bike controller releases the brakes of the bike once
    the race starts. This mechanism prevents the player from launching onto the track
    before the green light.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自行车控制器**：一旦赛事开始，自行车控制器将释放自行车的刹车，这种机制防止玩家在绿灯亮起之前冲上赛道。'
- en: '**InputRecorder**: At the start of the race, the input replay system will start
    recording the player''s inputs so that they can be replayed later on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入记录器**：在赛事开始时，输入回放系统将开始记录玩家的输入，以便稍后回放。'
- en: All these components have specific behaviors that have to be triggered at particular
    stages of the race. So we will use the Event Bus to implement these global race
    events.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件在赛事的特定阶段都有特定的行为需要触发。因此，我们将使用事件总线来实现这些全局赛事事件。
- en: Implementing a Race Event Bus
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现赛事事件总线
- en: 'We are going to implement the Race Event Bus in two easy steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步实现赛事事件总线：
- en: 'To start, we need to expose the specific race event types that we support,
    which we will do with the following enum:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要暴露我们支持的具体赛事事件类型，我们将使用以下枚举来完成：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's important to note that the preceding enum values represent specific events
    outlining the stages of a race, from start to finish. So we are restricting ourselves
    to handling events with just a global scope.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，前面的枚举值代表从开始到结束的赛事各个阶段的具体事件。因此，我们限制自己只处理具有全局作用域的事件。
- en: 'The next part is the core component of the pattern, the actual game event bus
    class, which we will call `RaceEventBus`, to be more domain-specific in the naming
    convention of our classes:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是模式的核心理念，实际的赛事事件总线类，我们将称之为`RaceEventBus`，以使我们的类命名约定更具领域特定性：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The key ingredient of our class is the `Events` dictionary. This acts as a ledger
    in which we maintain a list of relations between event types and subscribers.
    By keeping it `private` and `readonly`, we are ensuring that it can't be overwritten
    by another object directly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类中的关键成分是`Events`字典。它充当一个账本，在其中我们维护事件类型和订阅者之间关系列表。通过将其保持为`private`和`readonly`，我们确保它不能被另一个对象直接覆盖。
- en: Therefore, a client must call the `Subscribe()` public static method to add
    itself as a subscriber of a specific event type. The `Subscribe()` method takes
    two parameters; the first is the race event type, and the second one is the callback
    function. Because `UnityAction` is a delegate type, it provides us with a way
    to pass a method as an argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端必须调用`Subscribe()`公共静态方法来将自己添加为特定事件类型的订阅者。`Subscribe()`方法接受两个参数；第一个是赛事事件类型，第二个是回调函数。因为`UnityAction`是一个委托类型，它为我们提供了一种将方法作为参数传递的方式。
- en: Hence, when a client object calls the `Publish()` method, the registered callback
    methods of all the subscribers of a specific race event type will get called at
    the same time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当客户端对象调用`Publish()`方法时，特定赛车事件类型的所有订阅者的注册回调方法将同时被调用。
- en: The `Unsubscribe()` method is self-explanatory as it permits objects to remove
    themselves as subscribers of a specific event type. Thus, their callback methods
    will not be called by the Event Bus when an object publishes an event.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unsubscribe()`方法很容易理解，因为它允许对象将自己从特定事件类型的订阅者中移除。因此，当对象发布事件时，事件总线不会调用它们的回调方法。'
- en: If this still looks abstract, it will be made clear as we implement client classes
    in the next section and see how we can use the Event Bus to trigger behaviors
    of objects at specific moments in the proper sequence.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然看起来很抽象，我们将在下一节实现客户端类，并看到我们如何使用事件总线以正确的顺序在特定时刻触发对象的行为。
- en: Testing the Race Event Bus
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试赛车事件总线
- en: 'Now that we have the core elements of the pattern in place, we can write some
    code to test our `RaceEventBus` class. For reasons of brevity, I have removed
    all the behavior code in each client class to focus on the use of the pattern:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了模式的核心元素，我们可以编写一些代码来测试我们的`RaceEventBus`类。为了简洁起见，我已经从每个客户端类中删除了所有行为代码，以专注于模式的使用：
- en: 'For starters, we are going to write a countdown timer that subscribes to the
    `COUNTDOWN` race event type. Once the `COUNTDOWN` event is published, it will
    trigger a 3-second countdown to the start of the race. And at the exact moment
    the count reaches its end, it will publish the `START` event to signal the beginning
    of the race:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个倒计时计时器，它订阅了`COUNTDOWN`赛车事件类型。一旦发布`COUNTDOWN`事件，它将触发一个3秒的倒计时，直到比赛开始。当计数达到结束时，它将发布`START`事件，以表示比赛的开始：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The most significant lines of code in the preceding class are the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类中最关键的代码行如下：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every time the `CountdownTimer` object is enabled, the `Subscribe()` method
    is called. And when the opposite happens, and it gets disabled, it unsubscribes
    itself. We are doing this to ensure that the object is listening to an event when
    it's active or doesn't get called by `RaceEventBus` when disabled or destroyed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`CountdownTimer`对象被启用时，就会调用`Subscribe()`方法。而当它被禁用时，它会自己取消订阅。我们这样做是为了确保对象在活动时正在监听事件，或者在禁用或销毁时不会被`RaceEventBus`调用。
- en: The `Subscribe()` method takes two arguments – the event type, and a callback
    function. This means that the `StartTimer()` method of `CountdownTimer` will be
    called by `RaceEventBus` every time the `COUNTDOWN` event is published.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscribe()`方法接受两个参数——事件类型和回调函数。这意味着每当发布`COUNTDOWN`事件时，`RaceEventBus`都会调用`CountdownTimer`的`StartTimer()`方法。'
- en: 'Next up, we will implement a skeleton of the `BikeController` class to test
    out the `START` and `STOP` events:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`BikeController`类的骨架来测试`START`和`STOP`事件：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And lastly, we are going to write an `HUDController` class. This doesn''t do
    much except display a button to stop the race once it starts:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写一个`HUDController`类。这个类除了显示一个按钮来停止比赛之外，没有做太多的事情：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To test the sequence of events, we need to attach the following client class
    to a GameObject in an empty Unity scene. With this, we will be able to trigger
    the countdown timer:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试事件序列，我们需要将以下客户端类附加到一个空的Unity场景中的GameObject上。有了这个，我们就可以触发倒计时计时器：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding example might seem overly simplified, but its purpose is to showcase
    how we can trigger individual object behaviors in a specific sequence with events
    while keeping them decoupled. None of the objects communicate with one another
    directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可能看起来过于简化，但其目的是展示我们如何通过事件触发特定顺序中单个对象的行为，同时保持它们解耦。没有任何对象之间直接通信。
- en: Their only common point of reference is `RaceEventBus`. Therefore, we could
    easily add more subscribers and publishers; for instance, we could have a `TrackController`
    object listen for the `RESTART` event to know when to reset the race track. And
    thus, we can now sequence the triggering of behaviors of core components with
    events, each presenting a particular stage of the race.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它们唯一的共同参考点是`RaceEventBus`。因此，我们可以轻松地添加更多的订阅者和发布者；例如，我们可以让一个`TrackController`对象监听`RESTART`事件，以知道何时重置赛道。因此，我们现在可以使用事件来按顺序触发核心组件的行为，每个事件都代表比赛的特定阶段。
- en: Action is a delegate that points to a method that accepts one or more arguments
    but returns no value. For instance, you should use Action when your delegate points
    to a method that returns void. UnityAction behaves like Actions in native C#,
    except UnityActions was designed to be used with UnityEvents.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是一个委托，它指向一个接受一个或多个参数但不返回任何值的方法。例如，你应该在委托指向返回void的方法时使用Action。UnityAction的行为类似于原生C#中的Actions，但UnityAction是为了与UnityEvents一起使用而设计的。
- en: Reviewing the Event Bus implementation
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾事件总线实现
- en: By using the Event Bus, we can trigger behaviors while keeping core components
    decoupled. It's straightforward for us to add or remove objects as subscribers
    or publishers. We also defined a specific list of global events that represent
    every stage of a race. Therefore, we can now start sequencing and triggering behaviors
    of core components, from the start to the end of a race, and anything in between.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用事件总线，我们可以在保持核心组件解耦的同时触发行为。对我们来说，添加或删除作为订阅者或发布者的对象非常简单。我们还定义了一个特定的全局事件列表，代表比赛的每个阶段。因此，我们现在可以开始对核心组件的行为进行排序和触发，从比赛开始到结束，以及任何中间阶段。
- en: In the next section, we will review some alternative solutions to the Event
    Bus, with each solution offering a different approach that might be a better solution
    depending on context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾一些替代事件总线的方法，每个解决方案都提供了一种可能根据上下文更好的不同方法。
- en: Reviewing some alternative solutions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾一些替代解决方案
- en: 'Event systems and patterns are a vast topic, and it''s a subject matter we
    can''t cover in depth in this book. Therefore, we have prepared a shortlist of
    patterns to consider when implementing an event system or mechanism, but keep
    in mind that there''s a lot more out there, and we encourage you as a reader to
    continue exploring the topic beyond the limited scope of this book:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统和模式是一个广泛的话题，我们无法在这本书中深入探讨这个话题。因此，我们准备了一份简短的列表，供你在实现事件系统或机制时考虑，但请记住，还有更多内容，我们鼓励你作为读者在本书有限的范围内继续探索这个话题：
- en: '**Observer**: An oldie but goodie pattern in which an object (subject) maintains
    a list of objects (observers) and notifies them of an internal state change. It''s
    a pattern to consider when you need to establish a one-to-many relationship between
    a group of entities.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**：这是一个老式但实用的模式，其中一个对象（主题）维护一个对象（观察者）列表，并在内部状态发生变化时通知它们。当你需要在一组实体之间建立一对一的关系时，这是一个值得考虑的模式。'
- en: '**Event Queue**: This pattern permits us to store events generated by publishers
    in a queue and forward them to their subscribers at a convenient time. This approach
    decouples the temporal relationship between publishers and subscribers.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件队列**：这个模式允许我们将发布者生成的事件存储在队列中，并在方便的时候将它们转发给订阅者。这种方法解耦了发布者和订阅者之间的时间关系。'
- en: '**ScriptableObjects**: It''s possible to create an event system with ScriptableObjects
    in Unity. The key benefit of this approach is that it makes it easier to author
    new custom game events. If you need to build a scalable and customizable event
    system, this might be the way to go.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ScriptableObjects**：在Unity中，你可以使用ScriptableObjects创建一个事件系统。这种方法的关键优势是它使得创建新的自定义游戏事件变得更加容易。如果你需要构建一个可扩展和可定制的的事件系统，这可能是一个不错的选择。'
- en: If you are asking yourself why we are not showcasing more advanced event systems
    in this book, including those implemented with ScriptableObjects, the answer is
    that the core intent of this book is to introduce readers to design patterns,
    not overwhelm them with complexity. We offer a first-step introduction to core
    concepts, but encourage readers to seek more advanced material as they progress.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己在想为什么这本书没有展示更多高级的事件系统，包括使用ScriptableObjects实现的事件系统，答案是这本书的核心目的是向读者介绍设计模式，而不是用复杂性让他们感到不知所措。我们提供了一个核心概念的初步介绍，但鼓励读者在进步的过程中寻找更高级的材料。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we reviewed the Event Bus, a simple pattern that simplifies
    the process of publishing and subscribing to events in Unity. It's a tool that
    helps during rapid prototyping or when you have a defined list of global events
    to manage. However, it has its limits of use, and it's always wise to explore
    other options before committing to using a globally accessible event bus.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了事件总线，这是一种简化在Unity中发布和订阅事件过程的简单模式。这是一个在快速原型设计或当你有一个明确的全局事件列表需要管理时非常有用的工具。然而，它有其使用的局限性，因此在决定使用全局可访问的事件总线之前探索其他选项总是明智的。
- en: In the next chapter, we will implement a system that will allow us to replay
    player inputs. Many racing games have replay and rewind features, and with the
    Command pattern, we will attempt to build one from scratch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现一个系统，使我们能够回放玩家输入。许多赛车游戏都有回放和倒退功能，而通过命令模式，我们将尝试从头开始构建一个这样的系统。
