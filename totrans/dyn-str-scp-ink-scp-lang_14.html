<html><head></head><body><div><div><h1 id="_idParaDest-160"><em class="italic"><a id="_idTextAnchor159"/>Chapter 11</em>: Quest Tracking and Branching Narratives</h1>
			<p>In this chapter, we will review how to create an ink template for quests, track multiple quests based on this template, and show the player the values of variables across quests. In the first section, we will create an ink template and its required sections. Next, we will improve the ink template and create a <code>Quest</code> class to track multiple quests progressing independently from each other. Finally, we will show the player the results of progressing quests and view the values of change during this progression.</p>
			<p>Many larger or narrative-focused video games are composed of separate quests for the player to complete. This chapter will provide a template for creating quests in ink and will also show you how to access and manipulate this template in Unity. Using multiple quests, a branching narrative approach is possible by allowing a player to progress through each quest separately, as explained in this chapter. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Making a quest count</li>
				<li>Tracking progress across multiple quests</li>
				<li>Displaying and awarding player progression<p class="callout-heading">Important </p><p class="callout">Each topic in this chapter has a separate, completed Unity project. Each topic includes instructions that state the name of the project and where to find it.</p></li>
			</ul>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Technical requirements</h1>
			<p>The examples in this chapter have been divided into folders per project and can be found online on GitHub: <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Making a quest count</h1>
			<p>In narrative<a id="_idIndexMarker405"/> terms, a <strong class="bold">quest</strong> is a series of events connected to a character within a story. In video games, quests are a sequence of connected events experienced by the <em class="italic">player</em>. In role-playing games, a quest might include unlocking a weapon, rescuing a prince, or defeating some great evil. Each point along the way is a <em class="italic">step</em> of the quest. Translated in terms of story and code, a quest can be thought of as a series of steps where the resolution of each step unlocks the next.</p>
			<p>ink supports this pattern of smaller parts within a larger whole as stitches within a knot. Thought of in this way, each step of the quest can become its own stitch within the code, with the outcome of each stitch being able to move to the next within the larger structure. Using <code>LIST</code> in ink also allows us to define the steps we want by name, with a special knot progressing the player from one stitch to the next within the quest structure.</p>
			<p>In this section, we will learn how to design a quest template in ink and access its values in Unity across one single project, with each section building on the previous one:</p>
			<ul>
				<li>In the first section, <em class="italic">Creating a quest template in ink</em>, we will review how to use this pattern and the built-in automation available by using existing Ink functions. </li>
				<li>In the second section, <em class="italic">Choosing specific knots in Unity</em>, we will move away from ink and look at Unity. Here, we will examine how to run the template in ink, as well as some potential issues to be aware of when using certain Story API methods.<p class="callout-heading">Reminder</p><p class="callout">The completed project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a>, examples on GitHub folder, under the name <code>Chapter11,QuestProgression</code>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p></li>
			</ul>
			<p>Now let us<a id="_idIndexMarker406"/> understand the next topic where we will create a quest template.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor162"/>Creating a quest template in ink</h2>
			<p>ink<a id="_idIndexMarker407"/> stories are<a id="_idIndexMarker408"/> composed of different sections. In <a href="B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Text Flow, Choices, and Weaves</em>, we learned how ink breaks code<a id="_idIndexMarker409"/> into different sections called <code>VAR</code> and <code>LIST</code> keywords in ink, which we did in <a href="B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 4</em></a>, <em class="italic">Variables, Lists, and Functions</em>, we can create a quest that's composed of a series of steps:</p>
			<pre><strong class="bold">LIST stages = (one), (two), (three)</strong>
<strong class="bold">VAR stage = one</strong>
<strong class="bold">VAR end = false</strong></pre>
			<p>This code creates a list named <code>steps</code>, a variable named <code>step</code>, and a variable named <code>end</code> in ink. These three values keep track of the <em class="italic">quest's progression</em>. The name of each step in the quest is added as an entry to the list, with the first used as the value of the <code>stage</code> variable:</p>
			<pre>You meet an old man by the side of a dusty road with a wide hat set out in front of him. "Got any change?"
* [Sure]
    -&gt; quest
* [Not today]
    -&gt; quest.stop</pre>
			<p>The player is presented with their first options: <code>Sure</code> and <code>Not today</code>. If the first is selected, the flow moves into the <code>quest</code> knot. If the second is selected, the flow moves to a stitch inside of the <code>quest</code> knot named <code>stop</code>:</p>
			<pre>== quest
{step:
    - one: -&gt; first
    - two: -&gt; second
    - three: -&gt; third
}
-&gt; DONE</pre>
			<p>The <a id="_idIndexMarker412"/>names <em class="italic">quest</em> and <em class="italic">stop</em> were chosen specifically. The use<a id="_idIndexMarker413"/> of the word <em class="italic">quest</em> helps in understanding the code as part of a template for other quests. As will be outlined in the next section, <em class="italic">Tracking progress across multiple quests</em>, multiple <code>Story</code> objects can exist at the same time in Unity. In this case, the word is used to show the pattern.</p>
			<p>The <code>quest</code> knot contains the central logic of this pattern. Because the entries in a <code>LIST</code> in ink are Boolean values (either <code>true</code> or <code>false</code>), a multi-line comparison is used, where the order is important. The list named <code>steps</code> contains three entries, each of which are initially set to <code>true</code>. When the <code>quest</code> knot is first encountered, it will move the flow to the stitch named <code>first</code>:</p>
			<pre>= first
You empty some coins from your pocket and the old man nods. "Thanks, stranger! May the gods bless you!"
-&gt; DONE</pre>
			<p>The <code>first</code> stitch contains an unusual ending. The use of the <code>DONE</code> keyword usually signals that the story is over in ink. However, in this case, the <code>DONE</code> keyword is used to signal that the <em class="italic">step</em> is done. Instead of diverting to the <code>quest</code> knot or another section, the story seemingly stops. Progression happens using a combination of the <code>LIST_MIN()</code> function and the subtraction (<code>-</code>) operation for lists in Ink:</p>
			<pre>== progress
~ steps -= LIST_MIN(steps)
~ step = LIST_MIN(steps)
-&gt; quest</pre>
			<p>Within the <code>progress</code> knot, each entry is removed (subtracted) and the top (minimum) value is used as part of the <code>step</code> variable. Each use of this knot <em class="italic">progresses</em> the quest by removing a step from the list and then using the top remaining one each time. However, the knot itself is not accessed directly. Instead, it is used externally by Unity.</p>
			<p>In this section, we learned how each step can be divided into stitches as part of a knot named <code>quest</code>. By using a <code>LIST</code> and different variables in ink, progress can be tracked across the <a id="_idIndexMarker414"/>quest. In the next section, we will learn how an ink <a id="_idIndexMarker415"/>template can be used as a series of steps to access the <code>progress</code> knot externally in Unity.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>Choosing specific knots in Unity</h2>
			<p>Different <a id="_idIndexMarker416"/>methods <a id="_idIndexMarker417"/>and properties of the Story API provided by the ink-Unity Integration plugin were covered in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, and <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>. However, what was not covered in those chapters was a useful but potentially very dangerous method named <code>ChoosePathString()</code>. In this section, we will look at an example of how this method can be used safely.</p>
			<p>Internally, the ink runtime uses the term "path string" to describe any knot that is part of a story. When loaded, these can be accessed by using the <code>ChoosePathString()</code> method, which forcibly moves the story to that section. In most cases, this is unwanted behavior, as its use will disregard any existing tunnels or threads. It can be thought of as <em class="italic">ripping</em> the flow away from wherever it was and dropping it into a new location.</p>
			<p>As part of the ink runtime, variables are global. This means that while their values might be changed as part of the flow of a story, they exist outside of it. The values of variables are maintained despite any uses of the <code>ChoosePathString()</code> method. In other words, by carefully avoiding any structures that might be disrupted by its use, the <code>ChoosePathString()</code> method can be carefully used in projects.</p>
			<p>In the previous section, the ink <code>progress</code> knot was introduced. To choose this path string in Unity using the <code>ChoosePathString()</code> method, only its name is needed:</p>
			<pre>public void Progress()
{
     <strong class="bold">InkStory.ChoosePathString("progress");</strong>
     FlipProgress();
    UpdateContent();
}</pre>
			<p>When the <code>ChoosePathString()</code> method is used with the <code>progress</code> ink knot, it <em class="italic">does</em> disrupt the <a id="_idIndexMarker418"/>flow of the story that's kept within the <code>InkStory</code> C# variable. However, as <a id="_idIndexMarker419"/>we learned, the values of variables are maintained throughout the story because of their global nature. The use of the <code>progress</code> ink knot <em class="italic">progresses</em> the quest to its next step by updating the variables each time.</p>
			<p>The code also includes calls to two other methods: <code>FlipProgress()</code> and <code>UpdateContent()</code>. The first method sets a <code>Button</code> game object in Unity to inactive by using the <code>SetActive()</code> method in Unity. When a game object is turned off (set to inactive) in Unity, it does not appear on the screen. This code effectively sets the game object to appear as needed and to disappear when the player is selecting dialogue options:</p>
			<pre>void FlipProgress() {
<strong class="bold">ProgressButton.gameObject.SetActive(!ProgressButton.gameObject.activeSelf);</strong>
}</pre>
			<p>The second method, <code>UpdateContent()</code>, follows the pattern we first introduced in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, where a <code>Prefab</code> is used to dynamically create <code>Button</code> game objects as needed:</p>
			<pre>void UpdateContent()
{
     DestroyChildren(OptionsPanel.transform);
     DialogueText.text = InkStory.ContinueMaximally();
     foreach (Choice in InkStory.currentChoices)
     {
          <strong class="bold">Button choiceButton = Instantiate(ButtonPrefab,</strong>
<strong class="bold">             OptionsPanel.transform);</strong>
           choiceButton.onClick.AddListener(delegate
           {
                InkStory.ChooseChoiceIndex(choice.index);
                FlipProgress();
                UpdateContent();
           });
             Text choiceText =
             choiceButton.GetComponentInChildren&lt;Text&gt;();
           choiceText.text = choice.text;
      }
}</pre>
			<p>In this section, we <a id="_idIndexMarker420"/>learned how to create a template for quests in ink. Using a<a id="_idIndexMarker421"/> knot and then individual stitches for each step, the parts were divided into different sections. Next, we looked at the <code>progress</code> ink knot. After that, we looked at Unity and using the <code>ChoosePathString()</code> method. While it can be potentially dangerous with larger projects using more advanced techniques, using variables in the ink quest template helped maintain their values. Finally, at the end of this section, the <code>ChoosePathString()</code> method in Unity was paired with the <code>progress</code> knot in ink. By using this knot, the Unity code could <em class="italic">progress</em> the quest, with ink updating its internal variables.</p>
			<p>In the next section, we will continue with the pattern we looked at in this section by extending part of the quest template in ink and creating <code>Quest</code> and <code>Dialogue</code> classes in C#. These <a id="_idIndexMarker422"/>will <a id="_idIndexMarker423"/>allow us to track multiple quests at the same time.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Tracking progress across multiple quests</h1>
			<p>In the <a id="_idIndexMarker424"/>previous section, we created an ink template for a quest and then moved into Unity to create the user interface to progress the quest using the <code>ChoosePathString()</code> method. This forced the flow within ink to move to a specific location. In this section, we move beyond a single quest and start tracking multiple quests at the same time. To do this, the ink template needs additional variables. For this, we will need the <code>Quest</code> and <code>Dialogue</code> classes in C#. We also will depart from using a single ink file and start using multiple files. For every quest, we will create a separate file and use the <code>Quest</code> class to track the progress of each in Unity with the <code>Dialogue</code> class, which handles creating options for a player to choose from during each step in the quest.</p>
			<p>First, we will update the ink template with a new variable we will access later in Unity. Then, we will create the <code>Quest</code> and <code>Dialogue</code> classes in Unity. After that, we will access multiple ink files in Unity to present an interface containing multiple quests. Finally, we will allow a user to toggle between quests and progress them independently of each other.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a><em class="italic"> examples on GitHub</em> folder, under the name <em class="italic">Chapter11-MultipleQuests</em>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor165"/>Building on the ink quest template</h2>
			<p>As we<a id="_idIndexMarker425"/> saw in <a href="B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123"><em class="italic">Chapter 8</em></a>, <em class="italic">Story API – Accessing ink Variables and Functions</em>, we can access ink variables that have been created with the <code>VAR</code> keyword using the <code>variablesState</code> property in Unity. This allows us to retrieve the value of a variable based on its name. With that in mind, the existing ink template can be expanded to include a new variable for each quest – its <code>name</code>.</p>
			<p>By understanding that the compiled ink files will be operated from Unity, we can anticipate certain needs we will have with quests. For example, a quest usually has a <em class="italic">name</em>. We can then define this variable alongside our existing values in Ink:</p>
			<pre>LIST steps = (one), (two), (three)
VAR step = one
VAR end = false
<strong class="bold">VAR name = "Old Man's Change"</strong></pre>
			<p>Once we know <a id="_idIndexMarker426"/>that the <code>name</code> variable exists in ink, we can read it in Unity. However, unlike what was shown in the previously section, we will need to observe the <code>end</code> ink variable as well: </p>
			<pre>InkStory = new Story(text);
Name = (string)InkStory.variablesState["name"];
<strong class="bold">End = (bool)InkStory.variablesState["end"];</strong>
<strong class="bold">InkStory.ObserveVariable("end", delegate</strong>
<strong class="bold">{</strong>
      <strong class="bold">End = (bool)InkStory.variablesState["end"];</strong>
<strong class="bold">});</strong></pre>
			<p>These small changes may not seem important, but by establishing a pattern where certain variables exist (<code>name</code> and <code>end</code>) and all files containing quests will also have a knot named <code>progress</code> (as defined in the previous section), we can write any quests we want if those parts remain the same.</p>
			<p>Once these variables have been prepared, we can start creating the <code>Quest</code> and <code>Dialogue</code> classes, which will hold the values we defined in ink and read them in Unity.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor166"/>Making Quest and Dialogue classes in Unity</h2>
			<p>In <a id="_idIndexMarker427"/>the<a id="_idIndexMarker428"/> previous <a id="_idIndexMarker429"/>section, we<a id="_idIndexMarker430"/> combined a simple presentation of dialogue options with the values and methods to progress the single quest presented. In this section, we will break that functionality into two new classes in Unity: <code>Quest</code> and <code>Dialogue</code>.</p>
			<p>Most of the <code>Quest</code> class was shown in the previous section. However, its purpose is to hold a <code>Story</code> object <a id="_idIndexMarker431"/>and to <a id="_idIndexMarker432"/>expose a <a id="_idIndexMarker433"/>method named <code>Progress()</code> that<a id="_idIndexMarker434"/> internally calls the <code>ChoosePathString()</code> method:</p>
			<pre>using Ink.Runtime;
public class Quest
{
    public Story InkStory;
    public string Name;
    public string Description;
    public bool End;
    public Quest(string text)
    {
        InkStory = new Story(text);
        Name = (string)InkStory.variablesState["name"];
        End = (bool)InkStory.variablesState["end"];
        InkStory.ObserveVariable("end", delegate
        {
            End = (bool)InkStory.variablesState["end"];
        });
    }
    <strong class="bold">public void Progress()</strong>
    <strong class="bold">{</strong>
        <strong class="bold">InkStory.ChoosePathString("progress");</strong>
    <strong class="bold">}</strong>
}</pre>
			<p>The <code>Quest</code> class is small because it is used by other classes. Its sole purpose is to contain the quest (ink story) and provide a way to progress the quest (via the <code>Progress()</code> method). </p>
			<p>The new<a id="_idIndexMarker435"/> class, <code>Dialogue</code>, performs<a id="_idIndexMarker436"/> most <a id="_idIndexMarker437"/>of the work to create<a id="_idIndexMarker438"/> the <code>Button</code> game objects needed and to remember what the last line of dialogue was as a reminder for the player. Its <code>UpdateContent()</code> method looks like the example code that was first shown in <a href="B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 7</em></a>, <em class="italic">Unity API – Making Choices and Story Progression</em>, except for using the new <code>Quest</code> class:</p>
			<pre>public void UpdateContent()
{
     DestroyChildren();
        
     <strong class="bold">if(quest.InkStory.canContinue)</strong>
     {
           <strong class="bold">DialogueText.text =</strong>
<strong class="bold">             quest.InkStory.ContinueMaximally();</strong>
           lastDialogue = DialogueText.text;
      }
      else
     {
            DialogueText.text = lastDialogue;
     }</pre>
			<p>With the updated ink template from the first section and the introduction of the <code>Quest</code> and <code>Dialogue</code> classes in this section, two more parts are needed:</p>
			<ul>
				<li>Quests need to be based on compiled JSON files</li>
				<li>Players need to be able to toggle which quest they are progressing</li>
			</ul>
			<p>In the<a id="_idIndexMarker439"/> next <a id="_idIndexMarker440"/>section, we <a id="_idIndexMarker441"/>will <a id="_idIndexMarker442"/>start with the first part by learning how to read files and creating a new <code>Quest</code> class per file found. </p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor167"/>Organizing multiple quest files</h2>
			<p>In the <a id="_idIndexMarker443"/>previous examples in this book, a single ink file was used per project. This section will break away from that pattern. To track multiple quests, we will define each quest in its own file and then read the compiled JSON files. The <code>Quest</code> class, which we looked at in the previous section, will hold the contents and expose some of the values in each file. The <code>Dialogue</code> class will create the options the player will see based on the <code>Quest</code> class's values. First, however, we will need to read the files.</p>
			<p>This book follows the recommended naming convention of Unity folders and has placed all the Ink files in a folder named <code>Ink</code>. Using the <strong class="bold">Compile All Ink Automatically</strong> option in the <strong class="bold">Project Settings</strong> window, each created ink file will also contain a JSON file:</p>
			<div><div><img src="img/Figure_11.1_B17597.jpg" alt="Figure 11.1 – Compiled JSON files in the Ink folder&#13;&#10;" width="457" height="175"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Compiled JSON files in the Ink folder</p>
			<p>Because Unity can run on many different operating systems, it exposes the <code>Assets</code> folder (shown in the <code>Application.dataPath</code>. This is the <em class="italic">path</em> to the data, as part of the currently running application. Based on this value, any additional folders can be found, and their files can be<a id="_idIndexMarker444"/> accessed:</p>
			<pre>void GetFiles()
{
     <strong class="bold">string inkPath = Application.dataPath + "/Ink/";</strong>
     foreach(string file in Directory.GetFiles(inkPath,
       "*.json"))
     {
           <strong class="bold">string contents = File.ReadAllText(file);</strong>
           <strong class="bold">quests.Add(new Quest(contents));</strong>
     }  
}</pre>
			<p>By using the <code>Application.dataPath</code> property, each compiled ink file (JSON file) can be read, and a new object based on the <code>Quest</code> class is created. This not only allows each quest to operate independently of each other via their quest progression, but it also exposes values that the <code>Dialogue</code> class can use to present different options to the player.</p>
			<p>In the next and final section, we will write some code that will allow a player to toggle between which quest is active for them and see the <code>Quest</code> and <code>Dialogue</code> classes in action.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor168"/>Toggling quests</h2>
			<p>In Unity, the <code>Toggle</code> game <a id="_idIndexMarker445"/>object allows a user to select a single item among a group of items. For its usage in the project that's part of this section, a <code>Toggle</code> prefab must be created. Like the usage of <code>Button</code> game objects, these are created as needed. As each <code>Toggle</code> game object is based on an object using the <code>Quest</code> class, this means the <code>GetFiles()</code> method (shown in the previous section, <em class="italic">Organizing multiple quest files</em>) is run first, and the resulting quests are used to make the <code>Toggle</code> game<a id="_idIndexMarker446"/> objects:</p>
			<pre>void CreateQuestToggles()
{
      foreach(Quest q in quests)
      {
     <strong class="bold">Toggle questToggle = Instantiate(QuestTogglePrefab, </strong>
<strong class="bold">       QuestPanel.transform);</strong>
     <strong class="bold">questToggle.group =QuestPanel.GetComponent</strong>
<strong class="bold">       &lt;ToggleGroup&gt;();</strong>
            
     Text questToggleText = questToggle
       .GetComponentInChildren&lt;Text&gt;();
     questToggleText.text = q.Name;
     }
}</pre>
			<p>The <code>CreateQuestToggles()</code> method references a component named <code>ToggleScript</code>. This is a <code>Script</code> component that is part of each <code>Toggle</code> prefab. Each time one is created, its values are set:</p>
			<pre>ToggleScript ts = questToggle.GetComponent&lt;ToggleScript&gt;();
<strong class="bold">ts.quest = q;</strong>
<strong class="bold">ts.DialogueText = DialogueText;</strong>
<strong class="bold">ts.ButtonPrefab = ButtonPrefab;</strong>
<strong class="bold">ts.OptionsPanel = OptionsPanel;</strong>
<strong class="bold">ts.ProgressPanel = ProgressPanel;</strong>
<strong class="bold">ts.ProgressButtonPrefab = ProgressButtonPrefab;</strong></pre>
			<p>This process, starting with the <code>GetFiles()</code> method, creates objects based on the <code>Quest</code> class first. Next, <code>Toggle</code> prefabs are created, and values are passed to its <code>Script</code> component. Internally, the <code>Toggle</code> prefab creates an additional <code>Script</code> component based on the <code>Dialogue</code> class:</p>
			<pre><strong class="bold">dialogue = gameObject.AddComponent&lt;Dialogue&gt;();</strong>
dialogue.quest = quest;
dialogue.DialogueText = DialogueText;
dialogue.ButtonPrefab = ButtonPrefab;
dialogue.OptionsPanel = OptionsPanel;</pre>
			<p>The reason for<a id="_idIndexMarker447"/> this multiple-step process of creating objects based on the <code>Quest</code> class, and then leading to the <code>Dialogue</code> class, is to allow each <code>Toggle</code> prefab to control what is shown to the player:</p>
			<div><div><img src="img/Figure_11.2_B17597.jpg" alt="Figure 11.2 – Quest selection and options shown to the player&#13;&#10;" width="629" height="485"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – Quest selection and options shown to the player</p>
			<p>Upon clicking on a <code>Toggle</code> prefab, its object is enabled based on the <code>Dialogue</code> class, showing the current text and options to the player. These, in turn, are based on the <code>Quest</code> class's values, as passed to the <code>Dialogue</code> class.</p>
			<p>The combined effect of the code is to create separate quests. Depending on which is active, as determined by each <code>Toggle</code> prefab selected by the player, they will see different dialogue options and be presented with the ability to progress each quest independently of each other at the end of each step. This combines the ink template that we created in the first section with a multiple-quest approach, as shown in this section, which uses multiple files and adds the ability to progress across individual quests, independent of each other.</p>
			<p>In the next section, we will examine how to award player progression by passing information <a id="_idIndexMarker448"/>between quests. This will build on the project we created for this section and the concepts from the first section.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Displaying and awarding player progression</h1>
			<p>In <a id="_idIndexMarker449"/>programming, there<a id="_idIndexMarker450"/> are two approaches to accessing values in one system from another: <strong class="bold">polling</strong> and <strong class="bold">events-based</strong>. Either <a id="_idIndexMarker451"/>a value can be checked if it has changed (<em class="italic">polling</em>) or<a id="_idIndexMarker452"/> one system can wait for a message (<em class="italic">event</em>) from the other to signal that a value has changed. Because the second system must wait for an event to happen, this is <a id="_idIndexMarker453"/>often known as the <strong class="bold">observer pattern</strong> because the second system is <em class="italic">observing</em> events.</p>
			<p>In the first section, we saw an example of polling in action. Each time a step of the quest came to its end, the Unity code checked (<em class="italic">polled</em>) the ink values to see if it should show a <code>Button</code> game object and allow the player to progress the quest. The second section moved us closer to an events-based approach, where the <code>ObserveVariable()</code> method was used within the <code>Quest</code> class. In the second project, whenever the <code>end</code> ink variable changed, it updated the <code>End</code> property of the <code>Quest</code> class in Unity. As this value (the <code>End</code> property) was used as part of determining whether the quest could progress, this made the second project more dynamic than the one that was used in the first project.</p>
			<p>To award a player for completing a quest or achieving some outcome as part of one quest in another, information needs to be passed between them. Because the ink runtime already supports an events-based approach via its <code>ObserveVariable()</code> and <code>ObserveVariables()</code> named methods, this makes the process slightly easier. However, as we introduced in the previous section, using a <code>Quest</code> class means each ink story is now independent of each other.</p>
			<p>In this section, we will start by creating a way for each <code>Quest</code> class to share changes as they happen while a player is progressing them. We will end by learning how to show the player this information as they complete different quests.</p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">The<a id="_idIndexMarker454"/> completed <a id="_idIndexMarker455"/>project for this section can be found in the <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a><em class="italic"> examples on GitHub</em> folder, under the name <em class="italic">Chapter11-TrackingQuests</em>. Only select parts of the code will be shown as they relate to the concepts examined in the sections of this topic.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Tracking quest values</h2>
			<p>The <code>Story</code> class <a id="_idIndexMarker456"/>method, <code>ObserveVariables()</code>, can track different <a id="_idIndexMarker457"/>variables based on their names. However, the existing ink template contains the variables it uses to track progression. This means that the first step of tracking quest values is to make a list of variables to exclude from tracking as part of an expanded <code>Quest</code> class:</p>
			<pre>public Story InkStory;
public string Name;
public string Description;
public bool End;
<strong class="bold">public List&lt;string&gt; excludeVariables = new List&lt;string&gt;(){ "step", "steps", "name", "end" };</strong></pre>
			<p>Next, all the variables contained in the <code>variablesState</code> property, excluding those in the created list used to track quest progression, need to be tracked. This means that for each variable, it can be added to a separate list to be passed to the <code>Story</code> method known as <code>ObserveVariables()</code>. This can be part of the <code>ObserveVariables()</code> method, as part of the <code>Quest</code> method, so that it matches the one on the <code>Story</code> class:</p>
			<pre><strong class="bold">public void ObserveVariables(Story.VariableObserver callback)</strong>
{
      List&lt;string&gt; variables = new List&lt;string&gt;();
      foreach(string n in InkStory.variablesState)
     {
           if(!excludeVariables.Contains(n))
           {
                variables.Add(n);
           }
     }
     <strong class="bold">InkStory.ObserveVariables(variables, callback);</strong>
}</pre>
			<p>The <a id="_idIndexMarker458"/>new <code>ObserveVariables()</code> method that was added<a id="_idIndexMarker459"/> to the <code>Quest</code> class accepts a single parameter, <code>Story.VariableObserver</code>. Internally, the <code>Story</code> class defines a <code>delegate</code> method called <code>VariableObserver</code>. Using the same type for the new method allows other methods to be passed through the <code>Quest</code> method to the <code>Story</code> method of the same name. In other words, the new method works the same as the existing one, but it will exclude a specific list of variable names.</p>
			<p>While observing variables, there also needs to be a way to update the values of variables across all quests whenever a value changes in one. Using the existing <code>variablesState</code> property, a new method can be added to the <code>Quest</code> class named <code>UpdateVariable()</code>:</p>
			<pre>public void UpdateVariable(string name, object value)
{
        <strong class="bold">if(InkStory.variablesState.GlobalVariableExistsWith</strong>
<strong class="bold">          Name(name))</strong>
     {
<strong class="bold">          if (!InkStory.variablesState[name].Equals(value))</strong>
           {
                InkStory.variablesState[name] = value;
           }
     }
}</pre>
			<p>Inside the <code>UpdateVariable()</code> method<a id="_idIndexMarker460"/> are two important <a id="_idIndexMarker461"/>checks. The first uses the <code>GlobalVariableExistsWithName()</code> method. This method checks if a variable exists. Without this check, if one quest added a variable another did not have, the entire project could crash. The second check verifies whether the variable to be updated does not already have the same value. Without this second check, updating a variable would trigger a variable change in any other quests, which would trigger another update. This would eventually cause a crash as quests would be trying to update each other in an endless loop.</p>
			<p>Between the two new methods, <code>ObserveVariables()</code> and <code>UpdateVariable()</code>, one more part is needed: the two methods must be combined. Based on the project from the second section, <em class="italic">Tracking progress across multiple quests</em>, the <code>InkStoryScript</code> code is the best place to add this combination. The reason for this placement is because this will allow each quest to be configured as part of the existing loop:</p>
			<pre>foreach(Quest q in quests)
{
     <strong class="bold">q.ObserveVariables((name, value) =&gt;</strong>
     <strong class="bold">{</strong>
          <strong class="bold">UpdateAllQuests(name, value);</strong>
     <strong class="bold">});</strong>
}</pre>
			<p>This new code references an additional method, <code>UpdateAllQuests()</code>. When passed the name of a variable and its value, this new method works through the existing quests and updates their values by calling <code>UpdateVariable()</code> per quest:</p>
			<pre>void UpdateAllQuests(string name, object value)
{
     foreach (Quest q in quests)
     {
            <strong class="bold">q.UpdateVariable(name, value);</strong>
     }
}</pre>
			<p>In this<a id="_idIndexMarker462"/> section, we <a id="_idIndexMarker463"/>have defined multiple new methods. We added two to the <code>Quest</code> class called <code>ObserveVariables()</code> and <code>UpdateVariable()</code>. These detect changes using the event approach. ink will signal to Unity when a variable in one of the quests changes. We also added code to <code>InkStoryScript</code> by using a new method called <code>UpdateAllQuests()</code>, which will update the same variable in other quests.</p>
			<p>In the next section, we will finalize this project. Detecting changes and updating other quests help keep all of them updated as changes happen. Next, we need to show data to the player as changes happen.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor171"/>Showing player progress</h2>
			<p>In the <a id="_idIndexMarker464"/>previous section, we created the necessary code to keep all the variables used across quests updated. To show the player this data, we must add a new game object named <code>StatisticsText</code>. Next, we need to use a special keyword in C#: <code>static</code>.</p>
			<p>Any method or property using the <code>static</code> keyword in C# exists outside of any instances of the class. This means that the property can be accessed or the method can be called anywhere in the project. However, this comes with a major caveat: any <code>static</code> method can only access <code>static</code> properties. To allow another class (<code>Dialogue</code>) to be able to call a <code>static</code> method in <code>InkStoryScript</code> (which holds all the quests), the existing <code>quests</code> and new <code>StatisticsText</code> variable must both use the <code>static</code> keyword:</p>
			<pre>public GameObject QuestPanel;
public Toggle QuestTogglePrefab;
public Text DialogueText;
public Button ButtonPrefab;
public GameObject OptionsPanel;
public GameObject ProgressPanel;
public Button ProgressButtonPrefab;
<strong class="bold">public static GameObject StatisticsText;</strong>
<strong class="bold">static List&lt;Quest&gt; quests;</strong></pre>
			<p>With the <code>quests</code> and <code>StatisticsText</code> properties, they can be<a id="_idIndexMarker465"/> accessed by a new method named <code>ShowStatistics()</code>:</p>
			<pre>public static void ShowStatistics()
{
     StatisticsText = 
       GameObject.Find("/Canvas/Right/StatisticsText");
     Dictionary&lt;string, object&gt; vars = new
       Dictionary&lt;string, object&gt;();
     foreach (Quest q in quests)
     {
           foreach(string s in q.InkStory.variablesState)
           {
                if(!vars.ContainsKey(s) &amp;&amp;
                  !q.excludeVariables.Contains(s))
                {
                      vars.Add(s,
                        q.InkStory.variablesState[s]);
                }
           }
     }
     Text stats = StatisticsText.GetComponent&lt;Text&gt;();
     stats.text = "";
      foreach (KeyValuePair&lt;string, object&gt; entry in vars)
      {
           stats.text += entry.Key + ": " + entry.Value +
             "\n";
      }
}</pre>
			<p>The new <code>ShowStatistics()</code> method uses a <code>Dictionary&lt;string, object&gt;</code>. This<a id="_idIndexMarker466"/> combines the name of the variable (<code>string</code>) with its value (<code>object</code>). However, a <code>Dictionary</code> in C# comes with an obstacle: it can only contain unique keys. In the <code>ShowStatistics()</code> method, the use of the <code>ContainsKey()</code> method prevents this issue.</p>
			<p>To set up a method that can be called by another class, the new <code>ShowStatistics()</code>code must be placed within the <code>Dialogue</code> class as part of its <code>UpdateContent()</code> method, after the creation of the <code>Button</code> game objects based on the current choices:</p>
			<pre>foreach (Choice in quest.InkStory.currentChoices)
{
     Button choiceButton = Instantiate(ButtonPrefab,
       OptionsPanel.transform);
     choiceButton.onClick.AddListener(delegate
     {
           quest.InkStory.ChooseChoiceIndex(choice.index);
           UpdateContent();
     });
     Text choiceText =       choiceButton.GetComponentInChildren&lt;Text&gt;();
       choiceText.text = choice.text;
}
<strong class="bold">InkStoryScript.ShowStatistics();</strong></pre>
			<p>The new code will <a id="_idIndexMarker467"/>always show the latest values of the variables as the values are updated. Because each quest handles updating its variables based on an event-based approach, any user action for making choices or selecting a quest will update all the values being tracked by the project and constantly show player progression.</p>
			<p>In this section, we awarded player progression by showing the player's the updated values. We started by adding some code from the previous section to constantly update the variables with the same names across all quests. This keeps all the quests connected. Then, we created a <code>ShowStatistics()</code> method to show these values and updated a <code>Text</code> game object with their names and values.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor172"/>Summary</h1>
			<p>We started this chapter by creating an ink template. By defining variables and a <code>progress</code> knot in ink, we can move through the various sections of a quest as individual stitches within a larger knot. Next, we looked at the <code>ChoosePathString()</code> method, which can forcibly move a story to a new section.</p>
			<p>In the second section, we broke away from single files and developed a <code>Quest</code> class. Each object based on the <code>Quest</code> class contained an ink <code>Story</code> object based on different files and a method named <code>Progress()</code>, which calls the <code>ChoosePathString()</code> method internally. As part of this section, we learned how the <code>Quest</code> and <code>Dialogue</code> classes can help organize functionality into different classes.</p>
			<p>Finally, we displayed the name and values of variables. First, we added new methods to detect variable changes in any quest using an events-based approach. This triggered other variables with the same name in other quests to have their values updated. Then, we added the <code>ShowStatistics()</code> method to display these updating values.</p>
			<p>In the next chapter, <a href="B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a>, <em class="italic">Procedural Storytelling with ink</em>, we will review the basics of procedurally organizing different story sections and content. While looking at two approaches, either coding values in ink or loading data into ink dynamically, we will examine when one approach might be better, depending on the context.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Q&amp;A</h1>
			<ol>
				<li>What is a quest?</li>
				<li>What is the name of the knot that's used to progress a quest based on the ink template shown in this chapter?</li>
				<li>How does the <code>ChoosePathString()</code> method work?</li>
				<li>What is the name of the global property where Unity records the path for the data of the application?</li>
				<li>What is the difference between polling and events-based approaches?</li>
			</ol>
		</div>
	</div></body></html>