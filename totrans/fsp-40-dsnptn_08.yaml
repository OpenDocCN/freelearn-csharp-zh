- en: Chapter 8. Data Crunching – Data Transformation Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。数据压缩 – 数据转换模式
- en: After dealing with advanced patterns of the function definition and application
    in the previous chapter, I want to revisit the topic that was just slightly scratched
    in [Chapter 6](text00053.html#ch06 "Chapter 6.  Sequences - The Core of Data Processing
    Patterns") , *Sequences - The Core of Data Processing Patterns* in connection
    with sequences. There, I claimed that the quite bulky `Collection.seq` library
    absorbs and implements just a handful of universal data processing patterns. Then
    I regrouped the library members by assigning to one of these patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章处理了函数定义和应用的先进模式之后，我想回顾一下在第 6 章 *序列 - 数据处理模式的核心* 中刚刚略微触及的主题，即与序列相关的内容。在那里，我声称相当庞大的
    `Collection.seq` 库吸收并实现了少数几个通用数据处理模式。然后我根据这些模式重新分组了库成员。
- en: This chapter digs deeper into these patterns of data transformation that are
    applicable not only to sequences, but also to other data collections. The goal
    of this chapter is to help you develop the skill to convey your data processing
    needs with functions belonging to a handful of typical polymorphic transformation
    categories composed of a handful of combinators, and by operating upon data collection
    types that are best suitable for the task at hand. This approach allows you to
    uniformly cover the widest assortment of specific data transformations. Sticking
    to the above approach is essential for F# programmer practitioners as it effectively
    curbs the development of lengthy custom solutions without compelling reasons and
    overall adds to the positive properties of F# programs, such as succinctness,
    correctness, and performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将进一步探讨这些数据转换模式，这些模式不仅适用于序列，也适用于其他数据集合。本章的目标是帮助您掌握使用少量典型多态转换类别中的函数来表达数据处理需求的能力，这些类别由少量组合子组成，并通过操作最适合当前任务的数据集合类型来实现。这种方法允许您统一覆盖最广泛的具体数据转换。坚持上述方法对于
    F# 程序员实践者至关重要，因为它有效地抑制了没有充分理由而开发冗长自定义解决方案的趋势，并总体上增加了 F# 程序的积极属性，如简洁性、正确性和性能。
- en: 'In this chapter, we will inspect:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查：
- en: How normalization of data transformation libraries in F# 4.0 reflects upon underlying
    transformation patterns commonalities. These commonalities have a polymorphic
    nature being applicable to the various data collections that the libraries aim.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 4.0 中数据转换库的规范化如何反映在底层转换模式共性上。这些共性具有多态性，适用于库旨在处理的各种数据集合。
- en: How the transformation patterns scooped in [Chapter 6](text00053.html#ch06 "Chapter 6. 
    Sequences - The Core of Data Processing Patterns") , *Sequences - The Core of
    Data Processing Patterns* reveal themselves over various data collections.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 6 章](text00053.html#ch06 "第 6 章。序列 - 数据处理模式的核心") *序列 - 数据处理模式的核心* 中收集的转换模式如何在各种数据集合中展现出来。
- en: It will be a long trip, so please stay with me, cool and hydrated.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一次漫长的旅程，所以请和我一起坚持，保持冷静和水分充足。
- en: Core data transformation libraries in F# 4.0
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 4.0 的核心数据转换库
- en: 'One of the enhancements to the FSharp.Core run-time brought by F# 4.0 is **normalized
    data collection modules** ([https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/](https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/)
    ). It is quite interesting that this development:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: F# 4.0 带给 FSharp.Core 运行时的一项增强是 **规范化的数据集合模块** ([https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/](https://blogs.msdn.microsoft.com/fsharpteam/2014/11/12/announcing-a-preview-of-f-4-0-and-the-visual-f-tools-in-vs-2015/)
    )。这个发展非常有趣：
- en: Confirms the commonality of data processing patterns across data processing
    platforms. Functions such as `map` or `filter` can be found in functional programming
    languages such as F#, query tools such as **LINQ** , and scripting engines such
    as **PowerShell** , to name a few.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证实了数据处理模式在数据处理平台间的共性。例如，`map` 或 `filter` 函数可以在 F# 等函数式编程语言中找到，在 **LINQ** 等查询工具和
    **PowerShell** 等脚本引擎中也可以找到，仅举几例。
- en: Recognizes that concrete functions belonging to these patterns are polymorphic
    and may be uniformly apply across different data collection types. F# 4.0 successfully
    delivers this polymorphism over the most frequently used data collection types,
    namely for `Array` , `List` , and `Seq` modules.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到属于这些模式的具体函数是多态的，并且可能被统一应用于不同的数据集合类型。F# 4.0 成功地将这种多态性应用于最常用的数据集合类型，即 `Array`、`List`
    和 `Seq` 模块。
- en: Overall, this library normalization added 95 new optimized per collection type
    function implementations to F# 4.0 data crunching offering. This addition bumps
    the overall amount of individual functions in the previously mentioned three collection
    modules to 309 (as of April 2016), which is definitely a sizable result. However,
    it would be really challenging for a random developer to memorize and recall this
    arrangement by heart without recognizing some formative principles.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这个库为 F# 4.0 数据处理功能增加了 95 个针对不同集合类型的优化函数实现。这一增加使得之前提到的三个集合模块中的单个函数总数达到了
    309 个（截至 2016 年 4 月），这无疑是一个相当大的成果。然而，对于一个随机开发者来说，在没有认识到一些形成性原则的情况下，要凭记忆和回忆这种安排是非常具有挑战性的。
- en: Considering that most of the functions apply uniformly to three base collection
    types (some of them naturally do not apply to some concrete collections; for example,
    `toList` does not apply to `List` ), this still leaves 117 (as of April 2016)
    *different function names* just for the base data collections. And do not forget
    about a certain number of functions related to less widely used data collections,
    such as `set` , `IDictionary` , or `Array2D` . How should you approach this variety?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到大多数函数都统一应用于三种基础集合类型（其中一些函数自然不适用于某些具体集合；例如，`toList` 不适用于 `List` ），这仍然留下了 117
    个（截至 2016 年 4 月）*不同的函数名称* 仅用于基础数据集合。而且别忘了与较少使用的数据集合相关的某些函数，例如 `set`、`IDictionary`
    或 `Array2D` 。你应该如何处理这种多样性？
- en: Fortunately, the number of data transformation patterns is just a handful. Recognizing
    the underlying pattern most often imposes an order on associated library functions,
    leaving just a dozen or so functions associated with each pattern. Such categorized
    amounts are much easier to recall.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，数据转换模式只有少数几种。识别底层模式通常会对相关库函数施加顺序，使得每种模式只关联十几个函数。这样的分类数量更容易回忆。
- en: In the rest of the chapter, we will examine these concealed patterns and their
    correspondent cohesive function groups. The provided idiomatic code examples facilitate
    the pattern retention, recognition, and reuse.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将检查这些隐藏的模式及其相应的凝聚函数组。提供的惯用代码示例有助于模式的保留、识别和重用。
- en: Data transformation patterns
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据转换模式
- en: 'A good question about data transformation libraries richness would be: Where
    does such an overwhelming variety come from in the first place? Why do designers
    of F# include as many as hundred-something functions over base data collections
    into the *core* library?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据转换库丰富性的一个好问题是：这种压倒性的多样性最初是从哪里来的？为什么 F# 的设计者将如此多的函数（多达一百多个）包含到基础数据集合的 *核心*
    库中？
- en: 'I believe a single "right" answer to this question simply does not exist. However,
    some clues may come from considering a typical **ETL - Extract, Transform, Load**
    ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) enterprise data crunching process. In the world of mutable collections and arbitrarily
    changing states, this operation can be expressed as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个问题没有单一的“正确”答案。然而，从考虑典型的 **ETL - 提取、转换、加载** ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) 企业数据处理流程中，可能会得到一些线索。在可变集合和任意变化的状态的世界中，这个操作可以表达如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This C#-like pseudocode demonstrates how literally gazillions of possible data
    transformations can be hidden behind the same few opaque lines of code. We cannot
    say anything about the details until we meticulously delve into the implementation
    of each of the above pieces, find out what it does, how it gets to the data, and
    how it shares the mutating state with other involved pieces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类似于 C# 的伪代码展示了数以亿计的可能数据转换如何被隐藏在几行不透明的代码背后。我们无法对这些细节做出任何评论，除非我们仔细研究上述每个组件的实现，找出它们的功能、如何获取数据以及如何与其他相关组件共享修改状态。
- en: 'Now let''s express the semantically similar chain of activities in a more functional
    manner as following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以更函数式的方式表达语义上相似的系列活动如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding snippet tells a better story than its imperative sibling. We can
    see right away that `extractData` is a collection generator function that is based
    on certain input parameters `params` that produce the initial `inputCollection`
    function out of some sort of persistent store. This collection is given as an
    input parameter to the transformation function `transformData` that produces as
    a result the output collection `outputCollection` . Finally, this collection is
    given to the data loader function `loadData` , and it ends up being stored back
    into the persistent store. Given that the communication with the persistent store
    is implemented in an *idempotent* manner and the involved functions are referentially
    transparent, this chain of transformations can be replayed an arbitrary number
    of times with the same results.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段比它的命令式兄弟讲述了一个更好的故事。我们可以立即看出`extractData`是一个基于某些输入参数`params`的集合生成函数，这些参数从某种持久存储中产生初始的`inputCollection`函数。这个集合作为输入参数传递给转换函数`transformData`，该函数的结果是输出集合`outputCollection`。最后，这个集合被传递给数据加载函数`loadData`，并最终存储回持久存储。鉴于与持久存储的通信是以一种*幂等*的方式实现的，并且涉及的函数是引用透明的，这个转换链可以被任意次数地重放，并得到相同的结果。
- en: 'We can even take another step toward idiomatic use and rewrite the last snippet
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，将最后一个代码片段重写如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we really deal with the code, transforming immutable data. This code does
    not dependent on the side effects of an internal state. Its components are better
    composable and it can be easily extended, if necessary. Finally, this code is
    simply more elegant now, it is easier to read and comprehend.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们真正处理代码，转换不可变数据。这段代码不依赖于内部状态的副作用。其组件具有更好的可组合性，并且如果需要，可以轻松扩展。最后，这段代码现在更加优雅，更容易阅读和理解。
- en: You may ask how this rather simplistic passage relates to significant library
    members' variety?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这篇相当简单的文章如何与重要的库成员的多样性相关？
- en: 'First of all, there are a few dozen of typical transformations that exist in
    correspondence with the widely accepted ways in which data processing algorithms
    are captured in computer science. For example, if we are going to provide a library
    function to split a collection into a pair of partitions, we cannot make it much
    differently than with a higher-order function of the following pseudo-signature:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一些典型的转换与计算机科学中广泛接受的数据处理算法捕获方式相对应。例如，如果我们打算提供一个库函数来将集合拆分为一对分区，我们无法将其做得与以下伪签名中的高阶函数有很大不同：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `predicate` is a function that takes a single collection member of type
    `'T` and returns `bool` , where `true` signifies that the input element will go
    to the first collection of the result tuple, and `false` means it will go to the
    second collection. The  `source`  parameter represents the input collection to
    be split. I intentionally put "generic" `collection` into the preceding signature,
    and I will explain the reason in a bit. The result is a tuple carrying `source`
    elements being partitioned into two collections by the `predicate` values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`predicate`是一个函数，它接受一个类型为`'T`的单个集合成员，并返回`bool`，其中`true`表示输入元素将进入结果元组的第一个集合，而`false`表示它将进入第二个集合。`source`参数表示要拆分的输入集合。我故意将“泛型”`collection`放入前面的签名中，我将在稍后解释原因。结果是包含`source`元素，通过`predicate`值被分割成两个集合的元组。
- en: 'Many known algorithms of computer science can be succinctly implemented almost
    barely using the above `partition` function. For example, the famous **QuickSort**
    ([https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)
    ) representing the broad **Divide and Conquer** ([https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)
    ) class of algorithms. Let''s look at how **QuickSort** may be elegantly implemented
    using `partition` as shown by the following snippet (`Ch8_1.fsx` ):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学中已知的算法几乎可以简洁地使用上述`partition`函数实现。例如，著名的**快速排序**([https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort))代表了广泛的**分而治之**([https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms))算法类别。让我们看看如何优雅地使用`partition`实现**快速排序**，如下面的代码片段所示（`Ch8_1.fsx`）：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `qsort` function (somewhat simplistically) partitions a non-empty input
    list argument into two groups: one containing only elements that are less than
    one `x` in the head of the list, and the other containing the rest. The result
    would be to append the list that has `x` prepended to `qsortgreater` to the list
    `qsortless` . Beautiful! Let''s look at how this plays out in FSI in the following
    screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`qsort`函数（有些简化地）将非空输入列表参数分成两组：一组只包含列表头部小于`x`的元素，另一组包含其余元素。结果是将`x`前置的列表`qsortgreater`附加到列表`qsortless`上。太棒了！让我们看看以下截图中的FSI是如何实现的：'
- en: '![Data transformation patterns](img/Image00038.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![数据转换模式](img/Image00038.jpg)'
- en: Implementing quicksort with the partition function
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分区函数实现快速排序
- en: 'Now let me return to the reason I used `collection` in the signature of the
    preceding `partition` function. Coincidentally, this is another piece of the consideration
    prompting the variety of library members, which is *performance* . You can bet
    the farm on the assertion that in order to be effective, `partition` should be
    implemented separately for `array` and `list` collections, yielding the pair of
    functions, each belonging to their respective module as shown:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我回到我为什么在前面`partition`函数的签名中使用`collection`的原因。巧合的是，这也是促使库成员多样化的考虑因素之一，那就是**性能**。你可以打赌，为了有效，`partition`应该分别针对`array`和`list`集合实现，从而产生一对函数，每个函数都属于其各自的模块，如下所示：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Along these lines, an interesting point is the lack of the `Seq.partition` function
    in F# 4.0 core libraries. The root cause for this artifact comes down to the performance.
    I refer those of you who are curious to to **pertinent piece of F# design specs**
    ([https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections](https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections)
    ) and a more mundane **explanation on StackOverflow Q&A website** ([http://stackoverflow.com/a/31750808/917053](http://stackoverflow.com/a/31750808/917053)
    ) that gives of the exact reason.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这个思路，一个有趣的观点是F# 4.0核心库中缺少`Seq.partition`函数。这个现象的根本原因在于性能。我建议那些好奇的人查阅**相关的F#设计规范**([https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections](https://github.com/fsharp/FSharpLangDesign/blob/5cec1d3f524240f063b6f9dad2f23ca5a9d7b158/FSharp-4.0/ListSeqArrayAdditions.md#regular-functional-operators-producing-two-or-more-output-collections)
    )以及一个更普通的**StackOverflow问答网站上的解释**([http://stackoverflow.com/a/31750808/917053](http://stackoverflow.com/a/31750808/917053)
    )，以了解确切的原因。
- en: 'Summing up, F# language designers, when defining and implementing the F# core
    library of data transformation functions, are continually looking for equilibrium
    between the following factors:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，F#语言设计者在定义和实现F#核心库的数据转换函数时，一直在寻找以下因素的平衡：
- en: Good coverage of typical use cases distilled by many years of functional programming
    practice
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的覆盖面，这是多年函数式编程实践提炼出的典型用例
- en: Not bloating the size of the library above reasonable limits
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使库的大小超过合理的极限
- en: Making each library-provided function optimized to the extent that makes nonsensical
    any custom implementation of the same
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个库提供的函数优化到极致，以至于任何自定义实现的相同功能都显得毫无意义
- en: Equipped with this holistic view, let me turn to covering patterns per se. In
    cases where the demonstration of a function representing a pattern can fit a one-liner
    I'll provide the result of the evaluation in the upcoming line as a comment for
    the sake of saving space.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种整体的观点，让我转向具体覆盖模式。在函数表示模式可以简洁表达的情况下，我将在下一行提供评估结果作为注释，以节省空间。
- en: The generation pattern
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成模式
- en: 'This pattern is very easy to recognize: it represents a transition from the
    state without any collection to the state where a collection has been created.
    Generation pattern is represented by library functions that have a generic signature
    structure as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式很容易识别：它代表了一个从没有任何集合的状态到创建了一个集合的状态的过渡。生成模式由具有通用签名结构的库函数表示，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This generalized signature leads to some concrete use cases depending on the
    specific shape of the result collection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用签名导致了一些具体的使用案例，具体取决于结果集合的具体形状。
- en: Generating an empty collection
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成一个空集合
- en: 'To generate an empty collection of a generic type, the core library function,
    `empty` , exists, allowing you to produce a strongly typed empty collection for
    any of the base collection types as shown here (`Ch8_2.fsx` ):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '要生成一个泛型类型的空集合，核心库函数 `empty` 存在，允许您为任何基本集合类型生成强类型空集合，如下所示 (`Ch8_2.fsx` ):'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same can be also achieved using corresponding constant expressions for
    each base collection type (`Ch8_2.fsx` ):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，也可以使用每个基本集合类型的相应常量表达式来实现 (`Ch8_2.fsx` ):'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Generating a single element collection
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成单个元素集合
- en: 'This simple task belonging to a generation pattern can be achieved by the core
    library function `singleton` that exists for each of the base collection types.
    It does not need explicit declaration of collection elements type as it can be
    easily inferred from the typed literal given for the single collection element
    as shown in the following code (`Ch8_2.fsx` ):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '这个属于生成模式简单任务可以通过核心库函数 `singleton` 实现，该函数适用于每个基本集合类型。它不需要显式声明集合元素类型，因为它可以从为单个集合元素提供的类型字面量中轻松推断出来，如下面的代码所示
    (`Ch8_2.fsx` ):'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, this can be also achieved using corresponding constant expressions for
    each base collection type as shown here (`Ch8_2.fsx` ):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，这也可以通过使用每个基本集合类型的相应常量表达式来实现，如下所示 (`Ch8_2.fsx` ):'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Generating a collection of a known size
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成一个已知大小的集合
- en: 'This task of the generation pattern is represented by two different cases:
    the case where all elements in the collection are of the same value and the case
    where they can be of different values.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 生成模式的任务由两种不同的情况表示：集合中所有元素都具有相同值的情况和它们可以具有不同值的情况。
- en: Generating a collection of a known size - all elements of the same value
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成一个已知大小的集合 - 所有元素具有相同的值
- en: 'The F# 4.0 core library provides functions to replicate each base collection
    type that has the following signatures:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: F# 4.0 核心库提供了具有以下签名的函数来复制每个基本集合类型：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Examples of this usage are as following (`Ch8_2.fsx` ):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是一些使用示例 (`Ch8_2.fsx` ):'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As I discussed earlier, this can be achieved using literals and comprehension
    expressions as shown here (`Ch8_2.fsx` ):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '如我之前讨论的，这可以通过使用字面量和理解表达式来实现，如下所示 (`Ch8_2.fsx` ):'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In addition to `replicate` , F# core library for **array** collections exclusively
    provides the `create` and `zeroCreate` functions as shown below (`Ch8_2.fsx` ):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '除了 `replicate` 之外，F# 核心库为 **数组** 集合专门提供了 `create` 和 `zeroCreate` 函数，如下所示 (`Ch8_2.fsx`
    ):'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that `zeroCreate` , by design, does not give any clue about the type of
    the target array to the F# compiler. So, in order to avoid the infamous `error
    FS0030: Value restriction` error message that is going to take place if the matter
    of the target array type is delegated to the type inference, the type annotation
    can be added to the value itself, such as `string[]` for `fazc` , or a type argument
    can be added to the function name itself, such as `<int>` for `fazci` in the preceding
    code.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，`zeroCreate` 按设计不会向 F# 编译器提供任何有关目标数组类型的线索。因此，为了避免在将目标数组类型委托给类型推断时出现的臭名昭著的
    `error FS0030: Value restriction` 错误消息，可以在值本身上添加类型注解，例如 `string[]` 对于 `fazc`，或者可以在函数名称本身上添加类型参数，例如前述代码中的
    `fazci` 的 `<int>`。 '
- en: Generating a collection of a known size - elements may have different values
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成一个已知大小的集合 - 元素可能具有不同的值
- en: 'What if elements of the collection need to be of different values? The F# core
    library comes to our help with the `init` function for each base collection type
    that has signatures as following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合的元素需要具有不同的值怎么办？F# 核心库为我们提供了每个基本集合类型的 `init` 函数，其签名如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Examples of this usage are given as following (`Ch8_2.fsx` ):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是一些使用示例 (`Ch8_2.fsx` ):'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that `initializer` is given the implicit index of each element that transforms
    it into the element value. This transformation can be very simple, such as `vs`
    , or quite complex, such as `va` , where it is closed around `src` and de-facto
    transforms a `string` to the array of `char` of its characters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`initializer` 被赋予了每个元素的隐式索引，这将其转换为元素值。这种转换可以非常简单，例如 `vs`，或者非常复杂，例如 `va`，其中它围绕
    `src` 封闭，实际上将 `string` 转换为其字符的字符数组。
- en: 'Similar to the case of the same value elements, the alternative to `init` in
    order to generate lists and arrays may be literals, and for all three base collection
    types, the alternative could be comprehension expressions. Examples follow-`vll`
    and `val` for literals and the rest for a comprehension expression having (`vlcy`
    , `vacy` , `vscy` ) or not using (`vlc` , `vac` , `vsc` ) of the `yield` construction
    as shown here (`Ch8_2.fsx` ):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与相同值元素的情况类似，为了生成列表和数组，`init`的替代方案可能是字面量，对于所有三种基本集合类型，替代方案可能是理解表达式。以下是一些示例 -
    `vll`和`val`用于字面量，其余用于具有（`vlcy`，`vacy`，`vscy`）或没有使用（`vlc`，`vac`，`vsc`）`yield`构造的理解表达式，如下所示（`Ch8_2.fsx`）：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the expression initializing the collection element value within comprehension
    expressions can be arbitrarily complex; for example, in the case of `vacy` , it
    takes a value from the `src` closure indexed by the element place and converts
    the corresponding `char` array element into uppercase.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在理解表达式中初始化集合元素值的表达式可以是任意复杂的；例如，在`vacy`的情况下，它从`src`闭包中按元素位置索引取值，并将相应的`char`数组元素转换为大写字母。
- en: 'Before further proceeding with the rest of the use cases, let me drill deeper
    into comprehension expressions. They are much more powerful than what has been
    shown so far. I''ve already mentioned this in [Chapter 6](text00053.html#ch06
    "Chapter 6.  Sequences - The Core of Data Processing Patterns") , *Sequences -
    The Core of Data Processing Patterns* when talking about sequences in which sequence
    expressions may contain multiple occurrences of `yield` as well as `yield!` .
    You are free to use this feature when creating comprehension expressions for lists
    and arrays as well as use recursion to your taste. To prove this, let me demonstrate
    all these features in one quick example, building a generator for a list of pseudo-random
    integers in a range between `lo` and `hi` of length `len` as shown in the following
    code (`Ch8_2.fsx` ):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步处理其他用例之前，让我更深入地探讨理解表达式。它们比迄今为止展示的更强大。我已在[第6章](text00053.html#ch06 "第6章。序列
    - 数据处理模式的核心") *序列 - 数据处理模式的核心* 中提到过这一点，当时在讨论序列表达式可能包含多个`yield`以及`yield!`出现的情况。当为列表和数组创建理解表达式时，你可以自由使用此功能，并且可以根据你的喜好使用递归。为了证明这一点，让我通过一个快速示例演示所有这些功能，构建一个生成器，用于在`lo`和`hi`之间的范围内生成伪随机整数的列表，长度为`len`，如下所示（`Ch8_2.fsx`）：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results of smoke testing `randoms` in FSI by modeling three series of 20
    throws of a dice are given in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中给出了通过模拟三次20投掷骰子的结果，用于FSI中的`randoms`烟雾测试：
- en: '![Generating a collection of a known size - elements may have different values](img/Image00039.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![生成已知大小的集合 - 元素可能具有不同的值](img/Image00039.jpg)'
- en: Modelling series of throwing dice with pseudo-random number generator
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伪随机数生成器模拟投掷骰子的系列
- en: Generating a collection of an unknown size
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成未知大小的集合
- en: 'From time to time, you may get into a situation where you should generate a
    collection with the size that is to be found along the generation. In such situations,
    the following F# core library function `unfold` comes to help as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到需要生成一个在生成过程中要找到大小的集合的情况。在这种情况下，以下F#核心库函数`unfold`会提供帮助，如下所示：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I have already provided a very simple example of this function workings in [Chapter
    6](text00053.html#ch06 "Chapter 6.  Sequences - The Core of Data Processing Patterns")
    , *Sequences - The Core of Data Processing Patterns* ; here, I describe its inner
    workings to the full extent. The `unfold` function produces result collection
    elements one by one. For each element, the `generator` function takes a `'State`
    value as an input parameter and produces the result as an **option** value. If
    the returned option is of the form `Some('T * 'State)`  consisting of the current
    generated collection element value `'T` and the `'State` value for the next iteration
    this return value indicates that sequence unfolding will continue. Otherwise,
    when `generator` function returns `None` this means that the collection unfolding
    has been completed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 [第 6 章](text00053.html#ch06 "第 6 章。序列 - 数据处理模式的核心") 中提供了一个非常简单的这个函数工作原理的例子，*序列
    - 数据处理模式的核心*；在这里，我将其内部工作原理描述得淋漓尽致。`unfold` 函数逐个产生结果集合元素。对于每个元素，`generator` 函数将一个
    `'State` 值作为输入参数，并以 **option** 值的形式产生结果。如果返回的 `option` 是 `Some('T * 'State)` 的形式，其中包含当前生成的集合元素值
    `'T` 和下一次迭代的 `'State` 值，则此返回值表示序列展开将继续。否则，当 `generator` 函数返回 `None` 时，这意味着集合展开已经完成。
- en: 'Let me offer you a loaded example for this use case: the so-called **Collatz
    conjecture** ([https://en.wikipedia.org/wiki/Collatz_conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
    ). Let us consider an integral sequence built by a simple rule of moving from
    an element `n` to the next element `nn` : if `n` is even, then `nn` is `n` divided
    by `2` ; otherwise, it is `3 * n + 1` . The conjecture itself is that for any
    initial `n` , this sequence named by German mathematician Lothar Collatz eventually
    reaches `1` . For example,'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我为这个用例提供一个充满例子的例子：所谓的**柯尔萨茨猜想**([https://en.wikipedia.org/wiki/Collatz_conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)
    )。让我们考虑一个由简单规则构建的整数序列，该规则是将一个元素 `n` 移动到下一个元素 `nn`：如果 `n` 是偶数，则 `nn` 是 `n` 除以 `2`；否则，它是
    `3 * n + 1`。这个猜想本身是，对于任何初始的 `n`，这个由德国数学家洛塔尔·柯尔萨茨命名的序列最终会达到 `1`。例如，
- en: 42 -> 24 -> 12 -> 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 42 -> 24 -> 12 -> 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
- en: To this day, no starting number has been found that leads to an unbound number
    of elements in the Collatz sequence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有找到任何起始数字会导致柯尔萨茨序列中有无限数量的元素。
- en: 'For starters, I begin with an idiomatic implementation of the Collatz sequence
    generator `collatzLib` function that relies upon the `unfold` library function
    as shown here (`Ch8_2.fsx` ):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我从一个依赖于 `unfold` 库函数的柯尔萨茨序列生成器 `collatzLib` 函数的惯用实现开始，如下所示（`Ch8_2.fsx`）：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the trick I used in order to deliver the value 1 to the collection that,
    if the generation is continued beyond it, leads to the cycle `...1 -> 4 -> 2 ->
    1...` `.` For the state of `1L` , I produced the `Some` option that has `1L` as
    the current value and an impossible marker value, `0L` . For the marker value,
    the generator produces `None` and the collection growth terminates. Another precaution
    is to operate in the field of `int64` numbers because even some not-that-big initial
    numbers may bring `'State` outside of the `int` field, which I was able to find
    by switching to **checked** F# arithmetic from the default **unchecked** when
    the generator started taking a suspiciously long time to complete.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我用来将值 `1` 传递给集合的技巧，如果生成继续超过它，会导致循环 `...1 -> 4 -> 2 -> 1...`。对于 `1L` 的状态，我生成了具有
    `1L` 作为当前值和不可能的标记值 `0L` 的 `Some` 选项。对于标记值，生成器产生 `None`，并且集合增长终止。另一个预防措施是在 `int64`
    数字域中操作，因为即使是一些不是很大的初始数字也可能将 `'State`` 超出 `int` 域，这是我在生成器开始花费可疑地长时间完成时，从默认的 **unchecked**
    转换到 **checked** F# 算术时发现的。
- en: 'So far, so good. I''m going to give this implementation a try shortly. But
    some of you may already have this question: what''s the point if this can be achieved
    with a sequence expression? And the answer was already given in the beginning
    of this chapter -  *performance* . To prove this statement experimentally, let
    me put down the custom Collatz sequence generator implementation without using
    the `unfold` library function (`Ch8_2.fsx` ):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我很快就要尝试这个实现了。但你们中的一些人可能已经提出了这个问题：如果可以用序列表达式来实现，这有什么意义呢？答案已经在本章的开头给出了——**性能**。为了实验性地证明这个陈述，让我放下不使用
    `unfold` 库函数的自定义柯尔萨茨序列生成器实现（`Ch8_2.fsx`）：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s run `collatzLib` and `collatzCustom` against each other in order
    to identify the difference. For this purpose, let''s find out what the longest
    Collatz sequence collection for initial numbers between 2 and 1000 would be. This
    exercise is a variation of **Project Euler problem 14** ([https://projecteuler.net/problem=14](https://projecteuler.net/problem=14)
    ). Composing the performance measuring code is not that difficult as shown here
    (`Ch8_2.fsx` ):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 `collatzLib` 和 `collatzCustom` 以比较它们之间的差异。为此，让我们找出初始数字在 2 到 1000 之间最长的
    Collatz 序列集合。这个练习是 **Project Euler 问题 14** ([https://projecteuler.net/problem=14](https://projecteuler.net/problem=14)
    ) 的变体。编写性能测量代码并不像这里所示的那样困难（`Ch8_2.fsx`）。
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s compare the performance of the preceding code to this one (`Ch8_2.fsx`
    ):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较前面代码的性能与这个代码（`Ch8_2.fsx`）的性能：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'by the running time. Comparison is given in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行时间。比较如下截图所示：
- en: '![Generating a collection of an unknown size](img/Image00040.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![生成未知大小的集合](img/Image00040.jpg)'
- en: Comparing the performance of library function-based and custom implementations
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 比较基于库函数和自定义实现的性能
- en: The lesson to take home is that the run using library-based `collatzLib` function
    takes **only 63%** of the time required for the run that uses custom-implemented
    `collatzCustom` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的教训是，使用基于库的 `collatzLib` 函数的运行时间仅占使用自定义实现的 `collatzCustom` 函数所需时间的 **63%**。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not spend time re-implementing functionality that F# core library functions
    offer unless you are in need for speed and absolutely sure that your custom implementation
    would improve the performance!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你需要速度并且绝对确信你的自定义实现会提高性能，否则不要浪费时间重新实现 F# 核心库函数提供的功能！
- en: Generating a collection of an infinite size
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成无穷大小的集合
- en: 'Finally, I''ve reached the last use case under the Generation pattern: collections
    of infinite size. Apparently, when we consider this case, the underlying collection
    type can be the only sequence as we cannot rely on infinite memory resources yet.
    The F# core library function signature for the purpose of generating a sequence
    of infinite length is as following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在生成模式下的最后一个用例中达到了：无穷大小的集合。显然，当我们考虑这个情况时，底层集合类型只能是唯一的序列，因为我们还不能依赖无穷的内存资源。用于生成无穷长度序列的
    F# 核心库函数签名如下：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It does not differ from `init` that much; it just lacks the input argument setting
    the collection size. Side by side with the `initInfinite` library function go
    custom implementations of infinite size sequences with sequence expressions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `init` 并没有太大的区别；它只是缺少设置集合大小的输入参数。与 `initInfinite` 库函数并列的是自定义的无穷大小序列实现，使用序列表达式。
- en: 'I already covered the pattern of infinite size sequences in [Chapter 6](text00053.html#ch06
    "Chapter 6.  Sequences - The Core of Data Processing Patterns") , *Sequences -
    The Core of Data Processing Patterns* and provided some examples there as well
    as some advanced examples in [Chapter 7](text00058.html#ch07 "Chapter 7.  Advanced
    Techniques: Functions Revisited") , *Advanced Techniques: Functions Revisited*
    so I will not repeat myself here. This use case concludes the variety that Generation
    data transformation pattern covers.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 [第 6 章](text00053.html#ch06 "第 6 章。序列 - 数据处理模式的核心")，*序列 - 数据处理模式的核心* 中涵盖了无穷大小序列的模式，并在那里提供了一些示例，以及在第
    7 章 [第 7 章。高级技术：函数回顾](text00058.html#ch07 "第 7 章。高级技术：函数回顾") 中提供了一些高级示例，所以在这里我不会重复。这个用例结束了生成数据转换模式涵盖的多样性。
- en: The aggregation pattern
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合模式
- en: The aggregation pattern can be recognized by the following kind of activity
    when the collection is traversed to end up with a value of type `'T` , similar
    to the collection elements' type `'T` , which carries some cumulative impact of
    all traversed elements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合模式可以通过以下活动识别，当遍历集合以得到类型为 `'T'` 的值时，类似于集合元素的类型 `'T'`，它携带了所有遍历元素的一些累积影响。
- en: Generic aggregation
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型聚合
- en: 'The generic aggregation data transformation pattern signature is conveniently
    similar to the pair of concrete library functions that represent aggregation:
    `reduce` and `reduceBack` as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型聚合数据转换模式的签名方便地类似于表示聚合的成对具体库函数：`reduce` 和 `reduceBack`，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you recall [Chapter 7](text00058.html#ch07 "Chapter 7.  Advanced Techniques:
    Functions Revisited") , *Advanced Techniques: Functions Revisited* , the preceding
    code is almost as generic as `folds` ; the difference is that the state threaded
    through the collection by `fold` can be of any arbitrary type that does not necessarily
    coincide with the type of collection elements, while `reduce` deals with the same
    type. It is easy to implement `reduce` with `fold` but not the other way around.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得 [第7章](text00058.html#ch07 "第7章。高级技巧：函数回顾")，*高级技巧：函数回顾*，前面的代码几乎与 `folds`
    一样通用；区别在于，通过 `fold` 在集合中传递的状态可以是任何任意类型，不一定与集合元素类型相同，而 `reduce` 处理的是相同类型。用 `fold`
    实现 `reduce` 很容易，但反过来则不然。
- en: 'The `reduce` function applies the `reduction` operation from the beginning
    to the end of the collection; if I denote the `reduction` function as `r` , then
    for the special case of `reduce` over array collection `c` it will be equivalent
    to this expression as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数将 `reduction` 操作从集合的开始应用到结束；如果我用 `r` 表示 `reduction` 函数，那么对于 `reduce`
    在数组集合 `c` 上的特殊情况，它将等同于这里所示的表达式：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the contrary, `reduceBack` applies the `reduction` operation from the right-hand
    side to the left of the collection; if I denote the `reduction` function as `r`
    again, then for the special case of `reduceBack` over array collection `c` of
    `n+1` elements it will be equivalent to this expression as shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`reduceBack` 从集合的右侧应用 `reduction` 操作；如果我用 `r` 再次表示 `reduction` 函数，那么对于 `reduceBack`
    在 `n+1` 个元素的数组集合 `c` 上的特殊情况，它将等同于这里所示的表达式：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is quite easy to notice that for the **associative** ([https://en.wikipedia.org/wiki/Associative_property](https://en.wikipedia.org/wiki/Associative_property)
    ) `reduction` operation, the results of `reduce` and `reduceBack` over the same
    collection would be the same, which is confirmed by simple tests as shown here
    (`Ch8_3.fsx` ):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '很容易注意到，对于具有**结合性** ([https://en.wikipedia.org/wiki/Associative_property](https://en.wikipedia.org/wiki/Associative_property)
    ) 的 `reduction` 操作，`reduce` 和 `reduceBack` 在同一集合上的结果将是相同的，这可以通过以下简单测试得到证实 (`Ch8_3.fsx`
    ):'
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I''d like to point at the asymmetry taking place: there is no `reduceBack`
    for sequences in the library out of the box.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出正在发生的不对称性：库中没有现成的 `reduceBack` 用于序列。
- en: 'All other library aggregate functions are just specific implementations of
    aggregations that can be expressed by `reduce` . Before turning to their consideration,
    I want to point out just another pattern: performing aggregation not on the original
    element type `''T` but projecting each collection element to some other type `''U`
    and aggregating upon `''U` .'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他库聚合函数只是可以用 `reduce` 表达的聚合的特殊实现。在考虑它们之前，我想指出另一个模式：不是在原始元素类型 `'T` 上执行聚合，而是将每个集合元素投影到其他类型
    `'U` 并在 `'U` 上进行聚合。
- en: Direct aggregation
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接聚合
- en: 'Members of this group of aggregating library functions perform aggregation
    directly on the type of collection elements `''T` , such as the library members
    that have the following signatures:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聚合库函数组的成员直接在集合元素类型 `'T` 上执行聚合，例如具有以下签名的库成员：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Based on signatures, you may notice that the library's aggregate functions introduce
    static constraints upon the collection type `'T` for the aggregations to make
    sense. For example, apparently, the max aggregation cannot be performed upon type
    `'T` if `'T` does not support comparison.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 根据签名，你可能会注意到，库的聚合函数在聚合有意义的情况下对集合类型 `'T` 引入了静态约束。例如，显然，如果 `'T` 不支持比较，则不能在类型 `'T`
    上执行最大聚合。
- en: Projected aggregation
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 投影聚合
- en: 'The projected aggregation library function, instead of performing aggregations
    upon original collection elements, first projects them from type `''T` into some
    other type `''U` , and only then it performs the aggregation over `''U` values.
    Here go the signatures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 投影聚合库函数，不是在原始集合元素上执行聚合，而是首先将它们从类型 `'T` 投影到其他类型 `'U`，然后才在 `'U` 值上执行聚合。以下是签名：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There is a little intricacy that should be mentioned when considering projected
    aggregations-while `averageBy` and `sumBy` return a result of type `''U` , `maxBy`
    and `minBy` return `''T` . Refer to the following code sample that highlights
    the mentioned detail (`Ch8_3.fsx` ):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '在考虑投影聚合时，应该提到一点复杂性——虽然 `averageBy` 和 `sumBy` 返回类型为 `''U` 的结果，但 `maxBy` 和 `minBy`
    返回 `''T`。请参考以下代码示例，它突出了提到的细节 (`Ch8_3.fsx` ):'
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Counting aggregation
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数聚合
- en: The left-over two functions of aggregation data transformation pattern perform
    the counting of collection elements.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合数据转换模式的剩余两个函数执行集合元素的计数。
- en: 'The first one is the good old `length` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是那个古老的`length`函数：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are no hidden surprises here. Just recognize that `Seq.length` traverses
    the `source` sequence and, being applied to a sequence of infinite length will
    eventually blow up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有隐藏的惊喜。只需认识到`Seq.length`遍历`source`序列，并且当应用于无限长度的序列时，最终会崩溃。
- en: 'The other one, `countBy` , is trickier:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个，`countBy`，更复杂一些：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This higher-order function applies `projection` to each element value `'T` ,
    converting it into a `'Key` value, counts the number of elements projected to
    each unique `'Key` , and in the end, delivers the distribution as a collection
    of tuples (`'Key` , amount). Let me make quite an interesting observation. At
    the beginning of this chapter, in  *Generating a collection of a known size* we
    implemented a pseudo-random number sequence generator `randoms` . Let's look at
    roughly how "random" it is in emulating the throwing of a dice by building a long
    series of throws and then binning each score, expecting that the deviation of
    bin sizes is not statistically significant.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数对每个元素值`'T`应用`projection`，将其转换为`'Key`值，计算投影到每个唯一`'Key`的元素数量，最后将分布作为元组集合（`'Key'`,
    数量）返回。让我做一个相当有趣的观察。在本章的开头，在*生成已知大小的集合*中，我们实现了一个伪随机数序列生成器`randoms`。让我们看看通过构建一系列长投掷并分箱每个得分，期望分箱大小的偏差在统计上不显著，来模拟抛掷骰子的“随机性”。
- en: 'The following snippet emulates the throwing of a dice 10 million times; so,
    the expected number of hits of each of the six bins for outcomes should be somewhere
    around 1,666,000\. Let''s see... (`Ch8_3.fsx` ):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码片段模拟了抛掷一百万次骰子；因此，每个六进制结果应该有大约166,600次命中。让我们看看... (`Ch8_3.fsx` ):'
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The results of running the preceding code in FSI are presented in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在FSI中运行前面代码的结果如下所示：
- en: '![Counting aggregation](img/Image00041.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![计数聚合](img/Image00041.jpg)'
- en: Checking the quality of a pseudo-random number generator with countBy
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`countBy`检查伪随机数生成器的质量
- en: 'Based on results reflected by preceding screenshot, my gut feeling is that
    the underlying pseudo-random number generator is not bad for the purpose of emulating
    the dice. And it is pretty fast too: it took a bit more than 2 seconds to generate
    and bin the series of 10 million trials.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面截图显示的结果，我的直觉是，底层的伪随机数生成器在模拟骰子方面还不错。而且它还相当快：生成和分箱一百万次试验的系列只用了2秒多。
- en: The wrapping and type conversion pattern
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装和类型转换模式
- en: 'Library functions belonging to this data transformation pattern split into
    two groups as following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 属于这种数据转换模式的库函数分为两组如下：
- en: Ones that wrap the entire collection, changing its behavior
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些包装整个集合，改变其行为的操作
- en: Ones that simply transform the collection from one base type to another
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单地将集合从一种基本类型转换为另一种类型的操作
- en: The collection wrapping pattern
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合包装模式
- en: 'There are only three functions that belong to this pattern. All of them are
    applicable only to sequences and have the following signatures:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 属于这个模式的函数只有三个。它们都只适用于序列，并且具有以下签名：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I have already covered the `Seq.cache` function in [Chapter 6](text00053.html#ch06
    "Chapter 6.  Sequences - The Core of Data Processing Patterns") , *Sequences -
    The Core of Data Processing Patterns* and also used it in [Chapter 7](text00058.html#ch07
    "Chapter 7.  Advanced Techniques: Functions Revisited") , *Advanced Techniques:
    Functions Revisited* in the prime number generator sample, so let me not spend
    any more time on it and move on to the other pair.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在[第6章](text00053.html#ch06 "第6章。序列 - 数据处理模式的核心")中介绍了`Seq.cache`函数，*序列 - 数据处理模式的核心*，并在[第7章](text00058.html#ch07
    "第7章。高级技术：函数回顾")的质数生成器示例中也使用了它，*高级技术：函数回顾*，所以我就不再多花时间在这上面了，让我们继续到下一对。
- en: '`Seq.delay` allows you to postpone an eager evaluation of the wrapped `generator`
    function. The evaluation is postponed until the wrapper gets enumerated. In the
    following code snippet, there is an eager list comprehension present that, if
    being evaluated, immediately prints `"Evaluating eagerList"` and then returns
    the list of `strings` . However, being wrapped into `Seq.delay` , it does not
    evaluate until the wrapper itself gets materialized (`Ch8_4.fsx` ):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.delay` 允许你推迟对包装的 `generator` 函数的急切评估。评估将推迟到包装器被枚举时。在下面的代码片段中，存在一个急切列表解析，如果被评估，将立即打印
    `"Evaluating eagerList"`，然后返回 `strings` 列表。然而，由于被包装进 `Seq.delay`，它不会评估，直到包装器本身被具体化（`Ch8_4.fsx`）：'
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The commented lines of the preceding script demonstrate that the expected behavior
    described earlier is actually taking place.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个脚本中的注释行展示了之前描述的预期行为实际上正在发生。
- en: 'The `Seq.readonly` builds a wrapper sequence around the original collection,
    which does not allow you to rediscover and mutate it via a type cast. In the following
    snippet, it is possible via an upcast followed by a downcast, to create a backdoor,
    and mutate with its help the original mutable collection (`Ch8_4.fsx` ):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq.readonly` 在原始集合周围构建了一个包装序列，这不允许你通过类型转换重新发现和修改它。在下面的代码片段中，通过向上转换和向下转换，可以创建一个后门，并使用它帮助修改原始可变集合（`Ch8_4.fsx`）：'
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now if `src` gets wrapped into `Seq.readonly` , an attempt to downcast the
    sequence back to `int []` will incur cast exception as shown in the following
    code (`Ch8_4.fsx` ):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `src` 被包装进 `Seq.readonly`，尝试将序列向下转换为 `int []` 将会引发类型转换异常，如下面的代码所示（`Ch8_4.fsx`）：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The type conversion pattern
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换模式
- en: 'Library functions that belong to the type conversion pattern provide symmetric
    conversions between base collection types as shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 属于类型转换模式的库函数提供了基集合类型之间的对称转换，如下所示：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These functions are very straightforward and do not require additional comments.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数非常直接，不需要额外的注释。
- en: 'Apart from them stands function that converts a loosely-typed sequence from
    legacy pre-generic `System.Collections` namespace into a typed sequence:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些之外，还有一个函数可以将松散类型化的序列从旧式预泛型 `System.Collections` 命名空间转换为类型化序列：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This casting is often needed in interoperability scenarios between F# and legacy
    Microsoft systems in order to convert them into F#-friendly strongly typed sequences.
    As an example of this, let''s take a look at the following snippet (`Ch8_4.fsx`
    ):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换在 F# 与旧式 Microsoft 系统之间的互操作性场景中很常见，以便将它们转换为 F# 友好的强类型序列。作为一个例子，让我们看看下面的代码片段（`Ch8_4.fsx`）：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, you can see that a `Stack` loosely typed collection was casted to a strongly
    typed F# sequence and printed out. The output shows the F# sequence containing
    elements of different types: `string` , `char` , `int` . But the sequence is strongly
    typed, isn''t it? Can you determine the type of the preceding sequence?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到松散类型化的 `Stack` 集合被转换为强类型化的 F# 序列并打印出来。输出显示包含不同类型的 F# 序列：`string`、`char`、`int`。但是序列是强类型化的，对吧？你能确定前面序列的类型吗？
- en: The selection pattern
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选取模式
- en: 'This kind of data transformation pattern can be recognized by segregating one
    or more elements from the collection based on certain characteristic(s). These
    traits can be very diverse: a position of element(s), an element value matching
    criteria, to name a few.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据转换模式可以通过根据某些特征（s）从集合中分离一个或多个元素来识别。这些特征可能非常多样：元素的位置、与标准匹配的元素值，仅举几例。
- en: 'The genuine trait that distinguishes the selection transformation pattern from
    the rest of the crowd is the following: *selection result is always either a single
    element or a single collection carrying from zero to all elements of the original
    collection; the selection comes as-is, without any additional projection* .'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 区分选取转换模式与其他模式的真正特征如下：*选取结果始终是单个元素或单个包含从零到原始集合所有元素的集合；选取是原样提供的，没有任何额外的投影*。
- en: 'Such a seemingly broad transformation class lays out into surprisingly few
    subclasses: positional selection, search, and filtering.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看似广泛的转换类实际上只有少数几个子类：基于位置的选取、搜索和过滤。
- en: Position-based **selection** ties the element pick criteria with the element(s)
    position in the original collection; for example, take up to the first 10 elements
    of a collection.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 基于位置的 **选取** 将元素选取标准与原始集合中元素的位置绑定；例如，选取集合的前10个元素。
- en: '**Searching** and **filtering** are ubiquitous data collection transformations
    indeed. Although these two transformations strongly resemble each other, there
    is a subtle difference has place between them, which is outlined below.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索**和**过滤**确实是普遍的数据集合转换。尽管这两个转换非常相似，但它们之间有一个细微的区别，如下所述。'
- en: Filtering is usually associated with taking a source collection and copying
    it to the result collection element by element sifting out *all* elements that
    do not match given criteria.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤通常与将源集合逐个元素地复制到结果集合相关，筛选出所有不符合给定标准的元素。
- en: 'Turning to searching, it is usually associated with a more sophisticated process.
    The initial state for the search is composed of the original collection, initially
    empty search result, and search criteria. The search process also traverses the
    original collection element by element applying search criteria and shaping the
    search result. However, searching may carry not only the matching criteria, but
    also a stop condition of a sort and maybe some ranking. A typical example of searching
    would be this: "find *any* collection element that fulfills the condition(s)".'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 转到搜索，它通常与一个更复杂的过程相关。搜索的初始状态由原始集合、最初为空的搜索结果和搜索条件组成。搜索过程也会逐个元素遍历原始集合，应用搜索条件并塑造搜索结果。然而，搜索可能不仅包含匹配条件，还可能包含某种停止条件，也许还有一些排名。一个典型的搜索例子是这样的：“找到满足条件（s）的任何集合元素”。
- en: Based on this difference, I place searching in a separate selection pattern,
    but consider the filtering a part of the *element group selection* pattern.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此差异，我将搜索放在一个单独的选取模式中，但将过滤视为 *元素组选择* 模式的一部分。
- en: The position-based selection pattern
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于位置的选取模式
- en: 'F# core library functions that constitute this pattern can be further broken
    down into two groups: single element selections and element group selections.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 构成此模式的 F# 核心库函数可以进一步分为两组：单个元素选择和元素组选择。
- en: Single element selection
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单个元素选择
- en: 'This group of functions determines the single desired element by the position
    it occupies in the collection. The position may be requested either explicitly
    via an input argument or implicitly by the associated function name. To see what
    I mean please compare "give me the third element" with "give me the last element".
    Single element selection returns either the desired element or an indication that
    such an element does not exist:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这组函数通过元素在集合中占有的位置确定单个所需元素。位置可以通过输入参数显式请求，也可以通过相关函数名隐式请求。为了理解我的意思，请比较“给我第三个元素”与“给我最后一个元素”。单个元素选择返回所需的元素或表示不存在这样的元素：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Note how members of this group differ by the manner of indicating an unsuccessful
    selection. Some simply throw an exception, while the others wrap the selection
    result into an `option` , where `None` indicates the absence of the sought-for
    element: (`Ch8_5.fsx` ):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个组中的成员如何通过指示不成功的选择方式来区分。有些简单地抛出异常，而另一些则将选择结果包装在一个 `option` 中，其中 `None` 表示所寻求的元素不存在：（`Ch8_5.fsx`）
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Further on functions with names that begin with `try...` : these allow to alleviate
    the lurking possibility of the requested element being missing and handle such
    unfortunate cases nicely.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关于以 `try...` 开头的函数名：这些函数允许减轻请求的元素可能缺失的风险，并很好地处理这种不幸的情况。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use the *imperative* forms of selection with caution. If you are not ABSOLUTELY
    sure that the existence of requested element is invariant, fall back to *try*
    forms.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择操作的命令式形式时请谨慎。如果你绝对不确定请求的元素是否存在且不变，则退回到 *try* 形式。
- en: 'Also, note that for data collections that support element indexing, often the
    simple use of index does the job of dedicated library function, like in the following
    code (`Ch8_5.fsx` ):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，对于支持元素索引的数据集合，通常简单的索引使用就完成了专用库函数的工作，如下面的代码所示（`Ch8_5.fsx`）：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The element group selection
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 元素组选择
- en: 'This collection transformation sub-pattern arranges the procurement of a group
    of elements from a collection based on the whole slew of criteria: it can be an
    element counter, a predicate peeking at an element''s value, a collection of undesired
    values, or an exclusion of repeated values:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此集合转换子模式根据一系列标准安排从集合中获取一组元素：它可以是一个元素计数器，一个查看元素值的谓词，一个不希望出现的值集合，或者排除重复值：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that the constituent of *element group selection* pattern is the ubiquitous
    `filter` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*元素组选择* 模式的组成部分是普遍存在的 `filter` 函数。
- en: 'Similarly to the previous sub-pattern for collections implementing index slicing,
    this is an alternative way of element group selection (`Ch8_5.fsx` ):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前实现索引切片的集合子模式类似，这是另一种元素组选择的方法（`Ch8_5.fsx`）：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You may also notice that the more generic `filter` function is accompanied
    by more specific filtering cases, such as `takeWhile` , `skipWhile` , or just
    a `where` synonym as shown here (`Ch8_5.fsx` ):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到，更通用的 `filter` 函数伴随着更具体的过滤情况，例如 `takeWhile`、`skipWhile`，或者就像这里所示（`Ch8_5.fsx`）的
    `where` 同义词：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The searching pattern
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索模式
- en: The F# 4.0 core library offer a very normalized set of functions that constitute
    the **search** pattern, where the name of the function carries exhaustive characteristics
    of the function workings indeed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: F# 4.0 核心库提供了一套非常规范化的函数，构成了 **搜索** 模式，其中函数的名称确实包含了函数工作的详尽特征。
- en: All the functions that have `...find...` in the name perform the search for
    the first single element that occurs while having `...findIndex...` do the search
    for the same element but returning its ordinal number in the collection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有名称中包含 `...find...` 的函数都执行搜索第一个出现的单个元素，而 `...findIndex...` 则执行相同的搜索，但返回该元素在集合中的序号。
- en: Functions that have `...Back...` in the name perform the search in the opposite
    direction of the natural order of elements.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中包含 `...Back...` 的函数在元素的自然顺序的反方向进行搜索。
- en: 'Similarly to the already examined selection pattern groups, the library functions
    of the search pattern implement two approaches to represent the *"not found"*
    search outcome: those without the `try...` prefix throw an exception if the search
    comes back empty, while others with the `try...` prefix in this situation return
    the `None` option; otherwise, it returns the found element wrapped into `Some...`
    option as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与已经检查过的选择模式组类似，搜索模式的库函数实现了两种表示 *"未找到"* 搜索结果的方法：那些没有 `try...` 前缀的，如果搜索返回空结果，则抛出异常；而那些带有
    `try...` 前缀的，在这种情况下返回 `None` 选项；否则，它返回包含在 `Some...` 选项中的找到的元素，如下所示：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s demonstrate the listed above instruments in action (`Ch8_5.fsx` ):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下列出的小工具来展示其作用（`Ch8_5.fsx`）：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Slightly apart from this very logical arrangement stands the `(try)pick` group
    of functions. Functions that belong to this group combine both search and transform
    functionalities together: the `chooser` function applies to each element of type
    `''T` , producing `None` until the first element matches the search criteria somehow
    expressed within `chooser` . Then, `Some` is wrapped around potentially different
    type `''U` and is returned, and the higher-order function returns the result of
    type `''U` . If `chooser` does not find any suitable element, then `pick` throws
    an exception, while `tryPick` returns `None` (`Ch8_5.fsx` ):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种非常逻辑的安排略有不同的是 `(try)pick` 函数组。属于此组的函数将搜索和转换功能结合起来：`chooser` 函数应用于类型 `'T'`
    的每个元素，产生 `None`，直到第一个元素以某种方式匹配 `chooser` 内部表达的选择标准。然后，`Some` 将潜在的、不同类型的 `'U'`
    包裹起来并返回，并且高阶函数返回类型为 `'U'` 的结果。如果 `chooser` 找不到任何合适的元素，则 `pick` 抛出异常，而 `tryPick`
    返回 `None`（`Ch8_5.fsx`）：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Please pay attention how the above functions fuse together to some extent selection
    and transformation by applying both actions while traversing the collection only
    once.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上述函数如何通过在遍历集合时同时应用这两个动作，在一定程度上融合了选择和转换。
- en: The partitioning pattern
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区模式
- en: 'F# core library elements of **partitioning** pattern consume a single collection,
    usually returning more than one result collections as shown here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**分区** 模式的 F# 核心库元素消耗单个集合，通常返回多个结果集合，如下所示：'
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Examples of simple usage of the preceding functions are as following (`Ch8_6.fsx`
    ):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些先前函数的简单用法示例（`Ch8_6.fsx`）：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The reordering pattern
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新排序模式
- en: 'This group of F# core library functions represents the **reordering** data
    transformation pattern of changing the order of the elements in the collection
    using many forms of sorting, reversing, and permuting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这组 F# 核心库函数代表了 **重新排序** 数据转换模式，通过多种形式的排序、反转和排列来改变集合中元素的位置：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Some examples of the reordering transformations are as following (`Ch8_7.fsx`
    ):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重新排序转换的示例（`Ch8_7.fsx`）：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Take into account that some functions perform the reordering by mutating the
    input collection. These are limited to `ArraysortInPlace` , `sortInPlaceBy` ,
    and `sortInPlaceWith` .
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到一些函数通过修改输入集合来执行重新排序。这些函数限于`ArraysortInPlace`，`sortInPlaceBy`和`sortInPlaceWith`。
- en: The testing pattern
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试模式
- en: 'This is a very straightforward pattern. **Testing** library functions instead
    of transforming the input collection, always returning the `bool` result: `true`
    if certain properties have place, otherwise `false` . They may check whether the
    given collection contains the given element, whether an element exists with the
    value, turning the given predicate to `true` , whether all elements of the collection
    turn the given predicate to `true` , or whether the input collection is empty
    as their signatures reflect below:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常直接的模式。**测试库函数而不是转换输入集合**，总是返回`bool`结果：如果某些属性存在，则返回`true`，否则返回`false`。它们可能检查给定的集合是否包含给定的元素，是否存在具有该值的元素，将给定的谓词转换为`true`，是否所有元素都将给定的谓词转换为`true`，或者输入集合是否为空，如它们的签名所示：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The functions representing this pattern have so obvious an intent that I didn't
    even provide the usage samples for them; the samples can be easily found in F#
    core library documentation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表示此模式的函数意图如此明显，以至于我甚至没有提供它们的用法示例；这些示例可以在F#核心库文档中轻松找到。
- en: The iterating pattern
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代模式
- en: This is another very straightforward data transformation pattern. In fact, **iterating**
    pattern *does not introduce any noticeable transformations* , merely denoting
    instead the collection traversal. Its member functions always return `unit` .
    On each single traversal step the operations performed upon the current element
    are hidden behind the `action` function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一种非常直接的数据转换模式。实际上，**迭代模式并不引入任何明显的转换**，而是仅仅表示集合的遍历。它的成员函数总是返回`unit`。在每次单独的遍历步骤中，对当前元素执行的操作都隐藏在`action`函数之后。
- en: This manner of data transformations must vividly remind us of imperative and
    object-oriented paradigms as `action` effectively hides what's going on and also
    must exploit some side effects in order to be of any practical use. Such F# programs
    that massively (ab) use the iterating data transformation pattern usually indicate
    that their authors are still captives of a non-functional way of thinking.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据转换的方式会让我们鲜明地联想到命令式和面向对象范式，因为`action`有效地隐藏了正在发生的事情，并且也必须利用一些副作用才能在实际中发挥作用。那些大量（滥用）迭代数据转换模式的F#程序通常表明，它们的作者仍然受制于一种非函数式思维方式。
- en: 'The signatures of functions representing iterating pattern are given below:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表示迭代模式的函数的签名如下：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that library member functions of this pattern demonstrate a certain level
    of regularization. The actions may involve elements (`iter` , `iter2` ), or elements
    and the index (`iteri` , `iteri2` ), and also may involve a single collection
    (`iter` , `iteri` ) or pair of collections (`iter2` , `iteri2` ).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该模式的库成员函数展示了一定程度的规范化。操作可能涉及元素（`iter`，`iter2`），或者元素和索引（`iteri`，`iteri2`），也可能涉及单个集合（`iter`，`iteri`）或一对集合（`iter2`，`iteri2`）。
- en: As with the testing pattern, finding samples of these function's use on the
    Internet is not a problem.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试模式一样，在互联网上找到这些函数用法的示例并不成问题。
- en: The mapping pattern
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射模式
- en: 'Mappings constitute the gist of data transformations, projecting one or more
    input elements to the single result and then applying this projection to the entire
    input collection(s) producing the result collection(s) as the following member
    function signatures indicate:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 映射构成了数据转换的核心，将一个或多个输入元素映射到单个结果，然后将此投影应用于整个输入集合（产生结果集合），如下成员函数签名所示：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the group of functions belonging to the mapping pattern is normalized
    fairly well. Functions with names resembling `map` (`map` , `map2` , `map3` )
    project elements of a single, a pair, or a triple of input collections to the
    elements of the single result collection. Functions with names resembling `mapi`
    (`mapi` , `mapi2` ) also add the ordinal number of element(s) as an additional
    input parameter to the projection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属于映射模式的函数组已经相当规范化。名称类似于`map`（`map`，`map2`，`map3`）的函数将单个、一对或三对输入集合的元素映射到单个结果集合的元素。名称类似于`mapi`（`mapi`，`mapi2`）的函数还向投影添加了元素序号作为额外的输入参数。
- en: The `collect` function does not fit the same approach. Instead, it projects
    each element of the input collection into a matching collection and then flattens
    all these element-matching collections into a single result collection. It's a
    bit complicated, so I'd better provide an example.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect` 函数不采用相同的方法。相反，它将输入集合的每个元素投影到匹配的集合中，然后将所有这些元素匹配的集合展平成一个单一的结果集合。这有点复杂，所以我最好提供一个例子。'
- en: 'Let''s assume we are given an array of words and we want to convert it into
    a list of characters constituting input words (`Ch8_7.fsx` ):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个单词数组，并希望将其转换为构成输入单词的字符列表（`Ch8_7.fsx`）：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `indexed` function is a helper function; it converts any collection into
    a collection of tuples, each combining an ordinal number of the original element
    and the element itself (`Ch8_7.fsx` ):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexed` 函数是一个辅助函数；它将任何集合转换为包含元组的集合，每个元组结合了原始元素的序号和元素本身（`Ch8_7.fsx`）：'
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The folding pattern
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 折叠模式
- en: 'I''ve already mentioned on multiple occasions the `fold` function as a representation
    of the most universal and generic data transformation pattern of functional programming.
    As it has already been covered fairly well, I will not get into details here and
    will just list the multiple variations of this extremely versatile **folding**
    pattern as shown by the following member function signatures:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到 `fold` 函数作为函数式编程中最通用和最通用的数据转换模式的表示。由于它已经被相当详细地介绍过了，这里我将不会深入细节，而只是列出以下成员函数签名所展示的这种极其通用的
    **折叠** 模式的多种变体：
- en: '[PRE60]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In addition to multiple `fold` usage examples sprinkled around the book and
    readily available on the Internet I provide a few more in the script `Ch8_8.fsx`
    .
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 除了书中散布的多个 `fold` 使用示例和互联网上随时可用的示例之外，我在脚本 `Ch8_8.fsx` 中还提供了一些额外的示例。
- en: The merge/split pattern
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并/分割模式
- en: 'Our long journey into the world of data transformation patterns captured by
    F# 4.0 core library has reached the last stop. Here, functions residing with **merge/split**
    pattern either merge some collections into one, or perform the opposite by splitting
    one collection into many:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 F# 4.0 核心库中捕获的数据转换模式的漫长旅程已经到达了最后一站。在这里，位于 **合并/分割** 模式下的函数要么将一些集合合并成一个，要么通过分割一个集合成多个来执行相反的操作：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `append` function is the simplest form of merge pattern as it combines a
    pair of collections into the single one. Elements of the second argument collection
    just follow the elements of the first argument collection in the result collection.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 函数是合并模式的最简单形式，因为它将一对集合合并成一个单一的集合。第二个参数集合的元素紧随第一个参数集合的元素之后，出现在结果集合中。'
- en: The `concat` function is the generalization of `append` to any number of input
    collections just wrapped into a sequence.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat` 函数是 `append` 的泛化，适用于任何数量的输入集合，只需将其包装成序列。'
- en: Finally, zippers (`zip` , `zip3` ) take two or three collections and turn them
    into a single collection of corresponding tuples. Unzippers (`unzip` , `unzip3`
    ) do the opposite, taking a collection of tuples and turning it into the tuple
    of collections. Note that the library does not provide unzippers for `seq` .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接器（`zip`、`zip3`）将两个或三个集合转换成对应元组的单一集合。解连接器（`unzip`、`unzip3`）执行相反的操作，将元组集合转换成集合的元组。请注意，库不提供
    `seq` 的解连接器。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This was a long chapter, but it was an essential step into the universal patterns
    of data transformations and their reflection in the F# 4.0 core library. The knowledge
    you acquired will support the process of idiomatic blueprinting of an arbitrary
    data transformation by prompting you to build your F# code around the handful
    of retained reference points. When you mentally dissect your task at hand into
    a composition of functions along the patterns covered here, the high-quality library
    functions are always available for you to quickly compose from them an error-free
    and adequately performant solution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个漫长的章节，但它是进入数据转换的通用模式和它们在 F# 4.0 核心库中的反映的必要步骤。你获得的知识将支持通过提示你围绕保留的几个参考点构建
    F# 代码来构建任意数据转换的惯用蓝图的过程。当你将手头的任务在心理上分解为这里涵盖的模式的函数组合时，高质量的库函数总是可供你快速组合，从而得到一个无错误且性能充足的解决方案。
- en: The next chapter will continue with the data transformation theme, looking into
    F# data queries and the subject of data parsing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续数据转换主题，探讨 F# 数据查询和数据解析的主题。
