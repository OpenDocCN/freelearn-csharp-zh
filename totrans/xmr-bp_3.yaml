- en: Chapter 3. Building a GPS Locator Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：构建 GPS 定位器应用程序
- en: In this chapter, we will delve deeper into code sharing. We will build a `Xamarin.Forms`
    application that integrates native GPS location services and Google Maps APIs.
    We will cover more content on IoC containers, the `Xamarin.Forms.Maps` library,
    and techniques for c-sharp `async` and background tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨代码共享。我们将构建一个集成了原生 GPS 定位服务和 Google Maps API 的 `Xamarin.Forms`
    应用程序。我们将涵盖更多关于 IoC 容器、`Xamarin.Forms.Maps` 库以及 c-sharp `async` 和后台任务技术的内容。
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: Web services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: JSON
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: Google Maps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Maps
- en: Google Geocoding APIs (it helps to have a Google Developer account)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 地理编码 API（拥有 Google 开发者账户会有帮助）
- en: 'In this chapter, you will learn the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Core location and GPS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心定位和 GPS
- en: Navigation with `Xamarin.Forms`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Xamarin.Forms` 进行导航
- en: Google Maps integration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Maps 集成
- en: Integrating Google Maps with `Xamarin.Forms.Maps`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Google Maps 与 `Xamarin.Forms.Maps` 集成
- en: Reactive extensions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展
- en: Core location with iOS and the `CLLocationManager` Library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 iOS 和 `CLLocationManager` 库进行核心定位
- en: Android and the `LocationManager`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 和 `LocationManager`
- en: Creating our Windows project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的 Windows 项目
- en: Core location services with Windows Phone
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Phone 的核心定位服务
- en: The Application class
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类
- en: Web services and data contracts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务和数据契约
- en: Integrating with a Google APIs
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Google API 集成
- en: Creating the Geocoding web service controller
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建地理编码网络服务控制器
- en: '`Newtonsoft.Json` and Microsoft HTTP client libraries'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Newtonsoft.Json` 和 Microsoft HTTP 客户端库'
- en: '`ModernHttpClient` and client message handlers'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModernHttpClient` 和客户端消息处理器'
- en: Feeding JSON data into the `IObservable` framework more reactive extensions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JSON 数据喂入 `IObservable` 框架的更多反应式扩展
- en: Resource (RESX) files
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源（RESX）文件
- en: Using the Geocoding web server controller
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地理编码网络服务器控制器
- en: '`OnNavigatedTo` and `OnShow`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnNavigatedTo` 和 `OnShow`'
- en: Pythagoras equirectangular projection
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毕达哥拉斯等角投影
- en: Core location and GPS
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心定位和 GPS
- en: All mobile phone platforms have access to core location services. These services
    are background tasks that run in the background and update the latitude and longitude
    values at certain intervals indefinitely until the service is stopped. 99% of
    smart phones come with a built-in GPS tracker, allowing you to integrate these
    latitude and longitude values with your application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有移动平台都可以访问核心定位服务。这些服务是在后台运行的背景任务，在特定的时间间隔内无限期地更新纬度和经度值，直到服务停止。99% 的智能手机都内置了
    GPS 跟踪器，允许你将这些纬度和经度值集成到你的应用程序中。
- en: Project setup
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设置
- en: Let's jump straight into project setup and create a new `Xamarin.Forms` application.
    We are going to start by setting up an IoC container with **Autofac**, exactly
    the same as the previous project, import **Autofac** into all three projects (PCL,
    Android, and iOS). We can reuse a lot of the PCL code from the IoC container implementation
    in the previous project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入项目设置并创建一个新的 `Xamarin.Forms` 应用程序。我们将首先使用 **Autofac** 设置一个 IoC 容器，这与之前的工程完全相同，将
    **Autofac** 导入所有三个项目（PCL、Android 和 iOS）。我们可以从上一个项目中重用 IoC 容器实现中的大量 PCL 代码。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The more apps you build, the more problems you solve; why reinvent the wheel
    over and over? Eventually, when you have built multiple applications, future apps
    will be built mostly from piecing parts of different projects together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的应用程序越多，解决的问题就越多；为什么总是要反复地重新发明轮子呢？最终，当你构建了多个应用程序后，未来的应用程序将主要是由不同项目的不同部分拼接而成的。
- en: 'Copy in the `IoC`, `Pages`, and `ViewModels` folders, and let''s start building
    our `MainPage`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `IoC`、`Pages` 和 `ViewModels` 文件夹复制进来，然后开始构建我们的 `MainPage`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is very much the same as the previous `MainPage`, but this time we are
    adding two `Buttons`, a `Label`, and an `Image`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的 `MainPage` 非常相似，但这次我们添加了两个 `Buttons`，一个 `Label` 和一个 `Image`。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before reading any further, have a look at the properties bounded to each element.
    See if you can build the properties for the view model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，看看绑定到每个元素的属性。看看你是否能构建视图模型的属性。
- en: Navigation with Xamarin.Forms
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Xamarin.Forms 进行导航
- en: Before we start building any view models we are going to build our navigation
    system. `Xamarin.Forms` comes complete with navigation control for all platforms,
    so you won't have to worry about it. But as we always like to do things the hard
    way, we are going to show you a technique to separate our cross-platform structure
    a little more, in order to keep things more modular. Using one PCL project to
    contain both view models and views is great, but what if we could separate our
    views from view models into two PCL projects?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建任何视图模型之前，我们将构建我们的导航系统。`Xamarin.Forms`为所有平台提供了完整的导航控制，所以你不必担心这一点。但因为我们总是喜欢走难路，我们将向你展示一种技术，以使我们的跨平台结构更加分离，以便使事物更加模块化。使用一个PCL项目同时包含视图模型和视图是很好的，但如果我们能够将视图和视图模型分开到两个PCL项目中呢？
- en: Why would we do this?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们为什么要这样做？
- en: One small issue we have with the current PCL is that it relies completely on
    `Xamarin.Forms`. Only our XAML sheets and user interfaces rely on `Xamarin.Forms`;
    our view models do not. Then let's move the view models from the `Xamarin.Forms`
    PCL into an even lower-level PCL project that only relies on c-sharp libraries.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前PCL的一个小问题是它完全依赖于`Xamarin.Forms`。只有我们的XAML表单和用户界面依赖于`Xamarin.Forms`；我们的视图模型不依赖于它。那么，让我们将视图模型从`Xamarin.Forms`
    PCL移动到一个更低级的PCL项目中，该项目只依赖于c-sharp库。
- en: This is a good technique to keep the PCL projects completely separated. Developing
    a modular system is advantageous when it comes to code sharing. For example, we
    are building a new app that requires a login screen, a list view screen, and other
    similar screens most apps include. As we already have the view models that handle
    all the web services, JSON processing, and property bindings, do we really need
    to change much? Now that we have a low-level project that simply has the view
    models, let's just extract the ones we need, design our user interfaces for the
    view models, and bind them together. Not only can we reuse these view models for
    other apps, but if we wanted to develop an entirely separated application (for
    example, a WPF application), we can just compare the required screens, take the
    related view models, create new user interfaces, and bind them together. Keeping
    everything completely separated allows for complete plug-and-play capability,
    which will dramatically decrease the development time required to build similar
    applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的技术，可以使PCL项目完全分离。在代码共享方面，构建模块化系统是有利的。例如，我们正在构建一个需要登录屏幕、列表视图屏幕和其他大多数应用程序都包含的类似屏幕的新应用程序。因为我们已经有了处理所有网络服务、JSON处理和属性绑定的视图模型，我们真的需要改变很多吗？现在我们有一个只包含视图模型的低级项目，让我们只提取我们需要的，为视图模型设计用户界面，并将它们绑定在一起。我们不仅可以将这些视图模型用于其他应用程序，而且如果我们想开发一个完全分离的应用程序（例如，一个WPF应用程序），我们只需比较所需的屏幕，取相关的视图模型，创建新的用户界面，并将它们绑定在一起。将一切完全分离可以提供完全的即插即用能力，这将大大减少构建类似应用程序所需的开发时间。
- en: 'Let''s approach this pattern by creating a new PCL project and copying in the
    view models; call it **Locator.Portable**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个新的PCL项目并将视图模型复制进来来实现这个模式；命名为**Locator.Portable**：
- en: '![Why would we do this?](img/B05293_03_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![我们为什么要这样做？](img/B05293_03_01.jpg)'
- en: We also want to copy over the `IoC` folder as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望复制`IoC`文件夹。
- en: Building the navigation control
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建导航控制
- en: 'Our first step is to create a folder called `enum`, add the `PageNames.cs`
    file, and copy in the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个名为`enum`的文件夹，添加`PageNames.cs`文件，并复制以下内容：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s add a new folder called `UI` and create a new file called `INavigationService.cs`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`UI`的新文件夹，并创建一个名为`INavigationService.cs`的新文件：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we create a new folder in the `Xamarin.Forms` PCL (Locator) project called
    `UI`, and create a new file called `NavigationService.cs`. The `NavigationService`
    class will inherit the `INavigationService` interface:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Xamarin.Forms` PCL (定位器)项目中创建一个新的文件夹，命名为`UI`，并创建一个名为`NavigationService.cs`的新文件。`NavigationService`类将继承`INavigationService`接口：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Simple, right? Navigate will be used whenever we want the stack to navigate
    to a page. In making an abstracted interface, as we have done for navigation,
    this allows us to control navigation way down in the lower-level PCL. Now, fill
    in the rest:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，对吧？导航将在我们想要堆栈导航到页面时使用。在创建一个抽象接口时，就像我们为导航所做的那样，这允许我们在更低级的PCL中控制导航。现在，填写其余部分：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Firstly, look more closely at the private function `GetPage`; this will be called
    every time the `Navigate` function is called to retrieve the correct `ContentPage`
    object (which is registered in the `IoC` container) based upon the `PageName ``enum`
    passed to it, and if we have found the correct page, push it onto the navigation
    stack.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更仔细地看看私有的`GetPage`函数；每次调用`Navigate`函数时，它都会根据传入的`PageName`枚举来检索正确的`ContentPage`对象（该对象已在`IoC`容器中注册），并且如果我们找到了正确的页面，就会将其推入导航堆栈。
- en: 'Finally, let''s build our new `XamFormsModule` for registering the pages and
    navigation service:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建我们的新`XamFormsModule`以注册页面和导航服务：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are registering one navigation page throughout the entire life of the application,
    and we set the starting page to the one main page item we registered before.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在整个应用程序的生命周期中注册了一个导航页面，并将起始页面设置为之前注册的一个主页面项。
- en: 'Now open up the `App.cs` file and update it accordingly:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`App.cs`文件并相应地更新它：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Making sense now?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在明白了吗？
- en: IoC is a very powerful pattern for cross-platform applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: IoC是跨平台应用的一个非常强大的模式。
- en: View model navigation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图模型导航
- en: 'Now let''s get back to our `MainPageViewModel` and update and modify the previous
    chapter''s `MainPageViewModel` with the properties required for the data-bindings
    on `MainPage.xaml` shown previously. Firstly, let''s implement the `private` properties:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`MainPageViewModel`，并更新和修改之前章节中的`MainPageViewModel`，以包含之前在`MainPage.xaml`中显示的数据绑定所需的属性。首先，让我们实现`private`属性：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now for the `Public` properties:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于`Public`属性：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Are we starting to see the same pattern here?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否开始看到相同的模式了？
- en: 'Now add the constructor, which is going to use the navigation service interface
    that we abstracted earlier through the `IoC` container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加构造函数，它将使用我们之前通过`IoC`容器抽象出的导航服务接口：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it''s time to show you another trick using the IoC container. In our constructor,
    we need to be able to create a new `Command` object from the `Xamarin.Forms` library.
    We are lucky here, because since commands from `Xamarin.Forms` inherit the `ICommand`
    interface from `System.Windows.Input`, we are able to register this object in
    the IoC container. Open up `XamFormsModule.cs` and update the `Register` function
    to include the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向你展示另一个使用IoC容器的技巧了。在我们的构造函数中，我们需要能够从`Xamarin.Forms`库中创建一个新的`Command`对象。在这里我们很幸运，因为`Xamarin.Forms`中的命令从`System.Windows.Input`继承了`ICommand`接口，所以我们能够将这个对象注册到IoC容器中。打开`XamFormsModule.cs`文件，并更新`Register`函数以包含以下内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take note that we are registering this type as an `InstancePerDependency` because
    we want an independent instance every time we create a command in the view model
    constructors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将此类型注册为`InstancePerDependency`，因为我们希望在视图模型构造函数中创建命令时每次都得到一个独立的实例。
- en: 'Now let''s create a new command through the constructor of `MainPageViewModel`;
    update the constructor like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过`MainPageViewModel`的构造函数创建一个新的命令；更新构造函数如下：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the constructor, we are pulling a `Func` out of the `IoC` container, which
    takes an Action and returns an `ICommand` object, because we have registered this
    interface to a `Xamarin.FormsCommand` object, we will be left with a new `Command`
    with the action passed in the constructor as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们从`IoC`容器中拉出一个`Func`，它接受一个Action并返回一个`ICommand`对象，因为我们已经将这个接口注册到了`Xamarin.FormsCommand`对象，所以我们将得到一个新的`Command`，其动作是构造函数中传入的，如下所示：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is exactly the same as doing this if we were using the `Xamarin.Forms`
    library:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们使用`Xamarin.Forms`库时做的是完全一样的：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we have a new `Command` set with and `Action` to push a new `MapPage` onto
    the stack when the button is pressed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个新的`Command`集合和`Action`，当按钮被按下时，可以将新的`MapPage`推入堆栈：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now to register our new view model with the `IoC` container. Create a new folder
    called `Modules` for the portable `IoC` module. Create a new file called `PortableModule.cs`
    and paste in the preceding code into it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将我们的新视图模型注册到`IoC`容器中。为可移植的`IoC`模块创建一个名为`Modules`的新文件夹。创建一个名为`PortableModule.cs`的新文件，并将前面的代码粘贴进去。
- en: Integrating Google Maps using Xamarin.Forms.Maps
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Xamarin.Forms.Maps集成Google Maps
- en: 'Our next step is to implement the `MapPage`; this page will show a panel that
    will display Google Maps. Underneath this panel, we will also display the location
    information (latitude, longitude, address, and so on) retrieved from our native
    platform core location services. To access these native services, we need to import
    `Xamarin.Forms.Maps`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是实现 `MapPage`；这个页面将显示一个面板，该面板将显示 Google Maps。在这个面板下方，我们还将显示从我们的本地平台核心位置服务检索到的位置信息（纬度、经度、地址等）。要访问这些本地服务，我们需要导入
    `Xamarin.Forms.Maps`：
- en: '![Integrating Google Maps using Xamarin.Forms.Maps](img/B05293_03_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Xamarin.Forms.Maps 集成 Google Maps](img/B05293_03_02.jpg)'
- en: 'Now that we have imported the `Xamarin.Forms.Maps` library, we can access the
    native Google Maps services. We can now create the `Map` user interface element
    via `MapPage.xaml`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了 `Xamarin.Forms.Maps` 库，我们可以访问本地的 Google Maps 服务。现在我们可以通过 `MapPage.xaml`
    创建 `Map` 用户界面元素：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See at the top how we imported the `Xamarin.Forms.Maps` library?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看看顶部我们是如何导入 `Xamarin.Forms.Maps` 库的？
- en: We have created four rows in the `Grid`, one for the `Map` (this will cover
    most of the screen), one for a label that will display the address, and two buttons
    for starting/stopping location updates and finding the closest location out of
    a list of addresses.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Grid` 中创建了四行，一行用于 `Map`（这将覆盖大部分屏幕），一行用于显示地址的标签，以及两个按钮用于启动/停止位置更新和从地址列表中查找最近的位置。
- en: So where does the address come from?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么地址是从哪里来的？
- en: We now need to implement the core location service; this is a background service
    that will send position information based upon your location. The information
    returned is very detailed; we can depict exact longitude and latitude values,
    as well as addresses.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要实现核心位置服务；这是一个后台服务，它将根据您的位置发送位置信息。返回的信息非常详细；我们可以描绘确切的经纬度值，以及地址。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Core location services can drain device battery life, so when using core location,
    we must manage the usage and turn it on and off when required. As this is a background
    service, when the app is placed in the background, the location service will still
    be running.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 核心位置服务可能会耗尽设备电量，因此在使用核心位置时，我们必须管理使用情况，并在需要时打开和关闭它。由于这是一个后台服务，当应用置于后台时，位置服务仍然会运行。
- en: To begin our core location implementation, we are going to create an abstracted
    geolocation interface called **IGeolocator**, but first we are going to add another
    library for processing our location updates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的核心位置实现，我们将创建一个名为 **IGeolocator** 的抽象地理位置接口，但首先我们需要添加另一个库来处理我们的位置更新。
- en: Reactive Extensions
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Reactive Extensions
- en: If you haven't heard of the RX framework before, you are about to enter a never-ending
    rabbit hole of asynchrony. RX gives developers the ability to use LINQ-style query
    operations for processing objects in observable sequences. It allows for full
    control over event-based operations between different elements of an application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有听说过 RX 框架，你即将进入一个关于异步的永无止境的兔子洞。RX 给开发者提供了使用 LINQ 风格的查询操作来处理可观察序列中对象的权限。它允许对应用程序不同元素之间基于事件的操作进行完全控制。
- en: In our project, we are going to use a **Subject** for handling location events
    received on the native side. In cross-platform development, because we work in
    both PCL and native-level projects, it involves passing data and events up and
    down the project structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用一个 **Subject** 来处理在本地端接收到的位置事件。在跨平台开发中，因为我们同时在 PCL 和本地级别项目中工作，这涉及到在项目结构中上下传递数据和事件。
- en: We could use the `event` framework, which is standard in c-sharp, but instead
    we are going to use a `Subject` to push events into an observable sequence, while
    we subscribe to the subject at a lower level to receive and handle these events.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的 c-sharp 中的 `event` 框架，但我们将使用一个 `Subject` 将事件推送到一个可观察序列中，同时我们在较低级别订阅主题以接收和处理这些事件。
- en: 'Let''s start by importing the **Reactive Extensions** interface in our native
    and PCL projects:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在我们的本地和 PCL 项目中导入 **Reactive Extensions** 接口开始：
- en: '![Reactive Extensions](img/B05293_03_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Reactive Extensions](img/B05293_03_03.jpg)'
- en: 'Now let''s create our `IGeolocator` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的 `IGeolocator` 类：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice the interface `IPosition`? We must also create a new interface, which
    is going to store all the location information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `IPosition` 接口吗？我们还必须创建一个新的接口，它将存储所有位置信息：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The interface is designed to return these variables to be used for the `Xamarin.Forms`
    geolocator, so we can pull down address information. This information is returned
    by `CLLocationManager` with every position update.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接口设计用于返回这些变量以供`Xamarin.Forms` geolocator使用，这样我们就可以拉取地址信息。这些信息由`CLLocationManager`在每次位置更新时返回。
- en: Why do we need to create an interface for the position information?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要为位置信息创建一个接口？
- en: As this information comes from different native services, we want to create
    our own object to contain the information we need in the lower-level projects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些信息来自不同的本地服务，我们希望创建自己的对象来包含在底层项目中需要的信息。
- en: Core location with iOS and the CLLocationManager library
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS和CLLocationManager库的核心定位
- en: '`CLLocationManager` is used for the delivery of location and heading events;
    we must use this object in our Geolocator implementation, so let''s begin:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLLocationManager`用于位置和航向事件的传递；我们必须在我们的Geolocator实现中使用此对象，所以让我们开始：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From our interface, we must include the `Subject`. Now let''s instantiate `CLLocationManager`.
    First, we must import the `CoreLocation` library:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的接口，我们必须包含`Subject`。现在让我们实例化`CLLocationManager`。首先，我们必须导入`CoreLocation`库：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we instantiate `CLLocationManager` in the constructor when this is created
    through the IoC container. According to iOS standards, since changes to iOS 9
    and iOS 8, we must implement a few separate calls to allow the location manager
    to begin sending location events:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过IoC容器创建`CLLocationManager`时在构造函数中实例化它。根据iOS标准，由于iOS 9和iOS 8的变化，我们必须实现一些单独的调用，以允许位置管理器开始发送位置事件：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is nothing major; in iOS 8 we must request the authorization before using
    the location manager. For iOS 9, we can also set some conditional settings. For
    our example, we have used this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是什么大问题；在iOS 8中，我们必须在使用位置管理器之前请求授权。对于iOS 9，我们还可以设置一些条件设置。在我们的例子中，我们使用了以下设置：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This allows the location manager to keep sending events, even when the app
    is in the background. We can also do this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许位置管理器在应用处于后台时继续发送事件。我们还可以这样做：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will only allow events from `CLLocationManager` when the app is in the
    foreground. There are multiple settings that can be changed, between controlling
    location events in the foreground and background when using location services.
    We want to know whether our app is going to keep updates running in the background/foreground.
    Most of the time, we want location updates when the app is in the foreground to
    reduce battery consumption, but there are scenarios where updates should continue
    in the background.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只允许在应用处于前台时从`CLLocationManager`接收事件。在使用位置服务时，可以在前台和后台控制位置事件之间更改多个设置。我们想知道我们的应用是否将在后台/前台持续运行更新。大多数时候，我们希望在应用处于前台时进行位置更新以减少电池消耗，但也有一些场景下更新应该在后台继续。
- en: 'Now for the rest of the class; let''s begin handling the location events:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续处理类的其余部分；让我们开始处理位置事件：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous function is called every time we receive a location update from `CLLocationManager`.
    From the event argument `CLLocationsUpdatedEventArgs`, we pull out a list of locations;
    as sometimes the `CLLocationManager` receives multiple updates at one time, we
    always want to take the very last location. Then once we create a new `Position`,
    assign the latitude and longitude values, and by calling the `OnNext` function,
    we push a new event into the observable sequence.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们从`CLLocationManager`接收到位置更新时，都会调用前面的函数。从事件参数`CLLocationsUpdatedEventArgs`中，我们提取出位置列表；由于`CLLocationManager`有时会一次性接收到多个更新，我们总是希望获取最后一个位置。然后一旦我们创建了一个新的`Position`，分配纬度和经度值，并通过调用`OnNext`函数，我们将一个新的事件推入可观察序列。
- en: Our next step is to add some small additions to the `info.plist` file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是向`info.plist`文件添加一些小的修改。
- en: 'Let''s add the following keys:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加以下键：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code is from the source of the `info.plist` file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码来自`info.plist`文件的源代码。
- en: 'The `NSLocationAlwaysUsageDescription` and `NSLocationWhenInUseUsageDescription`
    keys will be displayed to the user in the alert that requests location data access.
    We must also add the background modes for the location in which we can set the
    iOS project properties:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSLocationAlwaysUsageDescription`和`NSLocationWhenInUseUsageDescription`键将在请求位置数据访问的警告中显示给用户。我们还必须添加位置的后台模式，我们可以设置iOS项目的属性：'
- en: '![Core location with iOS and the CLLocationManager library](img/B05293_03_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![iOS和CLLocationManager库的核心定位](img/B05293_03_04.jpg)'
- en: 'Now we must implement the `Start` and `Stop` functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须实现`Start`和`Stop`函数：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Start` function will check whether location services have been enabled,
    assign the `LocationsUpdated` event, and start the location updates:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`函数将检查位置服务是否已启用，分配`LocationsUpdated`事件，并开始位置更新：'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Stop` function will do nothing more than stop the location updates and
    remove the event handler. That's all for the iOS geolocator. Next, we must register
    this interface through the IoC container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`函数将不会做更多的事情，只是停止位置更新并移除事件处理器。这就是iOS地理定位器的全部内容。接下来，我们必须通过IoC容器注册这个接口。'
- en: Handling location updates
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理位置更新
- en: Our next step is to build the `MapPageViewModel`; this view model will contain
    the `IGeolocator` we just built. We will also be listening for location updates
    from the observable sequence and processing latitude and longitude values to gather
    address details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是构建`MapPageViewModel`；这个视图模型将包含我们刚刚构建的`IGeolocator`。我们还将监听来自可观察序列的位置更新，并处理纬度和经度值以收集地址详情。
- en: 'Let''s begin with the constructor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构造函数开始：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our constructor will retrieve the navigation service and the geolocator. Notice
    how we assign the `geolocator` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数将检索导航服务和地理定位器。注意我们如何分配`geolocator`类：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The constructor will also be responsible for creating the commands for the
    two buttons on our map page. Any view models that require objects from the IoC
    container are usually assigned as read-only properties because they will never
    change. We want the property name to be the exact same as the item in the constructor
    argument:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还将负责创建地图页面上两个按钮的命令。通常，需要从IoC容器中获取对象的视图模型通常被分配为只读属性，因为它们永远不会改变。我们希望属性名与构造函数参数中的项完全相同：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s create our private properties:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的私有属性：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have a new object, the `IDisposable` interface, which is used to take control
    of unmanaged resources, meaning we can release objects that have no control over
    memory disposal. In our case, we are going to be setting up a subscription to
    the events received via the observable sequence (`Subject`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的对象，即`IDisposable`接口，它用于控制非托管资源，这意味着我们可以释放那些无法控制内存释放的对象。在我们的例子中，我们将设置一个通过可观察序列（`Subject`）接收事件的订阅。
- en: 'Let''s look at this technique more closely:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个技术：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are going to use these functions to be called when the `MapPage` appears
    and disappears. The `OnAppear` function will create a subscription to the `Subject`,
    so whenever a new position is pushed onto the observable sequence, we will receive
    an item on the other side where we subscribed. In this case, we will be calling
    the `OnNext` function on a different subject, meaning we are passing the item
    of the observable sequence into another observable sequence.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些函数在`MapPage`出现和消失时被调用。`OnAppear`函数将创建对`Subject`的订阅，所以每当新的位置被推送到可观察序列时，我们将在我们订阅的另一侧收到一个项目。在这种情况下，我们将对另一个主题调用`OnNext`函数，这意味着我们将可观察序列的项目传递到另一个可观察序列中。
- en: What a pointless function. We will show you why soon.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有意义的函数。我们很快就会向你展示原因。
- en: We are also assigning the subscription to our `IDisposable`. A subscription
    is an unmanaged resource, meaning that without the use of an `IDisposable`, we
    can't control the release of the subscription.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将订阅分配给我们的`IDisposable`。订阅是一个非托管资源，这意味着如果没有使用`IDisposable`，我们无法控制订阅的释放。
- en: Why do we need to worry about disposing of the subscription?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要担心释放订阅？
- en: Sometimes our observable streams may be propagating events to a user interface
    on the main UI thread. If we change pages, and the previous page's view model
    is still receiving events to update the previous page's interface, this means
    the events will be changing the user interface on a different thread from the
    main UI thread, which will break the application. This is just one example, but
    cleaning up subscriptions when we aren't using them is a good practice to control
    unwanted application processing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的可观察流可能会将事件传播到主UI线程上的用户界面。如果我们更改页面，并且前一个页面的视图模型仍在接收事件以更新前一个页面的界面，这意味着事件将在主UI线程之外的另一个线程上更改用户界面，这将破坏应用程序。这只是其中一个例子，但当我们不再使用订阅时清理订阅是一个良好的实践，以控制不受欢迎的应用程序处理。
- en: 'Now for the `public` properties:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`public`属性：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All we need is a string that will be bound to `MapPageLabel` under the map
    item. It will be used to display the address of the current location. Now we must
    create a label on `MapPage`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的只是一个字符串，它将被绑定到地图项下的 `MapPageLabel`。它将用于显示当前位置的地址。现在我们必须在 `MapPage` 上创建一个标签：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our next step is to make use of the latitude and longitude values that we receive
    from `CLLocationManager`. We are going to use the `Geocoder` class to get address
    information from our positions. A `Geocoder` class is used to convert positions
    (latitudes and longitudes) into address information. We could actually do this
    conversion on the native side, but the idea of this exercise is to show you what
    is available in `Xamarin.Forms` to share between the different platforms.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是利用我们从 `CLLocationManager` 收到的纬度和经度值。我们将使用 `Geocoder` 类从我们的位置获取地址信息。`Geocoder`
    类用于将位置（纬度和经度）转换为地址信息。我们实际上可以在本地端进行此转换，但这个练习的目的是向您展示 `Xamarin.Forms` 中可用于在不同平台之间共享的内容。
- en: Now let's get back to answering the questions about passing events between two
    observable sequences.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到回答关于在两个可观察序列之间传递事件的问题。
- en: 'Let''s start building the `MapPage.xaml.cs` sheet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建 `MapPage.xaml.cs` 文件：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here we create another two `IDisposables` for handling the events from the
    view-model. We will also be subscribing to and disposing on the page''s appearing
    and disappearing events, so now add the `HandleAppearing` and `HandleDisappearing` functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了另外两个 `IDisposables` 来处理来自视图模型的事件。我们还将订阅和处置页面的出现和消失事件，所以现在添加 `HandleAppearing`
    和 `HandleDisappearing` 函数：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also create a new `Geocoder`, so every time we receive an event from the
    observable sequence in the view model, we use this position to retrieve the address
    information from `Geocoder` via the following function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新的 `Geocoder`，所以每次我们从视图模型中的可观察序列接收到事件时，我们都会使用这个位置通过以下函数从 `Geocoder`
    中检索地址信息：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That is everything we need to retrieve our latitude and longitude positions,
    as well as update the current address. The last step of our iOS version is to
    update the position on the map; we want the map view to zoom in to our current
    position and place the blue marker on the map. Next, we add the following to the
    end of `LocationChanged` function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要用来检索我们的纬度和经度位置以及更新当前地址的所有内容。我们 iOS 版本的最后一步是在地图上更新位置；我们希望地图视图放大到我们的当前位置，并将蓝色标记放置在地图上。接下来，我们在
    `LocationChanged` 函数的末尾添加以下内容：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `MoveToRegion` function requires a `MapSpan`; a `MapSpan` is created from
    the latitude, longitude point and the radius from the position point. A circle
    will be drawn from the point to give the view radius to be shown on the map; in
    our case the radius is 0.3 miles around the latitude and longitude position.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MoveToRegion` 函数需要一个 `MapSpan`；`MapSpan` 是从纬度、经度点和从位置点开始的半径创建的。从点绘制一个圆，以给出在地图上显示的视图半径；在我们的情况下，半径是纬度和经度位置周围的
    0.3 英里。'
- en: The `ContinueWith` function is used to execute some extra work as soon as the
    task finishes. As soon as we have retrieved all the possible address names, we
    wake the first on the list and assign it to the `Address` property of the variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith` 函数用于在任务完成时执行一些额外的工作。一旦我们检索到所有可能的地址名称，我们就唤醒列表中的第一个，并将其分配给变量的
    `Address` 属性。'
- en: 'Our final step is to complete the rest of the project; we must first create
    an iOS module for registering the geolocator class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一步是完成项目的其余部分；我们首先必须为地理定位器类创建一个 iOS 模块：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then finally we add the extras to the `AppDelegate.cs` file (exactly the same
    as the previous example iOS project):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后最后，我们将额外的代码添加到 `AppDelegate.cs` 文件中（与之前的示例 iOS 项目完全相同）：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Excellent! Let's run the project and click on the **Find Location** button.
    Watch the map update with the address shown in the preceding label.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们运行项目并点击 **查找位置** 按钮。观察地图如何更新，并显示在前面标签中显示的地址。
- en: Let's move on to the Android project and implement the same features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到 Android 项目并实现相同的功能。
- en: Android and the LocationManager
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 和 LocationManager
- en: The Android `LocationManager` works like the `CLLocationManager`, but we will
    use an observable sequence to handle location updates. When a location update
    is received, a new Position object is instantiated with the latitude and longitude
    values from the location update. Then the resulting Position is pushed on to the
    Geolocator's Subject.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Android `LocationManager` 的工作方式类似于 `CLLocationManager`，但我们将使用可观察序列来处理位置更新。当接收到位置更新时，会实例化一个新的
    `Position` 对象，其中包含位置更新的纬度和经度值。然后，得到的 `Position` 被推送到 `Geolocator` 的 Subject。
- en: 'First we create the `Geolocator` implementation. It must also inherit the `ILocationListener`
    interface:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建 `Geolocator` 实现。它也必须继承 `ILocationListener` 接口：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You may have noticed the `#define` keywords. These are useful for separating
    different sections and for referencing locations in code sheets, making code more
    readable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 `#define` 关键字。这些关键字对于分隔不同的部分和在代码表中引用位置非常有用，使代码更易于阅读。
- en: The only one we are concerned about is the `OnLocationChanged` function; whenever
    a location update is received by the location manager, the listener function will
    be called with the latitude and longitude values, and we will then use these values
    to push into the observable sequence for the `Geocoder` and `MapSpan`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一关心的是 `OnLocationChanged` 函数；每当位置管理器接收到位置更新时，监听器函数将被调用，并带有纬度和经度值，然后我们将使用这些值将它们推入
    `Geocoder` 和 `MapSpan` 的可观察序列。
- en: We also have to implement the extra requirements for the `ILocationListener`
    interface. Since this interface inherits the `IJavaObject` interface, we are required
    to implement the `Dispose` function and the `IntPtr` object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须实现 `ILocationListener` 接口的额外要求。由于该接口继承了 `IJavaObject` 接口，我们被要求实现 `Dispose`
    函数和 `IntPtr` 对象。
- en: 'To save time, we can have the class inherit the `Java.Lang.Object` class like
    this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省时间，我们可以让类继承 `Java.Lang.Object` 类，如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we add the constructor:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加构造函数：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the constructor, we pull out the required system service using the `GetSystemService`
    function for the location service. The line underneath simply retrieves the `NetworkProvider`
    of the `LocationManager`; we need to use this for starting the location updates.
    There are further configurations we can set for retrieving correct providers (mainly
    logging purposes), but in this example we aren't going to bother too much as we
    are only interested in retrieving location positions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们使用 `GetSystemService` 函数获取所需的位置服务系统服务。下面的行简单地检索 `LocationManager` 的
    `NetworkProvider`；我们需要使用这个来启动位置更新。我们可以设置进一步的配置来获取正确的提供者（主要是日志记录目的），但在本例中我们不会太在意，因为我们只对检索位置位置感兴趣。
- en: 'Now it''s time to implement the other required functions of the `IGeolocator`
    interface:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现 `IGeolocator` 接口的其他所需函数了：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Start` function will first check whether we have these services enabled,
    then by calling the `RequestLocationUpdates` function, we pass in the provider,
    the minimum time between locations updates, the minimum location distance between
    updates, and the pending intent to be called on each location update; in our case,
    this is the geolocator (the same class that started the location updates) as we
    have implemented the `ILocationListener` class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 函数首先会检查我们是否已启用这些服务，然后通过调用 `RequestLocationUpdates` 函数，我们传入提供者、位置更新的最小时间间隔、更新之间的最小位置距离以及每个位置更新时需要调用的挂起意图；在我们的案例中，这是地理定位器（与启动位置更新的相同类），因为我们实现了
    `ILocationListener` 类。'
- en: 'The `Stop` function simply removes the updates from the `Geolocator`, which
    in turn will stop the location updates from the location manager. Our next step
    in implementing the Android `Geolocator` is to create the Android IoC module,
    and register this implementation in the IoC container:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop` 函数简单地从 `Geolocator` 中移除更新，这反过来会停止来自位置管理器的位置更新。我们在实现 Android `Geolocator`
    的下一步是创建 Android IoC 模块，并在 IoC 容器中注册此实现：'
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Our final step is to set up the `MainActivity` class, which is exactly the
    same as the previous project:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的步骤是设置 `MainActivity` 类，这与之前的工程完全相同：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take note of how much code we are starting to reuse from previous projects.
    Why reinvent the wheel when we can save a lot of time by pulling from similar
    problems that have already been solved in other projects?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们开始从以前的项目中重用多少代码。为什么要在可以节省大量时间的情况下重新发明轮子，从其他项目中已经解决的问题中抽取相似的问题呢？
- en: 'The last step in the Android project is to apply some Android permissions to
    allow your app to use location services. Open up the `Mainfest.xml` and add the
    following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Android 项目的最后一步是为应用使用位置服务申请一些 Android 权限。打开 `Mainfest.xml` 并添加以下内容：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Inside the `<application>` tag, we have to place `API_KEY`, which is generated
    from the Google APIs platform (we will be doing this later). We then have to add
    the `ACCESS_FINE_LOCATION`, `ACCESS_COARSE_LOCATION`, and `ACCESS_NETWORK_STATE`
    permissions for **LocationManager** to work. We can switch these permissions on
    through the **Application** window:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<application>` 标签内部，我们必须放置 `API_KEY`，这是从 Google API 平台生成的（我们将在稍后进行此操作）。然后我们必须为
    `LocationManager` 工作添加 `ACCESS_FINE_LOCATION`、`ACCESS_COARSE_LOCATION` 和 `ACCESS_NETWORK_STATE`
    权限。我们可以通过 **Application** 窗口切换这些权限：
- en: '![Android and the LocationManager](img/B05293_03_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Android 和 LocationManager](img/B05293_03_05.jpg)'
- en: Creating an exit point
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建退出点
- en: 'You may have noticed the extra button added on the starting page for exiting
    the application. We will have to go ahead and create an abstracted object for
    exiting the application. Start by creating a new folder called `Extras`, then
    create a new file for the `IMethods` interface:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到启动页上添加了额外的退出应用程序的按钮。我们将创建一个抽象的退出应用程序对象。首先创建一个名为 `Extras` 的新文件夹，然后为 `IMethods`
    接口创建一个新文件：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before moving on with the tutorial, have a go at implementing the native side
    for each project on your own.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续教程之前，尝试自己实现每个项目的本地端。
- en: 'Let''s begin with the iOS version:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 iOS 版本开始：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the iOS version, we must dig into the `SharedApplication` object and perform
    a selector method `terminateWithSuccess`. We must then register this new object
    in our iOS module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iOS 版本，我们必须深入到 `SharedApplication` 对象中并执行一个选择器方法 `terminateWithSuccess`。然后我们必须在我们的
    iOS 模块中注册这个新对象：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now the Android implementation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 Android 实现步骤：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Using the Android operating system namespace, we use the static item `Process`
    to call the function `KillProcess` on the main process. Again, we also register
    this within the IoC container:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android 操作系统命名空间，我们使用静态项 `Process` 调用主进程上的 `KillProcess` 函数。同样，我们也在 IoC 容器中注册了这个函数：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we use the `IMethods` interface in our `MainPageViewModel` to call
    the exit function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在 `MainPageViewModel` 中使用 `IMethods` 接口调用退出函数：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Looking at this more closely, we are using the command factory to initialize
    the exit command to a new `Xamarin.Forms Command`, and when this command is executed,
    it will call the `Exit` method from the `IMethods` interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们使用命令工厂将退出命令初始化为一个新的 `Xamarin.Forms Command`，当这个命令被执行时，它将调用 `IMethods`
    接口中的 `Exit` 方法。
- en: Our last step is to create an API key using the Google APIs for our Android
    version.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是使用 Google API 为我们的 Android 版本创建一个 API 密钥。
- en: Creating an API key for Android
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Android 创建 API 密钥
- en: 'In order for us to create an API key, we will have to access the Google API
    portal. Android requires this extra step when configuring Google Maps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们能够创建 API 密钥，我们必须访问 Google API 门户。在配置 Google Maps 时，Android 需要执行这个额外的步骤：
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will need a Google Developer account to complete this section.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个 Google 开发者账户来完成本节。
- en: 'Visit the following link to create a new project in the API portal: [https://console.developers.google.com/iam-admin/projects](https://console.developers.google.com/iam-admin/projects).![Creating
    an API key for Android](img/B05293_03_06.jpg)'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问以下链接以在 API 门户中创建一个新项目：[https://console.developers.google.com/iam-admin/projects](https://console.developers.google.com/iam-admin/projects).![为
    Android 创建 API 密钥](img/B05293_03_06.jpg)
- en: Select **Create Project** from the top menu and call the project `Locator`:![Creating
    an API key for Android](img/B05293_03_07.jpg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单选择 **创建项目** 并将项目命名为 `Locator`：![为 Android 创建 API 密钥](img/B05293_03_07.jpg)
- en: Tip
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For more information on setting up an API key, visit this link: [https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key).'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关设置 API 密钥的更多信息，请访问此链接：[https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key](https://developers.google.com/maps/documentation/javascript/get-api-key#get-an-api-key).
- en: Once we have our new project, visit the API Manager and select the **Google
    Maps Android API**:![Creating an API key for Android](img/B05293_03_08.jpg)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了新的项目，访问 API 管理器并选择 **Google Maps Android API**：![为 Android 创建 API 密钥](img/B05293_03_08.jpg)
- en: Select the **Enable** button, then click **Credentials** from the left-hand
    menu. We want to create a new **API key** from the drop-down list:![Creating an
    API key for Android](img/B05293_03_09.jpg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **启用** 按钮，然后点击左侧菜单中的 **凭据**。我们想要从下拉列表中创建一个新的 **API 密钥**：![为 Android 创建 API
    密钥](img/B05293_03_09.jpg)
- en: Make sure we select an **Android key**:![Creating an API key for Android](img/B05293_03_10.jpg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们选择一个 **Android 密钥**：![为 Android 创建 API 密钥](img/B05293_03_10.jpg)
- en: We are going to leave the name as `Android key 1`. Now click the **Create**
    button:![Creating an API key for Android](img/B05293_03_11.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保留名称为 `Android key 1`。现在点击 **创建** 按钮：![为 Android 创建 API 密钥](img/B05293_03_11.jpg)
- en: Finally, let's select our Android key and place it in the `AndroidManifest.xml`
    file where it states `YOUR-API-KEY`:![Creating an API key for Android](img/B05293_03_12.jpg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们选择我们的 Android 密钥并将其放置在 `AndroidManifest.xml` 文件中，该文件中声明了 `YOUR-API-KEY`：![为
    Android 创建 API 密钥](img/B05293_03_12.jpg)
- en: Congratulations, we have now integrated the iOS and Android location services
    with Google Maps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们现在已经将 iOS 和 Android 定位服务与 Google Maps 集成。
- en: Now let's move on to the Windows Phone version.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到 Windows Phone 版本。
- en: Creating our Windows project
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的 Windows 项目
- en: 'Moving on to Visual Studio once again, let start by creating a new c-shape
    universal Windows project and calling it `Locator.WinRT`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进入 Visual Studio，我们首先创建一个新的 c-shape 通用的 Windows 项目，并将其命名为 `Locator.WinRT`：
- en: '![Creating our Windows project](img/B05293_03_13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的 Windows 项目](img/B05293_03_13.jpg)'
- en: We can remove the Windows store and shared projects. Before you remove the shared
    projects, move the `app.xaml` files into the Windows Phone project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除 Windows 商店和共享项目。在移除共享项目之前，将 `app.xaml` 文件移动到 Windows Phone 项目中。
- en: Tip
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `Map` object from `Xamarin.Forms.Maps` is not usable in Windows Phone 8.1\.
    We have to use the universal platform instead.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Xamarin.Forms.Maps` 中的 `Map` 对象在 Windows Phone 8.1 中不可用。我们必须使用通用平台。'
- en: 'For our Windows Phone version, we need the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Windows Phone 版本，我们需要以下内容：
- en: A Windows Phone module for registering the geolocator and methods interfaces
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于注册定位器和接口方法的 Windows Phone 模块
- en: To implement the geolocator interface
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现定位器接口
- en: To implement the methods interface
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方法接口
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have a think about that for a second...
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看...
- en: '**That''s all we have to do to replicate the application for Windows Phone?**
    Think how much extra work would be involved if we were to rebuild this app from
    scratch entirely on the Windows platform.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**这就是我们要做的，以复制 Windows Phone 应用程序吗？** 想想如果我们完全从零开始在 Windows 平台上重建这个应用程序，会有多少额外的工作要做。'
- en: 'Next, add the three folders, `Modules`, `Location`, and `Extras`, and create
    a new `.cs` file for each folder and name them accordingly: `WinPhoneModule.cs`,
    `GeolocatorWinPhone.cs`, and `WinPhoneMethods.cs`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加三个文件夹，`Modules`、`Location` 和 `Extras`，并为每个文件夹创建一个新的 `.cs` 文件，并相应地命名它们：`WinPhoneModule.cs`、`GeolocatorWinPhone.cs`
    和 `WinPhoneMethods.cs`。
- en: 'Firstly, we have to change the targets of the PCL projects to be compatible
    with the Windows Phone frameworks. Select the **Windows Phone 8.1** target for
    both PCL projects, then the Windows project can reference the two PCL projects:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须更改 PCL 项目的目标，使其与 Windows Phone 框架兼容。选择两个 PCL 项目的 **Windows Phone 8.1**
    目标，然后 Windows 项目可以引用这两个 PCL 项目：
- en: '![Creating our Windows project](img/B05293_03_14.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的 Windows 项目](img/B05293_03_14.jpg)'
- en: We must also import the `Xamarin.Forms`, `Xamarin.Forms.Maps`, and `Autofacnuget`
    packages.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须导入 `Xamarin.Forms`、`Xamarin.Forms.Maps` 和 `Autofacnuget` 包。
- en: Core Location Services with Windows Phone
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows Phone 的核心定位服务
- en: 'Now for the exciting part. Let''s integrate the core location services. First,
    we must turn on certain permissions. Open up the `package.appmanifest` file, select
    the **Capabilities** tab, and select the **Location** checkbox:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是激动人心的部分。让我们集成核心定位服务。首先，我们必须打开某些权限。打开 `package.appmanifest` 文件，选择 **功能** 选项卡，并选择
    **位置** 复选框：
- en: '![Core Location Services with Windows Phone](img/B05293_03_15.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Phone 的核心定位服务](img/B05293_03_15.jpg)'
- en: Secondly, open the `GeolocatorWinPhone.cs` file, and let's start building the
    Windows Phone locator class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，打开 `GeolocatorWinPhone.cs` 文件，让我们开始构建 Windows Phone 定位器类。
- en: 'Let''s start by creating the constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建构造函数开始：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We are implementing a native `Geolocator` from the interface `IGeolocator`,
    meaning we need to create an observable sequence for the positions. We also need
    a `Geolocator` object to receive location updates, which we will use to push events
    into the sequence. With all native locators, we can set accuracy for location
    points, which is what we are doing with the following line:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从`IGeolocator`接口实现一个本地的`Geolocator`，这意味着我们需要为位置创建一个可观察的序列。我们还需要一个`Geolocator`对象来接收位置更新，我们将使用它将事件推送到序列中。对于所有本地的定位器，我们可以为位置点设置精度，这正是我们在以下行中所做的：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our next step is to implement the `Start` and `Stop` functions:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是实现`Start`和`Stop`函数：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `Start` function uses `Geolocator` to retrieve the positions with the asynchronous
    function `GetGeopositionAsync`. The function will take the maximum age of a location,
    meaning once the time period is passed, the location will update again. The request
    for this location will cancel when the timeout value is reached during a location
    update. We also listen on the event handler `PositionChanged` via the following
    function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`函数使用`Geolocator`通过异步函数`GetGeopositionAsync`检索位置，该函数将位置的最大年龄作为参数，这意味着一旦时间周期过去，位置将再次更新。当位置更新期间达到超时值时，对这个位置的请求将被取消。我们还在以下函数中监听事件处理程序`PositionChanged`：'
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We actually have two places, which will push a new geoposition's latitude and
    longitude into the observable sequence.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们有两个地方，它们会将新的地理位置的纬度和经度推送到可观察的序列中。
- en: 'Now we add the `Stop` function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加`Stop`函数：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: All this does is remove the event handler function that we assigned in the `Start`
    function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的只是移除了我们在`Start`函数中分配的事件处理函数。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should be noticing the development patterns with this project, how we implement
    abstracted interfaces, generate modules, register types, and so on. The processes
    are all the same, no matter what platform.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在这个项目中注意到发展模式，比如我们如何实现抽象接口、生成模块、注册类型等等。这些流程在所有平台上都是一样的。
- en: 'That''s all for the `Geolocator` class; we can now get on to the `WinPhoneModule`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Geolocator`类的全部内容；我们现在可以继续到`WinPhoneModule`：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now let's get to the `WinPhoneMethods` class. We only need to implement the
    one function, `Exit`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看`WinPhoneMethods`类。我们只需要实现一个函数，`Exit`。
- en: The Application class
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序类
- en: 'The static class `Application` plays a similar role to the iOS `UIApplication`
    class. We simply reference the current application, and terminate:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类`Application`在iOS的`UIApplication`类中扮演着类似的角色。我们只是引用当前的应用程序，并终止：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we simply build the remaining elements with the `MainPage.xaml` page:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需用`MainPage.xaml`页面构建剩余的元素：
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And we do it for the `MainPage.xaml.cs` file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在`MainPage.xaml.cs`文件中这样做：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Exactly the same as the previous chapter, we are starting the `IoC` container,
    adding our modules, and loading the `Xamarin.Forms.App` object. The only difference
    is the `SharedModule`, as we pass in true so the `NativeMessageHandler` is used.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章完全相同，我们正在启动`IoC`容器，添加我们的模块，并加载`Xamarin.Forms.App`对象。唯一的区别是`SharedModule`，因为我们传入true所以使用`NativeMessageHandler`。
- en: Finally, we have one more issue to address. Since `Xamarin.Forms` 1.5, only
    Windows Phone Silverlight is supported for using Google Maps. We have to add an
    additional library to use maps in Windows Phone 8.1.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个问题要解决。自从`Xamarin.Forms` 1.5以来，只有Windows Phone Silverlight支持使用Google
    Maps。我们必须添加一个额外的库来在Windows Phone 8.1中使用地图。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Personal thanks to *Peter Foot* for addressing this issue.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢*Peter Foot*解决这个问题。
- en: Luckily, an open source library is available to address this issue. We must
    install the nuget package `InTheHand.Forms.Maps`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个开源库可以解决这个问题。我们必须安装nuget包`InTheHand.Forms.Maps`。
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This library is only available up to `Xamarin.Forms` 2.1.0.6529, meaning this
    entire example must stick to this version of `Xamarin.Forms`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库仅适用于`Xamarin.Forms` 2.1.0.6529，这意味着整个示例必须坚持这个版本的`Xamarin.Forms`。
- en: 'Then, inside `App.xaml.cs`, we need to initialize `Xamarin.Forms` and `Xamarin.Forms.Maps`.
    The `Xamarin.Forms.Maps` framework is initialized through the library `InTheHand.Forms.Maps`
    like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`App.xaml.cs`内部，我们需要初始化`Xamarin.Forms`和`Xamarin.Forms.Maps`。`Xamarin.Forms.Maps`框架通过`InTheHand.Forms.Maps`库这样初始化：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Just like that, we now have the application on Windows Phone. Now that we have
    core location services running with Google Maps, let's take things one step further
    with the Google API platforms.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那样，我们现在已经在Windows Phone上有了应用程序。现在我们已经有了运行在Google Maps上的核心位置服务，让我们通过Google
    API平台更进一步。
- en: Web services and data contracts
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务和数据合约
- en: We are now going to look at creating a web service controller to access web
    services provided by Google. These are useful implementations for downloading
    JSON data, deserializing it, and feeding this data in observable sequences for
    processing. With a web service controller, we get to use more of the `IObservable`
    interface. These sequences will be used to take in deserialized JSON objects from
    a web source, and feed these into our view models.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨创建一个网络服务控制器来访问Google提供的网络服务。这些是实现下载JSON数据、反序列化它并将这些数据馈送到可观察序列以进行处理的有用实现。有了网络服务控制器，我们可以使用更多的`IObservable`接口。这些序列将用于从网络源接收反序列化的JSON对象，并将这些对象馈送到我们的视图模型中。
- en: Our web service controller will be kept inside the **Locator.Portable** project.
    Remember, we can share this work across the different platforms as all use some
    form of HTTP client to connect to a web URL.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的网络服务控制器保存在**Locator.Portable**项目中。记住，我们可以跨不同平台共享这项工作，因为所有平台都使用某种形式的HTTP客户端来连接到Web
    URL。
- en: What about data contracts?
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于数据合约？
- en: Your data contract is a JSON object that is used to absorb the elements of the
    deserialized objects, so whenever we pull down raw JSON data, your contract will
    be the deserialized object or objects.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据合约是一个JSON对象，用于吸收反序列化对象的元素，所以每次我们拉取原始JSON数据时，您的合约将是反序列化的对象或对象。
- en: So the next question is, what data are we pulling to our application?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一个问题是，我们要从我们的应用程序中拉取哪些数据？
- en: We are going to use the Google `Geocoder` API to turn address information into
    latitude and longitude positions. We are going to pull down a list of addresses,
    calculate their latitude and longitude positions, calculate the closest address
    to our current position, and place a pin on the map.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Google的`Geocoder` API将地址信息转换为纬度和经度位置。我们将拉取一个地址列表，计算它们的纬度和经度位置，计算离我们当前位置最近的地址，并在地图上放置一个标记。
- en: 'Our first step is to create a new folder called `WebServices` in `Locator.Portable`.
    Inside this folder, we want to create another folder called `GeocodingWebServiceController`,
    and another folder inside this called `Contracts`. Let''s first implement our
    contracts. A nice quick easy way to implement your JSON objects is to use an online
    application like this one: [http://json2csharp.com/](http://json2csharp.com/).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是在`Locator.Portable`中创建一个名为`WebServices`的新文件夹。在这个文件夹内部，我们想要创建一个名为`GeocodingWebServiceController`的新文件夹，并在其中创建一个名为`Contracts`的文件夹。让我们首先实现我们的合约。实现JSON对象的一个简单快捷的方法是使用像这样的在线应用程序：[http://json2csharp.com/](http://json2csharp.com/)。
- en: 'When we are pulling down JSON data, it takes time to look through the text
    and find all the properties required for your JSON object. This provides a nice
    way is to call the web service URL, retrieve some sample JSON data, and paste
    this JSON data into the box here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拉取JSON数据时，需要花费时间来查找文本中所有必需的属性。这提供了一种很好的方式，即调用网络服务URL，检索一些示例JSON数据，并将这些JSON数据粘贴到这里的框中：
- en: '![What about data contracts?](img/B05293_03_16.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![关于数据合约？](img/B05293_03_16.jpg)'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Personal thanks to **Jonathan Keith** for saving us time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢**乔纳森·基思**为我们节省了时间。
- en: This application creates c-sharp JSON objects based on the JSON data you entered.
    Now let's get our sample JSON data to paste in the box, but before we can do this
    we have to access the **Google API**.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序根据您输入的JSON数据创建c-sharp JSON对象。现在让我们将我们的示例JSON数据粘贴到框中，但在我们能够这样做之前，我们必须访问**Google
    API**。
- en: Creating another API key for geocoding
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为地理编码创建另一个API密钥
- en: 'Log back in to the Google Developer console, and our first step is to enable
    to the Geocoding API from the API manager:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 重新登录到Google开发者控制台，我们的第一步是从API管理器中启用地理编码API：
- en: '![Creating another API key for geocoding](img/B05293_03_17-1.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![为地理编码创建另一个API密钥](img/B05293_03_17-1.jpg)'
- en: 'We then select the project `Locator` we created earlier, and this time we are
    going to create a browser key to access the Geocoding API via HTTP requests:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后选择我们之前创建的`Locator`项目，这次我们将创建一个浏览器密钥，通过HTTP请求访问地理编码API：
- en: '![Creating another API key for geocoding](img/B05293_03_18-1.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![为地理编码创建另一个API密钥](img/B05293_03_18-1.jpg)'
- en: 'Call the key `Geocoding Key` and click **Create**. We are now going to use
    this key for every HTTP request passed to the Geocoding API:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥命名为“地理编码密钥”并点击**创建**。我们现在将使用这个密钥来处理传递给地理编码API的每个HTTP请求：
- en: '![Creating another API key for geocoding](img/B05293_03_19-1.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![为地理编码创建另一个API密钥](img/B05293_03_19-1.jpg)'
- en: Creating GeocodingWebServiceController
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GeocodingWebServiceController
- en: 'Our first step creating `GeocodingWebServiceController` is to hit the web URL
    using your API key to pull down some sample JSON data; here is a test link: `https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=YOUR_API_KEY`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`GeocodingWebServiceController`的第一步是使用您的API密钥访问网络URL以拉取一些示例JSON数据；这里是一个测试链接：`https://maps.googleapis.com/maps/api/geocode/json?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA&key=YOUR_API_KEY`.
- en: 'Where it says `YOUR_API_KEY`, replace this text with your newly created API
    key, and then paste this link into the browser. You should get JSON results like
    this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在`YOUR_API_KEY`处，将此文本替换为您的全新创建的API密钥，然后将此链接粘贴到浏览器中。你应该会得到如下JSON结果：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We are going to copy and paste the entire resulting JSON into **Json2Sharp**
    to create our c-sharp objects:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制并粘贴整个生成的JSON到**Json2Sharp**中，以创建我们的c-sharp对象：
- en: '![Creating GeocodingWebServiceController](img/B05293_03_20.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![创建GeocodingWebServiceController](img/B05293_03_20.jpg)'
- en: 'There are quite a few JSON objects, so in the `Contracts` folder, create the
    following files:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有很多JSON对象，所以在`Contracts`文件夹中，创建以下文件：
- en: AddressComponentContract.cs
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AddressComponentContract.cs
- en: GeocodingContract.cs
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeocodingContract.cs
- en: GeocodingResultContract.cs
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeocodingResultContract.cs
- en: GeometryContract.cs
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GeometryContract.cs
- en: LocationContract.cs
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LocationContract.cs
- en: NortheastContract.cs
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NortheastContract.cs
- en: SouthwestContract.cs
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SouthwestContract.cs
- en: ViewportContract.cs
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewportContract.cs
- en: 'Let''s begin with `AddressComponentContract.cs`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`AddressComponentContract.cs`开始：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Make sure we keep all these contracts in the namespace `Locator.Portable.GeocodingWebServiceController.Contracts`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们将所有这些合约放在`Locator.Portable.GeocodingWebServiceController.Contracts`命名空间中。
- en: Note
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Namespaces should be named according to the folder hierarchy.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间应该按照文件夹层次结构命名。
- en: 'Now for the `GeocodingContract`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现`GeocodingContract`：
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The rest of the files are exactly the same; we simply copy the c-sharp objects
    created by **Json2Sharp**. Now it''s time to complete the others:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的文件完全相同；我们只是复制由**Json2Sharp**创建的c-sharp对象。现在是我们完成其他任务的时候了：
- en: '[PRE66]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Make sure you double-check the property names are exactly the same as the JSON
    properties, otherwise the values inside the JSON string will not be deserialized
    correctly.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你双检查属性名称与JSON属性完全相同，否则JSON字符串中的值将无法正确反序列化。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We are not going to paste in every contract, as this should be enough direction
    for you to build the others.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会粘贴每个合约，因为这应该足够指导你构建其他的。
- en: 'Now that we have our geocoding contracts, let''s create the interface for the
    `GeocodingWebServiceController`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了地理编码合约，让我们为`GeocodingWebServiceController`创建接口：
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is only a small interface; we only have one function, `GetGeocodeFromAddressAsync`.
    The function requires three arguments to build the parameters in the web URL.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的接口；我们只有一个函数，`GetGeocodeFromAddressAsync`。该函数需要三个参数来构建Web URL中的参数。
- en: Now let's implement this interface.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来实现这个接口。
- en: Tip
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A good practice with object-oriented and abstract coding is to declare interfaces
    before implementing the class which coincides; it will help you build the class
    quicker.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象和抽象编码中，一个好的做法是在实现与接口相对应的类之前声明接口；这将帮助你更快地构建类。
- en: Newtonsoft.Json and Microsoft HTTP client libraries
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Newtonsoft.Json和Microsoft HTTP客户端库
- en: 'As we are going to be deserializing JSON, we will need to import a JSON framework
    library. Newtonsoft is one of the most commonly used frameworks, so let''s import
    this library into our **Locator.Portable** project:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将要反序列化JSON，我们需要导入一个JSON框架库。Newtonsoft是最常用的框架之一，所以让我们将这个库导入到我们的**Locator.Portable**项目中：
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_21.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![Newtonsoft.Json和Microsoft HTTP客户端库](img/B05293_03_21.jpg)'
- en: 'We will also need to import the HTTP client libraries for our web service controller
    to access online web services:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入HTTP客户端库，以便我们的Web服务控制器可以访问在线Web服务：
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_22.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![Newtonsoft.Json和Microsoft HTTP客户端库](img/B05293_03_22.jpg)'
- en: 'Now that we have all the extra libraries for our **Locator.Portable** project,
    before we implement the `IGeocodingWebServiceController`, we have to make some
    additions to the project structure:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的**Locator.Portable**项目添加了所有额外的库，在我们实现`IGeocodingWebServiceController`之前，我们必须对项目结构做一些补充：
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_23.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![Newtonsoft.Json和Microsoft HTTP客户端库](img/B05293_03_23.jpg)'
- en: 'Right-click on the **Locator** and create a new shared project called **Locator.Shared**:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击**Locator**并创建一个名为**Locator.Shared**的新共享项目：
- en: '![Newtonsoft.Json and Microsoft HTTP client libraries](img/B05293_03_24.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![Newtonsoft.Json 和 Microsoft HTTP 客户端库](img/B05293_03_24.jpg)'
- en: ModernHttpClient and client message handlers
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ModernHttpClient 和客户端信息处理器
- en: In this project, we will be creating a shared module to register a `HttpClientHandler` class
    in the IoC container. `HttpClientHandler` is a message handler class that receives
    a HTTP request and returns a HTTP response. Message handlers are used on both
    the client and server side for handling/delegating requests between different
    end points.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个共享模块来在 IoC 容器中注册 `HttpClientHandler` 类。`HttpClientHandler` 是一个消息处理器类，它接收
    HTTP 请求并返回 HTTP 响应。消息处理器在客户端和服务器端都用于处理/委派不同端点之间的请求。
- en: In our example, we are interested in the client side, as we are calling the
    server; our client handler will be used to handle our HTTP messages sent from
    the HTTP client.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们关注客户端，因为我们正在调用服务器；我们的客户端处理器将用于处理来自 HTTP 客户端的 HTTP 消息。
- en: 'Let''s begin by adding the `ModernHttpClient` library to our **Locator** (we
    will refer to this project as the `Xamarin.Forms` project) and all native projects:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加 `ModernHttpClient` 库到我们的 **Locator**（我们将把这个项目称为 `Xamarin.Forms` 项目）以及所有原生项目开始：
- en: '![ModernHttpClient and client message handlers](img/B05293_03_25.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![ModernHttpClient 和客户端信息处理器](img/B05293_03_25.jpg)'
- en: We also want to add the Microsoft Client Libraries package to all native projects.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望将 Microsoft 客户端库包添加到所有原生项目中。
- en: 'In our shared project, remember we can''t import libraries; these projects
    are only used to share code sheets. In this project, we want to create a folder
    called `Modules`. In the `Modules` folder, create a new file called `SharedModule.cs`
    and implement the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的共享项目中，请记住我们无法导入库；这些项目仅用于共享代码。在这个项目中，我们想要创建一个名为 `Modules` 的文件夹。在 `Modules`
    文件夹中，创建一个名为 `SharedModule.cs` 的新文件，并实现以下内容：
- en: '[PRE68]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: One thing to notice is the minor change we have to make between the iOS and
    Android projects, and the Windows Phone project. Windows must use `NativeMessageHandler`
    for the `HttpClientHandler` in the IoC container. In iOS and Android, we can use
    a default `HttpClientHandler`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的小变化，那就是在 iOS 和 Android 项目以及 Windows Phone 项目之间。Windows 必须在 IoC 容器中的
    `HttpClientHandler` 上使用 `NativeMessageHandler`。在 iOS 和 Android 中，我们可以使用默认的 `HttpClientHandler`。
- en: We tell the client handler that we not going to be using cookies, and we allow
    for automatic decompression on the data being pulled through the client handler
    (**GZIP** is a common form of JSON data compression).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉客户端处理器我们不会使用 cookies，并允许客户端处理器自动解压缩通过客户端处理器拉取的数据（**GZIP** 是一种常见的 JSON 数据压缩形式）。
- en: Now let's focus our attention on the constructor. We simply pass in a `bool`
    to determine whether we are using Windows to register the correct type of message
    handler for the current platform.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力集中在构造函数上。我们只需传入一个 `bool` 来确定我们是否正在使用 Windows 来注册适用于当前平台的正确类型的信息处理器。
- en: 'Now let''s add this module to the registration in the `AppDelegate` and `MainActivity`
    file; it must be called before the `LoadApplication` function:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此模块添加到 `AppDelegate` 和 `MainActivity` 文件中的注册中；它必须在 `LoadApplication`
    函数之前调用：
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Excellent! We now have access to our HTTP client handler in the IoC container,
    so let''s start building the `GeocodingWebServiceController` class:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在可以在 IoC 容器中访问我们的 HTTP 客户端处理器，所以让我们开始构建 `GeocodingWebServiceController`
    类：
- en: '[PRE70]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Feeding JSON data into the IObservable framework
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 JSON 数据喂入 IObservable 框架
- en: 'As we are going to be registering this web service controller in the IoC container,
    we can pull out the client handler we just created and registered in the `SharedModule`
    class. Now we must implement the function we defined in the interface:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在 IoC 容器中注册此 Web 服务控制器，我们可以从 `SharedModule` 类中提取并注册我们刚刚创建的客户端处理器。现在我们必须实现我们在接口中定义的函数：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It may look a bit daunting at first, but let's break it down. Our web service
    controller is going to pull down data, deserialize the data into our main JSON
    object `GeocodingContract`, and create contracts in an observable sequence.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能看起来有些令人畏惧，但让我们将其分解。我们的 Web 服务控制器将下载数据，将数据反序列化到我们的主要 JSON 对象 `GeocodingContract`
    中，并在可观察序列中创建合约。
- en: When we instantiate a new `HttpClient`, we must pass in our registered client
    handler to delegate the request messages being sent from the HTTP client. We then
    create a new `Http.Get` message; this will be sent from the `HttpClient` and delegated
    through the message handler (`HttpClientHandler`), which in turn will receive
    a JSON response.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个新的 `HttpClient` 时，我们必须传递我们注册的客户端处理程序来委派从 HTTP 客户端发送的请求消息。然后我们创建一个新的
    `Http.Get` 消息；这将通过 `HttpClient` 发送并通过消息处理程序（`HttpClientHandler`）委派，然后消息处理程序将接收
    JSON 响应。
- en: This is where it gets tricky. Look at the `Observable.FromAsync` function; this
    method takes an asynchronous function, will run and await the function, and will
    return data as an observable sequence. The asynchronous function must return an
    `IObservable`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事情变得复杂的地方。看看 `Observable.FromAsync` 函数；这个方法接受一个异步函数，将运行并等待该函数，并将数据作为可观察序列返回。异步函数必须返回
    `IObservable`。
- en: The function we are passing is the `SendAsync` function of the `HttpClient`;
    we then use the RX function `SelectMany` to take all the response objects. If
    each response object incurs a HTTP status code `200` (`OK`), we return the response
    content as a string. Notice the `async` keyword in front of the expression; we
    have to use an asynchronous function to await the `ReadAsAsync` function and return
    the response content as a JSON string.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的函数是 `HttpClient` 的 `SendAsync` 函数；然后我们使用 RX 函数 `SelectMany` 来获取所有响应对象。如果每个响应对象都带有
    HTTP 状态码 `200` (`OK`)，我们就将响应内容作为字符串返回。注意表达式前面的 `async` 关键字；我们必须使用异步函数来等待 `ReadAsAsync`
    函数并返回响应内容作为 JSON 字符串。
- en: Finally, we use the RX function `Select` to take each response string and return
    the deserialized `GeocodingContract`. This contract will be fed into the observable
    sequence and returned to the original caller `Observable.FromAsync`, which in
    turn will be the data returned from the function.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 RX 函数 `Select` 来获取每个响应字符串并返回反序列化的 `GeocodingContract`。此合约将被输入到可观察序列中，并返回给原始调用者
    `Observable.FromAsync`，然后它将作为函数返回的数据。
- en: More Reactive Extensions
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多响应式扩展
- en: Before we move on, let's talk more about the RX functions we just used. The
    `Select` function is used for iterating over any `List`, `Enumerable`, or `IObservable`,
    and taking the value of each item to create a new observable sequence.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们更多地讨论我们刚刚使用的 RX 函数。`Select` 函数用于迭代任何 `List`、`Enumerable` 或 `IObservable`，并将每个项的值取出来创建一个新的可观察序列。
- en: 'Say we have a list of objects with a string property `Name`, and we do the
    following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个具有字符串属性 `Name` 的对象列表，我们执行以下操作：
- en: '[PRE72]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We are simply returning the same sequence of items, but then we do something
    like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是返回相同的项序列，但然后我们做类似这样的事情：
- en: '[PRE73]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Our new sequence would be a stream of just the `Name` property for each object.
    These functions are very useful for filtering streams and lists.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新序列将只包含每个对象的 `Name` 属性。这些函数对于过滤流和列表非常有用。
- en: Resource (RESX) files
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源 (RESX) 文件
- en: 'Notice in our `GetGeocodeFromAddressAsync` function we are referencing a static
    class, `ApiConfig`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在我们的 `GetGeocodeFromAddressAsync` 函数中，我们引用了一个静态类，`ApiConfig`：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is a technique for containing your application's resources, such as strings,
    URLs, constant variables, settings properties, and so on. It is also used for
    languages in which we have different constant variable values, based on language
    settings. This is normally how you would make your app multilingual.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含应用程序资源的技术，例如字符串、URL、常量变量、设置属性等。它还用于具有基于语言设置的不同的常量变量值的语言。通常，你会这样让你的应用支持多语言。
- en: 'Let''s create a new folder called `Resources` inside the **Locator.Portable**
    project:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 **Locator.Portable** 项目中创建一个名为 `Resources` 的新文件夹：
- en: '![Resource (RESX) files](img/B05293_03_26.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![资源 (RESX) 文件](img/B05293_03_26.jpg)'
- en: In the `ApiConfig.Designer.cs` file, we must have the namespace set according
    to the folder hierarchy. In this example, it is **Locator.Portable** | **Resources**.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ApiConfig.Designer.cs` 文件中，我们必须根据文件夹层次结构设置命名空间。在这个例子中，它是 **Locator.Portable**
    | **Resources**。
- en: Tip
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Locator.Portable** is the name assigned to our assembly. We must know the
    assembly name to reference where the folders will be stored when the app is built.
    To find out the name of your assembly, visit the properties page, shown in the
    next screenshot.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**Locator.Portable** 是我们程序集的名称。我们必须知道程序集名称，以便在构建应用程序时知道文件夹将存储在哪里。要查找您的程序集名称，请访问属性页面，如图所示。'
- en: '![Resource (RESX) files](img/B05293_03_27.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![资源 (RESX) 文件](img/B05293_03_27.jpg)'
- en: 'Now that we have our `ApiConfig.resx` file, let''s add a variable for the `GoogleMapsUrl`
    property; paste the following in the `ApiConfig.resx` file:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`ApiConfig.resx`文件，让我们为`GoogleMapsUrl`属性添加一个变量；在`ApiConfig.resx`文件中粘贴以下内容：
- en: '[PRE75]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you save this file, you will notice the `ApiConfig.Designer.resx` file
    is automatically generated, meaning the namespace may change to incorrect folder
    paths. Sometimes we have to manually change the folder path every time this file
    regenerates.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存此文件时，你会注意到`ApiConfig.Designer.resx`文件会自动生成，这意味着命名空间可能改变到错误的文件夹路径。有时我们必须手动更改文件夹路径，每次此文件重新生成时。
- en: Using GeocodingWebServiceController
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GeocodingWebServiceController
- en: 'Now that we have set up our web service controller, let''s integrate it with
    our `MapPageViewModel`. Our first step is to register the web service controller
    inside the IoC container; open up `PortableModule.cs` and add the following to
    the `Register` function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的Web服务控制器，让我们将其集成到我们的`MapPageViewModel`中。我们的第一步是在IoC容器中注册Web服务控制器；打开`PortableModule.cs`并在`Register`函数中添加以下内容：
- en: '[PRE76]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now we update the constructor inside `MapPageViewModel` to use `GeocodingWebServiceController`
    from the IoC container:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更新`MapPageViewModel`中的构造函数，以使用IoC容器中的`GeocodingWebServiceController`：
- en: '[PRE77]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Our next step is to add an array of static addresses as a dictionary:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是添加一个静态地址数组作为字典：
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We are going to use the geocoder API to determine latitude and longitude positions
    of all these address locations, and from your current location, determine which
    one is closer.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用地理编码API来确定所有这些地址位置的纬度和经度位置，并从你的当前位置确定哪个更近。
- en: OnNavigatedTo and OnShow
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OnNavigatedTo和OnShow
- en: 'Before we go any further with the Geocoding API, we need to make some additions
    to the navigation setup. Let''s begin by implementing the `OnNavigatedTo` function
    for all content pages. Create a new file called `INavigableXamFormsPage.cs` and
    paste in the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步使用地理编码API之前，我们需要对导航设置做一些补充。让我们首先实现所有内容页的`OnNavigatedTo`函数。创建一个名为`INavigableXamFormsPage.cs`的新文件，并粘贴以下内容：
- en: '[PRE79]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the `internal` keyword; this is because this class will never leave the
    `Xamarin.Forms` project.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`internal`关键字；这是因为这个类永远不会离开`Xamarin.Forms`项目。
- en: 'Now we want every page to inherit this interface and create the `OnNavigatedTo`
    function:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想让每个页面都继承这个接口并创建`OnNavigatedTo`函数：
- en: '[PRE80]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now we want to call the `OnNavigatedTo` function every time a page is navigated
    to. First, let''s update our interface for the `NavigationService`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在每次页面导航到时调用`OnNavigatedTo`函数。首先，让我们更新`NavigationService`的接口：
- en: '[PRE81]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now open up the `NavigationService` class and update the `Navigate` function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`NavigationService`类并更新`Navigate`函数：
- en: '[PRE82]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: After the page is pushed, we then call the `OnNavigatedTo` function.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 页面被推入后，我们随后调用`OnNavigatedTo`函数。
- en: 'Now we want to do a similar thing with page view models. In your `ViewModelBase`
    class, add the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在页面视图模型中也做类似的事情。在你的`ViewModelBase`类中添加以下内容：
- en: '[PRE83]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `OnShow` function will take in the navigation parameters from the coinciding
    page's `OnNavigatedTo` function.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnShow`函数将接收来自对应页面的`OnNavigatedTo`函数的导航参数。'
- en: Notice that the RX approach with handling asynchronous functions when the `LoadAsync`
    has finished?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意处理异步函数的RX方法，当`LoadAsync`完成后？
- en: We have options to handle results and errors from the `LoadAsync` function.
    You may have also noticed the short expressions used with arrows. This type of
    syntax is known as lambda expressions, a very common c-sharp syntax for abbreviating
    functions, arguments, and delegates. Our `LoadAsync` is also virtual, which means
    any page view model that implements this interface can override this function.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有处理`LoadAsync`函数结果和错误的选择。你可能也注意到了使用箭头的简短表达式。这种类型的语法被称为lambda表达式，这是一种非常常见的C#语法，用于简化函数、参数和委托。我们的`LoadAsync`也是虚拟的，这意味着任何实现此接口的页面视图模型都可以重写此函数。
- en: 'Now let''s make some extra additions to the `Xamarin.Forms` project (`Locator`).
    Create a new file in the `UI` folder and call it `XamarinNavigationExtensions.cs`.
    Now for the implementation:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`Xamarin.Forms`项目（`Locator`）做一些额外的补充。在`UI`文件夹中创建一个新文件，命名为`XamarinNavigationExtensions.cs`。现在进行实现：
- en: '[PRE84]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Looking at this more closely, we are actually making extension functions for
    all `ContentPage` types. The `OnShow` function for a `ContentPage` will extract
    the binding context as a `ViewModelBase` and call the `OnShow` function of the
    view model, which in turn will call `LoadAsync`. Finally, we make the changes
    to `MapPage.xaml.cs` and `MainPage.xaml.cs`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们实际上是在为所有`ContentPage`类型创建扩展函数。`ContentPage`的`OnShow`函数将提取绑定上下文作为`ViewModelBase`并调用视图模型的`OnShow`函数，然后视图模型将调用`LoadAsync`。最后，我们对`MapPage.xaml.cs`和`MainPage.xaml.cs`进行更改：
- en: '[PRE85]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Well done! What we just implemented is a Windows Phone principle. We know that
    when the `OnNavigatedTo` function is called, our layout for the `XAML` sheet is
    already sized accordingly. The advantage of having this is we can now retrieve
    x, y, height, and width figures from the page inside this function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好！我们刚刚实现的是一个Windows Phone原则。我们知道当`OnNavigatedTo`函数被调用时，我们的`XAML`布局已经相应地调整了大小。这个优势在于我们可以在该函数内部从页面中检索x、y、高度和宽度数值。
- en: Pythagoras equirectangular projection
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 毕达哥拉斯等角投影
- en: Now back to the Geocoding API. We are going to implement the math behind calculating
    the closest address to a latitude and longitude (current position).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到地理编码API。我们将实现计算纬度和经度（当前位置）最近地址背后的数学。
- en: 'For our first step, we need to add some properties for `MapPageViewModel`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一步，我们需要为`MapPageViewModel`添加一些属性：
- en: '[PRE86]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now for the extra `public` property, which will hold the string address of
    the closest position:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对于额外的`public`属性，它将保存最近位置的字符串地址：
- en: '[PRE87]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now we have to add another `Subject` sequence for when the closet position
    changes:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须为位置变化添加另一个`Subject`序列：
- en: '[PRE88]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This must be initialized in the constructor:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须在构造函数中初始化：
- en: '[PRE89]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now for the fun part.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入有趣的部分了。
- en: How are we going to calculate the closest position?
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们该如何计算最近的位置？
- en: 'Let''s start with the first private function, which will get the positions
    from the address:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个私有函数开始，它将从地址获取位置：
- en: '[PRE90]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this function, we finally get to use our `GeocodingWebServiceController`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们终于可以使用我们的`GeocodingWebServiceController`了。
- en: See how we pass in the variables that will make up the web service URL?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们是如何传递将构成Web服务URL的变量的？
- en: For each address, we must ping this API call to get the latitude and longitudes
    required to calculate the closest position. Then we do a bunch of checks on the
    values in the data contracts to make sure they aren't null, until we get the `GeometryContract`
    values; we will then use these to create a new position and add it to the list.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个地址，我们必须ping这个API调用以获取计算最近位置所需的纬度和经度。然后我们对数据合同中的值进行一系列检查，以确保它们不是null，直到我们得到`GeometryContract`值；然后我们将使用这些值创建一个新的位置并将其添加到列表中。
- en: 'Now let''s make a small change to the `Position` class and interface:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对`Position`类和接口做一些小的修改：
- en: '[PRE91]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Add the `Address` property so we can record the address string for the closest
    property. We need to record this in the position because as we fire off so many
    requests to the API, they will not necessarily finish in order so we can't expect
    to use index referencing to obtain the position index in the list, to be the coinciding
    address in the array.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`Address`属性，以便我们可以记录最近属性的地址字符串。我们需要在位置中记录这个信息，因为我们向API发送了如此多的请求，它们不一定按顺序完成，所以我们不能期望使用索引引用来获取列表中的位置索引，以与数组中的地址相对应。
- en: 'Now let''s add the mathematical functions for calculating distances using the
    `PythagorasEquirectangular` projection. It uses angular projection to calculate
    the distance between two coordinates on a map plane. We also need a `DegreesToRadians`
    conversion for the `PythagorasEquirectangular` function:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加用于计算距离的数学函数，使用`PythagorasEquirectangular`投影。它使用角投影来计算地图平面上两个坐标之间的距离。我们还需要为`PythagorasEquirectangular`函数提供一个`DegreesToRadians`转换：
- en: '[PRE92]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If the distance falls outside the radius value, it will not be used.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离超出了半径值，则不会使用。
- en: Tip
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try playing around with this setting to see the results you get.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整这个设置，看看你得到的结果。
- en: 'Now for the `FindNearestSite` function:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看`FindNearestSite`函数：
- en: '[PRE93]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We will call this when all the geocodes for the address have been obtained and
    added to the positions list. We then go through all the positions and compare
    each to our current position, determine which coordinate difference is the smallest,
    and use this as our closest position. Then we push a new position onto the `ClosestUpdates`
    observable sequence, which we will subscribe to on the `MapPage`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有地址的地理编码都已获取并添加到位置列表中时，我们将调用此功能。然后我们遍历所有位置，将每个位置与我们的当前位置进行比较，确定哪个坐标差值最小，并使用这个作为我们的最近位置。然后我们将一个新的位置推送到`ClosestUpdates`可观察序列，我们将在`MapPage`上订阅它。
- en: 'Our last step on the `MapPageViewModel` is to override the `LoadAsync` function:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MapPageViewModel`的最后一步是重写`LoadAsync`函数：
- en: '[PRE94]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This is where everything will kick off; when the page loads, it will iterate
    through every address and download the geocode, then once we count the entire
    count of the address list, we find the nearest positions and push onto the `ClosestUpdates`
    sequence. We also want to run the `GetGeocodeFromAddress` function in parallel
    for each address; this is why we have `ConfigureAwait` set to false.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一切开始的地方；当页面加载时，它将遍历每个地址并下载地理编码，然后当我们计算完整个地址列表的计数后，我们找到最近的位置并将其推送到`ClosestUpdates`序列。我们还希望为每个地址并行运行`GetGeocodeFromAddress`函数；这就是为什么我们将`ConfigureAwait`设置为false。
- en: 'Now let''s make changes to the `MapPage`. We are going to use two `IDisposables`
    now for the `MapPage`, one for each subject in the view model:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`MapPage`做一些修改。我们现在将为`MapPage`使用两个`IDisposables`，一个用于视图模型中的每个主题：
- en: '[PRE95]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now we update the `OnAppear` and `OnDisappear` functions to handle the subscribing
    to and disposing of the `Subjects`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们更新了`OnAppear`和`OnDisappear`函数来处理对`Subjects`的订阅和释放：
- en: '[PRE96]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And our final touch is to add the function that is called every time for the
    `ClosetUpdates` observable sequence:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的润色是添加一个每次对`ClosetUpdates`可观察序列进行调用的功能：
- en: '[PRE97]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We are creating a pin to place on the map. This pin will also show the address
    information when we click on the pin. We then move to the region on the map to
    show this pin, using the `MoveToRegion` function.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个可以放置在地图上的标记。当我们点击标记时，这个标记也会显示地址信息。然后我们使用`MoveToRegion`函数将地图区域移动到显示这个标记的位置。
- en: That is everything; we have now integrated with Google Maps and Geocoding.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容；我们现在已经集成了Google Maps和Geocoding。
- en: Summary
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed development with `Xamarin.Forms` and `Xamarin.Forms.Maps`.
    We learned how to implement location services on each platform, handling backgrounding
    location update events and using latitudes and longitudes to calculate positions.
    Have a play around with the application on all three platforms, and watch how
    the location updates and nearest positions update the regions on the map. In the
    next chapter, we will jump back into native development, and build an application
    that will control a sound file like an audio player.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用`Xamarin.Forms`和`Xamarin.Forms.Maps`进行开发。我们学习了如何在每个平台上实现位置服务，处理后台位置更新事件以及使用纬度和经度来计算位置。在所有三个平台上尝试运行应用程序，并观察位置更新和最近位置如何更新地图上的区域。在下一章中，我们将回到原生开发，并构建一个可以像音频播放器一样控制音频文件的应用程序。
