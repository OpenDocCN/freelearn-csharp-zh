["```cs\npublic class Message\n{\n  ...\n  public Dictionary<string, string> Headers { get; set; } =\n    new ();\n  public string? Text { get; set; }\n}\n```", "```cs\nprivate void InjectContext(Message message, Activity? act)\n{\n  if (act != null)\n  {\n    _propagator.Inject(new (act.Context, Baggage.Current),\n      message,\n    static (m, k, v) => m.Headers[k] = v);\n  }\n}\n```", "```cs\nStopwatch? duration = PublishDuration.Enabled ?\n  Stopwatch.StartNew() : null;\nusing var act = StartPublishActivity();\nInjectContext(message, Activity.Current);\ntry\n{\n  var receipt = await _queue.SendMessageAsync(\n    BinaryData.FromObjectAsJson(message));\n  act?.SetTag(\"messaging.message.id\",\n    receipt.Value.MessageId);\n  RecordPublishMetrics(duration, \"ok\");\n  ...\n}\ncatch (Exception ex)\n{\n  act?.SetStatus(ActivityStatusCode.Error, ex.Message);\n  RecordPublishMetrics(duration, \"fail\")\n  ...\n}\n```", "```cs\nvar act = Source.StartActivity($\"{_queue.Name} publish\",\n  ActivityKind.Producer);\nif (act?.IsAllDataRequested == true)\n  act.SetTag(\"messaging.system\", \"azqueues\")\n    .SetTag(\"messaging.operation\", \"publish\")\n    .SetTag(\"messaging.destination.name\", _queue.Name)\n    .SetTag(\"net.peer.name\", _queue.AccountName)\n}\n```", "```cs\nprivate static readonly Meter Meter = new(\"Queue.Publish\");\nprivate static readonly Histogram<double> PublishDuration =\n  Meter.CreateHistogram<double>(\n    \"messaging.azqueues.publish.duration\", ...);\n```", "```cs\npublic void RecordPublishMetrics(Stopwatch? dur,\n  string status)\n{\n  ...\n  TagList tags = new() {\n    { \"net.peer.name\", _queue.AccountName },\n    { \"messaging.destination.name\", _queue.Name },\n    { \"messaging.azqueue.status\", status }};\n  PublishDuration.Record(dur.Elapsed. TotalMilliseconds,\n    tags);\n}\n```", "```cs\nusing var act = StartProcessActivity(msg);\n...\ntry\n{\n  await ProcessMessage(msg, token);\n  await _queue.DeleteMessageAsync(msg.MessageId,\n    msg.PopReceipt, token);\n}\ncatch (Exception ex)\n{\n  await _queue.UpdateMessageAsync(msg.MessageId,\n    msg.PopReceipt, visibilityTimeout: BackoffTimeout,\n    cancellationToken: token);\n  ...\n  act?.SetStatus(ActivityStatusCode.Error, ex.Message);\n}\n```", "```cs\nPropagationContext ctx = ExtractContext(msg);\nvar current = new ActivityLink(Activity.Current?.Context ??\n  default);\nvar act = _messageSource.StartActivity(\n  $\"{_queue.Name} process\",\n  ActivityKind.Consumer,\n  ctx.ActivityContext,\n  links: new[] { current });\nif (act?.IsAllDataRequested == true)\n  act.SetTag(\"net.peer.name\",_queue.AccountName)\n     .SetTag(\"messaging.system\", \"azqueues\")\n     .SetTag(\"messaging.operation\", \"process\")\n     .SetTag(\"messaging.source.name\", _queue.Name)\n     .SetTag(\"messaging.message.id\", msg.MessageId);\n  ...\n```", "```cs\nusing var act = _receiverSource\n  .StartActivity(\"ReceiveAndProcess\");\ntry\n{\n  var response = await _queue.ReceiveMessagesAsync(1,\n    ProcessingTimeout, token);\n  QueueMessage[] messages = response.Value;\n  if (messages.Length == 0)\n  {\n    ...; continue;\n  }\n  act?.SetTag(\"messaging.message.id\",\n    messages[0].MessageId);\n  await ProcessAndSettle(messages[0], token);\n  ...\n}\ncatch (Exception ex)\n{\n  act?.SetStatus(ActivityStatusCode.Error, ex.Message);\n  ...\n}\n```", "```cs\nprivate readonly Meter _meter = new (\"Queue.Receive\");\nprivate readonly Histogram<double> _loopDuration;\n...\n_loopDuration = _meter.CreateHistogram<double>(\n  \"messaging.azqueues.process.loop.duration\", \"ms\",\n  \"Receive and processing duration.\");\n```", "```cs\nStopwatch? duration = Stopwatch.StartNew();\ntry\n{\n  var response = await _queue.ReceiveMessagesAsync(1,\n    ProcessingTimeout, token);\n  QueueMessage[] messages = response.Value;\n  RecordLag(messages);\n  if (messages.Length == 0)\n  {\n    ...\n    RecordLoopDuration(duration, \"empty\");\n    continue;\n  }\n  ...\n  await ProcessAndSettle(messages[0], token);\n  RecordLoopDuration(duration, \"ok\");\n}\ncatch (Exception ex)\n{\n  RecordLoopDuration(duration, \"fail\"); ...\n}\n```", "```cs\nTagList tags = new () {\n  { \"net.peer.name\", _queue.AccountName },\n  { \"messaging.source.name\", _queue.Name },\n  { \"messaging.azqueue.status\", status }};\n_loopDuration.Record(duration.ElapsedMilliseconds, tags);\n```", "```cs\n_consumerLag = _meter.CreateHistogram<double>(\n  \"messaging.azqueues.consumer.lag\", \"s\", ...);\n...\nlong receivedAt = DateTimeOffset.UtcNow\n  .ToUnixTimeMilliseconds();\nTagList tags = new () {\n  { \"net.peer.name\", _queue.AccountName },\n  { \"messaging.source.name\", _queue.Name }};\nforeach (var msg in messages\n    .Where(m => m.InsertedOn.HasValue))\n{\n  long insertedOn = msg.InsertedOn!\n    .Value.ToUnixTimeMilliseconds());\n  long lag = Math.Max(1, receivedAt - insertedOn);\n  _consumerLag.Record(lag/1000d, tags);\n}\n```", "```cs\nTagList tags = new () {\n  { \"net.peer.name\", queue.AccountName},\n  { \"messaging.source.name\", queue.Name}};\n_queueSize = _meter.CreateObservableGauge(\n  \"messaging.azqueues.queue.size\",\n  () => new Measurement<long>(_currentQueueSize, tags), ...);\n```", "```cs\nvar res = await _queue.GetPropertiesAsync(token);\n_currentQueueSize = res.Value.ApproximateMessagesCount;\n```", "```cs\n$ docker-compose up --build --scale consumer=3\n```", "```cs\n$ bombardier -c 1 -d 30m http://localhost:5051/send\n```", "```cs\nhistogram_quantile(0.95,\n  sum(rate(messaging_azqueues_consumer_lag_seconds_bucket[1m]))\n  by (le, messaging_source_name, net_peer_name)\n)\n```", "```cs\nmax by (net_peer_name, messaging_source_name)\n(messaging_azqueues_queue_size_messages)\n```", "```cs\nsum(\n rate(messaging_azqueues_process_loop_duration_milliseconds_\n    count[1m]))\nby (messaging_source_name, messaging_azqueue_status)\n```"]