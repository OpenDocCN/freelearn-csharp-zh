- en: '*Chapter 16*: Asynchronous Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the `async`, `await`, and `WhenAll`. You
    will also learn about different return types and extract the required results.
    Plus, you will learn how to correctly cancel asynchronous operations and perform
    asynchronous file reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the TAP model**: In this section, we provide a high-level overview
    of the TAP model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.Run`) and asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetAwaiter.GetResult()`, `.Result`, and `.Wait` for both `Task` and `ValueTask`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canceling asynchronous operations**: In this section, we write code that
    demonstrates asynchronous task cancellation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing files asynchronously**: In this section, we write text to a file
    asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reading files asynchronously**: In this section, we read text from a file
    asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be skilled in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the TAP model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing web resources asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing files asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading files asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll need Visual Studio to work on the code presented in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All code from this chapter is placed on GitHub at [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH16).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the TAP model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, it is worth noting that there are three different models for
    dealing with asynchronous programming. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Asynchronous Programming Model** (**APM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Event-Based Asynchronous Pattern** (**EAP**) model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Task Parallelism Library** (**TPL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APM uses `BeginMethod` to start the asynchronous process and `EndMethod` to
    complete the asynchronous process. EAP uses `MethodAsync` to start an asynchronous
    process, `CancelAsync` to handle the cancellation of an asynchronous operation,
    and a completed event handler to handle the completed asynchronous operation.
    Both these ways of performing asynchronous operations were replaced by TPL in
    C# 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: TPL uses the `async` and `await` pattern. Asynchronous method names are suffixed
    with `async`. An asynchronous method usually returns an awaitable `Task` or `Task<Result>`.
    From .NET 4.5 onwards, you are advised to use TPL instead of using APM and EAP.
  prefs: []
  type: TYPE_NORMAL
- en: TAP's foundation types are the `System.Thread.Tasks` namespace, and the `Task`
    and `Task<Tresult>` classes via asynchronous operations. Microsoft advises that
    you should use TAP when starting new projects.
  prefs: []
  type: TYPE_NORMAL
- en: Naming, parameters, and return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An asynchronous method using the TAP model prefixes the method signature with
    `async Task` for void methods, or `async Task<Tresult>`, `async ValueTask`, or
    `async ValueTask<Tresult>` for methods that return a value. The name of an asynchronous
    method that does not return a value should begin with a verb such as `Begin` or
    `Process`.
  prefs: []
  type: TYPE_NORMAL
- en: TAP method parameters should match and be in the same order as the parameters
    of synchronous counterpart methods. You should avoid entirely using `out` and
    `ref` parameters that are exempt from this rule. If you need to return data, use
    `Tresult` returned by `Task<Tresult>`. Use data structures to accommodate multiple
    return types. It is also worth considering adding cancellation tokens to TAP methods
    as parameters even if synchronous method counterparts don't have such tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Combinator methods that work with multiple tasks where the intent is clear do
    not have to follow this naming pattern. `WhenAll` and `WhenAny` are examples of
    combinator methods.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating asynchronous operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wish to perform some synchronous tasks, such as validation and preparing
    the asynchronous operation for execution, at the start of an asynchronous method.
    If so, you are advised to keep these tasks to the minimum, and the time they take
    should be minimal. The reason is that such methods may be invoked from **User
    Interface** (**UI**) threads, and you don't want to cause your applications to
    hang or freeze momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for keeping synchronous operations to the minimum and for spending
    minimal time within asynchronous operations is that when you run concurrent asynchronous
    methods, long-running synchronous operations can and do decrease the benefits
    of concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can take longer to prepare and launch an asynchronous operation
    than it can take to complete the same operation synchronously. In these situations,
    you can run the method synchronously and return a task.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usage errors, such as passing `null` arguments, are the only errors that should
    be raised in asynchronous methods. You can prevent asynchronous methods from raising
    usage errors by modifying the calling code to ensure that erroneous arguments
    are not passed into the asynchronous methods. All other types of exceptions and
    errors should be assigned to the task being returned. Normally, one exception
    is returned by one task. But when there are multiple operations represented by
    a single task, multiple exceptions may be returned by a single task.
  prefs: []
  type: TYPE_NORMAL
- en: Optional cancellation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cancellation of asynchronous method implementers and consumers is optional.
    An asynchronous method that can be canceled, exposes an overload method that accepts
    a `CancellationToken` that is named `cancellationToken` by convention.
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation requests are monitored by the asynchronous operation. When a cancellation
    request is received, it may be honored. If cancellation results in unfinished
    work, a task in the `Canceled` state is returned with no available result and
    no exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Canceled` state is a completed task state, as are `RanToCompletion` and
    `Faulted`. When a task's state is either `Canceled`, `RanToCompletion`, or `Faulted`,
    the `IsCompleted` property returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuations will continue to be scheduled and executed when a task is canceled
    unless the `NotOnCancelled` continuation option is specified. If this option is
    specified, then continuations will not be scheduled or executed when a task is
    canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code waiting for canceled tasks via language features will continue
    to run but will receive an `OperationCanceledException` or one of its derivatives.
    And code that is blocked synchronously waiting on tasks through methods like `Wait`
    and `WaitAll` will continue to run with an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'TAP methods should return a `Canceled` task when a cancellation token has requested
    cancellation before the TAP method that accepts the token has been called. During
    the execution of an asynchronous operation, cancellation requests can be ignored.
    When returning a task, you will normally return the task with one of three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Canceled`: The operation has ended as a result of a cancellation request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RanToCompletion`: A cancellation was requested but the operation was completed
    and produced a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Faulted`: A cancellation was requested that resulted in the generation of
    an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are coding an asynchronous method and want to enable the operation to
    be canceled first and foremost, then there is no need to produce an overload method
    devoid of a `CancellationToken`. If you are coding an asynchronous method that
    cannot be canceled, then you do not have to provide an overload method that accepts
    a `CancellationToken`. These guidelines help the caller to know whether or not
    the target method can be canceled. When a method that accepts a `CancellationToken`
    is called by a consumer that has no desire to cancel the method call, `None` can
    be passed in for the `CancellationToken` argument, as this is functionally equivalent
    to the default `CancellationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Progress Reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When asynchronous operations are running as part of a UI procedure, it can be
    beneficial to provide progress updates. This helps the end user to know that the
    program is still working.
  prefs: []
  type: TYPE_NORMAL
- en: The `IProgress<T>` interface is used to handle progress and is passed into an
    asynchronous method as a parameter that is conventionally called `progress`. Passing
    this interface into an asynchronous method can help prevent race conditions that
    can occur when event handlers are incorrectly registered once the operation has
    started, which can lead to missed updates. Another reason for passing in an interface
    is that consuming code can support various progress implementations. Only provide
    an `IProgress<T>` interface when progress notifications are supported by the TAP
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: An example that fits well with progress updates is the `FindFilesAsync` method,
    which returns a list of files meeting a particular search pattern. In this scenario,
    you could provide the percentage of work completed along with the current set
    of partial results. The information would be provided by some data type that is
    specific to your API. Such data types are conventionally suffixed with `ProgressInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: TAP methods that provide a progress parameter should allow no progress reporting
    by allowing the progress parameter to be `null`. Progress should be reported to
    the `Progress<T>` object that implements the `IProgress<T>` interface synchronously.
    This enables the asynchronous method to quickly provide progress. Consumers can
    then determine how and where they want to handle the information provided by the
    progress update.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProgressChanged` event is exposed by instances of the `Progress<T>` class.
    This event is raised every time a progress update is reported by the asynchronous
    operation. When a `Progress<T>` object is instantiated, the `ProgressChanged`
    event is raised on the captured `SynchronizationContext` object. A default context
    that targets the thread pool is used when there is no synchronization context
    available.
  prefs: []
  type: TYPE_NORMAL
- en: You can either register handlers for this event as you would any other event,
    and you can also provide the `Progress<T>` constructor with a single handler,
    for convenience. The single handler behaves the same as an event handler for the
    `ProgressChanged` event. During the execution of event handlers, delays to asynchronous
    operations are avoided by raising progress updates asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a high-level understanding of the task-based asynchronous pattern,
    in the next section, we will look at `async`, `await`, and `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: async, await, and Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be looking at the performance differences between running
    methods synchronously, using `Task.Run`, and asynchronously. An asynchronous method
    is identified by the `async` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `await` keyword informs the runtime to wait at the specified line until
    the current task has been completed. It can only be used with a method that is
    prefixed with the `async` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks` namespace. A task encapsulates threading in order
    to maximize the use of multiple cores on computer hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a simple project to benchmark three different ways of calling a
    method. We will call the method synchronously using `Task.Run`, and asynchronously
    using `async/await`. We will be using `BenchmarkDotNet` to see how each method
    call type performs. We aim to show the performance advantage of using asynchronous
    calls over synchronous and `Task.Run` calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We perform the following steps to write our little program:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 console application and call it `CH16_AsynchronousProgramming`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `BenchmarkDotNet` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `Benchmarks`, and in that class add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is our worker method. All it does is increment the `y` variable
    by one for ten iterations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `SynchronousMethod` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method calls the `LengthyTask` method synchronously and is a benchmark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `TaskMethod` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method runs the `LengthyTask` method as a new `Action`, which is queued
    to run on the `ThreadPool`. A `Task` or `Task<Tresult>` handle is returned for
    that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `AsynchronousTaskMethod` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method runs the `LengthyTask` method as an action using `Task.Run` asynchronously,
    and await the completion of the method before it continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our benchmark class is now complete. So, in the `Program.cs` file, replace
    the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will run our benchmarks and produce a report for us.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the project is set to `Release` build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command window and execute the compiled executable file called `CH16_AsynchronousProgramming.exe`
    in the `bin\Release\net6.0` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The benchmarks should start running, and once complete, you should see a report
    like the one shown in *Figure 16.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming
    Project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_16.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – The BenchmarkDotNet report for our CH16_AsynchronusProgramming
    Project
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 16.1*, running the `LengthyTask` method synchronously
    took `7.3220 ns` to complete. Using `Task.Run` took the longest time to run at
    `112.4494 ns`. And the fastest way to run the code was asynchronously, which only
    took `0.9982ns` to complete.
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see from those times that there is a clear performance benefit
    to running our code asynchronously, as it takes less overall time for our code
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will compare the performance of `await` with `GetAwaiter.GetResult()`,
    `.Result`, and `.Wait`. We will cover both `Task` and `ValueTask`.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking GetAwaiter.GetResult(), .Result, and .Wait for both Task and ValueTask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be writing some code to benchmark the `GetAwaiter.GetResult()`,
    `.Result`, and `.Wait` methods to see which method is best for obtaining the return
    value for both a `Task` and a `ValueTask`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At [https://github.com/dotnet/BenchmarkDotNet/issues/236](https://github.com/dotnet/BenchmarkDotNet/issues/236),
    the `BenchmarkDotNet` maintainer called *adamsitnik* wrote in reply to *@i3arnon*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"@i3arnon Thanks for the hint! I have measured* `.Result` *vs* `.Wait` *vs*
    `GetAwaiter.GetResult()` *and it seems that for* `Tasks` *the* `GetAwaiter.GetResult()`
    *is also the fastest way to go. On the other hand, for* `ValueTask` *it was much
    more slower so I stayed with* `.Result` *for VT*."'
  prefs: []
  type: TYPE_NORMAL
- en: And so, from the code that we will be writing, we should see that `.Result`
    should provide us with the best performance when working with a `ValueTask`. And
    `GetAwaiter.GetResult()` should give us the best performance when working with
    a `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now start writing our code. Please complete the following tasks in
    the `CH16_AsynchronousProgramming` project that we started in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CH16_AsynchronousProgramming` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Benchmarks` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method that returns an `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we are incrementing the `y` variable and returning the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetAwaiterGetResult` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method benchmarks the time taken to return an `int` from a method using
    `GetAwaiter().GetResult()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Result` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method benchmarks the time taken to await the return of `int` from a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Wait` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method runs a lengthy task and waits for it to finish before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetAwaiter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets an awaiter used to await the task completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and run the executable via the command line. You should see
    a summary report like the one shown in *Figure 16.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The BenchmarkDotNet summary report for this section''s methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_16.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – The BenchmarkDotNet summary report for this section's methods
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from these results, when returning a value from a `Task`, the
    `GetAwaiterGetResult` method operates much faster than the `Result` method. And
    when executing a long-running `Task`, the `GetAwaiter` method operates much more
    quickly than the `Wait` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how we can speed up our code asynchronously
    when awaiting multiple tasks by using `WhenAll`.
  prefs: []
  type: TYPE_NORMAL
- en: Using async, await, and WhenAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write some example code that demonstrates the use of
    `async`, `await`, and `WhenAll` and the effect on execution time.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple tasks that are being executed in a method and you `await`
    each task, your code will work asynchronously, and the execution time will be
    expensive. You can circumvent this time expense with improved performance by using
    `WhenAll` to `await` all completed tasks before continuing. In the code we will
    be writing, you will see how `WhenAll` reduces the time taken to execute two asynchronous
    methods within a function when compared to awaiting each task in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work our way through the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Benchmarks` class still, add the following asynchronous method, which
    waits `300` milliseconds before returning an `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TaskOne` method is the first of our methods that will be run by our benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the second of our asynchronous methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TaskTwo` method waits for `300` milliseconds and then returns a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will benchmark running asynchronous tasks synchronously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have two tasks and we `await` them both to complete before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add our method that will utilize `WhenAll`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we create our two tasks, then we pass them into the `WhenAll`
    method as parameters. We do not continue until all tasks are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run your executable via the command line. You should see something
    like *Figure 16.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The results of synchronous and asynchronous execution of multiple
    asynchronous calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_16.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – The results of synchronous and asynchronous execution of multiple
    asynchronous calls
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the results of our benchmarking, using `WhenAll` executes
    multiple asynchronous tasks much faster than when you await them in turn. In the
    next section, we will look at canceling asynchronous tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how we can cancel long-running asynchronous
    operations. Sometimes a task will take longer than it should do. A good example
    of this is fetching data from a website when it goes down. Asynchronous operations
    can take a long time before they are reset by the server due to something like
    `Error 404`, `Error 401`, or `Error 500` for example. And so, it pays to have
    the ability to cancel an asynchronous operation after a set period to prevent
    wasting an end user's time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we will write will return the text from a website URL. We will assign
    a very short timeout. This timeout will cancel the task that is responsible for
    returning the website text. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CH16_AsynchronousProgramming` project, and add a new class called
    `TaskCancellation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `using System.Text;` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `_website` variable holds the URL of the website whose page text we will
    be returning. And the `CancellationTokenSource` will be used to signal to a `CancellationToken`
    that it should be cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we declare a method that returns a `HttpClient` for our HTTP request.
    The `MaxResponseContentBufferSize` sets the number of bytes to buffer when reading
    the response content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `ReturnWebsiteTextAsync` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we declare `HttpResponseMessage`, which awaits an asynchronous
    task that returns the contents of a web page. The response is then read and converted
    into a byte array. This byte array is then transformed into an ASCII string and
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the `Start` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Start` method, we write a console message that states the task has started.
    We then set the cancellation time of `cancellationTokenSource` to 30 seconds,
    which is 3000 milliseconds. Then we `await` the call to the `ReturnWebsiteTextAsync`.
    If the process times out after the set timeout period, an `OperationCanceledException`
    is raised, which outputs a message to the console. Finally, `cancellationTokenSource`
    is disposed of and a console message is an output stating that the task is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the benchmark running code in the `Program.cs` file, and add the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project and try it several times with different timeout periods to test
    the code completing successfully and returning text, and to test the operation
    timing out and raising an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running this code through a couple of times with timeouts of `3000` and `30000`
    will present an operation timeout exception and display the web page text, respectively.
    As you can see if you run the code yourself, it is very easy to write asynchronous
    tasks that are canceled after a set period.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be writing code that shows how to write files asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write text to a file asynchronously. Scenarios where
    asynchronous file writing can be useful include writing large volumes of text
    and data to files that will not be read immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to write our code:'
  prefs: []
  type: TYPE_NORMAL
- en: On your `C:\` drive, add a folder called `Temp` if one does not already exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `CH16_AsynchronousProgramming` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class called `FileReadWriteAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `WriteTextAsync` method, we declare a file path for a text file and a
    variable that contains the text to be written to the file. The text to be written
    gets converted into a byte array. A writable asynchronous file stream is then
    opened in append mode. Then we write the text to the file stream and close it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we continue in this class as we add our asynchronous read
    method that shows how to read a file asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Reading files asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will read text from a file asynchronously. We will be building
    upon the code from the previous section that writes the text to a file asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will add our asynchronous read method and update the `Program.cs`
    file to run our asynchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FileReadWriteAsync` class, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define the path of the file that we need to read. Then we open a file
    stream in read mode with read access. Next, we define `StringBuilder` and byte
    array that will act as our buffer to store read data. We then read the stream
    until the read has been completed. During each iteration of the read, we read
    the text from the file, encode it into Unicode, and then append it to `StringBuilder`.
    Then, once the loop has finished and exits, we return the string from the method.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Program.cs` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We won't be needing these lines when we run our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we call our methods that write text to a file asynchronously,
    read the text asynchronously into a variable, and then print the contents of the
    variable to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and you should see something like *Figure 16.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.4 – The result of our asynchronous write and read code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_16.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.4 – The result of our asynchronous write and read code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the screenshot, we have successfully written text asynchronously
    to a file, asynchronously read it from that file, and printed the contents to
    the console window.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began with a high-level overview of the task-based asynchronous
    pattern. Things we covered were naming, parameters, return types, initializing
    asynchronous operations, exceptions, and optionally providing ways to report progress
    updates and cancel operations. We saw that we can have asynchronous operations
    that allow cancellation, and those that don't allow cancellation. Plus, we learned
    that when a cancellation has been requested, the cancellation will either go ahead
    or be ignored. Completed tasks can have a completed state of `Canceled`, `RanToCompletion`,
    or `Faulted`.
  prefs: []
  type: TYPE_NORMAL
- en: We then benchmarked three different ways of calling a method synchronously,
    using `Task.Run`, and asynchronously. Using `Task.Run` took the longest time,
    followed by running the method synchronously, and running the method asynchronously
    was by far the quickest way to run the method.
  prefs: []
  type: TYPE_NORMAL
- en: Then we benchmarked `GetAwaiter.GetResult()`, `Result`, and `Wait` for both
    `Task` and `TaskValue`. We saw that when returning a value from a `Task`, the
    `GetAwaiterGetResult` method operates much faster than the `Result` method. And
    when executing a long-running `Task`, the `GetAwaiter` method operates much more
    quickly than the `Wait` method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at cancelling asynchronous operations. We coded an example that
    obtains the text from a website and outputs the text to the console. If the operation
    fails to complete within a set period of time, then it is cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: In the final two sections, we wrote some code to demonstrate the writing and
    reading of text and data asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: To complete this chapter, there are some questions for you to answer to see
    how well you have retained what you have read and some further reading on asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for purchasing this book. I hope you have enjoyed reading it, and
    that you have learned plenty of ways to improve your own code. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does TAP stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parameter type identifies that an asynchronous operation can be canceled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What parameter type is passed into an asynchronous task to provide progress
    updates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain `async`, `await`, and `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you cancel an asynchronous operation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you report on an asynchronous operation's progress?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asynchronous programming; APM vs EAP: [https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap](https://stackoverflow.com/questions/11276314/asynchronous-programming-apm-vs-eap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Asynchronous programming: [https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Introduction to async programming in C#: [https://auth0.com/blog/introduction-to-async-programming-in-csharp/](https://auth0.com/blog/introduction-to-async-programming-in-csharp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The performance characteristics of async methods in C#: [https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/](https://devblogs.microsoft.com/premier-developer/the-performance-characteristics-of-async-methods/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exception Handling (Task Parallel Library): [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/exception-handling-task-parallel-library)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
