- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Optimizing Data Access with Entity Framework Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Entity Framework Core 优化数据访问
- en: Before Entity Framework was introduced in 2008, developers used **ActiveX Data
    Objects** (**ADOs**) and **Object Linking and Embedding Database** (**OLE DB**)
    to access their data for applications. Since its introduction, Entity Framework
    has evolved over the years into a high-performance bridge between **object-oriented**
    (**OO**) systems and relational databases. It enables developers to use **Language
    Integrated Query** (**LINQ**) syntax to perform complex queries using C#. However,
    some LINQ statements can be overwhelming for new developers. Since this is one
    of the most discussed topics when it comes to data access, we’ll cover various
    standards and implementations when using Entity Framework Core.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2008 年 Entity Framework 介绍之前，开发者使用 **ActiveX 数据对象**（**ADOs**）和 **对象链接和嵌入数据库**（**OLE
    DB**）来访问其应用程序的数据。自其引入以来，Entity Framework 在这些年来已经发展成为一个高性能的桥梁，连接 **面向对象**（**OO**）系统和关系数据库。它使开发者能够使用
    **语言集成查询**（**LINQ**）语法，通过 C# 执行复杂的查询。然而，一些 LINQ 语句可能会让新开发者感到不知所措。由于这是数据访问中最常讨论的话题之一，我们将涵盖使用
    Entity Framework Core 时各种标准和实现。
- en: This chapter will be similar to [*Chapter 2*](B19493_02.xhtml#_idTextAnchor031),
    *CI/CD – Building Quality Software with Software*, where we will review patterns
    for implementing Entity Framework Core to access data but also look at some common
    uses of Entity Framework Core in the industry.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将与 [*第 2 章*](B19493_02.xhtml#_idTextAnchor031)，*CI/CD – 使用软件构建高质量软件* 相似，我们将回顾实现
    Entity Framework Core 访问数据的模式，同时还将查看一些行业中对 Entity Framework Core 的常见使用。
- en: 'In this chapter, we’ll cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Entity Framework Core Implementations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core 实现
- en: Common Entity Framework Core Practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的 Entity Framework Core 实践
- en: Implementing the Theme Park Example
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现主题公园示例
- en: When you’ve finished reading this chapter, you’ll have a better understanding
    of the various design patterns and approaches you can use with Entity Framework
    Core and the various standards involved; we will end the chapter by applying these
    standards to a theme park example.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读完本章后，您将更好地理解您可以使用 Entity Framework Core 的各种设计模式和采用的方法，以及涉及的各种标准；我们将通过将这些标准应用于主题公园示例来结束本章。
- en: Let’s get started by examining the various Entity Framework Core common implementations
    used by many developers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，通过检查许多开发者使用的各种 Entity Framework Core 常见实现来入门。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'I recommend using your favorite editor to view the GitHub repository. Our recommendations
    include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用您最喜欢的编辑器来查看 GitHub 仓库。我们的建议包括以下内容：
- en: Visual Studio (preferably 2022 or newer)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio（最好是 2022 或更新版本）
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: JetBrains Rider
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: The editor we’ll be using is Visual Studio Enterprise 2022, but any version
    (Community or Professional) will work with the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的编辑器是 Visual Studio Enterprise 2022，但任何版本（社区版或专业版）都可以与代码一起使用。
- en: We will also be using **SQL Server Management Studio** (**SSMS**) for our example
    at the end of the chapter. However, if you feel you don’t need to download another
    tool, you can view SQL Server data through Visual Studio 2022 as well without
    installing SSMS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 **SQL Server Management Studio**（**SSMS**）在本章末尾的示例中。但是，如果您觉得您不需要下载另一个工具，您也可以通过
    Visual Studio 2022 查看 SQL Server 数据，而无需安装 SSMS。
- en: Downloading SQL Server Developer Edition
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 SQL Server 开发者版
- en: To run a local copy of SQL Server, download the Developer edition of SQL Server
    from [https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本地副本的 SQL Server，请从 [https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads)
    下载 SQL Server 开发者版。
- en: 'The code for this chapter is located in Packt Publishing’s GitHub repository,
    which you can navigate to here: [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码位于 Packt Publishing 的 GitHub 仓库中，您可以在此导航：[https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices)。
- en: Entity Framework Core Implementations
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework Core 实现
- en: Over the years, developers have used Entity Framework Core in various ways.
    Some were exceptionally **creative**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，开发者以各种方式使用了 Entity Framework Core。其中一些非常 **有创意**。
- en: 'In this section, we’ll discuss the following architectural approaches:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下架构方法：
- en: Repository/Unit of Work
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库/工作单元
- en: Specification
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规格
- en: Extension Methods
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: While these implementations are based on real-world experiences, they are merely
    observations, and, as mentioned in [*Chapter 1*](B19493_01.xhtml#_idTextAnchor014),
    the decision will fall on teams and/or community members as to the right approach
    for the application and trade-offs incurred.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些实现基于现实世界的经验，但它们仅仅是观察，如[*第1章*](B19493_01.xhtml#_idTextAnchor014)中提到的，决定将取决于团队和/或社区成员，以及应用程序的正确方法和所承受的权衡。
- en: Repository/Unit of Work
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库/工作单元
- en: While this implementation has already caused some friction among developers,
    it’s a common pattern seen with early adopters of ASP.NET Entity Framework applications
    (including me). However, it’s been said by community members it’s not an efficient
    way to use Entity Framework architecturally because of the duplication of repositories.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种实现已经引起了一些开发者的摩擦，但它对于早期采用 ASP.NET Entity Framework 应用程序的开发者（包括我）来说是一个常见的模式。然而，社区成员表示，由于仓库的重复，这并不是在架构上高效使用
    Entity Framework 的方法。
- en: Implementation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: Out of the box, the `DbContext` follows a **repository** and **unit of work**
    design pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`DbContext` 遵循 **仓库** 和 **工作单元** 设计模式。
- en: The repository design pattern is a class that manages objects between the business
    domain and the mapping of properties from the database using lists and single
    domain objects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库设计模式是一个类，它管理业务域和数据库属性映射之间的对象，使用列表和单个域对象。
- en: Repositories are self-contained in the `DbContext`, which is considered a Unit
    of Work design pattern. A unit of work pattern manages a list of objects (as repositories
    do) using a `ChangeTracker` to track changes in a transaction-like state and organizes
    how each change should be saved and how to resolve concurrency problems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库在 `DbContext` 中是自包含的，这被认为是工作单元设计模式。工作单元模式管理一系列对象（如仓库所做的那样），使用 `ChangeTracker`
    来跟踪事务状态中的更改，并组织每个更改应该如何保存以及如何解决并发问题。
- en: In Entity Framework, repositories are represented as `DbSet` instances in the
    `DbContext` where the `DbContext` is the unit of work itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Entity Framework 中，仓库以 `DbSet` 实例的形式表示在 `DbContext` 中，其中 `DbContext` 本身就是工作单元。
- en: 'Let’s look at an example. We have a database called `ThemePark` and it contains
    two tables: attractions and locations. We’ve also created a `ThemeParkDbContext`
    class to manage our entities. If you’ve worked with Entity Framework at any time,
    you’ve likely encountered the repository design pattern implemented in a similar
    fashion:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们有一个名为 `ThemePark` 的数据库，它包含两个表：景点和位置。我们还创建了一个 `ThemeParkDbContext`
    类来管理我们的实体。如果你在任何时候使用过 Entity Framework，你很可能遇到过以类似方式实现的仓库设计模式：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is wrong with this implementation? While this does separate the business
    rules from the data access, it’s an unnecessary layer for applications when a
    repository layer already exists in the `DbContext`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现有什么问题？虽然这确实将业务规则与数据访问分离，但当 `DbContext` 中已经存在仓库层时，对于应用程序来说，这是一个不必要的层。
- en: One of the jokes I love from the developer community is, “*What are the two
    hardest problems in computer science? Cache invalidation, naming things, and*
    *off-by-one errors.*”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我从开发者社区中喜欢的一个笑话是，“*计算机科学中最难的两个问题是什么？缓存失效、命名事物和* *off-by-one 错误*。”
- en: Consider this a case of naming things wrong. What if we changed the name to
    `Service`, like so?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将这视为一个命名错误的情况。如果我们将其名称更改为 `Service`，会怎样呢？
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Why `Service`? The repository pattern is already contained in the `DbContext`
    as a `DbSet<Attraction>`. The service uses the repository pattern to retrieve
    the data and perform additional updates before returning the data. Changing the
    class name from `Repository` to `Service` signifies we don’t need a repository
    pattern on top of an already existing repository. When creating a service for
    individual repositories (`DbSet` instances), this provides multiple benefits,
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是 `Service`？仓库模式已经包含在 `DbContext` 中的 `DbSet<Attraction>` 中。服务使用仓库模式来检索数据并在返回数据之前执行额外的更新。将类名从
    `Repository` 更改为 `Service` 表示我们不需要在现有的仓库之上再使用仓库模式。当为单个仓库（`DbSet` 实例）创建服务时，这提供了以下多个好处：
- en: '`DbContext`. Add `.Include()` on the `DbContext` to retrieve related entities.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DbContext`。在 `DbContext` 上添加 `.Include()` 以检索相关实体。'
- en: '`DbContext` instance through the constructor, allowing for multiple approaches
    to accessing data including LINQ statements, stored procedures, or even call raw
    SQL.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造函数传递 `DbContext` 实例，允许采用多种方法访问数据，包括 LINQ 语句、存储过程，甚至调用原始 SQL。
- en: '**Additional processing**—When calling a data access service, there are times
    when the data requires more massaging before returning the results. While this
    is temporarily acceptable in this service, it may require refactoring to the appropriate
    business entity or processing through another class.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**附加处理**——在调用数据访问服务时，有时数据在返回结果之前需要更多的处理。虽然在这个服务中这是暂时可接受的，但它可能需要重构到适当的企业实体或通过另一个类进行处理。'
- en: The benefits seen through this approach could easily pivot the already existing
    repository naming convention to a service moniker.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法看到的益处可以轻松地将现有的存储库命名约定转换为服务名称。
- en: The Specification Pattern
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范模式
- en: Developers are always looking to reuse existing code and make it as flexible
    as possible for maintenance purposes; update a line of code and it could change
    the retrieval of data required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者总是寻求重用现有代码，并使其尽可能灵活以方便维护；更新一行代码可能会改变所需的数据检索。
- en: The specification pattern is solving the problem of attaching requirements to
    an object with the rise of **Test-Driven Development** (**TDD**) making it easier
    to understand the results retrieved through a query. It uses a base class to retrieve
    data as either a list or a single entity while writing the least amount of code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试驱动开发（**TDD**）的兴起，规范模式正在解决将需求附加到对象上的问题，这使得通过查询检索的结果更容易理解。它使用基类以列表或单个实体形式检索数据，同时编写最少的代码。
- en: Implementation
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: 'When creating a specification class, you need two classes: one for processing
    the request and the specification for what you need. The specification class is
    built exactly as the class implies: it defines the filter for a single entity
    or list of entities, sorting and grouping, and inclusion of various related entities.
    Everything you can do with a LINQ query can be defined in the specification class.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建规范类时，你需要两个类：一个用于处理请求，另一个用于规范所需的内容。规范类构建得正好像其名称所暗示的那样：它定义了单个实体或实体列表的过滤器、排序和分组，以及包含各种相关实体。你可以使用LINQ查询做的任何事情都可以在规范类中定义。
- en: 'A sample specification’s contract (interface) could have the following structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例规范（接口）的结构可能如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The implementation of a `Specification` class would look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Specification`类的实现可能如下所示：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As mentioned at the start of this section, the properties in the class represent
    all of the different aspects of retrieving data: filtering, including, sorting,
    and grouping.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，类中的属性代表检索数据的各个方面：过滤、包含、排序和分组。
- en: 'Once you have the specification defined, we need a way to build our query based
    on a specification. In this case, we’ll create a `SpecificationBuilder<T>` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了规范，我们需要一种基于规范构建查询的方法。在这种情况下，我们将创建一个`SpecificationBuilder<T>`类：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet, our `SpecificationBuilder` class creates a LINQ
    query to retrieve the data. Since everything is self-contained and completely
    independent of itself, the class was marked as static.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们的`SpecificationBuilder`类创建了一个LINQ查询来检索数据。由于一切都是自包含的，并且完全独立于自身，因此该类被标记为静态。
- en: 'With every specification class, we need a way to retrieve the data. We’ll make
    the class abstract and call it `BaseSpecificationService<TEntity>`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个规范类，我们需要一种检索数据的方法。我们将使该类抽象并命名为`BaseSpecificationService<TEntity>`：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, `BaseSpecificationService` is what we’ll use to create
    our specific data needs. We require a specification property and a way to retrieve
    the query based on that specification.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`BaseSpecificationService`是我们将用来创建特定数据需求的。我们需要一个规范属性以及根据该规范检索查询的方法。
- en: With the specification pattern, the names of your classes are the specifications
    of the data required.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用规范模式，你的类名就是所需数据的规范。
- en: 'Let’s look at another example with a simple `Product` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个使用简单的`Product`类的示例：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you need a list of all products below `$5.00`, a specification class would
    look like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个所有产品价格低于$5.00的列表，一个规范类可能看起来像以下这样：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code creates the specification and uses it to retrieve the results:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建规范并使用它来检索结果：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code would generate a list of products of less than 5 dollars.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成一个低于5美元的产品列表。
- en: While this is a simple example, there are more extensive libraries dedicated
    to this type of Entity Framework design pattern, such as Steve Smith’s specification
    library located at [https://specification.ardalis.com](https://specification.ardalis.com).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但还有更多致力于此类 Entity Framework 设计模式的广泛库，例如位于 [https://specification.ardalis.com](https://specification.ardalis.com)
    的 Steve Smith 的规范库。
- en: Extension Methods
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法
- en: If we revisit the repository/unit of work method, the association between specific
    business logic and the data should be relatively close to `DbContext`. Instead
    of creating service classes while passing `DbContext` in, why not just attach
    your data access to the actual `DbSet` instance itself as an `IQueryable` extension
    method?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾仓库/单位工作方法，特定业务逻辑与数据之间的关联应该相对接近 `DbContext`。为什么不直接将数据访问附加到实际的 `DbSet` 实例本身作为
    `IQueryable` 扩展方法，而不是创建传递 `DbContext` 的服务类呢？
- en: The ability to add specific calls to a `DbContext` or `DbSet` instance is extremely
    attractive because they can be placed anywhere in your project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 能够向 `DbContext` 或 `DbSet` 实例添加特定调用非常吸引人，因为它们可以放置在你的项目的任何位置。
- en: The extension method approach does require a bit of discipline where specific
    entities are concerned. For example, if you created a product entity, your `IQueryable`
    extension methods should return only products and not order entities. Mixing order
    extension methods with product extension methods is usually frowned upon.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法方法在特定实体方面确实需要一定的纪律性。例如，如果你创建了一个产品实体，你的 `IQueryable` 扩展方法应该只返回产品，而不是订单实体。将订单扩展方法与产品扩展方法混合通常是不受欢迎的。
- en: Implementation
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: Extension methods allow your code to be more direct when accessing data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法允许你的代码在访问数据时更加直接。
- en: 'Since we can attach extension methods to interfaces, let’s define a simple
    interface for our `ThemeParkDbContext` class, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以将扩展方法附加到接口，让我们为我们的 `ThemeParkDbContext` 类定义一个简单的接口，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With our theme park idea, we built `AttractionExtensions` and `LocationExtensions`
    files for data access, like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主题公园想法中，我们为数据访问创建了 `AttractionExtensions` 和 `LocationExtensions` 文件，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our `AttractionExtensions` file has only two methods, `GetAttractions()` and
    `GetAttraction()`, which we attach to the `ThemeParkDbContext` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `AttractionExtensions` 文件中只有两个方法，`GetAttractions()` 和 `GetAttraction()`，我们将它们附加到
    `ThemeParkDbContext` 类。
- en: 'Our `LocationExtensions` file is small and compact as well, as we can see here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `LocationExtensions` 文件同样小巧紧凑，如下所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this section, we reviewed some of the more common Entity Framework Core design
    patterns used in real-world applications such as the repository and unit of work
    patterns, the specification pattern, and the extension methods approach to accessing
    data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了一些在现实世界应用程序中使用的更常见的 Entity Framework Core 设计模式，例如仓库和单位工作模式、规范模式和访问数据的扩展方法方法。
- en: 'While these are common in the .NET community, there are other patterns available
    for Entity Framework Core allowing even easier access to your data, but they do
    have drawbacks. Let’s look at these more closely:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些在 .NET 社区中很常见，但还有其他模式可用于 Entity Framework Core，允许更容易地访问你的数据，但它们确实有缺点。让我们更仔细地看看这些：
- en: '`DbContext` instance would exist for each partitioned feature in the application;
    for example, one `DbContext` instance for the `Books` and `BookAuthors` tables
    and another `DbContext` instance for the `Orders` and `Books` tables. One drawback
    is possible state conflicts across multiple `DbContext` instances (*NOT* recommended).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的每个分区功能都会存在一个 `DbContext` 实例；例如，一个 `DbContext` 实例用于 `Books` 和 `BookAuthors`
    表，另一个 `DbContext` 实例用于 `Orders` 和 `Books` 表。一个可能的缺点是多个 `DbContext` 实例之间可能存在状态冲突（**不推荐**）。
- en: '`DbContext` instance as a conduit while making direct calls to stored procedures
    without using LINQ. One drawback occurs when changes are made to a stored procedure
    and the mapping code doesn’t reflect the results returned, causing an error.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不使用 LINQ 的情况下直接调用存储过程时，将 `DbContext` 实例作为通道。一个缺点是，当对存储过程进行更改且映射代码没有反映返回的结果时，会导致错误。
- en: In the next section, we’ll be covering some common practices when using Entity
    Framework Core in real-world applications.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍在现实世界应用程序中使用 Entity Framework Core 的常见实践。
- en: Common Entity Framework Core Practices
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 Entity Framework Core 实践
- en: Even though Entity Framework patterns provide additional structure to your code,
    there are also common practices to keep in mind when building applications with
    Entity Framework.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Entity Framework模式为您的代码提供了额外的结构，但在使用Entity Framework构建应用程序时，还有一些常见的实践需要牢记。
- en: 'In this section, we’ll review some of the more common uses of Entity Framework
    and their benefits: how `async`/`await` can make your application more scalable,
    logging your queries to optimize SQL output, creating resource files to hold seed
    data for tables, learning about deferred execution, speeding up access with a
    read-only method called `.AsNoTracking()`, leveraging the database where it makes
    sense, and using AutoMapper to map source objects to destination objects.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾Entity Framework的一些更常见的用法及其好处：`async`/`await`如何使您的应用程序更具可扩展性，记录查询以优化SQL输出，创建资源文件以保存表的种子数据，了解延迟执行，使用名为
    `.AsNoTracking()` 的只读方法来加快访问速度，在合理的地方利用数据库，以及使用 AutoMapper 将源对象映射到目标对象。
- en: Confirming Your Model
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认您的模型
- en: If you’re using the database-first approach (where you have an existing database
    to work with) to generate your models, confirm that all of your indexes, relationships,
    identity fields, and foreign keys represent your model accordingly before using
    `Scaffold-DbContext`. The `Scaffold-Database` command creates your `DbContext`
    instance based on an existing database. The command takes everything into account
    when creating the `DbContext` instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用数据库优先的方法（即您有一个现有的数据库来工作）来生成模型，在使用 `Scaffold-DbContext` 之前，请确认您所有的索引、关系、标识字段和外键都相应地表示了您的模型。`Scaffold-Database`
    命令基于现有数据库创建您的 `DbContext` 实例。在创建 `DbContext` 实例时，该命令会考虑所有因素。
- en: If your relationships aren’t correct, this will cause problems with navigation
    properties on your model when accessing them through your `DbContext` instance.
    Essentially, your navigation properties will be empty.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的关系不正确，这将导致在通过您的 `DbContext` 实例访问它们时，您的模型上的导航属性出现问题。本质上，您的导航属性将是空的。
- en: Using Async/Await
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Async/Await
- en: For I/O-bound activities, such as database operations, it makes sense to use
    `async`/`await` for creating scalable applications. While it may not be apparent
    when running the web application on a developer machine, the true benefits of
    using `async`/`await` appear when you have hundreds of people hitting the website
    at once.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于I/O密集型活动，例如数据库操作，使用 `async`/`await` 来创建可扩展的应用程序是有意义的。虽然当在开发机器上运行Web应用程序时可能不明显，但使用
    `async`/`await` 的真正好处在于当有成百上千的人同时访问网站时。
- en: The reason to use `async`/`await` is to avoid blocking thread requests. When
    a request comes into a web server, the .NET Framework maintains a pool of threads
    to process those incoming requests. For each request, a thread is taken from the
    pool and used to process the request synchronously. While the thread is being
    used, nothing can use it until the process is completed (“blocking thread”). Once
    the process completes, the thread is released and returned to the thread pool
    for the next request.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async`/`await` 的原因是为了避免阻塞线程请求。当一个请求进入网络服务器时，.NET Framework维护一个线程池来处理这些传入的请求。对于每个请求，都会从池中取出一个线程来同步处理该请求。在线程被使用期间，直到处理完成之前，没有任何东西可以使用它（“阻塞线程”）。一旦处理完成，线程就会被释放并返回到线程池以处理下一个请求。
- en: When you use `async`/`await`, you aren’t taking a thread from the thread pool.
    Anything in between `async` and `await` doesn’t use a thread, which means you’re
    saving memory in the long run and allowing your application to perform better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `async`/`await` 时，您并没有从线程池中取出一个线程。在 `async` 和 `await` 之间的任何内容都不使用线程，这意味着您在长期运行中节省了内存，并允许您的应用程序表现更好。
- en: When it comes to making Entity Framework Core calls, it’s best to use `async`/`await`
    for performance reasons.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到调用Entity Framework Core时，出于性能原因，最好使用 `async`/`await`。
- en: Logging Your Queries
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录您的查询
- en: Most `OptionsBuilder` class specifically for logging to help solve this issue.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 `OptionsBuilder` 类专门用于日志记录，以帮助解决这个问题。
- en: 'For simple logging using Entity Framework, place a `.LogTo()` method into your
    `DbContext` instance’s `onConfiguring()` method, as shown in the following code
    snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Entity Framework的简单日志记录，将 `.LogTo()` 方法放入您的 `DbContext` 实例的 `onConfiguring()`
    方法中，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `.LogTo()` method takes either an action or a func on where to send the
    log data. In this snippet, we are simply logging to the debug window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`.LogTo()` 方法接受一个动作或一个函数，用于指定发送日志数据的位置。在这个片段中，我们只是将日志记录到调试窗口中。'
- en: Simple logging to the debug window is the easiest to implement because it’s
    a simple `Console.Write()` method and doesn’t require any third-party packages,
    but there are other types of logging available that are just as easy to plug into
    Entity Framework Core.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将简单的日志记录到调试窗口是最容易实现的，因为它是一个简单的`Console.Write()`方法，不需要任何第三方包，但还有其他类型的日志记录可供选择，它们同样容易集成到Entity
    Framework Core中。
- en: Additional logging options
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其他日志记录选项
- en: 'For additional logging methods in Entity Framework Core, navigate to the following
    URL: [https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/](https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Entity Framework Core中的其他日志记录方法，请访问以下URL：[https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/](https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/)
- en: Using Resources for Large Seed Data
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源文件处理大量种子数据
- en: If you need initial seed data with fewer than 20 records for your tables, it’s
    easy to just hand-code the records on the fly in your `DbContext` instance using
    `.HasData()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要少于20条记录的初始种子数据，只需在您的`DbContext`实例中即时使用`.HasData()`手动编码记录即可。
- en: But what if you have a table requiring hundreds of records seeded on the initial
    load? Hand-typing records can be painful using code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您有一个在初始加载时需要数百条记录的表怎么办？使用代码手动输入记录可能会很痛苦。
- en: One hidden gem in .NET is the use of resource files for storing simple strings
    (normally used for localization/translation), but it can also be used for populating
    seed data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的一个隐藏宝藏是使用资源文件来存储简单的字符串（通常用于本地化/翻译），但它也可以用于填充种子数据。
- en: 'Let’s use our `Attraction`/`Location` table example and show the steps for
    creating seed data in a resource file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的`Attraction`/`Location`表示例，并展示在资源文件中创建种子数据的步骤：
- en: Open SQL Server Management Studio.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开SQL Server Management Studio。
- en: Confirm the seeded records are created the way you want them in each table (`Attraction`
    and `Location`).
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认每个表（`Attraction`和`Location`）中创建的种子记录符合您的期望。
- en: 'Perform a `SELECT` operation with the JSON clause added to the end, as shown
    in the following SQL snippet:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个带有JSON子句的`SELECT`操作，如下面的SQL片段所示：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Click on the result, and a new result pane will open with your JSON. The JSON
    will look like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击结果，将打开一个新的结果面板，其中包含您的JSON。JSON将看起来像这样：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Copy the JSON returned.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制返回的JSON。
- en: 'Open Visual Studio and add a resource file through Visual Studio. The following
    screenshot illustrates the process:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，并通过Visual Studio添加资源文件。以下屏幕截图说明了该过程：
- en: '![Figure 5.1 – Creating a resource file called SeedResource.resx in Visual
    Studio](img/Figure_5.01_B19493.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 在Visual Studio中创建名为SeedResource.resx的资源文件](img/Figure_5.01_B19493.jpg)'
- en: Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 在Visual Studio中创建名为SeedResource.resx的资源文件
- en: 'Your resource file will automatically open. For our example, we’ll create the
    resource with the following parameters:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的资源文件将自动打开。在我们的示例中，我们将使用以下参数创建资源：
- en: '`AttractionRecords`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AttractionRecords`'
- en: '**Value**: <Paste your JSON here>'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**值**：在此粘贴您的JSON'
- en: '**Comment**: (These are optional, but added to identify for other devs)'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注释**：（这些是可选的，但添加以供其他开发者识别）'
- en: '**Access Modifier**: Change this to **Internal**'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**访问修饰符**：将其更改为**内部**'
- en: 'Your resource record should look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您的资源记录应如下所示：
- en: '![Figure 5.2 – A sample record in the Resources.resx file containing JSON for
    the Attraction table](img/Figure_5.02_B19493.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – Resources.resx文件中的一个示例记录，包含用于吸引表的JSON](img/Figure_5.02_B19493.jpg)'
- en: Figure 5.2 – A sample record in the Resources.resx file containing JSON for
    the Attraction table
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – Resources.resx文件中的一个示例记录，包含用于吸引表的JSON
- en: Save your resource file.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的资源文件。
- en: 'Open your `AttractionConfiguration` class and locate your `.HasData()` attraction
    in your `DbContext` instance and replace it with the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`AttractionConfiguration`类，并在您的`DbContext`实例中找到您的`.HasData()`吸引操作，并将其替换为以下代码：
- en: '[PRE15]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save and compile your code.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译您的代码。
- en: If you require a large amount of seed data, it’s better to create resource files
    with JSON data instead of hand-coding all of the records into code. Finding long
    pages of large JSON strings in a `DbContext` configuration may seem jarring to
    some developers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要大量的种子数据，最好创建包含JSON数据的资源文件，而不是手动将所有记录编码到代码中。在`DbContext`配置中找到大段大段的JSON字符串可能会让一些开发者感到震惊。
- en: Understanding Deferred Execution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解延迟执行
- en: Deferred execution when making Entity Framework calls means the LINQ query is
    delayed until the realized value is required.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用Entity Framework时进行延迟执行意味着LINQ查询将延迟到需要实际值时才执行。
- en: 'Here’s an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While this will return the correct list of items, it’s not as performant as
    it could be. With the `.ToList()` method added after the Products `DbSet` instance,
    the entire `Products` table is loaded, and *then* the `.Where()` method is executed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将返回正确的项目列表，但它的性能并不如它本可以做到的那样好。在`Products` `DbSet`实例之后添加`.ToList()`方法后，整个`Products`表被加载，然后才执行`.Where()`方法。
- en: 'A better approach to this call is shown in this code snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了处理此调用的一种更好的方法：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will also return the correct list of products. However, the SQL query generated
    will contain a `WHERE` clause as well to filter out and return the correct list
    of records. The difference here is the first query will return *all* of the records
    from the `Products` table and then filter out the resulting product list using
    the `.Where()` LINQ method. Remember—LINQ can also work with arrays.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将返回正确的产品列表。然而，生成的SQL查询将包含一个`WHERE`子句，用于过滤并返回正确的记录列表。这里的区别是第一个查询将返回`Products`表中的所有记录，然后使用`.Where()`
    LINQ方法过滤出结果产品列表。记住——LINQ也可以与数组一起工作。
- en: With the second query, a `WHERE` clause is created when the `.ToList()` method
    is encountered, and a subset of records is returned and “materialized” into entities,
    making this query extremely faster.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个查询中，当遇到`.ToList()`方法时，会创建一个`WHERE`子句，并返回一个记录子集，并将其“物化”为实体，这使得此查询非常快。
- en: Deferred execution means you are building the query and not executing it immediately.
    When you are finished building your query and want the results, end your LINQ
    query with a `.ToList()` method. If you are looking for one entity, end your LINQ
    query with a `.Single()`, `.SingleOrDefault()`, `.First()`, or `.``FirstOrDefault()`
    method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟执行意味着你正在构建查询而不是立即执行它。当你完成查询构建并想要结果时，使用`.ToList()`方法结束你的LINQ查询。如果你正在寻找一个实体，使用`.Single()`、`.SingleOrDefault()`、`.First()`或`.FirstOrDefault()`方法结束你的LINQ查询。
- en: Using a Read-Only State with .AsNoTracking()
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用.ReadOnly状态与.AsNoTracking()
- en: When retrieving data using LINQ, the `DbContext` instance has something called
    a `ChangeTracker`, which is updated when an entity’s state changes. This requires
    overhead—a small amount of overhead, but overhead, nonetheless.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用LINQ检索数据时，`DbContext`实例有一个名为`ChangeTracker`的东西，当实体的状态发生变化时，它会更新。这需要开销——虽然开销很小，但毕竟还是有开销。
- en: If you are using `DbSet` in a read-only situation, use the `.AsNoTracking()`
    method at the beginning of a LINQ statement to make Entity Framework Core aware
    it doesn’t need to track the state of models returned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个只读情况下使用`DbSet`，请在LINQ语句的开始处使用`.AsNoTracking()`方法，让Entity Framework Core知道它不需要跟踪返回的模型的状态。
- en: 'For example, the following LINQ query will retrieve an `Attraction` object
    without updating the `ChangeTracker`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下LINQ查询将检索一个`Attraction`对象，而不会更新`ChangeTracker`：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous snippet, we place the `.AsNoTracking()` method right after the
    `DbSet` instance, letting Entity Framework Core know not to track anything.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在`DbSet`实例之后放置了`.AsNoTracking()`方法，让Entity Framework Core知道不要跟踪任何内容。
- en: Leveraging the Database
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用数据库
- en: While it’s tempting to create everything in Entity Framework, there are times
    when it’s better to let the database perform data-heavy operations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建所有内容在Entity Framework中很有吸引力，但有时让数据库执行数据密集型操作会更好。
- en: With one project, I was writing large LINQ queries in code to retrieve entities
    into memory. Then, I continued to write code to calculate a count of items, sum
    up totals, and finally relate all types of child entities to the main collection
    of entities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目中，我需要在代码中编写大型的LINQ查询来将实体检索到内存中。然后，我继续编写代码来计算项目数量、汇总总额，最后将所有类型的子实体关联到主实体集合中。
- en: I realized I could achieve all of this using a stored procedure and bypass Entity
    Framework altogether. A stored procedure took care of these details, and Entity
    Framework Core simply retrieved the results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到我可以通过存储过程来实现所有这些，并且完全绕过Entity Framework。存储过程处理了这些细节，而Entity Framework Core只是检索了结果。
- en: Sometimes, it makes sense to let the database do the heavy lifting of calculating
    data and provide the results to the application since that’s its job.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，让数据库执行计算数据的繁重工作并提供结果给应用程序是有意义的，因为那是它的职责。
- en: Avoiding the Manual Property Mapping
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免手动属性映射
- en: When sending entities to render on the client, it’s best to create **Data Transfer
    Objects** (**DTOs**). You only want to send the minimal amount of data relevant
    to the currently displayed web page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当向客户端发送要渲染的实体时，最好创建 **数据传输对象**（**DTOs**）。你只想发送与当前显示的网页相关的最小数据量。
- en: However, it gets tiring writing manual left-to-right property assignments. One
    recommendation is to use AutoMapper.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动编写从左到右的属性赋值会让人感到疲倦。一个建议是使用 AutoMapper。
- en: 'AutoMapper enables the automation of mapping properties from one source object
    to a destination object. In the following example, we are taking an `Attraction`
    object and copying the properties over to a new `AttractionDto` object. AutoMapper
    handles the heavy lifting for us by matching properties and copying the data over
    to the destination object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 可以自动化将属性从一个源对象映射到目标对象。在下面的示例中，我们正在将一个 `Attraction` 对象的属性复制到一个新的 `AttractionDto`
    对象。AutoMapper 通过匹配属性并将数据复制到目标对象来为我们处理繁重的工作：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`AutoMapper` is very flexible, fills a specific need, has been downloaded from
    NuGet over 400,000 times, and is used by over 100,000 developers in the industry.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapper` 非常灵活，满足特定需求，已被从 NuGet 上下载超过 400,000 次，并且被行业中的超过 100,000 名开发者使用。'
- en: AutoMapper Library
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: AutoMapper 库
- en: 'The previous functionality only scratches the surface of what AutoMapper is
    capable of doing for developers. To understand the full potential of AutoMapper,
    visit the fully documented website at the following URL: [https://docs.automapper.org/](https://docs.automapper.org/).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的功能仅触及了 AutoMapper 为开发者所能做的功能表面。要了解 AutoMapper 的全部潜力，请访问以下 URL 的完整文档网站：[https://docs.automapper.org/](https://docs.automapper.org/)。
- en: In this section, we learned about the common uses of Entity Framework Core in
    the industry. We learned it’s best to confirm your database before creating your
    database-first `DbContext` instance, along with leveraging the capabilities of
    your database instead of hand-coding everything, and about how to perform read-only
    queries with `.AsNoTracking()`, why it’s best to use `async`/`await`, and why
    understanding deferred execution is important when writing LINQ queries. Finally,
    we examined how to log your queries, how to seed your tables using resource files,
    and avoiding manual left-to-right property mapping by using AutoMapper.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了 Entity Framework Core 在行业中的常见用法。我们学习了在创建数据库-first `DbContext` 实例之前最好确认你的数据库，以及如何利用数据库的能力而不是手动编写一切，以及如何使用
    `.AsNoTracking()` 执行只读查询，为什么最好使用 `async`/`await`，以及为什么在编写 LINQ 查询时理解延迟执行很重要。最后，我们探讨了如何记录你的查询，如何使用资源文件来初始化你的表，以及如何通过使用
    AutoMapper 避免手动从左到右映射属性。
- en: In the next section, we’ll take a simple Entity Framework application and apply
    all of our standards, and even learn some new techniques as well.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将对一个简单的 Entity Framework 应用程序应用我们所有的标准，并且甚至学习一些新技术。
- en: Implementing the Theme Park Example
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主题公园示例
- en: There is so much to digest when it comes to Entity Framework Core and all of
    its features. There are entire books on Entity Framework Core; this chapter will
    only scratch the surface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Entity Framework Core 及其所有功能时，有很多东西需要消化。关于 Entity Framework Core 的书籍有很多；本章将仅触及表面。
- en: Entity Framework Core Recommendation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 推荐
- en: For a deeper dive into Entity Framework Core, I would recommend Mastering Entity
    Framework Core 2.0 at [https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133](https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解 Entity Framework Core，我推荐阅读《Mastering Entity Framework Core 2.0》[https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133](https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133)。
- en: In this section, we’ll update a small ASP.NET application that uses Entity Framework
    Core with all of the standards we discussed in the previous section, with a few
    additional techniques to help understand Entity Framework Core even better.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新一个小型 ASP.NET 应用程序，该应用程序使用 Entity Framework Core，并包含上一节中讨论的所有标准，以及一些额外的技术来更好地理解
    Entity Framework Core。
- en: Overview
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In this example, we’ll use our previous `DbContext` instance with `Attractions`
    and `Locations` tables and create a database with SQL Server.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用我们之前的 `DbContext` 实例以及 `Attractions` 和 `Locations` 表，并使用 SQL Server
    创建一个数据库。
- en: Running the Web Application
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Web 应用程序
- en: The application used for this section is found on the Packt Publishing GitHub
    repository under `Ch5/EFApplication`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用的应用程序可在 Packt Publishing 的 GitHub 仓库中的 `Ch5/EFApplication` 下找到。
- en: We’ll keep our data access simple. We’ll use the services approach, accepting
    a `DbContext` instance to retrieve our data and create our database from our `DbContext`
    model in SQL Server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持我们的数据访问简单。我们将使用服务方法，接受一个 `DbContext` 实例来检索我们的数据，并从我们的 `DbContext` 模型在 SQL
    Server 中创建数据库。
- en: Creating the Database
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: For our application to work, we need to create our database in SQL Server. Since
    we already have our `DbContext` instance created (using the model-first approach),
    we can use Entity Framework Core migrations to build our tables.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序正常工作，我们需要在 SQL Server 中创建我们的数据库。由于我们已经创建了 `DbContext` 实例（使用模型优先方法），我们可以使用
    Entity Framework Core 迁移来构建我们的表。
- en: 'To create your local version of the database, type the following into the Package
    Manager Console (navigate to this via **View** | **Other Windows** | **Package**
    **Manager Console**):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建你的本地数据库版本，请在包管理控制台（通过 **视图** | **其他窗口** | **包** **管理器** **控制台**）中输入以下内容：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once you hit *Enter*, Entity Framework Core will locate the `DbContext` instance,
    read the configuration file (`appsettings.json`), and use the connection string
    to create our database and tables with seed data in it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你按下 *Enter*，Entity Framework Core 将定位到 `DbContext` 实例，读取配置文件（`appsettings.json`），并使用连接字符串来创建我们的数据库和表，其中包含种子数据。
- en: Adding an Asynchronous Read-Only Mode
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加异步只读模式
- en: Our first matter at hand is to apply `async`/`await` to the correct services
    so that we can scale the application later. If you are working with an existing
    ASP.NET application with Entity Framework and want to use `async`/`await` methods,
    it’s best to start with the database. If you are creating a “greenfield” project
    (meaning from scratch), use `async`/`await` methods right away to save yourself
    headaches later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的首要任务是应用 `async`/`await` 到正确的服务中，以便我们以后可以扩展应用程序。如果你正在使用带有 Entity Framework
    的现有 ASP.NET 应用程序并想使用 `async`/`await` 方法，最好从数据库开始。如果你正在创建一个“绿色”项目（即从头开始），立即使用 `async`/`await`
    方法以避免将来头疼。
- en: 'In the `AttractionService` and `LocationService` classes, we can convert all
    LINQ calls as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AttractionService` 和 `LocationService` 类中，我们可以将所有 LINQ 调用转换为以下形式：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We convert them into the following with `async`/`await`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们转换为以下形式，使用 `async`/`await`：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, since we’re not creating, updating, or deleting data, we can safely say
    this is a read-only query. So, we can apply a `.AsNoTracking()` method to the
    query, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们不会创建、更新或删除数据，我们可以安全地说这是一个只读查询。因此，我们可以将 `.AsNoTracking()` 方法应用于查询，如下所示：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As mentioned before, the `.AsNoTracking()` method will reduce the Entity Framework
    overhead since we aren’t tracking the model’s state but are simply populating
    the model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`.AsNoTracking()` 方法将减少 Entity Framework 的开销，因为我们不是跟踪模型的状态，而只是简单地填充模型。
- en: Including Child Entities
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含子实体
- en: When we query our attractions, we also want the attraction’s location. How do
    we include the location (stored in a separate table) in our query?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询我们的景点时，我们还想获取景点的位置。我们如何在查询中包含位置（存储在单独的表中）？
- en: 'As we call the `GetAttractionsAsync()` method, we place a `.Include()` method
    to retrieve the related entity. Our new `GetAttractionsAsync()` method is modified
    to match the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `GetAttractionsAsync()` 方法时，我们放置一个 `.Include()` 方法来检索相关实体。我们修改后的 `GetAttractionsAsync()`
    方法如下所示：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `.Include()` method relies heavily on the database relationships you created
    when building your model. I’ll refer you back to the “confirming your model” best
    practice we previously discussed. Entity Framework Core uses the model’s relationships
    to load related entities.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Include()` 方法在很大程度上依赖于你在构建模型时创建的数据库关系。我将回想起我们之前讨论的“确认你的模型”最佳实践。Entity Framework
    Core 使用模型的关系来加载相关实体。'
- en: Extending your Model
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展你的模型
- en: In our `Location` model, we need a way to know how many attractions are available
    at a location; we need a new property called `AttractionCount`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Location` 模型中，我们需要一种方式来知道一个位置上有多少个景点；我们需要一个新的属性，称为 `AttractionCount`。
- en: While this is a simple property added to the `Location` class, there are multiple
    decisions to be made here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个添加到 `Location` 类中的简单属性，但这里需要做出多个决定。
- en: 'First, let’s create a new file under the `Partials` folder with the same class
    name, `Location`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `Partials` 文件夹下创建一个具有相同类名的新文件，名为 `Location`：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code snippet, something may look strange. Even though the file
    is located in the `Partials` folder, *the partial namespace has to be the same
    namespace as the entities’ primary model* for the partial to work. .NET projects
    typically follow the convention of namespaces matching folder structures.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，某些内容可能看起来有些奇怪。尽管文件位于 `Partials` 文件夹中，但**部分命名空间必须与实体主模型相同的命名空间**，部分才能正常工作。.NET
    项目通常遵循命名空间与文件夹结构匹配的约定。
- en: 'When we run our application, we should experience a problem with our `Location`
    model as it currently stands, as represented here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们应该会遇到 `Location` 模型当前存在的问题，如下所示：
- en: '![Figure 5.3 – The error message when you create a property on an Entity Framework
    object](img/Figure_5.03_B19493.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 在实体框架对象上创建属性时的错误信息](img/Figure_5.03_B19493.jpg)'
- en: Figure 5.3 – The error message when you create a property on an Entity Framework
    object
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 在实体框架对象上创建属性时的错误信息
- en: What Entity Framework Core is telling us is there isn’t an `AttractionCount`
    field in the table and it can’t populate the property since it doesn’t exist.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 告诉我们的是，表中没有 `AttractionCount` 字段，因为它不存在，所以它不能填充该属性。
- en: 'We have three options here, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个选项，如下所示：
- en: Place a `[NotMapped]` attribute on the property so that it doesn’t try to populate
    the property and count our attractions by hand.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性上放置一个 `[NotMapped]` 属性，这样它就不会尝试填充属性，并手动计算我们的景点数量。
- en: Create a SQL Server function to calculate a calculated property called `AttractionCount`
    and return it so that it can populate our extra property.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 SQL Server 函数来计算一个名为 `AttractionCount` 的计算属性，并返回它，以便它可以填充我们的额外属性。
- en: Automatically count the number of attractions already in the model.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动计算模型中已有的景点数量。
- en: Let’s focus on implementing *option 3* as a quick hit for success.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于快速成功实施**选项 3**。
- en: 'While we do need a `[NotMapped]` attribute so that Entity Framework Core doesn’t
    try to load it, we’ll change the property into an `expression-bodied` property.
    We could make this an auto property ( `{get;set;}`), but we’re only using this
    as a `get` property, as shown in the following code snippet:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们确实需要一个 `[NotMapped]` 属性，这样 Entity Framework Core 就不会尝试加载它，但我们将属性改为 `expression-bodied`
    属性。我们可以将其制作为一个自动属性（`{get;set;}`），但我们只使用它作为 `get` 属性，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Keep in mind this is assuming you have a foreign-key relationship in your SQL
    Server instance created to load the attractions when a location is loaded. If
    you don’t have a `.Include()` method, your attraction count will be 0.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是假设你在 SQL Server 实例中创建了一个外键关系，用于在加载位置时加载景点。如果你没有 `.Include()` 方法，你的景点计数将为
    0。
- en: In this section, we learned how to create databases using the model-first approach,
    how to add an asynchronous, read-only mode using the `.AsNoTracking()` method
    so the state isn’t attached to the objects, how to include child entities when
    retrieving a parent model, and finally, how to extend your model using a partial
    class and attaching a `[NotMapped]` attribute to properties, letting Entity Framework
    know whether it should map a field to the property.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用模型优先方法创建数据库，如何使用 `.AsNoTracking()` 方法添加异步、只读模式，以便状态不会附加到对象上，如何在检索父模型时包含子实体，以及最后如何使用部分类扩展模型，并将
    `[NotMapped]` 属性附加到属性上，让 Entity Framework 知道它是否应该将字段映射到属性。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about three different Entity Framework Core patterns
    including Repository and Unit of Work, Specification, and Extension Methods and
    how to implement each one into your own projects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了三个不同的 Entity Framework Core 模式，包括仓储模式和单位工作模式、规范和扩展方法，以及如何将它们实现到自己的项目中。
- en: Then, we examined some of the standards in the industry, such as confirming
    your model, adding `async`/`await` to your LINQ calls, implementing logging, using
    resource files for seeding data, and understanding deferred execution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了行业的一些标准，例如确认你的模型，将 `async`/`await` 添加到你的 LINQ 调用中，实现日志记录，使用资源文件进行数据初始化，以及理解延迟执行。
- en: We also reviewed how to perform read-only queries and how to leverage the database
    by letting it perform data-intensive procedures.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还回顾了如何执行只读查询以及如何通过让数据库执行数据密集型过程来利用数据库。
- en: Finally, we applied these standards to an existing application with a way to
    create our database using the model-first approach, then examined how to add an
    asynchronous, read-only mode using the `.AsNoTracking()` method so that state
    isn’t attached to objects, how to include child entities when retrieving a parent
    model, and finally, how to extend your model while letting Entity Framework know
    which properties to populate and which properties to ignore.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些标准应用于一个现有应用程序，通过使用模型优先的方法创建我们的数据库，然后检查如何使用 `.AsNoTracking()` 方法添加异步、只读模式，以便状态不会附加到对象上，如何在检索父模型时包含子实体，以及最后如何在扩展模型的同时让
    Entity Framework 知道哪些属性需要填充以及哪些属性需要忽略。
- en: In the next chapter, we’ll learn about UI standards with MVC, Razor Pages, ViewComponents,
    HTMLHelpers, and Task Runners.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用 MVC、Razor Pages、ViewComponents、HTMLHelpers 和 Task Runners 的 UI
    标准。
