- en: Handy Interactables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方便的交互式组件
- en: You're in a virtual world with all this cool stuff; it is our nature to try
    to reach out and touch something. While gaze-based selection, as we saw in the
    previous chapter, is a good first step for interacting with virtual scenes, most
    people intuitively want to use their hands. Most VR devices provide a hand controller
    to select, grab, and interact with virtual objects in the scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你身处一个充满这些酷炫东西的虚拟世界；我们的天性就是试图伸手触摸某物。正如我们在上一章中看到的，基于注视的选择是交互虚拟场景的一个良好开端，但大多数人直观地想要用手操作。大多数VR设备都提供手柄控制器来选择、抓取和与场景中的虚拟对象交互。
- en: 'In this chapter, we introduce practices for capturing user input in Unity,
    illustrating how to use them in a simple VR scene. Everyone loves balloons, so
    in this project we will make balloons. We may even pop a few. We will continue
    from the previous chapter, using C# programming for basic scripting, and explore
    several software design patterns for user input. We will discuss the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍在Unity中捕获用户输入的实践，说明如何在简单的VR场景中使用它们。每个人都喜欢气球，所以在这个项目中我们将制作气球。我们甚至可能会弄爆几个。我们将从上一章继续，使用C#编程进行基本脚本编写，并探讨几个软件设计模式用于用户输入。我们将讨论以下主题：
- en: Polling for input device data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询输入设备数据
- en: Using scriptable data objects for storing and retrieving input state
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可脚本数据对象存储和检索输入状态
- en: Invoking and subscribing to input events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和订阅输入事件
- en: Using interactable components provided with device-specific Unity packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备特定Unity包提供的交互式组件
- en: An important lesson we will learn in this chapter is there is not just one way
    to handle user input for your VR application. There isn't even one *best way*.
    Unity includes several mechanisms for handling user input and, in general, messaging
    between objects. VR device manufacturers provide their own input controller objects
    and scripts for their SDK.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习的一个重要教训是，处理VR应用程序的用户输入并不只有一种方式。甚至没有一种*最佳方式*。Unity包括处理用户输入和对象之间一般消息传递的几种机制。VR设备制造商为其SDK提供自己的输入控制器对象和脚本。
- en: Furthermore, VR manufacturers and others offer convenient framework toolkits
    with higher-level components and prefabs. We recommend you become familiar with
    the toolkits provided for your target device. Study the demo scenes to see how
    the components work and their recommended practices, as we will do at the end
    of this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，VR制造商和其他人提供了方便的框架工具包，包含高级组件和预制件。我们建议你熟悉为你目标设备提供的工具包。研究演示场景，看看组件是如何工作的以及它们的推荐实践，就像我们在本章末尾将要做的那样。
- en: That said, in this chapter we will start with the very simple button press input,
    and progress from there, showing various design patterns. You won't always want
    to roll your own, but you should have an understanding of how things work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在本章中，我们将从非常简单的按钮按下输入开始，并由此展开，展示各种设计模式。你并不总是想自己从头开始，但你应该了解事物是如何工作的。
- en: Setting up the scene
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: To begin our exploration of input mechanisms, let's set up our scene. The plan
    is to let players create balloons. Everyone loves balloons!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们对于输入机制的探索，让我们设置我们的场景。计划是让玩家创建气球。每个人都喜欢气球！
- en: 'For this scene, you could start with a new scene (File | New Scene) and then
    add the MyMyselfEye prefab we built in the previous chapter. Instead, I''ve decided
    to start with the Diorama scene created in the previous chapter, and remove all
    but the GroundPlane and PhotoPlane, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个场景，你可以从一个新场景（文件 | 新场景）开始，然后添加我们在上一章中构建的MyMyselfEye预制件。相反，我决定从上一章中创建的“展览馆”场景开始，并移除除了地面平面和照片平面之外的所有对象，如下所示：
- en: Open the Diorama scene
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“展览馆”场景
- en: Remove all the objects, except for MyMyselfEye, Directional Light, GroundPlane
    and PhotoPlane
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有对象，除了MyMyselfEye、方向光、地面平面和照片平面
- en: Position the MeMyselfEye at the scene origin, Position (0, 0, 0)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MeMyselfEye放置在场景原点，位置(0, 0, 0)
- en: Select File | Save Scene As and give it a name, such as "Balloons"
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 保存场景为，并给它起一个名字，例如“气球”
- en: Creating a balloon
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建气球
- en: For the balloon, you can simply use a standard Unity sphere 3D primitive if
    you choose. Or you can find an object in the Unity Asset Store or elsewhere. We
    are using a low poly balloon object that we found on Google Poly ([https://poly.google.com/view/a01Rp51l-L3](https://poly.google.com/view/a01Rp51l-L3))
    and which is provided with the download files for this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于气球，如果你选择，可以简单地使用标准的Unity球体3D原语。或者你可以在Unity资产商店或其他地方找到一个对象。我们使用了一个在Google Poly上找到的低多边形气球对象（[https://poly.google.com/view/a01Rp51l-L3](https://poly.google.com/view/a01Rp51l-L3)），并且它提供了本章的下载文件。
- en: 'Either way, please parent the object so its origin (pivot point) is at the
    bottom, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，请将对象设置为父对象，使其原点（旋转点）位于底部，如下所示：
- en: In Hierarchy, create an empty object (Create | Create Empty) and name it "Balloon".
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个空对象（创建 | 创建空对象）并将其命名为“气球”。
- en: Reset its transform (Transform | gear-icon | Reset), then Position it at (0,
    1, 1).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置其变换（变换 | 齿轮图标 | 重置），然后将其定位在（0，1，1）。
- en: Drag the balloon prefab into the Hierarchy as a child object of Balloon (mine
    is found in the `Assets/Poly/Assets/` folder).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将气球预制件拖入层次结构，作为气球（我的位于`Assets/Poly/Assets/`文件夹）的子对象。
- en: If you do not have a balloon model, use a sphere (Create | 3D Object | Sphere).
    And add a material, like the "Blue Material" we created in the previous chapter.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有气球模型，请使用球体（创建 | 3D对象 | 球体）。并添加一个材质，如我们在上一章中创建的“蓝色材质”。
- en: Set the child object's Position to (0, 0.5, 0) so its origin (pivot point) is
    at its bottom when referenced from the parent.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子对象的“位置”设置为（0，0.5，0），使其原点（旋转点）在从父对象引用时位于底部。
- en: 'The scene should look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 场景应该看起来像这样：
- en: '![](img/7881a110-f890-4d78-bdc3-6132de13f1d1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7881a110-f890-4d78-bdc3-6132de13f1d1.png)'
- en: Making it a prefab
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其成为预制件
- en: Our intent is to instantiate new balloons from a prefab when your player presses
    a button on their controller. And when the button is released, the balloon gets
    released and it floats away.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是在玩家按下控制器上的按钮时从预制件实例化新的气球。当按钮释放时，气球被释放并飘走。
- en: 'Let''s scale and position the balloon initially in the scene at a starting
    size and workable distance. We will also give it some physics properties by adding
    a `RigidBody` component:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中调整气球的大小和位置，使其在起始大小和工作距离内。我们还将通过添加`RigidBody`组件来给它一些物理属性：
- en: We discuss RigidBodies and Unity physics in more detail in [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml),
    *Playing with Physics and Fire*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第8章](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml)中更详细地讨论了刚体和Unity物理。
- en: Select your Balloon object in Hierarchy
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择你的气球对象
- en: In Inspector, set its Transform Scale to (0.1, 0.1, 0.1)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将其“变换缩放”设置为（0.1，0.1，0.1）
- en: Set its Position to (0, 1, 1)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（0，1，1）
- en: Use Add Component to add a Rigid Body
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“添加组件”添加一个刚体
- en: Uncheck the Use Gravity checkbox
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中“使用重力”复选框
- en: 'My balloon object now has the following properties:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的气球对象现在有以下属性：
- en: '![](img/15b70c9b-e8c5-4068-8f0a-0c94473f641e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15b70c9b-e8c5-4068-8f0a-0c94473f641e.png)'
- en: 'Make it a prefab as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式将其设置为预制件：
- en: Drag the balloon object into your `Prefabs/ `folder to make it a prefab object
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将气球对象拖入你的`Prefabs/`文件夹以使其成为预制件对象
- en: Delete the original balloon object from your Hierarchy
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的层次结构中删除原始气球对象
- en: Okay. Now let's play around with controller buttons.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在让我们来玩控制器按钮。
- en: If you ever want to modify a prefab, drag an instance of it back into the scene.
    Make the changes you want. Then, use the Apply button to save the changes back
    onto the prefab of the object. Delete the temporary instance from the Hierarchy
    if it's no longer needed in the scene.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要修改一个预制件，将其实例拖回场景中。进行你想要的更改。然后，使用应用按钮将更改保存回对象的预制件。如果场景中不再需要临时实例，请从层次结构中删除它。
- en: Basic button input
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本按钮输入
- en: Unity includes a standard Input Manager for accessing traditional game controller,
    keyboard, mouse, and mobile touchscreen input. This can include specific button
    presses, joystick axes, and the device accelerometer, for example. It also supports
    input from VR and AR systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity包括一个标准的输入管理器，用于访问传统的游戏控制器、键盘、鼠标和移动触摸屏输入。这可以包括特定的按钮按下、摇杆轴和设备加速度计等。它还支持来自VR和AR系统的输入。
- en: The Input Manager provides an abstraction layer over the physical input devices.
    For example, you can reference logical inputs, such as the `Fire1` button, which
    is mapped to a physical button. The mappings for your project can be set up and
    modified in Edit | Project Settings | Input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入管理器在物理输入设备之上提供了一个抽象层。例如，您可以引用逻辑输入，例如映射到物理按钮的 `Fire1` 按钮。您可以在编辑 | 项目设置 | 输入中设置和修改项目的映射。
- en: For a general overview and details of Unity Input Manager, see [https://docs.unity3d.com/Manual/ConventionalGameInput.html](https://docs.unity3d.com/Manual/ConventionalGameInput.html). 
    For scripting the Input class, see [https://docs.unity3d.com/ScriptReference/Input.html](https://docs.unity3d.com/ScriptReference/Input.html).
    Input mapping for various VR devices can be found at [https://docs.unity3d.com/Manual/vr-input.html](https://docs.unity3d.com/Manual/vr-input.html).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Unity 输入管理器的概述和详细信息，请参阅 [https://docs.unity3d.com/Manual/ConventionalGameInput.html](https://docs.unity3d.com/Manual/ConventionalGameInput.html)。有关输入类的脚本编写，请参阅
    [https://docs.unity3d.com/ScriptReference/Input.html](https://docs.unity3d.com/ScriptReference/Input.html)。各种
    VR 设备的输入映射可以在 [https://docs.unity3d.com/Manual/vr-input.html](https://docs.unity3d.com/Manual/vr-input.html)
    找到。
- en: Let's take a look. To start, we will write a test script to get a specific button
    state and see how the Unity Input class works. A common logical button is the
    one named "Fire1." Let's see which button your input device uses for "Fire1."
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看。首先，我们将编写一个测试脚本以获取特定按钮状态并查看 Unity 输入类的工作方式。一个常见的逻辑按钮是名为 "Fire1" 的按钮。让我们看看您的输入设备为
    "Fire1" 使用哪个按钮。
- en: Using the Fire1 button
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Fire1 按钮
- en: 'We will now write a script, `MyInputController`, to detect when your user has
    pressed the `Fire1` button. Add the script to your `MeMyselfEye` object as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写一个名为 `MyInputController` 的脚本，以检测用户是否按下了 `Fire1` 按钮。按照以下方式将脚本添加到您的 `MeMyselfEye`
    对象中：
- en: In Hierarchy, select the MyMyselfEye object
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Hierarchy 中选择 MyMyselfEye 对象
- en: In Inspector, click Add Component, then New Script
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Inspector 中点击添加组件，然后新建脚本
- en: Name it `MyInputController` and press Create And Add
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为 `MyInputController` 并按创建和添加
- en: Double-click the `MyInputController` script to open it for editing
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `MyInputController` 脚本以打开它进行编辑
- en: 'Edit the script as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编辑脚本：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this script, in each frame Update, we call a private function, `ButtonTest`.
    This function builds a message string named `msg` that reports whether the `Fire1`
    button has just been pressed down or released. The call to `Input.GetButtonDown("Fire1")`,
    for example, will return a Boolean (true or false) value, which we check in the
    `if` statement. When either of these situations are true, the `msg` string is
    not empty (null) and gets printed to the Unity Console window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，在每一帧的 Update 中，我们调用一个私有函数 `ButtonTest`。此函数构建一个名为 `msg` 的消息字符串，报告 `Fire1`
    按钮是否刚刚被按下或释放。例如，调用 `Input.GetButtonDown("Fire1")` 将返回一个布尔值（true 或 false），我们在 `if`
    语句中检查它。当这些情况中的任何一个为真时，`msg` 字符串不为空（null）并将其打印到 Unity 控制台窗口：
- en: Press Play in the Unity editor to run the scene
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中按播放键以运行场景
- en: 'When you press the Fire1 button on your input controller, you will see the
    Input: Fire1 down message as output'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当您按下输入控制器上的 Fire1 按钮时，您将看到输出消息 Input: Fire1 down'
- en: 'When you release the Fire1 button, you will see the Input: Fire1 up message,
    as shown here:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当您释放 Fire1 按钮时，您将看到 Input: Fire1 up 消息，如下所示：'
- en: '![](img/28bb4769-3388-4884-b766-d1a4741302e1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/28bb4769-3388-4884-b766-d1a4741302e1.png)'
- en: You can use even use this script to identify which physical button on your input
    controller maps to the logical `Fire1` button. Using OpenVR, for example, `Fire1`
    is triggered with the menu button on a Vive controller or the **B** button on
    the Oculus Touch controller ("Button.Two") as shown on the Unity Input System
    Mappings section in the Input for OpenVR Controllers page of the Unity manual 
    ([https://docs.unity3d.com/Manual/OpenVRControllers.html](https://docs.unity3d.com/Manual/OpenVRControllers.html)).
    Feel free to experiment with using other logical input names, and/or modifying
    the mappings using the Input project settings (Edit | Project Settings | Input).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用此脚本来识别您的输入控制器上的哪个物理按钮映射到逻辑 `Fire1` 按钮。例如，使用 OpenVR，`Fire1` 按钮是通过 Vive
    控制器的菜单按钮或 Oculus Touch 控制器的 **B** 按钮触发的 ("Button.Two")，如 Unity 输入系统映射部分所示，该部分位于
    Unity 手册的 OpenVR 控制器输入页面中 ([https://docs.unity3d.com/Manual/OpenVRControllers.html](https://docs.unity3d.com/Manual/OpenVRControllers.html))。您可以自由地尝试使用其他逻辑输入名称，以及/或通过输入项目设置（编辑
    | 项目设置 | 输入）修改映射。
- en: Instead of using Unity logical inputs, it is also common to access the device
    directly through SDK components. Let's look into that in the  next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Unity逻辑输入外，通过SDK组件直接访问设备也是常见的。让我们在下一节中探讨这一点。
- en: OpenVR trigger button
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenVR触发按钮
- en: If you have a VR device supported by OpenVR (HTC Vive, Oculus Rift, or Windows
    MR), let's modify the `ButtonTest` function to check for a pull and release of
    the trigger button.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个由OpenVR支持的VR设备（HTC Vive、Oculus Rift或Windows MR），让我们修改`ButtonTest`函数以检查触发按钮的拉动和释放。
- en: 'To implement this, we need to provide our script with the specific input component
    that we want to query. In OpenVR, this is represented by the `SteamVR_TrackedObject`
    component, as shown in the following variation of our script:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们需要为我们想要查询的特定输入组件提供我们的脚本。在OpenVR中，这由`SteamVR_TrackedObject`组件表示，如下面的脚本变体所示：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After saving this script, we need to populate the `rightHand` variable:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此脚本后，我们需要填充`rightHand`变量：
- en: In Unity, select MeMyselfEye so you can see the My Input Controller in the Inspector
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，选择MeMyselfEye以便可以在检查器中看到My Input Controller
- en: In the Hierarchy, unfold the [CameraRig] object
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中展开[CameraRig]对象
- en: Click the Controller (Right) child object and drag it onto the My Input Controller's
    Right Hand slot in the Inspector
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击控制器（右侧）子对象并将其拖动到检查器中My Input Controller的右手槽位
- en: Given the `rightHand` object, we reference its `SteamVR_TrackedObject` component
    directly. In the `ButtonTest` function, we get the *device* data using the right
    hand's device ID (`rightHand.index`), and check specifically for the trigger press
    status. As a bonus, I've shown you how to also provide a haptic buzz pulse on
    the device when the trigger is pressed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`rightHand`对象，我们直接引用其`SteamVR_TrackedObject`组件。在`ButtonTest`函数中，我们使用右手设备的设备ID（`rightHand.index`）获取*设备*数据，并检查特定于触发器的按下状态。作为额外的好处，我已经向你展示了如何在按下触发器时在设备上提供触觉蜂鸣脉冲。
- en: Now when you press Play, pulling the controller trigger will be recognized.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按下播放时，拉动控制器触发器将被识别。
- en: Using the SDK components like this, you can access other inputs specific to
    the device not supported by the Unity Input Manager. The trigger on some controllers
    are not just pressed/unpressed but can return a percentage of press, represented
    as a value between 0.0 and 1.0\. Another example is the touch-sensitive grips,
    buttons, and thumb pad on the Oculus Touch controllers and other controllers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的SDK组件，你可以访问Unity输入管理器不支持的其他特定于设备的输入。一些控制器上的触发器不仅仅是按下/未按下，还可以返回一个百分比，表示为介于0.0和1.0之间的值。另一个例子是Oculus
    Touch控制器和其他控制器上的触控敏感握把、按钮和拇指盘。
- en: 'Try modifying the script to recognize the controller `Grip` button instead,
    or other inputs. Hint: try *SteamVR_Controller.ButtonMask.**Grip*.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改脚本以识别控制器`Grip`按钮或其他输入。提示：尝试*SteamVR_Controller.ButtonMask.Grip*。
- en: Daydream controller clicks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Daydream控制器点击
- en: 'Google Daydream VR on Android may not respond, by default, to `Fire1` events.
    The following code shows how to access controller clicks directly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Google Daydream VR在Android上默认可能不会对`Fire1`事件做出响应。以下代码显示了如何直接访问控制器点击：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we call the `GvrControllerInput` class static functions `ClickButtonDown`
    and `ClickButtonUp`. There is no need to identify a specific controller object
    because `GvrControllerInput` is a *singleton*. That is why we're guaranteed to
    have only one instance of it in the scene, so we can reference its data directly.
    This makes sense because on Daydream there will only be one hand controller, whereas
    on OpenVR there will be two.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们调用`GvrControllerInput`类的静态函数`ClickButtonDown`和`ClickButtonUp`。没有必要识别特定的控制器对象，因为`GvrControllerInput`是一个*单例*。这就是为什么我们可以保证在场景中只有一个实例，因此我们可以直接引用其数据。这在Daydream中是有意义的，因为那里只有一个手柄控制器，而在OpenVR中则有两个。
- en: Polling for clicks
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测点击
- en: 'The simplest way to obtain user input is just *get* the current data from an
    input component. We''ve already seen this using the Input class and VR SDK. Presently,
    we will write our own input component that maps the Unity (or SDK) input to our
    own simple API in `MyInputController`. Then, we''ll write a `BalloonController`
    that polls the input, as illustrated:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户输入的最简单方法就是从输入组件中*获取*当前数据。我们已经使用Input类和VR SDK看到了这一点。目前，我们将编写自己的输入组件，将Unity（或SDK）输入映射到我们自己的简单API
    `MyInputController`中。然后，我们将编写一个`BalloonController`来轮询输入，如图所示：
- en: '![](img/65788305-5dad-48b6-aba4-387704e3ee6e.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65788305-5dad-48b6-aba4-387704e3ee6e.png)'
- en: Our own button interface functions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们自己的按钮接口函数
- en: You may recall that the `MeMyselfEye` player rig may have device-specific toolkit
    child objects for a particular VR SDK. The version for OpenVR, for example, has
    their [CameraRig] prefab. The version for Daydream has the Daydream Player prefab.
    It makes sense to add our `MyInputController` component to `MeMyselfEye`, as it
    may make device-specific SDK calls. In this way, should you want to maintain camera
    rig prefabs for a variety of platforms, and swap them in and out as you build
    the project for a different VR target, the API that is exposed to the rest of
    your application will be consistent and independent of the specific device toolkit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得`MeMyselfEye`玩家装置可能具有特定VR SDK的设备特定工具箱子对象。例如，OpenVR的版本有他们的[CameraRig]预制件。Daydream的版本有Daydream
    Player预制件。将我们的`MyInputController`组件添加到`MeMyselfEye`中是有意义的，因为它可能需要执行设备特定的SDK调用。这样，如果你想要维护适用于各种平台的相机装置预制件，并在为不同的VR目标构建项目时进行交换，那么公开给应用程序其余部分的API将是统一的，并且独立于特定的设备工具箱。
- en: 'Our input controller will expose two custom API Functions, `ButtonDown `and `ButtonUp`.
    The implementation of these functions will be hidden from the components that
    call them. For example, we could write it to handle `Fire1` button presses as
    first but later change it to use a trigger press instead, or make a version for
    Daydream that does not use `Fire1`. Let''s update the `MyInputController` by adding
    the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入控制器将公开两个自定义API函数，`ButtonDown`和`ButtonUp`。这些函数的实现将隐藏在调用它们的组件中。例如，我们可以将其编写为首先处理`Fire1`按钮按下，但稍后将其更改为使用触发器按下，或者为Daydream创建一个不使用`Fire1`的版本。让我们通过添加以下代码来更新`MyInputController`：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or you can modify the preceding code to use the button interface that works
    for you. For example, for Daydream you might use this instead:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以修改前面的代码以使用适合你的按钮界面。例如，对于Daydream，你可能可以使用以下代码代替：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we'll use our little `ButtonUp`/`ButtonDown` input API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们的`ButtonUp`/`ButtonDown`输入API。
- en: Creating and releasing balloons
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和释放气球
- en: 'Let''s now create a `BalloonController` that will be the application component
    that creates and controls balloons. It will reference our `MyInputController`.
    Follow these steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建一个`BalloonController`，它将是创建和控制气球的程序组件。它将引用我们的`MyInputController`。按照以下步骤操作：
- en: In Hierarchy, create an empty game object, reset its Transform, and name it
    `BalloonController`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个空的游戏对象，重置其变换，并将其命名为`BalloonController`
- en: 'Create a new script on the object named `BalloonController` and open it for
    editing as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`BalloonController`的对象上创建一个新的脚本，并按以下方式打开它进行编辑：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the skeleton of the controller. Given a reference to the `MeMyselfEye`
    object, the `Start()` function gets its `MyInputController` component and assigns
    it to the `inputController `variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制器的骨架。给定`MeMyselfEye`对象的引用，`Start()`函数获取其`MyInputController`组件并将其分配给`inputController`变量。
- en: '`Update()` is called each frame while your game is running. It will call `inputController.ButtonDown`
    or `ButtonUp` to see if the user has changed their input, and in response, either
    create or release a balloon. We''ll write the functions next.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`在游戏运行时每帧被调用。它将调用`inputController.ButtonDown`或`ButtonUp`以查看用户是否更改了输入，并根据响应创建或释放气球。我们将在下面编写这些函数。'
- en: Note that we've also included a placeholder (as a comment) where we'll add the
    `GrowBalloon` function too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在注释中包含了一个占位符，我们将在这里添加`GrowBalloon`函数。
- en: 'Given the balloon prefab, the `BalloonController` can create new instances
    of it in our scene, by calling the Unity `Instantiate` function. Add the following
    `public` variable declaration at the top of your controller class for the balloon
    prefab:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定气球预制件，`BalloonController`可以通过调用Unity的`Instantiate`函数在我们的场景中创建它的新实例。在你的控制器类顶部添加以下`public`变量声明以用于气球预制件：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And add a `private` variable to hold the current instance of the balloon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一个`private`变量来保存当前气球的实例：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the `NewBalloon` function, which is called when the player presses the
    button, references the prefab and instantiates it as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家按下按钮时调用的`NewBalloon`函数引用预制件，并按以下方式实例化：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `ReleaseBalloon` function is called when the player releases the button.
    It will apply a gentle upward force on the balloon so it floats skyward. We''ll
    define a floatStrength variable and apply it to the object''s RigidBody (the Unity
    physics engine and RigidBodies are explained in a later chapter):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家释放按钮时，会调用`ReleaseBalloon`函数。它将对气球施加一个轻微的向上力，使其向天空飘浮。我们将定义一个`floatStrength`变量并将其应用于对象的RigidBody（Unity物理引擎和RigidBodies将在后面的章节中解释）：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we also clear the balloon variable (setting it to null), getting
    it ready for the next button press.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还清除了气球变量（将其设置为 null），为下一次按钮按下做好准备。
- en: 'Save the file and in Unity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并在 Unity 中：
- en: Drag the MeMyselfEye object from Hierarchy onto the BalloonController's Me Myself
    Eye slot in Inspector
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hierarchy 中的 MeMyselfEye 对象拖动到 Inspector 中 BalloonController 的 Me Myself Eye
    插槽
- en: Drag the Ballon prefab from the Project's `Assets` folder onto the BalloonController's
    Balloon Prefab slot in Inspector
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Balloon 预制件从项目的 `Assets` 文件夹拖动到 Inspector 中 BalloonController 的 Balloon Prefab
    插槽
- en: 'When you''re ready, press Play. Inside VR, when you press the `Fire1` button
    (or whichever you programmed), a new balloon is instantiated. When you release
    it, the balloon floats upwards. In the following game window, I have pressed the
    button multiple times in succession, creating a series of balloons:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，按 Play。在 VR 中，当你按下 `Fire1` 按钮（或你编程的任意按钮）时，会实例化一个新的气球。当你释放它时，气球会向上漂浮。在下面的游戏窗口中，我已经连续多次按下按钮，创建了一系列气球：
- en: '![](img/db562021-0983-467f-ad46-ad884fc34a20.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db562021-0983-467f-ad46-ad884fc34a20.png)'
- en: 'Here is the Hierarchy of the same game state, showing the cloned balloons in
    the Hierarchy (my prefab''s name is `Balloon-poly`):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同游戏状态的 Hierarchy，显示了 Hierarchy 中的克隆气球（我的预制件名称为 `Balloon-poly`）：
- en: '![](img/afc206b2-54f7-4659-aa3e-e565dfb26bce.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afc206b2-54f7-4659-aa3e-e565dfb26bce.png)'
- en: Inflating a balloon while pressed
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按下时充气气球
- en: 'The next thing we want to do is inflate the balloon while you''re still holding
    the button. We can do this by checking whether there''s a current balloon instance
    from a button press, and modifying its scale each update by a specified grow rate.
    Let''s define that first, to grow by 150% each second the button is held down
    (1.5 times):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们想在按下按钮的同时充气气球。我们可以通过检查是否有来自按钮按下的当前气球实例，并在每次更新时通过指定的增长率修改其缩放来实现。让我们首先定义它，以便在按钮按下的每秒增长
    150%（1.5 倍）：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, modify the Update function with a third `else if` condition as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改 Update 函数，添加一个第三层的 `else if` 条件，如下所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And add the `GrowBalloon` function like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 并像这样添加 `GrowBalloon` 函数：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `GrowBalloon` function will modify the balloon's local scale by a percentage
    of its current size. `growRate` is the rate of growth per second. So, we multiply
    that by the current fraction of a second in this frame (`Time.deltaTime`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`GrowBalloon` 函数将通过当前大小的百分比修改气球的本地区域缩放。`growRate` 是每秒的增长率。因此，我们将其乘以当前帧中的当前分数秒（`Time.deltaTime`）。'
- en: Press Play in Unity. When you press the controller button, you'll create a balloon,
    which continues to inflate until you release the button. Then the balloon floats
    up. Wow, that's actually pretty fun!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中按 Play。当你按下控制器按钮时，你会创建一个气球，气球会继续充气，直到你释放按钮。然后气球会漂浮起来。哇，这实际上很有趣！
- en: Next, we're going to refactor our code to use a different software pattern for
    getting user input, using scriptable objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重构我们的代码，使用不同的软件模式来获取用户输入，使用可脚本化对象。
- en: No one writes code without expecting to change it. Programming is a dynamic
    art as you rethink how to do things, as requirements grow, and problems get fixed.
    Sometimes, these changes are not necessarily to add a new feature or fix a bug
    but to make the code cleaner, easier to use, and easier to maintain. This is called
    **refactoring**, when you change or rewrite parts of a program but do not necessarily
    change how the feature works from the player's perspective.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人编写代码而不期望对其进行更改。编程是一种动态的艺术，因为你需要重新思考如何做事，随着需求增长和问题解决，这些更改并不一定是为了添加新功能或修复错误，而是为了使代码更干净、更易于使用和维护。这被称为
    **重构**，当你更改或重写程序的一部分，但并不一定改变玩家视角中的功能工作方式时。
- en: Using scriptable objects for input
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可脚本化对象进行输入
- en: In this example, we will further decouple our application from the underlying
    input device using a technique called **scriptable** **objects****.** These are
    data objects used for holding information such as game state, player preferences,
    or any other data that is not necessarily graphical. Scriptable objects are instantiated
    during runtime, much like MonoBehaviour ones, but do not live in the Hierarchy,
    have no Transform, nor other physics and rendering behaviors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一种称为 **可脚本化** **对象** 的技术进一步解耦我们的应用程序与底层输入设备。这些是用于存储信息的数据对象，例如游戏状态、玩家偏好或任何其他非图形数据。可脚本化对象在运行时实例化，就像
    MonoBehaviour 一样，但它们不位于 Hierarchy 中，没有 Transform，也没有其他物理和渲染行为。
- en: It's useful to think of scriptable objects as *data containers* in your projects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将可脚本化对象视为项目中的*数据容器*是有用的。
- en: 'In the previous implementation, `BalloonController` requires a reference to
    the `MeMyselfEye` object to use its `MyInputController` component. Although the
    input controller component does separate you from the underlying SDK calls, if
    you modify your application to use a different `MeMyselfEye` (for example, from
    OpenVR to Daydream), you will need to find and replace all references to one `MeMyselfEye`
    in the scene and replace them with the new one. Here''s will have the input controller
    populate a scriptable object, and then our `BalloonController` reference that
    object for the data, as illustrated here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中，`BalloonController`需要一个对`MeMyselfEye`对象的引用来使用其`MyInputController`组件。尽管输入控制器组件可以让你与底层的SDK调用分离，但如果你要修改应用程序以使用不同的`MeMyselfEye`（例如，从OpenVR到Daydream），你需要找到并替换场景中所有对`MeMyselfEye`的引用，并将它们替换为新的对象。这里将输入控制器填充到一个可脚本化对象中，然后我们的`BalloonController`引用该对象的数据，如图所示：
- en: '![](img/ec4cf25f-0253-44ae-ac25-a67e3a53c83e.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec4cf25f-0253-44ae-ac25-a67e3a53c83e.jpg)'
- en: The process of implementing scriptable objects is a little more involved than
    game objects with components. But not much. Let's go!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实现脚本化对象的过程比具有组件的游戏对象稍微复杂一些。但并不多。让我们开始吧！
- en: Keep in mind this is just one example how to use scriptable objects and serves
    as an introduction to this powerful design pattern in Unity. For more information,
    see the Unity Tutorial *Introduction to* s*criptable* obj*ects* at [https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects](https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects). Also,
    see [Chapter 9](232442fa-b5ba-4e11-9734-905b243e34a5.xhtml), Exploring Interactive
    Spaces, for another example of scriptable objects for data management in a project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个如何使用可脚本化对象的例子，同时也是Unity中这种强大设计模式的入门介绍。更多信息，请参阅Unity教程 *Introduction
    to* s*criptable* obj*ects* 在[https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects](https://unity3d.com/learn/tutorials/modules/beginner/live-training-archive/scriptable-objects)。另外，参见[第9章](232442fa-b5ba-4e11-9734-905b243e34a5.xhtml)，探索交互空间，了解另一个在项目中使用可脚本化对象进行数据管理的例子。
- en: Creating the scriptable object
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建脚本化对象
- en: 'In this example, our object will just have one variable, for the current button
    action. We''ll say the button can have one of three possible values: `PressedDown`,
    `ReleasedUp`, or `None`. We''ll define the action as having occurred current during
    the current `Update`, then it''s cleared to `None`. That is, rather than record
    the current button state (for example, is pressed), we are capturing the current
    button action (was just pressed), to be consistent with other examples in this
    chapter.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的对象将只有一个变量，用于当前按钮动作。我们将说按钮可以有三个可能的值：`PressedDown`、`ReleasedUp`或`None`。我们将动作定义为在当前`Update`期间发生，然后清除为`None`。也就是说，我们不是记录当前按钮状态（例如，是否按下），而是捕获当前按钮动作（刚刚按下），以与其他章节中的示例保持一致。
- en: 'It''s useful to keep scriptable objects in their own folder in the Project
    `Assets`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将可脚本化对象保存在项目`Assets`中的单独文件夹中是有用的：
- en: In the **Project** window, create a new folder under *Assets* named `ScriptableObjects`
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，在*Assets*下创建一个名为`ScriptableObjects`的新文件夹
- en: In the new folder, right-click and select Create | C# Script
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，右键单击并选择创建 | C# 脚本
- en: Name the script `MyInputAction`
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为`MyInputAction`
- en: Then, open the `MyInputAction.cs` script for editing
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`MyInputAction.cs`脚本进行编辑
- en: 'Edit the `MyInputAction.cs` script as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式编辑`MyInputAction.cs`脚本：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rather than inheriting from `MonoBehaviour`, we will define the class as a `ScriptableObject`.
    We represent the action using an enum to restrict its possible values to the selection
    list.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从`MonoBehaviour`继承，而是将类定义为`ScriptableObject`。我们使用枚举来表示动作，以限制其可能的值到选择列表。
- en: '"The **enum** keyword is used to declare an enumeration, a distinct type that
    consists of a set of named constants called the enumerator list." - [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “`enum`关键字用于声明枚举，这是一个由称为枚举列表的命名常量集合组成的独特类型。” - [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)
- en: 'Notice the first line of the preceding script. We provide a *property attribute*
    which generates a menu item in the Unity Editor for our object. Since scriptable
    objects are not added to the scene Hierarchy, we need a way to create them in
    the project. Using this attribute makes it easy, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面脚本的第一行。我们提供了一个*属性属性*，它会在Unity编辑器中为我们的对象生成一个菜单项。由于脚本化对象不会被添加到场景层次结构中，我们需要一种在项目中创建它们的方法。使用此属性使其变得容易，如下所示：
- en: Save the script and return to Unity.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity。
- en: In the Unity editor main menu, navigate to Assets | Create.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器主菜单中，导航到资产 | 创建。
- en: You will see a new item, My Objects, with a submenu with an item Input Action,
    as directed in the `CreateAssetsMenu` property attribute in our script. The menu
    is shown next.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个名为My Objects的新项目，其中包含一个子菜单，有一个名为Input Action的项目，正如我们在脚本中的`CreateAssetsMenu`属性属性中指定的那样。菜单如下所示。
- en: Choose Input Action to create an instance. By default, it will be created in
    the currently selected Project Assets folder. So if you have the `ScriptableObjects`
    folder open, it will be created there.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择输入动作以创建一个实例。默认情况下，它将在当前选定的项目资产文件夹中创建。所以如果你打开了`ScriptableObjects`文件夹，它将在那里创建。
- en: Rename the object `My Input Action Data`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象重命名为`My Input Action Data`。
- en: '![](img/6eb1b9b9-4382-4b39-9893-091da7609977.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6eb1b9b9-4382-4b39-9893-091da7609977.png)'
- en: 'If you select the new `My Input Action Data` object in your `ScriptableObjects/`
    folder, you can see its properties in the Inspector. In the following screen capture,
    I have clicked the **Button Action** drop-down list to reveal the possible enum
    values we''ve specified in our code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择`ScriptableObjects/`文件夹中的新`My Input Action Data`对象，你可以在检查器中看到其属性。在下面的屏幕截图中，我已点击**按钮动作**下拉列表以显示我们在代码中指定的可能枚举值：
- en: '![](img/5f2f8d3f-50fa-435a-b1fa-ec685effef86.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f2f8d3f-50fa-435a-b1fa-ec685effef86.png)'
- en: Populating the input action object
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充输入动作对象
- en: 'The next step is to change `MyInputController.cs` to populate the input data
    object, using a reference to the object, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`MyInputController.cs`更改为填充输入数据对象，使用对对象的引用，如下所示：
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The script uses its own `ButtonDown` and `ButtonUp` functions to set the `buttonAction`
    as appropriate. These could even be changed from *public* to *private* to further
    encapsulate it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用自己的`ButtonDown`和`ButtonUp`函数来设置`buttonAction`为适当的值。这些甚至可以从*公共*更改为*私有*以进一步封装。
- en: 'Save the script. Then in Unity:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。然后在Unity中：
- en: Select **MeMyselfEye** object in Hierarchy
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择**MeMyselfEye**对象
- en: Find the My Input Action Data object in your `ScriptableObjects` folder
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`ScriptableObjects`文件夹中找到My Input Action Data对象
- en: 'Drag it onto the My Input slot of the My Input Controller (Script) component,
    as shown here for my Steam version of `MeMyselfEye`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖放到My Input Controller (Script)组件的My Input槽中，如下所示，这是我Steam版本的`MeMyselfEye`：
- en: '![](img/15e864f6-a58f-4dbf-8412-4b55731d4b69.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15e864f6-a58f-4dbf-8412-4b55731d4b69.png)'
- en: Accessing the input action object
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问输入动作对象
- en: Now the `BalloonController` can access the input data object rather than `MeMyselfEye`.
    Otherwise is very similar and a simple refactor. Modify `BalloonController.cs`
    as follows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`BalloonController`可以访问输入数据对象，而不是`MeMyselfEye`。否则非常相似，只是一个简单的重构。按照以下方式修改`BalloonController.cs`。
- en: First, we can remove any references to `MeMyselfEye` in the `BalloonController`,
    including the public variable and the entire `Start()` function (we do not need
    the `GetComponent<MyInputController>`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以从`BalloonController`中移除对`MeMyselfEye`的所有引用，包括公共变量和整个`Start()`函数（我们不需要`GetComponent<MyInputController>`）。
- en: 'Add a variable for the input data object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为输入数据对象添加一个变量：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And reference it in the `Update` conditions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`Update`条件中引用它：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save the script. Then in Unity, as we did previously for `MyInputController`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。然后在Unity中，就像我们之前对`MyInputController`所做的那样：
- en: Select the BalloonController object in Hierarchy
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择BalloonController对象
- en: Find the My Input Action Data object in your `ScriptableObjects` folder
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`ScriptableObjects`文件夹中找到My Input Action Data对象
- en: Drag it onto the My Input slot of the Balloon Controller component
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖放到Balloon Controller组件的My Input槽中
- en: Press **Play**. The app should work just like before. Press the button to create
    a balloon, hold the button to inflate it, and release the button to release the
    balloon.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按**播放**。应用应该和之前一样工作。按按钮创建气球，按住按钮使其膨胀，释放按钮释放气球。
- en: Simulation testing with scriptable objects
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可脚本化对象进行模拟测试
- en: 'An interesting advantage of this architecture is how it facilitates testing.
    Having completely decoupled our application objects from the input device, we
    can simulate input actions without actually using physical input controllers.
    For example, try this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的一个有趣的优势是它如何促进测试。由于我们的应用程序对象与输入设备完全解耦，我们可以模拟输入动作而不实际使用物理输入控制器。例如，尝试这样做：
- en: Select MeMyselfEye in Hierarchy. Then in Inspector, temporarily disable the
    **My Input Controller** component by unchecking its checkbox.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择MeMyselfEye。然后在检查器中，通过取消选中复选框暂时禁用**My Input Controller**组件。
- en: Select the My Input Action Data object in the Project `ScriptableObjects/` folder
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目`ScriptableObjects/`文件夹中选择My Input Action Data对象
- en: Press **Play.**
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**Play**。
- en: While the game is running, in Inspector, change the Button Action from None
    to PressedDown.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当游戏运行时，在检查器中，将按钮动作从None更改为PressedDown。
- en: The BalloonController thinks a PressedDown action has occurred. It creates a
    new balloon and begins inflating it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BalloonController认为发生了PressedDown动作。它创建了一个新的气球并开始充气。
- en: In Inspector, change the Input Action to PressedUp.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将输入动作更改为PressedUp。
- en: The BalloonController sees a **PressedUp** action has occurred and releases
    the current balloon.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BalloonController检测到发生了**PressedUp**动作，并释放了当前气球。
- en: When you're done testing, don't forget to re-enable the input controller component!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，别忘了重新启用输入控制器组件！
- en: This kind of manual setup of object states for development and testing can be
    very helpful, especially as your project grows and gets more complex.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这种为开发和测试手动设置对象状态的方法可以非常有帮助，尤其是在你的项目增长并变得更加复杂时。
- en: Using Unity events for input
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity事件进行输入
- en: The third software pattern we will explore using Unity Events. Events allow
    decoupling of the source of the event from the consumer of the event. Basically,
    events are a messaging system where one object triggers an event. Any other objects
    in the project can listen for the event. It can subscribe a specific function
    to be called when the event occurs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Unity事件探索的第三个软件模式。事件允许将事件源与事件消费者解耦。基本上，事件是一个消息系统，其中一个对象触发事件。项目中的任何其他对象都可以监听该事件。它可以为事件发生时调用的特定函数进行订阅。
- en: You can set this up using drag-and-drop via the Unity Inspector. Or you can
    subscribe listener functions in scripts. In this example, we will minimize the
    scripting involved, and use the Unity editor to subscribe to events.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Unity检查器使用拖放来设置此功能。或者你可以在脚本中订阅监听函数。在这个例子中，我们将最小化脚本的使用，并使用Unity编辑器来订阅事件。
- en: Events are a very rich topic and we can only introduce them here. For more information
    on using Unity Events, there are a lot of good references online, including the
    Unity tutorials [https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events) and [https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system](https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一个非常丰富的主题，我们只能在这里简要介绍。有关使用Unity事件的更多信息，网上有很多很好的参考资料，包括Unity教程[https://unity3d.com/learn/tutorials/topics/scripting/events](https://unity3d.com/learn/tutorials/topics/scripting/events)和[https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system](https://unity3d.com/learn/tutorials/topics/scripting/events-creating-simple-messaging-system)。
- en: 'The following diagram illustrates the relationship between our input controller,
    which invokes events, and the balloon controller, which subscribes to the events:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了我们的输入控制器（调用事件）和气球控制器（订阅事件）之间的关系：
- en: '![](img/b7ee0d95-05b4-4178-9d2a-f2c8f77d113f.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7ee0d95-05b4-4178-9d2a-f2c8f77d113f.jpg)'
- en: It's important to note that, unlike normal events, these events do not need
    to be unsubscribed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，与普通事件不同，这些事件不需要取消订阅。
- en: If you are a developer and familiar with .NET, it may help to know that Unity
    Events are delegates. As explained in the Unity Manual, "UnityEvents can be added
    to any MonoBehaviour and are executed from code like a standard .net delegate.
    When a UnityEvent is added to a MonoBehaviour it appears in the Inspector and
    persistent callbacks can be added."
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名开发者并且熟悉.NET，了解Unity事件是委托可能会有所帮助。正如Unity手册中解释的，“UnityEvents可以添加到任何MonoBehaviour中，并且可以从代码中以标准.NET委托的方式执行。当UnityEvent添加到MonoBehaviour时，它会在检查器中显示，并且可以添加持久回调。”
- en: Invoking our input action events
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用我们的输入动作事件
- en: To implement our example using events, we'll first have the `MyInputController`
    trigger events when a button is pressed and another event when the button is released.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用事件实现我们的示例，我们首先让`MyInputController`在按钮按下时触发一个事件，在按钮释放时触发另一个事件。
- en: First, at the top of the script we need to declare that we are using the Unity
    event API. The we declare the two UnityEvents we will invoke. The `Update()` function
    only needs to invoke one event or the other as they happen.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在脚本的顶部，我们需要声明我们正在使用Unity事件API。然后，我们声明将要调用的两个UnityEvents。`Update()`函数只需要在事件发生时调用其中一个事件即可。
- en: 'The entire `MyInputController.cs` is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`MyInputController.cs`如下所示：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it for this side of the equation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是等式这一边的全部内容。
- en: Subscribing to input events
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅输入事件
- en: Using events, `BalloonController` does not need to check for input actions each
    frame Update. All that conditional logic can be bypassed. Instead, we'll drag
    and drop the components to subscribe them to events. The `Update` function now
    only needs to grow the balloon if it's already instantiated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件，`BalloonController`不需要在每一帧更新时检查输入动作。所有这些条件逻辑都可以绕过。相反，我们将拖放组件以将它们订阅到事件。现在`Update`函数只需要在实例化后增长气球。
- en: 'The entire `BalloonController.cs` now looks like this. Aside from being less
    code, please note that we changed the `NewBalloon` and `ReleaseBalloon` functions
    from `private` to `public` so we can reference them in the Inspector:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`BalloonController.cs`现在看起来像这样。除了代码更少之外，请注意，我们将`NewBalloon`和`ReleaseBalloon`函数从`private`更改为`public`，这样我们就可以在检查器中引用它们：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To wire up the input events to our balloon controller:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入事件连接到我们的气球控制器：
- en: Select MeMyselfEye and look at its Inspector window
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MeMyselfEye并查看其检查器窗口
- en: You will see the My Input Controller component now has two event lists, as we
    declared in its script
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到My Input Controller组件现在有两个事件列表，正如我们在其脚本中声明的。
- en: On the Button Down Event list, press the + in the lower-right to create a new
    item.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮按下事件列表中，按右下角的+号创建一个新项目。
- en: Drag the BalloonController from Hierarchy into the empty Object slot
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BalloonController从层次结构拖到空对象槽中
- en: In the function select list, choose **BalloonController** | **NewBalloon**
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择列表中，选择**BalloonController** | **NewBalloon**
- en: 'Repeat the process for the Button Up Event as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重复执行以下按钮按下事件的流程：
- en: On the Button Up Event list, press the + in the lower-right to create a new
    item
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮按下事件列表中，按右下角的+号创建一个新项目
- en: Drag the BalloonController from Hierarchy into the empty Object slot
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BalloonController从层次结构拖到空对象槽中
- en: In the function select list, choose **BalloonController** | **ReleaseBalloon**
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择列表中，选择**BalloonController** | **ReleaseBalloon**
- en: 'The component should now look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件应该看起来像这样：
- en: '![](img/58469bd5-2930-4ff0-9177-4f6d833f1acb.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58469bd5-2930-4ff0-9177-4f6d833f1acb.png)'
- en: Now when you press Play and press a button, the input controller invokes an
    event. The *NewBalloon* function is listening for these events and gets called.
    Likewise for the Button Up event.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你按下播放并按下一个按钮时，输入控制器会调用一个事件。*NewBalloon*函数正在监听这些事件并被调用。同样对于按钮抬起事件。
- en: This wiring can also be done entirely with scripting. We will not go into it
    here. As a developer, we more often are "users" of event systems set up by others.
    As your experience grows, you may find yourself implementing your own custom events.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此连接也可以完全通过脚本完成。我们在这里不会深入讨论。作为开发者，我们更经常是其他人设置的事件系统的“用户”。随着你的经验增长，你可能会发现自己正在实现自己的自定义事件。
- en: For another detailed example of using Unity Events for user interface, consider
    *Augmented Reality for Developers*, a Unity projects book from Packt Publishing
    co-authored by the author of this book, Jonathan Linowes, and Krystian Babilinski.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用Unity事件进行用户界面的另一个详细示例，请考虑由本书作者Jonathan Linowes和Krystian Babilinski合著的Packt
    Publishing出版的Unity项目书籍《Augmented Reality for Developers》。
- en: Really using your hands
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真正地使用你的双手
- en: The last couple of things we'll explore in the chapter involve getting your
    hands even more into virtual reality. In addition to buttons and touch pads, VR
    hand controllers can be tracked in 3D space along with your head. PC- and console-based
    VR, such as Rift, Vive, MR, and PSVR, are really very good at this, with full
    positionally tracked hand controllers for both left and right hands. Lower-end
    mobile VR, such as Daydream, has a single hand controller with limited tracking,
    but better than nothing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后几件事情涉及让你更深入地体验虚拟现实。除了按钮和触摸板之外，VR 手控制器可以与你的头部一起在 3D 空间中跟踪。基于 PC 和控制台的游戏，如
    Rift、Vive、MR 和 PSVR，在这方面做得非常好，为左右手提供了完全位置跟踪的手控制器。低端移动 VR，如 Daydream，有一个单手控制器，跟踪有限，但总比没有好。
- en: To start, we'll take advantage of positional tracking by simply parenting the
    balloon to your hand model. On VR, without actual positional tracking, like Daydream,
    the location of your hand controller is approximated by the SDK software, but
    useful enough.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将利用位置跟踪的优势，简单地将气球绑定到你的手模型上。在 VR 中，如果没有实际的位置跟踪，例如 Daydream，你的手控制器位置将由 SDK
    软件近似，但足够有用。
- en: Parenting balloons to your hand
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将气球绑定到手中
- en: Suppose when you press the button, rather than creating the new balloon at a
    fixed position in space, it spawns and grows from your hand position. One way
    to accomplish this is to make the balloon instance a child of your hand controller
    object.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当你按下按钮时，而不是在空间中的固定位置创建新的气球，它从你的手位置生成并生长。实现这一目标的一种方法是将气球实例作为你的手控制器对象的子对象。
- en: 'The BalloonController will need to know which hand pressed the button and parent
    the balloon to that controller object. Specifically, we''ll pass the hand Game
    Object to the `NewBalloon` function as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`BalloonController` 需要知道哪个手按下了按钮，并将气球绑定到该控制器对象。具体来说，我们将按如下方式将手游戏对象传递给 `NewBalloon`
    函数：'
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that in this function we added an extra test for (`balloon == null`), just
    to make sure we haven't called `NewBalloon` twice in a row without releasing the
    first one yet.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个函数中，我们添加了一个额外的测试 (`balloon == null`)，只是为了确保我们没有在未释放第一个气球的情况下连续两次调用 `NewBalloon`。
- en: Like before, we instantiate a new balloon from the prefab.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们从预制体实例化一个新的气球。
- en: Then, we set its parent to the `parentHand` object. This is comparable to dragging
    one object to become a child of another in the Hierarchy. The parent-child relationships
    between game objects are handled by the built-in *Transform* component so the
    API functions are on the transform.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将它的父对象设置为 `parentHand` 对象。这相当于在层次结构中将一个对象拖动以成为另一个对象的子对象。游戏对象之间的父子关系由内置的
    *Transform* 组件处理，因此 API 函数位于 transform 上。
- en: Lastly, we reset the local position of the balloon. If you recall, the prefab
    was positioned at (0, 1, 1) or something like that. As a child of the hand, we
    want it attached directly at the pivot point of the hand model. (Alternatively,
    you could offset the balloon origin to a different attachment point as needed.)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重置气球的局部位置。如果你还记得，预制体位于 (0, 1, 1) 或类似的位置。作为手的一个子对象，我们希望它直接连接到手模型的旋转中心点。（或者，根据需要，你可以将气球的原点偏移到不同的连接点。）
- en: Worth noting, there are variations of the *Instantiate* function that let you
    specify the parent and transforms all in one call. See [https://docs.unity3d.com/ScriptReference/Object.Instantiate.html](https://docs.unity3d.com/ScriptReference/Object.Instantiate.html) .
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Instantiate` 函数有几种变体，允许你在一次调用中指定父对象和变换。请参阅 [https://docs.unity3d.com/ScriptReference/Object.Instantiate.html](https://docs.unity3d.com/ScriptReference/Object.Instantiate.html)。
- en: 'Likewise, the `ReleaseBalloon` detaches the balloon from the hand before send
    it on its way, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`ReleaseBalloon` 在发送气球之前将其从手中分离，如下所示：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'How do we pass the hand game object to NewBalloon? Assuming your project is
    presently using the Unity Events we setup in the previous topic, it''s very easy. In
    Inspector we need to update the Button Down Event function, since it now requires
    the game object argument:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将手游戏对象传递给 `NewBalloon`？假设你的项目目前正在使用我们在上一主题中设置的 Unity 事件，这非常简单。在检查器中，我们需要更新“按钮按下事件”函数，因为它现在需要游戏对象参数：
- en: In Unity editor, select the MeMyselfEye object
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中，选择 MeMyselfEye 对象
- en: In the Button Down Event list, the function may now say something like `Missing
    BalloonController.NewBalloon`
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“按钮按下事件”列表中，函数现在可能显示类似 `Missing BalloonController.NewBalloon` 的内容。
- en: Select the function dropdown and choose BalloonController | NewBalloon(GameObject)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择函数下拉菜单，选择 BalloonController | NewBalloon(GameObject)
- en: Unfold the MeMyselfEye object in Hierarchy and look for the hand model, then
    drag it onto the empty Game Object slot
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中展开MeMyselfEye对象，寻找手模型，然后将它拖放到空的游戏对象槽中
- en: If you are using OpenVR, the hand will be called Controller (right)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用OpenVR，手将被称为Controller（右手）
- en: If you are using Daydream, the hand will be called GvrControllerPointer
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Daydream，手将被称为GvrControllerPointer
- en: Here is a screenshot of me generating a bunch of balloons flying "over" the
    Grand Canyon, fun!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我生成的一堆气球飞越大峡谷的截图，很有趣！
- en: '![](img/4a1140e8-35eb-42ae-b30f-556bc0639af3.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a1140e8-35eb-42ae-b30f-556bc0639af3.png)'
- en: Popping balloons
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 气球弹出
- en: To be honest, it's really hard to think about creating balloons without also
    wanting to pop them! For fun, let's do a quick implementation. You can come up
    with your own ideas how to improve on it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 说实话，很难想到创造气球而不想戳破它们！为了好玩，让我们快速实现一下。你可以想出自己的想法来改进它。
- en: 'The Unity physics engine can detect when two object collide. To do this, each
    object must have a *Collider* component attached. You can then have the collision
    trigger an event. And we can subscribe that event to make something else happen,
    like play an explosion effect. This gets set up on the balloon prefab. So when
    two balloons collide, they''ll explode. Let''s do that:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Unity物理引擎可以检测两个对象何时发生碰撞。为此，每个对象都必须附加一个*碰撞器*组件。然后你可以让碰撞触发一个事件。我们可以订阅该事件，使其执行其他操作，例如播放爆炸效果。这将在气球预制体上设置。所以当两个气球相撞时，它们会爆炸。让我们这样做：
- en: Drag a copy of your Balloon prefab from Project `Assets prefabs` folder into
    the scene Hierarchy**.**
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的气球预制体的副本从项目`Assets prefabs`文件夹拖动到场景层次结构中**。**
- en: Select Add Component | Physics | Sphere Collider.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加组件 | 物理 | 球形碰撞器。
- en: To scale and center the collider into position, click the Edit Collider icon
    in its component.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要缩放并定位碰撞器，请在其组件中点击编辑碰撞器图标。
- en: In the **Scene** window, the green collider outline has small anchor points
    you can click to edit. Note that the *Alt* key pins the center position and *Shift*
    locks the scale ratio.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**场景**窗口中，绿色的碰撞器轮廓上有你可以点击来编辑的小锚点。注意，按住*Alt*键可以固定中心位置，而*Shift*键可以锁定缩放比例。
- en: Or, you can edit the **Center** and Radius values directly. I like Radius 0.25
    and Center (0, 0.25, 0) on my balloon.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你可以直接编辑**中心**和半径值。我喜欢我的气球使用半径0.25和中心(0, 0.25, 0)。
- en: Now, we will add a script to handle the collision events.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个脚本来处理碰撞事件。
- en: Add Component to create a new C# script,
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件以创建一个新的C#脚本，
- en: Name it `Poppable`
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`Poppable`
- en: And open it for editing
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并打开它进行编辑
- en: 'The `Poppable` script will provide a callback function for `OnCollisionEnter`
    events. When another object with a collider enters this object''s collider, our
    function will get called. At that point, we''ll call `PopBalloon` which instantiates
    the explosion and destroys the balloon:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Poppable`脚本将为`OnCollisionEnter`事件提供一个回调函数。当另一个具有碰撞器的对象进入这个对象的碰撞器时，我们的函数将被调用。在那个时刻，我们将调用`PopBalloon`来实例化爆炸并销毁气球：'
- en: '[PRE22]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that the `OnCollisionEnter` gets a `Collision` argument with information
    including what game object collided with it. We will ignore this here but you
    might explore it more: [https://docs.unity3d.com/ScriptReference/Collision.html](https://docs.unity3d.com/ScriptReference/Collision.html).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`OnCollisionEnter`接收一个包含碰撞信息的`Collision`参数，包括与之碰撞的游戏对象。我们在这里将忽略它，但你可能想进一步探索它：[https://docs.unity3d.com/ScriptReference/Collision.html](https://docs.unity3d.com/ScriptReference/Collision.html)。
- en: 'Save the script. Now, back in Unity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。现在，回到Unity中：
- en: Select a particle system prefab from **Project** Assets, such as `Assets/Standard
    Assets/ParticleSystems/Prefabs/Explosion` (this is the one we used to kill Ethan
    in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml), *Gaze-Based Control*)
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**资源中选择一个粒子系统预制体，例如`Assets/Standard Assets/ParticleSystems/Prefabs/Explosion`（这是我们用来在[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)，*基于注视的控制*中杀死伊森的预制体）
- en: Drag the effects prefab onto the Poppable's `Pop Effect` slot
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将效果预制体拖放到Poppable的`Pop Effect`槽中
- en: Save these changes back to the prefab by pressing Apply
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按Apply保存这些更改到预制体
- en: You can now delete the **Balloon** from the Hierarchy
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以从层次结构中删除**气球**
- en: Alright, let's try it. Press Play. Create a balloon. Then, reach out and push
    the button again so a new balloon collides with that one. Does it explode? Yikes!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们试试。按Play。创建一个气球。然后，伸手再次按下按钮，让一个新的气球与它相撞。它会爆炸吗？哎呀！
- en: Interactable items
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可交互物品
- en: Directly interacting with objects in VR, such as grabbing items and using them
    to perform other actions, is a bit more complex. And, it can be tricky to get
    right. So it doesn't make sense, especially in this book, to grow our own interaction
    system. Unfortunately, there is not a single standard toolkit either. But, there
    are more than a few very good toolkits you can use, albeit most are specific to
    individual target platforms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在VR中与对象交互，例如抓取物品并使用它们执行其他操作，要复杂一些。而且，正确做到这一点可能有点棘手。所以，特别是在这本书中，自己构建交互系统是没有意义的。不幸的是，也没有一个单一的标准化工具包。但是，有超过几个非常好的工具包可以使用，尽管大多数都是针对特定目标平台的。
- en: 'Generally, the architecture is similar among these solutions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些解决方案的架构是相似的：
- en: Provides prefabs for the player camera rig
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供玩家相机装置的预制件
- en: Camera rig includes objects for your hands, including input controller components
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机装置包括用于您手部的对象，包括输入控制器组件
- en: Hand objects include components that trigger events when interactions occur
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手对象包括在交互发生时触发事件的组件
- en: An interactable component is added to any objects in the scene that can be interacted
    with using input events
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可以交互的对象都会添加一个交互组件，使用输入事件进行交互
- en: Additional components and options extend the interactable behaviors
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外组件和选项扩展了可交互行为
- en: Toolkits will include a number of demo scenes which provide rich examples how
    to use the particular toolkit. Often, it is more informative to study the demos
    to see how to use the toolkits than the actual documentation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包将包括一些演示场景，提供丰富的示例，说明如何使用特定的工具包。通常，研究演示比实际文档更有信息量。
- en: In this section, we introduce a grabbing and throwing mechanic using two toolkits,
    the *SteamVR InteractionSystem* and the *Daydream VR Elements*. The technique
    is similar for other platforms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一种使用两个工具包（*SteamVR InteractionSystem*和*Daydream VR Elements*）的抓取和投掷机制。对于其他平台，技术是类似的。
- en: For Oculus SDK (without OpenVR), you will need to integrate the Oculus Avatar
    SDK (see [Chapter 12](721ca227-9208-4342-b6ac-a12799adbb2b.xhtml), *Social VR
    Metaverse*, for details on Oculus Avatars). Also, here's a quick video showing
    how to add an `OVR Grabber` component to your `OVRCameraRig` controllers: [https://www.youtube.com/watch?v=sxvKGVDmYfY](https://www.youtube.com/watch?v=sxvKGVDmYfY).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Oculus SDK（无OpenVR），您需要集成Oculus Avatar SDK（有关Oculus Avatars的详细信息，请参阅第12章，*Social
    VR Metaverse*），这里还有一个快速视频，展示如何将`OVR Grabber`组件添加到您的`OVRCameraRig`控制器中：[https://www.youtube.com/watch?v=sxvKGVDmYfY](https://www.youtube.com/watch?v=sxvKGVDmYfY)。
- en: Interactables using SteamVR Interaction System
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SteamVR Interaction System进行交互
- en: The SteamVR Unity package includes an Interaction System, originally developed
    and used for minigames and scenes from Steam's impressive demo VR application,
    *The Lab* ([http://store.steampowered.com/app/450390/The_Lab/](http://store.steampowered.com/app/450390/The_Lab/)).
    It can be found in the `Assets/SteamVR/InteractionSystem/` folder. We recommend
    you explore the example scenes, prefabs, and scripts.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: SteamVR Unity包包括一个交互系统，最初是为Steam令人印象深刻的演示VR应用程序*The Lab*（[http://store.steampowered.com/app/450390/The_Lab/](http://store.steampowered.com/app/450390/The_Lab/)）中的迷你游戏和场景开发的。它可以在`Assets/SteamVR/InteractionSystem/`文件夹中找到。我们建议您探索示例场景、预制件和脚本。
- en: 'The Interaction System includes its own Player camera rig which replaces the
    default [CameraRig] we have been using. The Player hierarchy is shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 交互系统包括它自己的玩家相机装置，它替换了我们一直在使用的默认[CameraRig]。玩家层次结构如下所示：
- en: '![](img/eee0c315-01b3-405a-9a23-6b36fb920243.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eee0c315-01b3-405a-9a23-6b36fb920243.png)'
- en: It includes a *VRCamera*, two hands (*Hand1* and *Hand2*), and other useful
    objects. Each hand includes an attach point (*Attach_ControllerTip*), a hover
    highlight (*ControllerHoverHighlight*), and a tooltips object (*ControllerButtonHints*).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个*VRCamera*，两个手（*Hand1*和*Hand2*），以及其他有用的对象。每个手都包括一个附加点（*Attach_ControllerTip*），一个悬停高亮（*ControllerHoverHighlight*），以及一个工具提示对象（*ControllerButtonHints*）。
- en: Locate the **Player** prefab in `SteamVR/InteractionSystem/Core/Prefabs `and
    drag it as a child of MyMyselfEye in your scene Hierarchy
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SteamVR/InteractionSystem/Core/Prefabs `中定位**Player**预制件，并将其拖动到场景层次结构中的MyMyselfEye作为子对象
- en: Delete or disable the [CameraRig] object
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或禁用[CameraRig]对象
- en: 'For compatibility with the current scene, we also need to update the **NewBalloon**
    argument in **Button Down Event**:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与当前场景兼容，我们还需要更新**Button Down Event**中的**NewBalloon**参数：
- en: Unfold the Player object in Hierarchy so you can see the Hand1 and Hand2 objects
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中展开玩家对象，以便您可以看到Hand1和Hand2对象
- en: Select the MeMyselfEye in Hierarchy
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择MeMyselfEye
- en: Drag Hand2 (or Hand1) from **Hierarchy** onto the GameObject argument slot in
    the Button Down Event on the My Input Controller component
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hand2（或 Hand1）从 **层次结构** 拖动到 My Input Controller 组件的 Button Down Event 中的
    GameObject 参数槽。
- en: Next, for interactable objects there is a large collection of components available.
    Review the `SteamVR/InteractionSystem/Core/Scripts` folder contents. We will use
    the *Throwable* one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于交互式对象，有一大堆组件可供选择。查看 `SteamVR/InteractionSystem/Core/Scripts` 文件夹的内容。我们将使用
    *可投掷* 的一个。
- en: 'First, lets try this on a basic Cube. Then, we''ll make the balloons grabbable
    and throwable too:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在一个基本的立方体上尝试这个操作。然后，我们将使气球可抓取并可投掷：
- en: In Hierarchy, create a cube (Create | 3D Object | Cube).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个立方体（创建 | 3D 对象 | 立方体）。
- en: Scale and position it within reaching distance of the Player. For example, Scale
    (0.3, 0.3, 0.3) and **Position** (-0.25, 1.3, -0.25) may work.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家可触及的距离内调整其大小和位置。例如，大小 (0.3, 0.3, 0.3) 和 **位置** (-0.25, 1.3, -0.25) 可能适用。
- en: With the Cube selected, Add Component `Throwable` from the Interaction System.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择立方体，从交互系统添加 `Throwable` 组件。
- en: Notice this will automatically add other required components, including the
    base Interactable and a RigidBody.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这将自动添加其他所需组件，包括基本交互式对象和刚体。
- en: On the RigidBody component, uncheck the Use Gravity checkbox, so it hangs in
    the air rather than falling to the ground when you play.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在刚体组件上，取消选中使用重力复选框，这样它就会悬挂在空中而不是掉到地上。
- en: Now when you press Play, reach out to the Cube so your controller penetrates
    (collides) it. Then, using the Trigger on your controller, grab the Cube and throw
    it *outta here*!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您按下播放时，伸手到立方体上，以便您的控制器穿透（碰撞）它。然后，使用控制器上的扳机，抓住立方体并将其扔出去！
- en: 'To make the balloons throwable, we modify the prefab:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使气球可投掷，我们修改预制件：
- en: Drag a copy of the Balloon prefab from the Project window into the scene Hierarchy
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目窗口中将气球预制件的副本拖动到场景层次结构中。
- en: Add Component the Steam Throwable
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件 Steam Throwable。
- en: Press **Apply** to save the prefab
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **应用** 保存预制件。
- en: And delete the Balloon from the Hierarchy
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并从层次结构中删除气球。
- en: Press Play. Press the Fire1 button to create and inflate a balloon. Release
    it. Then, grab it with the trigger. Throw the balloon. If you implemented the
    *Poppable* explosion earlier, it'll even explode like a projectile when it hits
    something, like the ground or the photo plane!
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 按 Play。按 Fire1 按钮创建并充气一个气球。释放它。然后，用扳机抓住它。投掷气球。如果您之前实现了 *可爆裂* 爆炸，当它撞击到某个物体时，它甚至像投射物一样爆炸，比如地面或照片平面！
- en: Interactables using Daydream VR Elements
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Daydream VR 元素进行交互。
- en: 'The base GoogleVR package does not include interactables, but you can find
    them in the Daydream Elements package. This package is a collection of demo scenes,
    components, and prefabs for using Daydream VR from the engineers at Google. To
    get the package:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 GoogleVR 包不包含交互式对象，但您可以在 Daydream Elements 包中找到它们。这个包是谷歌工程师用于使用 Daydream
    VR 的示例场景、组件和预制件的集合。要获取该包：
- en: Visit the Daydream Elements' Github Releases page at [https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 Daydream Elements 的 Github 发布页面 [https://github.com/googlevr/daydream-elements/releases](https://github.com/googlevr/daydream-elements/releases)。
- en: Download `DaydreamElements.unitypackage`
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `DaydreamElements.unitypackage`。
- en: Import it into your project using **Assets** | **Import Package** | **Custom
    Package...**
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **资产** | **导入包** | **自定义包...** 将其导入到您的项目中。
- en: 'The package includes a prefab named `ObjectManipulationPointer` which is a
    drop-in replacement for the `GvrControllerPointer` we have been using:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含一个名为 `ObjectManipulationPointer` 的预制件，它是我们一直在使用的 `GvrControllerPointer`
    的直接替代品：
- en: In Hierarchy, unfold your MeMyselfEye and drill down to the Player object
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，展开 MeMyselfEye 并钻到 Player 对象。
- en: Select GvrControllerPointer and disable it in Inspector
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 GvrControllerPointer 并在检查器中禁用它。
- en: In the Project window, navigate to the `Assets/DaydreamElements/Elements/ObjectManipulationDemo/Prefabs/UI/`
    folder
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，导航到 `Assets/DaydreamElements/Elements/ObjectManipulationDemo/Prefabs/UI/`
    文件夹。
- en: Drag the ObjectManipulationPointer prefab into Hierarchy as a sibling of GvrControllerPointer
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ObjectManipulationPointer 预制件拖动到层次结构中，作为 GvrControllerPointer 的同级。
- en: 'For compatibility with the current scene, we also need to update the NewBalloon argument
    in Button Down Event:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与当前场景兼容，我们还需要更新 Button Down Event 中的 NewBalloon 参数。
- en: Select the MeMyselfEye in Hierarchy
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 MeMyselfEye。
- en: Drag ObjectManipulationPointer from Hierarchy onto the GameObject argument slot
    in the Button Down Event on the My Input Controller component
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ObjectManipulationPointer从层级拖到My Input Controller组件的“按钮按下事件”中的GameObject参数槽。
- en: Next, for interactable objects we add a `MoveablePhysicsObject` component, found
    in `Assets/DaydreamElements/Elements/ObjectManipulationDemo/Scripts/`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于交互式对象，我们在`Assets/DaydreamElements/Elements/ObjectManipulationDemo/Scripts/`中添加一个`MoveablePhysicsObject`组件。
- en: Additional information on Daydream Elements object manipulation can be found
    at [https://developers.google.com/vr/elements/object-manipulation](https://developers.google.com/vr/elements/object-manipulation).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developers.google.com/vr/elements/object-manipulation](https://developers.google.com/vr/elements/object-manipulation)可以找到关于Daydream
    Elements对象操作的相关附加信息。
- en: 'First, lets try this on a basic Cube. Then, we''ll make the balloons grabbable
    and throwable too:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在一个基本的立方体上尝试这个。然后，我们将使气球可抓取和可投掷：
- en: In Hierarchy, create a cube (Create | 3D Object | Cube).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中创建一个立方体（创建 | 3D对象 | 立方体）。
- en: Scale and position it within reaching distance of the Player. For example, Scale (0.25,
    0.25, 0.25) and Position (-0.4, 0.75, -0.3) may work.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家可触及的距离内调整其大小和位置。例如，缩放（0.25，0.25，0.25）和位置（-0.4，0.75，-0.3）可能适用。
- en: With the Cube selected, Add Component `MoveablePhysicsObject`.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择立方体后，添加组件`MoveablePhysicsObject`。
- en: Notice this will automatically add a `RigidBody` component if not present.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，如果不存在，这将自动添加一个`RigidBody`组件。
- en: On the `RigidBody` component, uncheck the Use Gravity checkbox, so it hangs
    in the air rather than falling to the ground when you play.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RigidBody`组件上，取消选中“使用重力”复选框，这样它就会悬挂在空中，而不是在播放时掉到地上。
- en: Now when you press Play, use your controller so its laser beam hits the cube.
    Then, press the clicker button on your controller to grab it. Move it around and
    press again to release it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你按“播放”时，使用你的控制器，使其激光束击中立方体。然后，按控制器上的点击按钮来抓住它。移动它，然后再次按下来释放它。
- en: Since the app is presently using the same button to create new balloons and
    manipulate the laser pointer, we get a balloon each time we use the button. Consider
    that a bug in your application. We will leave this as an exercise for you to implement
    the logic, for example, to tell *MyInputController* to not invoke events if the
    *MoveablePhysicsObject* is busy moving something.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序目前使用相同的按钮来创建新的气球和操作激光指针，因此每次我们使用按钮时都会得到一个气球。请考虑这是你应用程序中的一个错误。我们将把这个逻辑实现留给你自己去完成，例如，告诉*MyInputController*如果*MoveablePhysicsObject*正在移动某个对象，则不要调用事件。
- en: 'Hint: you could add a script component to Cube that checks the MoveablePhysicsObject
    state and disables MyInputController actions when the object is Selected. This
    is not well documented but look at the source code for MoveablePhysicsObjects.cs
    and its base class, BaseInteractiveObjects.cs.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以在Cube上添加一个脚本组件，该组件检查MoveablePhysicsObject状态，并在对象被选中时禁用MyInputController动作。这没有很好地记录，但请查看MoveablePhysicsObjects.cs及其基类BaseInteractiveObjects.cs的源代码。
- en: 'To make the balloons throwable, we modify the prefab:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要使气球可投掷，我们修改预制件：
- en: Drag a copy of the Balloon prefab from the Project window into the scene Hierarchy
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Balloon预制件的副本从项目窗口拖到场景的层级中。
- en: Add Componen**t** the MoveablePhysicsObject
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加组件**MoveablePhysicsObject**
- en: Click Apply to save the prefab
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“应用”以保存预制件
- en: And delete the Balloon from Hierarchy
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并从层级中删除气球
- en: Press Play. Press the button to create and inflate a balloon. Release it. Then,
    try to grab it with the laser pointer. If you implemented the *Poppable* explosion
    earlier, it'll even explode like a projectile when it hits something!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按“播放”。按按钮创建并充气气球。释放它。然后，尝试用激光指针抓住它。如果你之前实现了*Poppable*爆炸，当它撞击到某物时，它甚至会像投射物一样爆炸！
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored a variety of software patterns for handling user
    input for your VR projects. The player uses a controller button to create, inflate,
    and release balloons into the scene. First, we tried the standard Input class
    for detecting logical button clicks, like the "Fire1" button, and then learned
    how to access device-specific SDK input, such as the OpenVR trigger button with
    haptic feedback.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了处理VR项目用户输入的各种软件模式。玩家使用控制器按钮在场景中创建、充气和释放气球。首先，我们尝试使用标准Input类来检测逻辑按钮点击，例如“Fire1”按钮，然后学习了如何访问特定于设备的SDK输入，例如具有触觉反馈的OpenVR扳机按钮。
- en: In our scene, we implemented a simple input component for polling the button
    actions. Then, we refactored the code to use scriptable objects to hold the input
    action data. In the third implementation, we used Unity Events to message input
    actions to listening components. We also enhanced the scene to attach the balloon
    to your virtual hand position, and added the ability to pop the balloons as  explosive
    projectiles! Lastly, we used an interactable framework (for SteamVR and Daydream)
    to implement grabbing and throwing mechanics, using components provided in given
    toolkits rather than attempting to write our own.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，我们实现了一个简单的输入组件来轮询按钮动作。然后，我们对代码进行了重构，使用可脚本化的对象来存储输入动作数据。在第三次实现中，我们使用了Unity事件将输入动作消息传递给监听组件。我们还增强了场景，将气球附着到你的虚拟手部位置，并添加了弹出气球作为爆炸性投射物的能力！最后，我们使用了一个交互框架（用于SteamVR和Daydream）来实现抓取和投掷机制，使用给定工具包中提供的组件，而不是尝试编写自己的代码。
- en: In the next chapter, we will further explore user interactions, using the Unity
    UI (user interface) system for implementing information canvases, buttons, and
    other UI controls.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步探讨用户交互，使用Unity UI（用户界面）系统来实现信息画布、按钮和其他UI控件。
