- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Dealing with Brownfield Projects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理棕色地带项目
- en: I cringe whenever I hear **brownfield project**, and probably you do too. Design
    decisions are already taken, code is already written by previous developers, and
    code quality varies between one class and another; brownfields are not for the
    faint-hearted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我听到**棕色地带项目**这个词时，我都会感到不舒服，可能你也是。设计决策已经做出，代码已经被前开发人员编写，代码质量在一类和另一类之间有所不同；棕色地带不是胆小鬼的领域。
- en: As there could be multiple definitions for the term brownfield, I want to start
    by defining it here, so we are all on the same page. From this book’s perspective,
    a brownfield project is a project not covered by unit tests and was probably written
    a while ago. It might have been covered by other types of tests than unit tests,
    but we will still refer to it as a brownfield. Some techies also refer to it as
    a **legacy project**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“棕色地带”这个术语可能有多个定义，我想先在这里定义它，以便我们都在同一页上。从本书的角度来看，棕色地带项目是一个没有单元测试覆盖且可能已经编写了一段时间的项目。它可能被其他类型的测试而不是单元测试所覆盖，但我们将仍然称其为棕色地带。一些技术人员也将其称为**遗留项目**。
- en: As you have already figured out, we have dedicated a whole chapter to brownfields
    as there are challenges in introducing TDD or unit testing to such projects. We
    will discuss those challenges and how to overcome them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所已发现的，我们专门用了一整章来讨论棕色地带，因为将TDD或单元测试引入这样的项目存在挑战。我们将讨论这些挑战以及如何克服它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Analyzing the challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析挑战
- en: The strategy for enabling TDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用TDD的策略
- en: Refactoring for unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单元测试进行重构
- en: By the end of this chapter, you will better understand what you need to look
    for when enabling unit testing for your project. You will also get an insight
    into required code changes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更好地了解在为你的项目启用单元测试时需要寻找什么。你还将对所需的代码更改有所了解。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found at the following GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12)'
- en: Analyzing the challenges
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析挑战
- en: 'In the previous chapters, we’ve been talking about adding new features while
    starting from the unit tests end (testing first). We relied on having a new functionality
    or modifying an existing functionality that is already covered by existing unit
    tests. This is not the case for brownfields as, when trying to apply TDD, you
    will face some of these challenges:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们一直在谈论从单元测试端开始添加新功能（先测试后开发）。我们依赖于有一个新的功能或修改一个已经由现有单元测试覆盖的功能。对于棕色地带（brownfields）来说，情况并非如此，因为当你尝试应用TDD时，你将面临以下挑战：
- en: '**Dependency injection support**: Some legacy frameworks do not natively support
    DI, which is necessary for unit tests.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入支持**：一些遗留框架没有原生支持依赖注入（DI），这对于单元测试是必要的。'
- en: '**Code modification challenges**: Changes to code that are not covered by tests
    (of any type) can introduce new bugs.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码修改挑战**：未覆盖的测试（任何类型的测试）的代码更改可能会引入新的错误。'
- en: '**Time and effort challenges**: Introducing the ability to unit test the code
    requires time and effort.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间和精力挑战**：引入代码的单元测试能力需要时间和精力。'
- en: Let’s go through each challenge in detail, so you can consider them when the
    time comes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地逐一分析每个挑战，以便你在需要时考虑它们。
- en: Dependency injection support
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入支持
- en: In this book, before learning about unit testing or TDD, we had to introduce
    DI. DI is what allows you to separate your code into units/components; it is a
    natural requirement for unit testing. There are two challenges in enabling DI
    – framework support and refactoring work. Let’s dig deeper.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，在学习单元测试或TDD之前，我们不得不介绍依赖注入（DI）。依赖注入（DI）是允许你将代码分割成单元/组件的工具；它是单元测试的自然要求。在启用依赖注入（DI）时有两个挑战——框架支持和重构工作。让我们深入了解。
- en: Framework support for DI
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入的框架支持
- en: This is a .NET book, so we are only interested in legacy .NET frameworks that
    do not support DI natively. In the early 2000s, while unit testing was becoming
    a trend, Microsoft was more interested in migrating developers from **Visual Basic
    6** (**VB6**) and **Active Server Pages** (**ASP**), thus enabling native DI in
    the early days of .NET was not on the priority list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本.NET书籍，所以我们只对不支持原生依赖注入的遗留.NET框架感兴趣。在2000年代初，当单元测试成为一种趋势时，微软更感兴趣的是将开发者从**Visual
    Basic 6**（**VB6**）和**Active Server Pages**（**ASP**）迁移过来，因此，在.NET的早期阶段实现原生依赖注入并不是优先事项。
- en: Therefore, Win Forms and ASP.NET Web Forms were born with no native DI support.
    Surely, you can hack the framework and add some support for DI. Still, when you
    start shifting from the norms of a framework, you alienate other developers working
    on the code base and introduce subtle bugs and complexity to the design.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Win Forms和ASP.NET Web Forms在没有原生依赖注入支持的情况下诞生。当然，你可以通过修改框架来添加一些依赖注入的支持。然而，当你开始偏离框架的规范时，你会使其他在代码库上工作的开发者感到疏远，并给设计引入微妙的错误和复杂性。
- en: More modern frameworks, such as WPF, and ASP.NET MVC from the classical .NET
    Framework allowed dependency injection through third-party DI containers. Today,
    with ASP.NET Core, DI is natively supported using Microsoft-built DI containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更现代的框架，如WPF和来自经典.NET Framework的ASP.NET MVC，允许通过第三方依赖注入容器进行依赖注入。如今，随着ASP.NET
    Core的推出，依赖注入通过微软构建的依赖注入容器原生支持。
- en: If you have a project that is built on a legacy framework with no native support
    for DI, such as Win Forms and ASP.NET Web Forms, I would say the effort put into
    bending these frameworks to enable unit testing needs to be weighed against the
    benefits of having unit tests. Maybe you can invest this effort in applying other
    types of testing to the project instead. Obviously, migrating the project into
    a modern framework solves this problem, but that has its own challenges as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个基于没有原生支持依赖注入的遗留框架（如Win Forms和ASP.NET Web Forms）的项目，我会说，将这些框架弯曲以实现单元测试的努力需要权衡拥有单元测试的好处。也许你可以将这项努力投入到应用其他类型的测试到项目中。显然，将项目迁移到现代框架可以解决这个问题，但这也有其自身的挑战。
- en: If the framework supports DI natively or can support DI with little effort,
    then you are in luck, but is that all? Clearly, now you have to refactor everything
    to enable DI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果框架原生支持依赖注入或可以轻松支持依赖注入，那么你很幸运，但这就是全部吗？显然，现在你必须重构所有内容以启用依赖注入。
- en: Refactoring for DI support
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持依赖注入的重构
- en: We dedicated [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037)*, Understanding
    Dependency Injection by Example,* to discussing DI, so we will not go into details
    here. What we need to do when we plan to introduce unit tests or TDD is to make
    sure we are using DI to inject components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在**第2章**[理解依赖注入的示例](B18370_02.xhtml#_idTextAnchor037)中专门讨论了依赖注入，因此在这里我们不会深入探讨。当我们计划引入单元测试或TDD时，我们需要确保我们正在使用依赖注入来注入组件。
- en: 'Ideally, all your components need to be injected through constructor injection,
    and instantiating a variable should not be done in the method or property code.
    With that said, consider the following unwelcome code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有组件都需要通过构造函数注入进行注入，变量实例化不应在方法或属性代码中完成。话虽如此，考虑以下不受欢迎的代码：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you have code that is not unit tested, you’ll probably find that all the
    components are instantiated in the code, and no DI container is used. In this
    case, you will have to go through the cases of direct instantiation and modify
    them to support DI. We will see an example of this at the end of this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有未进行单元测试的代码时，你可能会发现所有组件都在代码中直接实例化，并且没有使用依赖注入容器。在这种情况下，你必须遍历直接实例化的案例，并将它们修改以支持依赖注入。我们将在本章末尾看到一个这样的例子。
- en: 'Not all cases of direct instantiation will require you to refactor them for
    DI. Some cases are part of a standard library that you could unit test, but you
    shouldn’t. Take this line as an example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有直接实例化的案例都需要你为依赖注入进行重构。有些案例是标准库的一部分，你可以对其进行单元测试，但你不应该这样做。以下是一个例子：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we had no intention of injecting the `UriBuilder` class, so
    you might not need to change the code because the class is not relying on an external
    dependency. Accordingly, injecting the class is not beneficial, but actually,
    it adds a bit of unnecessary effort.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有打算注入`UriBuilder`类，所以你可能不需要更改代码，因为该类不依赖于外部依赖。因此，注入该类并不有益，反而增加了不必要的努力。
- en: In brief, to make the code unit testable, all the components need to be DI-ready.
    Depending on how big your project is and the way you want to implement it (such
    as iteratively), it will take time and effort.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，为了使代码可进行单元测试，所有组件都需要准备好依赖注入。根据你的项目大小以及你想要实现的方式（例如迭代），这将需要时间和努力。
- en: Introducing DI is not the only challenge; modifying the code will pose a new
    challenge as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 引入依赖注入不是唯一的挑战；修改代码也将带来新的挑战。
- en: Code modification challenges
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码修改挑战
- en: 'When you are adding non-unit tests to your project, you are working externally
    to the code and some of the activities can be as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中添加非单元测试时，你是在代码外部工作，以下是一些可能的活动：
- en: Testing the UI with an automation tool such as Selenium or Cypress. The tests
    will deal with the application like an external user.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Selenium或Cypress等自动化工具测试UI。测试将像外部用户一样处理应用程序。
- en: Doing integration testing by performing an end-to-end call, say on an API endpoint.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行端到端调用进行集成测试，例如在API端点上。
- en: Load testing a project by creating multiple instances of the application.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建应用程序的多个实例来对项目进行负载测试。
- en: Penetration testing by trying to hack into the application externally.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尝试从外部黑客攻击应用程序进行渗透测试。
- en: All these activities do not require changing the code, but unit testing requires
    the production code to be in a certain shape.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些活动都不需要更改代码，但单元测试要求生产代码处于某种形状。
- en: When changing the code to enable unit testing, we risk breaking it. Imagine
    having a bug that found its way to production and the irony of the business hearing
    *it broke because we added tests*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改代码以启用单元测试时，我们冒着破坏它的风险。想象一下，一个错误找到了进入生产环境的方法，而业务方听到“它坏了，因为我们增加了测试”，这真是讽刺。
- en: Important note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I would be lying if I said that you have to change the code for unit testing
    because you can use an isolation testing framework, which would allow you to unit
    test the code without changing it. However, this would be the last resort if you
    really want to unit test and you cannot change the code. We’ll discuss this further
    later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我说你为了单元测试而必须更改代码，那我就撒谎了，因为你可以使用隔离测试框架，这会让你能够在不更改代码的情况下进行单元测试。然而，如果你真的想进行单元测试而无法更改代码，这将是一个最后的手段。我们将在本章后面进一步讨论这个问题。
- en: There are solutions to change the code that will reduce the possibility of breaking,
    so follow along.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些解决方案可以更改代码，从而降低出错的可能性，所以请继续阅读。
- en: Time and effort challenges
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间和努力挑战
- en: The process of enabling dependency injection and refactoring the code into components
    that act as units is mentally challenging and time-consuming.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 启用依赖注入并将代码重构为作为单元操作的组件的过程在心理上具有挑战性且耗时。
- en: Think of approaching the process iteratively by dividing it into your sprints
    (or iterations, or whatever you call them) or by blocking some iterations and
    implementing your changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑通过将过程迭代地划分为你的sprint（或迭代，或你称之为什么）或通过阻塞一些迭代并实施你的更改来接近这个过程。
- en: The challenge here is to justify to the business the time spent in introducing
    unit testing and enabling TDD, as from their perspective, you still have the same
    product, the same number of bugs, and nothing is fixed, but you have just added
    tests. Obviously, you and I know that unit testing will guard the code against
    future bugs and add documentation, but the challenge is to convey this to the
    business. The next chapter is going to tackle dealing with the business when introducing
    TDD and unit testing, so I will stop here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战在于向业务方证明引入单元测试和启用TDD所花费的时间是合理的，因为从他们的角度来看，你们的产品还是一样的，同样的数量的问题，而且什么都没有修复，只是增加了测试。显然，我和你都知道单元测试可以保护代码免受未来错误的侵害并增加文档，但挑战在于将这一点传达给业务方。下一章将讨论在引入TDD和单元测试时如何处理业务问题，所以我在这里就先停下了。
- en: All these challenges have solutions; after all, we work in software! The next
    sections will address them with different strategies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些挑战都有解决方案；毕竟，我们在软件行业工作！接下来的几节将使用不同的策略来处理这些问题。
- en: The strategy of enabling TDD
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用TDD的策略
- en: 'Now is the time to discuss solutions to the challenges described in the previous
    section. Since *a picture is worth a thousand words*, I will present a workflow
    diagram that should clarify how to introduce unit testing into a brownfield project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论上一节中描述的挑战解决方案的时候了。由于“一张图片胜过千言万语”，我将展示一个工作流程图，以阐明如何将单元测试引入到一个棕色地带项目中：
- en: '![Figure 12.1 – The workflow of enabling TDD in a project ](img/Figure_12.1_B18370.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 在项目中启用TDD的工作流程](img/Figure_12.1_B18370.jpg)'
- en: Figure 12.1 – The workflow of enabling TDD in a project
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 在项目中启用 TDD 的工作流程
- en: Let’s go through the diagram and our options.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看图表和我们的选项。
- en: Consider rewriting
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑重写
- en: You might consider rewriting because the existing project might be based on
    an old framework with fewer developers and less support. However, the rewriting
    idea is controversial. If you tell the business that the project requires rewriting,
    you will be their least favorite individual. Trust me; nobody wants to hear this.
    However, good rewriting doesn’t need to be a big bang; it can be divided into
    smaller chunks of upgrades and can be appended to sprints. Obviously, choosing
    a modern framework that supports DI natively or through a third party is out of
    the question.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会考虑重写，因为现有项目可能基于一个较旧的框架，开发者较少，支持也较少。然而，重写想法是有争议的。如果你告诉业务该项目需要重写，你将成为他们最不喜欢的个人。相信我；没有人想听到这个。然而，好的重写不需要是一次性的大爆炸；它可以分成更小的升级块，并可以附加到冲刺中。显然，选择一个原生支持
    DI 或通过第三方支持的现代框架是不可能的。
- en: There are many ways to rewrite software, which are beyond the scope of this
    book. But if you are rewriting, you can start the new pieces with TDD, and the
    problem would be sorted!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重写软件有许多方法，这超出了本书的范围。但如果你正在重写，你可以从 TDD 开始新的部分，问题就会得到解决！
- en: Changing code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改代码
- en: In some settings, the code is too tangled to be changed, or sometimes the business
    doesn’t like the idea of changing the code for whatever reason. If you are facing
    one of these situations, then ask yourself whether it is worth adding unit tests
    or whether this effort should be put into other types of testing. Obviously, other
    types of tests will do good, although unit testing would even be more beneficial.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些设置中，代码过于复杂，难以修改，或者有时业务出于任何原因不喜欢修改代码。如果你面临这些情况之一，那么请自问是否值得添加单元测试，或者是否应该将这项工作投入到其他类型的测试中。显然，其他类型的测试也会有益，尽管单元测试会更有益。
- en: Unit testing can be done without DI; hence, you don’t need to change the code.
    Here you go, I let the secret out! But for this to work, you will have to use
    a **test isolation framework**. A test isolation framework makes some changes
    to the way components are loaded externally without touching the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以在没有 DI 的情况下进行；因此，你不需要更改代码。看这里，我已经泄露了这个秘密！但为了使其工作，你将不得不使用一个 **测试隔离框架**。测试隔离框架会对组件外部加载的方式做一些更改，而不触及代码。
- en: 'For example, consider this class:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个类：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice that the class does not implement an interface, and the `Products` property
    is not virtual. Let’s see how the **JustMock** **test isolation framework** by
    Telerik would unit test code related to this class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类没有实现接口，`Products` 属性也不是虚拟的。让我们看看 Telerik 的 **JustMock** **测试隔离框架**如何对这个类相关的代码进行单元测试：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this code block, we only care about the two highlighted lines. `Products`
    property on the `Warehouse` class, although the property is not virtual and the
    `warehouse` object is not instantiated with the help of the mock library.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们只关心两条被突出显示的行。`Warehouse` 类上的 `Products` 属性，尽管这个属性不是虚拟的，并且 `warehouse`
    对象没有通过模拟库实例化。
- en: JustMock did some magic here, it made the `Warehouse` class mockable, despite
    that `Warehouse` doesn’t have an interface and `Products` is not virtual. No DI
    was required!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: JustMock 在这里施展了一些魔法，它使 `Warehouse` 类可模拟，尽管 `Warehouse` 没有接口，`Products` 也不是虚拟的。不需要
    DI！
- en: However, the isolation framework’s magic is not liked by most TDD practitioners,
    as it leads to bad programming practices. Plus, these frameworks are not free.
    They definitely solve a problem when you want to avoid code changes, but they
    pose the question, is it worth the effort and the cost?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，隔离框架的魔法并不受大多数 TDD 实践者欢迎，因为它会导致不良的编程实践。此外，这些框架并非免费。当你想要避免代码更改时，它们确实解决了问题，但它们提出了一个问题：这是否值得付出努力和成本？
- en: Going through the hassle of having a dependency on a non-standard way of testing
    will require training, maintenance, and licensing costs, which should be weighed
    against utilizing any framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖非标准测试方式所带来的麻烦，将需要培训、维护和许可费用，这些成本应该与使用任何框架进行权衡。
- en: Native support for DI
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生支持 DI
- en: Some frameworks within .NET have no notion of DI – Win Forms and Web Forms are
    perfect examples. You can force them to support DI, but this means bending the
    framework and being on your own. Sometimes, you can try to isolate the UI layer
    and unit test what is underneath it. That is good enough in this case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架中的一些框架没有DI的概念——Win Forms和Web Forms是完美的例子。你可以强迫它们支持DI，但这意味着扭曲框架并独自承担。有时，你可以尝试隔离UI层并对下面的内容进行单元测试。在这种情况下，这已经足够好了。
- en: What I want to say is having a framework that doesn’t natively support plugging
    in a DI container or has one that is built in, such as ASP.NET Core, will cost
    you more effort and will shift you away from the norm.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我想说的是，拥有一个不原生支持插入DI容器或内置了DI容器（如ASP.NET Core）的框架将让你付出更多努力，并将你从规范中移开。
- en: I would avoid unit testing such frameworks and promote the quality by employing
    other testing categories.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我会避免对这样的框架进行单元测试，并通过采用其他测试类别来提高质量。
- en: Test coverage prior to unit test
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试之前的测试覆盖率
- en: Code changes will lead to bugs, but what about careful code changes? Well, yes,
    it will still lead to bugs! Bugs will come when you change code, no matter how
    careful you are. So, what is your bug hunting plan?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改会导致错误，但仔细的代码更改呢？嗯，是的，它仍然会导致错误！无论你多么小心，更改代码时都会出现错误。那么，你的错误查找计划是什么？
- en: If you plan to change the code for unit testing, your code should have high
    coverage at first by other types of tests, mainly automation and integration.
    These tests will help to point out where you’ve broken the code before it gets
    to production.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划为了单元测试而更改代码，你的代码应该首先通过其他类型的测试达到高覆盖率，主要是自动化和集成测试。这些测试将帮助你指出在代码进入生产之前你破坏了哪些地方。
- en: 'The logical question coming up is, if I have high coverage with other types
    of tests, why do I need unit tests? The answers are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着问题的出现，一个逻辑问题是，如果我已经有了其他类型测试的高覆盖率，为什么我还需要单元测试？以下是一些答案：
- en: If your project is still in development, then you will need unit tests. Also,
    preferably add new features in TDD style.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目仍在开发中，那么你需要单元测试。此外，最好以TDD风格添加新功能。
- en: You can change the balance of all the available tests to unit tests once your
    project can support them, as unit tests have advantages over other tests that
    we’ve discussed earlier in this book, in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的项目能够支持它们时，你可以将所有可用测试的平衡改变为单元测试，因为单元测试在我们这本书的[第4章](B18370_04.xhtml#_idTextAnchor097)“使用测试替身进行真实单元测试”中讨论的具有其他测试的优势。
- en: If your code is in maintenance mode and the coverage is already high, then I
    would argue that adding unit tests is not very useful. In this case, TDD would
    not be applicable as TDD is a companion of new features or features change.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码处于维护模式且覆盖率已经很高，那么我会说添加单元测试并不是非常有用。在这种情况下，TDD不适用，因为TDD是新功能或功能变更的伴侣。
- en: My advice is not to change the code if it is not covered by tests, as your valuable
    effort in advancing the project might be countered by production bugs. Maybe the
    effort should be put into other tests or rewriting.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，如果代码没有被测试覆盖，不要更改它，因为你在推进项目中的宝贵努力可能会被生产中的错误所抵消。也许应该将努力投入到其他测试或重写中。
- en: Every project is different and the strategies we have mentioned here are just
    points to consider. You should consider adding these to your train of thought
    when you plan the introduction of unit tests into a brownfield.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都是不同的，我们在这里提到的策略只是需要考虑的点。当你计划将单元测试引入棕色地带时，你应该考虑将这些点加入你的思考过程中。
- en: Next, we will see samples of changing legacy code to allow unit testing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到将遗留代码更改为允许单元测试的示例。
- en: Refactoring for unit testing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元测试进行重构
- en: When you write in TDD, your code is unit testable from the first moment. This
    is because you took into consideration DI scenarios. Brownfield code almost always
    has no consideration for DI, and it will have to change to accommodate it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在TDD（测试驱动开发）中编写代码时，你的代码从第一刻起就是可单元测试的。这是因为你考虑了依赖注入（DI）的场景。棕色地带代码几乎从未考虑过DI，它将不得不改变以适应它。
- en: In this section, we will cover the scenarios that you have to change, and then
    we will go through an example of a sample refactoring at the end of this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖你必须更改的场景，然后在本节的末尾通过一个示例重构来展示。
- en: Variables instantiated in the code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码中实例化的变量
- en: 'Whenever you see a `new` keyword in the code that is instantiating a library
    or a service, then most probably, this needs refactoring. Take the following example
    of code in a method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中看到用于实例化库或服务的 `new` 关键字时，那么很可能，这需要重构。以下是一个方法中的代码示例：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous line means we cannot inject a test double for `Foo`, so the code
    needs to change to inject it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行意味着我们无法注入 `Foo` 的测试替身，因此代码需要更改以注入它。
- en: The next thing to do is to check whether `Foo` implements an interface for the
    methods you are using from this class. Let me break the bad news for you here
    – keep your expectations low; you most probably won’t find that the class implements
    an interface for the methods you are using unless you are consuming a well-designed
    and sophisticated framework.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检查 `Foo` 是否实现了你从该类使用的方法的接口。让我在这里告诉你一个坏消息——保持你的期望低；除非你正在使用一个设计良好且复杂的框架，否则你很可能找不到该类实现了你使用的方法的接口。
- en: In the next few sections, we will go through the process of making the code
    testable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过使代码可测试的过程。
- en: Creating an interface for your own class
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为你自己的类创建接口
- en: 'If you own the code in `Foo` and you can change it, great! Your code can change
    from:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有 `Foo` 中的代码并且可以更改它，那太好了！你的代码可以从：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To this class and an additional interface, `IFoo`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个类和额外的接口 `IFoo`：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is easy. But what if the source code of this class is not accessible to
    you, or you are not allowed to change the source code?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。但如果这个类的源代码不可用，或者你不允许更改源代码怎么办？
- en: Creating an interface for a third-party class
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为第三方类创建接口
- en: 'Adding an interface for a class you do not own is not possible. You have to
    go through another pattern, usually referred to as a wrapper class. You will need
    to create a new class and interface, as such:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为你并不拥有的类添加接口是不可能的。你必须通过另一个模式，通常被称为包装类。你需要创建一个新的类和接口，如下所示：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that we have wrapped the `Foo` class with another class to intercept
    the calls to the `DoBar` method. This would allow us to add an interface in the
    same way we can add an interface to a class we own.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们已经用另一个类包装了 `Foo` 类，以拦截对 `DoBar` 方法的调用。这将允许我们以与我们添加到我们拥有的类中的接口相同的方式添加接口。
- en: There is a bit of extra work here, but you will get used to it, and it will
    become straightforward after a couple of class changes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的工作，但你会习惯的，经过几次类更改后，它将变得简单易懂。
- en: Now that we have an interface for our class, we can go to the second step, DI.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为我们的类有了接口，我们可以进行第二步，即依赖注入。
- en: Injecting your components
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注入你的组件
- en: 'How you do dependency injection depends on the library you are using (ASP.NET
    Core, Win Forms, among others) and the way you’ve wired up your DI container.
    Let’s take an ASP.NET Core WebAPI project. To wire up your newly created or updated
    class, write code similar to the following in `Program.cs`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何进行依赖注入取决于你使用的库（ASP.NET Core、Win Forms 等）以及你如何配置你的 DI 容器。让我们以一个 ASP.NET Core
    WebAPI 项目为例。为了配置你新创建或更新的类，在 `Program.cs` 中编写类似于以下代码：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 或者以下代码：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, the lifespan scope (transient, scoped, or singleton) will change
    based on the `Foo` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，生命周期范围（瞬态、作用域或单例）将根据 `Foo` 类而变化。
- en: 'Once you’ve done the modification, you can refactor your controller to inject
    `FooWrapper`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成修改，你可以重构你的控制器以注入 `FooWrapper`：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We introduced a `wrapper` class and an interface so we can follow along with
    a familiar DI pattern, so the previous code became possible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个 `wrapper` 类和一个接口，这样我们就可以遵循一个熟悉的依赖注入（DI）模式，因此之前的代码成为可能。
- en: Now, you can go ahead and implement whatever unit testing you want to put in
    place, as you can inject a test double for `FooWrapper` at test time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以继续实施你想要的任何单元测试，因为你在测试时可以注入 `FooWrapper` 的测试替身。
- en: The instantiation scenario is sorted. Let’s explore another refactoring pattern.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化场景已经整理好了。让我们探索另一个重构模式。
- en: Static members replacement
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换静态成员
- en: Static methods, which include extension methods, are simple, occupy fewer coding
    lines, and produce beautiful code. However, they are evil when it comes to dependency
    injection; as per the explanation in [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, static methods are not unit test
    friendly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法，包括扩展方法，简单、占用更少的代码行，并产生优美的代码。然而，当涉及到依赖注入时，它们是邪恶的；根据 [*第2章*](B18370_02.xhtml#_idTextAnchor037)
    的解释，*通过示例理解依赖注入*，静态方法不适合单元测试。
- en: '`Date.Now` looks innocent, and `Now` is a read-only static property. If you
    want your unit test to freeze the time, for example, say you want to test what
    happens on February 29 (leap year), you can’t do that. The solution to this one
    is a wrapper, as discussed earlier. This is what you can do to make `Now` an instance
    method rather than a static method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.Now`看起来很无辜，`Now`是一个只读的静态属性。如果你想让你的单元测试冻结时间，例如，比如说你想测试2月29日（闰年）会发生什么，你做不到。这个问题的解决方案是一个包装器，如之前讨论的那样。这是你可以做的，将`Now`作为一个实例方法而不是静态方法：'
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve done exactly what we’ve done earlier where we did not have control over
    the class (few sections back). We enabled DI support by introducing the wrapper
    pattern to the `DateTime` class. Now, you can inject `DateTimeWrapper` at runtime
    and use a test double for unit testing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了和之前一样的事情，当时我们没有控制这个类（几节之前）。我们通过向`DateTime`类引入包装模式来启用DI支持。现在，你可以在运行时注入`DateTimeWrapper`并使用测试替身进行单元测试。
- en: 'If you have control over the class, you might want to change the static member
    to an instance one (non-static) or introduce an additional instance member and
    keep the static member:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制这个类，你可能想将静态成员更改为实例成员（非静态）或者引入一个额外的实例成员并保留静态成员：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a way to expose your static property as an instance property. You will
    also have to use the `PropWrapper` wrapper property instead of the non-wrapped
    one, `Prop`, in the rest of your code. In the previous example, we added an additional
    property, but you could also refactor the code to replace the static property
    if it makes sense.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将你的静态属性公开为实例属性的一种方法。你还需要在其余代码中使用`PropWrapper`包装属性，而不是未包装的`Prop`。在之前的示例中，我们添加了一个额外的属性，但你也可以重构代码以替换静态属性，如果这样做有意义的话。
- en: Changing the consumer to rely on an instance member
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将消费者改为依赖于实例成员
- en: 'The code consuming the previous `Foo` class might look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 消耗先前`Foo`类的代码可能看起来像这样：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After refactoring `Foo` as per the previous section, the implementation here
    can change into a unit-testable format, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在根据上一节重构`Foo`之后，这里的实现可以改变为可测试的格式，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that we have injected `IFoo` into the `Consumer` class and we have
    used another property, `PropWrapper`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们已经将`IFoo`注入到`Consumer`类中，并且我们使用了另一个属性，`PropWrapper`。
- en: Instantiated classes and static member calls can be easily spotted. However,
    the most notable thing about legacy code is that it doesn’t have a structure,
    and a component cannot be easily noticed and tested. So for this, we will have
    to make more changes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化的类和静态成员调用很容易被发现。然而，关于遗留代码最显著的一点是它没有结构，一个组件不能轻易被发现和测试。因此，为了这个，我们不得不做更多的改变。
- en: Changing code structure
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变代码结构
- en: 'The code in the brownfield project might be in a format that isn’t unit testable.
    One popular structure is the controller’s action method with all the code written
    inside it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在棕色地带项目中，代码可能处于无法进行单元测试的格式。一个流行的结构是控制器动作方法，所有代码都写在其内部：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we need to get the code into a unit-testable structure. I would choose
    an architecture such as DDD, as per *Part 2* of this book, where we’ve used services
    and domain objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要将代码放入可测试的结构中。我会选择一个架构，如本书的*第2部分*中所述，在那里我们使用了服务和领域对象。
- en: 'The previous sample code works fine, but it is not unit testable. You can find
    the full listing in the `WeatherForecasterBefore` directory of this chapter in
    the `WeatherForecastController.cs` GitHub file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码运行良好，但它不可进行单元测试。你可以在本章的`WeatherForecasterBefore`目录下的`WeatherForecastController.cs`
    GitHub文件中找到完整的列表：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Clearly, most of the code is omitted for brevity. The code will call a third-party
    service called Open Weather, and get the forecast for the next 5 days for a certain
    geographical coordinate. It will then analyze the temperature and produce a word
    that describes the temperature feel, such as *Freezing* or *Balmy*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了简洁起见，大部分代码被省略了。代码将调用一个名为Open Weather的第三方服务，并为某个地理坐标获取未来5天的天气预报。然后，它将分析温度并产生一个描述温度感觉的词，例如*Freezing*或*Balmy*。
- en: The previous code also instantiates a `HttpClient` instance, which means there
    is no easy way of avoiding calling the third party whenever we try to unit test
    this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码还实例化了一个`HttpClient`实例，这意味着在尝试对这段代码进行单元测试时，我们无法避免调用第三方服务。
- en: Next, we shall invest some thoughts into changing this code into testable components.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将思考如何将此代码改为可测试组件。
- en: Analyzing code change for a testable format
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析代码更改以实现可测试格式
- en: 'The code that we’ve just seen can be made into components in several ways,
    and there is no one way to do it. This code does two things, so we can think of
    two components that will encompass all the code functionality:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到的代码可以通过几种方式制作成组件，并且没有一种方法可以做到。这段代码做了两件事，因此我们可以考虑两个将包含所有代码功能的组件：
- en: Calling Open Weather and obtaining a forecast
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Open Weather 并获取预报
- en: Obtaining the forecast and analyzing it
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取预报并分析
- en: The idea here is to have the controller with no business logic and if there
    is no business logic, then we will not need to unit test the controller. The controller,
    in general, should have no business logic, and it should do a single job – deliver
    **data transfer objects** (**DTOs**) to views (as of Model-View-Controller views).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是拥有没有业务逻辑的控制器，如果没有业务逻辑，那么我们就不需要单元测试控制器。一般来说，控制器应该没有业务逻辑，它应该做单一的工作——将 **数据传输对象**
    (**DTOs**) 传递给视图（如模型-视图-控制器视图）。
- en: 'We will give the following names to our components:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将给我们的组件以下命名：
- en: '`OpenWeatherService`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenWeatherService`'
- en: '`WeatherAnalysisService`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeatherAnalysisService`'
- en: 'The whole call to obtain the forecast and the temperature feeling analysis
    would look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 获取预报和温度感觉分析的整体调用将看起来像这样：
- en: '![Figure 12.2 – Workflow by components ](img/Figure_12.2_B18370.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 组件工作流程](img/Figure_12.2_B18370.jpg)'
- en: Figure 12.2 – Workflow by components
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 组件工作流程
- en: The client will call the APIs to obtain the forecast with the feeling. The weather
    forecast controller will receive the call and pass it to the weather analysis
    service, which loads the Open Weather service and calls an external dependency
    to obtain the weather.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将调用 API 以感觉获取预报。天气预报控制器将接收调用并将其传递给天气分析服务，该服务加载 Open Weather 服务并调用外部依赖以获取天气。
- en: Next, we will see what the code looks like after our refactoring.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到重构后的代码看起来是什么样子。
- en: The final testable code
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终可测试的代码
- en: There are levels of refactoring invasiveness when you want to enable unit testing.
    I chose an aggressive level, but you might choose to refactor less code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想启用单元测试时，存在重构侵入性的级别。我选择了积极级别，但您可能选择重构更少的代码。
- en: You can see the whole refactored code in the **WeatherForecasterAfter** directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **WeatherForecasterAfter** 目录中看到整个重构后的代码。
- en: 'Now the controller looks like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在控制器看起来是这样的：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The controller is almost empty, compared to how it was before. The action method
    in the controller is mapping the API call to the right service.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相比，控制器几乎是空的。控制器中的操作方法将 API 调用映射到正确的服务。
- en: 'This is the `OpenWeatherService` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `OpenWeatherService` 类：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The class contains the logic of mapping the feeling to the temperature and calling
    `OpenWeatherService`. The service doesn’t know how the Open Weather APIs are called.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含将感觉映射到温度并调用 `OpenWeatherService` 的逻辑。服务不知道如何调用 Open Weather API。
- en: 'Finally, let’s look at `OpenWeatherService`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看 `OpenWeatherService`：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The job of this service is to wrap the HTTP call to the internet Open Weather
    APIs with code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务的任务是使用代码封装对互联网 Open Weather API 的 HTTP 调用。
- en: The full unit tests for the newly added services can be found in the source
    code directory with the rest of the services.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 新增服务完全单元测试可以在与其余服务相同的源代码目录中找到。
- en: Remember that we are doing the refactoring while assuming the code has undergone
    other types of testing. Aggressively refactoring code is time-consuming, especially
    for the first set of refactors, but remember that refactoring is also paying back
    part of the technical debt of the project. The code is now documented by the unit
    test as well, so this is a step forward.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们在假设代码已经经历过其他类型的测试的情况下进行重构。积极重构代码是耗时的，尤其是对于第一组重构，但请记住，重构也是偿还项目部分技术债务。现在代码由单元测试进行文档化，所以这是一个进步。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the implications of enabling unit testing for
    a brownfield project. We’ve gone through the considerations to allow you to decide
    whether it is worth it and all the things that you have to watch for while progressing
    with the process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了为现有项目启用单元测试的后果。我们已经讨论了考虑因素，以便您决定这是否值得，以及在推进过程中需要注意的所有事情。
- en: As a developer, you will encounter brownfield projects that went up in value
    and would benefit from unit tests and TDD. Hopefully, this chapter equipped you
    with the required knowledge to tackle them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，您将遇到价值上升的棕色地带项目，这些项目将从单元测试和TDD中受益。希望这一章能为您提供应对这些项目的所需知识。
- en: Deciding to introduce TDD into your organization is not a straightforward process.
    The next chapter will go through the process and prepare you for some scenarios
    that you would face.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将TDD引入您的组织并非一个简单的过程。下一章将详细介绍这一过程，并为您准备您可能会遇到的一些场景。
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章讨论的主题，您可以参考以下链接：
- en: '*JustMock (Isolation Framework from Telerik)*: [https://docs.telerik.com/devtools/justmock](https://docs.telerik.com/devtools/justmock%0D)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JustMock（来自Telerik的隔离框架）*：[https://docs.telerik.com/devtools/justmock](https://docs.telerik.com/devtools/justmock%0D)'
- en: '*Microsoft Fakes (Isolation Framework that comes with VS Enterprise)*: [https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes](https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes%0D)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Microsoft Fakes（随VS Enterprise提供的隔离框架）*：[https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes](https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes%0D)'
- en: '*TypeMock (Isolation Framework for classical .NET Framework)*: [https://www.typemock.com](https://www.typemock.com)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TypeMock（适用于经典.NET Framework的隔离框架）*：[https://www.typemock.com](https://www.typemock.com)'
