<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Sockets and Ports</h1>
                </header>
            
            <article>
                
<p class="mce-root">At this point, we understand how to handle data streams from remote hosts, process those streams asynchronously on background threads, and handle the errors that arise from processing that data. Now we're going to look at the most primitive connections you can make with a remote host. In this chapter, we'll be looking at the physical ports through which your machine is going to do this, and we'll be looking at the concept of a socket: the software structure that exposes access to a port for network interaction. We'll examine the WinSocks library for instantiating and working with those ports, and we'll consider the various ways sockets can be leveraged by your application code for efficient, low-level communication with a target host.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>How the <kbd>System.Net.Sockets</kbd> classes serve as the C# interface to your hardware-level network APIs for communication with external machines</li>
<li>How to establish a connection to a socket exposed by another machine on your network</li>
<li>How to program server applications that expose sockets to accept external connection requests</li>
<li>The nature of communicating over serial ports and exposing serial ports to accept serial data for processing, and how this can open you up to interesting use cases for C# and .NET Core</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter will have a number of samples and driver programs to demonstrate the concepts discussed, each of which will be available here: <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%208">https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter 8</a>.</p>
<p class="mce-root">As always, clone the repository locally and begin playing with the source code, or writing your own along with the topics in the chapter to get comfortable with it.</p>
<p><span>We'll also start using external tools to test and inspect the behavior of a sample API. For this, you'll need to download and install either Postman, which can be found here:</span> <a href="https://www.getpostman.com/apps"><span>https://www.getpostman.com/apps/</span></a> ,<span>Or you'll need the Insomnia REST client, which can be found here</span><a href="https://www.getpostman.com/apps"><span>:</span></a> <a href="https://insomnia.rest/"><span>https://insomnia.rest/.</span></a></p>
<p><span>The feature set of each of these applications is almost identical, and each will allow you to send arbitrary requests to a local API through an intuitive UI. We'll be using them to test out our web software going forward, and I'd recommend spending at least a little time getting familiar with some of the basic functionality of whichever tool you choose to use. Throughout this chapter I'll be presenting screenshots captured from Postman, but that's not an endorsement of Postman over Insomnia, and the steps and UI when following along should be virtually identical in both.</span></p>
<p><span>Finally, we'll be using Docker to demonstrate port mapping. While you could manage an understanding of the specific concepts of this chapter without this tool, I'd strongly recommend downloading and familiarizing yourself with it. It is core to the modern web application development experience, and you will only benefit from practicing with it. This chapter provides one of the best opportunities to do so, and I'd certainly encourage you to try.</span> <span>Docker can be downloaded here:</span> <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows"><span>https://hub.docker.com/editions/community/docker-ce-desktop-windows</span></a>.</p>
<p><span>Check out the following video to see the code in action: <a href="http://bit.ly/2HYmX49">http://bit.ly/2HYmX49</a></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sockets versus ports</h1>
                </header>
            
            <article>
                
<p>The first thing we should do as we look at these connection mechanisms is to distinguish between the two. While they are two words identifying a common hardware interaction, the software or abstract concepts each term identifies are actually mutually exclusive. These terms aren't as interchangeable as abstract class and interface were in previous chapters, so when we use each term, it will be for a specific purpose, and you'll need to know what it is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ports – a hardware interface</h1>
                </header>
            
            <article>
                
<p>As we already know, machines are identified by their IP address, or the hostname mapped to that IP address in the DNS registry. So for any given connection between machines to be resolved, the initiating host will ultimately need the underlying IP address of the target host. However, simply specifying the target IP address is insufficient to target a service or application running on the host. It only gives us the location of the host itself. That's where ports come in. A port is a two byte unsigned integer that identifies a running process on a target machine.</p>
<p>Each application on your host that will interact with remote processes must do so on a designated port. Furthermore, no two applications can listen on the same port. Every time you want to start up your application and designate it as listening for network requests, you must assign it to an unsigned port on your machine. If you've ever tried to run multiple instances of an API project on the <kbd>8099</kbd> or <kbd>8080</kbd> port (or any other common listening port) on your local machine, you'll have seen the startup failure message indicating that the target port is already in use. That port is occupied, so you'll have to find a different one to process transactions targeting your new application.</p>
<p>The reason for this should be fairly obvious. If you want to host multiple services on a single device, you will need some way of distinguishing between incoming requests for service <em>A</em> and incoming requests for service B. By designating mutually-exclusive listening ports for each hosted application, you move the burden of proper routing back to the client. This is perfectly acceptable, since the client already has to keep track of the remote hosts URI, and if you remember from our earlier chapter, the port number is simply another component of that API. The alternative would require an application to serve as an intermediary between your hosted listening applications and all incoming network requests. Such an application would have to have reasonable knowledge of the state or expectations of each listening application, then it will parse every incoming request to identify which expectation the following requests meets. It would be just a whole mess of state management that would become infeasible incredibly quickly. So instead, we simply add 2-byte address suffixes to specify the target listening application built directly into our URI specification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reserved ports</h1>
                </header>
            
            <article>
                
<p>If you know the valid integer values of an unsigned 2-byte <kbd>int</kbd>, you already know the full range of possible exposed ports for a machine. Using this data type, a port specification could have a value from <kbd>0</kbd> to <kbd>65535</kbd>. However, just because a port designation falls within the range for the data-type of a port, it doesn't mean you should attempt to listen on it. There are in fact a number of port ranges that your user-application code should never attempt to listen on. These are designated as reserved ports and typically handle very specific functions.</p>
<p>The first set of ports that are reserved, and thus unavailable for you to register your application to, are called the <strong>well-known ports</strong>. These ports fall between <kbd>0</kbd> and <kbd>1023</kbd>, and are used for anything from DNS address resolution (the <span>port </span><kbd>53</kbd>  used to make sure there is still a machine listening at the address listed in the registry) to FTP data and control ports (the <span>ports</span> <kbd>20</kbd> and <kbd>21</kbd> , respectively). If you've done any sort of network programming prior to reading this book, you're already likely to be familiar with the fact that the <kbd>80</kbd> port is the designated port for incoming HTTP requests and the <kbd>443</kbd> port is reserved for HTTPS.</p>
<p>The other list of ports that you won't be able to register your application to is what's known as the <strong>dynamic port range</strong>. Dynamic ports, or private ports, are used to establish connections for private or customized services or interactions, or used for temporary <span><strong>Transmission Control Protocol</strong> (</span><strong>TCP</strong>) or <span><strong>User Datagram Protocol</strong> (</span><strong>UDP</strong>) interactions between two hosts. When used in a temporary context to service a brief need from either machine, the designated port is known as an <strong>ephemeral</strong> <strong>port</strong>. These ports cannot be registered with the <strong>Internet Assigned Numbers Authority</strong> (<strong>IANA</strong>) for use in general-purpose network interactions on a given host. The range for these ports begins at port number <kbd>49152</kbd> and ends at <kbd>65535</kbd>.</p>
<div class="packt_tip packt_infobox">The IANA is a non-profit organization responsible for managing the allocation of IP addresses, among other things. As I mentioned in <a href="7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml" target="_blank">Chapter 1</a>, <em>Networks in a Nutshell</em>, a centralized system for standards (and names) is important to guarantee that every device routes requests for one IP address to the same device.</div>
<p>With that specification, that appears to leave everything between and including <kbd>1024</kbd> and <kbd>49151</kbd> as available for use by your applications. These are what's known as <strong>registered ports</strong><em>.</em> They are available for assignment by user applications or system services as needed, and won't interfere with default behavior from your hardware or other connected hosts.</p>
<p>It probably seems like configuring your application to listen within the registered port range will be sufficient for use. However, that's still not <em>quite</em> the case. If you've ever run a JBoss application server (back in the bad old days of bloated application servers like JBoss, you probably remember accessing your locally-hosted development environment by accessing <kbd>http://localhost:8080/my-java-application</kbd>, or at least that's what I used to have to do. The reason JBoss always configured that port specifically is because it actually serves as an alias for the <kbd>80</kbd> port, the HTTP port. The same is true for <kbd>8008</kbd>. So, even though the ports fall within the registered port range, there are specific expectations around their behavior. It really just provides a value within the registered ports range for users to define default HTTP handlers, since you can't really assign an application directly to the <kbd>80</kbd> port.</p>
<p>There are other ports within the registered port range that will likely be occupied by common services and applications on your local machine. Since .NET Core will stop if it can't register itself with the designated port, though, you'll notice immediately if you need to update your configuration with a different port number.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exposing multiple applications on a single port</h1>
                </header>
            
            <article>
                
<p>If you have been working in web development for a substantial amount of time, you may already be familiar with wrangling the various configurations and settings in <strong>Internet Information Services</strong> (<strong>IIS</strong>) or the aforementioned JBoss whenever you wanted to deploy a web application on a Windows host. This is what's called an <strong>application server</strong>, and it essentially serves as a shared hosting environment for any network-exposed applications on your system. When working with IIS, you can register any number of applications to respond to requests against a single port (<kbd>80</kbd> for HTTP, or <kbd>443</kbd> for HTTPS) and distinguish between them with application paths in the URI, or sub-domain specifications.</p>
<p>So if you had two applications named, for instance, <kbd>TestApp</kbd> and <kbd>SampleApp</kbd>, and you wanted to host both on a single machine, but expose both over the HTTP port, you would do so by registering them and deploying them within IIS. In doing so, you would specify an application directory within IIS, such as <kbd>/sample</kbd> and <kbd>/test</kbd>. This would tell IIS that any requests to your hostname over the <kbd>80</kbd> port, the request paths had as their first component the <kbd>/sample</kbd> directory, should be routed to your <kbd>SampleApp</kbd> as though the request went directly to that application. This essentially moved the problem of mapping specific ports to mapping specific application directories.</p>
<p>While IIS still supports deployment of .NET Core applications, it's much less common in modern web-hosting contexts. IIS specifically is known for its convoluted configuration schemes and the immense memory and CPU usage footprint it imposes on your host machine. That's not to mention the fact that IIS is exclusive to Windows operating systems, making portability of IIS hosted applications non-existent.</p>
<p>More typically, engineers are embracing a more lightweight approach to hosting concerns. With the cross-platform support of the .NET Core  runtime, engineers that have the benefit of working in greenfield applications are encouraged to pursue more cutting- edge solutions. Typically, .NET Core developers deploy your application to a remote host by way of a Docker container. Docker provides an isolated hosting context for your application, and exposes the ports your application is listening on to the outside world by mapping the container's internal listening ports to an available port on the machine that's actually running your Docker container. You can specify the port you'd like your application to listen on within what's called a <strong>Dockerfile</strong>, which specifies the build and deployment steps for a Docker-hosted application. It's not unlike a PowerShell script or bash script for automating common OS-level operations. Once you specify your desired port, you can map it to a port on the host machine within the <kbd>run</kbd> command like so:</p>
<pre><strong>docker run -p 80:5000 -p 443:5001 SampleApp</strong></pre>
<p>This command will map from the port <kbd>5000</kbd> inside our <strong>Docker Container</strong> to the <kbd>80</kbd> port on the host machine, and the <kbd>5001</kbd> port to the <kbd>443</kbd> port. So from our hosting context, we'll get a request against the <kbd>80</kbd> port, and that will be listened to by our Docker instance, which will forward the request into our running <strong>.NET Core App</strong>, which will be listening on the <kbd>5000</kbd> port:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-911 image-border" src="assets/e6214c27-0fca-42c8-8266-d87737cecc75.png" style="width:37.25em;height:18.17em;"/></p>
<p>From here, the problem of hosting multiple applications behind a single port that was solved by IIS or JBoss is often simply a matter of configuration. If your application is cloud-hosted, you can typically do the same sort of route-prefix mapping that was provided by IIS. In other contexts, you can host your suite of applications behind what's called a <strong>reverse-proxy</strong>.</p>
<p>We'll take the time to look at, and in some cases even build, each of these approaches in later chapters. For now though, it is sufficient that you understand the nature of ports as a mechanism by which external requests can access specific services or applications hosted on a target device. When exposing your application to network resources, the specific port over which you do so is typically a matter of simple configuration and convention; for now, we'll take a look at how to interact with those specific ports in our software through sockets.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sockets – a software interface to a port</h1>
                </header>
            
            <article>
                
<p>So now that we understand how ports are used to route requests to specific processes on a host device, how do we set up our applications to actually <em>accept</em> requests over those ports? This is where a socket comes in.</p>
<p>A socket provides a software interface to a specific port on a specific remote host. It's an open connection stream between your application and any remote application exposed at the server and port address you specify. Once this connection is established, you're free to write (or read) any data to the open stream of that connection that you need. Sockets are a versatile concept, implemented in almost any server-side programming language, and .NET Core is no different.</p>
<p>One key distinction between a socket and its underlying port is that the port represents access to a single process on a remote device. Therefore, a port can only be registered for a single application. Sockets, however, represent active connections to that single resource. Therefore, there can be as many active sockets connected to a resource as can be supported by the network and the remote host:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-912 image-border" src="assets/2086663d-49a1-4de5-90de-659a148cc28a.png" style="width:28.42em;height:11.42em;"/></p>
<p>So, a port represents a single process running on a remote machine, while a socket represents a connection to a process on a remote machine, designated by a port number. When we run our applications and intend to expose them to remote resources, we must register them to a specific port. If we want to connect to our application to an exposed port, we do so with a socket. A port is merely a configuration concern, whereas leveraging sockets is an implementation detail, so let's take a look now at how to instantiate and leverage sockets for network communication.</p>
<div class="packt_tip">While I brush aside port registration as <em>merely</em> a configuration concern, that doesn't mean it's not your responsibility to understand and configure. Full-stack network engineering requires you to understand not only how to write your applications, but how to properly configure and deploy them to your various preproduction and production environments so that others can use them. We'll take a look at application deployment in the next chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging sockets in C#</h1>
                </header>
            
            <article>
                
<p>Sockets in C# are an extremely versatile and flexible concept. As their definition indicates, they only expose a connection to a remote resource, and how that connection is used is almost entirely up to the developer who establishes it. An instance of the <kbd>Socket</kbd> class in C# provides synchronous and asynchronous data transfer of packets of arbitrary collections of bytes. The contents, structure, and even protocol used to transmit those packets is up to you (though I do strongly recommend that you always leverage asynchronous communication over synchronous communication). So, let's look at how we'll use it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The socket specification</h1>
                </header>
            
            <article>
                
<p class="mce-root">The first thing to know about a socket is how to initialize it. The most basic information necessary to initialize a socket is understanding what kind of socket we'll be working with, and what protocol it will be operating on.</p>
<p class="mce-root">The first aspect of that specification, the socket type, tells our code how we'll be interacting with the connection once it's established. This is defined in a <kbd>SocketType</kbd> array, located in the <kbd>System.Net.Sockets</kbd> namespace, which defines the full set of valid interaction mechanisms. The values of <kbd>enum</kbd> include <kbd>Dgram</kbd>, which indicates that we'll be working directly with unordered, connectionless datagrams between our software and the connected host; the <kbd>Seqpacket</kbd> type, which operates with ordered, boundary-protected bytes transmitted back and forth over a stream; and the <kbd>Stream</kbd> type, which provides the asynchronous flow of bytes over a <kbd>Stream</kbd> instance that we've become familiar with so far. There are a handful of other <kbd>SocketType</kbd> values, and you can find them and descriptions of what they mean, and how they're used on the Microsoft documentation page. For this chapter, we'll just be working with a <kbd>Stream</kbd> type, since that most closely resembles the <kbd>Stream</kbd> classes from the <kbd>System.IO</kbd> namespace that we're already so familiar with.</p>
<p class="mce-root">A <kbd>Socket</kbd> can connect and communicate over a wide array of protocols from the transmission layer of the OSI network stack. This means that when you're constructing a socket, you'll need to specify specifically what protocol you'll be using to communicate once the connection is established. This informs the remote host of how it should be parsing the primitive datagrams or packets it will be receiving once the connection is established (provided the host supports the requested protocol in the first place). To define the protocol your <kbd>Socket</kbd> instance will be using, you'll be looking to values of the <kbd>ProtocolType</kbd> enum found in the <kbd>System.Net.Sockets</kbd> namespace. There are a number of defined values that correspond to well-established transmission protocols, including IPv4, IPv6, TCP, UDP, IDP, Raw, and others. For the purposes of our code, we'll be connecting to a local application listening for HTTP requests, which is handled by the TCP protocol, so we'll specify the TCP protocol when we initialize <kbd>Socket</kbd>.</p>
<p>And those two pieces of information are the minimum details we're required to specify for a socket, the public constructor signature being as follows:</p>
<pre><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Socket</span> (<span class="hljs-params">System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType</span>)</span><span>;</span></pre>
<p>There is also an option to specify what's known as the <kbd>AddressFamily</kbd> of your connection. This can actually be derived from your connection endpoint and provided to the constructor for your socket. Typically, for an HTTP resource transmitted over TCP, your specification will be <kbd>AddressFamily.Osi</kbd>, indicating that you're using OSI addressing schemes. So now that we know how to initialize a socket, let's look at what it takes to connect a socket to a remote endpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Establishing a socket connection</h1>
                </header>
            
            <article>
                
<p><span>The first thing we'll want to do is set up a simple listening server to which we can connect our socket driver program. To do this, we'll spin up a simple, <kbd>WebAPI</kbd> project and run it. Start by opening up Command Prompt and navigating to the directory where you want to create your sample API. Next, create a new <kbd>WebAPI</kbd> with the following command from the .NET Core CLI:</span></p>
<pre><strong>dotnet new webapi -n SampleApp</strong></pre>
<p>This will spin up a new application from scratch that will be ready-made to receive and respond to HTTP and HTTPS requests made to your local machine and a pre-configured port.</p>
<p>For the purposes of this demonstration, we'll actually want to disable some default functionality in this application. The template for a WebAPI will redirect all calls made to the HTTP port to the HTTPS port instead. We want to prevent this from happening so the HTTP port, can service requests directly. You'll see why later, but for now you can disable this functionality by opening up your <kbd>SampleApp</kbd> project and navigating to the <kbd>Startup.cs</kbd> file. Within this file, you'll find a method with the following signature:</p>
<pre>public void Configure(IApplicationBuilder app, IHostingEnvironment env)</pre>
<p>At the bottom of this method, delete or comment out the line of code that reads:</p>
<pre>app.UseHttpsRedirection();</pre>
<p>Once that's done, you can close that folder and ignore its contents for the rest of this sample project. Now, let's run it and test it, first by navigating into the folder that was just created, and then calling the CLI <kbd>dotnet run</kbd> command. Once you've done that, you should see the following output from your running application:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-913 image-border" src="assets/e02c49cd-5085-429f-95eb-02094047f785.png" style="width:81.42em;height:20.25em;"/></p>
<div class="packt_tip">You can take your time investigating the project template created by the <kbd>dotnet new</kbd> command if you're curious, but we'll be covering WebAPI applications, among many others, in much greater detail in the next chapter. For now, it's just important that we have an application that's listening for requests and returning responses. You can simply take my word on its expected functionality going forward, if you'd rather defer learning that until later.</div>
<p>The last three lines of your console output give you some valuable information; they tell you the exact host and port through which your application is exposed to outside connections. As you can see, the default from new WebAPIs created by .NET is going to be port <kbd>5000</kbd> for incoming HTTP requests, and <kbd>5001</kbd> for HTTPS.</p>
<p>To confirm that the application is responding to requests, open up Postman (or Insomniac, if that was your REST client of choice), and send a GET request to <kbd>http://localhost:5000/api/values</kbd>. You should see the following response in your output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-914 image-border" src="assets/b2185971-58e0-4437-83fa-fe4c12330170.png" style="width:105.25em;height:42.25em;"/></p>
<p>We can see a valid response with two strings in a <kbd>JSON</kbd> array. Once you have this, we're ready to connect with <kbd>Socket</kbd>.</p>
<p class="mce-root">Create a new console application in the parent directory of <kbd>SampleApp</kbd>, using the <kbd>dotnet new console -n SocketTest</kbd> command in the CLI. This will be our driver application for working with the <kbd>Socket</kbd> class. The objective of this sample project is to connect to our <kbd>SampleApp</kbd><em>,</em> which is listening on the <kbd>5000</kbd> port, submit a request to the <kbd>/api/values</kbd> endpoint, and then parse and print the response.</p>
<p>So, the first thing we'll have to do is define an <kbd>IPEndPoint</kbd> instance for <kbd>Socket</kbd> to connect to. <kbd>IPEndPoint</kbd> is a specific implementation of the <kbd>EndPoint</kbd> abstract class required by the <kbd>Socket.ConnectAsync()</kbd> method we'll be using. It defines the specific location of the remote resource we intend to connect to, and exposes metadata about that endpoint. It also provides the <kbd>AddressFamily</kbd> value for our <kbd>Socket</kbd> constructor signature. So let's first define that with the host address and port, and use it to construct <kbd>Socket</kbd>.</p>
<p>To do so, we need an <kbd>IPAddress</kbd> instance, which we could build ourselves based on the 4 bytes stored in our localhost address of <kbd>127.0.0.1</kbd>, or we could simply request it explicitly from our DNS using the <kbd>Dns.GetHostEntry()</kbd> method from <a href="ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml" target="_blank">Chapter 2</a>, <em>DNS and Resource Location</em>. You can do as you please when following along, but since it involves less math, I'll be using the DNS. However, since <kbd>AddressList</kbd> returned by a host entry can have an arbitrarily large list of IP Addresses to which the name could resolve, we'll want to connect to the first address that allows us to, and proceed from there. This means looping through <kbd>AddressList</kbd> until a connection is established. So the initial setup to attempt to establish our connection will look like this:</p>
<pre>static async Task Main(string[] args) {<br/>  string server = "localhost";<br/>  int port = 5000;<br/>  string path = "/api/values";<br/><br/>  Socket socket = null;<br/>  IPEndPoint endpoint = null;<br/>  var host = Dns.GetHostEntry(server);<br/><br/>  foreach (var address in host.AddressList) {<br/>    socket = new Socket(address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);<br/>    endpoint = new IPEndPoint(address, port);<br/>    await socket.ConnectAsync(endpoint);<br/>    if (socket.Connected) {<br/>      break;<br/>    }<br/>  }<br/>  ...<br/>}</pre>
<p>One thing that might jump out to you about this code is that we're using the <kbd>async</kbd> version of the <kbd>Main()</kbd> method. This is a feature that was only added in version 7.2 of C#, and if your project isn't configured to target at least that version, you'll encounter build errors. To resolve them, simply modify the <kbd>PropertyGroup</kbd> tag of your <kbd>.csproj</kbd> file to include the <kbd>LangVersion</kbd> tag with its version set to <kbd>latest</kbd>, as seen here:</p>
<pre>&lt;PropertyGroup&gt;<br/>    &lt;OutputType&gt;Exe&lt;/OutputType&gt;<br/>    &lt;TargetFramework&gt;netcoreapp2.2&lt;/TargetFramework&gt;<br/>    &lt;LangVersion&gt;latest&lt;/LangVersion&gt;<br/>&lt;/PropertyGroup&gt;</pre>
<p>Once you've made this change, your source code will always target the latest minor version of C#. With that in place, you should have no problems running your <kbd>Main()</kbd> method asynchronously.</p>
<p>If you want to make sure things are behaving as expected, you can go ahead and run your application, placing a breakpoint on the <kbd>break;</kbd> operator, and you should see that the breakpoint is hit, and so a connection was established between your two applications. You'll notice, though, that simply establishing the connection didn't trigger any log messages in your running WebAPI application. This is because, while a connection was established, no request was made of the resource to which we connected. Requests must be sent as a well-formed message over an established connection. So now, let's build our request and send it over the connected socket.</p>
<p>Sending requests is as simple as calling the <kbd>SendAsync()</kbd> method on our socket with a byte array representing our data buffer to be sent over the connection. So for an HTTP request, we have to build our message from scratch. That means specifying the method or HTTP verb we'll be using, the specific URL of our requested resource, the size of any content we intend to send over, and any request headers we need to attach. I'm sure by now you can already see how tedious it is to work directly with sockets. For such a simple request, however, we can easily construct our message with a simple utility function:</p>
<pre>private static string GetRequestMessage(string server, int port, string path) {<br/>  var message = $"GET {path} HTTP/1.1\r\n";<br/>  message += $"Host: {server}:{port}\r\n";<br/>  message += "cache-control: no-cache\r\n";<br/>  message += "\r\n";<br/>  return message;<br/>}</pre>
<p>Then using this, we can build our byte array just as we did when writing to streams. So back in our main method, we'll get our request message, convert it to a byte array, and then send the request to our remote host (<em>SampleApp</em>, running at <kbd>http://localhost:5000</kbd>). Add the following lines into the main method after the connection has been established by the <kbd>Socket</kbd> instance:</p>
<pre>var message = GetRequestMessage(server, port, path);<br/>var messageBytes = Encoding.ASCII.GetBytes(message);<br/>var segment = new ArraySegment&lt;byte&gt;(messageBytes);<br/><br/>await socket.SendAsync(segment, SocketFlags.None);</pre>
<p>If you add this code and then run your application, you'll know you've succeeded when you begin to see logging information in the console displayed by your WebAPI project, as seen here:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-915 image-border" src="assets/4ef05055-81cf-43ee-a743-062dbb81db9e.png" style="width:81.58em;height:43.75em;"/></p>
<p>And just like that, you've managed to send your first transport-level message over a socket connection.</p>
<p>Now, to confirm that we're receiving the responses from the server properly, we'll try to write to our <kbd>SocketTest</kbd> application's console the same message that we saw earlier in the responses from our Postman (or Insomnia) requests. In order to do that, we'll have to use the <kbd>ReceiveAsync()</kbd> method to accept whatever byte arrays were returned by the server in response to our request.</p>
<p>Just like with the instances of the <kbd>Stream</kbd> class we used in earlier chapters, the <kbd>ReceiveAsync()</kbd> method accepts a byte array into which it will write. For this, we'll provide it with an empty array, 512 bytes long. Once we define that, we can receive the response from the remote resource, and simply write it to our console, one line at a time. Just add the following lines of code to the bottom of your <kbd>Main()</kbd> method:</p>
<pre>var receiveSeg = new ArraySegment&lt;byte&gt;(new byte[512], 0, 512);<br/><br/>await socket.ReceiveAsync(receiveSeg, SocketFlags.None);<br/><br/>string receivedMessage = Encoding.ASCII.GetString(receiveSeg);<br/><br/>foreach(var line in receivedMessage.Split("\r\n")) {<br/>    Console.WriteLine(line);<br/>}<br/>Thread.Sleep(10000);</pre>
<p>When you run the application now, you should see the message headers, along with the body containing the string array we saw earlier in Postman, printed to your console:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-916 image-border" src="assets/45cee704-5e2e-4f03-adc9-9b1814956ce4.png" style="width:32.50em;height:12.08em;"/></p>
<p class="CDPAlignLeft CDPAlign">And just like that, you've successfully executed an HTTP request over TCP from scratch.</p>
<p>The last order of business is to disconnect from your host, and dispose of your socket. Let the last two lines of your application <kbd>Main()</kbd> method read as follows:</p>
<pre>  ...<br/>  socket.Disconnect(false);<br/>  socket.Dispose();<br/>}</pre>
<p>This is a major courtesy on your part. Even though a port can handle multiple connections simultaneously, there is an upper limit to how many connection requests it can service at a given point in time. Disconnecting your own Socket frees up resources on the remote host for others to take advantage of. While there is a maximum time limit for an inactive connection, after which the remote host will forcibly cancel the connection, you shouldn't ever let an inactive connection remain alive for that long. If you're done with the host, disconnect from the host.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing responses</h1>
                </header>
            
            <article>
                
<p>As I'm sure you already figured out, the simple string of ASCII characters that encapsulated the entirety of a response from your remote host is not exactly a computer-friendly format. Receiving a response is one thing, but leveraging its contents in your application is a whole different kinds of beast. Doing this kind of work from scratch every time you needed to access something on a different machine would slow the software development life cycle down to a crawl.</p>
<p>This is why .NET Core provides so many functional flexible wrapper and utility classes for the specific protocols and interactions you're most likely to deal with day to day. So, while I think it's important that you understand exactly how to establish and then leverage a direct connection from your application to any other application running on any other machine on your network, it's also not exactly so common that you'll find yourself needing to do so. As we move into the next few chapters, we'll see how the templates and libraries provided by .NET Core (and ASP.NET Core, in the case of HTTP) do all the heavy lifting so that we don't have to. If you're curious to learn more about low-level network interactions in C#, there's an entire ocean of knowledge and use cases that I simply didn't have time to cover in this chapter, and I would encourage you to spend some time digging in. If this content seemed a bit boring or tedious, though, don't worry. It's about to get a lot more fun.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we began to leverage and finally build from the foundation we've laid in previous chapters, opening up our applications to the full spectrum of network functionality available in C#. We learned that any application we write that we expect to be used by resources on our network must first be exposed to those resources through a port on our host machine. We looked at how ports are specified and registered, and learned about some restrictions that exist on how we can register our own, looking at the reason for, and the range, of well-known port addresses and the range of dynamic or ephemeral ports to which we cannot (or at least should not) register our applications.</p>
<p>Once we cemented that concept, we looked at the other side of the connection, and started working with sockets. We learned that sockets are a generic in-code representation of an active connection to an open port on a remote machine. We saw how the simplicity of that concept opened up a wide array of applications for socket-based network code and the low-level control it gives over packet-level communication.</p>
<p>With the concepts we've covered in this book so far, you have the resources necessary to write any network software you could ever need. Understanding the nature of asynchronous streams, packet construction and parsing, and socket connections to remote resources would be sufficient to implement any piece of networking functionality possible. It would be far from ideal, though, using such primitive building blocks. That's why the .NET Standard provides so many useful templates, patterns, and libraries for the myriad of applications you might have to write, and that's what we'll start looking at in the next chapter, starting with HTTP-based applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the definition of a port?</li>
<li>What is the range of well-known ports?</li>
<li>What is the dynamic port range?</li>
<li>What is one of the primary functions of an application server?</li>
<li>What is the definition of a socket?</li>
<li>What are some of the primary distinctions between a socket and a port?</li>
<li>Which construct provides the range of protocols over which a socket can connect?</li>
<li>What are some of the protocols that sockets support?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>For further reading on this subject, many of the books I've recommended in previous chapters still apply.</span></p>
<p>For additional insight, though, you can look at <em>ASP.NET Core 1.0 High Performance</em>, <em>James Single</em><em>ton,</em> Packt Publishing<em>.</em> While the subject of that book is specifically application-layer network programming, he addresses the performance benefits of managing direct connection I/O, and the subject may be of interest. You can find it through <em>Packt Publishing</em>, here: <a href="https://www.packtpub.com/application-development/aspnet-core-10-high-performance">https://www.packtpub.com/application-development/aspnet-core-10-high-performance.</a></p>


            </article>

            
        </section>
    </body></html>