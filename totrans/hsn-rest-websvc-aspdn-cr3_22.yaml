- en: Deploying Services on Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to deploy the catalog web service on Microsoft
    Azure. Although we will be focusing on the Microsoft Azure cloud provider and
    most of the instructions will be strongly linked to that platform, some of the
    concepts can be applied to multiple cloud providers: containers are becoming a
    common way to build and run applications and web services on the cloud, therefore,
    every cloud provider offers slightly different services and products to host containers.
    This chapter will not go too deeply into Microsoft Azure; it will provide an overview
    of **Azure Container Instances** (**ACI**) and Azure App Service features of the
    Azure cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing containers into Azure Container Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring ACI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring app services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, Microsoft Azure is the cloud platform built by Microsoft.
    Azure offers a wide range of IT products, technologies, and integration tools.
    Virtual machines, serverless technologies, databases, and machine learning pipelines
    are just some of the products that it provides. In this chapter, we will focus
    on a few of the services that are presented by Azure, such as**Container Instances**,
    **App Service**, and **Azure SQL Databases**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a subscription. Microsoft allows us to try Azure services
    out when a new user creates an Azure account for the first time. It is possible
    to register for a new Microsoft Azure account at [https://azure.microsoft.com/free/](https://azure.microsoft.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: The signup process will ask you for some personal details, as well as a valid
    phone number and valid credit card. By default, Microsoft provides 12 months of
    popular free services, plus €170 of Azure services for 30 days and 25+ services
    that are always free. This makes it easy for a new developer or engineer to test/learn
    how to use some of Azure's new services.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've completed the signup process, you will be able to log in to the
    Azure portal ([https://portal.azure.com](https://portal.azure.com/)) using the
    account you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure CLI is Microsoft''s official CLI for managing Azure resources; it
    is available for almost all OSes and is part of the Azure SDK. The Azure SDK is
    cross-platform; therefore, it is possible to install it on Windows, macOS, or
    Linux in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Platform** | **Command** | **Requirements** |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | `curl -L https://aka.ms/InstallAzureCli &#124; bash` | You will require
    some preinstalled software, that is, Python 2.7 or Python 3.x ([https://www.python.org/downloads/](https://www.python.org/downloads/)),libffi
    ([https://sourceware.org/libffi/](https://sourceware.org/libffi/)), and OpenSSL
    1.0.2 ([https://www.openssl.org/source/](https://www.openssl.org/source/)). For
    more information, please go to[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-linux?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-linux?view=azure-cli-latest).
    |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | `brew update && brew install azure-cli` | You will need `brew`, which
    should already be installed on your machine. For more information about `brew`,
    please go to [https://brew.sh/](https://brew.sh/). |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)
    | Microsoft provides an MSI for the Windows platform. |'
  prefs: []
  type: TYPE_TB
- en: 'The Azure SDK and its CLI provide all of the command-line tools you''ll need
    to manage Azure services. Let''s start by signing in using the CLI. We can do
    this by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will open a browser window and send you to the sign-in
    page for the Microsoft Azure portal and save the session into your local environment.
    In the next section, we will see how to use the CLI to push the container images
    we built in the previous chapters into the container registry service of Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing containers into Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will focus on deploying our containers into Microsoft Azure.
    This process involves some resources and services that are provided out of the
    box by the cloud provider. The following diagram is an overview of the architecture
    schema that we are going to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d32f4269-5723-4e15-92fc-fa0b1d67eddc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the different components that are involved in this schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Container Registry** is a managed Docker Registry service ([https://docs.docker.com/registry/](https://docs.docker.com/registry/))
    based on the open source Docker Registry 2.0\. It is possible to use Azure Container
    Registry to store, manage, and use your private Docker container images. We will
    use it to save images related to our custom images, such as the `catalog_api`
    image, and make them available to other cloud services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web app for containers allows us to use our containers and deploy them to
    **App Service** as a web app. Furthermore, it eliminates time-consuming infrastructure
    management tasks such as updating, scaling, and in general, managing the infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other dependencies of the application, such as `catalog_esb` and `catalog_cache`,
    will take the image from the public Docker Hub *(*[https://hub.docker.com](https://hub.docker.com))*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue by creating an Azure Container Registry. The registry will be
    used further in this chapter to push and pull the image of `catalog_api`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Container Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new Azure Container Registry, we should start by creating a new
    resource group. Resource groups are a fundamental concept in Azure resource management:
    they allow us to group a collection of resources for management, deployment, and
    billing reasons. In general, all of the resources that have the same life cycle
    should be grouped into the same resource group. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a resource group by using the following command on the Azure
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a new resource group called `handsOn` in our account
    stored in the West Europe region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create the Azure Container Registry by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates a new Azure Container Registry under the `handsOn`
    resource group with the name we have chosen. It also defines the **Stock-Keeping
    Unit** (**SKU**) for this resource—in our case, the basic one.
  prefs: []
  type: TYPE_NORMAL
- en: SKU usually refers to a specific variant of a product and all of the attributes
    that identify that type of product. In the same way, Microsoft Azure uses this
    term to identify a specific purchasable good or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created an Azure Container Registry, let''s push the `catalog_api`
    image into the registry. To solve the other dependencies of our container, we
    will create another `appsettings.json` file dedicated to a `Stage` environment.
    Therefore, we will set the `ASPNETCORE_ENVIRONMENT` variable to `Stage` to apply
    the connection string needed by the container. We can proceed by creating the
    `appsettings.Stage.json` file in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `appsettings.json` file definition declares the endpoints for
    the `catalog_db`, `catalog-esb`, and `catalog-cache` containers. Every endpoint
    is composed of the name of the container we are going to create, followed by the
    syntax—`<region_name>.azurecontainer.io`. The first part represents the region,
    followed by the subdomain of the service we are using, in our case, `azurecontainer.io`.
    Let''s continue by defining the steps to push our local image into the container
    registry previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by authenticating the Azure CLI in the container registry using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This should return a Login Succeeded message to the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can proceed by preparing the Docker image of our service and
    build the image by triggering the following command in the `Catalog.API` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction creates a new Docker image based on the Dockerfile we already
    have in the project folder. The name of the image will depend on the name specified
    on the `docker-compose.yml` file and `COMPOSE_PROJECT_NAME` specified in the `.env`
    file: if the `COMPOSE_PROJECT_NAME` is `store`, then the command will create an
    image with the `store_catalog_api` name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to verify the resulting image by executing the `docker images`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It is necessary to get the Azure Container Registry server address so that
    we can push the local image to the registry. We can proceed by tagging the container
    that we just created with the server address of the Azure Container Registry we
    created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After tagging the image and using the `docker push` command, Docker will start
    uploading the container into our Azure container repository. Hence, we will be
    able to use our container image in all of the services provided by Azure. This
    upload usually takes some time, depending on the size of the image and the quality
    of your internet connection. When the upload is completed, it is possible to check
    the result by browsing the Container registries section of the Azure portal ([https://portal.azure.com/](https://portal.azure.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ddbea9e-5b47-42b7-81ef-2d5ba99cd8df.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we can see that we have created a container registry called `handsonaspnetcoreacr`
    under the `handsOn` resource group. Eventually, we can choose to create or manage
    the container registry directly from the portal. Now that we've pushed the container,
    we can proceed by configuring ACI.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Azure Container Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ACI service by Microsoft Azure provides us with a fast and easy way to
    run containers in the cloud without worrying about the management part of virtual
    machines or having to learn about new tools. This service is designed to be as
    quick as possible and ease the process of getting a container up and running in
    the cloud. Furthermore, it is possible to launch a container by executing a simple
    Azure CLI command, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The ACI service is the ideal service for testing and running containers in Azure.
    Hence, the ACI service allows us to lower our infrastructure costs by taking advantage
    of *per-second billing*. For that reason, the ACI service is also the favorite
    service for continuous integration and continuous pipeline purposes. The following
    steps show you how to deploy the catalog service on ACI*:*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new resource group so that we can group our containers.
    Use the following command to do so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can proceed by getting the registry username and password of the service
    account of the container registry using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the group, we will need to execute the Azure CLI command using
    a Bash script from the GitHub repository called `aci-deploy.sh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The script mostly runs five different instructions for the creation of new
    instances of these containers:'
  prefs: []
  type: TYPE_NORMAL
- en: It declares information regarding the containers, such as the resource group,
    the names to assign to the containers, and some additional environment variables.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: It executes the `az container create` command to create and run `microsoft/mssql-server-linux`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It executes the `az container create` instruction to create and run the `rabbitmq:3-management-alpine`
    image, and it uses the `rabbitmq_user` and `rabbitmq_pass` environment variables
    to set the default user for the RabbitMQ instance.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It deploys the Redis cache instance using `redis:alpine`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it executes `az container create` to create and deploy the `catalog_api`
    image that's already present in the Azure Container Registry repository by specifying
    the registry URL.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that the execution order follows the same logic of the dependencies
    of these containers; therefore, the API container is run last.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, to keep the demo as simple as possible, the `aci-deploy.sh` script
    creates the catalog service container using `--ip-address public`, which means
    that our container can be accessed by anyone. Directly exposing an API without
    any reverse proxy and an API gateway is strongly discouraged in a production environment
    so that you avoid exposing your containers to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve executed the script, we can see the result by signing into
    the Azure portal ([https://portal.azure.com/#](https://portal.azure.com/#)) and
    checking our container in the Container instances section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69924149-046e-4903-b729-14b57491cd2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there are four container instances up and running. All of them
    are running on DNS using the `--dns-name-label` parameter and can access each
    other through their addresses. Hence, it is possible to call the container API
    using the address that was generated by our shell script. We can also check the
    statistics and the properties associated with the container by clicking on the
    name of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a71ce45-9376-4faf-be99-ef3ee41a0a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can call the health check HTTP route from our browser to verify
    that all of the dependencies are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding process describes how to deploy the catalog service into the ACI
    product. Although ACI are powerful and easy to deploy, they lack some minimal
    out-of-the-box features, such as SSH, monitoring, and configuration management.
    Therefore, it becomes hard to manage container instances in a production environment.
    In the next section, we will focus on a different hosting process that uses app
    service technologies to host the application called app services. This way of
    working is more focused on the hosting of web applications and web services; therefore,
    it provides a set of tools and features for the monitoring and the configuration
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring app services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to ACI is app services. Microsoft Azure recently released a new
    feature so that we can deploy Docker images using **app services**. This kind
    of approach is useful when you want to keep the same environment for your development
    machine and production environment. In contrast to ACI*,* app services provides
    us with a managed way to run our containers. It comes with some out-of-the-box
    features, such as SSL encryption, monitoring, configuration management, remote
    debugging, and application scaling settings. On top of that, app services is strongly
    integrated with other Azure products. Therefore, it is possible to plug other
    services into `catalog-srv` easily. For example, we may choose to run our Azure
    SQL Database solution to set up a fully-managed SQL database for the catalog service.
    Azure SQL provides the broadest SQL Server engine compatibility; it simplifies
    the maintenance process using the SQL tools you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, it is not easy to integrate persistence data storage
    using Docker without using persistent volumes. For that reason, in this section,
    we will look at an alternative way to store data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed by creating a new Azure SQL database by using the `azuresql-deploy.sh`
    script in the root folder of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, the `azuresql-deploy.sh` file creates the logical server
    that hosts the `store` database and the effective database that contains the catalog
    information. First of all, the script proceeds by creating the resource group;
    then, it continues by creating the Azure SQL elements. Since `start-ip` and `end-ip`,
    which are specified in the firewall rules, are both `0.0.0.0`, all of the Azure
    services that are part of that account can connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, it is possible to connect the previously created `catalog-srv`
    app service to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app service using a container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s walk through how to create an app service using the previously published
    image, which is already present in Azure Container Registry, that is, `<registry_name>.azurecr.io/catalog_api:v1`.
    As a first step, we need to create an app service plan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The app service plan is required for the creation of the app service: it defines
    a set of computing resources that are used to run all of the app services that
    are part of the same plan. For this example, we will use the most basic service
    plan, which can be specified using the following flag: `--sku FREE`. This plan
    supports up to 10 instances and it does not provide any additional autoscale capability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created all of the requirements, we can proceed by executing
    the `appservice-deploy.sh` file, which is located in the root of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script creates the web app using the `az webapp create` instruction,
    and after the creation of the app service, it proceeds by executing the `az webapp
    config appsettings set` command to set the right ASP.NET Core environment value.
    Once the script has been executed, we can continue by checking the status of the
    app service in the portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59b4576b-52d0-43ac-94ab-20c0bd57bd3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, we can verify the status of the service by calling the health
    check URL: `http://catalog-api.westeurope.azurecontainer.io/health`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen how we can host and run the catalog service project
    in Microsoft Azure. We also learned how to create a private Azure Container Registry
    and how to store the Docker image of the catalog service. Then, we showed you
    some of the patterns you can use to get a custom container into the cloud and
    how to run them using different services offered by the Microsoft Azure cloud
    provider. Finally, we looked at two different approaches to hosting the catalog
    service: using the ACI product and Azure App Service and storing the data using
    the Azure SQL service.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to document APIs using the OpenAPI Specification
    by implementing the Swagger framework.
  prefs: []
  type: TYPE_NORMAL
