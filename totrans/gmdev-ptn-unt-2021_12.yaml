- en: Implementing Power-Ups with the Visitor Pattern
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement a power-up mechanic for our game.
    Power-ups have been a core ingredient of video games since their early inception.
    One of the first games that implemented power-ups is *Pac-Man* from 1980\. In
    the game, you could eat Power Pellets that would give Pac-Man temporary invincibility.
    Another classic example is the mushrooms in *Mario Bros.*, which made Mario taller
    and more robust.
  prefs: []
  type: TYPE_NORMAL
- en: The power-up ingredients that we will build will be similar to the classics
    but with a little more granularity. Instead of having a power-up boost a singular
    ability of an entity, we can create combos that give out multiple benefits at
    once. For instance, we could have a power-up named "**Protector**"that adds durability
    to the front-facing shield and increments the strength of the primary weapon.
  prefs: []
  type: TYPE_NORMAL
- en: And so, in this chapter, we are going to implement a power-up mechanic that's
    scalable and configurable, not just for us programmers but also for designers
    that might be assigned the responsibility of creating and adjusting unique power-up
    ingredients. We will achieve this using a combination of the Visitor pattern and
    a unique Unity API feature named ScriptableObjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic principles behind the Visitor pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of a power-up mechanic for a racing game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section includes simplified code examples for the sake of simplicity and
    readability. If you wish to review a complete implementation in the context of
    an actual game project, open the `FPP` folder in the GitHub project, the link
    for which can be found under the *Technical requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#. We will be using the following Unity engine and C# language concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScriptableObjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter. The code files for this chapter can be found on [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)[.](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [https://bit.ly/3eeknGC](https://bit.ly/3eeknGC)[.](https://bit.ly/3eeknGC)
  prefs: []
  type: TYPE_NORMAL
- en: We often use ScriptableObjects in the code examples of this book because when
    building game systems and mechanics, it is essential to make them easily configurable
    by non-programmers. The process of balancing systems and authoring new ingredients
    usually falls under the responsibility of game and level designers. Therefore,
    we use ScriptableObjects because it offers a consistent way of establishing an
    authoring pipeline to create and configure in-game assets.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Visitor pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of the Visitor pattern is simple once you grasp it; a *Visitable* object
    permits a *Visitor* to operate on a specific element of its structure. This process
    allows the visited object to acquire new functionality from visitors without being
    directly modified. This description might seem very abstract at first, but it
    is easier to visualize if we imagine an object as a structure instead of a closed-off
    container of data and logic. Therefore, it is possible with the Visitor pattern
    to traverse an object's structure, operate on its elements, and extend its functionality
    without modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to imagine the Visitor pattern in action is by visualizing the bike
    in our game colliding with a power-up. Like an electronic current, the power-up
    flows through the inner structure of the vehicle. Components marked as visitable
    get visited by the power-up, and new functionalities are added, but nothing is
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can visualize those principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84326d4d-0653-464b-9d6c-eb5f5d361c0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 - UML diagram of the Visitor pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key participants in this pattern that we need to know well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IVisitor** is the interface that a class that wishes to be a visitor must
    implement. The visitor class will have to implement a visitor method per visitable
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IVisitable** is the interface that classes that wish to become visitable
    must implement. It includes an `accept()` method that offers an entry point to
    a visitor object to come and visit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before proceeding, it is essential to declare that the code example that we
    will review in the upcoming sections breaks a potential rule of the Visitor pattern.
    In the example, the visitor object changes some of the properties of the visited
    objects. However, whether this transgresses the integrity of the pattern and invalidates
    its original design intention is open to debate.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, in this chapter, we focus more on how the Visitor pattern permits
    us to traverse the elements that compose the structure of visitable objects. In
    our use case, this structure represents the core elements of our bike, which include
    the engine, shield, and primary weapon.
  prefs: []
  type: TYPE_NORMAL
- en: The Visitor is considered by some to be one of the hardest patterns to understand.
    So don't feel bad if you don't grasp its core concepts at first. I believe one
    reason it's a difficult pattern to learn is that it's one of the hardest patterns
    to explain.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits and drawbacks of the Visitor pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've written a short list of the benefits and drawbacks of using this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open/Closed**: You can add new behaviors that can work with objects of different
    classes without modifying them directly. This approach follows the object-oriented
    programming principle of Open/Closed that states that entities should be open
    for extension but closed for modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '** Single Responsibility**: The Visitor pattern can adhere to the single responsibility
    principle in the sense you can have an object (visitable) that holds the data
    and another object (visitor) is responsible for introducing specific behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the potential drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessibility**: Visitors could lack the necessary access to specific private
    fields and methods of the elements that they are visiting. Therefore, we might
    need to expose more public properties in our classes than we usually would if
    we didn''t use the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: We could argue that the Visitor pattern is structurally more
    complex than straightforward patterns such as the Singleton, State, and Object
    Pool. Therefore, it could bring a degree of complexity to your code base that
    other programmers might find confusing if they are not familiar with the structure
    and intricacies of the pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Visitor uses a software engineering concept in its fundamental design named **Double
    Dispatch**. The simplest definition of the concept is that it's a mechanism that
    relegates a method call to different concrete methods depending on the types of
    two objects implicated in the call at runtime. *It's not essential to comprehend
    this concept completely to follow the example of the pattern presented in this
    chapter.*
  prefs: []
  type: TYPE_NORMAL
- en: Designing a power-up mechanic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned at the beginning of this chapter, the power-up is a staple of
    video games. And it''s a core ingredient of our game. But first, we will review
    some of the key specifications of our mechanic:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granularity**: Our power-up entities will have the ability to boost multiple
    properties at the same time. For example, we could have a power-up that increases
    offensive capabilities such as the primary weapon''s range while repairing the
    front-facing shield.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time**: The power-up effects are not temporal so they don''t expire after
    a certain amount of time. And the benefits of the next power-up are added on top
    of the previous one until they hit the maximum settings of the boosted properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take note that these specifications are limited to the following code example,
    but are not final. We could easily make the benefits of a power-up temporary or
    change the overall design of the mechanic with slight changes to the code example
    presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Our level designers will position the power-ups in strategic points across the
    race track; they will have 3D shapes that are easy to spot at high speed. The
    player will have to collide with a power-up to activate the abilities and benefits
    it contains.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a combination of the Visitor pattern and ScriptableObjects to implement
    this game mechanic so designers can author new variations of power-ups without
    needing to write a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: In video games, the core difference between an item and a power-up is that a
    player can collect items, store them, and choose when to use their benefits. But
    in contrast, a power-up takes effect immediately after the player touches it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a power-up mechanic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write the necessary skeleton code to implement a power-up
    system with the Visitor pattern. Our goal is to have a valid proof of concept
    by the end of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the power-up system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the steps for implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by writing a core element of the pattern, the `Visitor` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we are going to code an interface that each visitable element will
    have to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our primary interfaces, let''s implement the main class that
    makes our power-up mechanism work; because of its length, we will review it in
    two parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to notice is that this class is a `ScriptableObject` with a
    `CreateAssetMenu` attribute. Therefore, we will be able to use it to create new
    power-up assets from the Asset menu. And then, we will be able to configure the
    parameters of each new power-up in the engine''s Inspector. But another important
    detail is that this class implements the `IVisitor` interface, which we will review
    in the following part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, for each visitable element, we have a unique method associated
    with it; inside each of them, we implement the operation we want to execute when
    visiting a specific element.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are changing specific properties of the visited object while
    taking into account the defined maximum values. Therefore, we encapsulate the
    expected behavior of a power-up when it visits a specific visitable element of
    the bike's structure inside individual `Visit()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: We need to change specific values, modify operations, and add new behaviors
    for a particular visitable element; we can do these things inside this single
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `BikeController` class, responsible for controlling the bike''s
    key components that comprise its structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the class is implementing the `Accept()` method from the `IBikeElement`
    interface. This method will get called automatically when the bike collides with
    a power-up item positioned on the race track. And through this method, a power-up
    entity will be able to pass a visitor object to the `BikeController`.
  prefs: []
  type: TYPE_NORMAL
- en: The controller will proceed to forward the received visitor object to each of
    its visitable elements. And the visitable elements will get their properties updated
    as configured in the instance of the visitor object. Hence, this is how the power-up
    mechanism is triggered and operates.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to implement our individual visitable elements, starting with our
    skeleton `BikeWeapon` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `BikeEngine` class; take note that in a complete implementation,
    this class would have the responsibility of simulating some of the behaviors of
    an engine, including activating the turbocharger, managing the cooling system,
    and controlling the speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `BikeShield`, the name of which implies its main function, is
    done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, each individual visitable bike element class implements the `Accept()`
    method, thus making themselves visitable.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the power-up system implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly test our implementation in your own instance of Unity, you need
    to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy all the scripts we just reviewed into your Unity project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a GameObject to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the following `ClientVisitor` script to the new GameObject:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Go to the **Assets/Create** menu option and create three `PowerUp` assets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure and name the new `PowerUp` assets with your desired parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `PowerUp` assets and adjust their parameters in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the new `PowerUp` assets to the public properties of the `ClientVisitor`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you start the scene, you should see the following GUI buttons and debug
    output on your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c84cf0c5-925b-4d5f-af9f-4cd806b5e0ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 - Screenshot of the code example in action
  prefs: []
  type: TYPE_NORMAL
- en: But you might be asking yourself, how do I create an actual pickup entity that
    I can spawn on the race track?
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick way to do this is simply to create a `Pickup` class like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By attaching this script to a GameObject with a collider component configured
    as a trigger, we can detect when an entity with the `BikeController` component
    enters the trigger. Then we just need to call its `Accept()` method and pass the
    `PowerUp` instance. Setting up triggers is beyond the scope of this chapter, but
    I recommend looking at the FPP project in the Git repo to review how we set it
    up in a playable prototype of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the power-up system implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were able to combine the structure of the Visitor pattern and the API features
    of ScriptableObjects to create a power-up mechanic that permits anyone on our
    project to author and configure new power-ups without writing a single line of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to adjust how power-ups affect various components of our vehicle,
    we can do so by modifying a single class. So, in conclusion, we achieved a degree
    of scalability while keeping our code easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The implementations of the standard software design patterns in this book are
    experimental and adapted in creative ways. We are adapting them to utilize Unity
    API features and adjusting them for game development use cases. So we should not
    consider the examples to be academic or standardized references, just interpretations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter of the book, we built a power-up mechanic for our game using
    the Visitor pattern as our foundation. We also established a workflow to create
    and configure power-ups. Therefore, we combined the technical and creative mindsets,
    which is the core of game development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to design and implement attack maneuvers for
    enemy drones. We are going to use the Strategy pattern as the foundation of our
    system.
  prefs: []
  type: TYPE_NORMAL
