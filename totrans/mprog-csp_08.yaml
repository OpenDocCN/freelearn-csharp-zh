- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and Executing Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions in C# are not just great to use as a means of capturing metadata
    and reason about code; you can also generate expression trees, either based on
    code represented as lambdas, as we saw in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118),
    *Reasoning about Expressions*, or by programmatically adding the different expression
    node types yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The expressions that you build can then be executed. And with the breadth of
    capabilities offered with expressions, they’re almost as powerful as generating
    intermediate language code, as we saw in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098),
    *Dynamic Proxy Generation*. Since every expression is code that sits inside the
    specific expression that is executed and performs the task of the expression,
    you can’t expect the same level of performance as with generating intermediate
    language that runs natively on the .NET runtime. So, it depends on your use case
    whether or not you should pick expression generation over proxy generation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into how we can leverage expressions to express
    our intent and execute them, and hopefully get some inspiration as to what they
    can be useful for.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating expressions as delegates and executing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a query engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this chapter, you should understand how expression trees are constructed
    and how you can leverage them to generate logic dynamically that can then be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter8))
    and it builds on top of the **Fundamentals** code that is found here: [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions are pretty much as powerful and capable as the .NET runtime. That
    means that we can express all operations that the intermediate language holds
    and eventually the runtime executes. Constructs are very different from the intermediate
    language, as we saw in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118), *Reasoning
    about Expressions*. They’re all focused around a tree structure with left and
    right expressions representing the nodes in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: With expressions, we don’t necessarily need to limit ourselves to using them
    as a means to filter data, but we could in fact use them to hold logic that performs
    operations. Since they are just as powerful as the intermediate language, we could
    go and generate very complex expression trees.
  prefs: []
  type: TYPE_NORMAL
- en: But with great power comes great responsibility. Even though this is possible,
    it doesn’t mean it’s necessarily a good idea. The structures can be hard to understand
    and debug, so I would recommend not going all in and treating it as a new programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a type we want to manipulate the property of. For simplicity,
    let’s make our type a simple type with a string property that we want to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For this sample, we want to manipulate the **StringProperty** property, so we’re
    making it a **class** rather than a **record**, enabling us to manipulate its
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an expression representing the property we need to build, start off
    with something that represents the type the property belongs to. The owning type
    will also be represented by an expression. For this sample, we don’t want the
    expression to create an instance of the **MyType** type but rather manipulate
    an existing one. The instance it will be working on is represented by a parameter
    for the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The parameter takes the type of the parameter. But you can also give it a name
    with one of the overloads of the **.Parameter()** method, which can be very useful
    for debugging information if one has multiple parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to work with the property, we need to use C# reflection to get the **PropertyInfo**
    for the property we want to manipulate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the parameter representing the instance, we will manipulate the actual
    property. We can now create an expression representing the property on the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we want to do is then to do the actual assignment. For this,
    we use the **Expression.Assign()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The **Expression.Assign()** method takes the left-hand expression representing
    the target while the right-hand expression is the source. In the code, we assign
    it a constant of **Hello world**.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is a very simple sample and doesn’t really do much. You can
    really go to town with expressions and leverage things such as **Expression.IfThen()**
    and **Expression.IfElse()** for **if**/**else** statements and you can even go
    and do **Expression.Call()** to invoke methods, passing along arguments and dealing
    with the result. Results can be manipulated with things such as **Expression.Add()**
    and **Expression.Subtract()**. Anything you can imagine can be done. For this
    book, we’ll just keep it simple with regard to building expressions representing
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions aren’t really useful unless we can invoke them and get the result.
    What we want to do is build out the expression tree we want and then be able to
    quite easily call them with standard C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating expressions as delegates and executing them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can think of expressions as methods or functions we can call. They might
    have parameters or not and they might return results or not. We can represent
    the expressions as either **Action** or **Func**. Both are delegate types found
    in the **System** namespace. **Action** represents a parameter-less action that
    can, if you need to, return results. While **Func** represents a function that
    has one or more parameters and can return a result. Both of these delegate types
    can take generic parameters representing the input parameter types and the result
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are basically just representations of methods. They define a callable
    signature. We can invoke delegates as methods directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With expressions, we can turn them into a callable expression. This is done
    through **Expression.Lambda()**. Let’s build on the property assign expression
    we had earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the following lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The **Expression.Lambda()** method takes a generic parameter – the type of delegate.
    This delegate can be whatever delegate type you want – your own custom delegate
    or just use either **Action** or **Func**. For this example, we’ll use **Action<MyType>**
    since we are going to just call the expression and it will manipulate the instance
    we give it. We pass along the expression representing the assignment of the value
    and then the definition of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the lambda expression in place, we can compile the expression down to
    a callable delegate and call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code calls the **.Compile()** method, which will then compile the expression
    down into a delegate we can invoke directly. It creates an instance of the **MyType**
    type and passes it along to the delegate. Running the program, you should now
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward and this example probably doesn’t show the full
    potential.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a query engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s switch gears a little bit and increase the complexity a couple of levels
    and make it a little bit more relevant. One thing we could use expressions for
    is as a way to do dynamic querying of data. Some applications might want to even
    give the end user the ability to create arbitrary queries for your data. I’ve
    worked on solutions that offered this type of power to the end user, which can
    be a tough problem to solve if you’re providing a flexible query system for the
    end user without something such as expressions. I’ve seen solutions that basically
    just expose SQL directly to the end user instead of trying to tackle this problem.
    Giving this level of power to the end user can cause problems in the future. What
    you end up doing is completely obliterating all abstractions between your data
    storage and your end users. Good luck changing technologies or supporting multiple
    data storage mechanisms. But luckily, we have the power of expressions in our
    hands, giving us the opportunity to create an abstraction that puts us in the
    pit of success.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions, as discussed in [*Chapter 7*](B19418_07.xhtml#_idTextAnchor118),
    *Reasoning about Expressions*, are disconnected from how they are translated for
    execution for the target data source. As long as we keep our expression trees
    simple enough, it should be possible to execute them optimally for the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Building out an interactive query user interface is involved, so for this book,
    let’s make it a bit more developer-centric and make our query interface a JSON
    document. We want to create a data store that can hold data with the capability
    of being queried with a defined query language.
  prefs: []
  type: TYPE_NORMAL
- en: A MongoDB-like database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build something that resembles a document database. MongoDB can be a good
    blueprint for this. Obviously, we’re not going to be building a fully capable
    document database but will use the characteristics of one and also be inspired
    by them.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB has a query language that is very much like JSON, meaning that you
    construct the different clauses as key/value expressions. Let’s say we have a
    document in JSON that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With a MongoDB-like syntax, we can do a query that does an equals match for
    the **LastName** property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To add more properties that needs to match – a typical **And** operation –
    you just simply add another property as a key/value with the value you want it
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes you have **Or** statements, saying *this* or *this*, with MongoDB
    that would be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to do queries that need a value to be greater than, less than,
    or similar to, you would need an object structure for the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in MongoDB, keywords are prefixed with **$**. We’re not going
    to implement them all, but just a few – enough to make it interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple query engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the requirements in place, we’re now ready to start building out the engine
    that will be able to parse queries and create expressions that we can call from
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder called **Chapter8**. Change into this folder in
    your command-line interface and create a new console project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a file called **QueryParser.cs**. Add the following to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code adds the namespaces we’re going to need for this to work and then adds
    a class that holds, for now, a representation of the parameter we’re going to
    pass into the query evaluation expression that we will have at the end.
  prefs: []
  type: TYPE_NORMAL
- en: One of the characteristics of document databases is that, by default, they don’t
    have a definition of the shape of objects being put into them, unlike a SQL database,
    which has a table definition with columns. To mimic that behavior, you’re going
    to be using a key/value dictionary represented as **IDictionary<string, object>**.
    This is the parameter of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query expressions will have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That means we need to build the correct left value expression and right value
    expression. Add the following method to the **QueryParser** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code is based on the fact that your query is coming in as a JSON construct.
    It’s built for recursion, which is why it takes a **parentProperty** and a **property**.
    This is to support more than the **equals** operand and support the nested **greater
    than** type of operands. At the top level, the **parentProperty** and **property**
    will be the same, while when we do the nested ones, we need the **parentProperty**
    and not the **property** in the nested expression as that represents the operand
    and value.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the code does is create an expression that accesses the dictionary.
    This is done by using the **Item** property that exists on **IDictionary<string,
    object>**. The **Item** property is not a property you’ll see on the interface.
    It represents the indexer when you typically index using **["SomeString"]**. Indexers
    are properties that take an argument. The code, therefore, sets up an **IndexerExpression**
    by using one of the overloads of the **Expression.Property()** method. It passes
    the indexer property and a constant that represents the property on the document.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing the code needs to do is make sure the value being returned is
    of the correct type. Since we have **IDictionary<string, object>**, the values
    are represented as **object**. You do this to be able to use the different operands
    (**=**, **>**, **<**). If you don’t do this, you’ll get an exception because it
    will not know how to deal with comparing **object** to the actual type of the
    right-hand expression.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are value types and need to be unboxed, while strings and Booleans need
    to cast to their actual type.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: JSON numbers are hardcoded to be an **int**. This is just a simplification for
    this sample. Numbers could be more than that, such as **float**, **double**, **Int64**,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have your left-hand expression, you’ll need the right-hand expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code creates constant expressions that get the value in the correct type.
    On the **JsonProperty** type, the **Value** property is the **JsonElement** type.
    It has methods for getting the actual value in the type you’re expecting. Since
    the query engine is somewhat limited in types, it just supports **int**, **string**,
    and **bool**.
  prefs: []
  type: TYPE_NORMAL
- en: With the right-hand side also in place, you’re going to need something that
    builds on both the left- and right-hand expressions and puts them together as
    an expression you can use. The defined query capabilities include being able to
    do **greater than**, **less than**, and more and we have defined that as a complex
    object as the value in the key/value part of the query JSON. With that, you need
    a method that builds the correct expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the **QueryParser** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The code enumerates the object given and makes it possible to have more than
    one clause. It groups these as **And** operations. It leverages the methods you
    created earlier to get the left- and right-hand expressions and then for each
    supported operand, uses these to create the correct operand expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the **GetNestedFilterExpression** method is only dealing with the nested
    filter clauses based on an object, you need a method that will deal with the top-level
    clause and call into the nested one if it’s a nested object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Based on the kind of value, the code chooses to use the nested expression only
    if it’s an object representation. For everything else, it creates a simple **equal**
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we discussed having the ability to do Or operations and not just And
    operations. Add the following method to the **QueryParser** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We defined the Or expressions as an array of expressions. The code enumerates
    the value as an array and for each element, it calls **GetQueryExpression** –
    the next method we’ll be needing. From the result, it creates an **OrElse** expression.
    The reason for the **OrElse** expression is that we only want to evaluate the
    Or if the prior expression evaluates to **false**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and add the following method to the **QueryParser** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since the query JSON can consist of multiple statements, the code enumerates
    the object and evaluates each property. If it is an Or expression, it calls the
    **GetOrExpression** method. Anything else goes to the **GetFilterExpression**.
    This is the place you could be adding more operations. For each of the properties
    in the query, it will And them together.
  prefs: []
  type: TYPE_NORMAL
- en: With the **GetQueryExpression** method in place, we have all the logic for the
    query engine in place. Now we need an entry point from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the **QueryParser** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The **Parse** method takes a JSON document representing the query and returns
    an expression that is meant to be used with single documents where each document
    is **IDictionary<string, object>**. It calls into **GetQueryExpression** to create
    the actual expression based on the root element of the JSON and then wraps the
    expression in a callable **lambda** expression that takes a dictionary as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your query engine in place, it’s time to create some data
    and a query, and some code to test it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called **data.json** and add the following or your own content to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the query itself, add a file called **query.json** and add the following
    or your own query to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You then want to have code that parses these files and creates an expression
    from the **query.json**.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to parse the **data.json** file and get a nice collection of **Dictionary<string,
    object>** types, we need a JSON converter. By default, if you try to deserialize
    JSON into this, the serializer will give you a **JsonElement** for the value.
    We want the actual value. The JSON converter listing and walk-through have no
    value in this context. They can be found in the GitHub repository referenced at
    the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Program.cs** file, replace everything with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code loads the **query.json** and the **data.json** files and parses them.
    For the query, you need it as a **JsonDocument** before it’s passed into the **QueryParser.Parse()**
    method, while the data is deserialized into a collection of **Dictionary<string,
    object>**.
  prefs: []
  type: TYPE_NORMAL
- en: Since the documents are **IEnumerable**, you don’t get the **.Where()** extension
    methods you’re looking for. The code therefore does a **.AsQueryable()** first
    and then passes the parsed query expression into it.
  prefs: []
  type: TYPE_NORMAL
- en: The filtered objects can then be enumerated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code should give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this approach rather than presenting something such as SQL to
    the end user is that you now have an abstraction that works with different data
    stores. You can even apply the same expression in memory as you would for a database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the power of building out expressions
    and expression trees. Not only can they represent queries but, in fact, they can
    be just as powerful as generating intermediate language code.
  prefs: []
  type: TYPE_NORMAL
- en: With expressions, you get an alternative to intermediate language. They do have
    some limitations over generating intermediate language code, such as you can’t
    simply create types and implement interfaces or override the behavior of virtual
    methods inherited. But as a tool for expressing simpler actions, they are really
    great.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at yet another approach to dynamically creating
    types and implementations by leveraging the capabilities of the **Dynamic** **Language
    Runtime**.
  prefs: []
  type: TYPE_NORMAL
