<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-97" class="chapter-number"><a id="_idTextAnchor097"/>4</h1>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Advanced MVVM Concepts</h1>
			<p>After learning the basics of the MVVM pattern and its implementation in WinUI, it’s now time to build on that knowledge base to handle some more advanced techniques. Now, you will learn how to keep components loosely coupled and testable when adding new dependencies to <span class="No-Break">the project.</span></p>
			<p>Few modern applications have only a single page or window. There are MVVM techniques that can be leveraged to navigate between pages from a <strong class="source-inline">ViewModel</strong> command without being coupled to the <span class="No-Break">UI layer.</span></p>
			<p>In this chapter, you will learn about the <span class="No-Break">following concepts:</span></p>
			<ul>
				<li>Understanding the basics of <strong class="bold">Dependency </strong><span class="No-Break"><strong class="bold">Injection</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DI</strong></span><span class="No-Break">)</span></li>
				<li>Leveraging DI to expose <strong class="source-inline">ViewModel</strong> classes to <span class="No-Break">WinUI views</span></li>
				<li>Using MVVM and <strong class="source-inline">x:Bind</strong> to handle additional UI events with event handlers in <span class="No-Break">the ViewModel</span></li>
				<li>Navigating between pages with MVVM <span class="No-Break">and DI</span></li>
			</ul>
			<p>By the end of this chapter, you will have a deeper understanding of the MVVM pattern and will know how to decouple your view models from any <span class="No-Break">external dependencies.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, please reference the <em class="italic">Technical requirements</em> section in <a href="B20908_02.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Configuring the Development Environment and Creating </em><span class="No-Break"><em class="italic">the Project</em></span><span class="No-Break">.</span></p>
			<p>You will find the code files for this chapter <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Understanding the basics of DI</h1>
			<p>Before <a id="_idIndexMarker304"/>starting down the path of using DI in our project, we should take some time to understand what DI is and why it is fundamental for building modern applications. You <a id="_idIndexMarker305"/>will often see DI referenced with another related concept, <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>). Let’s discuss these two concepts by doing <span class="No-Break">the following:</span></p>
			<ul>
				<li>Clarify the relationship <span class="No-Break">between them</span></li>
				<li>Prepare you to use DI properly in <span class="No-Break">this chapter</span></li>
			</ul>
			<p>DI is used by modern developers to inject dependent objects into a class rather than creating instances of the objects inside the class. There are several ways to inject <span class="No-Break">those objects:</span></p>
			<ul>
				<li><strong class="bold">Method injection</strong>: Objects are <a id="_idIndexMarker306"/>passed as parameters to a method in <span class="No-Break">the class</span></li>
				<li><strong class="bold">Property injection</strong>: Objects <a id="_idIndexMarker307"/>are set <span class="No-Break">through properties</span></li>
				<li><strong class="bold">Constructor injection</strong>: Objects <a id="_idIndexMarker308"/>are passed as <span class="No-Break">constructor parameters</span></li>
			</ul>
			<p>The most common method of DI is constructor injection. In this chapter, we will be using both property injection and constructor injection. Method injection will not be used because it is not common to use methods to set a single object’s value in .NET projects. Most developers use properties for <span class="No-Break">this purpose.</span></p>
			<p>IoC is<a id="_idIndexMarker309"/> the concept that a class should not be responsible for (or have knowledge of) the creation of its dependencies. You’re inverting control over object creation. This sounds a bit like DI, doesn’t it? Well, DI is one method of achieving this IoC in your code. There are other ways to implement IoC, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Delegate</strong>: This <a id="_idIndexMarker310"/>holds a reference to a method that can be used to create and return <span class="No-Break">an object</span></li>
				<li><strong class="bold">Event</strong>: Like a <a id="_idIndexMarker311"/>delegate, this is typically used in association with user input or other <span class="No-Break">outside actions</span></li>
				<li><strong class="bold">Service Locator Pattern</strong>: This is<a id="_idIndexMarker312"/> used to inject the implementation of a service <span class="No-Break">at runtime</span></li>
			</ul>
			<p>When you separate the responsibilities of object creation and use, it facilitates code reuse and <span class="No-Break">increases testability.</span></p>
			<p>The classes that will be taking advantage of DI in this chapter are views and ViewModels. So, if we will not be creating instances of objects in those classes, where will they be created? Aren’t we just moving the tight coupling somewhere else? In a way, that is true, but the coupling will be minimized by centralizing it to one part of the project, the <strong class="source-inline">App.xaml.cs</strong> file. If you remember from the previous chapter, the <strong class="source-inline">App</strong> class is where we handle application-wide actions <span class="No-Break">and data.</span></p>
			<p>We are going to use a <strong class="bold">DI container</strong> in the <strong class="source-inline">App</strong> class to manage the application’s dependencies. A DI container<a id="_idIndexMarker313"/> is responsible for creating and maintaining the lifetime of the objects it manages. The object’s lifetime in the container is usually either <em class="italic">per instance</em> (each object request returns a new instance of the object) or a <em class="italic">singleton</em> (every object request returns the same instance of the object). The container is configured in the <strong class="source-inline">App</strong> class, and it makes instances available to other classes in <span class="No-Break">the application.</span></p>
			<p>In .NET 6 and later, DI is now a part of .NET itself. We will leverage the <strong class="bold">host builder</strong> configuration<a id="_idIndexMarker314"/> in .NET to register our application’s dependencies and resolve them in the classes where they <span class="No-Break">are needed.</span></p>
			<p>There are a <a id="_idIndexMarker315"/>number of other DI implementations that can be leveraged from MVVM frameworks. If you would like to explore some of them, here are their <span class="No-Break">respective links:</span></p>
			<ul>
				<li><strong class="bold">Unity</strong>: This<a id="_idIndexMarker316"/> DI implementation supports all types of .NET applications and has a full-featured IOC <span class="No-Break">container (</span><a href="http://unitycontainer.org/articles/introduction.html)&#13;"><span class="No-Break">http://unitycontainer.org/articles/introduction.html)</span></a></li>
				<li><strong class="bold">DryIoc</strong>: This<a id="_idIndexMarker317"/> small, lightweight IOC container supports .NET Standard 2.0 and .NET 4.5 and later <span class="No-Break">applications (</span><a href="https://github.com/dadhi/DryIoc"><span class="No-Break">https://github.com/dadhi/DryIoc</span></a><span class="No-Break">)</span></li>
				<li><strong class="bold">Prism</strong>: This <a id="_idIndexMarker318"/>MVVM framework does not support WinUI 3, but developers can still leverage the DI <span class="No-Break">capabilities (</span><a href="https://prismlibrary.com/docs/dependency-injection/index.html"><span class="No-Break">https://prismlibrary.com/docs/dependency-injection/index.html</span></a><span class="No-Break">)</span></li>
			</ul>
			<p>These concepts will be easier to understand as we implement the code in our application. Now, it’s time to see DI and DI containers <span class="No-Break">in practice.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Using DI with ViewModel classes</h1>
			<p>Most of the popular <a id="_idIndexMarker319"/>MVVM frameworks<a id="_idIndexMarker320"/> today include a DI container to manage dependencies. Because .NET now includes its own DI container, we will use that one. The .NET team has incorporated the DI container that used to be bundled<a id="_idIndexMarker321"/> with <strong class="bold">ASP.NET Core</strong>. It’s both lightweight and easy to use. Luckily, this container is now available to all types of .NET projects via<a id="_idIndexMarker322"/> a <span class="No-Break"><strong class="bold">NuGet</strong></span><span class="No-Break"> package:</span></p>
			<ol>
				<li>Open the project from the previous chapter or use the project in the <strong class="source-inline">Start</strong> folder in the GitHub repository for this chapter. In the <strong class="source-inline">MyMediaCollection</strong> project, open <strong class="bold">NuGet Package Manager</strong> and search <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Microsoft.Extensions.Hosting</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B20908_04_01.jpg" alt="Figure 4.1 – Microsoft’s DI NuGet package"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Microsoft’s DI NuGet package</p>
			<ol>
				<li value="2">Select the package and install the latest stable version. After the installation completes, close the <strong class="bold">NuGet Package Manager</strong> tab and open <strong class="source-inline">App.xaml.cs</strong>. We will make a few changes here to start using the <span class="No-Break">DI container.</span><p class="list-inset">The DI container implements DI through interfaces called <strong class="source-inline">IHostBuilder</strong> and <strong class="source-inline">IServiceCollection</strong>. As the names imply, they are intended to create a collection of services for the application through a shared host. However, we can add any type of class to the container. Its use is not restricted to services. <strong class="source-inline">IServiceCollection</strong> builds the container, implementing the <strong class="source-inline">IServiceProvider</strong> interface. In the following steps, you will add support for DI to <span class="No-Break">the application.</span></p></li>
				<li>The first thing you should do is add a <strong class="source-inline">public</strong> property to the <strong class="source-inline">App</strong> class that makes the host container available to <span class="No-Break">the project:</span><pre class="source-code">
public static IHost HostContainer { get; private set;
}</pre><p class="list-inset">Here, <strong class="source-inline">get</strong> is public, but the property has a <strong class="source-inline">private set</strong> accessor. This restricts the <a id="_idIndexMarker323"/>creation of the container<a id="_idIndexMarker324"/> to the <strong class="source-inline">App</strong> class. Don’t forget to add the required <strong class="source-inline">using</strong> statements to <span class="No-Break">the code:</span></p><pre class="source-code">using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;</pre></li>				<li>The next step is to create a new method that initializes the container, sets it to the <strong class="source-inline">public</strong> property, and adds our <span class="No-Break">first dependency:</span><pre class="source-code">
private void RegisterComponents()
{
    HostContainer = Host.CreateDefaultBuilder()
        .ConfigureServices(services =&gt;
    {
        services.AddTransient&lt;MainViewModel&gt;();
    }).Build();
}</pre><p class="list-inset">In the new <strong class="source-inline">RegisterComponents</strong> method, we are creating <strong class="source-inline">HostContainer</strong> and its service collection, registering <strong class="source-inline">MainViewModel</strong> as a <strong class="bold">transient</strong> (one instance per container request) object, and using the <strong class="source-inline">Build</strong> method to create and return the DI container. Although it’s not strictly required, when adding multiple types to the container, it’s a good practice to add dependent objects to the service collection first. We’ll be adding more items to the <span class="No-Break">container soon.</span></p></li>				<li>Finally, you will call <strong class="source-inline">RegisterComponents</strong> before creating the instance of <strong class="source-inline">MainWindow</strong> in the <strong class="source-inline">App.OnLaunched</strong> <span class="No-Break">event handler:</span><pre class="source-code">
protected override void
OnLaunched(LaunchActivatedEventArgs args)
{
<strong class="bold">    RegisterComponents();</strong>
<strong class="bold">    m_window = new MainWindow();</strong>
    m_window.Activate();
}</pre></li>			</ol>
			<p>That’s all the <a id="_idIndexMarker325"/>code needed to create and expose <a id="_idIndexMarker326"/>the DI container to the application. Now that we are delegating the creation of <strong class="source-inline">MainViewModel</strong> to the container, you can remove the property that exposes a static instance of <strong class="source-inline">MainViewModel</strong> from the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> class.</span></p>
			<p>Using the ViewModel controlled by the container is simple. Go ahead and open <strong class="source-inline">MainWindow.xaml.cs</strong> and update the <strong class="source-inline">ViewModel</strong> property to remove the initialization. Then, set the value of the <strong class="source-inline">ViewModel</strong> property using <strong class="source-inline">HostContainer.Services.GetService</strong> from the <strong class="source-inline">App</strong> class before the call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">InitializeComponent</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public MainWindow()
{
    ViewModel = App.HostContainer.Services
      .GetService&lt;MainViewModel&gt;();
    this.InitializeComponent();
}
public MainViewModel ViewModel;</pre>			<p>If you build and run the application now, it will work just as it did before. However, now our <strong class="source-inline">MainViewModel</strong> instance will be registered in the <strong class="source-inline">App</strong> class and managed by the container. As new models, view models, services, and other dependencies are added to the project, they can be<a id="_idIndexMarker327"/> added to the <strong class="source-inline">HostContainer</strong> in <a id="_idIndexMarker328"/>the <span class="No-Break"><strong class="source-inline">RegisterComponents</strong></span><span class="No-Break"> method.</span></p>
			<p>We will be adding page navigation to the app<a id="_idIndexMarker329"/> later in this chapter. First, let’s discuss the <span class="No-Break"><strong class="bold">event-to-command</strong></span><span class="No-Break"> pattern.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Leveraging x:Bind with events</h1>
			<p>In the previous chapter, we bound <strong class="source-inline">ViewModel</strong> commands to the <strong class="source-inline">Command</strong> properties of the <strong class="bold">Add Item</strong> and <strong class="bold">Delete Item</strong> buttons. This works great and keeps the ViewModel decoupled from the UI, but what happens if you need to handle an event that isn’t exposed through a <strong class="source-inline">Command</strong> property? For<a id="_idIndexMarker330"/> this scenario, you have <span class="No-Break">two </span><span class="No-Break"><a id="_idIndexMarker331"/></span><span class="No-Break">options:</span></p>
			<ul>
				<li>Use a custom behavior such as <strong class="source-inline">EventToCommandBehavior</strong> in the .NET MAUI Community Toolkit. This allows you to wire up a command in the ViewModel to <span class="No-Break">any event.</span></li>
				<li>Use <strong class="source-inline">x:Bind</strong> in the view to bind directly to an event handler on the <span class="No-Break">view model.</span></li>
			</ul>
			<p>In this application, we will use <strong class="source-inline">x:Bind</strong>. This option will provide compile-time type checking and added performance. If you want to learn more about the .NET MAUI Community Toolkit, you can read the documentation<a id="_idIndexMarker332"/> on Microsoft <span class="No-Break">Learn: </span><a href="https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior"><span class="No-Break">https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/event-to-command-behavior</span></a><span class="No-Break">.</span></p>
			<p>We want to<a id="_idIndexMarker333"/> provide users of the <strong class="bold">My Media Collection</strong> application <a id="_idIndexMarker334"/>with the option to double-click (or double-tap) a row on the list to view or edit its details. The new <strong class="bold">Item Details</strong> window will be added in the next section. Until then, double-clicking an item will invoke the same code as the <strong class="bold">Add Item</strong> button, as this will become the <strong class="bold">Add/Edit Item</strong> <span class="No-Break">button later:</span></p>
			<ol>
				<li>Start by adding an <strong class="source-inline">ItemRowDoubleTapped</strong> event handler to the <strong class="source-inline">MainViewModel</strong> class that calls the existing <span class="No-Break"><strong class="source-inline">AddEdit</strong></span><span class="No-Break"> method:</span><pre class="source-code">
public void ListViewDoubleTapped(object sender,
DoubleTappedRoutedEventArgs args)
{
    AddEdit();
}</pre></li>				<li>Next, bind the <strong class="source-inline">ListView.DoubleTapped</strong> event to <span class="No-Break">the ViewModel:</span><pre class="source-code">
&lt;ListView Grid.Row="1" ItemsSource="{x:Bind
    ViewModel.Items}"
    SelectedItem="{x:Bind
    ViewModel.SelectedMediaItem,
    Mode=TwoWay}"
    <strong class="bold">DoubleTapped="{x:Bind ViewModel</strong>
<strong class="bold">      .ListViewDoubleTapped}"</strong>&gt;</pre></li>				<li>Finally, to ensure that the double-clicked row is also selected, modify the <strong class="source-inline">Grid</strong> inside <strong class="source-inline">ListView.ItemTemplate</strong> to set the <strong class="source-inline">IsHitTestVisible</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;ListView.ItemTemplate&gt;
    &lt;DataTemplate x:DataType="model:MediaItem"&gt;
        &lt;Grid <strong class="bold">IsHitTestVisible="False"</strong>&gt;
            ...
        &lt;/Grid&gt;
    &lt;/DataTemplate&gt;
&lt;/ListView.ItemTemplate&gt;</pre></li>			</ol>
			<p>Now when<a id="_idIndexMarker335"/> you run the application, you can either click the <strong class="bold">Add Item</strong> button<a id="_idIndexMarker336"/> or double-click a row in the list to add new items. In the next section, you will update the <strong class="bold">Add Item</strong> button to be an <strong class="bold">Add/Edit </strong><span class="No-Break"><strong class="bold">Item</strong></span><span class="No-Break"> button.</span></p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor103"/>Page navigation with MVVM and DI</h1>
			<p>Until this point, the <a id="_idIndexMarker337"/>application has consisted of only a single window. Now it’s time to implement page navigation by adding a host <strong class="source-inline">Frame</strong> and two <strong class="source-inline">Page</strong> objects so we can handle adding new items or editing existing items. The new <strong class="source-inline">Page</strong> will be accessible from the <strong class="bold">Add/Edit Item</strong> button or by double-clicking on an item in <span class="No-Break">the list.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Migrating MainWindow to MainPage</h2>
			<p>If you’re familiar with <a id="_idIndexMarker338"/>UWP app development, you should already understand page navigation. In UWP, the application consists of only a single window. At the root of the window, there is a <strong class="source-inline">Frame</strong> object, which hosts pages and handles the navigation between them. To achieve the same result in a desktop WinUI 3 app, we will create a new <strong class="source-inline">MainPage</strong>, move all the XAML content from <strong class="source-inline">MainWindow</strong> into <strong class="source-inline">MainPage</strong>, and update the <strong class="source-inline">App</strong> class to create a <strong class="source-inline">Frame</strong> as the new content of <strong class="source-inline">MainWindow</strong>. Then we can display the same contents by navigating to <strong class="source-inline">MainPage</strong>. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>First, add a new folder to the project <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Views</strong></span><span class="No-Break">.</span></li>
				<li>Right-click the <strong class="bold">Views</strong> folder and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Item</strong></span><span class="No-Break">.</span></li>
				<li>On the <strong class="bold">Add New Item</strong> dialog, select <strong class="bold">WinUI</strong> on the left and choose the <strong class="bold">Blank Page (WinUI 3)</strong> item template. Name the page <strong class="source-inline">MainPage</strong> and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break">.</span></li>
				<li>Open <strong class="source-inline">MainWindow.xaml</strong> and cut the entire XAML contents of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Window</strong></span><span class="No-Break">.</span></li>
				<li>Open <strong class="source-inline">MainPage.xaml</strong> and paste the XAML from <strong class="source-inline">MainWindow</strong>, replacing the empty <span class="No-Break"><strong class="source-inline">Grid</strong></span><span class="No-Break"> control.</span></li>
				<li>You will also need to cut and paste the <strong class="source-inline">xmlns</strong> declaration for <strong class="source-inline">model</strong> from <strong class="source-inline">MainWindow</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">MainPage</strong></span><span class="No-Break">:</span><pre class="source-code">
xmlns:model="using:MyMediaCollection.Model"</pre></li>				<li>In <strong class="source-inline">MainWindow.xaml.cs</strong>, remove the <strong class="source-inline">ViewModel</strong> variable and the constructor code that fetches it from the <strong class="source-inline">HostContainer</strong>. Put this same code <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">MainPage.xaml.cs</strong></span><span class="No-Break">:</span><pre class="source-code">
public MainPage()
{
    ViewModel = App.HostContainer.Services.GetService
      &lt;MainViewModel&gt;();
    this.InitializeComponent();
}
public MainViewModel ViewModel;</pre></li>				<li>Next, open <strong class="source-inline">App.xaml.cs</strong> and add some code inside <strong class="source-inline">OnLaunched</strong> to create a <strong class="source-inline">rootFrame</strong>, add it to the <strong class="source-inline">MainWindow</strong>, and navigate to <strong class="source-inline">MainPage</strong> before activating <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker339"/></span><span class="No-Break">window:</span><pre class="source-code">
protected override void OnLaunched
  (LauchActivatedEventArgs args)
{
    m_window = new MainWindow();
    var rootFrame = new Frame();
    RegisterComponents();
    rootFrame.NavigationFailed +=
      RootFrame_NavigationFailed;
    rootFrame.Navigate(typeof(MainPage), args);
    m_window.Content = rootFrame;
    m_window.Activate();
}
private void RootFrame_NavigationFailed(object sender,
  NavigationFailedEventArgs e)
{
    throw new Exception($"Error loading page
      {e.SourcePageType.FullName}");
}</pre><p class="list-inset">We’ve also added an event handler to handle navigation failures for <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Frame</strong></span><span class="No-Break">.</span></p></li>				<li>Make sure to<a id="_idIndexMarker340"/> add the necessary <strong class="source-inline">using</strong> statements to <span class="No-Break">the file:</span><pre class="source-code">
using System;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Microsoft.UI.Xaml.Navigation;
using MyMediaCollection.Views;</pre></li>			</ol>
			<p>If you run the app now, it should look and behave just as it did before, but now the controls are nested within a <strong class="source-inline">Page</strong> and a <strong class="source-inline">Frame</strong> on the <strong class="source-inline">Window</strong>. Let’s add a second page and get ready to start navigating between our list and <span class="No-Break">detail pages.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Adding ItemDetailsPage</h2>
			<p>The full <strong class="source-inline">ItemDetailsPage.xaml</strong> code <a id="_idIndexMarker341"/>can be found on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/main/Chapter04/Complete/MyMediaCollection/Views/ItemDetailsPage.xaml</a>). You can follow along with the steps in this section or review the final code <span class="No-Break">on GitHub.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The project will not compile successfully until we have added the new ViewModel to the project and added it to the DI container for consumption by the view. Before we add the ViewModel, we need to create some services to enable navigation and data persistence <span class="No-Break">between views.</span></p>
			<p>We will be<a id="_idIndexMarker342"/> showing <strong class="bold">Item Details</strong> in the same host window, and our content will reside within a new <strong class="source-inline">Page</strong> control. The <strong class="source-inline">Page</strong> will be set as the content and navigated to by the <strong class="source-inline">Frame</strong> we created. For more information about page navigation with WinUI, you can read this Microsoft Learn <span class="No-Break">article: </span><a href="https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk"><span class="No-Break">https://learn.microsoft.com/windows/apps/design/basics/navigate-between-two-pages?tabs=wasdk</span></a><span class="No-Break">.</span></p>
			<p>To add <strong class="source-inline">ItemDetailsPage</strong>, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Right-click the <strong class="bold">Views</strong> folder in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Item</strong></span><span class="No-Break">.</span></li>
				<li>On the new item dialog, select <strong class="bold">Blank Page (WinUI 3)</strong> and name the <span class="No-Break">page </span><span class="No-Break"><strong class="source-inline">ItemDetailsPage</strong></span><span class="No-Break">.</span></li>
				<li>There are going to be several input controls with some common attributes on the page. Start by adding three styles to a <strong class="source-inline">Page.Resources</strong> section just before the top-level <span class="No-Break"><strong class="source-inline">Grid</strong></span><span class="No-Break"> control:</span><pre class="source-code">
&lt;Page.Resources&gt;
    &lt;Style x:Key="AttributeTitleStyle"
      TargetType="TextBlock"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Right"/&gt;
        &lt;Setter Property="VerticalAlignment"
          Value="Center"/&gt;
    &lt;/Style&gt;
    &lt;Style x:Key="AttributeValueStyle"
       TargetType="TextBox"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Stretch"/&gt;
        &lt;Setter Property="Margin" Value="8"/&gt;
    &lt;/Style&gt;
    &lt;Style x:Key="AttributeComboxValueStyle"
       TargetType="ComboBox"&gt;
        &lt;Setter Property="HorizontalAlignment"
          Value="Stretch"/&gt;
        &lt;Setter Property="Margin" Value="8"/&gt;
    &lt;/Style&gt;
&lt;/Page.Resources&gt;</pre><p class="list-inset">In the <a id="_idIndexMarker343"/>next step, we can assign <strong class="source-inline">AttributeTitleStyle</strong> to each <strong class="source-inline">TextBlock</strong>, <strong class="source-inline">AttributeValueStyle</strong> to each <strong class="source-inline">TextBox</strong>, and <strong class="source-inline">AttributeComboValueStyle</strong> to each <strong class="source-inline">ComboBox</strong>. If you need to add any other attributes to input labels later, you will only update <strong class="source-inline">AttributeTitleStyle</strong> and the attributes will automatically be applied to every <strong class="source-inline">TextBlock</strong> using <span class="No-Break">that style.</span></p></li>				<li>The top-level <strong class="source-inline">Grid</strong> will contain three child <strong class="source-inline">Grid</strong> controls to partition the view into three areas—a header, the input controls, and the <strong class="bold">Save</strong> and <strong class="bold">Cancel</strong> buttons at the bottom. The input area will be given the bulk of the available space, so define <strong class="source-inline">Grid.RowDefinitions</strong> <span class="No-Break">like this:</span><pre class="source-code">
&lt;Grid.RowDefinitions&gt;
    &lt;RowDefinition Height="Auto"/&gt;
    &lt;RowDefinition Height="*"/&gt;
    &lt;RowDefinition Height="Auto"/&gt;
&lt;/Grid.RowDefinitions&gt;</pre></li>				<li>The header area will contain only a <strong class="source-inline">TextBlock</strong>. You are welcome to design this area however <span class="No-Break">you like:</span><pre class="source-code">
&lt;TextBlock Text="Item Details" FontSize="18"
Margin="8"/&gt;</pre></li>				<li>The input area<a id="_idIndexMarker344"/> contains a <strong class="source-inline">Grid</strong> with four <strong class="source-inline">RowDefinitions</strong> and two <strong class="source-inline">ColumnDefinitions</strong> for the labels and input controls for the four fields that users can <span class="No-Break">currently edit:</span><pre class="source-code">
&lt;Grid Grid.Row="1"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="200"/&gt;
        &lt;ColumnDefinition Width="*"/&gt;
    &lt;/Grid.ColumnDefinitions&gt;
    &lt;TextBlock Text="Name:" Style="{StaticResource
      AttributeTitleStyle}"/&gt;
    &lt;TextBox Grid.Column="1"
        Style="{StaticResource AttributeValueStyle}"
        Text="{x:Bind ViewModel.ItemName, Mode=TwoWay,
UpdateSourceTrigger=PropertyChanged}"/&gt;
    &lt;TextBlock Text="Media Type:" Grid.Row="1"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="1" Grid.Column="1"
        Style="{StaticResource AttributeCombox
          ValueStyle}"
        ItemsSource="{x:Bind ViewModel.ItemTypes}"
        SelectedValue="{x:Bind ViewModel
          .SelectedItemType, Mode=TwoWay}"/&gt;
    &lt;TextBlock Text="Medium:" Grid.Row="2"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="2" Grid.Column="1"
        Style="{StaticResource
          AttributeComboxValueStyle}"
        ItemsSource="{x:Bind ViewModel.Mediums}"
        SelectedValue="{x:Bind ViewModel
          .SelectedMedium, Mode=TwoWay}"/&gt;
    &lt;TextBlock Text="Location:" Grid.Row="3"
        Style="{StaticResource AttributeTitleStyle}"/&gt;
    &lt;ComboBox Grid.Row="3" Grid.Column="1"
        Style="{StaticResource
          AttributeComboxValueStyle}"
        ItemsSource="{x:Bind ViewModel.LocationTypes}"
        SelectedValue="{x:Bind ViewModel
          .SelectedLocation,Mode=TwoWay}"/&gt;
&lt;/Grid&gt;</pre></li>				<li>The item’s <strong class="source-inline">Name</strong> is a free-text entry field, while the others are <strong class="source-inline">ComboBox</strong> controls to <a id="_idIndexMarker345"/>allow the user to pick values from lists bound to <strong class="source-inline">ItemsSource</strong>. The final child element of the top-level <strong class="source-inline">Grid</strong> is a right-aligned horizontal <strong class="source-inline">StackPanel</strong> containing the <strong class="bold">Save</strong> and <span class="No-Break"><strong class="bold">Cancel</strong></span><span class="No-Break"> buttons:</span><pre class="source-code">
&lt;StackPanel Orientation="Horizontal"
        Grid.Row="2" HorizontalAlignment="Right"&gt;
    &lt;Button Content="Save" Margin="8,8,0,8"
        Command="{x:Bind ViewModel.SaveCommand}"/&gt;
    &lt;Button Content="Cancel" Margin="8"
        Command="{x:Bind ViewModel.CancelCommand}"/&gt;
&lt;/StackPanel&gt;</pre></li>			</ol>
			<p>The next stage is to add interfaces and services, so let’s work on <span class="No-Break">this next.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Adding new interfaces and services</h2>
			<p>Now that <a id="_idIndexMarker346"/>we have more than a single page to manage in the application, we need some services to centralize the page management and abstract the details from the <strong class="source-inline">ViewModel</strong> code. Start by creating <strong class="source-inline">Services</strong> and <strong class="source-inline">Interfaces</strong> folders in the project. Each service will implement an interface. This interface will be used for DI and later, if you were to add unit tests to a <span class="No-Break">test project.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Creating a navigation service</h2>
			<p>The first service <a id="_idIndexMarker347"/>we need is a <strong class="bold">navigation service</strong>. Start by defining the <strong class="source-inline">INavigationService</strong> interface in the <strong class="source-inline">Interfaces</strong> folder. The interface defines methods to get the current page name, navigate to a specific page, or navigate back to the <span class="No-Break">previous page:</span></p>
			<pre class="source-code">
public interface INavigationService
{
string CurrentPage { get; }
void NavigateTo(string page);
void NavigateTo(string page, object parameter);
void GoBack();
}</pre>			<p>Now, create a <strong class="source-inline">NavigationService</strong> class in the <strong class="source-inline">Services</strong> folder. In the class definition, make sure that <strong class="source-inline">NavigationService</strong> implements the <strong class="source-inline">INavigationService</strong> interface. The full class can be viewed on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/NavigationService.cs</a>). Let’s discuss a <span class="No-Break">few highlights.</span></p>
			<p>The purpose of a navigation service in MVVM is to store a collection of available pages in the application so that when its <strong class="source-inline">NavigateTo</strong> method is called, the service can find a page that matches the requested <strong class="source-inline">Name</strong> or <strong class="source-inline">Type</strong> and navigate <span class="No-Break">to it.</span></p>
			<p>The collection of pages will be stored in a <strong class="source-inline">ConcurrentDictionary&lt;T&gt;</strong> collection. The <strong class="source-inline">ConcurrentDictionary&lt;T&gt;</strong> functions like the standard <strong class="source-inline">Dictionary&lt;T&gt;</strong>, but it can automatically add locks to prevent changes to the dictionary simultaneously across <span class="No-Break">multiple threads:</span></p>
			<pre class="source-code">
private readonly IDictionary&lt;string, Type&gt; _pages = new
ConcurrentDictionary&lt;string, Type&gt;();</pre>			<p>The <strong class="source-inline">Configure</strong> method will be called when you create <strong class="source-inline">NavigationService</strong> before adding it to the DI <a id="_idIndexMarker348"/>container. This method is not a part of the <strong class="source-inline">INavigationService</strong> interface and will not be available to classes that consume the service from the container. There is a check here to ensure views are only added to the service once. We check the dictionary to determine whether any pages of the same data type exist. If this condition is <strong class="source-inline">true</strong>, then the page has already <span class="No-Break">been registered:</span></p>
			<pre class="source-code">
public void Configure(string page, Type type)
{
    if (_pages.Values.Any(v =&gt; v == type))
    {
        throw new ArgumentException($"The {type.Name} view
          has already been registered under another
            name.");
    }
    _pages[page] = type;
}</pre>			<p>These are the implementations of the three navigation methods in the service. The two <strong class="source-inline">NavigateTo</strong> methods navigate to a specific page, with the second providing the ability to pass a parameter to the page. The third is <strong class="source-inline">GoBack</strong>, which does what you would think: it navigates to the previous page in the application. They wrap the <strong class="source-inline">Frame</strong> navigation calls to abstract the UI implementation from the view models that will be consuming <span class="No-Break">this service:</span></p>
			<pre class="source-code">
public void NavigateTo(string page)
{
    NavigateTo(page, null);
}
public void NavigateTo(string page, object parameter)
{
    if (!_pages.ContainsKey(page))
    {
        throw new ArgumentException($"Unable to find a page
          registered with the name {page}.");
    }
    AppFrame.Navigate(_pages[page], parameter);
}
public void GoBack()
{
    if (AppFrame?.CanGoBack == true)
    {
        AppFrame.GoBack();
    }
}</pre>			<p>We’re ready to <a id="_idIndexMarker349"/>start using <strong class="source-inline">NavigationService</strong>, but first, let’s create a data service for <span class="No-Break">the application.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can jump ahead to implementing the services in the next section if you like. The <strong class="source-inline">DataService</strong> and <strong class="source-inline">IDataService</strong> code is available in the completed solution on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection"><span class="No-Break">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter04/Complete/MyMediaCollection</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Creating a data service</h2>
			<p>The<a id="_idIndexMarker350"/> data on <strong class="source-inline">MainPage</strong> of <strong class="bold">My Media Collection</strong> currently consists of a few sample records created and stored in <strong class="source-inline">MainViewModel</strong>. This isn’t going to work very well across multiple pages. By using a data service, view models will not need to know how the data is created <span class="No-Break">or stored.</span></p>
			<p>For now, the<a id="_idIndexMarker351"/> data will still be sample records that are not saved between sessions. Later, we can update the data service to save and load data from a database without any changes to the view models that use <span class="No-Break">the data.</span></p>
			<p>The first step is to add an interface named <strong class="source-inline">IDataService</strong> to the <span class="No-Break"><strong class="source-inline">Interfaces</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
public interface IDataService
{
    IList&lt;MediaItem&gt; GetItems();
    MediaItem GetItem(int id);
    int AddItem(MediaItem item);
    void UpdateItem(MediaItem item);
    IList&lt;ItemType&gt; GetItemTypes();
    Medium GetMedium(string name);
    IList&lt;Medium&gt; GetMediums();
    IList&lt;Medium&gt; GetMediums(ItemType itemType);
    IList&lt;LocationType&gt; GetLocationTypes();
    int SelectedItemId { get; set; }
}</pre>			<p>These methods should look familiar to you from previous chapters, but let’s briefly review the purpose <span class="No-Break">of each:</span></p>
			<ul>
				<li><strong class="source-inline">GetItems</strong>: Returns all the available <span class="No-Break">media items</span></li>
				<li><strong class="source-inline">GetItem</strong>: Finds a media item with the <span class="No-Break">provided </span><span class="No-Break"><strong class="source-inline">id</strong></span></li>
				<li><strong class="source-inline">AddItem</strong>: Adds a new media item to <span class="No-Break">the collection</span></li>
				<li><strong class="source-inline">UpdateItem</strong>: Updates a media item in <span class="No-Break">the collection</span></li>
				<li><strong class="source-inline">GetItemTypes</strong>: Gets the list of media <span class="No-Break">item types</span></li>
				<li><strong class="source-inline">GetMedium</strong>: Gets a <strong class="source-inline">Medium</strong> with the <span class="No-Break">provided name</span></li>
				<li><strong class="source-inline">GetMediums</strong>: These two methods either get all available mediums or any available for the <span class="No-Break">provided </span><span class="No-Break"><strong class="source-inline">ItemType</strong></span></li>
				<li><strong class="source-inline">GetLocationTypes</strong>: Gets all the available <span class="No-Break">media locations</span></li>
				<li><strong class="source-inline">SelectedItemId</strong>: Persists the ID of the selected item <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">MainPage</strong></span></li>
			</ul>
			<p>Now, create the <strong class="source-inline">DataService</strong> class in the <strong class="source-inline">Services</strong> folder. Make sure that <strong class="source-inline">DataService</strong> implements <strong class="source-inline">IDataService</strong> in the <span class="No-Break">class definition.</span></p>
			<p>Again, we will only <a id="_idIndexMarker352"/>review parts of the code. You can review the entire implementation on GitHub (<a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/Services/DataService.cs</a>). The data in <strong class="source-inline">DataService</strong> will be persisted in four lists and the <span class="No-Break"><strong class="source-inline">SelectedItemId</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
private IList&lt;MediaItem&gt; _items;
private IList&lt;ItemType&gt; _itemTypes;
private IList&lt;Medium&gt; _mediums;
private IList&lt;LocationType&gt; _locationTypes;
public int SelectedItemId { get; set; }</pre>			<p>Copy the <strong class="source-inline">PopulateItems</strong> method from <strong class="source-inline">MainViewModel</strong> and modify it to use <strong class="source-inline">List&lt;T&gt;</strong> collections and add the <strong class="source-inline">Location</strong> property assignment to <span class="No-Break">each item.</span></p>
			<p>Start by creating the three <span class="No-Break"><strong class="source-inline">MediaItem</strong></span><span class="No-Break"> objects:</span></p>
			<pre class="source-code">
var cd = new MediaItem
{
    Id = 1,
    Name = "Classical Favorites",
    MediaType = ItemType.Music,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "CD"),
    Location = LocationType.InCollection
};
var book = new MediaItem
{
    Id = 2,
    Name = "Classic Fairy Tales",
    MediaType = ItemType.Book,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "Hardcover"),
    Location = LocationType.InCollection
};
var bluRay = new MediaItem
{
    Id = 3,
    Name = "The Mummy",
    MediaType = ItemType.Video,
    MediumInfo = _mediums.FirstOrDefault(m =&gt; m.Name ==
      "Blu Ray"),
    Location = LocationType.InCollection
};</pre>			<p>Then, initialize<a id="_idIndexMarker353"/> the <strong class="source-inline">_items</strong> list and add the three <strong class="source-inline">MediaItem</strong> objects you <span class="No-Break">just created:</span></p>
			<pre class="source-code">
_items = new List&lt;MediaItem&gt;
{
    cd,
    book,
    bluRay
};</pre>			<p>There are <a id="_idIndexMarker354"/>three other methods to pre-populate the sample data: <span class="No-Break"><strong class="source-inline">PopulateMediums</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">Populate</strong></span><strong class="source-inline"> ItemTypes</strong>, and <strong class="source-inline">PopulateLocationTypes</strong>. All of these are called from <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Data</strong></span><strong class="source-inline"> Service</strong> constructor. These methods will be updated later to use an <strong class="bold">SQLite</strong> data store<a id="_idIndexMarker355"/> for <span class="No-Break">data persistence.</span></p>
			<p>Most of the <strong class="source-inline">Get</strong> method implementations are very straightforward. The <strong class="source-inline">GetMediums(ItemType itemType)</strong> method uses <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) to find<a id="_idIndexMarker356"/> all <strong class="source-inline">Medium</strong> objects for the <span class="No-Break">selected </span><span class="No-Break"><strong class="source-inline">ItemType</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public IList&lt;Medium&gt; GetMediums(ItemType itemType)
{
    return _mediums
        .Where(m =&gt; m.MediaType == itemType)
        .ToList();
}</pre>			<p class="callout-heading">Note</p>
			<p class="callout">If you are not familiar with<a id="_idIndexMarker357"/> LINQ expressions, Microsoft has some good documentation on the <span class="No-Break">topic: </span><a href="https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/"><span class="No-Break">https://learn.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">AddItem</strong> and <strong class="source-inline">UpdateItems</strong> methods are also simple. They add to and update the <span class="No-Break"><strong class="source-inline">_items</strong></span><span class="No-Break"> collection:</span></p>
			<pre class="source-code">
public int AddItem(MediaItem item)
{
    item.Id = _items.Max(i =&gt; i.Id) + 1;
    _items.Add(item);
    return item.Id;
}
public void UpdateItem(MediaItem item)
{
    var idx = -1;
    var matchedItem = (from x in _items
                       let ind = idx++
                       where x.Id == item.Id
                       select ind).FirstOrDefault();
    if (idx == -1)
    {
        throw new Exception("Unable to update item. Item
          not found in collection.");
    }
    _items[idx] = item;
}</pre>			<p>The <strong class="source-inline">AddItem</strong> method <a id="_idIndexMarker358"/>has some basic logic to find the highest <strong class="source-inline">Id</strong> and increment it by <strong class="source-inline">1</strong> to use at the new item’s <strong class="source-inline">Id</strong>. <strong class="source-inline">Id</strong> is also returned to the calling method in case the caller needs <span class="No-Break">the information.</span></p>
			<p>The services are all created. It is time to set them up when the application launches and consume them in the <span class="No-Break">view models.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor109"/>Increasing maintainability by consuming services</h2>
			<p>Before using the<a id="_idIndexMarker359"/> services in view models, open the <strong class="source-inline">RegisterServices</strong> method in <strong class="source-inline">App.xaml.cs</strong> and add the following code to register the new services in the DI container and register a new <strong class="source-inline">ItemDetailsViewModel</strong> (yet to be created). We’re also adding a parameter to the method to pass along to the constructor of the <strong class="source-inline">NavigationService</strong>. This will provide access to the <strong class="source-inline">Frame</strong> for <span class="No-Break">page navigation:</span></p>
			<pre class="source-code">
private IServiceProvider RegisterServices(Frame rootFrame)
{
var navigationService = new NavigationService(rootFrame);
navigationService.Configure(nameof(MainPage),
typeof(MainPage));
navigationService.Configure(nameof(ItemDetailsPage),
typeof(ItemDetailsPage));
HostContainer = Host.CreateDefaultBuilder()
    .ConfigureServices(services =&gt;
    {
        services.AddSingleton&lt;INavigationService&gt;
          (navigationService);
        services.AddSingleton&lt;IDataService, DataService&gt;();
        services.AddTransient&lt;MainViewModel&gt;();
        services.AddTransient&lt;ItemDetailsViewModel&gt;();
    }).Build();
}</pre>			<p>Both <strong class="source-inline">INavigationService</strong> and <strong class="source-inline">IDataService</strong> are registered<a id="_idIndexMarker360"/> as <strong class="bold">singletons</strong>. This means that there will be <a id="_idIndexMarker361"/>only a single instance of each stored in the container. Any state held in these services is shared across all classes that <span class="No-Break">consume them.</span></p>
			<p>You will<a id="_idIndexMarker362"/> notice that when we’re registering <strong class="source-inline">INavigationService</strong>, we are passing the instance we already created to the constructor. This is a feature of Microsoft’s DI container and most other DI containers. It allows for initialization and configuration of instances before they’re added to <span class="No-Break">the container.</span></p>
			<p>We need to make a few changes to <strong class="source-inline">MainViewModel</strong> to consume <strong class="source-inline">IDataService</strong> and <strong class="source-inline">INavigationService</strong>, update the <strong class="source-inline">PopulateData</strong> method, and navigate to <strong class="source-inline">ItemDetailsPage</strong> when <strong class="source-inline">AddEdit()</strong> <span class="No-Break">is invoked:</span></p>
			<ol>
				<li>Start by adding properties to <strong class="source-inline">MainViewModel</strong> for <strong class="source-inline">INavigationService</strong> and <span class="No-Break"><strong class="source-inline">IDataService</strong></span><span class="No-Break">:</span><pre class="source-code">
private INavigationService _navigationService;
private IDataService _dataService;</pre><p class="list-inset">Don’t forget to add a <strong class="source-inline">using</strong> statement <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">MyMediaCollection.Interfaces</strong></span><span class="No-Break">.</span></p></li>				<li>Next, update the constructor to receive and store <span class="No-Break">the services:</span><pre class="source-code">
public MainViewModel(<strong class="bold">INavigationService</strong>
<strong class="bold">navigationService, IDataService dataService</strong>)
{
<strong class="bold">    _navigationService = navigationService;</strong>
<strong class="bold">    _dataService = dataService;</strong>
    PopulateData();
}</pre><p class="list-inset">Wait, we’ve added two parameters to the constructor but haven’t changed the code that adds them to the DI container. How does that work? Well, the container is smart enough to pass them because both of those interfaces are also registered. <span class="No-Break">Pretty cool!</span></p></li>				<li>Next, update <strong class="source-inline">PopulateData</strong> to get the <a id="_idIndexMarker363"/>data the view model needs <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">_dataService</strong></span><span class="No-Break">:</span><pre class="source-code">
public void PopulateData()
{
    items.Clear();
    foreach(var item in _dataService.GetItems())
    {
        items.Add(item);
    }
    allItems = new
    ObservableCollection&lt;MediaItem&gt;(Items);
    mediums = new ObservableCollection&lt;string&gt;
    {
        AllMediums
    };
    foreach(var itemType in _dataService
      .GetItemTypes())
    {
        mediums.Add(itemType.ToString());
    }
    selectedMedium = Mediums[0];
}</pre><p class="list-inset">You need to add the <strong class="source-inline">AllMediums</strong> string constant with a value of <strong class="source-inline">"All"</strong> to the <strong class="source-inline">mediums</strong> collection because it’s not part of the persisted data. It’s only needed for the UI filter. Be sure to add this constant definition <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">MainViewModel</strong></span><span class="No-Break">.</span></p></li>				<li>Finally, when the<a id="_idIndexMarker364"/> hidden <strong class="source-inline">AddEditCommand</strong> calls the <strong class="source-inline">AddEdit</strong> method, instead of adding hardcoded items to the collection, you will pass <strong class="source-inline">selectedItemId</strong> as a parameter when navigating <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ItemDetailsPage</strong></span><span class="No-Break">:</span><pre class="source-code">
private void AddEdit()
{
    var selectedItemId = -1;
    if (SelectedMediaItem != null)
    {
        selectedItemId = SelectedMediaItem.Id;
    }
    _navigationService.NavigateTo("ItemDetailsPage",
      selectedItemId);
}</pre></li>			</ol>
			<p>That’s it for <strong class="source-inline">MainViewModel</strong>. Now let’s work on <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ItemDetailsPage</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>Handling parameters in ItemDetailsPage</h2>
			<p>To accept a <a id="_idIndexMarker365"/>parameter passed from another page during navigation, you must override the <strong class="source-inline">OnNavigatedTo</strong> method in <strong class="source-inline">ItemDetailsPage.xaml.cs</strong>. The <strong class="source-inline">NavigationEventArgs</strong> parameter contains a property named <strong class="source-inline">Parameter</strong>. In our case, we passed an <strong class="source-inline">int</strong> containing the selected item’s <strong class="source-inline">Id</strong>. Cast this <strong class="source-inline">Parameter</strong> property to <strong class="source-inline">int</strong> and pass it to a method on the <strong class="source-inline">ViewModel</strong> named <strong class="source-inline">InitializeItemDetailData</strong>, which will be created in the <span class="No-Break">next section:</span></p>
			<pre class="source-code">
protected override void OnNavigatedTo(NavigationEventArgs
e)
{
    base.OnNavigatedTo(e);
    var itemId = (int)e.Parameter;
    if (itemId &gt; 0)
    {
        ViewModel.InitializeItemDetailData(itemId);
    }
}</pre>			<p>In the <a id="_idIndexMarker366"/>next section, we’ll add the final piece of the puzzle, the <span class="No-Break"><strong class="source-inline">ItemDetailsViewModel</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>Creating the ItemDetailsViewModel class</h2>
			<p>To add or <a id="_idIndexMarker367"/>edit items in the application, you will need a view model to bind <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ItemDetails</strong></span><strong class="source-inline"> Page</strong>. Right-click the <strong class="source-inline">ViewModels</strong> folder in <strong class="bold">Solution Explorer</strong> and add a new class named <span class="No-Break"><strong class="source-inline">ItemDetailsViewModel</strong></span><span class="No-Break">.</span></p>
			<p>The class will inherit from <strong class="source-inline">ObservableObject</strong> like <strong class="source-inline">MainViewModel</strong>. The full class can be found on GitHub at <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/blob/master/Chapter04/Complete/MyMediaCollection/ViewModels/ItemDetailsViewModel.cs</a>. Let’s review some of the important members of <span class="No-Break">the class.</span></p>
			<p>The constructor receives the two services from the container and calls <strong class="source-inline">PopulateLists</strong> to populate <strong class="source-inline">ComboBox</strong> data from the <span class="No-Break">data service:</span></p>
			<pre class="source-code">
public ItemDetailsViewModel(INavigationService
  navigationService, IDataService dataService)
{
    _navigationService = navigationService;
    _dataService = dataService;
    PopulateLists();
}</pre>			<p>A <strong class="source-inline">public</strong> method <a id="_idIndexMarker368"/>named <strong class="source-inline">InitializeItemDetailData</strong> will accept the <strong class="source-inline">itemId</strong> parameter passed by <strong class="source-inline">ItemDetailsPage.OnNavigatedTo</strong>. It will call methods to populate the lists and initializes an <strong class="source-inline">IsDirty</strong> flag to enable or disable <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">SaveCommand</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public void InitializeItemDetailData(int itemId)
{
    _selectedItemId = itemId;
    PopulateExistingItem(_dataService);
    IsDirty = false;
}</pre>			<p>The <strong class="source-inline">PopulateExistingItem</strong> method will add existing item data if the page is in edit mode, and <strong class="source-inline">PopulateLists</strong>, called from the constructor, fills the drop-down data to be bound to <span class="No-Break">the view:</span></p>
			<pre class="source-code">
private void PopulateExistingItem(IDataService dataService)
{
    if (_selectedItemId &gt; 0)
    {
        var item = _dataService.GetItem(_selectedItemId);
        Mediums.Clear();
        foreach (string medium in dataService.GetMediums
          (item.MediaType).Select(m =&gt; m.Name))
            Mediums.Add(medium);
        _itemId = item.Id;
        ItemName = item.Name;
        SelectedMedium = item.MediumInfo.Name;
        SelectedLocation = item.Location.ToString();
        SelectedItemType = item.MediaType.ToString();
    }
}
private void PopulateLists()
{
    ItemTypes.Clear();
    foreach (string iType in Enum.GetNames
      (typeof(ItemType)))
        ItemTypes.Add(iType);
    LocationTypes.Clear();
    foreach (string lType in Enum.GetNames
      (typeof(LocationType)))
        LocationTypes.Add(lType);
    Mediums = new TestObservableCollection&lt;string&gt;();
}</pre>			<p>Most of this view model’s properties are straightforward, but <strong class="source-inline">SelectedItemType</strong> has some logic to repopulate the list of <strong class="source-inline">Mediums</strong> based on the <strong class="source-inline">ItemType</strong> selected. For instance, if you are adding a book to the collection, there’s no need to see the DVD or CD mediums in the<a id="_idIndexMarker369"/> selection list. We’ll handle this custom logic <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">OnSelectedItemTypeChanged</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
partial void OnSelectedItemTypeChanged(string value)
{
    IsDirty = true;
    Mediums.Clear();
    if (!string.IsNullOrWhiteSpace(value))
    {
        foreach (string med in _dataService.GetMediums
          ((ItemType)Enum.Parse(typeof(ItemType),
            SelectedItemType)).Select(m =&gt; m.Name))
            Mediums.Add(med);
    }
}</pre>			<p>Lastly, let’s look at <a id="_idIndexMarker370"/>the code that <strong class="source-inline">SaveCommand</strong> and <strong class="source-inline">CancelCommand</strong> will invoke to save and navigate back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">MainPage</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
private void Save()
{
    MediaItem item;
    if (_itemId &gt; 0)
    {
        item = _dataService.GetItem(_itemId);
        item.Name = ItemName;
        item.Location = (LocationType)Enum.Parse
          (typeof(LocationType), SelectedLocation);
        item.MediaType = (ItemType)Enum.Parse(typeof
          (ItemType), SelectedItemType);
        item.MediumInfo = _dataService.GetMedium
          (SelectedMedium);
        _dataService.UpdateItem(item);
    }
    else
    {
        item = new MediaItem
        {
            Name = ItemName,
            Location = (LocationType)Enum.Parse
              (typeof(LocationType), SelectedLocation),
            MediaType = (ItemType)Enum.Parse(typeof
              (ItemType), SelectedItemType),
            MediumInfo = _dataService.GetMedium
              (SelectedMedium)
        };
        _dataService.AddItem(item);
    }
    _navigationService.GoBack();
}
private void Cancel()
{
    _navigationService.GoBack();
}</pre>			<p>The other change<a id="_idIndexMarker371"/> needed before you run the application to test the new page is to consume <strong class="source-inline">ItemDetailsViewModel</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">ItemDetailsPage.xaml.cs</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public ItemDetailsPage()
{
    ViewModel = App.HostContainer.Services.GetService
      &lt;ItemDetailsViewModel&gt;();
    this.InitializeComponent();
}
public ItemDetailsViewModel ViewModel;</pre>			<p>Now, run the app and<a id="_idIndexMarker372"/> try to add or edit an item—you should see the new page. If you are editing, you should also see the existing item data in <span class="No-Break">the controls:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B20908_04_02.jpg" alt="Figure 4.2 – The Item Details page with edited data populated"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The Item Details page with edited data populated</p>
			<p>Great! Now when you save, you should see any added records or edited data appear on <strong class="source-inline">MainPage</strong>. Things are really starting to take shape in our project. Let’s review what we have learned about WinUI and MVVM in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Summary</h1>
			<p>You have learned quite a bit about MVVM and WinUI page navigation in this chapter. You have learned how to create and consume services in your application, and you have leveraged DI and DI containers to keep your view models and services loosely coupled. Understanding and using DI is key to building testable, maintainable code. At this point, you should have enough knowledge to create a robust, testable <span class="No-Break">WinUI application.</span></p>
			<p>In the next chapter, you will learn about more of the available controls and libraries in <span class="No-Break">WinUI 3.</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor113"/>Questions</h1>
			<ol>
				<li>How do DI and <span class="No-Break">IoC relate?</span></li>
				<li>How do you navigate to the previous page in a <span class="No-Break">WinUI application?</span></li>
				<li>What object do we use to <span class="No-Break">manage dependencies?</span></li>
				<li>With Microsoft’s DI container, what method can you call to get an <span class="No-Break">object instance?</span></li>
				<li>What is the name of the framework that queries objects <span class="No-Break">in memory?</span></li>
				<li>What event argument property can you access to get a parameter passed to <span class="No-Break">another </span><span class="No-Break"><strong class="source-inline">Page</strong></span><span class="No-Break">?</span></li>
				<li>Which dictionary type is safe to use <span class="No-Break">across threads?</span></li>
			</ol>
		</div>
	</body></html>