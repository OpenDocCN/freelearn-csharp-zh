<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Anti-Patterns and Misconceptions on Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Patterns show us the proper way to implement Dependency Injection. </span><span class="koboSpan" id="kobo.2.2">In the last chapter, we got an insight into every pattern available in the DI Ecosystem and explored their usage, their pros, their cons, and which one to select when. </span><span class="koboSpan" id="kobo.2.3">If these patterns are followed correctly, we achieve a loosely coupled architecture which will be easier to unit test.</span></p>
<p><span class="koboSpan" id="kobo.3.1">However, while applying these patterns, we generally neglect some principles, which leads us to problems in the future. </span><span class="koboSpan" id="kobo.3.2">That might happen either to the ignorance about pattern' behavior or simply due to laziness.</span></p>
<p><span class="koboSpan" id="kobo.4.1">At that point, a pattern becomes an anti-pattern, as it does not solve the problem; rather it gives birth to more bugs and maintenance becomes a headache.</span></p>
<p><span class="koboSpan" id="kobo.5.1">After reading this chapter, don't worry if you find anti-patterns in your project because we will learn the steps to refactor each </span><span><span class="koboSpan" id="kobo.6.1">anti-pattern</span></span><span class="koboSpan" id="kobo.7.1"> to a proper Pattern by selecting any technique from the patterns we discussed in the last chapter. </span><span class="koboSpan" id="kobo.7.2">If you directly came to this chapter, I suggest you complete the previous chapter (which covers everything you should know about DI Patterns in detail) first before moving ahead.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we will talk about such scenarios in projects with examples to understand how a pattern can behave as an </span><span><span class="koboSpan" id="kobo.9.1">anti-pattern</span></span><span class="koboSpan" id="kobo.10.1">.</span></p>
<p><span class="koboSpan" id="kobo.11.1">We will cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">When DI becomes an </span><span><span class="koboSpan" id="kobo.13.1">anti-pattern</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">DI </span><span><span class="koboSpan" id="kobo.15.1">anti-pattern</span></span><span class="koboSpan" id="kobo.16.1">s</span></li>
<li><span class="koboSpan" id="kobo.17.1">Identifying </span><span><span class="koboSpan" id="kobo.18.1">anti-pattern</span></span><span class="koboSpan" id="kobo.19.1">s in the project</span></li>
<li><span class="koboSpan" id="kobo.20.1">Problems </span><span><span class="koboSpan" id="kobo.21.1">anti-patterns</span></span><span class="koboSpan" id="kobo.22.1"> introduce to apps</span></li>
<li><span class="koboSpan" id="kobo.23.1">Solutions and refactoring steps for each type of </span><span><span class="koboSpan" id="kobo.24.1">anti-pattern</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">When does Dependency Injection become an anti-pattern?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We are heading towards exploring </span><span><span class="koboSpan" id="kobo.3.1">anti-patterns</span></span><span class="koboSpan" id="kobo.4.1"> followed by developers in projects with DI in place. </span><span class="koboSpan" id="kobo.4.2">However, have you envisaged the scenario where DI itself becomes an </span><span><span class="koboSpan" id="kobo.5.1">anti-pattern</span></span><span class="koboSpan" id="kobo.6.1">! </span><span class="koboSpan" id="kobo.6.2">Yes, it can be an </span><span><span class="koboSpan" id="kobo.7.1">anti-pattern</span></span><span class="koboSpan" id="kobo.8.1"> sometimes. </span><span class="koboSpan" id="kobo.8.2">The cases are listed as follows:</span></p>
<p><span class="koboSpan" id="kobo.9.1">Suppose we have a controller that is depending on a </span><kbd><span class="koboSpan" id="kobo.10.1">Service</span></kbd><span class="koboSpan" id="kobo.11.1"> for some database operation. </span><span class="koboSpan" id="kobo.11.2">For instance, </span><kbd><span class="koboSpan" id="kobo.12.1">UsersController</span></kbd><span class="koboSpan" id="kobo.13.1"> would need an </span><kbd><span class="koboSpan" id="kobo.14.1">IUsersService</span></kbd><span class="koboSpan" id="kobo.15.1"> type as a dependency for </span><kbd><span class="koboSpan" id="kobo.16.1">User</span></kbd><span class="koboSpan" id="kobo.17.1"> table-related operations. </span><span class="koboSpan" id="kobo.17.2">We configured </span><kbd><span class="koboSpan" id="kobo.18.1">UsersService</span></kbd><span class="koboSpan" id="kobo.19.1"> for the dependency and it got registered with the container. </span><span class="koboSpan" id="kobo.19.2">Now, help yourself a little bit and ask the following question. </span></p>
<p><em><span class="koboSpan" id="kobo.20.1">Are you going to change the dependency to any other implementation of</span></em> <strong><kbd><span class="koboSpan" id="kobo.21.1">IUsersService</span></kbd></strong><em><span class="koboSpan" id="kobo.22.1">? </span></em><span class="koboSpan" id="kobo.23.1">If your answer is </span><em><span class="koboSpan" id="kobo.24.1">No</span></em><span class="koboSpan" id="kobo.25.1">, then hold back and think a bit. </span><span class="koboSpan" id="kobo.25.2">The reason is, if you won't change the implementation for the dependency either dynamically through code or configurations, then DI is not going to play an important role. </span><span class="koboSpan" id="kobo.25.3">For example, if you save data to a database/XML/text file, you might have different implementations and swapping is needed in certain conditions, then DI will definitely come in handy. </span><span class="koboSpan" id="kobo.25.4">But if you only save to the database and nothing else, there is no necessity to have extra codes for injecting dependencies. </span><span class="koboSpan" id="kobo.25.5">It does not make much sense.</span></p>
<p><em><span class="koboSpan" id="kobo.26.1">Are you going to need a dependency as soon as you start the app? </span></em><span class="koboSpan" id="kobo.27.1">DI recommends that we register everything at one place called the Composition Root. </span><span class="koboSpan" id="kobo.27.2">However, imagine a </span><kbd><span class="koboSpan" id="kobo.28.1">Service</span></kbd><span class="koboSpan" id="kobo.29.1"> called </span><kbd><span class="koboSpan" id="kobo.30.1">CompanyService</span></kbd><span class="koboSpan" id="kobo.31.1"> whose instance is needed only when I want to add a </span><kbd><span class="koboSpan" id="kobo.32.1">User</span></kbd><span class="koboSpan" id="kobo.33.1"> to a company. </span><span class="koboSpan" id="kobo.33.2">For example, see the following code:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">    public IActionResult AddUser(UserModel userModel)</span><br/><span class="koboSpan" id="kobo.35.1">    {</span><br/><span class="koboSpan" id="kobo.36.1">      var user = _usersService.CreateUser(userModel);</span><br/><span class="koboSpan" id="kobo.37.1">      if (userModel.AddUserToCompany)</span><br/><span class="koboSpan" id="kobo.38.1">      {</span><br/><span class="koboSpan" id="kobo.39.1">        var companyService = new CompanyService();</span><br/><span class="koboSpan" id="kobo.40.1">        companyService.AssignUserToCompany(user);</span><br/><span class="koboSpan" id="kobo.41.1">      }</span><br/><span class="koboSpan" id="kobo.42.1">      return View();</span><br/><span class="koboSpan" id="kobo.43.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.44.1">Normally we have admins in a company who manages user records. </span><span class="koboSpan" id="kobo.44.2">Imagine a scenario, where the admin is logged in and wants to assign a few users to a certain company. </span><span class="koboSpan" id="kobo.44.3">In this case, there is a </span><kbd><span class="koboSpan" id="kobo.45.1">boolean</span></kbd><span class="koboSpan" id="kobo.46.1"> coming from the model named </span><kbd><span class="koboSpan" id="kobo.47.1">AddUserToCompany</span></kbd><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">If that is </span><kbd><span class="koboSpan" id="kobo.49.1">true</span></kbd><span class="koboSpan" id="kobo.50.1">, we need to assign the user to the company. </span><span class="koboSpan" id="kobo.50.2">This means a lazy instantiation and it is looking pretty good.</span></p>
<p><span class="koboSpan" id="kobo.51.1">So, here, it's meant to get a </span><kbd><span class="koboSpan" id="kobo.52.1">CompanyService</span></kbd><span class="koboSpan" id="kobo.53.1"> instance quickly and work with it. </span><span class="koboSpan" id="kobo.53.2">However, if you have chosen DI, then the </span><kbd><span class="koboSpan" id="kobo.54.1">CompanyService</span></kbd><span class="koboSpan" id="kobo.55.1"> instance stays in the container (because you register it at the Composition Root) till you actually use it inside the code, which often does not happen. </span><span class="koboSpan" id="kobo.55.2">Sometimes, it doesn't happen at all if the user logged in as a normal user and not an admin.</span></p>
<p><span class="koboSpan" id="kobo.56.1">This is just a small example. </span><span class="koboSpan" id="kobo.56.2">You can visualize a complex application with these types of scenarios that might create a nasty impact with DI in place. </span><span class="koboSpan" id="kobo.56.3">Sometimes it's better to have lazy instantiation instead of having them in a container which consumes memory space unnecessarily.</span></p>
<p><span class="koboSpan" id="kobo.57.1">Like a pattern, if DI is selected unnecessarily or used incorrectly, that leads to an anti-pattern itself. </span><span class="koboSpan" id="kobo.57.2">If you are never going to inject different dependencies for one implementation, then no need to use DI. </span><span class="koboSpan" id="kobo.57.3">Let's now explore anti-patterns, which we might encounter while using DI in the project.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Anti-patterns</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There are four major types of anti-pattern found in projects where DI is implemented and those are listed as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Control Freak</span></li>
<li><span class="koboSpan" id="kobo.4.1">Bastard Injection</span></li>
<li><span class="koboSpan" id="kobo.5.1">Constrained Construction</span></li>
<li><span class="koboSpan" id="kobo.6.1">Service Locator</span></li>
</ul>
<p><span class="koboSpan" id="kobo.7.1">Let's analyze each type and see how to avoid them.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Control Freak</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Control Freak is opposite to Inversion of Control. </span><span class="koboSpan" id="kobo.2.2">When a class holds its dependencies and tries to manage them itself without any interference from others, it will be tagged as a </span><strong><span class="koboSpan" id="kobo.3.1">Control Freak</span></strong><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The following diagram shows Control Freak at a glance:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img height="141" width="227" src="assets/bb44cae7-c5fc-46ae-9bed-747d3b101475.png"/></span></div>
<p><span class="koboSpan" id="kobo.7.1">When we said that </span><em><span class="koboSpan" id="kobo.8.1">it tries to manage the dependencies itself</span></em><span class="koboSpan" id="kobo.9.1">, what do we mean by that? </span><span class="koboSpan" id="kobo.9.2">Remember in </span><a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank"><span class="koboSpan" id="kobo.10.1">Chapter 6</span></a><span class="koboSpan" id="kobo.11.1">, </span><em><span class="koboSpan" id="kobo.12.1">Object Lifetime</span></em><span class="koboSpan" id="kobo.13.1">, if a class wants to manage a dependency, that means it wants to instantiate it, then manage its lifetime and kill or dispose of it as well.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Instantiation, yes, that is done by our well-known keyword </span><kbd><span class="koboSpan" id="kobo.15.1">new</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2"> The class instantiates every dependency </span><span><span class="koboSpan" id="kobo.17.1">with the </span></span><kbd><span class="koboSpan" id="kobo.18.1">new</span></kbd><span class="koboSpan" id="kobo.19.1"> keyword inside it, then works with the objects and disposes of them through a </span><kbd><span class="koboSpan" id="kobo.20.1">destructor</span></kbd><span class="koboSpan" id="kobo.21.1"> or </span><kbd><span class="koboSpan" id="kobo.22.1">finalizer</span></kbd><span class="koboSpan" id="kobo.23.1">. </span><span><span class="koboSpan" id="kobo.24.1">As a result</span></span><span class="koboSpan" id="kobo.25.1">, it is creating a tightly coupled system as soon as it does so. </span><span class="koboSpan" id="kobo.25.2">Moreover, it makes unit testing difficult.</span></p>
<p><span class="koboSpan" id="kobo.26.1">The class either creates the object itself or asks some other class to do so on its behalf. Let's understand the scenario with an example:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">    public class EmployeeService
    {
      private readonly EmployeeRepository repository;
      public EmployeeService()
      {
         string connectionString = "Read String from config";
         this.repository = </span><strong><span class="koboSpan" id="kobo.28.1">new SqlEmployeeRepository(connectionString)</span></strong><span class="koboSpan" id="kobo.29.1">;
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.30.1">The first thing that instantly comes into play is </span><kbd><span class="koboSpan" id="kobo.31.1">new SqlEmplyeeRepository()</span></kbd><span class="koboSpan" id="kobo.32.1">. </span><span class="koboSpan" id="kobo.32.2">Now, this service is tightly coupled with </span><kbd><span class="koboSpan" id="kobo.33.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Suppose you want to use another repository class instead of this, then we have to change the service code and recompile. </span><span class="koboSpan" id="kobo.34.3">There is no such plugin point to say </span><em><span class="koboSpan" id="kobo.35.1">I am providing you with this repository, please use it</span></em><span class="koboSpan" id="kobo.36.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To fix this problem, the developer might think of different patterns, which eventually complicates the scene. </span><span class="koboSpan" id="kobo.2.2">We can see the following types of factory used commonly:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">Concrete Factory</span></li>
<li><span class="koboSpan" id="kobo.4.1">Abstract Factory</span></li>
<li><span class="koboSpan" id="kobo.5.1">Static Factory</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Concrete Factory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Creating </span><kbd><span class="koboSpan" id="kobo.3.1">EmployeeRepositoryFactory</span></kbd><span class="koboSpan" id="kobo.4.1"> is another excuse (and a lazy approach) to have a </span><kbd><span class="koboSpan" id="kobo.5.1">Create()</span></kbd><span class="koboSpan" id="kobo.6.1"> method that will create a </span><kbd><span class="koboSpan" id="kobo.7.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.8.1"> instance by the </span><kbd><span class="koboSpan" id="kobo.9.1">new</span></kbd><span class="koboSpan" id="kobo.10.1"> keyword:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    public class EmployeeRepositoryFactory
    {
      public EmployeeRepository Create()
      {
        string connectionString = "Read String from config";
        return new SqlEmployeeRepository(connectionString);
      }
    }</span></pre>
<p><span><span class="koboSpan" id="kobo.12.1">We removed this block from </span></span><kbd><span class="koboSpan" id="kobo.13.1">EmployeeService</span></kbd> <span><span class="koboSpan" id="kobo.14.1">but added another class which is working very similar to the previous one. </span></span><span class="koboSpan" id="kobo.15.1">We can then use the factory as follows:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">    public EmployeeService()
    {
      var employeeRepofactory = new EmployeeRepositoryFactory();
      this.repository = employeeRepofactory.Create();
    }</span></pre>
<p><span class="koboSpan" id="kobo.17.1">Inside the </span><kbd><span class="koboSpan" id="kobo.18.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.19.1"> constructor, we use the </span><kbd><span class="koboSpan" id="kobo.20.1">new</span></kbd><span class="koboSpan" id="kobo.21.1"> keyword to get a factory instance and then call </span><kbd><span class="koboSpan" id="kobo.22.1">Create()</span></kbd><span class="koboSpan" id="kobo.23.1"> to get the </span><kbd><span class="koboSpan" id="kobo.24.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.25.1"> instance and assign it to the </span><kbd><span class="koboSpan" id="kobo.26.1">repository</span></kbd><span class="koboSpan" id="kobo.27.1"> variable.</span></p>
<p><span class="koboSpan" id="kobo.28.1">Did we achieve anything useful? </span><span class="koboSpan" id="kobo.28.2">Not at all. </span><span class="koboSpan" id="kobo.28.3">We just added another bunch of code to the </span><kbd><span class="koboSpan" id="kobo.29.1">Service</span></kbd><span class="koboSpan" id="kobo.30.1">, doing the same thing (using the </span><kbd><span class="koboSpan" id="kobo.31.1">new</span></kbd><span class="koboSpan" id="kobo.32.1"> keyword to instantiate) in an indirect way through the factory. </span><span class="koboSpan" id="kobo.32.2">Basically, the factory uses the same </span><kbd><span class="koboSpan" id="kobo.33.1">new</span></kbd><span class="koboSpan" id="kobo.34.1"> keyword to instantiate the </span><kbd><span class="koboSpan" id="kobo.35.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.36.1"> class. </span><span class="koboSpan" id="kobo.36.2">That is what we wanted to avoid, but we could not achieve this.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Abstract Factory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Abstract Factory behaves as an encapsulating component that encapsulates complex logic including dependencies associated with it. </span><span class="koboSpan" id="kobo.2.2">It can transfer the control from the consumer because it does not totally allow the consumer to control the lifetime of objects.</span></p>
<p><span class="koboSpan" id="kobo.3.1">A Derived Factory is responsible for the creation and management of the required repository instead of the initially designed factory. </span><span class="koboSpan" id="kobo.3.2">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.4.1">    public abstract class EmployeeRepositoryFactory
    {
        public abstract EmployeeRepository Create();
    }</span></pre>
<p><span class="koboSpan" id="kobo.5.1">That means we are trying to hide which repository will be served. </span><span class="koboSpan" id="kobo.5.2">We are trying to achieve loose coupling by hiding the actual supplied type.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In order to assign the </span><kbd><span class="koboSpan" id="kobo.7.1">repository</span></kbd><span class="koboSpan" id="kobo.8.1"> variable, we have to inherit this class and create one child of it returning </span><kbd><span class="koboSpan" id="kobo.9.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.10.1">:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    public class SqlEmployeeService : EmployeeRepositoryFactory
    {
      public override EmployeeRepository Create()
      {
        string connectionString = "Read String from config";
        return new SqlEmployeeRepository(connectionString);
      }
    }</span></pre>
<p><span class="koboSpan" id="kobo.12.1">Basically, we decoupled the instantiation of the </span><kbd><span class="koboSpan" id="kobo.13.1">repository</span></kbd><span class="koboSpan" id="kobo.14.1"> from the main service. </span><span class="koboSpan" id="kobo.14.2">The same question again arises. </span><span class="koboSpan" id="kobo.14.3">Did we achieve anything useful? </span><span class="koboSpan" id="kobo.14.4">I don't think so. </span><span class="koboSpan" id="kobo.14.5">That is because this new architecture  again achieved at the cost of one instantiation inside the </span><kbd><span class="koboSpan" id="kobo.15.1">EmployeeService </span></kbd><span class="koboSpan" id="kobo.16.1">(with the </span><kbd><span class="koboSpan" id="kobo.17.1">new</span></kbd><span class="koboSpan" id="kobo.18.1"> keyword):</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    public EmployeeService()
    {
      var sqlEmployeeService = new SqlEmployeeService();
      this.repository = sqlEmployeeService.Create();
    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.20.1">Although you were able to hide the </span><kbd><span class="koboSpan" id="kobo.21.1">SqlEmplyeeRepository</span></kbd><span class="koboSpan" id="kobo.22.1"> from the factory by making it abstract, you made no change to the way things are handled inside the </span><kbd><span class="koboSpan" id="kobo.23.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.24.1"> constructor. </span><span class="koboSpan" id="kobo.24.2">You are now instantiating </span><kbd><span class="koboSpan" id="kobo.25.1">SqlEmployeeService</span></kbd><span class="koboSpan" id="kobo.26.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Static Factory</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The next approach is to avoid factory instantiation by introducing the </span><kbd><span class="koboSpan" id="kobo.3.1">static</span></kbd><span class="koboSpan" id="kobo.4.1"> pattern. </span><span class="koboSpan" id="kobo.4.2">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    public static class EmployeeRepositoryFactory</span><br/><span class="koboSpan" id="kobo.6.1">    {</span><br/><span class="koboSpan" id="kobo.7.1">      public static EmployeeRepository Create()</span><br/><span class="koboSpan" id="kobo.8.1">      {</span><br/><span class="koboSpan" id="kobo.9.1">        string connectionstring = "read string from config";</span><br/><span class="koboSpan" id="kobo.10.1">        return new SqlEmployeeRepository(connectionstring);</span><br/><span class="koboSpan" id="kobo.11.1">      }</span><br/><span class="koboSpan" id="kobo.12.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.13.1">This would prevent us from creating an object and using it directly. </span><span class="koboSpan" id="kobo.13.2">Let's see how:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    public EmployeeService()</span><br/><span class="koboSpan" id="kobo.15.1">   {</span><br/><span class="koboSpan" id="kobo.16.1">      repository = EmployeeRepositoryFactory.Create(); </span><br/><span class="koboSpan" id="kobo.17.1">   }</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Horray! </span><span class="koboSpan" id="kobo.18.2">We finally removed the </span><kbd><span class="koboSpan" id="kobo.19.1">new</span></kbd><span class="koboSpan" id="kobo.20.1"> keyword. </span><span class="koboSpan" id="kobo.20.2">Alright, looks like we are done. </span><span class="koboSpan" id="kobo.20.3">Oh, wait! </span><span class="koboSpan" id="kobo.20.4">We still have </span><kbd><span class="koboSpan" id="kobo.21.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.22.1"> instantiated using </span><kbd><span class="koboSpan" id="kobo.23.1">new</span></kbd><span class="koboSpan" id="kobo.24.1"> inside </span><kbd><span class="koboSpan" id="kobo.25.1">Create()</span></kbd><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">But there is a simple solution to reading this type of repository from the </span><kbd><span class="koboSpan" id="kobo.27.1">config</span></kbd><span class="koboSpan" id="kobo.28.1"> or something:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">    public static EmployeeRepository Create()</span><br/><span class="koboSpan" id="kobo.30.1">    {</span><br/><span class="koboSpan" id="kobo.31.1">      var repository = "read from config";</span><br/><span class="koboSpan" id="kobo.32.1">      switch (repository)</span><br/><span class="koboSpan" id="kobo.33.1">      {</span><br/><span class="koboSpan" id="kobo.34.1">        case "sql":</span><br/><span class="koboSpan" id="kobo.35.1">            return EmployeeRepositoryFactory.CreateSql();</span><br/><span class="koboSpan" id="kobo.36.1">        case "azure":</span><br/><span class="koboSpan" id="kobo.37.1">            return EmployeeRepositoryFactory.CreateAzure();</span><br/><span class="koboSpan" id="kobo.38.1">        default:</span><br/><span class="koboSpan" id="kobo.39.1">            throw new InvalidOperationException("Invalid operation");</span><br/><span class="koboSpan" id="kobo.40.1">      }</span><br/><span class="koboSpan" id="kobo.41.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.42.1">It looks promising at first glance, but it is actually something else. </span><span class="koboSpan" id="kobo.42.2">All classes become tightly coupled. </span><span class="koboSpan" id="kobo.42.3">This is depicted in the following diagram:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.43.1"><img height="191" width="409" src="assets/f36aaab7-6112-4fb2-814c-497ae3b09222.png"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.44.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.45.1"> depends upon the </span><kbd><span class="koboSpan" id="kobo.46.1">EmployeeRepositoryFactory</span></kbd><span class="koboSpan" id="kobo.47.1"> for the </span><kbd><span class="koboSpan" id="kobo.48.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.49.1"> instance, which means that clients of the service need to refer to the factory, repository, and then the types of repository such as </span><kbd><span class="koboSpan" id="kobo.50.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.51.1"> and </span><kbd><span class="koboSpan" id="kobo.52.1">AzureEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.53.1"> returned by </span><kbd><span class="koboSpan" id="kobo.54.1">CreateSql()</span></kbd><span class="koboSpan" id="kobo.55.1"> and </span><kbd><span class="koboSpan" id="kobo.56.1">CreateAzure()</span></kbd><span class="koboSpan" id="kobo.57.1">.</span></p>
<p><span class="koboSpan" id="kobo.58.1">These concrete classes got coupled, which can't produce a flexible design resulting in bad days for upcoming programmers of the application.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have already explored patterns in the last chapter. </span><span class="koboSpan" id="kobo.2.2">The best fit for Control Freak issues is Constructor Injection. </span><span class="koboSpan" id="kobo.2.3">Consider the following code snippet:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    public class EmployeeService</span><br/><span class="koboSpan" id="kobo.4.1">    {</span><br/><span class="koboSpan" id="kobo.5.1">      private readonly IEmployeeRepository repository;</span><br/><span class="koboSpan" id="kobo.6.1">      public EmployeeService(</span><strong><span class="koboSpan" id="kobo.7.1">IEmployeeRepository repository</span></strong><span class="koboSpan" id="kobo.8.1">)</span><br/><span class="koboSpan" id="kobo.9.1">      {</span><br/><span class="koboSpan" id="kobo.10.1">        this.repository = repository ?? </span><span class="koboSpan" id="kobo.10.2">throw new</span><br/><span class="koboSpan" id="kobo.11.1">          ArgumentNullException("repository");</span><br/><span class="koboSpan" id="kobo.12.1">      }</span><br/><span class="koboSpan" id="kobo.13.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.14.1">In this way, you abstracted out the concrete repository and also inserted the dependency through the constructor. </span><span class="koboSpan" id="kobo.14.2">More refactoring can be applied by introducing a factory class, which will be responsible for generating the repository.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Now using the DI Containers, you can register either the factory interface or the repository interface and resolve as required so that the dependency will be available for the service.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Control Freak is the most commonly found anti-pattern implemented in projects. </span><span class="koboSpan" id="kobo.16.2">While developers consider using DI in their project, they find it difficult sometimes and they are attracted to controlling the object creation instead of any other component doing it for them. </span><span class="koboSpan" id="kobo.16.3">The outcome will be awesome if they just ignore being a control freak and go with the DI flow.</span></p>
<p><span class="koboSpan" id="kobo.17.1">The next anti-pattern is Bastard Injection. </span><span class="koboSpan" id="kobo.17.2">However, before going to that, we need to understand a manual approach to dependency management called </span><strong><span class="koboSpan" id="kobo.18.1">Poor Man's DI</span></strong><span class="koboSpan" id="kobo.19.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Poor Man's DI</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Poor Man's DI; the name sounds very interesting, doesn't it! </span><span class="koboSpan" id="kobo.2.2">When you yourself try to take care of the registrations of dependencies at commonplace (which otherwise can be denoted as the Composition Root) instead of using a library (specifically a DI Container), that technique can be defined as Poor Man's DI.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The approach</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's find out how this can be done with a quick code example. </span><span class="koboSpan" id="kobo.2.2">Suppose </span><kbd><span class="koboSpan" id="kobo.3.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.4.1"> has a dependency of the </span><kbd><span class="koboSpan" id="kobo.5.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.6.1"> type, which we can directly provide into the constructor, shown as follows:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.8.1">    {</span><br/><span class="koboSpan" id="kobo.9.1">      EmployeeService empService = new </span><br/><span class="koboSpan" id="kobo.10.1">         EmployeeService(new EmployeeRepository());</span><br/><span class="koboSpan" id="kobo.11.1">      Console.ReadKey();</span><br/><span class="koboSpan" id="kobo.12.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.13.1">Consider this console app example, where </span><kbd><span class="koboSpan" id="kobo.14.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.15.1"> is instantiated inside the </span><kbd><span class="koboSpan" id="kobo.16.1">Main</span></kbd><span class="koboSpan" id="kobo.17.1"> method. </span><span class="koboSpan" id="kobo.17.2">It looks simple and beautiful. </span><span class="koboSpan" id="kobo.17.3">But it is not that effective if the dependency nesting runs deep.</span></p>
<p><span class="koboSpan" id="kobo.18.1">What if </span><kbd><span class="koboSpan" id="kobo.19.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.20.1"> again needs some other dependency and then another one and so on. </span><span class="koboSpan" id="kobo.20.2">You might end up doing something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">    EmployeeService empService = new </span><br/><span class="koboSpan" id="kobo.22.1">      EmployeeService(new EmployeeRepository(new</span><br/><span class="koboSpan" id="kobo.23.1">      Cass1(new Class2(new Class3()))));</span></pre>
<p><span class="koboSpan" id="kobo.24.1">Now it becomes ugly and not so maintainable. </span><span class="koboSpan" id="kobo.24.2">Then you might think of simplifying this structure to some extent by introducing a default constructor for each class. </span><span class="koboSpan" id="kobo.24.3">So, the following is what you will do for </span><kbd><span class="koboSpan" id="kobo.25.1">Service</span></kbd><span class="koboSpan" id="kobo.26.1"> and </span><kbd><span class="koboSpan" id="kobo.27.1">Repository</span></kbd><span class="koboSpan" id="kobo.28.1">:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">    public class EmployeeService : IEmployeeService</span><br/><span class="koboSpan" id="kobo.30.1">    {</span><br/><span class="koboSpan" id="kobo.31.1">      private readonly IEmployeeRepository repository;</span><br/><strong><span class="koboSpan" id="kobo.32.1">      // Default Constructor calls the parameterized one</span></strong><br/>      <strong><span class="koboSpan" id="kobo.33.1">public EmployeeService() : this(new EmployeeRepository()) </span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">      {</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">      }</span></strong><br/><span class="koboSpan" id="kobo.36.1">      public EmployeeService(IEmployeeRepository employeeRepository)</span><br/><span class="koboSpan" id="kobo.37.1">      {</span><br/><span class="koboSpan" id="kobo.38.1">         repository = employeeRepository;</span><br/><span class="koboSpan" id="kobo.39.1">      }</span><br/><span class="koboSpan" id="kobo.40.1">    }</span><br/><span class="koboSpan" id="kobo.41.1">    public class EmployeeRepository : IEmployeeRepository</span><br/><span class="koboSpan" id="kobo.42.1">    {</span><br/><span class="koboSpan" id="kobo.43.1">      private readonly ISomeClass class1;</span><br/><strong><span class="koboSpan" id="kobo.44.1">      // Default constructor calls the parameterised one.</span></strong><br/>      <strong><span class="koboSpan" id="kobo.45.1">public EmployeeRepository() : this(new Class1())</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">      {</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">      }</span></strong><br/><span class="koboSpan" id="kobo.48.1">      public EmployeeRepository(ISomeClass someClass)</span><br/><span class="koboSpan" id="kobo.49.1">      {</span><br/><span class="koboSpan" id="kobo.50.1">        class1 = someClass;</span><br/><span class="koboSpan" id="kobo.51.1">      }</span><br/><span class="koboSpan" id="kobo.52.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.53.1">You can do the same thing to all the nested classes. </span><span class="koboSpan" id="kobo.53.2">We added default constructors for all the classes; these a call internally to the parameterized constructors with a default dependency instance. </span><span><span class="koboSpan" id="kobo.54.1">I</span></span><span class="koboSpan" id="kobo.55.1">t will definitely, reduce the code. </span><span class="koboSpan" id="kobo.55.2">Check the following reduced code:</span></p>
<pre><span class="koboSpan" id="kobo.56.1">    static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.57.1">    {</span><br/><span class="koboSpan" id="kobo.58.1">      EmployeeService empService = </span><strong><span class="koboSpan" id="kobo.59.1">new </span><br/><span class="koboSpan" id="kobo.60.1">        EmployeeService(); // No Dependency passed here.</span></strong><br/><span class="koboSpan" id="kobo.61.1">      Console.ReadKey();</span><br/><span class="koboSpan" id="kobo.62.1">    }</span></pre>
<p class="mce-root"><span class="koboSpan" id="kobo.63.1">Now there is no need to pass any dependency to these constructors. </span><span class="koboSpan" id="kobo.63.2">Moreover, if you pass any dependency of the expected type, that will also work because a parameterized constructor also exists. </span><span class="koboSpan" id="kobo.63.3">That means we got a very flexible structure for the class and we also reduced the instantiation.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">While we tried to make the instantiation flexible, testable, and simple, we did not realize the following disadvantages with this approach:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">A concrete reference was created in the default constructor when we did </span><kbd><span class="koboSpan" id="kobo.4.1">new EmployeeRepository()</span></kbd><span class="koboSpan" id="kobo.5.1">.</span></li>
<li><span class="koboSpan" id="kobo.6.1">The default dependency instance is tied with all the classes using the </span><kbd><span class="koboSpan" id="kobo.7.1">new</span></kbd><span class="koboSpan" id="kobo.8.1"> operator. </span><span class="koboSpan" id="kobo.8.2">But the whole point of the dependency injection technique is to reduce the </span><kbd><span class="koboSpan" id="kobo.9.1">new</span></kbd><span class="koboSpan" id="kobo.10.1"> keywords in the app.</span></li>
<li><span class="koboSpan" id="kobo.11.1">We also violated another principle in registering all dependencies in one place known as the Composition Root. </span><span class="koboSpan" id="kobo.11.2">Now, we have Composition Roots everywhere across the app in all classes. </span><span class="koboSpan" id="kobo.11.3">This is bad.</span></li>
<li><span class="koboSpan" id="kobo.12.1">Imagine the situation of having 10 classes using the same dependency; now it would be very problematic to instantiate everything with the same </span><kbd><span class="koboSpan" id="kobo.13.1">new</span></kbd><span class="koboSpan" id="kobo.14.1"> keyword again and again.</span></li>
<li><span class="koboSpan" id="kobo.15.1">You don't have any facility to manage the lifetime of the dependencies created like this using the </span><kbd><span class="koboSpan" id="kobo.16.1">new</span></kbd><span class="koboSpan" id="kobo.17.1"> keyword. </span><span class="koboSpan" id="kobo.17.2">You have to manually dispose of everything which can become a headache in a fully fledged application. </span><span class="koboSpan" id="kobo.17.3">Moreover, if you want to reuse one instance, you need to carefully deal with that. </span><span class="koboSpan" id="kobo.17.4">This might lead to inconsistent behavior and wrong data.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">So, how do we deal with this? </span><span class="koboSpan" id="kobo.18.2">Let's find out.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Obviously, using a DI Container to register the dependencies solves the problem. </span><span class="koboSpan" id="kobo.2.2">We can remove the default constructor that is actually creating a tight coupling with the required types:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">The registration of dependencies can be restricted to one place unlike Poor Man's DI, where you instantiate concrete classes here and there.</span></li>
<li><span class="koboSpan" id="kobo.4.1">With the registrations inside the Composition Root using a DI Container, we can make use of the facility to configure the app to use different types of dependency using different configuration options.</span></li>
<li><span class="koboSpan" id="kobo.5.1">We get cleaner code for deeply nested dependencies.</span></li>
<li><span class="koboSpan" id="kobo.6.1">For a dependency to be used by many classes, it's just a matter of registering it to the container and sitting back and relaxing.</span></li>
<li><span class="koboSpan" id="kobo.7.1">You can manage the lifetime of dependencies as you like. </span><span class="koboSpan" id="kobo.7.2">The instance can behave as a </span><kbd><span class="koboSpan" id="kobo.8.1">Singleton</span></kbd><span class="koboSpan" id="kobo.9.1"> , </span><kbd><span class="koboSpan" id="kobo.10.1">Transient</span></kbd><span class="koboSpan" id="kobo.11.1"> , or </span><kbd><span class="koboSpan" id="kobo.12.1">Scoped</span></kbd><span class="koboSpan" id="kobo.13.1"> as you configure them.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.14.1">It's recommended to use a DI Container </span><span><span class="koboSpan" id="kobo.15.1">to register and resolve dependencies</span></span><span class="koboSpan" id="kobo.16.1"> instead of manually managing them in the Composition Root. </span><span class="koboSpan" id="kobo.16.2">So, the default constructor approach is denoted as Bastard Injection. </span><span class="koboSpan" id="kobo.16.3">In the next section, we will explore this a bit more.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Bastard Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Usually, classes have more than one constructor. </span><span class="koboSpan" id="kobo.2.2">You might have a situation where you have referred to some class from another assembly in your default constructor.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The following diagram shows how one class has two constructors: one default and one parameterized. </span><span class="koboSpan" id="kobo.3.2">The parameterized constructor handles the injection and makes the </span><kbd><span class="koboSpan" id="kobo.4.1">ISomeClass</span></kbd><span class="koboSpan" id="kobo.5.1"> implementation available for the class to operate on. </span><span class="koboSpan" id="kobo.5.2">Thus, the default constructor that is creating an instance of </span><kbd><span class="koboSpan" id="kobo.6.1">SomeClass</span></kbd><span class="koboSpan" id="kobo.7.1"> becomes unnecessary:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="202" width="402" src="assets/6b599f09-8916-4f3f-85ac-54710d8b7933.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For simplicity, let's consider the same example: </span><kbd><span class="koboSpan" id="kobo.3.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.4.1">, which needs a repository to work with:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">    public class EmployeeService</span><br/><span class="koboSpan" id="kobo.6.1">    {</span><br/><span class="koboSpan" id="kobo.7.1">      private readonly IEmployeeRepository repository;</span><br/><span class="koboSpan" id="kobo.8.1">      // Default Constructor.</span><br/><span class="koboSpan" id="kobo.9.1">      public EmployeeService()</span><br/><span class="koboSpan" id="kobo.10.1">      {</span><br/><span class="koboSpan" id="kobo.11.1">         repository = CreateDefaultRepository();</span><br/><span class="koboSpan" id="kobo.12.1">      }</span><br/><br/><span class="koboSpan" id="kobo.13.1">      // Constructor Injection can happen here.</span><br/><span class="koboSpan" id="kobo.14.1">      public EmployeeService(IEmployeeRepository repository)</span><br/><span class="koboSpan" id="kobo.15.1">      {</span><br/><span class="koboSpan" id="kobo.16.1">        if (repository == null)</span><br/><span class="koboSpan" id="kobo.17.1">        {</span><br/><span class="koboSpan" id="kobo.18.1">          throw new ArgumentNullException("repository");</span><br/><span class="koboSpan" id="kobo.19.1">        }</span><br/><span class="koboSpan" id="kobo.20.1">        this.repository = repository;</span><br/><span class="koboSpan" id="kobo.21.1">      }</span><br/><span class="koboSpan" id="kobo.22.1">      // Method creating a default repository.</span><br/><span class="koboSpan" id="kobo.23.1">      private static EmployeeRepository CreateDefaultRepository()</span><br/><span class="koboSpan" id="kobo.24.1">      {</span><br/><span class="koboSpan" id="kobo.25.1">        string connectionString = "Read String from config";</span><br/><span class="koboSpan" id="kobo.26.1">        return new SqlEmployeeRepository(connectionString);</span><br/><span class="koboSpan" id="kobo.27.1">      }</span><br/><span class="koboSpan" id="kobo.28.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.29.1">There is a default constructor which ensures repository availability by creating an instance of </span><kbd><span class="koboSpan" id="kobo.30.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">The default repository is referred from another assembly, obviously, as the s</span><span><span class="koboSpan" id="kobo.32.1">ervice and repository don't stay in one assembly together</span></span><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">That's why the default can be denoted as a </span><strong><span class="koboSpan" id="kobo.34.1">Foreign Default</span></strong><span class="koboSpan" id="kobo.35.1">.</span></p>
<p><span class="koboSpan" id="kobo.36.1">While we thought of having a default repository just because we wanted to make the service usable </span><span><span class="koboSpan" id="kobo.37.1">as soon as it is instantiated</span></span><span class="koboSpan" id="kobo.38.1">, unknowingly we designed a tightly coupled system between the service and repository.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Bastard Injection is bad just because of this Foreign Default. </span><span class="koboSpan" id="kobo.2.2">Also, it might be depending on something we don't even need inside the class. </span><span class="koboSpan" id="kobo.2.3">From the preceding example, it's quite clear that, if we use a DI Container, it will automatically wire up the resolved dependency to the other parameterized constructor. </span><span class="koboSpan" id="kobo.2.4">However, if we have these kinds of default constructor, then DI Container might get confused while selecting which one to target. </span><span class="koboSpan" id="kobo.2.5">Having just one constructor for injection ensures a smooth operation with the container.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.3.1">When you encounter a default constructor generating coupling with a Foreign Default, you can consider eliminating that, as you decide to apply Constructor Injection. </span><span class="koboSpan" id="kobo.3.2">Having one constructor for DI is enough because it is the responsibility of the DI Container to make sure that Foreign Default is in place whenever the service is requested.</span></div>
<p><span class="koboSpan" id="kobo.4.1">While you refactor the code and remove the default constructor, the compiler might complain. </span><span class="koboSpan" id="kobo.4.2">In that case, you need to move instantiation codes to the Composition Root. </span><span class="koboSpan" id="kobo.4.3">If the referred dependency is a </span><em><span class="koboSpan" id="kobo.5.1">Local Default</span></em><span class="koboSpan" id="kobo.6.1"> (it resides inside the same assembly), then we still need to remove that constructor, because constructor ambiguity leads to an increase in the complexity of </span><em><span class="koboSpan" id="kobo.7.1">Auto-Wiring</span></em><span class="koboSpan" id="kobo.8.1">.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.9.1">If you remember, we have already discussed local defaults in </span><a href="795befd2-857f-40d2-ba05-cb2921168bcc.xhtml" target="_blank"><span class="koboSpan" id="kobo.10.1">Chapter 8</span></a><span class="koboSpan" id="kobo.11.1">, </span><em><span class="koboSpan" id="kobo.12.1">Patterns - Dependency Injection</span></em><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">The easiest way to handle local defaults is to introduce </span><em><span class="koboSpan" id="kobo.14.1">Property Injection</span></em><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">The default constructor can be converted to a writable property.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Constrained Construction</span></h1>
                </header>
            
            <article>
                
<p class="mce-root"><span class="koboSpan" id="kobo.2.1">Here comes yet another type of </span><em><span class="koboSpan" id="kobo.3.1">Anti-Pattern,</span></em><span class="koboSpan" id="kobo.4.1"> that tries to hijack the constructor. </span><span class="koboSpan" id="kobo.4.2">So, the developer forces the dependency's constructor to have a particular signature, which creates the problem. </span><span class="koboSpan" id="kobo.4.3">The reason behind this might be the intention of defining the dependencies in external configuration files to achieve late binding.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Late binding can be referred to as reading the type of repository (the derived class of the repository) and connection string from the configuration file to instantiate some repository.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Having a late binding technique not only helps to isolate code from the dependency but also makes sure that the code is not recompiled if the configuration is updated. </span><span class="koboSpan" id="kobo.6.2">Using a commonplace or application root to define all dependencies doesn't expose any problem, but recompiling is a must when we want to update dependencies:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="119" width="517" src="assets/b26c2b49-2055-4fa7-93d7-8a9bab80c914.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Imagine two repositories </span><kbd><span class="koboSpan" id="kobo.3.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">StaffRepository</span></kbd><span class="koboSpan" id="kobo.6.1"> used in an application. </span><span class="koboSpan" id="kobo.6.2">Both have constructors and you will pass the type of repository and connection string to both of them in order to create the repositories using these params. </span><span class="koboSpan" id="kobo.6.3">This is bad as you will now fetch the repository type and connection string from the config which might create issues if the </span><kbd><span class="koboSpan" id="kobo.7.1">config</span></kbd><span class="koboSpan" id="kobo.8.1">, does not have the required keys.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Now after you fetch the repository type name from the </span><kbd><span class="koboSpan" id="kobo.10.1">config</span></kbd><span class="koboSpan" id="kobo.11.1">, you have to create a </span><kbd><span class="koboSpan" id="kobo.12.1">System.Type</span></kbd><span class="koboSpan" id="kobo.13.1"> instance using that name:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    var employeeRepositoryTypeName = "Read from config"; </span><br/><span class="koboSpan" id="kobo.15.1">      //SqlEmployeeRepository</span><br/><span class="koboSpan" id="kobo.16.1">    var connectionString = "Read from config";</span><br/><br/><span class="koboSpan" id="kobo.17.1">    var employeeRepositoryType = Type.GetType(employeeRepositoryTypeName,</span><br/><span class="koboSpan" id="kobo.18.1">         true);</span><br/><span class="koboSpan" id="kobo.19.1">    var employeeRepository = Activator.CreateInstance(employeeRepositoryType,</span><br/><span class="koboSpan" id="kobo.20.1">       connectionString);</span></pre>
<p><kbd><span class="koboSpan" id="kobo.21.1">Activator.CreateInstance</span></kbd><span class="koboSpan" id="kobo.22.1"> is used to call the constructor of the given type. </span><span class="koboSpan" id="kobo.22.2">The second param in this method is passed to the constructor of the type provided in the first param.</span></p>
<p><span class="koboSpan" id="kobo.23.1">Suppose the type in the </span><kbd><span class="koboSpan" id="kobo.24.1">config</span></kbd><span class="koboSpan" id="kobo.25.1"> is </span><kbd><span class="koboSpan" id="kobo.26.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.27.1">. </span><span class="koboSpan" id="kobo.27.2">Basically, it assumes the following:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.28.1">SqlEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.29.1"> derives from </span><kbd><span class="koboSpan" id="kobo.30.1">EmployeeRepository</span></kbd></li>
<li><span class="koboSpan" id="kobo.31.1">The implementation should contain a constructor that can take a connection string as a parameter</span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">These are the constraints, actually.</span></p>
<p><span class="koboSpan" id="kobo.33.1">From the object construction perspective, it might look perfect, but there are disadvantages. </span><span class="koboSpan" id="kobo.33.2">For instance, think of constructing the repositories with the same dependency such as a single context. </span><span class="koboSpan" id="kobo.33.3">With the </span><kbd><span class="koboSpan" id="kobo.34.1">Activator.CreateInstance</span></kbd><span class="koboSpan" id="kobo.35.1">, we can no doubt create instances of the type specified to it, which in our case will create instances of </span><kbd><span class="koboSpan" id="kobo.36.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.37.1"> and </span><kbd><span class="koboSpan" id="kobo.38.1">StaffRepository</span></kbd><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">But we can never assign a single context to both of them, as everyone will create their individual context based on their constructors. </span><span class="koboSpan" id="kobo.39.3">The following diagram depicts what I want to convey:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.40.1"><img height="201" width="344" src="assets/1f2672df-330e-436b-be6f-604db85e0e54.png"/></span></div>
<p><span class="koboSpan" id="kobo.41.1">Sharing of context can only happen if someone from the outside provides that to each of them instead of their creating the context themselves:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.42.1"><img height="263" width="377" src="assets/c9fddb65-626d-49b7-b507-867a49852a70.png"/></span></div>
<p><span class="koboSpan" id="kobo.43.1">Sharing a single dependency across the classes becomes difficult in this situation. </span><span class="koboSpan" id="kobo.43.2">More than one instance of the same dependency will be created, which is unnecessary. </span><span class="koboSpan" id="kobo.43.3">This would consume memory and resources as well.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.44.1">A single instance of a particular dependency should be carefully chosen while designing. </span><span class="koboSpan" id="kobo.44.2">If not handled with care, there might be an adverse effect on the application running in different threads. </span><span class="koboSpan" id="kobo.44.3">If you remember, we have already discussed the Singleton Lifetime in </span><a href="72113d11-0af8-431f-91d0-ced4cb35af21.xhtml" target="_blank"><span class="koboSpan" id="kobo.45.1">Chapter 6</span></a><span class="koboSpan" id="kobo.46.1">, </span><em><span class="koboSpan" id="kobo.47.1">Object Lifetime, </span></em><span class="koboSpan" id="kobo.48.1">where we talked about the pattern's benefits and usage.</span></div>
<p><span class="koboSpan" id="kobo.49.1">The </span><span class="packt_screen"><span class="koboSpan" id="kobo.50.1">Someone</span></span><span class="koboSpan" id="kobo.51.1"> can be considered to be a Factory which we are going to explore next.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A DI container comes to the rescue at the composition root to overcome these difficulties and resolve all the dependencies in one go. </span><span class="koboSpan" id="kobo.2.2">Thus, the injection can take place and everything works smoothly. </span><span class="koboSpan" id="kobo.2.3">There is no need to have individual constructors for the dependencies with connection strings.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Even without a DI Container, we can formulate our solution differently. </span><span class="koboSpan" id="kobo.3.2">Abstract Factory comes into the play when we think of centralizing the dependency construction.</span></p>
<p><span class="koboSpan" id="kobo.4.1">First of all, the Factory, Service, and Repository should be in different assemblies. </span><span class="koboSpan" id="kobo.4.2">There is a strong reason behind that. </span><span class="koboSpan" id="kobo.4.3">We will explore it shortly.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Instead of creating every dependency object inside the </span><em><span class="koboSpan" id="kobo.6.1">Global asax</span></em><span class="koboSpan" id="kobo.7.1"> for ASP.NET app using </span><kbd><span class="koboSpan" id="kobo.8.1">Activator.CreateInstance</span></kbd><span class="koboSpan" id="kobo.9.1">, we will design in a different way so that there will be no need to recompile the app every time you want to use different types of repositories.</span></p>
<p><span class="koboSpan" id="kobo.10.1">We will design a Factory named </span><kbd><span class="koboSpan" id="kobo.11.1">EmployeeServiceFactory</span></kbd><span class="koboSpan" id="kobo.12.1"> implementing </span><kbd><span class="koboSpan" id="kobo.13.1">IEmployeeServiceFactory</span></kbd><span class="koboSpan" id="kobo.14.1"> using a particular repository. </span><span class="koboSpan" id="kobo.14.2">This factory will be responsible for creating the service. </span><kbd><span class="koboSpan" id="kobo.15.1">Service</span></kbd><span class="koboSpan" id="kobo.16.1"> would look something like the following:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    public class EmployeeService : IEmployeeService</span><br/><span class="koboSpan" id="kobo.18.1">    {</span><br/><span class="koboSpan" id="kobo.19.1">      public EmployeeService(IEmployeeRepository repository)</span><br/><span class="koboSpan" id="kobo.20.1">      {</span><br/><span class="koboSpan" id="kobo.21.1">      }</span><br/><span class="koboSpan" id="kobo.22.1">    }</span></pre>
<p><kbd><span class="koboSpan" id="kobo.23.1">EmployeeServiceFactory</span></kbd><span class="koboSpan" id="kobo.24.1"> contains a </span><kbd><span class="koboSpan" id="kobo.25.1">CreateService()</span></kbd><span class="koboSpan" id="kobo.26.1"> method to create the service it is responsible for (</span><kbd><span class="koboSpan" id="kobo.27.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.28.1"> in this case).</span></p>
<p><span class="koboSpan" id="kobo.29.1">It's important to isolate the Factory from the app and </span><kbd><span class="koboSpan" id="kobo.30.1">DataAccess</span></kbd><span class="koboSpan" id="kobo.31.1"> to remove coupling. </span><span class="koboSpan" id="kobo.31.2">So, the Factory should be in a different assembly.</span></p>
<p><span><span class="koboSpan" id="kobo.32.1">You can store the assembly-qualified type name for a factory in a </span><kbd><span class="koboSpan" id="kobo.33.1">.config</span></kbd><span class="koboSpan" id="kobo.34.1"> file. </span></span><span><kbd><span class="koboSpan" id="kobo.35.1">Activator.CreateInstance</span></kbd><span class="koboSpan" id="kobo.36.1"> can then be used to create an instance of t</span></span><span class="koboSpan" id="kobo.37.1">he </span><kbd><span class="koboSpan" id="kobo.38.1">IEmployeeServiceFactory</span></kbd><span class="koboSpan" id="kobo.39.1"> implementation (that you will define in the config) because that has a default constructor:</span></p>
<pre><span class="koboSpan" id="kobo.40.1">    var employeeFactoryTypeName = "Read from config";</span><br/><span class="koboSpan" id="kobo.41.1">    var employeeFactoryType = Type.GetType(employeeFactoryTypeName, true);</span><br/><span class="koboSpan" id="kobo.42.1">    var employeeFactory = Activator.CreateInstance(employeeFactoryType);</span></pre>
<p><span class="koboSpan" id="kobo.43.1">With </span><kbd><span class="koboSpan" id="kobo.44.1">employeeFactory</span></kbd><span class="koboSpan" id="kobo.45.1"> now you can fire </span><kbd><span class="koboSpan" id="kobo.46.1">CreateService()</span></kbd><span class="koboSpan" id="kobo.47.1">, which will return the </span><kbd><span class="koboSpan" id="kobo.48.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.49.1"> instance by using the related repository </span><kbd><span class="koboSpan" id="kobo.50.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.51.1">.</span></p>
<p><span class="koboSpan" id="kobo.52.1">If you decide to use another type of dependency for the service instead of </span><kbd><span class="koboSpan" id="kobo.53.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.54.1">, then you can update the related key in the </span><kbd><span class="koboSpan" id="kobo.55.1">config</span></kbd><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">But before that, you need to add another factory in the factory assembly to implement </span><kbd><span class="koboSpan" id="kobo.57.1">IEmployeeServiceFactory</span></kbd><span class="koboSpan" id="kobo.58.1"> and operate on the new configured repository. </span><span class="koboSpan" id="kobo.58.2">In this way, you recompile the factory assembly without compiling the application again and everything works as expected.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Service Locator</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">If you remember, in the </span><em><span class="koboSpan" id="kobo.3.1">Control Freak</span></em><span class="koboSpan" id="kobo.4.1"> section, we discussed Static Factories. </span><span class="koboSpan" id="kobo.4.2">With certain modifications, a Static Factory can behave as a Service Locator. </span><span class="koboSpan" id="kobo.4.3">As the name suggests, it will locate or find your required service:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="128" width="312" src="assets/eb58b76b-a22f-41d5-bc18-e7063e0a4694.png"/></span></div>
<p><em><span class="koboSpan" id="kobo.6.1">Service Locator</span></em><span class="koboSpan" id="kobo.7.1"> is very useful in many cases, which is why developers consider it to be a pattern. </span><span class="koboSpan" id="kobo.7.2">But it has many disadvantages. </span><span class="koboSpan" id="kobo.7.3">That's why we are listing this in this chapter instead of the previous one.</span></p>
<p><span class="koboSpan" id="kobo.8.1">I am not going to discourage you from using this technique, but I would like to shed some light on its pros and cons. </span><span class="koboSpan" id="kobo.8.2">This will definitely help you to make better design decisions according to your application.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Some noticeable properties of Locator include the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">The important logic behind </span><em><span class="koboSpan" id="kobo.11.1">Locator</span></em><span class="koboSpan" id="kobo.12.1"> is that it allows dependencies or services to be injected into it easily</span></li>
<li><span class="koboSpan" id="kobo.13.1">A Static Factory, when configured with services or dependencies, is usually considered a </span><em><span class="koboSpan" id="kobo.14.1">Service Locator</span></em></li>
<li><span class="koboSpan" id="kobo.15.1">The configuration of a Service Locator can happen at the Composition Root</span></li>
<li><span class="koboSpan" id="kobo.16.1">Service Locator configuration can be managed through code or reading-related settings from config</span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">A DI Container looks like a </span><em><span class="koboSpan" id="kobo.18.1">S</span></em><span class="koboSpan" id="kobo.19.1">ervice Locator. </span><span class="koboSpan" id="kobo.19.2">The principal duty of a Locator or Container in the DI Context is to resolve the dependency graph before every other operation starts. </span><span class="koboSpan" id="kobo.19.3">Ideally, resolving the graph should only happen at the Composition Root for proper implementation. </span><span class="koboSpan" id="kobo.19.4">The problem starts when you ask for dependencies or services in the application directly using the Locator or Container, instead of injecting them to the consumer. </span><span class="koboSpan" id="kobo.19.5">In this case, Locator will be tagged as an anti-pattern.</span></p>
<p><span class="koboSpan" id="kobo.20.1">The Locator Process can be defined as follows:</span></p>
<ol>
<li><strong><span class="koboSpan" id="kobo.21.1">While registering a service, Locator stores one instance of it in a Dictionary</span></strong><span class="koboSpan" id="kobo.22.1">: The registration is normally done using an interface. </span><span class="koboSpan" id="kobo.22.2">You basically inform the Locator about an interface and its concrete implementation. </span><span class="koboSpan" id="kobo.22.3">For example, you would say </span><em><span class="koboSpan" id="kobo.23.1">Serve </span><kbd><span class="koboSpan" id="kobo.24.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.25.1"> if </span><kbd><span class="koboSpan" id="kobo.26.1">IEmployeeService</span></kbd><span class="koboSpan" id="kobo.27.1"> is requested, Serve </span><kbd><span class="koboSpan" id="kobo.28.1">StudentService</span></kbd><span class="koboSpan" id="kobo.29.1"> if </span><kbd><span class="koboSpan" id="kobo.30.1">IStudentService</span></kbd><span class="koboSpan" id="kobo.31.1"> is demanded</span></em><span class="koboSpan" id="kobo.32.1">.</span></li>
<li><strong><span class="koboSpan" id="kobo.33.1">Locator receives the request to serve one instance of a service registered by its interface</span></strong><span class="koboSpan" id="kobo.34.1">: So, when some code in your application wants to work with a </span><kbd><span class="koboSpan" id="kobo.35.1">Student</span></kbd><span class="koboSpan" id="kobo.36.1"> entity, it will ask the Locator for an </span><kbd><span class="koboSpan" id="kobo.37.1">IStudentInterface</span></kbd><span class="koboSpan" id="kobo.38.1"> implementation. </span></li>
<li><strong><span class="koboSpan" id="kobo.39.1">Locator searches for the instance from the stored instances and then returns that to the client: </span></strong><span class="koboSpan" id="kobo.40.1">As you have already trained the Locator, it will just return the requested implementation of the interface by checking all the stored instances.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Design</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A simple Service Locator would resemble the following class:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">    public static class ServiceLocator</span><br/><span class="koboSpan" id="kobo.4.1">    {</span><br/><span class="koboSpan" id="kobo.5.1">      static Dictionary&lt;Type, object&gt; servicesDictionary = </span><br/><span class="koboSpan" id="kobo.6.1">        new Dictionary&lt;Type, object&gt;();</span><br/><span class="koboSpan" id="kobo.7.1">      public static void Register&lt;T&gt;(T service)</span><br/><span class="koboSpan" id="kobo.8.1">      {</span><br/><span class="koboSpan" id="kobo.9.1">         servicesDictionary[typeof(T)] = service;</span><br/><span class="koboSpan" id="kobo.10.1">      }</span><br/><span class="koboSpan" id="kobo.11.1">       public static T GetService&lt;T&gt;()</span><br/><span class="koboSpan" id="kobo.12.1">       {</span><br/><span class="koboSpan" id="kobo.13.1">         T instance = default(T);</span><br/><span class="koboSpan" id="kobo.14.1">         if (servicesDictionary.ContainsKey(typeof(T)) == true)</span><br/><span class="koboSpan" id="kobo.15.1">         {</span><br/><span class="koboSpan" id="kobo.16.1">            instance = (T)servicesDictionary[typeof(T)];</span><br/><span class="koboSpan" id="kobo.17.1">         }</span><br/><span class="koboSpan" id="kobo.18.1">         return instance;</span><br/><span class="koboSpan" id="kobo.19.1">       }</span><br/><span class="koboSpan" id="kobo.20.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">The </span><kbd><span class="koboSpan" id="kobo.22.1">Register</span></kbd><span class="koboSpan" id="kobo.23.1"> method stores the service in the dictionary and </span><kbd><span class="koboSpan" id="kobo.24.1">GetService</span></kbd><span class="koboSpan" id="kobo.25.1"> returns. </span><span class="koboSpan" id="kobo.25.2">We can use the locator to get the instance of a particular type:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">    public class EmployeeService : IEmployeeService</span><br/><span class="koboSpan" id="kobo.27.1">    {</span><br/><span class="koboSpan" id="kobo.28.1">      private readonly IEmployeeRepository repository;</span><br/><span class="koboSpan" id="kobo.29.1">      public EmployeeService()</span><br/><span class="koboSpan" id="kobo.30.1">      {</span><br/><span class="koboSpan" id="kobo.31.1">        this.repository = ServiceLocator.GetService&lt;IEmployeeRepository&gt;();</span><br/><span class="koboSpan" id="kobo.32.1">      }</span><br/><span class="koboSpan" id="kobo.33.1">     } </span></pre>
<p><span class="koboSpan" id="kobo.34.1">If you have registered the service beforehand using the </span><kbd><span class="koboSpan" id="kobo.35.1">Register</span></kbd><span class="koboSpan" id="kobo.36.1"> method, then you can get it from the dictionary.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Advantages</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Of course, the pattern has some advantages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">It supports late binding by altering the registration codes.</span></li>
<li><span class="koboSpan" id="kobo.4.1">It adopts </span><span><span class="koboSpan" id="kobo.5.1">program against interfaces so that w</span></span><span class="koboSpan" id="kobo.6.1">e can develop code in parallel and we can replace modules as per our requirements.</span></li>
<li><span class="koboSpan" id="kobo.7.1">Separation of concerns can be achieved. </span><span class="koboSpan" id="kobo.7.2">We can write maintainable code, though it is not so easy.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.8.1">Don't get fooled by the advantages. </span><span class="koboSpan" id="kobo.8.2">It might look perfectly fine to you, but there are many disadvantages with this approach.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Problem</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Service Locator acts as a proper pattern; however, you have to live with the following issues:</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Code reusability</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It hampers the reusability of the class as dependencies are not centralized anymore with Locator. </span><span class="koboSpan" id="kobo.2.2">They might be scattered throughout the class by the Locator's </span><kbd><span class="koboSpan" id="kobo.3.1">GetService</span></kbd><span class="koboSpan" id="kobo.4.1"> method:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="109" width="294" src="assets/a995e4f8-b337-47e6-9b84-2d9a7e91033c.png"/></span></div>
<p><kbd><span class="koboSpan" id="kobo.6.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.7.1"> now depends upon both </span><kbd><span class="koboSpan" id="kobo.8.1">EmployeeRepository</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">ServiceLocator</span></kbd><span class="koboSpan" id="kobo.11.1">. </span><span class="koboSpan" id="kobo.11.2">Ideally, it should just rely upon the repository to follow the DI principle.</span></p>
<p><span class="koboSpan" id="kobo.12.1">With both these dependencies in place, if someone wants to reuse </span><kbd><span class="koboSpan" id="kobo.13.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.14.1">, then they have to refer to both of them. </span><span class="koboSpan" id="kobo.14.2">If </span><kbd><span class="koboSpan" id="kobo.15.1">ServiceLocator</span></kbd><span class="koboSpan" id="kobo.16.1"> stays in a different assembly, then the assembly reference is also required, which draws a very inefficient design. </span><span class="koboSpan" id="kobo.16.2">You will definitely agree with me if I say that it is a tightly coupled architecture.</span></p>
<p><span class="koboSpan" id="kobo.17.1">Moreover, the consumer of the service won't be able to identify the dependencies while instantiating the service. </span><span><span class="koboSpan" id="kobo.18.1">That is because Locator is used internally inside the constructor or the methods and not exposed, unlike the DI strategy:</span></span></p>
<pre><span class="koboSpan" id="kobo.19.1">    var empService = new EmployeeService();</span></pre>
<p><span class="koboSpan" id="kobo.20.1">Now you might argue, Why would the developer would try to know what's inside because the dependencies are internally handled inside the default constructor? </span><span class="koboSpan" id="kobo.20.2">But what will happen if you forgot to register the dependency to Locator? </span><span class="koboSpan" id="kobo.20.3">Don't say that you won't forget. </span><span class="koboSpan" id="kobo.20.4">Most likely it will happen because, while you instantiate the class, the dependency's existence is not clear through the constructor. </span><span class="koboSpan" id="kobo.20.5">Therefore, if the class is not telling you what it depends on, you won't be so careful in finding and registering it, which would throw up unexpected exceptions.</span></p>
<p><span class="koboSpan" id="kobo.21.1">I know what you are thinking now; apparently, the service is a type of Control Freak, isn't it? </span><span class="koboSpan" id="kobo.21.2">It is taking control of the dependencies using Locator.</span></p>
<p><span><span class="koboSpan" id="kobo.22.1">The needy class means the class that depends on someone else. </span><span class="koboSpan" id="kobo.22.2">It no longer follows DI because the dependency is not injected; rather, it is fetched from Locator's </span></span><kbd><span class="koboSpan" id="kobo.23.1">static</span></kbd><span><span class="koboSpan" id="kobo.24.1"> dictionary.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">Another problem is clearly identifiable when the developer wants to add more dependencies to the class that has already adopted the Locator Pattern. </span><span class="koboSpan" id="kobo.25.2">Either you follow the same principle to introduce more dependencies or remove the Service Locator pattern and implement DI. </span><span class="koboSpan" id="kobo.25.3">Compilation errors are a certainty in both these cases.</span></p>
<p><span class="koboSpan" id="kobo.26.1">For all the preceding reasons, Service Locator is considered an anti-pattern. </span><span class="koboSpan" id="kobo.26.2">Let's talk about a robust solution to address this </span><span><span class="koboSpan" id="kobo.27.1">anti-pattern</span></span><span class="koboSpan" id="kobo.28.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Solution</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As usual, Constructor Injection is the best fit and comes to mind first when we decide to refactor Service Locator codes. </span><span class="koboSpan" id="kobo.2.2">Complete removal of Service Locator can be achieved through Constructor Injection.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Refactoring steps</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In most cases, Locator is used everywhere in the code base to get an instance of the dependency. </span><span class="koboSpan" id="kobo.2.2">Follow these steps to refactor it towards DI:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Identify all the Locator calls in the code base.</span></li>
<li><span class="koboSpan" id="kobo.4.1">Introduce a member variable to the class to hold the dependency, if that is not present.</span></li>
<li><span class="koboSpan" id="kobo.5.1">Mark the field </span><kbd><span class="koboSpan" id="kobo.6.1">readonly</span></kbd><span class="koboSpan" id="kobo.7.1"> so that it can't be modified outside the constructor.</span></li>
<li><span class="koboSpan" id="kobo.8.1">Assign the field inside the constructor using the Locator. </span><span class="koboSpan" id="kobo.8.2">Now the Locator call is in one place.</span></li>
<li><span class="koboSpan" id="kobo.9.1">Add a constructor parameter for the dependency.</span></li>
<li><span class="koboSpan" id="kobo.10.1">Remove Locator from the constructor block and directly assign the constructor parameter to the </span><kbd><span class="koboSpan" id="kobo.11.1">readonly</span></kbd><span class="koboSpan" id="kobo.12.1"> field.</span></li>
<li><span class="koboSpan" id="kobo.13.1"> Identify all the instantiation made to the class and move the wiring to a Composition Root.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.14.1">After all these steps, the same </span><kbd><span class="koboSpan" id="kobo.15.1">EmployeeService</span></kbd><span class="koboSpan" id="kobo.16.1"> with the Constructor Injection Pattern can be designed, shown as follows:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    public class EmployeeService : IEmployeeService</span><br/><span class="koboSpan" id="kobo.18.1">    {</span><br/><span class="koboSpan" id="kobo.19.1">      private readonly IEmployeeRepository repository;</span><br/><span class="koboSpan" id="kobo.20.1">      public EmployeeService(IEmployeeRepository repository)</span><br/><span class="koboSpan" id="kobo.21.1">      {</span><br/><span class="koboSpan" id="kobo.22.1">        this.repository = repository;</span><br/><span class="koboSpan" id="kobo.23.1">      }</span><br/><span class="koboSpan" id="kobo.24.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.25.1">The service now asks its consumers to provide a dependency of type </span><kbd><span class="koboSpan" id="kobo.26.1">IEmployeeRepository</span></kbd><span class="koboSpan" id="kobo.27.1"> implementation, which was not happening before.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The last chapter illustrated ways to implement DI. </span><span class="koboSpan" id="kobo.2.2">When we don't implement patterns correctly, we end up with a bad design for our app. </span><span class="koboSpan" id="kobo.2.3">We learned about mistakes we regularly make while implementing DI.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Before moving on to DI anti-patterns, we discussed why and when we can consider DI as an anti-pattern itself!</span></p>
<p><span class="koboSpan" id="kobo.4.1">Then we moved ahead and touched upon all those common </span><span><span class="koboSpan" id="kobo.5.1">anti-patterns</span></span><em><span class="koboSpan" id="kobo.6.1"> </span></em><span class="koboSpan" id="kobo.7.1">caused by misconceptions regarding Dependency Injection. </span><span class="koboSpan" id="kobo.7.2">We explored Control Freak, Bastard Injection, Constrained Construction, and (the most important) Service Locator.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Control Freak is the easiest one to discover. </span><span class="koboSpan" id="kobo.8.2">Whenever you see any class </span><span><span class="koboSpan" id="kobo.9.1">using the </span><kbd><span class="koboSpan" id="kobo.10.1">new</span></kbd><span class="koboSpan" id="kobo.11.1"> keyword to instantiate </span></span><span class="koboSpan" id="kobo.12.1">its dependencies, that means it is trying to manage them without any external module controlling it. </span><span class="koboSpan" id="kobo.12.2">This is bad and should be avoided in the DI ecosystem.</span></p>
<p><span class="koboSpan" id="kobo.13.1">This is the most dangerous one, which we should address first while refactoring. </span><span class="koboSpan" id="kobo.13.2">Other patterns are less damaging than this because it has a direct impact on loose coupling. </span><span class="koboSpan" id="kobo.13.3">Composition Root should be the place to instantiate everything needed for the application and then every possible dependency will be available by injection.</span></p>
<p><span class="koboSpan" id="kobo.14.1">Bastard Injection can be seen with Foreign Defaults which is unnecessary from the DI point of view. </span><span class="koboSpan" id="kobo.14.2">We can easily move to Constructor Injection by removing codes related to Foreign Defaults.</span></p>
<p><span class="koboSpan" id="kobo.15.1">On the other hand, Constrained Construction imposes restrictions on constructors to support late binding of services by taking types from configuration files, which in turn creates tight coupling. </span><span class="koboSpan" id="kobo.15.2">Adopting a DI Container or one Abstract Factory would help to eliminate constraints.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Last but not the least, we discussed Service Locator, which is arguably a proper Pattern. </span><span class="koboSpan" id="kobo.16.2">However, we explored its pros and cons and came to the conclusion that it is an anti-pattern.</span></p>
<p><span class="koboSpan" id="kobo.17.1">If you have reached this point, that means you have now have grasped the ways to implement DI and what to avoid. </span><span class="koboSpan" id="kobo.17.2">In the next chapter, we will be discussing more realistic problems in projects and how to deal with them.</span></p>


            </article>

            
        </section>
    </body></html>