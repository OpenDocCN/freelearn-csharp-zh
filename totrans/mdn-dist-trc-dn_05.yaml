- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration and Control Plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we learned how to enable auto-instrumentation with
    a few lines of code and leverage collected telemetry to debug issues and monitor
    performance. Auto-collected traces and metrics provide the basis for your observability
    solution, but they are rarely sufficient without an application context. In this
    chapter, we’ll learn how to customize telemetry collection – enrich, adjust, or
    control its volume. We will dive into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling costs with sampling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enriching and filtering telemetry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing context propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a processing pipeline with the OpenTelemetry Collector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to choose a sampling strategy and
    configure it in your system, efficiently enrich auto-generated traces with custom
    attributes, and propagate your context between services. We’ll see also how to
    suppress noisy spans and metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the book’s repository on GitHub at
    [https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5),
    which has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sampling` application contains sampling code snippets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `memes` application is an improved version of the meme service from [*Chapter
    2*](B19423_02.xhtml#_idTextAnchor038), *Native Monitoring in .NET*, which contains
    enrichment and context propagation examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run samples and perform analysis, we’ll need the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET SDK 7.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and `docker-compose`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling costs with sampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracing all operations gives us the ability to debug individual issues in the
    system, even very rare ones, but it could be impractical from a performance and
    telemetry storage perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The performance impact of optimized and succinct instrumentation is usually
    low, but telemetry ingestion, processing, storage, queries, and other observability
    experiences could be very costly.
  prefs: []
  type: TYPE_NORMAL
- en: Observability vendors’ pricing models vary – some charge for the volume of ingested
    traces, others for the number of events, traces, or hosts reporting data. The
    ingestion cost usually includes retaining telemetry for 1 to 3 months. Data retrieval
    and scanning are also billed by some vendors. Essentially, costs associated with
    sending and retrieving telemetry grow along with telemetry volume.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, we’re going to be interested in a very small fraction of traces
    – ones that record failures, long requests, and other rare cases. We may also
    query a subset of traces for analytics purposes.
  prefs: []
  type: TYPE_NORMAL
- en: So, collecting all traces comes at a relatively small performance hit and could
    be reasonable, but storing all of them on an observability backend is rarely justified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might consider using traces as audit logs and then need every operation
    to be recorded. However, we need traces to debug and resolve incidents in production,
    which implies a fast query time, potentially short retention, and traces being
    accessible by every on-call person. Audit logs usually need a different privacy
    and retention policy. They also don’t necessarily require fast and random access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sampling** is a technique that allows recording a subset of traces, thus
    reducing storage costs. There are two main approaches to sampling: **head-based**
    and **tail-based**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both head-based and tail-based sampling rely on trace context propagation that
    needs to happen regardless of the sampling decision.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at different sampling approaches and see how and when
    to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: Head-based sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With head-based sampling, the decision to record or not record a trace is done
    when the trace is started by the application process and is usually random (or
    based on information available beforehand). The assumption here is that under
    high-scale problems that need attention happen frequently enough to record at
    least some occurrences. In other words, problems that are never recorded are too
    rare and are likely less important. “Too rare” and “frequently enough” here totally
    depend on application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Head-based sampling algorithms try to be consistent so that we can capture all
    spans or none of them in any trace. It’s achieved by either following upstream
    sampling decisions or making independent, but consistent, decisions on each service.
    Let’s learn more about these approaches and also check how we can implement custom
    sampling solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Parent-based sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `traceparent`. For example, as we saw in [*Chapter 1*](B19423_01.xhtml#_idTextAnchor016),
    *Observability Needs of Modern Applications*, `traceparent` with `00-trace1-span1-01`
    indicates that upstream services recorded this span, and `00-trace2-span2-00`
    indicates that the span was not recorded. To enable this behavior in OpenTelemetry,
    you can use `ParentBasedSampler`. When all services follow the parent decision,
    the sampling probability (or percentage or recorded traces) configured on the
    first component applies to all downstream services.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With using parent-based sampling, the component that makes decision needs to
    be fully trusted – if it starts to record all traces, it might overload your telemetry
    collection pipeline and could cause your observability backend costs to skyrocket.
    You would normally make sampling decisions on your API gateway or frontend and
    would never trust sampling decisions coming from an external client.
  prefs: []
  type: TYPE_NORMAL
- en: The root component still needs to make independent sampling decision. Even though
    this decision can be random and other services would follow, it’s a good idea
    to stick to OpenTelemetry (or your observability vendor) sampling algorithms and
    keep them consistent across the system.
  prefs: []
  type: TYPE_NORMAL
- en: Probability sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach involves making a sampling decision on every service but doing
    it consistently, so `trace` that’s recorded on one service would be recorded on
    another if they have the same sampling rate configured.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the `trace-id`. If the score is smaller than the probability,
    the span is recorded, otherwise, it’s dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Probability sampling reduces your costs by only recording a fraction of the
    traces. Unexpected loads or bursts of traffic result in prorated growth in the
    volume of recorded traces. OpenTelemetry for .NET does not support a fixed-rate
    sampler out of the box, but you can configure the collector to do it or your observability
    vendor may provide one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probability sampling is implemented in OpenTelemetry with `TraceIdRatioBasedSampler`
    and can be configured with the `SetSampler` method on `TracerProviderBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: We set the probability to `0.1` in this example, which means that 10% of all
    traces will be recorded.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we want to configure parent-based sampling on downstream components,
    we should set an instance of `ParentBasedSampler` instead, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to provide a sampler that’s used when there is no parent trace context
    – in this example, we’re sampling out all the requests that come without `traceparent`.
    We could customize parent-based samplers further – set samplers to handle different
    cases: when the parent is remote or local, and whether the parent is recorded
    or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Consistent sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming all services have the same sampling probability configured, all spans
    in a trace will be recorded or dropped consistently – there will be no partial
    traces. However, using the same rate for all services is not always practical.
    You might want to configure higher sampling probability on a new service, or for
    one that has a small load. We can do it using a probability sampler by configuring
    it to different rates on different services.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we should expect that some tracers will be recorded partially.
    *Figure 5**.1* shows an example of a partial trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Services with different sampling probabilities](img/B19423_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Services with different sampling probabilities
  prefs: []
  type: TYPE_NORMAL
- en: Service A starts a trace – it generates trace-id and makes a sampling decision
    by calculating the score and comparing it to the sampling probability configured
    on the service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say the score is `0.1` – it’s smaller than the probability (`0.2`), so
    the request is sampled in, and we should record the corresponding span and its
    local children. Then `0.01`. **Service B** calculates the score – it’s the same,
    so the decision is to not record the span or its local children. But then **Service
    B** calls **Service C**, which records corresponding spans.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, for this trace, we’ll have spans from `trace-id` had a different
    score, for example, `0.005`, all services would record corresponding spans and
    we’d have a complete trace.
  prefs: []
  type: TYPE_NORMAL
- en: Probability sampling relies on `trace-id` being random and that the same hash
    function is used to calculate the score for each span. This is the case if you
    use vanilla OpenTelemetry in the same language on all your services and don’t
    customize ID generation or configure vendor-specific samplers. If your `trace-id`
    is not random or if you have to use different sampling algorithms, we need a slightly
    different approach called **consistent sampling**. It’s experimental and not implemented
    in .NET at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach relies on sampling score propagation: the component that starts
    the trace calculates the sampling score using any algorithm and propagates it
    to downstream services via `tracestate`. Downstream services don’t need to calculate
    the score again – they read it from `tracestate` and make a sampling decision
    by comparing this score to their configured probability.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom sampler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can implement your own samplers. For example, `DebugSampler` records all
    activities that have a `debug` flag in a `tracestate` header and uses the probability
    sampler for all other activities. With this sampler, you can force the trace to
    be recorded, by sending a request with valid `traceparent` and `tracestate: myapp=debug:1`
    headers, which can be useful when testing or reproducing problems:'
  prefs: []
  type: TYPE_NORMAL
- en: DebugSampler.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: The sampler implements a `ShouldSample` method, which takes `SamplingParameters`
    in and returns `SamplingResult`.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling parameters include parent trace context and additional details such
    as creation-time attributes, the `Activity` name, kind, `tracestate`, and links.
  prefs: []
  type: TYPE_NORMAL
- en: '`SamplingResult` is a struct that contains a `SamplingDecision` enum that takes
    one of three possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Drop`: Create `Activity`, but don’t record it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecordAndSample`: Create `Activity`, record it, and set the sampling flag
    on trace context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecordOnly`: Create `Activity` and record it, but don’t set a sampling flag
    on trace context. Built-in samplers never return a `RecordOnly` decision, but
    you can implement a custom sampler and return such a decision to a trace request
    locally without forcing downstream services to follow it (if they respect parent
    decisions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SamplingResult` also contains updated `tracestate` values and attributes –
    samplers can set them, and they will be used on the activity-to-be-created. We
    can configure this sampler in the same way as before, by calling the `SetSampler`
    method on the `TracerProviderBuilder` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With OpenTelemetry, an activity is created for every sampling decision. But
    in .NET, it’s possible to prevent a sampled-out `Activity` from being created
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn more about sampling in vanilla .NET in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing Your Code*, and will see some examples of how instrumentations can suppress
    activity creation later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tail-based sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With tail-based sampling, the decision is made after the trace ends and could
    consider trace duration, presence of errors, or any other information available
    on spans. As you can imagine, we should first buffer all spans in the trace and
    then send all of them to the observability provider or drop all of them. Tail-based
    sampling must happen across different services and can only be done by an external
    component such as the OpenTelemetry Collector. The tail-sampling processor in
    the Collector is highly configurable and supports multiple sampling policies,
    including rate-limiting, latency, and status-code-based policies. You can combine
    multiple policies together. It’s not really possible to know when a trace ends,
    so the Collector starts buffering spans after the first span in that trace is
    received for a configurable time period and then makes a decision based on the
    available data.
  prefs: []
  type: TYPE_NORMAL
- en: The tail-based sampling processor in collector allows the creation of composite
    sampling strategies. For example, you can configure probability sampling on your
    .NET services to minimize performance impact and then apply rate limiting on the
    collector to control telemetry volume and observability backend costs.
  prefs: []
  type: TYPE_NORMAL
- en: You could also configure a higher sampling probability to collect more traces
    with bigger latency, errors, or specific attributes. Buffering is currently limited
    to a single instance of the Collector, so if spans from the same trace end up
    on different collectors, tail-based sampling may produce partial traces, but still
    would capture parts corresponding to failure or increased latency. Since tail-based
    sampling has to buffer spans, it is memory-consuming and requires additional compute
    resources, and works well for short traces. As usual, it makes sense to compare
    the costs of managing the Collector setup with the savings it brings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With non-probabilistic sampling, usage analysis based on traces is skewed and
    could be misleading. Metrics collected inside the application independently of
    traces could still be your source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your needs, you may combine different approaches – for example,
    collect all data but keep it in a cold(ish) storage, only using a more expensive
    backend for a small subset of traces.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to choose a sampling strategy and implement it in your system!
    Let’s move and explore how to enrich spans with additional context.
  prefs: []
  type: TYPE_NORMAL
- en: Enriching and filtering telemetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traces and metrics coming from auto-instrumentation describe the technical side
    of an operation. While we can always add more spans with custom context (and we’ll
    learn how to do it in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing
    Your Code*), it could be more practical to add custom context to auto-collected
    telemetry.
  prefs: []
  type: TYPE_NORMAL
- en: Application-specific context is necessary to track usage and contains essential
    information that helps to detect and investigate issues.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we take our meme service, it would be very helpful to have the
    meme name and size on spans. With this, we’d be able to find the most popular
    memes, correlate meme upload and download requests, plan capacity, make cache
    optimizations, or reason about partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to add a meme name is via the `Activity.SetTag` method. For
    example, we can the following code on the `Meme` page:'
  prefs: []
  type: TYPE_NORMAL
- en: Meme.cshtml.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Activity.Current` here is created by ASP.NET Core. It was enabled with OpenTelemetry
    ASP.NET Core instrumentation – if tracing was disabled, `Activity.Current` would
    be `null` here, so we should always guard `Activity.Current` with a `null` check
    or use null coalescence.'
  prefs: []
  type: TYPE_NORMAL
- en: We also check whether the activity is recorded – if the `IsAllDataRequested`
    flag is `true`. There is no point in recording attributes on a sampled-out activity,
    so it’s an optimization. While it’s very small in this case, it’s a good practice
    to use it to avoid any unnecessary string allocations or prevent heavier operations
    needed to retrieve the attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `SetTag` – a method that takes the string tag name and nullable
    object value. We’ll talk more about the Activity API and tags in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098),
    *Tracing* *Your Code*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A tag in the .NET Activity API is the same as the OpenTelemetry `span` attribute.
    Tags came from OpenTracing and were not renamed for backward-compatibility reasons.
    This book uses *tag* and *attribute* interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we can add meme names to all ASP.NET Core activities. But
    what about HTTP client and MySQL activities? Having meme names on them would be
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: In the general case, it can be done with a span processor, but some instrumentations
    provide extensibility hooks allowing them to enrich their activities.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of these approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Span processors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The span processor is a component of the OpenTelemetry export pipeline. When
    OpenTelemetry is notified about activity start or stop events, it synchronously
    calls the corresponding method on the processor. By implementing our own processor
    and adding it to the tracer provider, we can intercept all activities and add
    attributes from `AsyncLocal`, `ThreadLocal`, or another context available globally.
    We could also overwrite or remove attributes or filter out activities.
  prefs: []
  type: TYPE_NORMAL
- en: Enriching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we do this for the meme name, we need to decide how to pass it to the
    processor. Since we want meme names to be on all spans from all services, it would
    be a good case for baggage. Baggage, as we saw in [*Chapter 1*](B19423_01.xhtml#_idTextAnchor016),
    *Observability Needs of Modern Applications*, represents application-specific
    context propagated between services.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s go ahead and add the meme name to the baggage on the frontend `Meme`
    and `Upload` pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Meme.cshtml.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `Baggage` does not always affect an activity that has started beforehand
    and is current now – it’s a side effect of `AsyncLocal`, and we’ll dig into this
    in [*Chapter 6*](B19423_06.xhtml#_idTextAnchor098), *Tracing Your Code*. So, we’re
    going to keep setting meme name tags on activities on the frontend pages. `Baggage`
    uses `AsyncLocal` underneath, so we can now reliably use it in the processor:'
  prefs: []
  type: TYPE_NORMAL
- en: MemeNameEnrichingProcessor.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re overriding the `OnEnd` method here – we first get the meme name from the
    baggage and add it as a tag to the activity. We don’t need to check whether the
    activity is `null` since the processor won’t be called in such a case, but we
    might still need to check whether it’s sampled in because, as we’ll see soon,
    sampled-out activities can still sometimes reach your processor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We get a name from `Baggage.Current`, but if it’s not there, we also check `Activity.Baggage`.
    The reason is that the `Baggage` type lives in the `OpenTelemetry` namespace and
    can be used beyond tracing. But ASP.NET Core is not aware of it and populates
    `Baggage` on `Activity`. As a rule of thumb, always set `Baggage` with `Baggage.SetBaggage`,
    but read it from `Baggage` and `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to register this processor on `TracerProvider` on the frontend
    and storage services:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it – the frontend adds a meme name to `Baggage`, then `Baggage` is automatically
    propagated to **storage**. Whenever any activity ends, the enriching processor
    stamps the meme name on it.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, we can also use the processor to remove unwanted tags by calling
    `SetTag` with a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to drop some activities – for example, those that represent
    retrieving static files on a frontend or requests from web crawlers.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping an activity after it has started in the middle of a trace breaks causation.
    It should be only done for activities that don’t have any children.
  prefs: []
  type: TYPE_NORMAL
- en: Some instrumentations provide a hook to suppress activities so they are never
    even created – we’ll see some examples of it later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'But instrumentations don’t always support suppression, and filtering out already
    started activities might be the only option. Let’s see how to do it with a processor:'
  prefs: []
  type: TYPE_NORMAL
- en: StaticFilesFilteringProcessor.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: In this processor, we check whether the activity has a `Server` kind (describes
    an incoming request), a `GET` method, and does not have a route. We can only check
    route presence in the `OnEnd` callback as the route is calculated after the activity
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we unset the recording flag on `Activity` so it will be dropped later
    in the exporting pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: You may come up with a better heuristic to identify static files, and if it
    doesn’t require a route, you could suppress such activities using ASP.NET Core
    instrumentation options, as we’ll see a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To register this processor, add it to `TracerProviderBuilder` with the `AddProcessor`
    method. Make sure to add processors in the order you want them to run:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: We just learned how to filter and enrich activities with processors; let’s now
    see what we can do with instrumentation options.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing instrumentations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instrumentations may provide configuration options allowing to customize telemetry
    collection. For example, you can configure recording exception events with HTTP
    client and ASP.NET Core instrumentations through the `RecordException` flag on
    the corresponding configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Instrumentations can also provide callbacks allowing to populate attributes
    from instrumentation-specific contexts such as `request` or `response` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use it to set a request size on incoming HTTP requests on storage, so
    we can analyze meme sizes using ASP.NET Core instrumentation enrichments hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to ASP.NET Core, you can find similar hooks for HTTP, gRPC, and
    SQL client instrumentations available in the `opentelemetry-dotnet` repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same instrumentations also provide hooks that prevent `Activity` from being
    created. For example, if we wanted to suppress activities created for static files
    instead of dropping them in the processor, we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: If you consider suppressing or enriching individual activities based on dynamic
    context, instrumentation hooks, when available, are the best option. If you want
    to enrich all activities with ambient context, processors would be the right choice.
    Let’s now see how to populate static context on all activities with resources.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An OpenTelemetry resource describes a service instance – it’s a set of static
    attributes describing the service name, version, namespace, instance, or any other
    static property. OpenTelemetry defines semantic conventions for Kubernetes, generic
    containers, clouds, processes, OS, devices, and other common resource kinds.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure resources explicitly or through environment variables. For
    example, we already used the `OTEL_SERVICE_NAME` environment variable to configure
    the service name. We can set `OTEL_RESOURCE_ATTRIBUTES` to a list of comma-separated
    key-value pairs (for example, `region=westus,tag=foo`) to specify any custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicit configuration can be done with `ResourceBuilder`, which we should
    register on `TraceProviderBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that environment variable detection is done by default, but you can turn
    it off by using `ResourceBuilder.CreateEmpty` instead of the `CreateDefault` factory
    method. Resources are populated on each of the signals, and we can configure different
    resources for traces, metrics, and logs if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re ready to run the meme service and check out the result. Go ahead and
    run it with `compose up --build`. After the application starts, hit the frontend
    at `http://locahost:5051` and upload and download some memes. Now, you should
    be able to see new attributes – meme names on all spans and content size on incoming
    requests on storage. *Figure 5**.2* shows an example of a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes](img/B19423_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'We also get new resource attributes on every exported span, as well as exception
    events on incoming and outgoing HTTP spans, as shown in *Figure 5**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Resource attributes and exception events](img/B19423_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Resource attributes and exception events
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see `service.version`, `service.namespace`, `service.instance.id`,
    `env`, `region`, and `tag` attributes coming from our application, while `host.name`
    and `os.type` are added later on by the OpenTelemetry Collector resource detector.
  prefs: []
  type: TYPE_NORMAL
- en: With resource attributes, processors and baggage, instrumentation hooks, and
    flags, you can customize telemetry auto-collection, enrich activities with custom
    attributes, add events, and record exceptions. You can also change or remove attributes
    and suppress or filter out activities. But what about metrics, can we customize
    them?
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auto-collected metrics are not as customizable as traces. With OpenTelemetry
    SDK, we can only enrich them using static resource attributes, but OpenTelemetry
    Collector provides processors that can add, remove, or rename attribute names
    and values, aggregate across attributes, change data types, or massage metrics
    in other ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, you can filter out specific instruments or their attributes using the
    `MeterProviderBuilder.AddView` method. For example, you can drop an instrument
    with a specific name using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus replaces the dot with an underscore and the corresponding instrument
    appears as `process_runtime_dotnet_jit_il_compiled_size` there. Check the corresponding
    OpenTelemetry instrumentation documentation to find the original name of the instrument.
    For example, .NET runtime instrumentation documentation can be found here: git[hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md](http://hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify attributes you want on the instrument – OpenTelemetry will
    use only those specified and will drop other attributes. It can be done to save
    costs on unused attributes or to remove high-cardinality attributes added by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code removes `http.scheme` and `http.flavor` from the ASP.NET
    Core request duration metric:'
  prefs: []
  type: TYPE_NORMAL
- en: Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: We just saw how to enrich traces and metrics with application-specific context,
    and update or remove attributes using different mechanisms available in OpenTelemetry.
    Let’s continue exploring OpenTelemetry configuration and learn how to configure
    context propagation.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing context propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When instrumenting new systems, using W3C trace context propagation is the default
    and the easiest option – it does not need any explicit configuration since .NET
    and OpenTelemetry use it by default. However, existing systems may employ legacy
    context propagation conventions.
  prefs: []
  type: TYPE_NORMAL
- en: To support them, we can configure a custom global propagator on OpenTelemetry
    using `Sdk.SetDefaultTextMapPropagator`. For example, if one of your old client
    applications still uses some variation of custom correlation ID, you can still
    read it from request headers and convert it to a `trace-id`-compatible format
    (or move it to baggage).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a composite propagator and support multiple standards at once as
    shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: XCorrelationIdPropagator.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs](https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we configured the B3 propagator from the `OpenTelemetry.Extensions.Propagators`
    package, a custom one for the `x-correlation-id` support, and also one for baggage.
    Note that we also disabled native ASP.NET Core and HTTP client propagation by
    setting `DistributedContextPropagator.Current` to the no-output propagator. If
    we don’t do it, they will keep extracting and injecting `Trace-Context` headers.
  prefs: []
  type: TYPE_NORMAL
- en: When using composite context propagators, make sure to resolve collisions and
    define priority in case you get multiple conflicting combinations of trace context
    in the same request – we’ll talk more about it in *Chapter 16*, *Instrumenting*
    *Brownfield Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Processing a pipeline with the OpenTelemetry Collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve seen before, the OpenTelemetry Collector is another component that’s
    capable of controlling, enriching, filtering, converting, routing, aggregating,
    sampling, and processing telemetry in any other possible way. *Figure 5**.4* shows
    the main Collector components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – OpenTelemetry Collector pipeline](img/B19423_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – OpenTelemetry Collector pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Receivers get telemetry from different sources, and processors massage data
    and pass it over to exporters.
  prefs: []
  type: TYPE_NORMAL
- en: Since the collector is a separate process, potentially running on a different
    machine, it does not have a dynamic context, such as a specific HTTP request header,
    which you might want to stamp on spans. Such context can only be added inside
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: But the collector could have more context about the environment the application
    runs in – for example, it can enrich telemetry with Kubernetes or cloud provider
    context. It can also receive telemetry in any format and convert it into OpenTelemetry
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: The Collector supports a variety of receivers including Docker stats, statsd,
    or containerd for metrics, Kubernetes events, syslog, or journald for logs, and
    many others. Collector processors can enrich, filter, or change attribute names
    and values on any signal. One of the common use cases is sensitive data redaction.
  prefs: []
  type: TYPE_NORMAL
- en: You can find available Collector components in the OpenTelemetry Registry, [https://opentelemetry.io/registry](https://opentelemetry.io/registry);
    just make sure to check the stability level for each component you consider using.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, it’s not a question of whether to configure and customize your
    telemetry pipeline in-process or with Collector – it’s both. Collector can help
    you migrate from one observability stack to another, provide safety belts on telemetry
    collection, and offload some work from your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we explored telemetry auto-collection, and now we have
    learned how to customize this telemetry. We learned about different sampling approaches
    – head-based and tail-based. Head-based sampling makes the decision to record
    a trace (or span) when it starts with a certain probability. Children can follow
    parent decisions and then traces are always complete, but it’s not possible to
    control the volume of traces on individual services. To overcome this, downstream
    services can configure different rates and use consistent sampling to maximize
    the number of complete traces. Some traces become partial but are still useful
    for monitoring individual services or groups of them.
  prefs: []
  type: TYPE_NORMAL
- en: Probability sampling captures a percentage of all traces and is great to mitigate
    performance overhead. If you need predictable costs, you should consider rate-based
    sampling. It’s implemented in the OpenTelemetry Collector or by observability
    vendors. The OpenTelemetry Collector can also do tail-based sampling and record
    failures and long traces with higher probability.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-instrumentations collect generic information, so we need to add application-specific
    context to gain a much deeper level of observability. Enrichment can be done inside
    the process with resources – static attributes describing your service instance,
    or with span processors, instrumentation hooks, or configuration options that
    can capture dynamic context. We can add, remove, or change attributes, and we
    can use baggage to propagate application-specific context within our system.
  prefs: []
  type: TYPE_NORMAL
- en: We can sometimes suppress activities with instrumentation hooks or flags or
    filter them out using processors. Filtering activities that have already started
    should be done with caution as it will break the correlation between dropped activity’s
    ancestors and successors. It should only be done for activities that don’t have
    children.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics allow some customization too – we can enrich them with resource attributes,
    drop specific instruments, or limit attributes populated by instrumentations.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at context propagation customization, which can provide interoperability
    with custom and legacy correlation solutions you might have.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we talked about Collector features that can be used in addition to
    in-process configuration – environment resource detection or filtering and massaging
    telemetry. It can also provide rate-limiting sampling and protect your telemetry
    pipeline from overloading.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned to choose a sampling strategy and implement it,
    enrich traces with application context, and customize context propagation. It
    concludes our auto-instrumentation journey; from now on, we’re going to explore
    instrumentation internals and learn how to write our own. In the next chapter,
    we’ll focus on creating activities.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you build a general-purpose sampling solution that also captures failures
    and long-running traces in a distributed application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you record retries on the HTTP client spans?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure rate-limiting sampling on the OpenTelemetry Collector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
