- en: Chapter 8. Open Source Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：开源编程
- en: In this chapter, we're going to review the current state of open source programming
    with Microsoft technologies and tools. This is something that has been referred
    to by many technology evangelists as the open source ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾使用微软技术和工具的开源编程的当前状态。这是许多技术传教士所指的开放源代码生态系统。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: We'll start with the initial movements in this area and explore how they have
    evolved over time, summarizing the most important initiatives that any developer
    can access at this moment.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从该领域的初始动作开始，并探讨它们随时间的发展，总结任何开发者现在都可以访问的最重要倡议。
- en: Later, we'll revise some of the most popular implementations, either on the
    side of tools (IDEs) or APIs and languages.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将回顾一些最受欢迎的实现，无论是工具（IDE）还是API和语言。
- en: We'll look at programming with open source solutions, such as Node.js, how it's
    is supported within Visual Studio and how easy it is to create a project that
    uses Node with this environment, as well as how other IDE choices are available,
    such as Visual Studio Code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨使用开源解决方案进行编程，例如Node.js，它在Visual Studio中的支持情况，以及如何轻松创建一个使用Node的此环境的项目，以及其他IDE选择，如Visual
    Studio Code。
- en: 'Later, we''ll go through perhaps the two most important and adopted open source
    initiatives in Microsoft: the Roslyn project, a set of APIs and services that
    provide extended support for the development experience; and TypeScript, the new
    language created by C# author Anders Hejlsberg, which allows programmers to use
    advanced JavaScript features today, with excellent support of IDEs and total backwards
    compatibility.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将探讨微软最关键且被广泛采用的两个开源倡议：Roslyn项目，一组提供扩展开发体验支持的API和服务；以及由C#作者Anders Hejlsberg创建的新语言TypeScript，它允许程序员今天使用高级JavaScript功能，并得到IDE的出色支持以及完全向后兼容。
- en: Historical open source movements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史上的开源运动
- en: Microsoft began to pave the way in open source as far back as 2003, when the
    first moves were made in order to adopt GPL Licensing on some products, the most
    noticeable being the effort to standardize the .NET Framework platform in general
    and the C# Language in particular.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 微软早在2003年就开始在开源领域铺路，当时采取了一些举措以在产品上采用GPL许可，最引人注目的是努力将.NET框架平台（特别是C#语言）标准化。
- en: Actually, it was soon approved as a standard by ECMA (ECMA-334) and ISO (ISO/IEC
    23270:2006).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它很快就被ECMA（ECMA-334）和ISO（ISO/IEC 23270:2006）批准为标准。
- en: Later on, the Mono Project (Xamarin) ([https://en.wikipedia.org/wiki/Mono_(software)](https://en.wikipedia.org/wiki/Mono_(software))),
    which is now part of Microsoft, provided versions of .NET capable of running in
    Linux and MacOS. This was probably the first serious attempt to make C# universal.
    The Mono licensing model was clearly open ([http://www.mono-project.com/docs/faq/licensing/](http://www.mono-project.com/docs/faq/licensing/)),
    although their IDE was not (Xamarin Studio).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Mono项目（Xamarin）（[https://en.wikipedia.org/wiki/Mono_(software)](https://en.wikipedia.org/wiki/Mono_(software)))，现在是微软的一部分，提供了能够在Linux和MacOS上运行的.NET版本。这可能是第一个使C#通用的严肃尝试。Mono许可模式是明确开放的（[http://www.mono-project.com/docs/faq/licensing/](http://www.mono-project.com/docs/faq/licensing/)），尽管他们的IDE不是（Xamarin
    Studio）。
- en: However, the acquisition of Xamarin by Microsoft brought even better news to
    developers, since now, clients of Visual Studio Community Edition could find Xamarin
    tools and libraries embedded in the IDE with all the value of building Android,
    iOS, and Windows Phone solutions seamlessly. Likewise, there's a free release
    of the product called Xamarin Studio Community Edition.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，微软收购Xamarin给开发者带来了更好的消息，因为现在，Visual Studio Community Edition的客户可以在IDE中找到嵌入的Xamarin工具和库，无缝构建Android、iOS和Windows
    Phone解决方案，并享有所有这些价值。同样，还有一个名为Xamarin Studio Community Edition的免费产品版本。
- en: Other projects and initiatives
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他项目和倡议
- en: However, what's been discussed so far was only part of the landscape. From 2005,
    they started to contribute to well-known open source initiatives, such as Linux
    and Hadoop, in order to use internally open source products and tools and publish
    some results.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止所讨论的只是冰山一角。从2005年开始，他们开始为知名的开放源代码倡议做出贡献，如Linux和Hadoop，以便内部使用开源产品和工具，并发布一些成果。
- en: Some of the best-known projects were the .NET Foundation initiative and WinJS,
    a library to use JavaScript that allows access to the Windows APIs and that appeared
    aligned with the Windows 8 suite of operating systems, permitting developers to
    build applications made with HTML5, CSS3, and JavaScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些最知名的项目包括.NET基金会的倡议和WinJS，这是一个使用JavaScript的库，允许访问Windows API，并且与Windows 8操作系统的套件保持一致，允许开发者使用HTML5、CSS3和JavaScript构建应用程序。
- en: Azure has been another important division where Microsoft started to show its
    interest in open source. To previous movements supporting Linux and MacOS directly
    in Azure, we have to add the recent announcement of SQL Server running in Linux
    ([http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux](http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux)),
    and the availability of PowerShell for Mac OS and Linux.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Azure一直是微软开始展示其对开源兴趣的重要部门。在直接在Azure中支持Linux和MacOS的先前运动中，我们必须加上最近宣布的SQL Server在Linux上运行([http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux](http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux))，以及PowerShell在Mac
    OS和Linux上的可用性。
- en: 'The latest announcements, officially confirmed in November''s Connect() event,
    only deepen that philosophy: Microsoft becomes a Platinum Partner of the Linux
    Foundation, one in three virtual machines running in Azure is a Linux "distro",
    and the inclusion of Bash in Windows 10 allows the native installation of several
    Linux "distros" in the system.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的公告，在11月的Connect()活动中正式确认，进一步加深了这一理念：微软成为Linux基金会的白金合作伙伴，Azure上运行的每三个虚拟机中就有一个是Linux“发行版”，Windows
    10中Bash的加入允许在系统中原生安装多个Linux“发行版”。
- en: On the other side, Google has become a member of the .NET Foundation and it's
    actively collaborating in the standardization of C#. Microsoft is as of this moment,
    the company with the highest amount of "open source" projects contributing in
    Github.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，谷歌已成为.NET基金会的成员，并积极参与C#标准的制定。截至目前，微软是GitHub上贡献“开源”项目数量最多的公司。
- en: Finally, the recent collaboration with Samsung and the Tizen initiative only
    extends the number of collaborations with the open source world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与三星和Tizen倡议的最新合作仅扩展了与开源世界的合作数量。
- en: Open source code for the programmer
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为程序员提供的开源代码
- en: 'What about the programmer? As we mentioned, to the announcement of the free
    Visual Studio Community Edition in 2013 followed the declaration that this tool
    is going to be free in later editions along with the opening of Xamarin Studio:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那程序员呢？正如我们提到的，2013年宣布免费Visual Studio Community Edition之后，声明了该工具将在后续版本中免费，同时Xamarin
    Studio的开放：
- en: '![Open source code for the programmer](img/image00565.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![为程序员提供的开源代码](img/image00565.jpeg)'
- en: This change was proposed in the spring of 2015 with the publication of Visual
    Studio Code, (free and available for Windows, Linux, and MacOS). It's a development
    tool that joins the capabilities of an editor with the debugging features of an
    IDE.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化是在2015年春季通过发布Visual Studio Code提出的，（免费且适用于Windows、Linux和MacOS）。它是一款将编辑器的功能与IDE的调试功能结合在一起的开发工具。
- en: 'How was Visual Studio Code coded so that it would work on the three platforms?
    Three projects? Not quite. It was done thanks to the other big movement that started
    in 2010, which we introduced in [Chapter 04](part0028.xhtml#aid-QMFO2 "Chapter 4. Comparing
    Approaches for Programming") *Comparing Approaches to Programming* and that I''ll
    cover later in this chapter: TypeScript.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那Visual Studio Code是如何被编码以在三个平台上工作的呢？三个项目？并非如此。这得益于2010年开始的另一个重大运动，我们在[第04章](part0028.xhtml#aid-QMFO2
    "第4章。比较编程方法")*比较编程方法*中介绍了它，并在本章后面会详细讨论：TypeScript。
- en: Other languages
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他语言
- en: Open source projects also appear with other tools and languages such as Node.js,
    now used as another type of project from Visual Studio (any version), Python,
    PHP, or Apache/Cordova. All these technologies are now part of the installable/programmable
    projects available from the IDE. This goes for GitHub as well, whose engineers
    collaborate to integrate it better with Visual Studio and Visual Studio Code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开源项目还出现在其他工具和语言中，如Node.js，现在作为Visual Studio（任何版本）的另一种项目类型使用，Python、PHP或Apache/Cordova。所有这些技术现在都是IDE中可安装/可编程项目的一部分。这也适用于GitHub，其工程师正在合作以更好地将其与Visual
    Studio和Visual Studio Code集成。
- en: 'In the case of Node.js, you have to install the templates for Visual Studio
    (a one-time, pretty straightforward operation), and you will be shown several
    templates when you select in to build a new project, as shown in the following
    screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的情况下，你必须安装 Visual Studio 的模板（这是一个一次性、相当直接的操作），当你选择构建新项目时，你会看到以下截图所示的几个模板：
- en: '![Other languages](img/image00566.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![其他语言](img/image00566.jpeg)'
- en: If you work with one of these projects, you'll discover that common tools on
    other platforms are, by default, available here as well, such as Grunt, Bower,
    NPM. Gulp, and so on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参与这些项目之一，你会发现其他平台上的常用工具默认也在这里可用，例如 Grunt、Bower、NPM、Gulp 等等。
- en: Just for the sake of completeness, let's perform a basic demo of Node.js with
    these templates and see how it works. If you select **Basic Node.js Express Application**,
    a whole application will be generated from the templates, including the files
    required to launch a working instance of Node.js and a simple web page that uses
    Node as the localhost web server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们使用这些模板进行 Node.js 的基本演示，看看它是如何工作的。如果你选择 **Basic Node.js Express Application**，将从模板生成一个完整的应用程序，包括启动
    Node.js 工作实例所需的文件以及一个使用 Node 作为本地主机 Web 服务器的简单网页。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For detailed information on Node, you can check another title in this "Mastering"
    series, with detailed documentation, explanations and demos: "Mastering Node.js",
    by Sandro Pasquali ([https://www.packtpub.com/web-development/mastering-nodejs](https://www.packtpub.com/web-development/mastering-nodejs)).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Node 的详细信息，你可以查看本系列中的另一本书籍，其中包含详细的文档、解释和演示：“Mastering Node.js”，作者桑德罗·帕斯卡利（[https://www.packtpub.com/web-development/mastering-nodejs](https://www.packtpub.com/web-development/mastering-nodejs)）。
- en: By default, the project uses the Express library, which works seamlessly with
    Node. The view engine is also the most common one in these projects (it's called
    Jade, and you can change it at any time or use one of the alternatives available).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目使用 Express 库，它与 Node 无缝协作。视图引擎也是这些项目中最常见的一个（它被称为 Jade，你可以随时更改它或使用可用的替代方案）。
- en: 'When reviewing the files generated, you''ll notice a number of libraries that
    have been downloaded and updated in our project. This is the result of the IDE''s
    interaction with the `package.json` configuration file, which establishes the
    libraries that the application depends on:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查生成的文件时，你会注意到在我们的项目中已下载和更新的许多库。这是 IDE 与 `package.json` 配置文件交互的结果，该文件确定了应用程序所依赖的库：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This file instructs the IDE to download all libraries required and all the dependencies
    these libraries rely upon.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件指示 IDE 下载所有必需的库以及这些库所依赖的所有依赖项。
- en: 'At launch, two windows will open. On the one hand, Console will open, and on
    the other hand, an instance of the default browser will open. In the console,
    Node.js is listening on two ports: the debugging port [`5858`] and the Express
    port [`1337`], which take care of web requests, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，将打开两个窗口。一方面，控制台将打开，另一方面，默认浏览器的实例将打开。在控制台中，Node.js 正在监听两个端口：调试端口 `[5858]`
    和 Express 端口 `[1337]`，它们负责处理 Web 请求，如下截图所示：
- en: '![Other languages](img/image00567.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![其他语言](img/image00567.jpeg)'
- en: 'As you can see in the preceding figure, two requests have been made at runtime:
    the rendered page (which Jade generates from the basic source code in the `index.jade`
    file) and the style sheet, which was referenced in the `layout.jade` file that
    serves as the master page in this demo. Both worked fine (`200` status).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，在运行时已发出两个请求：渲染的页面（Jade 从 `index.jade` 文件中的基本源代码生成）和样式表，它被引用在作为本演示中主页的
    `layout.jade` 文件中。两者都运行良好（状态码 `200`）。
- en: 'On the other hand, the resulting page from mixing these two .`jade` files (the
    actual master or the main page) is shown in the selected browser (note that you
    can select more than one browser to create a multi-browser debugging session):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，混合这两个 `.jade` 文件（实际的母版或主页）的结果将在选定的浏览器中显示（请注意，你可以选择多个浏览器以创建多浏览器调试会话）：
- en: '![Other languages](img/image00568.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![其他语言](img/image00568.jpeg)'
- en: 'Independently of the aspects of Node.js programming and its tools, you''ll
    observe that the tool''s support is very complete, so we can even mix projects
    that use different technologies in a single solution, and we don''t depend on
    an installation of IIS for debugging purposes anymore:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是 Node.js 编程及其工具的方面，还是工具的支持都非常全面，因此我们甚至可以在单个解决方案中混合使用不同技术的项目，并且不再依赖于 IIS 的安装来进行调试：
- en: '![Other languages](img/image00569.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![其他语言](img/image00569.jpeg)'
- en: 'Other remarkable areas where the community is very active in the Microsoft
    Open Source ecosystem are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Microsoft 开源生态系统中，社区非常活跃的其他显著领域如下：
- en: Entity Framework Core (now in version 1.1)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core（现在版本为 1.1）
- en: Microsoft Edge, where users can vote for new features under consideration and
    use the JavaScript internal engine (Chakra) for their own purposes (just like
    with Chrome's V8 engine)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Edge，用户可以在其中为正在考虑的新功能投票，并使用 JavaScript 内部引擎（Chakra）为自己的目的服务（就像 Chrome
    的 V8 引擎一样）
- en: Note
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about, and collaborate on, these projects at [https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter),
    as shown in the previous figure.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在 [https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter](https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter)
    上了解更多关于这些项目的信息，并参与协作，如图中所示。
- en: '.NET Core is the latest member in the .NET family, which enables the building
    of applications that work on any platform: Windows, Linux, or MacOS'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 是 .NET 家族中的最新成员，它使得构建可在任何平台上运行的应用程序成为可能：Windows、Linux 或 MacOS
- en: The Roslyn and TypeScript projects
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Roslyn 和 TypeScript 项目
- en: And, many, many more
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以及，还有更多更多
- en: The Roslyn project
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Roslyn 项目
- en: 'Also called .NET Compiler Platform and headed by Anders Hejlsberg, Roslyn is
    a set of tools and services that help the developer control, manage, and extend
    the capabilities of any source code editor or IDE and take care of the code in
    a number of ways, including edition, parsing, analyzing, and compilation. It is
    part of the .NET Foundation initiative:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为 .NET 编译器平台，由 Anders Hejlsberg 领导，Roslyn 是一套工具和服务，帮助开发者控制、管理和扩展任何源代码编辑器或
    IDE 的功能，并以多种方式照顾代码，包括编辑、解析、分析和编译。它是 .NET 基金会倡议的一部分：
- en: '![The Roslyn project](img/image00570.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Roslyn 项目](img/image00570.jpeg)'
- en: Actually, all the magic behind the editors (Intellisense, code snippets, code
    suggestions, refactoring, and so on) is managed by Roslyn.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编辑器（Intellisense、代码片段、代码建议、重构等）背后的所有魔法都是由 Roslyn 管理的。
- en: 'Overall, using Roslyn, you will be able to do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，使用 Roslyn，您将能够做到以下几件事情：
- en: Create custom, specific code examination tools, which can be incorporated in
    the editors in Visual Studio 2015 and other compatible tools. Along with this,
    you can expand the live code examination engine with your own guidelines. This
    implies that you can write diagnostics and code fixes (known as analyzers) and
    code refactoring rules for your APIs or your particular programming needs.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的特定代码检查工具，这些工具可以集成到 Visual Studio 2015 和其他兼容工具的编辑器中。此外，您还可以根据自己制定的指南扩展实时代码检查引擎。这意味着您可以为您的
    API 或特定的编程需求编写诊断和代码修复（称为分析器）以及代码重构规则。
- en: Furthermore, the Visual Studio Editor will identify code issues as you write,
    squiggling the code that requires consideration and proposing the best possible
    fixes.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Visual Studio 编辑器会在您编写代码时识别代码问题，对需要考虑的代码进行波浪线标记，并提出最佳可能的修复建议。
- en: You can instrument code generation, produce IL code (remember the demos we saw
    in previous chapters), and perform everyday, code-related jobs inside your .NET
    applications thanks to the compiler APIs.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以监控代码生成，生成 IL 代码（记得我们在前几章中看到的演示），并利用编译器 API 在您的 .NET 应用程序内部执行日常与代码相关的任务。
- en: Also, extensions are possible by building personalized plugins that can execute
    outside Visual Studio and also configure MSBuild and exploit the C# compiler to
    perform code-related jobs.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，通过构建个性化的插件，可以在 Visual Studio 之外执行，并配置 MSBuild，利用 C# 编译器执行与代码相关的任务，从而实现扩展。
- en: Create REPLs (read-evaluate-print loops) with your own IDE, which is able to
    examine and execute C# code.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的 IDE 创建 REPL（读取-评估-打印循环），该 IDE 能够检查和执行 C# 代码。
- en: Differences from traditional compilers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与传统编译器的不同之处
- en: Usually, compilers behave as black boxes or like a function in the source code,
    where the code to be compiled is the argument, there's something going on in the
    middle, and an output is generated at the other end. The process entails an inner,
    deep understanding of the code they are dealing with, but such information is
    not available to developers. Besides, this information is dismissed after the
    translated output is produced.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器表现为黑盒或源代码中的函数，其中要编译的代码是参数，中间发生了一些事情，在另一端生成输出。这个过程需要深入理解他们所处理的代码，但这种信息对开发者来说并不可用。此外，在生成翻译后的输出后，这些信息就会被忽略。
- en: The mission of Roslyn is to open the black box and allow developers to not only
    know what's going on behind the scenes, but—ultimately—also have the capability
    to create their own tools and code checkers and extend the traditional possibilities
    created by old compilers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 的使命是打开黑盒，让开发者不仅能够了解幕后发生的事情，而且最终能够创建自己的工具和代码检查器，并扩展旧编译器创建的传统可能性。
- en: 'The official documentation for Roslyn ([https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)),
    explains the main changes of this approach by comparing the classical compiler
    pipeline with the set of services proposed by Roslyn:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 的官方文档（[https://github.com/dotnet/roslyn](https://github.com/dotnet/roslyn)）通过比较经典编译器管道与
    Roslyn 提出的服务集来解释这种方法的 主要变化：
- en: '![Differences from traditional compilers](img/image00571.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![与传统编译器的区别](img/image00571.jpeg)'
- en: As the figure shows, every part of the pipeline has been replaced with APIs
    that allow you to write code that can be parsed, create **Syntax Tree API**, and
    generate a whole symbol map out of it, performing the required **Binding and Flow
    Analysis APIs** in order to finally use the **Emit API** to generate the resulting
    binaries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，管道的每个部分都已用允许你编写可解析代码的 API 替换，创建 **语法树 API**，并从中生成整个符号图，执行所需的 **绑定和流分析 API**，最终使用
    **Emit API** 生成结果二进制文件。
- en: 'The way Roslyn handles these phases is by creating object models for each of
    them. A deep study on the capabilities and opportunities offered by this set of
    services and tools is beyond the scope of this book, but I would like to present
    an introductory view of these possibilities, along with some demo code so that
    it''s possible to start building you own utensils: projects that read code and
    help identify potential issues and how to fix them.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 处理这些阶段的方式是为每个阶段创建对象模型。深入研究这一套服务和工具提供的功能和机会超出了本书的范围，但我希望提供一个对这些可能性的简介，以及一些示例代码，以便你可以开始构建自己的工具：读取代码并帮助识别潜在问题和如何修复它们的项目。
- en: Getting started with Roslyn
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Roslyn
- en: 'There are some requirements that apply before you start using Roslyn from Visual
    Studio. The first one is to have the Git extension installed: you can find it—as
    with many others—in the **Extensions and Updates** tool in the **Tools** menu.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始从 Visual Studio 使用 Roslyn 之前，有一些要求需要满足。首先是安装 Git 扩展：你可以在 **工具** 菜单中的 **扩展和更新**
    工具中找到它，就像许多其他工具一样。
- en: 'After installation, create a new project in Visual Studio, select the C# Language,
    and under the **Extensibility** item, choose **Download the .NET Compiler Platform
    SDK**, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在 Visual Studio 中创建一个新的项目，选择 C# 语言，然后在 **扩展性** 项下选择 **下载 .NET 编译器平台 SDK**，如图所示：
- en: '![Getting started with Roslyn](img/image00572.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Roslyn](img/image00572.jpeg)'
- en: An `index.html` web page will appear, containing a button linked to downloads
    for syntax tree visualizers, templates for analyzers, and so on. Note that if
    you have more than one edition of Visual Studio installed, you will be notified
    by the `.vsix` installer about which products you want the extensions to be installed
    in.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现一个 `index.html` 网页，其中包含一个按钮，链接到语法树可视化工具的下载、分析器模板等。请注意，如果你安装了多个版本的 Visual
    Studio，`.vsix` 安装程序将通知你希望扩展安装到哪些产品中。
- en: 'Several options appear as available in different contexts now. On the one hand,
    if you go to the **Tools/Options** menu and check the **Text Editors** item, you
    can find new options to control the way this language is managed within Visual
    Studio Editors on the C# side: options to format code for Intellisense, and so
    on.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在根据不同的上下文出现了几个可用的选项。一方面，如果你转到 **工具/选项** 菜单并检查 **文本编辑器** 项，你可以在 C# 方面找到控制 Visual
    Studio 编辑器中此语言管理方式的新选项：用于 Intellisense 的代码格式化选项等。
- en: 'On the other hand, after reloading Visual Studio, if you go back to Extension
    and Updates, you will find that new types of projects are available now, including
    **Stand-Alone Code Analysis Tool**, **Analyzer With Code Fix (NuGet + VSIX)**,
    **Code Refactoring (VSIX)**, and **VSIX Project**, this last one being specific
    to installations of plugins and the like. You should get an offer like the one
    shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在重新加载Visual Studio后，如果你回到扩展和更新，你会发现在现在有新的项目类型可供选择，包括**独立代码分析工具**、**带代码修复的分析器（NuGet
    + VSIX）**、**代码重构（VSIX）**和**VSIX项目**，最后一个专门用于插件等安装。你应该会收到如下截图所示的报价：
- en: '![Getting started with Roslyn](img/image00573.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Roslyn入门](img/image00573.jpeg)'
- en: Let's start with a simple class and see what we can do with the options. So,
    I create a new project (a Console one is just fine) and get rid of the using declarations
    included by default.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的类开始，看看我们可以使用哪些选项。因此，我创建了一个新的项目（控制台项目就很好）并去掉了默认包含的using声明。
- en: Even with the default initial code we have, Roslyn will read and convert it
    into a Syntax Tree representation, where everything (every word, whitespace, curly
    brace, and so on) has a place in the tree and can be managed accordingly. This
    tree can be examined using the new window available in **View** | **Other Windows**
    | **Syntax Visualizer** installed by the previous process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有默认的初始代码，Roslyn也会读取并将其转换为语法树表示，其中树中的每一部分（每个单词、空白、花括号等）都有一个位置，并且可以相应地管理。这个树可以使用之前过程安装的**视图**
    | **其他窗口** | **语法可视化器**中的新窗口进行检查。
- en: 'As soon as we click on the source code (that is, in the middle of the `class`
    word), the window will show the result of the code analysis (we show the legend
    as well):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击源代码（即在`class`单词的中间），窗口将显示代码分析的结果（我们也会显示图例）：
- en: '![Getting started with Roslyn](img/image00574.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Roslyn入门](img/image00574.jpeg)'
- en: You'll notice that the tree starts with something called **CompilationUnit**,
    with the main **NamespaceDeclaration** node hanging from it. Therefore, every
    single element in the source code is now recognizable and manageable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，树从所谓的**CompilationUnit**开始，主要的**NamespaceDeclaration**节点悬挂在其上。因此，源代码中的每个元素现在都是可识别和可管理的。
- en: If we want to see this tree in a more visual manner, we can right-click on the
    **CompilationUnit** contextual menu and select the **View Directed Syntax Graph**
    option, which will show a `.dgml` file in the editor with a colored tree in which
    every color in the legend represents one element in the code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以更直观的方式查看此树，可以在**CompilationUnit**的上下文菜单中右键单击并选择**查看有向语法图**选项，这将显示编辑器中的`.dgml`文件，其中包含一个着色的树，图例中的每个颜色都代表代码中的一个元素。
- en: 'When passing the mouse over one element, its properties are shown in a tooltip
    (also, right-clicking on a single node shows a contextual menu of possible options):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在某个元素上时，其属性会在工具提示中显示（同样，右键单击单个节点会显示可能的选项的上下文菜单）：
- en: '![Getting started with Roslyn](img/image00575.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Roslyn入门](img/image00575.jpeg)'
- en: The blue nodes characterize the high-level nodes of the C# grammar that can
    be divided into smaller units. The green ones are called *syntax tokens* and are,
    somehow, like the atoms or basic units of the syntax tree (they cannot be divided
    into anything smaller).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色节点表示C#语法的较高层节点，可以进一步划分为更小的单元。绿色节点被称为*语法标记*，在某种程度上，就像语法树的原子或基本单元（它们不能被进一步分割）。
- en: The rest of the nodes (white and gray nodes) are the so-called *trivia* nodes,
    and they're not relevant to compilation as they are the parts of the source text
    considered *largely insignificant for normal understanding of the code, such as
    whitespace, comments, and preprocessor directives*, according to the official
    documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的节点（白色和灰色节点）被称为所谓的*琐事*节点，根据官方文档，它们与编译无关，因为它们是源文本中被认为是*对代码的正常理解基本无关紧要的部分，例如空白、注释和预处理器指令*。
- en: Besides, there is another very useful online tool (open source) called Source
    Visualizer, which is available at [http://source.roslyn.io/](http://source.roslyn.io/)
    and shows how Roslyn is coded, along with its source code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个非常有用的在线工具（开源），名为Source Visualizer，可在[http://source.roslyn.io/](http://source.roslyn.io/)找到，它展示了Roslyn是如何编码的，以及其源代码。
- en: You're allowed to navigate through the whole tree of elements found in the Roslyn
    project and check them out, reviewing how they are coded to serve as an inspiration
    for your own code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导航到 Roslyn 项目中找到的所有元素的全树，并检查它们，了解它们的编码方式，以作为你自己的代码的灵感来源。
- en: 'For example, if we click on the left tree in the search for the CSharp compiler,
    we can see how it is coded and all the details linked to it, as the following
    screenshot shows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们点击搜索 CSharp 编译器的左侧树，我们可以看到它的编码方式以及与之相关的所有细节，如下面的截图所示：
- en: '![Getting started with Roslyn](img/image00576.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用 Roslyn](img/image00576.jpeg)'
- en: A first look at Microsoft Code Analysis Services
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初探微软代码分析服务
- en: Along the course of this book, and probably long before, you may have noticed
    the large amount of options available within the source code editors in order
    to facilitate usual operations, notify errors before compilations, and suggest
    changes among other things (remember, for example, when talking about the implementation
    of the `IDispose` interface, how the IDE suggested several possible implementations
    for us).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，也许在很久以前，你可能已经注意到了源代码编辑器中提供的大量选项，以便于执行常规操作，在编译前通知错误，以及提出更改等（记住，例如，当谈到
    `IDispose` 接口的实现时，IDE 如何为我们建议几种可能的实现方式）。
- en: From Visual Studio 2015 onwards, these features are just some of the many tools
    powered by Roslyn. One of the most popular among them is the set of services linked
    to Code Analyzers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio 2015 开始，这些功能只是由 Roslyn 驱动的众多工具中的一部分。其中最受欢迎的是与代码分析器相关的一组服务。
- en: Code Analyzers
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码分析器
- en: They're not anything new since they have been at our disposal for years within
    Visual Studio. However, as part of the work with Roslyn, these features—and many
    others—were rewritten in order to permit the use of extra functionalities.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们并不新颖，因为它们已经在 Visual Studio 中可用多年。然而，作为与 Roslyn 一起工作的部分，这些功能——以及许多其他功能——被重新编写，以便允许使用额外的功能。
- en: 'They are usually divided into three main categories: Code Analyzers, Code Visualizers,
    and Code Refactors. The three can work together to perform more complex tasks
    and help the developer in a variety or ways: programmers often need to work with
    some code they didn''t write, or they simply want to know something about the
    quality of someone else''s code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常分为三大类：代码分析器、代码可视化器和代码重构器。这三者可以协同工作以执行更复杂的任务，并以多种方式帮助开发者：程序员经常需要处理他们没有编写的代码，或者他们只是想了解别人代码的质量（例如，当谈到
    `IDispose` 接口的实现时，IDE 如何为我们建议几种可能的实现方式）。
- en: The first category (Code Analyzers) takes care of the generated tree that we
    saw in the basic demo earlier. These analyzers split the code into pieces, use
    some type of taxonomy to identify every unit, and place the resulting set in a
    fashion that can be managed later on by other tools.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一类（代码分析器）负责处理我们在基本演示中看到的生成树。这些分析器将代码拆分成片段，使用某种分类法来识别每个单元，并将结果集以可以由其他工具稍后管理的形式放置。
- en: Code Visualizers are responsible for presenting code in a readable manner. They
    can also provide us with tips about quality and mistakes.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可视化器负责以可读的方式呈现代码。它们还可以提供有关质量和错误的信息。
- en: Code Refactors are small fragments of code that—when applied to a previously
    recognized block—are able to suggest changes and even apply those changes, directly
    substituting the original code.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构器是代码的小片段，当应用于先前识别的块时，能够提出更改，甚至直接应用这些更改，替换原始代码。
- en: 'An entire open source sample for you to check: ScriptCS'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为您提供的一个完整的开源示例：ScriptCS
- en: There's an open source project that can give you an idea about some of these
    possibilities. It's called ScriptCS. Remember, we mentioned that with Roslyn,
    you can build a tool similar to the REPL (read-evaluate-print-loop) available
    for Node.js, Ruby, and Python, for example. I mean a tool that can examine and
    execute C# code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个开源项目可以让你了解一些这些可能性。它被称为 ScriptCS。记住，我们提到过，使用 Roslyn，你可以构建一个类似于 Node.js、Ruby
    和 Python 等可用的 REPL（读取-评估-打印循环）的工具。我的意思是，一个可以检查和执行 C# 代码的工具。
- en: To test it, just go to the ScriptCS website ([http://scriptcs.net/](http://scriptcs.net/))
    and download the project. It's a Visual Studio solution made up of several projects
    that shed some light about the possibilities this technology offers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，只需访问 ScriptCS 网站 ([http://scriptcs.net/](http://scriptcs.net/)) 并下载项目。这是一个由几个项目组成的
    Visual Studio 解决方案，可以让我们了解这项技术提供的可能性。
- en: Once compiled, if you launch the program, you'll see a console application,
    which suggests that you write some code to analyze and execute. The tool will
    use the compiler, and it works in a manner very similar to the Console tool in
    browsers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，如果你运行程序，你会看到一个控制台应用程序，这表明你需要编写一些代码来分析和执行。该工具将使用编译器，并且它的操作方式与浏览器中的控制台工具非常相似。
- en: 'The aspect will be like what is shown in the following screenshot. Note that
    I write three separate sentences, and only after writing the one that produces
    an output, we get the results in the console:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方面将类似于以下截图所示。请注意，我写了三个独立的句子，并且只有在写出了产生输出的那个句子之后，我们才会在控制台看到结果：
- en: '![An entire open source sample for you to check: ScriptCS](img/image00577.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![一个完整的开源示例供你检查：ScriptCS](img/image00577.jpeg)'
- en: Of course, Roslyn services are creating a class behind the scenes for us and
    are inserting that code within, later calling the compiler, executing the code,
    and redirecting the output to the Console window, where we see the results.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Roslyn服务在幕后为我们创建一个类，并将该代码插入其中，稍后调用编译器，执行代码，并将输出重定向到控制台窗口，在那里我们看到结果。
- en: It becomes useful when we just want to check out a simple piece of code without
    building a whole project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只想检查一小段代码而不构建整个项目时，它变得很有用。
- en: A basic project using Microsoft.CodeAnalysis
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Microsoft.CodeAnalysis的基本项目
- en: Let's start working with these tools, creating a simple Console application
    and installing Microsoft.CodeAnalysis tools directly from NuGet Package Manager
    Console.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些工具，创建一个简单的控制台应用程序，并直接从NuGet包管理器控制台安装Microsoft.CodeAnalysis工具。
- en: We can type `Install-Package Microsoft.CodeAnalysis`, and we'll see the installation
    process in which all the required dependencies are downloaded, with the last message
    shown saying something like `Successfully installed 'Microsoft.CodeAnalysis 1.3.2'
    to [TheNameOfYourProject]`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输入`Install-Package Microsoft.CodeAnalysis`，我们将看到安装过程，其中所有必需的依赖项都会被下载，最后一条消息显示类似于`Successfully
    installed 'Microsoft.CodeAnalysis 1.3.2' to [TheNameOfYourProject]`的信息。
- en: 'In the main method, we are going to load a C# file in order to analyze its
    contents. With this purpose, we have created a `Person.cs` file with the following
    contents:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，我们将加载一个C#文件以分析其内容。为此，我们创建了一个`Person.cs`文件，其内容如下：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Later on, we''re defining a new entry point, `InitialParser.cs`, which is going
    to take care of the analysis. We''ll establish this class as the entry point of
    the application, and in its main method, we start by reading the file to be checked,
    using the same class as earlier (CSharpSyntaxTree)—only, this time, we load the
    file contents early in order to pass them to the `ParseText` static method of
    the class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将定义一个新的入口点`InitialParser.cs`，它将负责分析。我们将把这个类作为应用程序的入口点，并在其主方法中，我们首先使用与之前相同的类（CSharpSyntaxTree）读取要检查的文件，只是这次我们提前加载文件内容，以便将它们传递给类的`ParseText`静态方法：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Observe that `ParseText` returns a `SyntaxTree` object. This is fundamental
    for analysis since it allows you to iterate over the whole tree in order to inspect
    how the Tree Object Model was implemented when it was applied to our `Person`
    class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`ParseText`返回一个`SyntaxTree`对象。这对于分析是基本的，因为它允许你遍历整个树，以检查当它应用于我们的`Person`类时，树对象模型是如何实现的。
- en: If you want to have a clear view of why certain objects are selected to recover
    the code's properties, remember that the Syntax Tree Viewer that we discussed
    earlier achieves many of the actions that we are going to perform here, and it
    offers the corresponding name of the element as we move from one point in the
    code to another.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要清楚地了解为什么某些对象被选中以恢复代码的特性，请记住我们之前讨论过的语法树查看器可以实现我们将要执行的大多数操作，并且当我们从代码的一个点移动到另一个点时，它会提供相应元素的名称。
- en: 'For instance, if you click on the code right inside the `class` keyword, the
    Syntax Tree Visualizer will move exactly to that point in the tree, indicating
    the name associated with the Object Model, as the next screenshot shows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你点击`class`关键字内部的代码，语法树可视化器将正好移动到树中的那个点，指示与对象模型关联的名称，如下一张截图所示：
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00578.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用Microsoft.CodeAnalysis的基本项目](img/image00578.jpeg)'
- en: Now, we have a very nice tool to suggest which classes and classes' members
    we should identify in the API in order to obtain references to the elements that
    compose the Syntax Tree.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个非常好的工具，可以建议我们应该在API中识别哪些类及其成员，以便获得组成语法树的元素的引用。
- en: If we want to obtain the name of the first class defined in the code (there's
    only one, but the syntax tree will show as many as there were), first, we need
    to access the root of the tree. We do that by calling `GetRoot()` in the tree
    object previously obtained.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取代码中定义的第一个类的名称（只有一个，但语法树会显示与之前相同数量的），首先，我们需要访问树的根节点。我们通过在之前获取的树对象中调用`GetRoot()`来实现这一点。
- en: 'Once we have the root element, a look at the methods used throws some light
    on the possibilities we have. Here are some of these methods, just to name a few:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了根元素，查看使用的方法可以让我们了解我们拥有的可能性。以下是一些这些方法，仅举几个例子：
- en: We can go down or up, looking for descendants in search of ancestors since we
    have access to the whole list of nodes
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以向上或向下查找，寻找后代以寻找祖先，因为我们有权访问整个节点列表
- en: We can find a given node or check the contents of any node in search for something
    special
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以找到一个特定的节点或检查任何节点的内容以寻找特殊的东西
- en: We can read a node's text
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以读取一个节点的文本
- en: 'We can even insert or remove any of them (refer to the following screenshot):'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们甚至可以插入或删除它们中的任何一个（参见图表）：
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00579.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![使用Microsoft.CodeAnalysis的基本项目](img/image00579.jpeg)'
- en: 'Given that all collections provided by the APIs are generic collections, we
    can ask for nodes of a concrete type using the `OfType<element>` syntax. That''s
    what we do next in order to get the `ClassDeclarationSyntax` object of our `Person`
    class, so we print it to the console as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API提供的所有集合都是泛型集合，我们可以使用`OfType<element>`语法请求具体类型的节点。这就是我们接下来要做的事情，以便获取`Person`类的`ClassDeclarationSyntax`对象，所以我们按照以下方式将其打印到控制台：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can go on and obtain the method''s names in the class using the objects
    already declared. So, in this case, we''ll ask for all the `MethodDeclarationSyntax`
    objects available after the `DescendantNodes()` call and go through them, printing
    their names:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续并获取类中方法的名称，使用已经声明的对象。因此，在这种情况下，我们将请求`DescendantNodes()`调用之后可用的所有`MethodDeclarationSyntax`对象，并遍历它们，打印它们的名称：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, we can go for the properties, knowing that the syntax tree categorizes
    them as `PropertyDeclarationSyntax` objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以查看属性，知道语法树将它们分类为`PropertyDeclarationSyntax`对象：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The previous code generates the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码生成了以下输出：
- en: '![A basic project using Microsoft.CodeAnalysis](img/image00580.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![使用Microsoft.CodeAnalysis的基本项目](img/image00580.jpeg)'
- en: This is one of the recommended procedures to iterate over the syntax tree and
    recover information about its members, although in this case, we're just reading
    data and presenting the results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种推荐的方法来遍历语法树并恢复有关其成员的信息，尽管在这种情况下，我们只是读取数据并展示结果。
- en: The first approach to code refactoring
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构的第一种方法
- en: Based on the previous ideas and APIs, let's look at how to program those diagnosing
    and refactoring features that Visual Studio offers. That's the main reason for
    Extensibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的想法和API，让我们看看如何编程Visual Studio提供的诊断和重构功能。这就是扩展性的主要原因。
- en: 'Just remember something about the building and parsing behavior of Visual Studio.
    Many of these features are disabled by default. The whole set of analysis'' capabilities
    is found—for any project—in the `Project/Properties/Code Analysis` tab and is
    presented with two main options:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住一些关于Visual Studio构建和解析行为的事情。许多这些功能默认都是禁用的。分析功能的整个集合可以在任何项目的`项目/属性/代码分析`选项卡中找到，并提供了两个主要选项：
- en: Enable **Code Analysis** on **Build**, which, internally, defines the `CODE_ANALYSIS`
    constant and forces the active set of features to be run against the current code
    before each compilation. Also, note that you can configure the behavior, changing
    the severity of any issue to be `Warning`, `Error`, `Info`, `Hidden`, or `None`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建**上启用**代码分析**，这内部定义了`CODE_ANALYSIS`常量，并强制在每次编译之前运行当前代码的激活功能集。此外，请注意，您可以配置行为，将任何问题的严重性更改为`Warning`、`Error`、`Info`、`Hidden`或`None`。
- en: Select one the available rule sets, which the IDE offers. By default, **Microsoft
    Managed Recommended Rules** is active, but there are many others to choose and
    you can even activate/deactivate every single rule in those sets. The following
    screenshot shows these options:![The first approach to code refactoring](img/image00581.jpeg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择IDE提供的可用规则集之一。默认情况下，**Microsoft Managed Recommended Rules**是激活的，但还有许多其他选项可供选择，您甚至可以激活/停用这些集合中的每个规则。以下截图显示了这些选项：![代码重构的第一种方法](img/image00581.jpeg)
- en: That said, we're going to create one of these projects that appeared after the
    installation of the SDK that we did earlier.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们将创建一个在安装我们之前所做的 SDK 之后出现的项目之一。
- en: What we'll do is select the type of project named Analyzer with code Fix (VSIX)
    and look at how it is programmed and what the principal units of code are. Then,
    we'll cover debugging since it works in a peculiar way with respect to any other
    debugging scenario.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择名为 Analyzer with code Fix (VSIX) 的项目类型，并查看其编程方式和主要代码单元。然后，我们将讨论调试，因为它与其他调试场景相比具有特殊的工作方式。
- en: 'After creating the new project, you''ll notice the presence of three individual
    projects in the solution: the analyzer itself, another one for testing purposes,
    and finally, the one with the `.vsix` extension, which serves as the deploying
    mechanism.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目后，你将注意到解决方案中存在三个独立的项目：分析器本身、用于测试目的的另一个项目，以及最终带有 `.vsix` 扩展名的项目，它作为部署机制。
- en: 'Let''s focus on the first one. To honor its name, there are two classes implied:
    one for analysis (`DiganosticAnalyzer.cs`) and another in charge of code fixing
    (`CodeFixProvider.cs`). It''s important to recognize these roles and keep the
    code like this, even when we want to extend the default functionality.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于第一个。为了符合其名称，隐含了两个类：一个用于分析（`DiganosticAnalyzer.cs`）和一个负责代码修复（`CodeFixProvider.cs`）。识别这些角色并保持代码如此，即使我们想要扩展默认功能也很重要。
- en: 'It doesn''t matter that the project''s purpose is a bit simple: it searches
    for a class definition that contains a lowercase letter and marks it as a target
    for `CodeFixProvider` to advise about this situation.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 项目目的的简单性并不重要：它搜索包含小写字母的类定义，并将其标记为 `CodeFixProvider` 的建议目标。
- en: 'To perform this first task of finding the code, the `Analyzer2Analyzer` class,
    which inherits from `DiagnosticAnalyzer` performs the following actions (we explain
    them one by one since it''s not obvious at first):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个找到代码的第一个任务，从 `DiagnosticAnalyzer` 继承的 `Analyzer2Analyzer` 类执行以下操作（我们逐个解释，因为一开始并不明显）：
- en: First, the class is decorated with the `[DiagnosticAnalyzer]` attribute, indicating
    that the language to be used will be CSharp.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，该类被 `[DiagnosticAnalyzer]` 属性装饰，表示将要使用的语言将是 CSharp。
- en: Then, at the class level, it declares some strings of type `LocalizableString`.
    The reason is that this could work in different versions of Visual Studio with
    different locales. This is why the arguments these strings are assigned to are
    read from a resource file (created for this purpose). Take a look at the `Resources.resx`
    file's contents to check how the strings are saved.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类级别上，它声明了一些 `LocalizableString` 类型的字符串。原因是这可以在不同版本的 Visual Studio 和不同区域设置中工作。这就是为什么这些字符串分配的参数是从资源文件（为此创建的）中读取的原因。查看
    `Resources.resx` 文件的內容以检查字符串是如何保存的。
- en: It creates a `DiagnosticDescriptor` instance (the rule to be checked), which
    will be in charge of creating a `Description` instance of a given diagnostic.
    It takes a few arguments to describe the issue to look for, and one of them is
    Severity, which, by default, is just a warning.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个 `DiagnosticDescriptor` 实例（要检查的规则），它将负责创建给定诊断的 `Description` 实例。它需要一些参数来描述要查找的问题，其中之一是严重性，默认情况下只是一个警告。
- en: It overrides the read-only `SupportedDiagnostics` property to return a new instance
    of an `InmutableArray` array based on the previous rule.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它重写了只读的 `SupportedDiagnostics` 属性，以返回一个基于先前规则的 `InmutableArray` 数组的新实例。
- en: It overrides the `Initialize` method, which receives a context object of type
    `SymbolAnalysisContext`, which is in charge of registering the corresponding action
    we want to perform on the code.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它重写了 `Initialize` 方法，该方法接收一个类型为 `SymbolAnalysisContext` 的上下文对象，该对象负责注册我们想要在代码上执行的相关操作。
- en: 'In this demo, it calls the `RegisterSymbolAction` method to register two things:
    the method to be used in the analysis and the category to which such analysis
    belongs. (Actually, it passes `AnalyzeSymbol` as the name of the method).'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个演示中，它调用 `RegisterSymbolAction` 方法来注册两件事：用于分析的方法和此类分析所属的类别。（实际上，它传递了 `AnalyzeSymbol`
    作为方法的名称）。
- en: Also, note that the `RegisterSymbolAction` method will be called as many times
    as required in order to iterate on all instances of symbols that might meet the
    condition to be tested.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，请注意，`RegisterSymbolAction` 方法将根据需要多次调用，以便迭代所有可能满足测试条件的符号实例。
- en: Finally, it declares the `AnalyzeSymbol` method that receives the context, looks
    at the symbol to be checked, and if it meets the diagnosis (in this demo, if it
    has any lowercase letter in its name), it creates a `Diagnostic` object and indicates
    the context to call `ReportDiagnostic`, which activates whatever action is programmed
    for this case.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它声明了 `AnalyzeSymbol` 方法，该方法接收上下文，查看要检查的符号，如果它符合诊断条件（在这个演示中，如果它的名字中包含任何小写字母），它创建一个
    `Diagnostic` 对象，并指示调用 `ReportDiagnostic` 的上下文，这将激活为这种情况编程的动作。
- en: 'As we can see, although there are not many lines, it''s not a simple code.
    That''s why we need to understand how the internals of Roslyn work in order to
    follow the right actions involved in the context to check for a certain issue.
    The complete code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，尽管代码行不多，但这不是简单的代码。这就是为什么我们需要了解 Roslyn 的内部工作原理，以便跟踪在上下文中检查特定问题的正确动作。完整的代码如下：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Although the counterpart (CodeFixer) has some more lines of code, you will be
    able to read the rest of the code—and understand how it operates—by taking a look
    at `Analyzer2CodeFixProvider` included in the `CodeFixProvider.cs` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对应的（CodeFixer）有一些更多的代码行，但您可以通过查看包含在 `CodeFixProvider.cs` 文件中的 `Analyzer2CodeFixProvider`
    来阅读其余的代码——并理解它是如何运行的。
- en: The two important methods here are the override to `RegisterCodeFixesAsync`,
    which receives `CodeFixContext` (required to launch the `fixing` action) and the
    `fixing` action represented in the demo by the `MakeUppercaseAsync` method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的方法：重写 `RegisterCodeFixesAsync` 方法，该方法接收 `CodeFixContext`（用于启动修复动作），以及由演示中的
    `MakeUppercaseAsync` 方法表示的修复动作。
- en: When this method is called, it returns a `Task<Solution>` object and receives
    all the required information to perform the task, plus a `CancellationToken` object
    to allow the user to ignore the fix suggestion offered in the contextual dialog
    box. Of course, it's responsible for changing the code if the user accepts the
    modification.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此方法时，它返回一个 `Task<Solution>` 对象，并接收执行任务所需的所有信息，以及一个 `CancellationToken` 对象，允许用户忽略在上下文对话框中提供的修复建议。当然，如果用户接受修改，它负责更改代码。
- en: Debugging and testing the demo
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试和测试演示
- en: To test these demos, a new instance of Visual Studio is launched, which will
    have the Analyzer registered and active when loaded. For this case, I launched
    the project, and in the new instance of the IDE, I opened the previous project
    to understand how it recognizes names of identifiers with lowercase letters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这些演示，将启动一个新的 Visual Studio 实例，该实例在加载时将注册并激活分析器。在这种情况下，我启动了项目，并在新的 IDE 实例中打开了之前的项目，以了解它是如何识别小写字母的标识符名称的。
- en: So, proceed in this manner, and open our previous `Person.cs` file (or any other
    similar file for that matter) to check this diagnosis in action. You will see
    a red squiggling underline on the declaration of the `Person` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照这种方式进行，并打开我们之前的 `Person.cs` 文件（或任何其他类似文件），以查看此诊断的实际效果。您将在 `Person` 类的声明上看到一条红色的波浪下划线。
- en: 'When you place your cursor underneath the word `Person`, a tooltip will show
    up, advising you of a potential problem (in this case, there''s no problem at
    all):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将光标放在单词 `Person` 下方时，将显示一个工具提示，提醒您潜在的问题（在这种情况下，根本没有任何问题）：
- en: '![Debugging and testing the demo](img/image00582.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![调试和测试演示](img/image00582.jpeg)'
- en: 'Up until this point, we were dealing with the first class analyzed (the `Analyzer2Analyzer`
    class). But now, we''re offered a double option: the yellow bulb, with a contextual
    menu and the **Show potential fixes** link. Both take to the same window, showing
    the potential fixes in all places where this fix could be applied.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理第一个分析过的类（`Analyzer2Analyzer` 类）。但现在，我们有两个选择：黄色的灯泡，带有上下文菜单和**显示潜在修复**链接。两者都导向同一个窗口，显示所有可以应用此修复的地方的潜在修复。
- en: 'Also, note how these fixes are marked with color. In this case, the color is
    green, indicating that fixes will not provoke another diagnosis issue, but if
    it does, we will be notified accordingly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意这些修复是如何用颜色标记的。在这种情况下，颜色是绿色，表示修复不会引发另一个诊断问题，但如果确实发生了，我们将相应地得到通知：
- en: '![Debugging and testing the demo](img/image00583.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![调试和测试演示](img/image00583.jpeg)'
- en: 'We also have the option of **Preview changes**, which, in turn, presents another
    (scrollable) window in order to examine in detail what would happen to our code
    if we accept the suggestion (shown in the following screenshot):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有**预览更改**的选项，这反过来又提供了一个（可滚动的）窗口，以便详细检查如果我们接受建议会发生什么（如下面的截图所示）：
- en: '![Debugging and testing the demo](img/image00584.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![调试和测试演示](img/image00584.jpeg)'
- en: 'To deploy the project, you can follow two different approaches: use the `NuGet`
    package generated (you will see it in the `Bin/Debug` folder after compilation
    as usual) or use the `.vsix` binaries generated by the compiler, which are also
    available in the same subdirectory, only in the Vsix project this time.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署项目，你可以遵循两种不同的方法：使用生成的 `NuGet` 包（在编译后，你可以在 `Bin/Debug` 文件夹中找到它，就像通常一样）或使用编译器生成的
    `.vsix` 二进制文件，这些文件也位于相同的子目录中，但这次是在 Vsix 项目中。
- en: 'In the first case, you should follow the indications in the `Readme.txt` file
    (what follows is a citation of the previously mentioned file):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你应该遵循 `Readme.txt` 文件中的指示（以下是对之前提到的文件的引用）：
- en: 'To try out the NuGet package:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 NuGet 包：
- en: 'Create a local NuGet feed by following the instructions here: [http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds](http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds).'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下说明创建本地 NuGet 源：[http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds](http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds)。
- en: Copy the `.nupkg` file into that folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `.nupkg` 文件复制到该文件夹中。
- en: Open the target project in Visual Studio 2015.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2015 中打开目标项目。
- en: Right-click on the project node in Solution Explorer and choose **Manage NuGet
    Packages**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目节点，然后选择 **管理 NuGet 包**。
- en: Select the NuGet feed you created on the left-hand side.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选择你创建的 NuGet 源。
- en: Choose your analyzer from the list and click on **Install**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中选择你的分析器，然后点击 **安装**。
- en: 'If you want to automatically deploy the `.nupkg` file to the local feed folder
    when you build this project, follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在构建此项目时自动部署 `.nupkg` 文件到本地源文件夹，请按照以下步骤操作：
- en: Right-click on this project in Solution Explorer and choose **Unload Project**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击此项目并选择 **卸载项目**。
- en: Right-click on this project and click on **Edit**.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击此项目并点击 **编辑**。
- en: Scroll down to the **AfterBuild** target.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 **AfterBuild** 目标。
- en: In the **Exec** task, change the value inside **Command** after the `–OutputDirectory`
    path to point to your local NuGet feed folder.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Exec** 任务中，将 `–OutputDirectory` 路径后面的 **Command** 中的值更改为指向你的本地 NuGet 源文件夹。
- en: The other choice is to launch the `.vsix` file (the extension will be recognized
    by the system). This will install the package in Visual Studio after asking for
    conformity, just like any other package that you might have previously installed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是启动 `.vsix` 文件（系统将识别扩展名）。在请求一致性后，这将像任何其他你可能之前安装的包一样，在 Visual Studio 中安装该包。
- en: 'Up to this point, we have introduced Roslyn and its capabilities. Now, we''re
    going to visit the other big open source project, which is getting more hype due
    to its importance in many web projects, including Angular, Ionic, and many others:
    TypeScript.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了 Roslyn 及其功能。现在，我们将参观另一个重要的开源项目，由于它在许多网络项目中的重要性，包括 Angular、Ionic
    以及许多其他项目，因此受到了更多的关注：TypeScript。
- en: TypeScript
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: We revert here to the study of TypeScript that we started in [Chapter 04](part0028.xhtml#aid-QMFO2
    "Chapter 4. Comparing Approaches for Programming") *Comparing Approaches to Programming*,
    and that served as an introduction to the language, the tools to use, its integration
    with Visual Studio and a basic coverage of its possibilities.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到我们在 [第四章](part0028.xhtml#aid-QMFO2 "第四章. 编程方法比较") *编程方法比较* 中开始研究的 TypeScript，它作为语言的介绍，使用的工具，与
    Visual Studio 的集成以及对其可能性的基本概述。
- en: In that chapter, I promised to review the characteristics of the language since
    it is the other big Microsoft project related to open source since its inception,
    and it's just gaining momentum and increasing adoption all over the world. TypeScript
    is, in the words of its own creator, *a JavaScript that scales*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一章中，我承诺要回顾语言的特点，因为它是从一开始就与开源相关的另一个大型微软项目，并且它正在全球范围内获得动力并增加采用率。TypeScript，正如其创造者所说，*是一种可扩展的
    JavaScript*。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: However, if you want to deep dive into the language and its possibilities, take
    a look at the excellent "Mastering TypeScript" by Nathan Rozentals, available
    at [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想深入了解语言及其可能性，请查看 Nathan Rozentals 的优秀作品 "Mastering TypeScript"，可在 [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript)
    获取。
- en: Let's remind ourselves that the project started around 2010 as a response to
    the growing popularity of JavaScript—not only in the browsers, but also on the
    servers. This means writing applications with not just hundreds of thousands,
    but sometimes millions of lines of code. The language itself lacks some features
    that we're accustomed to in large-scale application developments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己，该项目始于2010年左右，作为对JavaScript日益增长的流行度的回应——不仅是在浏览器中，也在服务器上。这意味着编写应用程序，不仅只有数十万行代码，有时甚至数百万行代码。这种语言本身缺乏我们在大规模应用程序开发中习惯的一些功能。
- en: As we mentioned earlier, until ECMAScript 2015, we didn't have classes or modules
    or any static type system. This static type system is exactly what empowers tools
    such as V. Studio, Eclipse, JetBrains, and others to enable those features that
    we're used to in the development cycle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，直到ECMAScript 2015，我们没有类或模块或任何静态类型系统。这个静态类型系统正是赋予V. Studio、Eclipse、JetBrains和其他工具能力，使我们能够在开发周期中习惯那些功能。
- en: Debugging TypeScript
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript调试
- en: Thanks to that static type system, TypeScript offers developers experiences
    parallel to those we would have using the C# language, and that includes debugging,
    as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了那个静态类型系统，TypeScript为开发者提供了与使用C#语言时相似的经验，这包括调试。
- en: As for debugging, TypeScript does not present any extra configuration or difficulties.
    Since it transpiles to plain JavaScript, all typical resources for JavaScript
    are usable here as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 至于调试，TypeScript没有额外的配置或困难。因为它编译成纯JavaScript，所以所有典型的JavaScript资源在这里都可以使用。
- en: This is especially useful when using the embedded debugger of Visual Studio
    because you can set breakpoints in the TypeScript code as well (not only in JavaScript)
    and debug, as always, watching values at runtime and inspecting elements involved
    in the process.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用Visual Studio的嵌入式调试器时特别有用，因为您可以在TypeScript代码中设置断点（而不仅仅是JavaScript）并调试，就像往常一样，监视运行时值并检查涉及的过程元素。
- en: For instance, in the previous code that we used in [Chapter 4](part0028.xhtml#aid-QMFO2
    "Chapter 4. Comparing Approaches for Programming"), *Comparing Approaches for
    Programming*, we can mark a breakpoint in the `sorted.map` call and watch the
    values of every element in the array, check the value of this, have access to
    the `Globals` definition, and—in general—witness all the goodness we would expect
    in a complete, extended, debugging session.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们在[第4章](part0028.xhtml#aid-QMFO2 "第4章。比较编程方法")中使用的代码中，*比较编程方法*，我们可以在`sorted.map`调用中设置断点，并监视数组中每个元素的值，检查这个值，访问`全局变量`定义，并且总的来说，见证我们在完整的、扩展的调试会话中期望的所有优点。
- en: Just remember that you have to use Internet Explorer (the default browser for
    Visual Studio).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，您必须使用Internet Explorer（Visual Studio的默认浏览器）。
- en: 'You can also use Edge as the default browser if you attach the Visual Studio
    debugger to the process in this manner using the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用Edge作为默认浏览器，如果使用以下步骤将Visual Studio调试器附加到该进程：
- en: Launch the execution and go to the **Visual Studio Debugger** menu.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动执行并转到**Visual Studio调试器**菜单。
- en: Enter the **Attach to Process** option, and in the dialog box, select the **Attach
    to** option to mark Script code.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**附加到进程**选项，在对话框中，选择**附加到**选项以标记脚本代码。
- en: Finally, in the list of processes, select the **MicrosoftEdgeCP.exe** process
    in the list and mark a breakpoint.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在进程列表中，选择列表中的**MicrosoftEdgeCP.exe**进程，并标记一个断点。
- en: When you reload the page, the execution will stop at the breakpoint.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您重新加载页面时，执行将在断点处停止。
- en: In addition, you can use Chrome to debug TypeScript code inside as well!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用Chrome来调试TypeScript代码！
- en: Debugging TypeScript with Chrome
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chrome调试TypeScript
- en: Just open the previous code using Chrome as the navigator of your choice. Then,
    press *F12*, and you will get access to the **Sources** tab. From there, select
    the `app.ts` file and mark any line with a breakpoint.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用您选择的浏览器Chrome打开之前的代码。然后，按*F12*，您将能够访问**源**标签页。从那里，选择`app.ts`文件，并标记任何一行以设置断点。
- en: 'When you reload the page, you will discover how the code stops in the TypeScript
    line you marked, and all variables and objects implied in the execution are perfectly
    available. The next screenshot illustrates this excellent feature:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重新加载页面时，您将发现代码如何停止在您标记的TypeScript行，并且所有在执行中隐含的变量和对象都完全可用。下一张截图说明了这个出色的功能：
- en: '![Debugging TypeScript with Chrome](img/image00585.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![使用Chrome调试TypeScript](img/image00585.jpeg)'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that Firefox doesn't support the `insertAdjacentElement` method. You should
    use `appendChild` instead.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Firefox 不支持 `insertAdjacentElement` 方法。你应该使用 `appendChild` 代替。
- en: Interfaces and strong typing
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口和强类型
- en: Let's think of a more complex object similar to a C# object, containing a field,
    methods with more than one signature (overloaded), and so on.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更复杂的对象，类似于 C# 对象，包含字段、具有多个签名的（重载）方法等。
- en: 'For example, we can declare a `Calculator` interface with the following definition:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下定义声明一个 `Calculator` 接口：
- en: '[PRE7]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The notion of state is provided with an optional increment field (the same syntax
    as in C#), and four methods are defined. The first two are standard declarations,
    but the other two deserve a review.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的概念通过可选的增量字段（与 C# 中的语法相同）提供，并定义了四个方法。前两个是标准声明，但其他两个值得审查。
- en: 'The `add` method is overloaded. We have two definitions: one that gets a number
    and another with no arguments (both return void). When using an object that implements
    the `Calculator` interface, we''ll discover that the editor recognizes overloading
    just as we would expect from a similar object programmed in C# (refer to the next
    figure):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 方法被重载。我们有两个定义：一个接受一个数字，另一个没有参数（两者都返回 void）。当使用实现 `Calculator` 接口的对象时，我们会发现编辑器识别重载的方式正如我们期望从用
    C# 编程的类似对象中看到的那样（参考下一图）：'
- en: '![Interfaces and strong typing](img/image00586.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![接口和强类型](img/image00586.jpeg)'
- en: Finally, the `new` method is the way we define a constructor inside an interface.
    This constructor receives a string but returns `Element`. `Element` is, in turn,
    defined as an interface that represents an object in a document ([https://developer.mozilla.org/en-US/docs/Web/API/Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)).
    It's something that belongs to the DOM (Document Object Model); so, with TypeScript,
    we can manage almost any DOM component, just like we could in plain old JavaScript.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`new` 方法是在接口内部定义构造函数的方式。这个构造函数接收一个字符串，但返回 `Element`。`Element` 是一个接口，表示文档中的对象（[https://developer.mozilla.org/en-US/docs/Web/API/Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)）。这是属于
    DOM（文档对象模型）的东西；因此，使用 TypeScript，我们可以管理几乎任何 DOM 组件，就像我们可以在纯 JavaScript 中做的那样。
- en: Implementing namespaces
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现命名空间
- en: Most evolved languages allow the concept of namespace. A namespace permits the
    developer to create areas of code that are totally separated from each other,
    avoiding the collision of member's names and functionalities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发展中的语言都允许命名空间的概念。命名空间允许开发者创建彼此完全分离的代码区域，避免成员名称和功能的冲突。
- en: TypeScript includes this concept using the `module` keyword. A module is a fragment
    of JavaScript whose members are private to the module. That is, they're not available
    outside the module unless we declare them in an explicit manner. This is something
    we do using the export keyword.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 使用 `module` 关键字包含这个概念。模块是 JavaScript 的一部分，其成员对模块是私有的。也就是说，除非我们以明确的方式声明它们，否则它们在模块外部不可用。这是通过使用
    `export` 关键字来实现的。
- en: 'So, a module is declared using a simple, intuitive syntax:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模块使用简单直观的语法声明：
- en: '[PRE8]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Later, the module''s exported members are accessible using the dot notation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，模块导出的成员可以通过点符号访问：
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Module declarations also admit several levels of indentation to clearly separate
    different areas of code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 模块声明也允许使用多个缩进来清楚地分隔不同的代码区域：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To simplify access to nested modules, we can also define an alias with the
    `import` keyword, which is especially useful when areas tend to grow:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化对嵌套模块的访问，我们还可以使用 `import` 关键字定义别名，这在区域倾向于增长时特别有用：
- en: '[PRE11]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Declarations, scope, and Intellisense
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明、作用域和 Intellisense
- en: We must not assume that objects created by the "context" (the browser or the
    user agent) are accessed in TypeScript by default. For example, the document object
    that a navigator creates to represent the DOM is not strictly part of the language.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能假设由“上下文”（浏览器或用户代理）创建的对象在 TypeScript 中默认可访问。例如，navigator 创建的表示 DOM 的文档对象不是严格的语言的一部分。
- en: However, it's very easy to make these members accessible simply by declaring
    them using the **declare** keyword. Also, for this case, the TypeScript compiler
    automatically supplies a declaration because by default, it includes a `'lib.d.ts'`
    file, which provides interface declarations for the built-in JavaScript library
    as well as the Document Object Model.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用 **declare** 关键字声明这些成员，可以非常容易地使它们变得可访问。此外，对于这种情况，TypeScript 编译器自动提供声明，因为默认情况下，它包含一个
    `'lib.d.ts'` 文件，该文件提供了内置 JavaScript 库以及文档对象模型（DOM）的接口声明。
- en: 'As the official documentation says, if you want additional help for other libraries,
    all you have to do is declare them, and the corresponding `.ts` library will be
    used. Imagine that we want to change the title of the document; according to the
    earlier code, we should write the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如官方文档所说，如果您需要其他库的帮助，您只需声明它们，相应的 `.ts` 库就会被使用。想象一下，如果我们想更改文档的标题；根据之前的代码，我们应该编写以下内容：
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we need support for jQuery, to mention a popular library, all we have to
    do is declare it in this way:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对 jQuery 提供支持，提及一个流行的库，我们只需以这种方式声明即可：
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From this point, any reference to the `$` symbol will offer the expected Intellisense
    in the editor provided that the description file for this library has been referenced.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个点开始，任何对 `$` 符号的引用都将提供编辑器中预期的 Intellisense，前提是已经引用了该库的描述文件。
- en: Scope and encapsulation
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域和封装
- en: Other important concepts in relation to the scope and visibility of members
    are the namespace and module declarations. A namespace allows the programmer to
    declare private members to a named module, making them invisible for the code
    not being included inside; so, they're similar to the concept of namespace that
    we've already seen and that is typical in .NET programming.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与成员的作用域和可见性相关的重要概念还包括命名空间和模块声明。命名空间允许程序员将私有成员声明给一个命名的模块，使其对未包含在内的代码不可见；因此，它们类似于我们已看到的命名空间概念，并且在
    .NET 编程中很典型。
- en: 'If we want to expose any member of a namespace, the exports keyword allows
    such definition so that we can have a partially exposed namespace with private
    members. For instance, take a look at the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想公开命名空间中的任何成员，`exports` 关键字允许这样的定义，这样我们就可以有一个部分公开的命名空间，其中包含私有成员。例如，看看以下代码：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we check this code inside Visual Studio, we'll see an advice from the compiler
    as we pass over the last sentence, indicating that property `insideStr` doesn't
    exist inside the `MyNS` module (which really means that from a namespace perspective,
    this member is not declared accessible or maybe it doesn't exist).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Visual Studio 中检查此代码，当我们翻过最后一句话时，编译器会给出建议，指出属性 `insideStr` 不存在于 `MyNS`
    模块中（这实际上意味着从命名空间的角度来看，此成员未声明为可访问，或者它可能不存在）。
- en: On the other hand, no advice is given in reference to the exposed greeter method,
    since the exports clause was used in its declaration (for other OOP languages,
    we would say that the greeter member is public).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，关于公开的问候方法没有给出建议，因为它的声明中使用了 `exports` 子句（对于其他面向对象的编程语言，我们会说问候成员是公开的）。
- en: '![Scope and encapsulation](img/image00587.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![作用域和封装](img/image00587.jpeg)'
- en: Classes and class inheritance
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和类继承
- en: As we've seen, classes are a key part of TypeScript, and their declaration syntax
    is almost identical to the C# declarations we all know.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，类是 TypeScript 的关键部分，它们的声明语法几乎与我们所有人都知道的 C# 声明相同。
- en: 'That is, we can declare private members, customized constructors, methods,
    access properties, and even static members so that they can be accessed using
    the name of the class instead of a variable instance. Take a look at this code
    written by Anders Hejlsberg in an online demo and published by Channel 9 ([https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript](https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript),
    in case you want to follow all the details and comments that this author provides):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以声明私有成员、自定义构造函数、方法、访问属性，甚至静态成员，以便可以使用类的名称而不是变量实例来访问它们。看看安德斯·海尔斯伯格（Anders
    Hejlsberg）在 Channel 9 上发布的一个在线演示中编写的代码，[https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript](https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript)，如果您想了解作者提供的所有详细信息和注释：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, there's a color declaration using the `private` keyword, a customized
    constructor, a read-only property (get `distanceP`), and a static declaration
    (`origin`) to establish the initial point of drawing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里使用`private`关键字声明了一个颜色，一个自定义的构造函数，一个只读属性（get `distanceP`），以及一个静态声明（`origin`）来建立绘图的初始点。
- en: Optionally, there is a variant of the { get; set; } construction of C# in the
    class' constructor, which allows you to simplify declarations and assign an initial
    value to the constructor's arguments.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的构造函数中，可以选择使用类似于C#的{ get; set; }构造，这允许您简化声明并为构造函数的参数赋一个初始值。
- en: 'With this syntax, we can write a simplified variation of the previous class,
    as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，我们可以写出之前类的简化版本，如下所示：
- en: '[PRE16]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, in order to properly implement OOP, we also need inheritance. Inheritance
    is achieved using the `extends` keyword in the declaration of a class. So, we
    can define a new, inherited version of the previous class as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了正确实现面向对象编程，我们还需要继承。继承是通过在类声明中使用`extends`关键字来实现的。因此，我们可以定义之前类的新的继承版本，如下所示：
- en: '[PRE17]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The previous code uses another specific keyword here, `super`, in order to refer
    to the parent class. There's much more to the language, and we recommend the detailed
    documentation found at GitHub ([https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md))
    for more details and code snippets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码在这里使用了一个特定的关键字`super`来引用父类。关于这个语言还有很多其他内容，我们建议您查看GitHub上找到的详细文档([https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md](https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md))以获取更多细节和代码片段。
- en: Functions
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'In the Greeter class discussed in the initial demo, the `start()` and `stop()`
    methods didn''t have any return value. You can express a return value for a function
    in exactly the same way as we do with parameters: appending a colon (`:`) at the
    end, thus allowing us to express the whole signature of any function. So, for
    the typical `add` function, we can write the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始演示中讨论的Greeter类中，`start()`和`stop()`方法没有返回值。您可以用与参数相同的方式为函数表达返回值：在末尾添加一个冒号（`:`），这样我们就可以表达任何函数的整个签名。因此，对于典型的`add`函数，我们可以写出以下内容：
- en: '[PRE18]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One the most common practices in the language is to use interfaces to declare
    user-defined object types. Once declared, the interface will be checked against
    any member proclaiming its implementation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语言中最常见的做法之一是使用接口来声明用户定义的对象类型。一旦声明，接口将检查任何声明其实例的成员：
- en: '[PRE19]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, `age` is declared with the same syntax as what we used with
    C# for optional values, except that no default value is required.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`age`的声明与我们在C#中用于可选值的语法相同，只是不需要默认值。
- en: 'Similarly, we can declare a type and assign it a value in the same sentence:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以在同一句话中声明一个类型并为其赋值：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we declare a function using the lambda expression as one of the argument''s
    syntaxes, the compiler infers that the type of the argument is a function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用lambda表达式作为参数语法之一来声明一个函数，编译器会推断出参数的类型是函数：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is how it is displayed in the IDE:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在IDE中的显示方式：
- en: '![Functions](img/image00588.jpeg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![函数](img/image00588.jpeg)'
- en: 'An interface may allow you also to declare method overloading. Take a look
    at this declaration and note the double definition for the `doSomething` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可能允许您声明方法重载。看看这个声明并注意`doSomething`方法的重复定义：
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A variant of the previous declaration allows us to declare overloading and
    include a data field for the `doSomething` member:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 之前声明的变体允许我们声明重载并包含`doSomething`成员的数据字段：
- en: '[PRE23]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Later, we can refer `Thing3` using the following syntax:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用以下语法来引用`Thing3`：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, you can see how the three different references to the overloaded forms
    of `doSomething` are considered valid by the compiler. We even have the possibility
    of declaring constructors and indexers (much like in C#):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到编译器如何认为对`doSomething`重载形式的三个不同引用是有效的。我们甚至有声明构造函数和索引器（类似于C#）的可能性：
- en: '[PRE25]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Another possibility is based on TypeScript''s ability of defining an interface
    to enforce the return type:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是基于TypeScript定义接口的能力来强制返回类型：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I want you to check the definition of any member, remember that right-clicking
    and selecting "**Go to Definition**" will open the corresponding `lib.d.ts` file
    and show the original definition of any member; for example, the `clientX` member
    of the `event` object will show the following information:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您检查任何成员的定义，记住右键单击并选择“**转到定义**”将打开相应的`lib.d.ts`文件并显示任何成员的原始定义；例如，`event`对象中的`clientX`成员将显示以下信息：
- en: '![Functions](img/image00589.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![函数](img/image00589.jpeg)'
- en: 'In the same way, we can import declarations from other libraries and use this
    technique to check those implementations: this includes jQuery, Bootstrap, and
    so on. The site Definitely Typed ([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped))
    holds hundreds of these definitions.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从其他库导入声明并使用这种技术来检查这些实现：这包括jQuery、Bootstrap等等。Definitely Typed网站([https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped))拥有数百个这样的定义。
- en: 'Moreover, there is still another way to declare overloaded functions: you can
    declare several signature methods and finish the block with a real function definition
    and implementation. This is done in order to avoid TypeScript from showing errors
    at compile time, although the final implementation in JavaScript will only consist
    of one function given that JavaScript doesn''t have types.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有另一种声明重载函数的方法：您可以声明几个签名方法，并在实际函数定义和实现后结束块。这样做是为了避免TypeScript在编译时显示错误，尽管JavaScript的最终实现将只包含一个函数，因为JavaScript没有类型。
- en: 'In this way, the previous definitions are taken as overloaded versions of the
    last definition, such as what is shown in the next piece of code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，前面的定义被视为最后一个定义的重载版本，如下所示：
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Arrays and interfaces
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和接口
- en: We can also use the concept of interface to declare conditions, types, and behaviors
    related to array elements.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用接口的概念来声明与数组元素相关的条件、类型和行为。
- en: 'Take a look at this code in which we enforce type and behavior for an array
    of mountains:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个代码，我们强制为数组中的山设置类型和行为：
- en: '[PRE28]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Mountain` interface makes sure that every element belonging to the `mountains`
    array actually implements the `Mountain` definition so that it can be compared
    later, which is something you can check if you include this code in an HTML script
    section. In the Console output, the "Denali" mountain is correctly sorted to be
    the highest by the `sort` method of the array.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mountain`接口确保`mountains`数组中的每个元素实际上都实现了`Mountain`定义，以便以后可以进行比较，如果您在HTML脚本部分中包含此代码，您可以检查这一点。在控制台输出中，"Denali"山被正确排序为最高的，这是通过数组的`sort`方法实现的。'
- en: More TypeScript in action
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多TypeScript应用
- en: 'So, let''s take a look at some more TypeScript in action, starting with some
    other simple code. After creating an empty solution in Visual Studio and adding
    a JavaScript file (a `.js` extension), here, I''m using a code pattern offered
    in several demos on the official site in order to illustrate some changes these
    tools can offer. So, I type the following (a short function to sort an array and
    return the results):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看更多TypeScript的实际应用，从一些其他简单的代码开始。在Visual Studio中创建一个空解决方案并添加一个JavaScript文件（`.js`扩展名）后，这里，我使用官方网站上提供的几个演示中的代码模式来展示这些工具可以提供的一些变化。因此，我输入以下内容（一个用于排序数组并返回结果的简短函数）：
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we pass the mouse over the `arg` argument, the editor is unable to tell
    anything about the type of argument (with only this code, it is impossible to
    know anything else). If we write `sortByName` a couple of lines after the function,
    the editor recognizes the name, but it can''t add any more information about it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将鼠标移到`arg`参数上时，编辑器无法告诉任何关于参数类型的信息（只有这段代码，我们无法知道其他任何信息）。如果我们函数几行后写`sortByName`，编辑器会识别名称，但它无法添加更多关于它的信息：
- en: '![More TypeScript in action](img/image00590.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![更多TypeScript应用](img/image00590.jpeg)'
- en: Now, let's add a new file of the same name and copy the contents of the previous
    file inside, only changing the extension to `.ts` (TypeScript). Even with exactly
    the same content, the editor's behavior changes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个具有相同名称的新文件，并将上一个文件的全部内容复制进去，只需将扩展名更改为`.ts`（TypeScript）。即使内容完全相同，编辑器的行为也会改变。
- en: First, when you now pass the cursor over the argument, it says that it's of
    type `any`. This happens when you pass over the s`ortByName` declaration outside
    the function as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当您将光标移到参数上时，它会说它是`any`类型。当您将光标移到函数外部的`s`ortByName`声明上时，也会发生这种情况。
- en: 'However, it can get even better. Since the function expects you to operate
    with an array of a type that has a `name` and `age` property, we can declare that
    object as an interface which includes both properties, such as a `Person` interface
    (or any other interface that complies with this requirement). Now, we can explicitly
    define that `arg` is an array of type `Person`, indicating it in the argument
    declaration after a colon, so we have the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它还可以变得更好。由于函数期望你操作一个具有`name`和`age`属性的数组类型，我们可以声明一个包含这两个属性的对象作为接口，例如一个`Person`接口（或任何符合此要求的其他接口）。现在，我们可以明确地定义`arg`是一个`Person`类型的数组，在冒号后的参数声明中指明，所以我们有如下所示：
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And here, the magic starts to happen. When I pass the cursor over the argument,
    it now indicates the type it should receive, but also, if I hover over the `arg.slice(0)`
    code fragment, it gives me a detailed explanation of what it expects to receive,
    and when I move my cursor down, I see that there's a red squiggle under the `localCompare`
    method call, signifying that such a method doesn't exist on type string (because
    it recognizes that name is of the type defined previously).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，魔法开始发生。当我将光标移到参数上时，它现在指示它应该接收的类型，而且，如果我将光标悬停在`arg.slice(0)`代码片段上，它会给我一个详细的解释，说明它期望接收的内容，当我将光标向下移动时，我看到在`localCompare`方法调用下有一个红色的波浪线，表示在字符串类型上不存在这样的方法（因为它认识到名称是之前定义的类型）。
- en: 'You can see both hints in the following (compound) screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下（复合）截图中看到这两个提示：
- en: '![More TypeScript in action](img/image00591.jpeg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![更多TypeScript示例](img/image00591.jpeg)'
- en: So, there's a bunch of extra information available just by making a few changes
    in the code in order to instruct TypeScript about the types we're dealing with.
    We see this if we try to rewrite the `name.local…` call in the search for help.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需对代码进行一些更改，就可以提供大量额外信息，以指导TypeScript关于我们正在处理的数据类型。如果我们尝试在搜索帮助时重写`name.local…`调用，我们会看到这一点。
- en: 'If we do this, and retype the sentence, when we press the dot symbol next to
    `return.name`, we''ll be given a list of possible values that the `name` property
    admits, including the correct form of writing the sentence that was misspelled,
    as shown in the next screenshot. We also see extra information about the parameters
    that `localeCompare` should receive and the number of overloads that it defines:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，并重新输入句子，当我们按下`return.name`旁边的点符号时，我们会得到一个列表，其中包含`name`属性接受的可能的值，包括拼写错误的句子正确的写法，如下一张截图所示。我们还看到了关于`localeCompare`应该接收的参数的额外信息以及它定义的重载数量：
- en: '![More TypeScript in action](img/image00592.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![更多TypeScript示例](img/image00592.jpeg)'
- en: 'Actually, since TypeScript supports advanced features, you can use them right
    now with total backward compatibility: for instance, we can change the function
    argument we pass to the sort method into a lambda expression, just as if we were
    using ECMAScript 2015.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，由于TypeScript支持高级功能，你现在可以使用它们，并且具有完全的向后兼容性：例如，我们可以将传递给排序方法的函数参数更改为lambda表达式，就像我们使用ECMAScript
    2015一样。
- en: Let's take a look at the entire example. We'll define an array of hardware appliances
    along with their prices and identification numbers. The target is to sort the
    array by name and dynamically generate an output in a page, showing the names
    and prices in the sorted array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下整个示例。我们将定义一个包含硬件设备和它们价格及识别号的数组。目标是按名称对数组进行排序，并在一个页面上动态生成输出，显示排序数组中的名称和价格。
- en: 'This is the code we''ll use:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的代码：
- en: '[PRE31]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, the `Entity` declaration guarantees that the later array definition of
    type `Entity[]` is recognized by the editor. At the time of putting everything
    together, the `window.onload` event uses a lambda expression with no arguments.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Entity`声明保证了编辑器可以识别类型为`Entity[]`的后续数组定义。在将一切组合在一起的时候，`window.onload`事件使用了一个不带参数的lambda表达式。
- en: In the body of this expression, a sorted array is produced from the original
    definition, and then the new `map` method included in JavaScript 5 is called,
    allowing us to pass a callback function to be executed for every element in the
    array.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表达式的主体中，从原始定义中生成一个排序后的数组，然后调用JavaScript 5中包含的新`map`方法，允许我们传递一个回调函数，该函数将对数组中的每个元素执行。
- en: Again, we use a lambda expression to define the callback function, where `e`
    will represent—sequentially—the elements of the array (`entities`). We will have
    Intellisense in the edition even when using the properties of `e` so that we ensure
    that all members end up correctly spelled.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 lambda 表达式来定义回调函数，其中 `e` 将依次代表数组的元素（`entities`）。即使在编辑 `e` 的属性时，我们也会拥有
    Intellisense，以确保所有成员都拼写正确。
- en: 'The execution shows the list of elements, ordered by name, including the `name`
    and `price` fields, just as we expected:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果显示了按名称排序的元素列表，包括 `name` 和 `price` 字段，正如我们所期望的：
- en: '![More TypeScript in action](img/image00593.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![更多 TypeScript 在行动](img/image00593.jpeg)'
- en: The DOM connection
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM 连接
- en: 'The "DOM connection" we mentioned earlier is very helpful in a variety of cases.
    Imagine that we want an alert dialog indicating the X coordinate of the mouse
    when the cursor moves over the window. We could program something like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的“DOM 连接”在许多情况下非常有帮助。想象一下，我们想要一个当鼠标指针移过窗口时显示鼠标 X 坐标的警告对话框。我们可以编写类似这样的程序：
- en: '[PRE32]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we pass the mouse over the `e` argument (representing the event object),
    we''ll be shown a tooltip containing the event definition as well. And if we write
    `e.` (dot)…, Intellisense will again show up knowing exactly what can be done
    with that object. (Refer to the following figure):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将鼠标移到 `e` 参数（表示事件对象）上，我们还会看到一个包含事件定义的工具提示。如果我们写 `e.`（点）…，Intellisense 也会出现，并确切地知道可以使用该对象做什么。（参见图表）：
- en: '![The DOM connection](img/image00594.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![DOM 连接](img/image00594.jpeg)'
- en: Where does this extra Intellisense come from? We have the ability to check this
    feature in the same manner as we would in other languages in Visual Studio. Just
    mark `onmousemove` or the `e` object, and in the contextual menu, select **Go
    to Definition** or **Peek definition**.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这额外的 Intellisense 从哪里来？我们有能力以与其他语言在 Visual Studio 中相同的方式检查此功能。只需标记 `onmousemove`
    或 `e` 对象，然后在上下文菜单中选择**转到定义**或**查看定义**。
- en: The IDE opens a new window pointing to the definition extracted from a file
    called `Lib.d.ts` and shows every detail. As mentioned previously, this file is
    the declaration file for the entire DOM and all the JavaScript's standard runtime
    libraries (it contains about 8,000 lines of code declarations).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 打开一个指向从名为 `Lib.d.ts` 的文件中提取的定义的新窗口，并显示所有细节。如前所述，此文件是整个 DOM 和所有 JavaScript
    的标准运行时库的声明文件（包含大约 8,000 行代码声明）。
- en: 'Also, anyone can write these declaration files and upload them to the DefinitelyTyped
    site, since its completely open source:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何人都可以编写这些声明文件并将它们上传到 DefinitelyTyped 网站，因为它是完全开源的：
- en: '![The DOM connection](img/image00595.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![DOM 连接](img/image00595.jpeg)'
- en: 'So, let''s summarize some of the most important points discussed up until this
    point:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下到目前为止讨论的一些最重要的要点：
- en: We count on a formalization of the JavaScript types that allow excellent edition
    tools
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们依赖于对 JavaScript 类型的正式化，这允许出色的编辑工具
- en: We find type inference and structural typing since the very beginning
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从一开始就发现了类型推断和结构化类型
- en: It all works with existing JavaScript, with no modifications
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都使用现有的 JavaScript，无需修改
- en: Once the code is compiled, everything goes away, and the resulting code is nothing
    but plain JavaScript of the version of your choice
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦代码编译完成，所有内容都会消失，生成的代码只是你选择的版本的纯 JavaScript
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through some of the most important projects that Microsoft
    promotes as part of its Open Source ecosystem.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些微软作为其开源生态系统一部分推广的最重要项目。
- en: First, we reviewed the evolution of "open source" projects since the initial
    movements and revised some of the new tools and technologies under the open source
    initiatives, including how to program with Node.js from Visual Studio.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们回顾了“开源”项目自初始运动以来的演变，并对开源倡议下的一些新工具和技术进行了修订，包括如何在 Visual Studio 中使用 Node.js
    进行编程。
- en: Then, we moved on to the Roslyn set of tools and services and explored how to
    install the tools, identify the Syntax Object Model, and program a basic analyzer
    with code refactoring capabilities and understand how to debug it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向 Roslyn 工具和服务集，探讨了如何安装工具、识别语法对象模型，以及如何使用代码重构功能编写基本分析器，并了解如何调试它。
- en: Finally, we took a tour of the main language features of TypeScript, studying
    some of the most meaningful and proper definitions of the language and checking
    the excellent support we get in the code editor thanks to its static type system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们游览了TypeScript的主要语言特性，研究了语言中最有意义和恰当的定义，并检查了由于它的静态类型系统，我们在代码编辑器中获得的出色支持。
- en: In the next chapter, we'll cover the concept of Software Architecture, from
    high-level abstract concepts to low-level implementation. I will outline a step-by-step
    guide on designing a .NET application from the ground up.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨软件架构的概念，从高级抽象概念到低级实现。我将概述一个从头开始设计.NET应用程序的逐步指南。
