<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer055">
<h1 id="_idParaDest-147"><em class="italic"><a id="_idTextAnchor146"/>Chapter 9</em>: Working with Concurrent Collections in .NET</h1>
<p>This chapter will dive deeper into some of the<span class="superscript"> </span><strong class="bold">concurrent collections</strong> in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace. These<a id="_idIndexMarker474"/> specialized collections help to preserve data integrity when using concurrency and parallelism in your C# code. Each section of this chapter will provide practical examples of how to use a specific concurrent collection provided by .NET.</p>
<p>We have seen some basic use of parallel data structures in .NET. We have already covered the basics of each of the concurrent collections in the <em class="italic">Introduction to concurrency</em> section of <a href="B18552_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>. So, we will quickly jump into the examples of their use in this chapter and learn more about their application and inner workings.</p>
<p>In this chapter, we will do the following:</p>
<ul>
<li>Using <strong class="source-inline">BlockingCollection</strong></li>
<li>Using <strong class="source-inline">ConcurrentBag</strong></li>
<li>Using <strong class="source-inline">ConcurrentDictionary</strong></li>
<li>Using <strong class="source-inline">ConcurrentQueue</strong></li>
<li>Using <strong class="source-inline">ConcurrentStack</strong></li>
</ul>
<p>By the end of this chapter, you will have a deeper understanding of how these collections protect your shared data from being mishandled while multithreading.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later.</li>
<li>.NET 6.</li>
<li>To complete any WinForms or WPF samples, you will need to install the .NET desktop development workload for Visual Studio. These projects will run only on Windows.</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09</a>.</p>
<p>Let’s get started by learning more about <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> and walk through a sample project that leverages the collection.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Using BlockingCollection</h1>
<p><strong class="source-inline">BlockingCollection&lt;T&gt;</strong> is one of <a id="_idIndexMarker475"/>the most useful concurrent collections. As we saw in <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> was created to be an implementation<a id="_idIndexMarker476"/> of the <strong class="bold">producer/consumer pattern</strong> for .NET. Let’s review some of the specifics of this <a id="_idIndexMarker477"/>collection before creating a different kind of sample project.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor149"/>BlockingCollection details</h2>
<p>One of the <a id="_idIndexMarker478"/>major draws of <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> for developers working with parallel code implementations is that it can be swapped to replace <strong class="source-inline">List&lt;T&gt;</strong> without too many additional modifications. You can use the <strong class="source-inline">Add()</strong> method for both. The difference with <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> is that calling <strong class="source-inline">Add()</strong> to add an item will block the current thread if another read or write operation is in process. If you want to specify a timeout<a id="_idIndexMarker479"/> period on the operation, you can use <strong class="source-inline">TryAdd()</strong>. The <strong class="source-inline">TryAdd()</strong> method optionally supports both timeouts and cancellation tokens.</p>
<p>Removing items from <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> with <strong class="source-inline">Take()</strong> has an equivalent <strong class="source-inline">TryTake()</strong>, which allows timed operations and cancellation. The <strong class="source-inline">Take()</strong> and <strong class="source-inline">TryTake()</strong> methods will take and remove the first remaining item that was added to the collection. This is because the default underlying collection type within <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> is <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>. Alternatively, you can specify that the collection uses <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong>, <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong>, or any collection that implements the <strong class="source-inline">IProducerConsumerCollection&lt;T&gt;</strong> interface. Here’s an example of <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> being initialized to use <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong>, with its capacity limited to <strong class="source-inline">100</strong> items:</p>
<pre class="source-code">var itemCollection = new BlockingCollection&lt;string&gt;(new </pre>
<pre class="source-code">    ConcurrentStack&lt;string&gt;(), 100);</pre>
<p>If your application needs to iterate over the items in <strong class="source-inline">BlockingCollection&lt;T&gt;</strong>, the <strong class="source-inline">GetConsumingEnumerable()</strong> method can be used in a <strong class="source-inline">for</strong> or <strong class="source-inline">foreach</strong> loop. However, keep in mind that this iteration over the collection is also removing items, and it will complete the collection if the enumeration continues until the collection is empty. This is the <em class="italic">consuming</em> part of the <strong class="source-inline">GetConsumingEnumerable()</strong> method name.</p>
<p>If you need to use multiple <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> classes of the same type, you can add to or take from them as one by adding them to an array. An array of <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> makes the <strong class="source-inline">TryAddToAny()</strong> and <strong class="source-inline">TryTakeFromAny()</strong> methods available. These methods will succeed if any of the collections in the array are in the proper state to accept or provide objects to the calling code. Microsoft Docs has an example of how to use an array of <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> in a pipeline: https://docs.microsoft.com/dotnet/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.</p>
<p>Now that we have covered the details needed to understand <strong class="source-inline">BlockingCollection&lt;T&gt;</strong>, let’s dive into a sample project.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor150"/>Using BlockingCollection with Parallel.ForEach and PLINQ</h2>
<p>We already covered <a id="_idIndexMarker480"/>an example that implements the producer/consumer pattern in <a href="B18552_07_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 7</em></a>, so let’s try something a little different in this section. We are going to create a WPF application that loads the contents of a book from a 1.5 MB text file and searches for words that start with a particular letter:</p>
<p class="callout-heading">Note</p>
<p class="callout">This sample uses a .NET Standard NuGet package created from a Microsoft extension sample that was originally built on .NET Framework 4.0. The extension is called <strong class="source-inline">ParallelExtensionsExtras</strong>, and the original source is available on GitHub: https://github.com/dotnet/samples/tree/main/csharp/parallel/ParallelExtensionsExtras. The extension method that we will be using from the package makes <strong class="source-inline">Parallel.ForEach</strong> operations and PLINQ queries run more efficiently with concurrent collections. To read more about the extensions, you can check out this post on the <em class="italic">.NET Parallel Programming</em> blog: https://devblogs.microsoft.com/pfxteam/parallelextensionsextras-tour-4-blockingcollectionextensions/.</p>
<ol>
<li>Start by creating a new WPF application in Visual Studio. Name the project <strong class="source-inline">ParallelExtras.BlockingCollection</strong>.</li>
<li>On the NuGet Package Manager page, search for and add the latest stable version of the <strong class="bold">ParallelExtensionsExtras.NetFxStandard</strong> package to your project:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package " height="116" src="image/Figure_9.1_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The ParallelExtensionsExtras.NetFxStandard NuGet package</p>
<ol>
<li value="3">We are going to read text from the book <em class="italic">Ulysses</em> by James Joyce. This book is public domain in the United States and most countries around the world. It can be downloaded in UTF-8 plain text format from <strong class="bold">Project Gutenberg</strong>: https://www.gutenberg.org/ebooks/4300. Download a copy, name the file <strong class="source-inline">ulysses.txt</strong>, and place it in the main folder with your other project files.</li>
<li>In Visual Studio, right-click <strong class="source-inline">ulysses.txt</strong> and select <strong class="bold">Properties</strong>. In the <strong class="bold">Properties</strong> window, update<a id="_idIndexMarker481"/> the <strong class="bold">Copy to Output Directory</strong> property to <strong class="bold">Copy if newer</strong>.</li>
<li>Open <strong class="bold">MainWindow.xaml</strong> and add <strong class="source-inline">Grid.RowDefinitions</strong> and <strong class="source-inline">Grid.Columndefinitions</strong> to the <strong class="source-inline">Grid</strong> control, as follows:<p class="source-code">&lt;Grid.RowDefinitions&gt;</p><p class="source-code">    &lt;RowDefinition Height="Auto"/&gt;</p><p class="source-code">    &lt;RowDefinition Height="*"/&gt;</p><p class="source-code">&lt;/Grid.RowDefinitions&gt;</p><p class="source-code">&lt;Grid.ColumnDefinitions&gt;</p><p class="source-code">    &lt;ColumnDefinition/&gt;</p><p class="source-code">    &lt;ColumnDefinition/&gt;</p><p class="source-code">&lt;/Grid.ColumnDefinitions&gt;</p></li>
<li>Add <strong class="source-inline">ComboBox</strong> and <strong class="source-inline">Button</strong> inside the <strong class="source-inline">Grid</strong> definition following the <strong class="source-inline">Grid.ColumnDefinitions</strong> element. These controls will be in the first row of <strong class="source-inline">Grid</strong>:<p class="source-code">&lt;ComboBox x:Name="LettersComboBox"</p><p class="source-code">            Grid.Row="0" Grid.Column="0"</p><p class="source-code">            Margin="4"&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="A"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="D"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="F"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="G"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="M"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="O"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="A"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="T"/&gt;</p><p class="source-code">    &lt;ComboBoxItem Content="W"/&gt;</p><p class="source-code">&lt;/ComboBox&gt;</p><p class="source-code">&lt;Button Grid.Row="0" Grid.Column="1"</p><p class="source-code">        Margin="4" Content="Load Words"</p><p class="source-code">        Click="Button_Click"/&gt;</p></li>
</ol>
<p><strong class="source-inline">ComboBox</strong> will contain nine different letters from which to choose. You can add as<a id="_idIndexMarker482"/> many of these as you like. <strong class="source-inline">Button</strong> contains a <strong class="source-inline">Click</strong> event handler that we will add to <strong class="source-inline">MainWindow.xaml.cs</strong> soon.</p>
<ol>
<li value="7">Finally, add <strong class="source-inline">ListView</strong> named <strong class="source-inline">WordsListView</strong> to the second row of <strong class="source-inline">Grid</strong>. It will span both of the columns:<p class="source-code">&lt;ListView x:Name="WordsListView" Margin="4"</p><p class="source-code">            Grid.Row="1" Grid.ColumnSpan="2"/&gt;</p></li>
<li>Now, open <strong class="source-inline">MainWIndow.xaml.cs</strong>. The first thing we will do here is to create a method named <strong class="source-inline">LoadBookLinesFromFile()</strong>, which reads each line of text from <strong class="source-inline">ulysses.txt</strong> into <strong class="source-inline">BlockingCollection&lt;string&gt;</strong>. There is only a single thread reading from the file, so using the <strong class="source-inline">Add()</strong> method instead of <strong class="source-inline">TryAdd()</strong> is best:<p class="source-code">private async Task&lt;BlockingCollection&lt;string&gt;&gt; </p><p class="source-code">    LoadBookLinesFromFile()</p><p class="source-code">{</p><p class="source-code">    var lines = new BlockingCollection&lt;string&gt;();</p><p class="source-code">    using var reader = File.OpenText(Path.Combine(</p><p class="source-code">        Path.GetDirectoryName(Assembly</p><p class="source-code">            .GetExecutingAssembly().Location), </p><p class="source-code">                "ulysses.txt"));</p><p class="source-code">    string line;</p><p class="source-code">    while ((line = await reader.ReadLineAsync()) != </p><p class="source-code">        null)</p><p class="source-code">    {</p><p class="source-code">        lines.Add(line);</p><p class="source-code">    }</p><p class="source-code">    lines.CompleteAdding();</p><p class="source-code">    return lines;</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Remember, it is important to call <strong class="source-inline">lines.CompleteAdding()</strong> before the end of the method. Otherwise, subsequent queries of this collection will hang and continue waiting for more items to be added to the stream.</p>
<ol>
<li value="9">Now, create<a id="_idIndexMarker483"/> a method named <strong class="source-inline">GetWords()</strong> that takes the lines from the text file and<a id="_idIndexMarker484"/> uses a <strong class="bold">regular expression</strong> to parse each line into individual words. These words will all be added to a new <strong class="source-inline">BlockingCollection&lt;string&gt;</strong>. In this method, we’re parsing multiple lines simultaneously with a <strong class="source-inline">Parallel.ForEach</strong> loop. The <strong class="bold">ParallelExtentionsExtras.NetFxStandard</strong> package provides the <strong class="source-inline">GetConsumingPartitioner()</strong> extension method, which tells the <strong class="source-inline">Parallel.ForEach</strong> loop that <strong class="source-inline">BlockingCollection</strong> will be doing its own blocking, so the loop does not need to do any. This makes the whole process <a id="_idIndexMarker485"/>more efficient:<p class="source-code">private BlockingCollection&lt;string&gt; </p><p class="source-code">    GetWords(BlockingCollection&lt;string&gt; lines)</p><p class="source-code">{</p><p class="source-code">    var words = new BlockingCollection&lt;string&gt;();</p><p class="source-code">    Parallel.ForEach(lines.GetConsumingPartitioner(), </p><p class="source-code">        (line) =&gt;</p><p class="source-code">    {</p><p class="source-code">        var matches = Regex.Matches(line, </p><p class="source-code">            @"\b[\w']*\b");</p><p class="source-code">        foreach (var m in matches.Cast&lt;Match&gt;())</p><p class="source-code">        {</p><p class="source-code">            if (!string.IsNullOrEmpty(m.Value))</p><p class="source-code">            {</p><p class="source-code">                words.TryAdd(TrimSuffix(m.Value, </p><p class="source-code">                    '\''));</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    });</p><p class="source-code">    words.CompleteAdding();</p><p class="source-code">    return words;</p><p class="source-code">}</p><p class="source-code">private string TrimSuffix(string word, char </p><p class="source-code">    charToTrim)</p><p class="source-code">{</p><p class="source-code">    int charLocation = word.IndexOf(charToTrim);</p><p class="source-code">    if (charLocation != -1)</p><p class="source-code">    {</p><p class="source-code">        word = word[..charLocation];</p><p class="source-code">    }</p><p class="source-code">    return word;</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">TrimSuffix()</strong> method<a id="_idIndexMarker486"/> will remove specific characters from the end of a word; in this case, we’re passing the apostrophe character to be removed.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are unfamiliar with regular expressions, you can read about how to use them with .NET on Microsoft Docs: <a href="https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions">https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions</a>. They are an extremely efficient way to parse text.</p>
<ol>
<li value="10">Next, create a method named <strong class="source-inline">GetWordsByLetter()</strong> to call the other methods we just created. Once <strong class="source-inline">BlockingCollection&lt;string&gt;</strong> containing all the words from the book has been fetched, this method will use PLINQ and <strong class="source-inline">GetConsumingPartitioner()</strong> to find all words that start with the uppercase or lowercase versions of the selected letter:<p class="source-code">private async Task&lt;List&lt;string&gt;&gt; GetWordsByLetter(char </p><p class="source-code">    letter)</p><p class="source-code">{</p><p class="source-code">    BlockingCollection&lt;string&gt; lines = await </p><p class="source-code">        LoadBookLinesFromFile();</p><p class="source-code">    BlockingCollection&lt;string&gt; words = </p><p class="source-code">        GetWords(lines);</p><p class="source-code">    // 275,506 words in total</p><p class="source-code">    return words.GetConsumingPartitioner()</p><p class="source-code">        .AsParallel()</p><p class="source-code">        .Where(w =&gt; w.StartsWith(letter) || </p><p class="source-code">            w.StartsWith(char.ToLower(letter)))</p><p class="source-code">        .ToList();</p><p class="source-code">}</p></li>
<li>Finally, we’ll add the <strong class="source-inline">Button_Click</strong> event to kick off the loading, parsing, and querying<a id="_idIndexMarker487"/> of the book’s text. Don’t forget to mark the event handler as <strong class="source-inline">async</strong>:<p class="source-code">private async void Button_Click(object sender, </p><p class="source-code">    RoutedEventArgs e)</p><p class="source-code">{</p><p class="source-code">    if (LettersComboBox.SelectedIndex &lt; 0)</p><p class="source-code">    {</p><p class="source-code">        MessageBox.Show("Please select a letter.");</p><p class="source-code">        return;</p><p class="source-code">    }</p><p class="source-code">    WordsListView.ItemsSource = await </p><p class="source-code">        GetWordsByLetter(</p><p class="source-code">        char.Parse(GetComboBoxValue(LettersComboBox</p><p class="source-code">            .SelectedValue)));</p><p class="source-code">}</p><p class="source-code">private string GetComboBoxValue(object item)</p><p class="source-code">{</p><p class="source-code">    var comboxItem = item as ComboBoxItem;</p><p class="source-code">    return comboxItem.Content.ToString();</p><p class="source-code">}</p></li>
</ol>
<p>The <strong class="source-inline">GetComboBoxValue()</strong> helper method will take the object from <strong class="source-inline">LettersComboBox.SelectedValue</strong> and find <strong class="source-inline">string</strong> with the selected letter within.</p>
<ol>
<li value="12">The<a id="_idIndexMarker488"/> following <strong class="source-inline">using</strong> declarations are required in <strong class="source-inline">MainWindow.xaml.cs</strong> to compile and run the project:<p class="source-code">using System.Collections.Concurrent;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.IO;</p><p class="source-code">using System.Linq;</p><p class="source-code">using System.Reflection;</p><p class="source-code">using System.Text.RegularExpressions;</p><p class="source-code">using System.Threading.Tasks;</p><p class="source-code">using System.Windows;</p><p class="source-code">using System.Windows.Controls;</p></li>
<li>Now, run the project, select a letter, and click <strong class="bold">Load Words</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 9.2 – Displaying words that begin with T from ulysses.txt " height="709" src="image/Figure_9.2_B18552.jpg" width="1074"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Displaying words that begin with T from ulysses.txt</p>
<p>The <a id="_idIndexMarker489"/>whole process runs very quickly considering the book contains over 275,000 total words. Try adding some sorting to the PLINQ query and see how the performance is impacted.</p>
<p>Let’s continue by learning about <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong>.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Using ConcurrentBag</h1>
<p>The <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> is an <a id="_idIndexMarker490"/>unordered collection of <a id="_idIndexMarker491"/>objects that can be safely added, peeked at, or removed concurrently. Keep in mind that, as with all of the concurrent collections, the methods exposed by <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> are thread-safe, but any extension methods are not guaranteed to be safe. Always implement your own synchronization when leveraging them. To review a list of safe methods, you can review this Microsoft Docs page: https://docs.microsoft.com/dotnet/api/system.collections.concurrent.concurrentbag-1#methods.</p>
<p>We are going to create a sample application that simulates working with a pool of objects. This scenario can be useful if you have some processing that leverages a stateful object that is memory-intensive. You want to minimize the number of objects created but cannot reuse one until the previous iteration has finished using it and returned it to the pool.</p>
<p>In our<a id="_idIndexMarker492"/> example, we will use a mocked-up PDF processing class that is assumed to be memory-intensive. In reality, document-processing libraries can be quite heavy, and they often rely on document states in each instance. The console application will iterate in parallel 15 times to create these fake PDF objects and append some text to each of them. Each time through the loop, we will output the text contents and the current count of PDF processors in the pool. If the current count remains low, then the application is working as intended:</p>
<ol>
<li value="1">Start by creating a new .NET console application in Visual Studio named <strong class="source-inline">ConcurrentBag.PdfProcessor</strong>.</li>
<li>Add a new class to represent the mocked-up PDF data. Name the class <strong class="source-inline">ImposterPdfData</strong>:<p class="source-code">public class ImposterPdfData</p><p class="source-code">{</p><p class="source-code">    private string _plainText;</p><p class="source-code">    private byte[] _data;</p><p class="source-code">    public ImposterPdfData(string plainText)</p><p class="source-code">    {</p><p class="source-code">        _plainText = plainText;</p><p class="source-code">        _data = System.Text.Encoding.ASCII.GetBytes</p><p class="source-code">            (plainText);</p><p class="source-code">    }</p><p class="source-code">    public string PlainText =&gt; _plainText;</p><p class="source-code">    public byte[] PdfData =&gt; _data;</p><p class="source-code">}</p></li>
</ol>
<p>We are storing the plain text and an ASCII-encoded version of the text that we will pretend is PDF format. This avoids implementing any third-party libraries in our sample application. If you have any PDF libraries with which you are familiar, you are welcome to adapt this sample to use them.</p>
<ol>
<li value="3">Next, add a <a id="_idIndexMarker493"/>new class named <strong class="source-inline">PdfParser</strong>. This class will be the one that is taken from and returned to <strong class="source-inline">ConcurrentBag&lt;PdfParser&gt;</strong>. We will create the host for that collection in an upcoming step:<p class="source-code">public class PdfParser</p><p class="source-code">{</p><p class="source-code">    private ImposterPdfData? _pdf;</p><p class="source-code">    public void SetPdf(ImposterPdfData pdf) =&gt; </p><p class="source-code">        _pdf = pdf;</p><p class="source-code">    public ImposterPdfData? GetPdf() =&gt; _pdf;</p><p class="source-code">    public string GetPdfAsString()</p><p class="source-code">    {</p><p class="source-code">        if (_pdf != null)</p><p class="source-code">            return _pdf.PlainText;</p><p class="source-code">        else</p><p class="source-code">            return "";</p><p class="source-code">    }</p><p class="source-code">    public byte[] GetPdfBytes()</p><p class="source-code">    {</p><p class="source-code">        if (_pdf != null)</p><p class="source-code">            return _pdf.PdfData;</p><p class="source-code">        else</p><p class="source-code">            return new byte[0];</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>This stateful class holds an instance of an <strong class="source-inline">ImposterPdfData</strong> object and can return the data as a string or the ASCII-encoded byte array.</p>
<ol>
<li value="4">Add a <a id="_idIndexMarker494"/>method to <strong class="source-inline">PdfParser</strong> named <strong class="source-inline">AppendString</strong>. This method will add some additional text to <strong class="source-inline">ImposterPdfData</strong> on a new line:<p class="source-code">public void AppendString(string data)</p><p class="source-code">{</p><p class="source-code">    string newData;</p><p class="source-code">    if (_pdf == null)</p><p class="source-code">    {</p><p class="source-code">        newData = data;</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">        newData = _pdf.PlainText + Environment.NewLine </p><p class="source-code">            + data;</p><p class="source-code">    }</p><p class="source-code">    _pdf = new ImposterPdfData(newData);</p><p class="source-code">}</p></li>
<li>Now, add a class named <strong class="source-inline">PdfWorkerPool</strong>:<p class="source-code">public class PdfWorkerPool</p><p class="source-code">{</p><p class="source-code">    private ConcurrentBag&lt;PdfParser&gt; _workerPool = </p><p class="source-code">        new();</p><p class="source-code">    public PdfWorkerPool()</p><p class="source-code">    {</p><p class="source-code">        // Add initial worker</p><p class="source-code">        _workerPool.Add(new PdfParser());</p><p class="source-code">    }</p><p class="source-code">    public PdfParser Get() =&gt; _workerPool.TryTake(out </p><p class="source-code">        var parser) ? parser : new PdfParser();</p><p class="source-code">    public void Return(PdfParser parser) =&gt; </p><p class="source-code">        _workerPool.Add(parser);</p><p class="source-code">    public int WorkerCount =&gt; _workerPool.Count();</p><p class="source-code">}</p></li>
</ol>
<p>Be <a id="_idIndexMarker495"/>sure to also add a <strong class="source-inline">using System.Collections.Concurrent;</strong> statement to <strong class="source-inline">PdfWorkerPool.cs</strong>. The pool stores <strong class="source-inline">ConcurrentBag&lt;PdfParser&gt;</strong> named <strong class="source-inline">_workerPool</strong>. When <strong class="source-inline">PdfWorkerPool</strong> is initialized, it adds a new instance to <strong class="source-inline">_workerPool</strong>. The <strong class="source-inline">Get</strong> method will return an existing instance from the pool with <strong class="source-inline">TryTake</strong> if one exists. If the pool is empty, a new instance is created and returned to the caller. The <strong class="source-inline">Return</strong> method adds <strong class="source-inline">PdfParser</strong> back to the pool when the consumer is finished. We will use the <strong class="source-inline">WorkerCount</strong> property to track the number of objects in the pool at any time.</p>
<ol>
<li value="6">Finally, replace the contents of <strong class="source-inline">Program.cs</strong> with the following code:<p class="source-code">using ConcurrentBag.PdfProcessor;</p><p class="source-code">Console.WriteLine("Hello, ConcurrentBag!");</p><p class="source-code">var pool = new PdfWorkerPool();</p><p class="source-code">Parallel.For(0, 15, async (i) =&gt;</p><p class="source-code">{</p><p class="source-code">    var parser = pool.Get();</p><p class="source-code">    var data = new ImposterPdfData($"Data index: {i}");</p><p class="source-code">    try</p><p class="source-code">    {</p><p class="source-code">        parser.SetPdf(data);</p><p class="source-code">        parser.AppendString(DateTime.UtcNow</p><p class="source-code">            .ToShortDateString());</p><p class="source-code">        Console.WriteLine($"</p><p class="source-code">           {parser.GetPdfAsString()}");</p><p class="source-code">        Console.WriteLine($"Parser count: </p><p class="source-code">            {pool.WorkerCount}");</p><p class="source-code">        await Task.Delay(100);</p><p class="source-code">    }</p><p class="source-code">    finally</p><p class="source-code">    {</p><p class="source-code">        pool.Return(parser);</p><p class="source-code">        await Task.Delay(250);</p><p class="source-code">    }</p><p class="source-code">});</p><p class="source-code">Console.WriteLine("Press the Enter key to exit.");</p><p class="source-code">Console.ReadLine();</p></li>
</ol>
<p>After creating a new <strong class="source-inline">PdfWorkerPool</strong>, we’re using a <strong class="source-inline">Parallel.For</strong> loop to iterate 15 times. Each time through the loop, we get <strong class="source-inline">PdfParser</strong>, set the text, append <strong class="source-inline">DateTime.UtcNow</strong>, and write the contents to the console, along with the<a id="_idIndexMarker496"/> current count of parsers in the pool.</p>
<ol>
<li value="7">Run the application and examine the output:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 9.3 – Running the PdfProcessor console application " height="691" src="image/Figure_9.3_B18552.jpg" width="871"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Running the PdfProcessor console application</p>
<p>In my case, the parser count got to a maximum number of seven. If you tweak the <strong class="source-inline">Task.Delay</strong> intervals or remove them entirely, you are likely to see the count never exceed one. This kind of pool can be configured to be very efficient.</p>
<p>This application is an example where we do not care which instance of the collection is returned, so <strong class="source-inline">ConcurrentBag&lt;T&gt;</strong> is a perfect choice. In the next section, we will create a drug lookup example using <strong class="source-inline">ConcurrentDictionary&lt;TKey, TValue&gt;</strong>.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Using ConcurrentDictionary</h1>
<p>In this <a id="_idIndexMarker497"/>section, we<a id="_idIndexMarker498"/> will create a WinForms application to load United States <strong class="bold">Food and Drug Administration</strong> (<strong class="bold">FDA</strong>) drug data concurrently from two files. Once loaded to <strong class="source-inline">ConcurrentDictionary</strong>, we can perform fast lookups with a <strong class="bold">National Drug Code</strong> (<strong class="bold">NDC</strong>) value to fetch the name. The FDA drug data is freely available to download in several formats from the NDC directory: https://www.fda.gov/drugs/drug-approvals-and-databases/national-drug-code-directory. We will be working with tab-delimited text files. I have downloaded the <strong class="source-inline">product.txt</strong> file and moved about half of the records to a <strong class="source-inline">product2.txt</strong> file, duplicating the header row in the second file. You can get these files in the <a id="_idIndexMarker499"/>GitHub repository for the chapter at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup</a>:</p>
<ol>
<li value="1">Start by creating a new WinForms project in Visual Studio targeting .NET 6. Name the project <strong class="source-inline">FdaNdcDrugLookup</strong>.</li>
<li>Open the WinForm designer for <strong class="source-inline">Form1.cs</strong>. Lay out two <strong class="source-inline">TextBox</strong> controls, two <strong class="source-inline">Button</strong> controls, and <strong class="source-inline">Label</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 9.4 – The layout of Form1.cs " height="524" src="image/Figure_9.4_B18552.jpg" width="1056"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The layout of Form1.cs</p>
<p>The <strong class="bold">Load Data</strong> button will have the following properties set: <strong class="bold">Name</strong> – <strong class="source-inline">btnLoad</strong> and <strong class="bold">Text</strong> – <strong class="bold">Load Data</strong>. The <strong class="bold">NDC Code</strong> text field will be named <strong class="source-inline">txtNdc</strong>. The <strong class="bold">Lookup Drug</strong> button will have these properties set: <strong class="bold">Name</strong> – <strong class="source-inline">btnLookup</strong>, <strong class="bold">Text</strong> – <strong class="bold">Lookup Drug</strong>, and <strong class="bold">Enabled</strong> – <strong class="bold">False</strong>. Finally, the <strong class="bold">Drug Name</strong> text field will have these properties set: <strong class="bold">Name</strong> – <strong class="source-inline">txtDrugName</strong> and <strong class="bold">ReadOnly</strong> – <strong class="bold">True</strong>.</p>
<ol>
<li value="3">Next, add the <strong class="source-inline">product.txt</strong> and <strong class="source-inline">product2.txt</strong> files to your project by right-clicking<a id="_idIndexMarker500"/> the project in <strong class="bold">Solution Explorer</strong> and choosing <strong class="bold">Add</strong> | <strong class="bold">Existing Item</strong>. </li>
<li>In the <strong class="bold">Properties</strong> panel, change <strong class="bold">Copy to Output Directory</strong> to <strong class="bold">Copy if newer</strong> for both of the text files we just added.</li>
<li>Add a new class to the project named <strong class="source-inline">Drug</strong> and add the following implementation:<p class="source-code">public class Drug</p><p class="source-code">{</p><p class="source-code">    public string? Id { get; set; }</p><p class="source-code">    public string? Ndc { get; set; }</p><p class="source-code">    public string? TypeName { get; set; }</p><p class="source-code">    public string? ProprietaryName { get; set; }</p><p class="source-code">    public string? NonProprietaryName { get; set; }</p><p class="source-code">    public string? DosageForm { get; set; }</p><p class="source-code">    public string? Route { get; set; }</p><p class="source-code">    public string? SubstanceName { get; set; }</p><p class="source-code">}</p></li>
</ol>
<p>This will contain the data for each record loaded from the NDC drug files.</p>
<ol>
<li value="6">Next, add a class to the project named <strong class="source-inline">DrugService</strong> and begin with the following implementation. To start, we only have <strong class="source-inline">private</strong> <strong class="source-inline">ConcurrentDictionary&lt;string, Drug&gt;</strong>. We will add a method to load the data in the next step:<p class="source-code">using System.Collections.Concurrent;</p><p class="source-code">using System.Data;</p><p class="source-code">using System.Reflection;</p><p class="source-code">namespace FdaNdcDrugLookup</p><p class="source-code">{</p><p class="source-code">    public class DrugService</p><p class="source-code">    {</p><p class="source-code">        private ConcurrentDictionary&lt;string, Drug&gt; </p><p class="source-code">            _drugData = new();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Next, add a <a id="_idIndexMarker501"/>public method to <strong class="source-inline">DrugService</strong> named <strong class="source-inline">LoadData</strong>:<p class="source-code">public void LoadData(string fileName)</p><p class="source-code">{</p><p class="source-code">    using DataTable dt = new();</p><p class="source-code">    using StreamReader sr = new(Path.Combine(</p><p class="source-code">        Path.GetDirectoryName(Assembly</p><p class="source-code">            .GetExecutingAssembly().Location), </p><p class="source-code">               fileName));</p><p class="source-code">    var del = new char[] { '\t' };</p><p class="source-code">    string[] colheaders = sr.ReadLine().Split(del);</p><p class="source-code">    foreach (string header in colheaders)</p><p class="source-code">    {</p><p class="source-code">        dt.Columns.Add(header); // add headers</p><p class="source-code">    }</p><p class="source-code">    while (sr.Peek() &gt; 0)</p><p class="source-code">    {</p><p class="source-code">        DataRow dr = dt.NewRow(); // add rows</p><p class="source-code">        dr.ItemArray = sr.ReadLine().Split(del);</p><p class="source-code">        dt.Rows.Add(dr);</p><p class="source-code">    }</p><p class="source-code">    foreach (DataRow row in dt.Rows)</p><p class="source-code">    {</p><p class="source-code">        Drug drug = new(); // map to Drug object</p><p class="source-code">        foreach (DataColumn column in dt.Columns)</p><p class="source-code">        {</p><p class="source-code">            switch (column.ColumnName)</p><p class="source-code">            {</p><p class="source-code">                case "PRODUCTID":</p><p class="source-code">                    drug.Id = row[column].ToString();</p><p class="source-code">                    break;</p><p class="source-code">                case "PRODUCTNDC":</p><p class="source-code">                    drug.Ndc = row[column].ToString();</p><p class="source-code">                    break;</p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">// REMAINING CASE STATEMENTS IN GITHUB</strong></p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        _drugData.TryAdd(drug.Ndc, drug);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">switch</strong> statement in the previous snippet is truncated. To get the full code listing, visit the sample in the chapter’s GitHub repository: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/FdaNdcDrugLookup</a>.</p>
<p>In this <a id="_idIndexMarker502"/>method, we are loading data from the provided <strong class="source-inline">fileName</strong> to <strong class="source-inline">StreamReader</strong>, adding the column headers to <strong class="source-inline">DataTable</strong>, populating its rows from the file, and then iterating over the rows and columns of <strong class="source-inline">DataTable</strong> to create <strong class="source-inline">Drug</strong> objects. Each <strong class="source-inline">Drug</strong> object is added to <strong class="source-inline">ConcurrentDictionary</strong> with a call to <strong class="source-inline">TryAdd</strong>, using the <strong class="source-inline">Ndc</strong> property as the key.</p>
<ol>
<li value="8">Now, add a <strong class="source-inline">GetDrugByNdc</strong> method to <strong class="source-inline">DrugService</strong> to complete the class. This method will return <strong class="source-inline">Drug</strong> for the provided <strong class="source-inline">ndcCode</strong>, if found:<p class="source-code">public Drug GetDrugByNdc(string ndcCode)</p><p class="source-code">{</p><p class="source-code">    bool result = _drugData.TryGetValue(ndcCode, out </p><p class="source-code">        var drug);</p><p class="source-code">    if (result &amp;&amp; drug != null)</p><p class="source-code">        return drug;</p><p class="source-code">    else</p><p class="source-code">        return new Drug();</p><p class="source-code">}</p></li>
<li>Open the code for <strong class="source-inline">Form1.cs</strong> and add a private variable for the <strong class="source-inline">DrugService</strong>:<p class="source-code">private DrugService _drugService = new();</p></li>
<li>Open the<a id="_idIndexMarker503"/> designer for <strong class="source-inline">Form1.cs</strong> and double-click the <strong class="bold">Load Data</strong> button to create the <strong class="source-inline">btnLoad_Click</strong> event handler. Add the following implementation. Note that we made the <strong class="source-inline">async</strong> event handler to allow us to use the <strong class="source-inline">await</strong> keyword:<p class="source-code">private async void btnLoad_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    var t1 = Task.Run(() =&gt; _drugService.LoadData</p><p class="source-code">        ("product.txt"));</p><p class="source-code">    var t2 = Task.Run(() =&gt; _drugService.LoadData</p><p class="source-code">        ("product2.txt"));</p><p class="source-code">    await Task.WhenAll(t1, t2);</p><p class="source-code">    btnLookup.Enabled = true;</p><p class="source-code">    btnLoad.Enabled = false;</p><p class="source-code">}</p></li>
</ol>
<p>To load the two text files, we are creating two tasks to run in parallel before using <strong class="source-inline">Task.WhenAll</strong> to await them both. Then, we can safely enable the <strong class="source-inline">btnLookup</strong> button and disable the <strong class="source-inline">btnLoad</strong> button to prevent a second load.</p>
<ol>
<li value="11">Next, switch back to the designer view for <strong class="source-inline">Form1.cs</strong> and double-click the <strong class="bold">Lookup Drug</strong> button. This will create the <strong class="source-inline">btnLookup_Click</strong> event handler. Add the following implementation to that handler to find a drug name based on the NDC code entered in the UI:<p class="source-code">private void btnLookup_Click(object sender, </p><p class="source-code">    EventArgs e)</p><p class="source-code">{</p><p class="source-code">    if (!string.IsNullOrWhiteSpace(txtNdc.Text))</p><p class="source-code">    {</p><p class="source-code">        var drug = _drugService.GetDrugByNdc</p><p class="source-code">           (txtNdc.Text);</p><p class="source-code">        txtDrugName.Text = drug.ProprietaryName;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Now, run<a id="_idIndexMarker504"/> the application and click the <strong class="bold">Load Data</strong> button. After the load process has completed and the <strong class="bold">Lookup Drug</strong> button is enabled, enter the <strong class="source-inline">70518-1120</strong> NDC code. Click <strong class="bold">Lookup Drug</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 9.5 – Looking up the drug Prednisone by its NDC code " height="512" src="image/Figure_9.5_B18552.jpg" width="1226"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Looking up the drug Prednisone by its NDC code</p>
<ol>
<li value="13">Try some other NDC codes and see how quickly each record loads. Here are a few random NDC<a id="_idIndexMarker505"/> codes taken from each file. If they all succeed, you know that both files loaded successfully in parallel: <strong class="bold">0002-0800</strong>, <strong class="bold">0002-4112</strong>, <strong class="bold">43063-825</strong>, and <strong class="bold">51662-1544</strong>.</li>
</ol>
<p>That’s it! You now have your own quick-and-dirty drug lookup application. Try replacing the drug name <strong class="source-inline">TextBox</strong> with <strong class="source-inline">DataGrid</strong> on your own to display an entire <strong class="source-inline">Drug</strong> record.</p>
<p>In the next section, we will work with customer orders in <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor153"/>Using ConcurrentQueue</h1>
<p>In this section, we <a id="_idIndexMarker506"/>will create a sample project that is <a id="_idIndexMarker507"/>a simplified version of a realistic scenario. We are going to create an order queuing system using <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>. This application will be a console application that enqueues orders for two customers in parallel. We will create five orders for each customer, and to mix up the order of the queue, each customer queuing process will use a different <strong class="source-inline">Task.Delay</strong> between calls to <strong class="source-inline">Enqueue</strong>. The final output should <a id="_idIndexMarker508"/>show a mix of orders dequeued for the first customer and the second customer. Remember that <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong> employs <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) logic:</p>
<ol>
<li value="1">Let’s start by opening Visual Studio and creating a .NET console application named <strong class="source-inline">ConcurrentOrderQueue</strong>.</li>
<li>Add a new class to the project named <strong class="source-inline">Order</strong>:<p class="source-code">public class Order</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public string? ItemName { get; set; }</p><p class="source-code">    public int ItemQty { get; set; }</p><p class="source-code">    public int CustomerId { get; set; }</p><p class="source-code">    public decimal OrderTotal { get; set; }</p><p class="source-code">}</p></li>
<li>Now, create a new class named <strong class="source-inline">OrderService</strong> containing a private <strong class="source-inline">ConcurrentQueue&lt;Order&gt;</strong> named <strong class="source-inline">_orderQueue</strong>. This class is where we will enqueue<a id="_idIndexMarker509"/> and dequeue orders for our two customers:<p class="source-code">using System.Collections.Concurrent;</p><p class="source-code">namespace ConcurrentOrderQueue</p><p class="source-code">{</p><p class="source-code">    public class OrderService</p><p class="source-code">    {</p><p class="source-code">        private ConcurrentQueue&lt;Order&gt; _orderQueue = </p><p class="source-code">            new();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
<li>Let’s start with the implementation of <strong class="source-inline">DequeueOrders</strong>. In this method, we will use a <strong class="source-inline">while</strong> loop to call <strong class="source-inline">TryDequeue</strong> until the collection is empty, adding each order to <strong class="source-inline">List&lt;Order&gt;</strong> to be returned to the caller:<p class="source-code">public List&lt;Order&gt; DequeueOrders()</p><p class="source-code">{</p><p class="source-code">    List&lt;Order&gt; orders = new();</p><p class="source-code">    <strong class="bold">while (_orderQueue.TryDequeue(out var order))</strong></p><p class="source-code">    {</p><p class="source-code">        orders.Add(order);</p><p class="source-code">    }</p><p class="source-code">    return orders;</p><p class="source-code">}</p></li>
<li>Now, we will create public and private <strong class="source-inline">EnqueueOrders</strong> methods. The public parameterless method will call the private method twice, once for each <strong class="source-inline">customerId</strong>. The two <a id="_idIndexMarker510"/>calls will be made in parallel, followed by a <strong class="source-inline">Task.WhenAll</strong> call to await them:<p class="source-code">public async Task EnqueueOrders()</p><p class="source-code">{</p><p class="source-code">    var t1 = EnqueueOrders(1);</p><p class="source-code">    var t2 = EnqueueOrders(2);</p><p class="source-code">    await Task.WhenAll(t1, t2);</p><p class="source-code">}</p><p class="source-code">private async Task EnqueueOrders(int customerId)</p><p class="source-code">{</p><p class="source-code">    for (int i = 1; i &lt; 6; i++)</p><p class="source-code">    {</p><p class="source-code">        var order = new Order</p><p class="source-code">        {</p><p class="source-code">            Id = i * customerId,</p><p class="source-code">            CustomerId = customerId,</p><p class="source-code">            ItemName = "Widget for customer " + </p><p class="source-code">                customerId,</p><p class="source-code">            ItemQty = 20 - (i * customerId)</p><p class="source-code">        };</p><p class="source-code">        order.OrderTotal = order.ItemQty * 5;</p><p class="source-code">        <strong class="bold">_orderQueue.Enqueue(order);</strong></p><p class="source-code">        await Task.Delay(100 * customerId);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
</ol>
<p>The private <strong class="source-inline">EnqueueOrders</strong> method iterates five times to create and <strong class="source-inline">Enqueue</strong> orders for the given <strong class="source-inline">customerId</strong>. This is also used to vary <strong class="source-inline">ItemName</strong>, <strong class="source-inline">ItemQty</strong>, and the duration of <strong class="source-inline">Task.Delay</strong>.</p>
<ol>
<li value="6">Finally, open <strong class="source-inline">Program.cs</strong> and add the following code to enqueue and dequeue<a id="_idIndexMarker511"/> the orders, and output the resulting list to the console:<p class="source-code">using ConcurrentOrderQueue;</p><p class="source-code">Console.WriteLine("Hello, World!");</p><p class="source-code">var service = new OrderService();</p><p class="source-code">await service.EnqueueOrders();</p><p class="source-code">var orders = service.DequeueOrders();</p><p class="source-code">foreach(var order in orders)</p><p class="source-code">{</p><p class="source-code">    Console.WriteLine(order.ItemName);</p><p class="source-code">}</p></li>
<li>Run the program and view the list of orders in the output. How does yours match up?</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 9.6 – Viewing the output of the order queue " height="517" src="image/Figure_9.6_B18552.jpg" width="1264"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Viewing the output of the order queue</p>
<p>Try varying the delay<a id="_idIndexMarker512"/> factor or changing <strong class="source-inline">customerId</strong> for one or both customers in the <strong class="source-inline">EnqueueOrders</strong> method to see how the order of the output changes.</p>
<p>Next, in the final section of the chapter, we will perform a quick experiment with the <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong> collection.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor154"/>Using ConcurrentStack</h1>
<p>In this<a id="_idIndexMarker513"/> section, we<a id="_idIndexMarker514"/> are going to experiment with <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> and <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong>. In the first example in this chapter, we used <strong class="source-inline">BlockingCollection&lt;T&gt;</strong> to read the words that started with a specific letter from the book <em class="italic">Ulysses</em>. We are going to make a copy of that project and change the code that reads the lines of text to use <strong class="source-inline">ConcurrentStack&lt;T&gt;</strong> inside <strong class="source-inline">BlockingCollection&lt;T&gt;</strong>. This will make the lines output in <a id="_idIndexMarker515"/>reverse order because a stack uses <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) logic. Let’s get started!</p>
<ol>
<li value="1">Make a copy of the <strong class="bold">ParallelExtras.BlockingCollection</strong> project from this chapter or modify the existing project if you prefer.</li>
<li>Open <strong class="source-inline">MainWindow.xaml.cs</strong> and modify the <strong class="source-inline">LoadBookLinesFromFile</strong> method<a id="_idIndexMarker516"/> to pass a new <strong class="source-inline">ConcurrentStack&lt;string&gt;</strong> to the constructor of <strong class="source-inline">BlockingCollection&lt;string&gt;</strong>:<p class="source-code">private async Task&lt;BlockingCollection&lt;string&gt;&gt; </p><p class="source-code">    LoadBookLinesFromFile()</p><p class="source-code">{</p><p class="source-code">    <strong class="bold">var lines = new BlockingCollection&lt;string&gt;(new </strong></p><p class="source-code"><strong class="bold">        ConcurrentStack&lt;string&gt;());</strong></p><p class="source-code"><strong class="bold">    ...</strong></p><p class="source-code">    return lines;</p><p class="source-code">}</p></li>
</ol>
<p>Note that the preceding method was truncated to emphasize the modified code. View the complete method on GitHub: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ParallelExtras.ConcurrentStack</a>.</p>
<ol>
<li value="3">Now, when you run the application and search for the same letter as before (in our case, <strong class="source-inline">T</strong>), you will see a different set of words at the beginning of the list:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 9.7 – Searching for words that start with T in Ulysses " height="710" src="image/Figure_9.7_B18552.jpg" width="1076"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Searching for words that start with T in Ulysses</p>
<p>If you <a id="_idIndexMarker517"/>scroll to the bottom of the list, you should see the words from the beginning of the book. Note that the list is not completely reversed because we didn’t use <strong class="source-inline">ConcurrentStack&lt;string&gt;</strong> when parsing the words from each line. You can try this on your own as another experiment.</p>
<p>That concludes our tour of the .NET concurrent collections. Let’s wrap up by summarizing what we have learned in this chapter.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Summary</h1>
<p>In this chapter, we delved into five of the collections in the <strong class="source-inline">System.Collections.Concurrent</strong> namespace. We created five sample applications in the chapter to get some hands-on experience with each of the concurrent collection types available in .NET 6. Through a mix of WPF, WinForms, and .NET console application projects, we examined some real-world methods of leveraging these collections in your own applications.</p>
<p>In the next chapter, we will explore the rich set of tools provided by Visual Studio for multithreaded development and debugging. We will also discuss some techniques for analyzing and improving the performance of parallel .NET code.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Questions</h1>
<ol>
<li value="1">Which concurrent collection can implement different types of collections under the covers?</li>
<li>What is the default internal collection type implemented by the collection in question 1?</li>
<li>Which collection type is frequently used as an implementation of the producer/consumer pattern?</li>
<li>Which concurrent collection contains key/value pairs?</li>
<li>Which method is used to add values to <strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong>?</li>
<li>Which methods are used to add and get items in <strong class="source-inline">ConcurrentDictionary</strong>?</li>
<li>Are extension methods used with the concurrent collections thread-safe?</li>
</ol>
</div>
</div>
</body></html>