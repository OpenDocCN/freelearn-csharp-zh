<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor182"/>11</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor183"/>Creating MVVM-Friendly Controls</h1>
<p>Up to this point, we’ve navigated through a wide spectrum of topics in MVVM and .NET MAUI – from the fundamental design pattern to data binding, navigation, and even working with remote data. Now, let’s dig into another important topic – <span class="No-Break"><strong class="bold">custom controls</strong></span><span class="No-Break">.</span></p>
<p>Sometimes, the built-in controls might fall short in catering to specific user interface requirements or unique design elements. As a consequence, you’ll need to create your own by combining individual UI elements into a single, more effective unit. Making these elements MVVM-friendly and reusable throughout your app is <span class="No-Break">our goal.</span></p>
<p>In this chapter, we’ll focus on <span class="No-Break">the following:</span></p>
<ul>
<li>Building a custom control with <span class="No-Break">bindable properties</span></li>
<li>Enabling interactions on <span class="No-Break">custom controls</span></li>
<li>Working with <span class="No-Break">control templates</span></li>
</ul>
<p>By the end of this chapter, you’ll know how to make custom controls that not only look good but are also easy to manage in an MVVM setup. Ready to <span class="No-Break">dive in?</span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor184"/>Technical requirements</h1>
<p>We’ll continue to enhance the <em class="italic">Recipes!</em> app by diving into custom controls and control templates, all designed with an MVVM architecture in mind. To follow along with the code, make sure to visit the GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11</a>. The <strong class="source-inline">Start</strong> folder has the initial code set up to begin this chapter, while the <strong class="source-inline">Finish</strong> folder contains the completed code for <span class="No-Break">your reference.</span></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor185"/>Building a custom control with bindable properties</h1>
<p>Building a feature-rich application often requires more than just the standard set of UI controls. When you have a<a id="_idIndexMarker746"/> combination of controls appearing together across multiple parts of your application – such as an input field with a list of validation errors or a button that’s always used with an activity indicator – it makes sense to package these into custom controls. These custom, reusable elements not only make the code base more maintainable but also align perfectly with MVVM architecture when <span class="No-Break">made bindable.</span></p>
<p>The focus of this section is not only to create custom controls but also to make them “bindable,” seamlessly integrating them into our MVVM architecture. By crafting controls that are bindable, you enable straightforward communication with your ViewModel. This is key to ensuring that the UI is always up to date with an application’s data <span class="No-Break">and logic.</span></p>
<p>So, how do we <span class="No-Break">achieve this?</span></p>
<p>Over the next few pages, we’ll see how to combine existing controls into a custom, bindable control. We’ll also discuss how to add custom properties and behavior to controls, ensuring they can effortlessly fit into an MVVM-based <span class="No-Break">application architecture.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">While we will be creating a custom control in XAML throughout this chapter, it’s important to note that everything we do can also be done entirely in code <span class="No-Break">if preferred.</span></p>
<p>As we dive into creating custom controls with data binding capabilities, it’s important to recall the concept of a binding target, which we covered in <a href="B20941_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Data Binding Building Blocks in .NET MAUI</em>. In .NET MAUI, a binding target is typically a <strong class="source-inline">BindableProperty</strong> on a UI element or another <strong class="source-inline">BindableObject</strong>. To make our custom controls serve as effective binding targets, they need to inherit from <strong class="source-inline">BindableObject</strong>. Additionally, any properties that we intend to bind must be of type <strong class="source-inline">BindableProperty</strong>. This ensures that our custom controls will integrate seamlessly into the MVVM <span class="No-Break">data-binding architecture.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor186"/>Implementing FavoriteControl</h2>
<p>In our <em class="italic">Recipes!</em> app, displaying <a id="_idIndexMarker747"/>whether a recipe is marked as a favorite or not is a recurring theme. The “favorite” icon appears across various parts of our app. Each time this icon appears, it behaves the same way – changing colors <a id="_idIndexMarker748"/>when the recipe is marked as a favorite. Instead of repeating the same code everywhere, we can encapsulate this pattern into a reusable <strong class="source-inline">FavoriteControl</strong>. By doing so, we make our code more maintainable and pave the way for future improvements – such as additional gestures or animations – without needing to alter multiple sections of the <span class="No-Break">code base.</span></p>
<p>Let’s go ahead and look at the steps needed to create <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong>, right-click the <strong class="source-inline">Controls</strong> folder in the <strong class="source-inline">Recipes.Mobile</strong> project and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Item…</strong></span><span class="No-Break">.</span></li>
<li>Select <strong class="bold">.NET MAUI ContentView (XAML)</strong> in the dialog window (<span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.1</em>) and enter <strong class="source-inline">FavoriteControl.xaml</strong> as the name of the new item. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 11.1: Select ContentView from the dialog" height="354" src="image/B20941_11_01.jpg" width="984"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: Select ContentView from the dialog</p>
<p>By following these steps, two new files will be created – <strong class="source-inline">FavoriteControl.xaml</strong> and its code-behind file, <strong class="source-inline">FavoriteControl.xaml.cs</strong>, as shown in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 11.2: Files making up FavoriteControl" height="111" src="image/B20941_11_02.jpg" width="422"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Files making up FavoriteControl</p>
<p>The generated <strong class="source-inline">FavoriteControl</strong> inherits the <strong class="source-inline">ContentView</strong> class, which itself is a descendant of <strong class="source-inline">BindableObject</strong>. This allows <strong class="source-inline">FavoriteControl</strong> to define <strong class="source-inline">BindableProperties</strong>, which is <a id="_idIndexMarker749"/>essential to make the control bindable. Speaking of which, <strong class="source-inline">FavoriteControl</strong> should contain a <strong class="source-inline">BindableProperty</strong> called <strong class="source-inline">IsFavoriteProperty</strong> and an <strong class="source-inline">IsFavorite</strong> property of type <strong class="source-inline">bool</strong>. The following code snippet shows what<a id="_idIndexMarker750"/> this <span class="No-Break">looks like:</span></p>
<pre class="source-code">
public static readonly BindableProperty IsFavoriteProperty
=
    BindableProperty.Create(nameof(IsFavorite),
        typeof(bool), typeof(FavoriteControl));
public bool IsFavorite
{
    get { return (bool)GetValue(IsFavoriteProperty); }
    set { SetValue(IsFavoriteProperty, value); }
}</pre> <p>Defining a <strong class="source-inline">BindableProperty</strong> can be confusing or unclear at first. If this concept is still vague, <a href="B20941_03.xhtml#_idTextAnchor051"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Data Binding Building Blocks in .NET MAUI</em>, covers it in <span class="No-Break">more depth.</span></p>
<p>With this in place, we can dive into XAML and start working on the visual layer of <span class="No-Break">this </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Data binding in a custom control</p>
<p class="callout">When building a custom control, it’s recommended to<a id="_idIndexMarker751"/> design it so that it doesn’t depend on its <strong class="source-inline">BindingContext</strong>, which it inherits from its parent page or control. Instead of depending on its <strong class="source-inline">BindingContext</strong>, the custom control should be self-contained and interact directly with its own bindable properties. This approach makes your control more modular and reusable, freeing it from dependencies on any specific ViewModel or data source. Element binding or relative binding is instrumental in achieving this independence. However, it’s worth noting that using data binding within the control is not mandatory. Handling all the logic and value assignments programmatically in the control’s code-behind is also a solid approach. This mostly depends on <span class="No-Break">personal preference.</span></p>
<p>Let’s have a look at<a id="_idIndexMarker752"/> how to define the control’s appearance<a id="_idIndexMarker753"/> and see how we can efficiently bind to its <span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break"> property:</span></p>
<ol>
<li>Open the <strong class="source-inline">FavoriteControl.xaml</strong> file, and add the following <strong class="source-inline">local</strong> and <strong class="source-inline">toolkit</strong> XML namespaces and the <span class="No-Break"><strong class="source-inline">x:Name</strong></span><span class="No-Break"> attribute:</span><pre class="source-code">
&lt;ContentView
    x:Class="Recipes.Mobile.Controls.FavoriteControl"
    xmlns="http://schemas.microsoft.com/dotnet/
      2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/
      2009/xaml"
    <strong class="bold">xmlns:local="clr-namespace:</strong>
<strong class="bold">      Recipes.Mobile.Controls"</strong>
<strong class="bold">    xmlns:toolkit="http://schemas.microsoft.com/</strong>
<strong class="bold">      dotnet/2022/maui/toolkit"</strong>
<strong class="bold">    x:Name="root"</strong>&gt;</pre></li> <li>With the <strong class="source-inline">toolkit</strong> namespace in place, which refers to the .NET MAUI Community Toolkit, we can add an instance of <strong class="source-inline">BoolToObjectConverter</strong> to the control’s <strong class="source-inline">Resources</strong>. This converter can be copied over from <strong class="source-inline">RecipesOverviewPage</strong> or <strong class="source-inline">RecipeDetailPage</strong>. The next code block shows what it <span class="No-Break">looks like:</span><pre class="source-code">
&lt;ContentView.Resources&gt;
    &lt;toolkit:BoolToObjectConverter
        x:Key="isFavoriteToColorConverter"
        x:TypeArguments="Color"
        FalseObject="#E9E9E9E9"
        TrueObject="#FF0000" /&gt;
&lt;/ContentView.Resources&gt;</pre><p class="list-inset">As a reminder, this converter (as it is configured here) will convert a <strong class="source-inline">bool</strong> value into a color – <strong class="source-inline">false</strong> will become a color with the hex value of <strong class="source-inline">"#E9E9E9E9"</strong> while <strong class="source-inline">true</strong> will be converted <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"#FF0000"</strong></span><span class="No-Break">.</span></p></li> <li>Next, we can add the <strong class="source-inline">Image</strong> control to display the <strong class="source-inline">"favorite.png"</strong> icon. We also want this Image control to <a id="_idIndexMarker754"/>match the dimensions <a id="_idIndexMarker755"/>specified for <strong class="source-inline">FavoriteControl</strong>. Here’s how to set <span class="No-Break">this up:</span><pre class="source-code">
&lt;Image
    x:Name="icon"
    HeightRequest="{Binding HeightRequest,
      Source={RelativeSource AncestorType={x:Type
        local:FavoriteControl}}}"
    Source="favorite.png"
    WidthRequest="{Binding WidthRequest, Source=
      {RelativeSource AncestorType={x:Type
        local:FavoriteControl}}}"&gt;</pre><p class="list-inset">In this code snippet, we’re using relative binding to connect the <strong class="source-inline">HeightRequest</strong> and <strong class="source-inline">WidthRequest</strong> properties of the <strong class="source-inline">Image</strong> control to those of <strong class="source-inline">FavoriteControl</strong>. By doing so, we ensure that the image scales according to the dimensions defined <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">.</span></p></li> <li>Finally, to control the tint of the <strong class="source-inline">Image</strong>, depending on the favorite status, we use <strong class="source-inline">IconTintColorBehavior</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;Image.Behaviors&gt;
    &lt;toolkit:IconTintColorBehavior
        TintColor="{Binding IsFavorite,
        Source={x:Reference root},
        Converter={StaticResource
        isFavoriteToColorConverter}}" /&gt;
 &lt;/Image.Behaviors&gt;</pre><p class="list-inset">This setup closely <a id="_idIndexMarker756"/>mirrors what we used on <strong class="source-inline">RecipesOverviewPage</strong> and <strong class="source-inline">RecipeDetailPage</strong>. The key difference lies in the source of the binding. Here, we bind directly to the <strong class="source-inline">IsFavorite</strong> property we just created. We achieve this using element binding (via <strong class="source-inline">x:Reference root</strong>), which refers back to <strong class="source-inline">FavoriteControl</strong> itself. This is necessary because relative binding isn’t suitable here. Behaviors, unlike other UI elements, are not part of the visual tree, so they can’t perform <a id="_idIndexMarker757"/>relative binding or find ancestors in the same way that other <span class="No-Break">elements can.</span></p></li> </ol>
<p>With these steps completed, we’ve successfully created our first custom control, <strong class="source-inline">FavoriteControl</strong>. Now, we can go ahead and replace the existing image and <strong class="source-inline">IconTintColorBehavior</strong> setup, used to indicate favorite recipes on both <strong class="source-inline">RecipesOverviewPage</strong> and <strong class="source-inline">RecipeDetailPage</strong>, with this custom control. Let’s do this in the <span class="No-Break">following steps:</span></p>
<ol>
<li>Go to <strong class="source-inline">RecipesOverviewPage</strong> and add an <strong class="source-inline">xml</strong> namespace, referring to the namespace containing the newly created <strong class="source-inline">FavoriteControl</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
</pre></li> <li>The XML namespace (<strong class="source-inline">xmlns:toolkit</strong>) pointing to the .NET MAUI Community Toolkit can be removed, as we won’t be using any of its functionalities anymore on this page. This is now encapsulated in our <span class="No-Break">custom control.</span></li>
<li>Remove the <strong class="source-inline">Image</strong> UI element along with its associated behavior, which until now served as the<a id="_idIndexMarker758"/> favorite indicator for <span class="No-Break">a recipe.</span></li>
<li>In place of the deleted <strong class="source-inline">Image</strong>, insert the <strong class="source-inline">FavoriteControl</strong> we just created. Here’s how to <span class="No-Break">do it:</span><pre class="source-code">
&lt;controls:FavoriteControl
    Margin="5"
    HeightRequest="45"
    HorizontalOptions="End"
    <strong class="bold">IsFavorite="{Binding IsFavorite}"</strong>
    IsVisible="{Binding IsFavorite}"
    VerticalOptions="Start"
    WidthRequest="45" /&gt;</pre><p class="list-inset">The layout properties <a id="_idIndexMarker759"/>such as margin, size, visibility, and alignment options are unchanged from the removed <strong class="source-inline">Image</strong>. Also, observe how easily we can bind the <strong class="source-inline">IsFavorite</strong> property of our <strong class="source-inline">FavoriteControl</strong> to the corresponding <strong class="source-inline">IsFavorite</strong> property on the <span class="No-Break">page’s </span><span class="No-Break"><strong class="source-inline">BindingContext</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>For <strong class="source-inline">RecipeDetailPage</strong>, we can follow a similar approach. Include an XML namespace that points to <strong class="source-inline">Recipes.Mobile.Controls</strong> and swap out the <strong class="source-inline">Image</strong>, which previously signaled whether the recipe was a favorite, with the newly created <strong class="source-inline">FavoriteControl</strong>. This is what the result <span class="No-Break">looks like:</span></p>
<pre class="source-code">
&lt;ContentPage
    x:Class="Recipes.Mobile.RecipeDetailPage"
    
    
    <strong class="bold"/>
    ...&gt;
...
    &lt;Grid ColumnDefinitions="*, Auto"&gt;
        &lt;Label FontAttributes="Bold" FontSize="22"
            Text="{Binding Path=Title, Mode=OneWay}"
            VerticalOptions="Center" /&gt;
        <strong class="bold">&lt;controls:FavoriteControl Grid.Column="1"</strong>
<strong class="bold">            Margin="5" HeightRequest="35"</strong>
<strong class="bold">            IsFavorite="{Binding IsFavorite}"</strong>
<strong class="bold">            VerticalOptions="Center" WidthRequest="35" /&gt;</strong>
    &lt;/Grid&gt;
...
&lt;/ContentPage&gt;</pre> <p>By consolidating the favorite indicator into a single, reusable <strong class="source-inline">FavoriteControl</strong>, we’ve achieved multiple <a id="_idIndexMarker760"/>objectives. Firstly, we’ve centralized the code, making it easier to manage and update. Secondly, this control can now be <a id="_idIndexMarker761"/>used consistently across different pages of the app, ensuring a uniform user experience. Finally, by doing so, we’ve also enhanced the readability and maintainability of our code base. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.3</em> shows <strong class="source-inline">FavoriteControl</strong> on different pages of the app. Although nothing has visibly changed for the user, the code and its maintainability profit immensely from this <span class="No-Break">reusable control.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 11.3: FavoriteControl on different pages" height="486" src="image/B20941_11_03.jpg" width="1637"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: FavoriteControl on different pages</p>
<p>Let’s see how we<a id="_idIndexMarker762"/> can improve this control a <a id="_idIndexMarker763"/>bit more, making the app more attractive to <span class="No-Break">the user.</span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor187"/>Animating state changes</h2>
<p>As a quick example of reacting to state <a id="_idIndexMarker764"/>changes, let’s explore<a id="_idIndexMarker765"/> how to add a subtle animation to <strong class="source-inline">FavoriteControl</strong> whenever the <strong class="source-inline">IsFavorite</strong> property changes. We’ll use the <strong class="source-inline">propertyChanged </strong> delegate method of <strong class="source-inline">IsFavoriteProperty</strong> to trigger this animation. Let’s <span class="No-Break">dive in!</span></p>
<ol>
<li>Modify <strong class="source-inline">IsFavoriteProperty</strong> by adding a <strong class="source-inline">propertyChanged</strong> delegate, <span class="No-Break">like this:</span><pre class="source-code">
public static readonly BindableProperty
  IsFavoriteProperty =
        BindableProperty.Create(nameof(IsFavorite),
        typeof(bool),
        typeof(FavoriteControl),
        <strong class="bold">propertyChanged: OnIsFavoriteChanged</strong>);
private static void OnIsFavoriteChanged(BindableObject
  bindable, object oldValue, object newValue)
{
}</pre><p class="list-inset">With this modification, the static <strong class="source-inline">OnIsFavoriteChanged</strong> method will be invoked each time the value of the <strong class="source-inline">IsFavorite</strong> property changes. The <strong class="source-inline">BindableObject</strong> that gets passed in is the instance on which <strong class="source-inline">BindableProperty</strong> is set. In this case, it will be an instance of <strong class="source-inline">FavoriteControl</strong>. The <strong class="source-inline">oldValue</strong> and <strong class="source-inline">newValue</strong> parameters are self-explanatory, as they provide the <a id="_idIndexMarker766"/>previous and new values of the <span class="No-Break">property, respectively.</span></p></li> <li>Next, let’s add the animation we want to play when the control’s state changes. Here’s how we <a id="_idIndexMarker767"/>can <span class="No-Break">add it:</span><pre class="source-code">
private async Task AnimateChange()
{
    await icon.ScaleTo(1.5, 100);
    await icon.ScaleTo(1, 100);
}</pre><p class="list-inset">The <strong class="source-inline">AnimateChange</strong> method will scale the <strong class="source-inline">Image</strong> holding the icon to 1.5 times its size over a period of 100 milliseconds. Afterward, it will be scaled down again to its original size over the same amount <span class="No-Break">of time.</span></p></li> <li>Finally, we need to call this method from the static <strong class="source-inline">OnIsFavoriteChanged</strong> method. The following code block shows how this can <span class="No-Break">be done:</span><pre class="source-code">
private static void OnIsFavoriteChanged(
    BindableObject bindable,
    object oldValue, object newValue)
    =&gt; (bindable as FavoriteControl).AnimateChange();</pre><p class="list-inset">The bindable parameter can safely be cast to <strong class="source-inline">FavoriteControl</strong>, allowing us to call the <strong class="source-inline">AnimateChange</strong> method, triggering <span class="No-Break">the animation.</span></p></li> </ol>
<p>Run the app to see the changes in action! You’ll observe a subtle animation on the <strong class="source-inline">RecipeDetailPage</strong> each time a recipe is toggled as a favorite. Introducing this custom control brings the convenience of unified animations across the application. Any modification made to the animation within the custom control gets automatically reflected everywhere it’s used. Without such a control, we’d need to manually update the animation at each individual instance<a id="_idIndexMarker768"/> throughout the app. Overlooking even a single instance would lead to inconsistent behavior. Thus, custom controls ensure both consistency and <span class="No-Break">streamlined </span><span class="No-Break"><a id="_idIndexMarker769"/></span><span class="No-Break">maintainability.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">This example underscores an important point – even when you’re fully committed to using the MVVM pattern, there will be scenarios where writing code in the code-behind is not just acceptable but necessary. This is especially true when creating custom controls, where using code-behind is not only inevitable but also <span class="No-Break">perfectly appropriate.</span></p>
<p>Next, let’s explore how to add interactions to a custom control by leveraging commanding, thereby further aligning it with <span class="No-Break">MVVM concepts.</span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor188"/>Enabling interactions on custom controls</h1>
<p>In real-world applications, controls often<a id="_idIndexMarker770"/> serve dual roles – they both display data and allow users to interact with it. In this section, we’ll further enhance our <strong class="source-inline">FavoriteControl</strong> to not only support user interactions through <strong class="source-inline">IsFavoriteChangedCommand</strong> but also to facilitate two-way data binding. These features will make the control more interactive and further align it with MVVM concepts. We want to allow users to tap the <strong class="source-inline">Image</strong> on the <strong class="source-inline">FavoriteControl</strong>. When <strong class="source-inline">FavoriteControl</strong>’s <strong class="source-inline">IsEnabled</strong> property is set to <strong class="source-inline">true</strong>, the <strong class="source-inline">IsFavorite</strong> property will be updated and <strong class="source-inline">IsFavoriteChangedCommand</strong> will <span class="No-Break">be executed.</span></p>
<p>Let’s take a look at the first part of this functionality – updating the <strong class="source-inline">IsFavorite</strong> property when a user taps on the image and making sure the value bound to this property gets updated <span class="No-Break">as well.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor189"/>User actions and reflecting state</h2>
<p>To start with, let’s add the ability for users to toggle their favorite state by tapping on the control. This user action will then update the <strong class="source-inline">IsFavorite</strong> property of the control, which, in turn, will reflect back to <a id="_idIndexMarker771"/>update the bound property. The<a id="_idIndexMarker772"/> following steps show how to <span class="No-Break">achieve this:</span></p>
<ol>
<li>Add a <strong class="source-inline">GestureRecognizer</strong> to the <strong class="source-inline">FavoriteControl</strong>’s <strong class="source-inline">ContentView</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;ContentView.GestureRecognizers&gt;
    &lt;TapGestureRecognizer
        Tapped="TapGestureRecognizer_Tapped" /&gt;
&lt;/ContentView.GestureRecognizers&gt;</pre><p class="list-inset">A <strong class="source-inline">GestureRecognizer</strong> allows you to handle user interaction events, such as tapping, pinching, and swiping, on a UI element. By adding a <strong class="source-inline">TapGestureRecognizer</strong> to the <strong class="source-inline">ContentView</strong>, we effectively instruct the application to listen for a tap event on <span class="No-Break">this control.</span></p><p class="list-inset">Here’s the <strong class="source-inline">TapGestureRecognizer_Tapped</strong> event handler in <span class="No-Break">the code-behind:</span></p><pre class="source-code">private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
}</pre><p class="list-inset">This method will be triggered when a user taps on <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">.</span></p></li> <li>Now, let’s implement the logic needed to update the <strong class="source-inline">IsFavorite</strong> property in the <span class="No-Break"><strong class="source-inline">TapGestureRecognizer_Tapped</strong></span><span class="No-Break"> method:</span><pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    if (IsEnabled)
    {
        IsFavorite = !IsFavorite;
    }
}</pre><p class="list-inset">Note how we first check the <strong class="source-inline">IsEnabled</strong> property before updating the <strong class="source-inline">IsFavorite</strong>. It’s crucial for custom controls to behave consistently with developers’ expectations. In this case, setting the <strong class="source-inline">IsEnabled</strong> property of a <strong class="source-inline">VisualElement</strong> to <strong class="source-inline">false</strong> should disable the control. As a result, we check the <strong class="source-inline">IsEnabled</strong> property before toggling the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">IsFavorite</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>If we run the app and navigate to <strong class="source-inline">RecipeDetailPage</strong> at this point, tapping <strong class="source-inline">FavoriteControl</strong> should update its state. The<a id="_idIndexMarker773"/> animation we defined earlier also plays as a reaction to the <strong class="source-inline">IsFavorite</strong> property being updated. However, the state change is not reflected on the<a id="_idIndexMarker774"/> ViewModel. You might wonder why this is the case. It’s because <strong class="source-inline">IsFavoriteProperty</strong> has a default binding mode of <strong class="source-inline">OneWay</strong>. That’s why the updated value doesn’t flow from the control back to the ViewModel. This can easily be adjusted – change the <strong class="source-inline">IsFavoriteProperty</strong>’s default binding mode to <strong class="source-inline">TwoWay</strong>, or update the binding statement on the <strong class="source-inline">RecipeDetailPage</strong> and explicitly set it to <strong class="source-inline">TwoWay</strong>. Here’s what the first approach – updating the default binding mode – <span class="No-Break">looks like:</span></p>
<pre class="source-code">
public static readonly BindableProperty
IsFavoriteProperty =
    BindableProperty.Create(nameof(IsFavorite),
        typeof(bool),
        typeof(FavoriteControl),
        <strong class="bold">defaultBindingMode: BindingMode.TwoWay</strong>,
        propertyChanged: OnIsFavoriteChanged);</pre> <p>Alternatively, we can leave the default binding mode to <strong class="source-inline">OneWay</strong> and update the binding statement on <strong class="source-inline">RecipeDetailPage</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
&lt;controls:FavoriteControl
    Grid.Column="1"
    Margin="5"
    HeightRequest="35"
    <strong class="bold">IsFavorite="{Binding IsFavorite, Mode=TwoWay}"</strong>
    VerticalOptions="Center"
    WidthRequest="35" /&gt;</pre> <p>Either way, the <strong class="source-inline">IsFavorite</strong> property on the <strong class="source-inline">FavoriteControl</strong> will now reflect its state on the ViewModel. How can we<a id="_idIndexMarker775"/> verify this? By adding breakpoints in code of course, but also by simply<a id="_idIndexMarker776"/> tapping the control – note how the visibility of the <strong class="bold">Add as favorite </strong>and <strong class="bold">Remove as favorite</strong> buttons also update, as their visibility depends on the <strong class="source-inline">IsFavorite</strong> property on <span class="No-Break">the ViewModel.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">When defining a bindable property, it’s crucial to select the <strong class="source-inline">defaultBindingMode</strong> that aligns best with the control’s primary intended behavior or the binding mode that will be most commonly used. In the rare instances where different behavior is required, the developer can always override the default by specifying a different binding mode in the <span class="No-Break">binding statement.</span></p>
<p><strong class="bold">Two-way data binding</strong> is a powerful<a id="_idIndexMarker777"/> feature that allows your custom control to interact with the underlying data. While this brings your control to life, adding support for command-based interactions allows developers to tie more meaningful, custom behavior to your control. This is particularly useful in scenarios where simply updating a data property may not be sufficient to capture the complexity of a user interaction. Specifically, in our scenario, simply updating the <strong class="source-inline">IsFavorite</strong> property won’t result in the underlying model being updated. Let’s delve into how we can incorporate commands into our <strong class="source-inline">FavoriteControl</strong> to make it even <span class="No-Break">more versatile.</span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor190"/>Adding command-based interactions</h2>
<p>Let’s further enhance our <strong class="source-inline">FavoriteControl</strong> by exposing a command property – <strong class="source-inline">ToggledCommand</strong>. This <a id="_idIndexMarker778"/>command will be invoked whenever the <strong class="source-inline">IsFavorite</strong> property is toggled via a tap gesture on the control. To <a id="_idIndexMarker779"/>make this even more robust, the command will send the updated <strong class="source-inline">IsFavorite</strong> bool value as <span class="No-Break">a parameter.</span></p>
<p>Adding command-based interactions to custom controls is pretty straightforward, as the following <span class="No-Break">steps show:</span></p>
<ol>
<li>It all starts by adding a <strong class="source-inline">BindableProperty</strong> and a property of type <strong class="source-inline">ICommand</strong>. This code block shows how to add the <strong class="source-inline">ToggledCommand</strong> property and its corresponding <strong class="source-inline">BindableProperty</strong> to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span><pre class="source-code">
public static readonly BindableProperty
  ToggledCommandProperty =
    BindableProperty.Create(
        nameof(ToggledCommand),
        typeof(ICommand), typeof(FavoriteControl));
public ICommand ToggledCommand
{
    get =&gt; (ICommand)
        GetValue(ToggledCommandProperty);
    set =&gt; SetValue(ToggledCommandProperty, value);
}</pre></li> <li>Next, we can call the command’s <strong class="source-inline">Execute</strong> method whenever the user has tapped the<a id="_idIndexMarker780"/> control and, thus, has updated the <strong class="source-inline">IsFavorite</strong> property. Here’s what the<a id="_idIndexMarker781"/> updated <strong class="source-inline">TapGestureRecognizer_Tapped</strong> method <span class="No-Break">looks like:</span><pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    if (IsEnabled)
    {
        IsFavorite = !IsFavorite;
        <strong class="bold">ToggledCommand?.Execute(IsFavorite);</strong>
    }
}</pre><p class="list-inset">Note that we’re using the null-conditional operator (<strong class="source-inline">?</strong>) to prevent a <strong class="source-inline">NullReferenceException</strong> in case <strong class="source-inline">ToggledCommand</strong> <span class="No-Break">is null.</span></p></li> <li>The following code block shows the <strong class="source-inline">FavoriteToggledCommand</strong> that we can add to the <strong class="source-inline">RecipeDetailViewModel</strong>, and which we will bind to the <strong class="source-inline">ToggledCommand</strong> of <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span><pre class="source-code">
...
public IRelayCommand FavoriteToggledCommand { get; }
...
public RecipeDetailViewModel(...)
{
    ...
    FavoriteToggledCommand =
        new AsyncRelayCommand&lt;bool&gt;(FavoriteToggled);
    ...
}
...</pre></li> <li>Next, let’s add the <strong class="source-inline">FavoriteToggled</strong> method, which is called by <strong class="source-inline">FavoriteToggledCommand</strong>. Here’s<a id="_idIndexMarker782"/> what it <span class="No-Break">looks like:</span><pre class="source-code">
private async Task FavoriteToggled(bool isFavorite)
{
    if(isFavorite)
    {
        await favoritesService.Add(recipeDto.Id);
    }
    else
    {
        await favoritesService.Remove(recipeDto.Id);
    }
}</pre><p class="list-inset">The <strong class="source-inline">ToggledCommand</strong> of the <strong class="source-inline">FavoriteControl</strong> sends the updated <strong class="source-inline">isFavorite</strong> value as<a id="_idIndexMarker783"/> a parameter. We can use this parameter to decide what method to call on <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">favoritesService</strong></span><span class="No-Break">.</span></p></li> <li>With this in place, we can also quickly refactor the existing <strong class="source-inline">AddAsFavorite</strong> and <strong class="source-inline">RemoveAsFavorite</strong> methods in order to avoid code duplication, as <span class="No-Break">shown here:</span><pre class="source-code">
private Task AddAsFavorite()
    =&gt; UpdateIsFavorite(true);
private Task RemoveAsFavorite()
    =&gt; UpdateIsFavorite(false);
private Task UpdateIsFavorite(bool newValue)
{
    IsFavorite = newValue;
    return FavoriteToggled(newValue);
}</pre><p class="list-inset">The <strong class="source-inline">UpdateIsFavorite</strong> method is added. This method takes in the new value that the <strong class="source-inline">IsFavorite</strong> property <a id="_idIndexMarker784"/>should get. It assigns this value to the property and calls the <strong class="source-inline">FavoriteToggled</strong> method that we just introduced. From the <strong class="source-inline">AddAsFavorite</strong> and <strong class="source-inline">RemoveAsFavorite</strong> methods, this new <strong class="source-inline">UpdateIsFavorite</strong> method can now be called, passing in just a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value.</span></p></li> <li>The only thing that is left to<a id="_idIndexMarker785"/> do is to bind <strong class="source-inline">FavoriteToggledCommand</strong> of <strong class="source-inline">RecipeDetailViewModel</strong> to the <strong class="source-inline">ToggledCommand</strong> property of the <strong class="source-inline">FavoriteControl</strong> on the <strong class="source-inline">RecipeDetailPage</strong>. <span class="No-Break">Here’s how:</span><pre class="source-code">
&lt;controls:FavoriteControl
    Grid.Column="1"
    Margin="5"
    HeightRequest="35"
    IsFavorite="{Binding IsFavorite, Mode=TwoWay}"
    <strong class="bold">ToggledCommand="{Binding FavoriteToggledCommand}"</strong>
    VerticalOptions="Center"
    WidthRequest="150" /&gt;</pre></li> </ol>
<p>If we run the app now, we’ll see that not only does the <strong class="source-inline">IsFavorite</strong> property updates when the <strong class="source-inline">FavoriteControl</strong> is tapped <a id="_idIndexMarker786"/>but the bound <strong class="source-inline">FavoriteToggledCommand</strong> is also invoked, allowing for seamless interaction and data updates in our application. This completes the integration of a<a id="_idIndexMarker787"/> very basic command-based interaction into our custom control. Let’s continue and make the control better and more intuitive for both the users of our app and <span class="No-Break">other developers.</span></p>
<h3>Improving developer and user experience</h3>
<p>While the previous example provided a foundational understanding of how to integrate command-based interactions into<a id="_idIndexMarker788"/> our custom control, it merely scratched the surface. Developers aiming to integrate this control across diverse use cases and the end-users who will interact with it both anticipate a solution that’s more polished and adaptable. For instance, we could enhance the user experience by providing visual cues that indicate the control is clickable. On the developer side, we want our control to be predictable; developers expect things to work in a certain way. Ideally, our control should adhere to the bound command’s <strong class="source-inline">CanExecute</strong> method and adjust its behavior accordingly. In my experience, poorly designed or inadequately thought-through controls have often created headaches for both myself and my colleagues. The goal is to make a custom control intuitive enough that it doesn’t require extensive explanation for straightforward tasks. Let’s see how we can bring our <strong class="source-inline">FavoriteControl</strong> to <span class="No-Break">another level!</span></p>
<p>Let’s first introduce a new property called <strong class="source-inline">IsInteractive</strong> to <strong class="source-inline">FavoriteControl</strong>. This property will be set to <strong class="source-inline">true</strong> when the <strong class="source-inline">IsEnabled</strong> property of the control is set to <strong class="source-inline">true</strong>, the <strong class="source-inline">ToggleCommand</strong> is set, and its <strong class="source-inline">CanExecute</strong> method returns <strong class="source-inline">true</strong>. In all other situations, the value of the <strong class="source-inline">IsInteractive</strong> property needs to be <strong class="source-inline">false</strong>. This property can then be checked inside the control prior to executing an action. Let’s go through this step <span class="No-Break">by step:</span></p>
<ol>
<li>Add the <strong class="source-inline">IsInteractive</strong> property to <strong class="source-inline">FavoriteControl</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
public bool IsInteractive { get; private set; }</pre></li> <li>The following code snippet shows the <strong class="source-inline">UpdateIsInteractive</strong> method. This method is responsible for setting the <span class="No-Break"><strong class="source-inline">IsInteractive</strong></span><span class="No-Break"> property:</span><pre class="source-code">
private void UpdateIsInteractive()
    =&gt; IsInteractive = IsEnabled
    &amp;&amp; (ToggledCommand?.CanExecute(IsFavorite)
    ?? false);</pre></li> <li>Update the <strong class="source-inline">TapGestureRecognizer_Tapped</strong> method, as shown in the next <span class="No-Break">code </span><span class="No-Break"><a id="_idIndexMarker789"/></span><span class="No-Break">block:</span><pre class="source-code">
private void TapGestureRecognizer_Tapped(
    object sender, TappedEventArgs e)
{
    <strong class="bold">if (IsInteractive)</strong>
    {
        IsFavorite = !IsFavorite;
        ToggledCommand?.Execute(IsFavorite);
    }
}</pre><p class="list-inset">By updating the code that is shown here, we only allow the <strong class="source-inline">IsFavorite</strong> property to be toggled when the <strong class="source-inline">IsInteractive</strong> property is set to <strong class="source-inline">true</strong>. This means the control is enabled, its <strong class="source-inline">ToggleCommand</strong> is set, and the <strong class="source-inline">ToggleCommand</strong>’s <strong class="source-inline">CanExecute</strong> method <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>Next, we need to make sure that the <strong class="source-inline">UpdateIsInteractive</strong> method is called when its value needs updating. That’s the case in the following <span class="No-Break">three situations:</span></p>
<ul>
<li>When the value of the <strong class="source-inline">IsEnabled</strong> <span class="No-Break">property changes</span></li>
<li>When the <strong class="source-inline">ToggleCommand</strong> property <span class="No-Break">is updated</span></li>
<li>When the <strong class="source-inline">CanExecuteChanged</strong> event of the command <span class="No-Break">is triggered</span></li>
</ul>
<p>In the following steps, we’ll put everything in place so that the <strong class="source-inline">UpdateIsInteractive</strong> method is called in the <span class="No-Break">aforementioned situations:</span></p>
<ol>
<li>In the <strong class="source-inline">FavoriteControl</strong> class, override the <strong class="source-inline">OnPropertyChanged</strong> method. This method gets called by the control’s properties in order to trigger the <strong class="source-inline">PropertyChanged</strong> event, just like we typically have in our ViewModels. Let’s see what <a id="_idIndexMarker790"/>we can do <span class="No-Break">with it:</span><pre class="source-code">
protected override void OnPropertyChanged(
    [CallerMemberName] string propertyName = null)
{
    base.OnPropertyChanged(propertyName);
    <strong class="bold">if(propertyName == nameof(IsEnabled))</strong>
<strong class="bold">    {</strong>
<strong class="bold">        UpdateIsInteractive();</strong>
<strong class="bold">    }</strong>
}</pre><p class="list-inset">Whenever the passed-in <strong class="source-inline">propertyName</strong> matches the <strong class="source-inline">IsEnabled</strong> property, we want to trigger the <strong class="source-inline">UpdateIsInteractive</strong> method. This ensures that whenever the <strong class="source-inline">IsEnabled</strong> property is updated, the <strong class="source-inline">IsInteractive</strong> property <span class="No-Break">gets re-evaluated.</span></p></li> <li>Next, we move on to make sure that the <strong class="source-inline">IsInteractive</strong> property gets updated when <strong class="source-inline">ToggledCommand</strong> is updated. Let’s start by adding a <strong class="source-inline">propertyChanged</strong> delegate to <strong class="source-inline">ToggledCommandProperty</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
public static readonly BindableProperty
  ToggledCommandProperty =
    BindableProperty.Create(nameof(ToggledCommand),
        typeof(ICommand), typeof(FavoriteControl),
        <strong class="bold">propertyChanged: ToggledCommandChanged</strong>);
private static void ToggledCommandChanged(
    BindableObject bindable,
    object oldValue, object newValue)
{
    var control = bindable as FavoriteControl;
    control.UpdateIsInteractive();
}</pre><p class="list-inset">The <strong class="source-inline">ToggledCommandChanged</strong> method is called when the value of the command is updated. This is the<a id="_idIndexMarker791"/> ideal place to call the <strong class="source-inline">UpdateIsInteractive</strong> method so that the <strong class="source-inline">IsInteractive</strong> property gets updated, based on the <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">ToggledCommand</strong></span><span class="No-Break">.</span></p></li> <li>Finally, our <strong class="source-inline">IsInteractive</strong> property isn’t solely reliant on the <strong class="source-inline">IsEnabled</strong> property and the presence of the <strong class="source-inline">ToggledCommand</strong>. It also takes into account the <strong class="source-inline">CanExecute</strong> method of the defined command. To achieve this, we need to listen for changes in the command’s <strong class="source-inline">CanExecute</strong> state by subscribing to its <strong class="source-inline">CanExecuteChanged</strong> event. Here’s how we can update the <strong class="source-inline">ToggleCommandChanged</strong> method for <span class="No-Break">that purpose:</span><pre class="source-code">
private static void ToggledCommandChanged(
    BindableObject bindable,
    object oldValue, object newValue)
{
    var control = bindable as FavoriteControl;
    <strong class="bold">if (oldValue is ICommand oldCommand)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        oldCommand.CanExecuteChanged -=</strong>
<strong class="bold">            control.CanExecuteChanged;</strong>
<strong class="bold">    }</strong>
    <strong class="bold">if (newValue is ICommand newCommand)</strong>
<strong class="bold">    {</strong>
<strong class="bold">        newCommand.CanExecuteChanged +=</strong>
<strong class="bold">            control.CanExecuteChanged;</strong>
<strong class="bold">    }</strong>
    control.UpdateIsInteractive();
}</pre><p class="list-inset">After setting the new command, we’re not just subscribing to its <strong class="source-inline">CanExecuteChanged</strong> event; we’re also making sure to unsubscribe from the same event on the previous command. This is crucial to ensure that our control only reacts to the current <a id="_idIndexMarker792"/>command’s <strong class="source-inline">CanExecute</strong> state. The <strong class="source-inline">CanExecuteChanged</strong> event handler merely calls the <strong class="source-inline">UpdateIsInteractive</strong> method, as <span class="No-Break">shown here:</span></p><pre class="source-code">private void CanExecuteChanged(
    object sender, EventArgs e)
    =&gt; UpdateIsInteractive();</pre></li> </ol>
<p>In summary, the <strong class="source-inline">IsInteractive</strong> property serves as the gateway for user interactions with the control. Its state is determined by a combination of factors – the <strong class="source-inline">IsEnabled</strong> property of the control, the presence of a command, and that command’s <strong class="source-inline">CanExecute</strong> method. Importantly, the <strong class="source-inline">IsInteractive</strong> state is dynamically re-evaluated every time any of these contributing <span class="No-Break">factors change.</span></p>
<p>Let’s see this in action! For <a id="_idIndexMarker793"/>demo purposes, let’s add a maximum number of times the favorite state of a recipe can be toggled via <strong class="source-inline">FavoriteControl</strong>. The <strong class="source-inline">canExecute</strong> delegate of the <strong class="source-inline">FavoriteToggledCommand</strong> on the <strong class="source-inline">RecipeDetailViewModel</strong> should return <strong class="source-inline">true</strong> as long as this number is not exceeded. Let’s see how we can <span class="No-Break">implement this:</span></p>
<ol>
<li>Let’s start by adding the following two fields <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">RecipeDetailViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
int updateCount = 0;
int maxUpdatedAllowed = 5;</pre></li> <li>Next, update the <strong class="source-inline">FavoriteToggledCommand</strong> so that it includes the <strong class="source-inline">canExecute</strong> predicate, as <span class="No-Break">shown here:</span><pre class="source-code">
FavoriteToggledCommand = new AsyncRelayCommand&lt;bool&gt;(
    FavoriteToggled,
    <strong class="bold">(e) =&gt; updateCount &lt; maxUpdatedAllowed</strong>);</pre></li> <li>Finally, update the <strong class="source-inline">FavoriteToggled</strong> method so that it keeps track of the number of times it was invoked, as <span class="No-Break">shown here:</span><pre class="source-code">
private async Task FavoriteToggled(bool isFavorite)
{
    ...
    updateCount++;
    FavoriteToggledCommand.NotifyCanExecuteChanged();
}</pre><p class="list-inset">Not only does this method now keep track of the number of times it was invoked, but it also triggers the <strong class="source-inline">NotifyCanExecuteChanged</strong> event of the <strong class="source-inline">FavoriteToggledCommand</strong>. As a result, the <strong class="source-inline">CanExecuteChanged</strong> method on <strong class="source-inline">FavoriteControl</strong> will get called, which will eventually call the command’s <strong class="source-inline">CanExecute</strong> method to see whether it still can <span class="No-Break">be executed.</span></p></li> </ol>
<p>With this in place, we can run the app and see how the <strong class="source-inline">FavoriteControl</strong> reacts to the <strong class="source-inline">ToggleCommand</strong>’s <strong class="source-inline">CanExecute</strong> method. Go to the detail page of a recipe and press the <strong class="source-inline">FavoriteControl</strong> a couple of times. You’ll <a id="_idIndexMarker794"/>notice the favorite state will be updated until you’ve clicked five times. After that, the <strong class="source-inline">ToggleCommand</strong>’s <strong class="source-inline">CanExecute</strong> method returns <strong class="source-inline">false</strong>, resulting in <strong class="source-inline">IsInteractive</strong> being set to <strong class="source-inline">false</strong> as well. Any following interactions with the control will be ignored because of this. Additionally, on the <strong class="source-inline">RecipesOverviewPage</strong>, you’ll find that <strong class="source-inline">FavoriteControl</strong> is not tappable due to the absence of a defined <strong class="source-inline">ToggleCommand</strong>. Both scenarios illustrate that the controls behave <span class="No-Break">as expected!</span></p>
<p>Now that we’ve established how the <strong class="source-inline">IsInteractive</strong> property works, let’s turn our attention to leveraging it for a more intuitive user experience. Specifically, we’ll explore how to use this property to provide a visual cue that indicates whether or not the control is tappable. There’s not that much we can do about our <strong class="source-inline">FavoriteControl</strong> to make it really clear that it’s tappable. For the purposes of this demo, we’ll add a simple indicator – a black border around the heart icon when it’s tappable. Here’s how we can <span class="No-Break">do this:</span></p>
<ol>
<li>Open the <strong class="source-inline">FavoriteControl.xaml</strong> file and surround the existing <strong class="source-inline">Image</strong> control with <strong class="source-inline">Grid</strong>, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
<strong class="bold">&lt;Grid&gt;</strong>
    &lt;Image x:Name="icon" ...&gt;
        ...
    &lt;/Image&gt;
<strong class="bold">&lt;/Grid&gt;</strong></pre></li> <li>Inside this grid, add the following <strong class="source-inline">Image</strong>, prior to the <span class="No-Break">existing one:</span><pre class="source-code">
&lt;Grid&gt;
    <strong class="bold">&lt;Image</strong>
<strong class="bold">        HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">            Source={x:Reference icon}}"</strong>
<strong class="bold">        WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">            Source={x:Reference icon}}"</strong>
<strong class="bold">        IsVisible="{Binding IsInteractive,</strong>
<strong class="bold">            Source={RelativeSource</strong>
<strong class="bold">            AncestorType={x:Type</strong>
<strong class="bold">            local:FavoriteControl}}}"</strong>
<strong class="bold">        Scale="1.2"</strong>
<strong class="bold">        Source="{Binding Source,</strong>
<strong class="bold">            Source={x:Reference icon}}" /&gt;</strong>
    &lt;Image x:Name="icon" ...&gt;
        ...
    &lt;/Image&gt;
&lt;/Grid&gt;</pre><p class="list-inset"><strong class="source-inline">Grid</strong> allows controls to be placed on top of each other. The added <strong class="source-inline">Image</strong> will be rendered below the existing favorite icon. Its <strong class="source-inline">HeightRequest</strong>, <strong class="source-inline">WidthRequest</strong>, and <strong class="source-inline">Source</strong> properties are bound to those of the existing Image. Do note its <strong class="source-inline">Scale</strong> property – it’s set to <strong class="source-inline">1.2</strong>. As a result, this new <strong class="source-inline">Image</strong> will be a bit bigger than the <strong class="source-inline">Image</strong> on<a id="_idIndexMarker795"/> top. This creates the visual effect of a border surrounding the icon. Also, take a look at the <strong class="source-inline">IsVisible</strong> property – it’s bound to the <strong class="source-inline">IsInteractive</strong> property we introduced earlier. Because of this, the underlying <strong class="source-inline">Image</strong> will only be rendered when the control is tappable, giving a user a <span class="No-Break">visual cue.</span></p></li> <li>Lastly, it’s crucial not to forget to trigger the <strong class="source-inline">PropertyChanged</strong> event for the <strong class="source-inline">IsInteractive</strong> property whenever it is updated. Otherwise, the binding engine wouldn’t be notified about the updated value. The following snippet shows how we can update the <strong class="source-inline">UpdateIsInteractive</strong> method to <span class="No-Break">do that:</span><pre class="source-code">
private void UpdateIsInteractive()
{
    IsInteractive = IsEnabled
    &amp;&amp; (ToggledCommand?.CanExecute(IsFavorite)
    ?? false);
    <strong class="bold">OnPropertyChanged(nameof(IsInteractive));</strong>
}</pre></li> </ol>
<p>When running the app now and navigating to a <strong class="source-inline">RecipeDetailPage</strong>, you should see a black border around the favorite icon, indicating that the control is interactive. This border isn’t visible on the <strong class="source-inline">RecipeOverviewPage</strong> because of the absence of a <strong class="source-inline">ToggledCommand</strong>. Moreover, when<a id="_idIndexMarker796"/> tapping <strong class="source-inline">FavoriteControl</strong> on a <strong class="source-inline">RecipeDetailPage</strong> a few times, after the fifth time, the border will disappear because <strong class="source-inline">FavoriteToggledCommand</strong>’s <strong class="source-inline">CanExecute</strong> method returns <strong class="source-inline">false</strong>. This visual cue informs a user that the control is no longer interactive. <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.4</em> shows the <strong class="source-inline">FavoriteControl</strong> on the <strong class="source-inline">RecipeDetailPage</strong> in all its <span class="No-Break">different states:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 11.4: FavoriteControl in different states" height="430" src="image/B20941_11_04.jpg" width="1560"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: FavoriteControl in different states</p>
<p>Now that we’ve fine-tuned the user and developer experience, let’s take it a step further by making our control’s design as adaptable as <span class="No-Break">its functionality.</span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor191"/>Working with control templates</h1>
<p>So far, we’ve been dealing with a hardcoded look and feel, but what if we want to offer more flexibility without forcing <a id="_idIndexMarker797"/>developers to rewrite or extend our control? By supporting control templates, we can expose the structure of our control’s visual tree, enabling both styling and structural changes while retaining its core functionality. This is an excellent way to ensure that our custom control seamlessly fits into a diverse array of user interfaces, providing an even greater degree <span class="No-Break">of customization.</span></p>
<p>You might wonder how this is relevant to MVVM. Consider the following – a control template serves to separate the logic and behavior of a control from its visual representation, much like how MVVM achieves loose coupling between the ViewModel and the View. In this sense, the control effectively serves as a ViewModel for the control template. It exposes properties that the template binds to. The control template, in turn, can be considered as the View. So, just like we are used to, we can use data binding in the control template and use a relative binding source set to <strong class="source-inline">TemplatedParent</strong> to bind to the properties of the control that the template is <span class="No-Break">applied to.</span></p>
<p class="callout-heading">TemplateBinding and TemplatedParent</p>
<p class="callout">In the upcoming examples, we’ll use binding statements with their <strong class="source-inline">RelativeSource</strong> set to <strong class="source-inline">TemplatedParent</strong>. It’s worth noting that this approach performs the same function as the now-obsolete <strong class="source-inline">TemplateBinding</strong> markup extension. Essentially, setting <strong class="source-inline">RelativeSource</strong> to <strong class="source-inline">TemplatedParent</strong> manually accomplishes what <strong class="source-inline">TemplateBinding</strong> used to do automatically, creating a binding whose source is the control to which the template is applied. However, since .NET 7, the <strong class="source-inline">TemplateBinding</strong> markup extension has been marked <span class="No-Break">as “obsolete.”</span></p>
<p>I want to quickly discuss control templates, as they reflect the MVVM philosophy. Whether you’re extending the visuals of existing controls or creating new ones from scratch, knowing how to properly structure and utilize control templates will make your development process more efficient and your applications more maintainable. I also think that being proficient in the aspects of XAML and data binding directly contributes to effectively applying the MVVM pattern in your projects. Without further ado, let’s <span class="No-Break">dive in!</span></p>
<p>The next steps show how to define a control template and apply it to <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span></p>
<ol>
<li>On <strong class="source-inline">RecipeDetailPage</strong>, we can add a <strong class="source-inline">ControlTemplate</strong> to the page’s <strong class="source-inline">Resource</strong>s, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
&lt;ControlTemplate x:Key="FavoriteTemplate"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Label
            FontSize="10" HorizontalOptions="Center"
            Text="Favorite?" /&gt;
        &lt;Switch
            HorizontalOptions="Center"
            InputTransparent="True"
            <strong class="bold">IsEnabled="{Binding IsInteractive,</strong>
<strong class="bold">             Source={RelativeSource TemplatedParent}}"</strong>
            <strong class="bold">IsToggled="{Binding IsFavorite, Source=</strong>
<strong class="bold">              {RelativeSource TemplatedParent},</strong>
<strong class="bold">                </strong><strong class="bold">Mode=OneWay}"</strong>
        /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">Note how this template uses <strong class="source-inline">TemplatedParent</strong> as <strong class="source-inline">RelativeSource</strong> in its binding<a id="_idIndexMarker798"/> statements. By doing this, we bind to the public properties exposed by the control where this template will be applied, as we will see <span class="No-Break">later on.</span></p></li> <li>The following code snippet shows how we can use the key associated with the <strong class="source-inline">ControlTemplate</strong> (<strong class="source-inline">FavoriteTemplate</strong>), together with the <strong class="source-inline">StaticResource</strong> Markup extension, to assign it as the template of <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">FavoriteControl</strong></span><span class="No-Break">:</span><pre class="source-code">
&lt;controls:FavoriteControl
    ...
    ControlTemplate="{StaticResource
      FavoriteTemplate}"
    ... /&gt;</pre></li> </ol>
<p>While maintaining the functionality of the <strong class="source-inline">FavoriteControl</strong>, this template gives an entirely different look to the <a id="_idIndexMarker799"/>control, as you can see in <span class="No-Break"><em class="italic">Figure 11</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 11.5: FavoriteControl with an alternative template" height="177" src="image/B20941_11_05.jpg" width="852"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: FavoriteControl with an alternative template</p>
<p>However, there is one thing missing. Remember the animation we had on the original control? The animation was triggered by the <span class="No-Break">following code:</span></p>
<pre class="source-code">
private async Task AnimateChange()
{
    await icon.ScaleTo(1.5, 100);
    await icon.ScaleTo(1, 100);
}</pre> <p>The original visual tree of the control is replaced by the new visual tree defined in the <strong class="source-inline">ControlTemplate</strong>. Therefore, the original elements are not visible and are not part of the current visual tree. However, those original elements do still exist in memory if you have references to them in your code-behind. Even though they are detached from the visual tree and are not visible, you can still interact with them using code. They just won’t have any impact on what a user sees because they are not in the visual tree anymore. As a result, the code responsible for the animation won’t crash, but there won’t be any visual effect on the screen. Let’s <a id="_idIndexMarker800"/>see how we can access visual elements defined on <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">ControlTemplate</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor192"/>Accessing elements from a template</h2>
<p>Traditionally, when working with custom controls, UI elements are defined directly within the control. These controls, when given an <strong class="source-inline">x:Name</strong> attribute, can be accessed and manipulated from the control’s code-behind, which is a perfectly valid approach to defining and working with custom <a id="_idIndexMarker801"/>controls. However, when fully embracing the power of control templates, the need for directly defined UI elements lessens. Instead, the default appearance of the control should ideally be encapsulated within <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">ControlTemplate</strong></span><span class="No-Break">.</span></p>
<p>For illustration, let’s consider <strong class="source-inline">FavoriteControlTemplated</strong>, which is a variant of <strong class="source-inline">FavoriteControl</strong>. Unlike the original, this version doesn’t have UI elements defined directly within it. Instead, its default appearance is declared in a <strong class="source-inline">ControlTemplate</strong>, defined in the control’s <strong class="source-inline">Resources</strong>. Here’s how it looks <span class="No-Break">in XAML:</span></p>
<pre class="source-code">
&lt;ContentView
    ...&gt;
    &lt;ContentView.Resources&gt;
        &lt;toolkit:BoolToObjectConverter
            ... /&gt;
        <strong class="bold">&lt;ControlTemplate x:Key="DefaultTemplate"&gt;</strong>
<strong class="bold">            &lt;Grid&gt;</strong>
<strong class="bold">                &lt;Image</strong>
<strong class="bold">                    </strong><strong class="bold">HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">                     Source={x:Reference TemplatedParent}}"</strong>
<strong class="bold">                    IsVisible="{Binding IsInteractive,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"</strong>
<strong class="bold">                    Scale="1.2"</strong>
<strong class="bold">                    Source="{Binding Source, Source=</strong>
<strong class="bold">                      {x:Reference scalableContent}}"</strong>
<strong class="bold">                    WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">                     Source={x:Reference scalableContent}}"</strong>
<strong class="bold">                       </strong><strong class="bold">/&gt;</strong>
<strong class="bold">                &lt;Image</strong>
<strong class="bold">                    x:Name="scalableContent"</strong>
<strong class="bold">                    HeightRequest="{Binding HeightRequest,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"</strong>
<strong class="bold">                    Source="favorite.png"</strong>
<strong class="bold">                    WidthRequest="{Binding WidthRequest,</strong>
<strong class="bold">                      Source={RelativeSource</strong>
<strong class="bold">                        TemplatedParent}}"&gt;</strong>
<strong class="bold">                    </strong><strong class="bold">&lt;Image.Behaviors&gt;</strong>
<strong class="bold">                        ...</strong>
<strong class="bold">                    &lt;/Image.Behaviors&gt;</strong>
<strong class="bold">                &lt;/Image&gt;</strong>
<strong class="bold">            &lt;/Grid&gt;</strong>
<strong class="bold">        &lt;/ControlTemplate&gt;</strong>
    &lt;/ContentView.Resources&gt;
    &lt;ContentView.GestureRecognizers&gt;
        ...
    &lt;/ContentView.GestureRecognizers&gt;
&lt;/ContentView&gt;</pre> <p>As you can see in the next code block, in the constructor of the <strong class="source-inline">FavoriteControlTemplated</strong> class, a default template is assigned when no other template <span class="No-Break">is specified:</span></p>
<pre class="source-code">
public FavoriteControlTemplated()
{
    InitializeComponent();
    if(ControlTemplate == null)
    {
        var template = Resources["DefaultTemplate"];
        ControlTemplate = template as ControlTemplate;
    }
}</pre> <p>If the <strong class="source-inline">ControlTemplate</strong> property is null, it means the developer hasn’t specified a different template. In that case, the<a id="_idIndexMarker802"/> default template from the control’s <strong class="source-inline">Resources</strong> is retrieved <span class="No-Break">and assigned.</span></p>
<p>The <strong class="source-inline">OnApplyTemplate</strong> method is called when the control template is fully loaded. This is where the <strong class="source-inline">GetTemplateChild</strong> method can be used to access specific elements within the template, like <strong class="source-inline">Image</strong> in our template, which we assigned the name <strong class="source-inline">scalableContent</strong>. The following snippet shows how we use the <strong class="source-inline">GetTemplateChild</strong> method to get a <strong class="source-inline">VisualElement</strong> <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">scalableContent</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
VisualElement scalableContent;
protected override void OnApplyTemplate()
{
    base.OnApplyTemplate();
    scalableContent =
        GetTemplateChild("scalableContent")
        as VisualElement;
}</pre> <p>Once a <strong class="source-inline">VisualElement</strong> with the name <strong class="source-inline">scalableContent</strong> is retrieved, it can be manipulated programmatically. For example, in the <strong class="source-inline">AnimateChange</strong> method, scaling animations can be applied <span class="No-Break">to it:</span></p>
<pre class="source-code">
private async Task AnimateChange()
{
    if (scalableContent is not null)
    {
        await scalableContent.ScaleTo(1.5, 100);
        await scalableContent.ScaleTo(1, 100);
    }
}</pre> <p>By adopting control templates and leveraging methods such as <strong class="source-inline">GetTemplateChild</strong>, we can maintain a clean separation <a id="_idIndexMarker803"/>between the logic and visual representation of our control, allowing more flexible and <span class="No-Break">reusable components.</span></p>
<p>Let’s update the <strong class="source-inline">FavoriteTemplate</strong> we created earlier on <strong class="source-inline">RecipeDetailPage</strong> by giving a certain UI element the name <strong class="source-inline">scalableContent</strong>, using <strong class="source-inline">FavoriteControlTemplated</strong> instead of <strong class="source-inline">FavoriteControl</strong>. <span class="No-Break">Here’s how:</span></p>
<ol>
<li>On <strong class="source-inline">RecipeDetailPage</strong>, update the <strong class="source-inline">FavoriteTemplate</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;ControlTemplate x:Key="FavoriteTemplate"&gt;
    ...
        &lt;Switch
            <strong class="bold">x:Name="scalebleContent"</strong>
            …  /&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ControlTemplate&gt;</pre><p class="list-inset">By assigning <strong class="source-inline">scalebleContent</strong> as the name of the <strong class="source-inline">Switch</strong> control, it can be picked up later by the <strong class="source-inline">FavoriteControlTemplated</strong> control and have animations applied <a id="_idIndexMarker804"/><span class="No-Break">to it.</span></p></li> <li>As shown in the next code block, let’s use the <strong class="source-inline">FavoriteControlTemplated</strong> custom control instead of the <strong class="source-inline">FavoriteControl</strong> <span class="No-Break">from earlier:</span><pre class="source-code">
&lt;controls:FavoriteCo<a id="_idTextAnchor193"/>ntrolTemplated
    Grid.Column="1"
    Margin="5"
    ControlTemplate="{StaticResource
      FavoriteTemplate}"
    IsFavorite="{Binding IsFavorite, Mode=TwoWay}"
    ToggledCommand="{Binding FavoriteToggledCommand}"
    VerticalOptions="Center" /&gt;</pre><p class="list-inset">If you run the app at this stage, you’ll notice the updated favorite indicator. When we tap the control, you’ll notice the <strong class="source-inline">Switch</strong> is scaled. This is because it was named <strong class="source-inline">scalableContent</strong> in the template. If you update <strong class="source-inline">RecipeDetailPage</strong> and leave out the assignment of the <strong class="source-inline">ControlTemplate</strong> property (<strong class="source-inline">ControlTemplate="{StaticResource FavoriteTemplate}"</strong>) and run the app again, you’ll see the visualization using the hearts we had earlier. That’s because when no <strong class="source-inline">ControlTemplate</strong> is assigned explicitly, the control will load the default <span class="No-Break">control template.</span></p></li> </ol>
<p>It’s worth noting that any control template that includes an element named <strong class="source-inline">scalableContent</strong> will be compatible with this code. In other words, as long as the template has a UI element with the name <strong class="source-inline">scalableContent</strong>, our <strong class="source-inline">FavoriteControlTemplated</strong> class will be able to retrieve it and apply the scaling animation. However, what if there’s no <strong class="source-inline">scalableContent</strong> element in the template? No worries – the control is designed to degrade gracefully. If the element isn’t found, all functionalities of the control will remain intact; only the animation will be absent. This flexibility allows developers to create a wide array of visual styles while the behavior of the control <span class="No-Break">remains intact.</span></p>
<p>The principle of separation of concerns is central to MVVM and vital to creating maintainable software. When you’re crafting custom controls, this same principle can be extended through the use of control templates. However, it’s worth mentioning that fully implementing control templates<a id="_idIndexMarker805"/> may not always be necessary. For simpler controls that are unique to your application and maintain a consistent appearance, directly defining UI elements within the control itself is both a practical and valid approach. This allows you to balance complexity with flexibility, enabling you to choose the approach that best suits your project’s <span class="No-Break">specific requirements.</span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor194"/>Summary</h1>
<p>In this chapter, we explored the powerful possibilities offered by custom controls and control templates in .NET MAUI, all within the context of the MVVM architecture. From understanding the basics of custom controls to creating bindable properties, we’ve delved into the intricacies of data binding on custom controls. We also explored how to add interactivity to our control and how commands can be exposed and dealt with. Furthermore, we dived deep into the flexibility and scalability offered by control templates. Collectively, these techniques enhance reusability and adhere to the principles of separation of concerns. Mastering the art of creating UIs – whether through XAML or code-behind – and understanding how to craft MVVM-friendly controls with bindable properties and commands contributes tremendously to being proficient in MVVM. Whether it’s a simple control with a hardcoded appearance or a complex, template-driven control, the key takeaway is understanding when and how to appropriately apply these approaches to create maintainable, adaptable, and highly customizable <span class="No-Break">UI components.</span></p>
<p>In the next chapter, we’ll explore localization within the context of MVVM, enabling our UI components to be not only flexible and maintainable but also <span class="No-Break">globally adaptable.</span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor195"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>Create a custom control using <span class="No-Break">handlers: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create</span></a></li>
<li>Customize controls with <span class="No-Break">handlers: </span><a href="https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize</span></a></li>
<li>More about control <span class="No-Break">templates: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate</span></a></li>
<li>Bind to a templated <span class="No-Break">parent: </span><a href="https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent</span></a></li>
</ul>
</div>
</div></body></html>