- en: Automation for Software Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试自动化
- en: In previous chapters, we discussed the importance of unit tests and integration
    tests in software development, and how they ensure the reliability of your code
    base. We also discussed how unit and integration tests are integral parts of all
    software production stages and are run each time the code base is modified.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了单元测试和集成测试在软件开发中的重要性，以及它们如何确保代码库的可靠性。我们还讨论了单元和集成测试是所有软件生产阶段的组成部分，并且每次修改代码库时都会运行。
- en: There are also other important tests, called **functional**/**acceptation**
    tests. They are run only at the end of each sprint to verify that the output of
    the sprint actually satisfies the specifications that were agreed upon with the
    stakeholders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他重要的测试，称为**功能**/**验收**测试。它们只在每个冲刺结束时运行，以验证冲刺的输出实际上是否满足与利益相关者商定的规范。
- en: 'This chapter is specifically dedicated to functional/acceptance tests and to
    the techniques for defining and executing them. More specifically, this chapter
    covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍功能/验收测试以及定义和执行它们的技巧。更具体地说，本章涵盖了以下主题：
- en: Understanding the purpose of functional tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解功能测试的目的
- en: Using unit testing tools for automating functional tests in C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单元测试工具自动化C#中的功能测试
- en: Use case – automating functional tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 – 自动化功能测试
- en: By the end of this chapter, you will be able to design both manual and automatic
    tests to verify that the code produced by a sprint complies with its specifications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够设计手动和自动测试，以验证冲刺产生的代码是否符合其规范。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The reader is encouraged to read [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*, before proceeding with this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者在继续本章之前阅读[第15章](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml)，*使用单元测试用例和TDD测试您的代码*。
- en: This chapter requires Visual Studio 2017 or the 2019 free Community Edition
    or better with all the database tools installed. Here, we will modify the code
    of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing Your Code
    with Unit Test Cases and TDD*, which is available at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)[.](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要Visual Studio 2017或2019免费社区版或更高版本，并安装所有数据库工具。在这里，我们将修改[第15章](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml)的代码，*使用单元测试用例和TDD测试您的代码*，该代码可在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)找到[.](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch20)
- en: Understanding the purpose of functional tests
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解功能测试的目的
- en: 'Functional/acceptance tests use techniques similar to unit and integration
    tests but differ from them in that they are run only at the end of each sprint.
    They have the fundamental role of verifying that the current version of the whole
    software complies with its specifications. This verification is turned into a
    formal process for the following purposes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 功能/验收测试使用与单元和集成测试类似的技术，但它们的不同之处在于它们只在每个冲刺结束时运行。它们的基本作用是验证当前版本的整个软件是否符合其规范。这种验证被转化为以下目的的正式流程：
- en: Functional tests represent the most important part of the contract between stakeholders
    and the development team, the other part being the verification of non-functional
    specifications. The way this contract is formalized depends on the very nature
    of the relationship between the development team and stakeholders. In the case
    of a supplier-customer relationship, they become part of the supplier-customer
    business contract for each sprint, and they are written by a team that works for
    the customer. If the tests fail, then the sprint is rejected and the supplier
    must run a supplementary sprint to fix all problems. In case there is no formal
    business contract, the result of the tests is usually used to drive the specifications
    for the next sprints. However, also in this case, if the failure percentage is
    high, the sprint may be rejected and should be repeated.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试代表了利益相关者和开发团队之间合同的最重要部分，另一部分是非功能规格的验证。这种合同的形式化方式取决于开发团队和利益相关者之间关系的本质。在供应商-客户关系的案例中，它们成为每个冲刺的供应商-客户商业合同的一部分，并由为客户工作的团队编写。如果测试失败，则冲刺将被拒绝，供应商必须运行一个补充冲刺来解决所有问题。如果没有正式的商业合同，测试的结果通常用于驱动下一个冲刺的规格。然而，在这种情况下，如果失败率很高，冲刺可能被拒绝并需要重新进行。
- en: Formalized functional tests that run at the end of each sprint avoid that results
    achieved in previous sprints might be destroyed by new code.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个冲刺结束时运行的正式功能测试可以避免之前冲刺中取得的结果被新代码破坏。
- en: When using an agile development methodology, maintaining an updated battery
    of functional tests is the best way to get a formal representation of the final
    system specifications since, during agile development, the specifications of the
    final system are not decided before development starts but are the result of the
    system evolution.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用敏捷开发方法时，维护一个最新的功能测试库是获取最终系统规格正式表示的最佳方式，因为在敏捷开发过程中，最终系统的规格并不是在开发开始之前就确定的，而是系统演化的结果。
- en: Since the output of the first sprints may differ a lot from the final system
    in these early stages, it is not worth spending too much time writing detailed
    manual tests and/or automatized tests. Therefore, you may limit to add a few examples
    to the user stories that will be used both as inputs for software development
    and as manual tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于早期阶段的第一轮冲刺的输出可能与最终系统有很大差异，因此不值得花费太多时间编写详细的手动测试和/或自动化测试。因此，你可以限制只添加一些示例到用户故事中，这些示例将同时作为软件开发输入和手动测试。
- en: 'As system functionalities become always more stable, it is worth investing
    time in writing detailed and formal functional tests for them. For each functional
    specification, we must write tests that verify their correct operation also in
    extreme cases. For instance, in a payment use case, we must write tests that verify
    all possibilities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统功能始终更加稳定，投入时间编写详细和正式的功能测试是值得的。对于每个功能规格，我们必须编写测试来验证它们在极端情况下的正确操作。例如，在一个支付用例中，我们必须编写测试来验证所有可能性：
- en: Not enough funds
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资金不足
- en: Various digitization errors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种数字化错误
- en: Card expired
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片过期
- en: Wrong credentials and repeated wrong credentials
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的凭证和重复的错误凭证
- en: In the case of manual tests, for each of the preceding scenarios, we must give
    all details of all steps involved in each operation, and for each step, the expected
    result.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动测试的情况下，对于上述每个场景，我们必须提供每个操作中涉及的每个步骤的所有详细信息，以及每个步骤的预期结果。
- en: An important decision is if you want to automate all or a part of the acceptance/functional
    tests since it is very expansive to write automatic tests that simulate a human
    operator that interacts with a system's user interface. The final decision depends
    on the cost of the test implementation divided by the expected number of times
    it will be used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的决定是是否要自动化所有或部分验收/功能测试，因为编写模拟与系统用户界面交互的人类操作员的自动化测试非常昂贵。最终的决定取决于测试实现的成本除以预期使用的次数。
- en: In the case of CI/CD, the same functional test can be executed several times
    but, unluckily, functional/acceptance tests are strictly tied to the way the user
    interface is implemented, and, in modern systems, the user interface is frequently
    changed. Therefore, in this case, the same test is executed with exactly the same
    user interface not more than a couple of times.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD的情况下，相同的功能测试可以执行多次，但不幸的是，功能/验收测试严格依赖于用户界面的实现方式，而在现代系统中，用户界面经常发生变化。因此，在这种情况下，相同的测试最多只能与完全相同的用户界面执行几次。
- en: In order to overcome all the problems related to the user interface, functional
    tests can be implemented as **subcutaneous tests**, that is, as tests that bypass
    the user interface. However, subcutaneous tests are incomplete by their very nature since
    they can't detect errors in the user interface itself. Moreover, in the case of
    a web application, subcutaneous tests usually suffer from other limitations because
    they bypass the whole HTTP protocol. In the case of ASP.NET Core applications,
    this means that the whole ASP.NET Core pipeline must be bypassed and that requests
    are passed directly to ASP.NET controllers. Therefore, authentication, authorization,
    CORS, and the behavior of other modules in the ASP.NET Core pipeline will not
    be analyzed by the tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服与用户界面相关的所有问题，功能测试可以实施为**皮下测试**，即作为绕过用户界面的测试。然而，皮下测试由于其本质是不完整的，因为它们无法检测用户界面本身的错误。此外，在Web应用的情况下，皮下测试通常还受到其他限制，因为它们绕过了整个HTTP协议。在ASP.NET
    Core应用的情况下，这意味着必须绕过整个ASP.NET Core管道，并将请求直接传递到ASP.NET控制器。因此，身份验证、授权、CORS以及ASP.NET
    Core管道中其他模块的行为将不会被测试分析。
- en: 'A complete automatic functional test of a web application should do the following
    things:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的Web应用功能自动测试应该执行以下操作：
- en: Start an actual browser on the URL to be tested.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要测试的URL上启动一个实际的浏览器。
- en: Wait so that any JavaScript on the page completes its execution.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待页面上的任何JavaScript完成其执行。
- en: Then, send commands to the browser that simulate the behavior of a human operator.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向浏览器发送模拟人类操作员行为的命令。
- en: Finally, after each interaction with the browser, automatic tests should wait
    so that any JavaScript that was triggered by the interaction completes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在每次与浏览器的交互之后，自动测试应该等待，以便任何由交互触发的JavaScript完成其执行。
- en: While browser automatization tools exist, tests implemented with browser automatization,
    as mentioned earlier, are very expensive and difficult to implement. Therefore,
    the suggested approach of ASP.NET Core MVC is to send actual HTTP requests to
    an actual copy of the web application, with a .NET HTTP client instead of using
    a browser. Once the HTTP client receives an HTTP response, it parses it in a DOM
    tree and verifies that it received the right response.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在浏览器自动化工具，但如前所述，使用浏览器自动化实现的测试非常昂贵且难以实现。因此，ASP.NET Core MVC建议的方法是使用.NET HTTP客户端向实际的Web应用副本发送实际的HTTP请求，而不是使用浏览器。一旦HTTP客户端收到HTTP响应，它就会将其解析为DOM树，并验证它是否收到了正确的响应。
- en: The only difference with the browser automatization tools is that the HTTP client
    is not able to run any JavaScript. However, other tests may be added to test the
    JavaScript code. These tests are based on test tools that are specific to JavaScript,
    such as **Jasmine** and **Karma**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器自动化工具的唯一区别是HTTP客户端无法运行任何JavaScript。然而，可以添加其他测试来测试JavaScript代码。这些测试基于特定的JavaScript测试工具，例如**Jasmine**和**Karma**。
- en: The next section explains how to automatize functional tests for web applications
    with a .NET HTTP client, while a practical example of functional test automation
    is shown in the last section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解释如何使用.NET HTTP客户端自动化Web应用的功能测试，而功能测试自动化的实际示例将在最后一部分展示。
- en: Using unit testing tools to automate functional tests in C#
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单元测试工具来自动化C#中的功能测试。
- en: Automated functional/acceptance tests use the same test tools as unit and integration
    tests. That is, these tests can be embedded in the same xUnit, NUnit, or MSTests
    projects that we described in [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*. However, in this case, we must add further
    tools that are able to interact with and inspect the user interface.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的功能/验收测试使用与单元和集成测试相同的测试工具。也就是说，这些测试可以嵌入到我们在第15章中描述的同一xUnit、NUnit或MSTests项目中，即使用单元测试用例和TDD测试您的代码。然而，在这种情况下，我们必须添加能够与用户界面交互和检查的进一步工具。
- en: In the remainder of this chapter, we will focus on web applications since they
    are the main focus of this book. Accordingly, if we are testing web APIs, we just need
    `HTTPClient` instances since they can easily interact with web API endpoints both
    in XML and JSON.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分，我们将专注于网络应用程序，因为它们是本书的主要焦点。因此，如果我们正在测试网络API，我们只需要`HTTPClient`实例，因为它们可以轻松地与XML和JSON格式的网络API端点进行交互。
- en: In the case of ASP.NET Core MVC applications that return HTML pages, the interaction
    is more complex, since we also need tools for parsing and interacting with the
    HTML page DOM tree. The `AngleSharp` NuGet package is a great solution since it
    supports state-of-the-art HTML and minimal CSS and has extension points for externally
    provided JavaScript engines, such as Node.js. However, we don't advise you to
    include JavaScript and CSS in your tests, since they are strictly tied to target
    browsers, so the best option for them is to use JavaScript-specific test tools
    that you can run directly in the target browsers themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core MVC应用程序返回HTML页面的情况下，交互更为复杂，因为我们还需要工具来解析和与HTML页面DOM树进行交互。`AngleSharp`
    NuGet包是一个很好的解决方案，因为它支持最先进的HTML和最小化的CSS，并为外部提供的JavaScript引擎（如Node.js）提供了扩展点。然而，我们不建议你在测试中包含JavaScript和CSS，因为它们严格绑定到目标浏览器，所以对于它们来说，最佳选项是使用可以在目标浏览器中直接运行的JavaScript特定测试工具。
- en: 'There are two basic options for testing a web application with the `HTTPClient` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HTTPClient`类测试网络应用程序有两个基本选项：
- en: An `HTTPClient` instance connects with the actual *staging* web application
    through the internet/intranet, together with all other humans that are beta-testing
    the software. The advantage of this approach is that you are testing the *real
    stuff*, but tests are more difficult to conceive since you can't control the initial
    state of the application before each test.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`HTTPClient`实例通过互联网/内网与实际的*预发布*网络应用程序以及所有正在测试软件的beta测试人员连接。这种方法的优势在于你正在测试*真实的东西*，但测试的构思更困难，因为你无法控制每个测试之前应用程序的初始状态。
- en: An `HTTPClient` instance connects with a local application that is configured,
    initialized, and launched before every single test. This scenario is completely
    analogous to the unit test scenario. Test results are reproducible the initial
    state before each test is fixed, tests are easier to design, and the actual database
    can be replaced by a faster and easier-to-initialize in-memory database. However,
    in this case, you are far from the actual system's operation.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`HTTPClient`实例连接到一个在每次测试之前都配置、初始化和启动的本地应用程序。这种情况与单元测试场景完全类似。测试结果可以在每个测试的初始状态固定后重现，测试设计更容易，并且实际数据库可以被一个更快、更容易初始化的内存数据库所替代。然而，在这种情况下，你离实际系统的操作还相当远。
- en: A good strategy is to use the second approach, where you have full control of
    the initial state, for testing all extreme cases, and then the first approach
    for testing random average cases on the *real stuff*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的策略是使用第二种方法，即完全控制初始状态，用于测试所有极端情况，然后使用第一种方法测试真实环境中的随机平均情况。
- en: The two sections that follow describe both approaches. The two approaches differ
    just in the way you define the fixtures of your tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个部分描述了两种方法。这两种方法的不同之处仅在于你定义测试固定值的方式。
- en: Testing the staging application
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试预发布应用程序
- en: In this case, your tests need just an instance of `HTTPClient`, so you must
    define an efficient fixture that supplies `HTTPClient` instances, avoiding the
    risk of running out of windows connections. We faced this problem in the *.NET
    Core HTTP clients* section of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml), *Applying
    Service-Oriented Architectures with .NET Core*. It can be solved by managing `HTTPClient` instances
    with `IHTTPClientFactory` and injecting them with dependency injection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你的测试只需要一个`HTTPClient`实例，因此你必须定义一个高效的固定值，它提供`HTTPClient`实例，避免出现窗口连接耗尽的风险。我们在第12章的“*.NET
    Core HTTP客户端*”部分遇到了这个问题，*使用.NET Core应用服务架构*。可以通过使用`IHTTPClientFactory`管理`HTTPClient`实例并将它们通过依赖注入注入来解决。
- en: 'Once we have a dependency injection container, we can enrich it with the capability
    of efficiently handling `HTTPClient` instances with the following code snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个依赖注入容器，我们可以通过以下代码片段来丰富其处理`HTTPClient`实例的能力：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the `AddHTTPClient` extension belongs to the `Microsoft.Extensions.DependencyInjection`
    namespace and is defined in the `Microsoft.Extensions.HTTP` NuGet package. Therefore,
    our test fixture must create a dependency injection container, must call `AddHTTPClient`,
    and finally, must build the container. The following fixture class does this job
    (please refer to the *Advanced test preparation/test tear down scenarios* section
    of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing Your Code
    with Unit Test Cases and TDD*, if you don''t remember fixture classes):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AddHTTPClient` 扩展属于 `Microsoft.Extensions.DependencyInjection` 命名空间，并在
    `Microsoft.Extensions.HTTP` NuGet 包中定义。因此，我们的测试固定项必须创建一个依赖注入容器，必须调用 `AddHTTPClient`，最后必须构建容器。以下固定类执行此操作（如果您不记得固定类，请参阅
    [第 15 章](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml) 的 *高级测试准备/测试清理场景* 部分，*使用单元测试用例和
    TDD 测试您的代码*，如果您不记得固定类）：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After the preceding definition, your tests should look as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义之后，您的测试应该如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In `Test1`, once you get an HTTP client, you can test the application by issuing
    an HTTP request and then by analyzing the response returned by the application.
    More details on how to process the response returned by the server will be given
    in the *Use case* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Test1` 中，一旦您获取了 HTTP 客户端，您可以通过发出 HTTP 请求并分析应用程序返回的响应来测试应用程序。有关如何处理服务器返回的响应的更多详细信息将在
    *用例* 部分提供。
- en: The next section explains how to test an application that runs in a controlled
    environment.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节解释如何测试在受控环境中运行的应用程序。
- en: Testing a controlled application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试受控应用程序
- en: In this case, we create an ASP.NET Core server within the test application and
    test it with an `HTTPClient` instance. The `Microsoft.AspNetCore.Mvc.Testing`
    NuGet package contains all that we need to create both an HTTP client and the
    server running the application. We also need to reference the whole web framework
    by referencing the `Microsoft.AspNetCore.App` NuGet package.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在测试应用程序中创建一个 ASP.NET Core 服务器，并使用 `HTTPClient` 实例对其进行测试。`Microsoft.AspNetCore.Mvc.Testing`
    NuGet 包包含我们创建 HTTP 客户端和运行应用程序的服务器所需的所有内容。我们还需要通过引用 `Microsoft.AspNetCore.App`
    NuGet 包来引用整个 Web 框架。
- en: 'Finally, we must also transform the test project into a web project with the
    following steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须通过以下步骤将测试项目转换为 Web 项目：
- en: Click on the test project icon in Visual Studio solution explorer, and select
    the edit project item from the context menu.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 解决方案资源管理器中单击测试项目图标，然后从上下文菜单中选择编辑项目项。
- en: Replace the root XML node, which should be `<Project Sdk="Microsoft.NET.Sdk">`,
    with `<Project Sdk="Microsoft.NET.Sdk.web">`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根 XML 节点替换为 `<Project Sdk="Microsoft.NET.Sdk">`，改为 `<Project Sdk="Microsoft.NET.Sdk.web">`。
- en: '`Microsoft.AspNetCore.Mvc.Testing` contains a fixture class that does the job
    of launching a local web server and furnishing a client for interacting with it.
    The predefined fixture class is `WebApplicationFactory<T>`. The generic `T` argument
    must be instantiated with the `Startup` class of your web project.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.AspNetCore.Mvc.Testing` 包含一个固定类，该类负责启动本地 Web 服务器并为与之交互提供客户端。预定义的固定类是
    `WebApplicationFactory<T>`。泛型 `T` 参数必须使用您的 Web 项目的 `Startup` 类进行实例化。'
- en: 'Tests look like the following class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试看起来像以下类：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to analyze the HTML of the returned pages, you must also reference
    the `AngleSharp` NuGet package. We will see how to use it in the example of the
    next section. The simplest way to cope with databases in this type of tests is
    to replace them with in-memory databases that are faster and automatically cleared
    whenever the local server is shut down and restarted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想分析返回页面的 HTML，您还必须引用 `AngleSharp` NuGet 包。我们将在下一节的示例中看到如何使用它。在这种类型的测试中处理数据库的最简单方法是使用内存数据库，这些数据库更快，并且每当本地服务器关闭和重新启动时都会自动清除。
- en: 'This can be done by creating a new deployment environment, say `AutomaticStaging`,
    and an associate configuration file that is specific for the tests. After having
    created this new deployment environment, go to the `ConfigureServices` method
    of your application''s `Startup` class and locate the place where you add your
    `DBContext` configuration. Once located that place, add an `if` there, that, in
    case the application is running in the `AutomaticStaging` environment, replaces
    your `DBContext` configuration with something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过创建一个新的部署环境，例如`AutomaticStaging`，以及一个针对测试的特定配置文件来完成。在创建了这个新的部署环境之后，前往你的应用程序的`Startup`类中的`ConfigureServices`方法，找到添加你的`DBContext`配置的地方。一旦找到这个地方，就在那里添加一个`if`语句，如果应用程序正在`AutomaticStaging`环境中运行，就用类似以下的内容替换你的`DBContext`配置：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As an alternative, you can also add all needed instructions to clear a standard
    database in the constructor of a custom fixture that inherits from `WebApplicationFactory<T>`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，你还可以在继承自`WebApplicationFactory<T>`的自定义固定工具的构造函数中添加所有必要的指令来清除标准数据库。
- en: Use case – automating functional tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 自动化功能测试
- en: In this section, we will add a simple acceptance test to the ASP.NET Core test
    project of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml), *Testing
    Your Code with Unit Test Cases and TDD*. Our test approach is based on the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages. Please make a new copy of the whole solution.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向[第15章](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml)的ASP.NET Core测试项目添加一个简单的验收测试，该章节是*使用单元测试用例和TDD测试你的代码*。我们的测试方法基于`Microsoft.AspNetCore.Mvc.Testing`和`AngleSharp`
    NuGet包。请创建整个解决方案的新副本。
- en: As a first step, we must turn the test project into a web project by replacing
    the `sdk` attribute of the root node of its project file in `Sdk="Microsoft.NET.Sdk.web"`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们必须将测试项目转换成一个Web项目，通过替换其项目文件根节点的`sdk`属性来实现，即`Sdk="Microsoft.NET.Sdk.web"`。
- en: The test project already references the ASP.NET Core project under `test` and
    all the required xUnit NuGet packages, so we need to add just the `Microsoft.AspNetCore.Mvc.Testing`
    and `AngleSharp` NuGet packages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目已经引用了位于`test`目录下的ASP.NET Core项目以及所有必需的xUnit NuGet包，因此我们只需要添加`Microsoft.AspNetCore.Mvc.Testing`和`AngleSharp`
    NuGet包。
- en: 'Now, let''s add a new class file called `UIExampleTestcs.cs`. We need `using`
    statements to reference all the necessary namespaces. More specifically, we need
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个名为`UIExampleTestcs.cs`的新类文件。我们需要`using`语句来引用所有必要的命名空间。更具体地说，我们需要以下内容：
- en: '`using PackagesManagement;`: This is needed for referencing your application
    classes.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using PackagesManagement;`: 这是为了引用你的应用程序类所必需的。'
- en: '`using Microsoft.AspNetCore.Mvc.Testing;`: This is needed for referencing the
    client and server classes.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using Microsoft.AspNetCore.Mvc.Testing;`: 这是为了引用客户端和服务器类所必需的。'
- en: '`using AngleSharp;` and `using AngleSharp.Html.Parser;`: These are needed for
    referencing `AngleSharp` classes.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using AngleSharp;`和`using AngleSharp.Html.Parser;`: 这些是为了引用`AngleSharp`类所必需的。'
- en: '`System.IO`: This is needed in order to extract HTML from HTTP responses.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.IO`: 这是为了从HTTP响应中提取HTML所必需的。'
- en: '`using Xunit`: This is needed for referencing all `xUnit` classes.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using Xunit`: 这是为了引用所有`xUnit`类所必需的。'
- en: 'Summing up, the whole `using` block is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，整个`using`块如下：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use the standard fixture class we introduced in the previous *Testing
    a controlled application* section, that is, the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前在*测试受控应用程序*部分中引入的标准固定工具类，即以下内容：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we are ready to write a test for the home page! This test verifies that
    the home URL returns a successful HTTP result and that the home page contains
    a link to the package management page, which is the `/ManagePackages` relative
    link.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写主页的测试了！这个测试验证了主页URL返回成功的HTTP结果，并且主页包含指向包管理页面的链接，这是一个`/ManagePackages`的相对链接。
- en: It is fundamental to understand that automatic tests must not depend on the
    details of the HTML, but that they must verify just logical facts, in order to
    avoid frequent changes after each small modification of the application HTML.
    That's why we just verify that the needed links exist without putting constraints
    on where they are.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点是基本的，即自动测试不应依赖于HTML的细节，而应仅验证逻辑事实，以避免在每次对应用程序HTML进行微小修改后频繁更改。这就是为什么我们只验证所需的链接存在，而不对其位置施加约束。
- en: 'Let''s call `TestMenu` our home page test:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`TestMenu`称为主页测试：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first step of each test is the creation of a client. Then, if the test
    needs the analysis of some HTML, we must prepare the so-called `AngleSharp` browsing
    context:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试的第一步是创建一个客户端。然后，如果测试需要分析一些HTML，我们必须准备所谓的`AngleSharp`浏览上下文：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The configuration object specifies options such as cookie handling and other
    browser-related properties. At this point, we are ready to require the home page:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 配置对象指定了诸如cookie处理和其他浏览器相关属性等选项。到目前为止，我们已经准备好要求主页：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As a first step, we verify that the response we received contains a success
    status code, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们验证收到的响应包含成功状态码，如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding method call throws an exception in case of unsuccessful status
    code, hence causing the test to fail. HTML analysis needs to be extracted from
    the response. The following code shows a simple way to do it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法调用在状态码不成功时抛出异常，从而导致测试失败。HTML分析需要从响应中提取。以下代码展示了如何简单地进行操作：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ReadAsStreamAsync` returns `Stream`, which we can use to build `StreamReader`
    (a stream specialized for reading text), which can read the whole response body.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadAsStreamAsync`返回`Stream`，我们可以使用它来构建`StreamReader`（一个专门用于读取文本的流），它可以读取整个响应体。'
- en: 'Now, we must pass the extracted HTML to our previous `AngleSharp` browsing
    context object, so it can build a DOM tree. The following code shows how to do
    it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将提取的HTML传递给之前的`AngleSharp`浏览上下文对象，以便它可以构建DOM树。以下代码展示了如何操作：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `OpenAsync` method executes a DOM-building activity with the settings contained
    in `context`. The input for building the DOM document is specified by the lambda
    function passed as an argument to `OpenAsync`. In our case, `req.Content(...)`
    builds a DOM tree from the HTML string passed to the `Content` method, which is
    the HTML contained in the response received by the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenAsync`方法使用`context`中包含的设置执行DOM构建活动。构建DOM文档的输入由传递给`OpenAsync`方法的lambda函数指定。在我们的情况下，`req.Content(...)`从传递给`Content`方法的HTML字符串构建DOM树，这是客户端收到的响应中包含的HTML。'
- en: 'Once a `document` object is obtained, we can use it as we would use it in JavaScript.
    In particular, we can use `QuerySelector` to find an anchor with the required
    link:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得`document`对象，我们就可以像在JavaScript中使用它一样使用它。特别是，我们可以使用`QuerySelector`来查找具有所需链接的锚点：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It remains to verify just that `node` is not null:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是验证`node`不是null：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have done it! If you want to analyze pages that require a user to be logged
    in or other more complex scenarios, you need to enable cookies and automatic URL
    redirects in the HTTP client. This way, the client will behave like a usual browser
    that stores and sends cookies and that moves to another URL whenever it receives
    a `Redirect` HTTP response. This can be done by passing an options object to the `CreateClient` method,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！如果你想要分析需要用户登录或其他更复杂场景的页面，你需要启用HTTP客户端中的cookie和自动URL重定向。这样，客户端将表现得像通常的浏览器，它会存储和发送cookie，并在接收到`Redirect`
    HTTP响应时移动到另一个URL。这可以通过将选项对象传递给`CreateClient`方法来实现，如下所示：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the preceding setup, your tests can do everything a usual browser can do.
    For instance, you can design tests where the HTTP client logs in and accesses
    pages that require authentication since `HandleCookies=true` lets the authentication
    cookie be stored by the client and be sent in all subsequent requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的设置，你的测试可以做到一个普通浏览器能做的所有事情。例如，你可以设计测试，其中HTTP客户端登录并访问需要身份验证的页面，因为`HandleCookies=true`允许客户端存储身份验证cookie并在所有后续请求中发送它。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter explains the importance of acceptance/functional tests, and how
    to define detailed manual tests to be run on the output of each sprint. At this
    point, you should be able to define automatic and/or manual tests to verify that,
    at the end of each sprint, your application complies with its specifications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了验收/功能测试的重要性，以及如何定义详细的手动测试，以便在每个冲刺的输出上运行。到目前为止，你应该能够定义自动和/或手动测试，以验证在每个冲刺结束时，你的应用程序符合其规范。
- en: Then, this chapter analyzed when it is worth automating some or all acceptance/functional
    tests and describes how to automate them in ASP.NET Core applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章分析了何时值得自动化某些或所有验收/功能测试，并描述了如何在ASP.NET Core应用程序中自动化它们。
- en: A final example showed how to write, in practice, ASP.NET Core acceptance/functional
    tests with the help of `AngleSharp` to inspect the responses returned by the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终的例子展示了如何使用`AngleSharp`编写ASP.NET Core验收/功能测试，以检查应用程序返回的响应。
- en: Questions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it always worth automating user interface acceptance tests in the case of
    quick CI/CD cycles?
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在快速 CI/CD 循环的情况下，自动化用户界面验收测试是否总是值得？
- en: What is the disadvantage of the subcutaneous test for ASP.NET Core applications?
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 ASP.NET Core 应用程序的皮下测试有什么缺点？
- en: What is the suggested technique for writing ASP.NET Core acceptance tests?
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议用于编写 ASP.NET Core 验收测试的技术是什么？
- en: What is the suggested way of inspecting the HTML returned by the server?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建议如何检查服务器返回的 HTML？
- en: Further reading
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details on the `Microsoft.AspNetCore.Mvc.Testing` NuGet package and `AngleSharp` can
    be found in their respective official documentation at [https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0) and [https://anglesharp.github.io/](https://anglesharp.github.io/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Microsoft.AspNetCore.Mvc.Testing` NuGet 包和 `AngleSharp` 的更多详细信息可以在它们各自的官方文档中找到：[https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0](https://docs.microsoft.com/en-US/aspnet/core/test/integration-tests?view=aspnetcore-3.0)
    和 [https://anglesharp.github.io/](https://anglesharp.github.io/).
- en: Readers interested in JavaScript tests can refer to the Jasmine documentation: [https://jasmine.github.io/](https://jasmine.github.io/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对 JavaScript 测试感兴趣的读者可以参考 Jasmine 文档：[https://jasmine.github.io/](https://jasmine.github.io/).
