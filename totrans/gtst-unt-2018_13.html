<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Optimizing Our Game for Deployment</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the last chapter, <span>we planned and implemented audio and visual effects into our game to enhance overall gameplay. Specifically, we added audio to key events in our combat system and added lighting and particle special effects. We started with an overview of Unity's audio system, then planned and implemented our game's audio. We then shifted to an introduction to lights and shadows in Unity and covered select special effects in Unity. We concluded by adding a point light to our cherry trees and a special effect to our spawn pads.</span></p>
<p class="mce-root">This chapter has two areas of focus: optimization and deployment. In the optimization sections, you will learn how t<span>o diagnose your Unity game for performance problems and how to optimize scripts and graphics rendering. In the deployment section, you will learn about the Unity build process, how to create a standalone player, and how to deploy your game to multiple platforms.</span></p>
<p>Specifically, in this chapter, we will cover the following topics:</p>
<ul>
<li>Using the Profiler window</li>
<li>Optimizing scripts</li>
<li>Optimizing graphics rendering</li>
<li>Additional optimizations</li>
<li>Creating builds </li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the Profiler window</h1>
                </header>
            
            <article>
                
<p>Unity has a native tool that helps us to examine how our game performs. This is a Profiler tool and is accessible via the <span class="packt_screen">Window</span> | <span class="packt_screen">Profiler</span> top menu option. As you can see in the following illustration, there are 13 components available in the <span class="packt_screen">Profiler</span> window:</p>
<div class="CDPAlignCenter CDPAlign"><img height="508" width="480" src="assets/e01a6986-68e0-4657-9a31-83799dcfe526.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Profiler Components</div>
<p>The individual Profiler names provide a clear indication of what performance measure is being analyzed. In order to fully explore the <span class="packt_screen">Profiler</span> window, let's get it up and running with the following steps:</p>
<ol>
<li><span>Open your Unity game project. </span><span>Alternatively, you can download the</span> <span class="packt_screen">Starting-Chapter-13</span><span> Unity </span><span>project available from the publisher's companion site.</span></li>
<li>Using the top menu, select <span class="packt_screen">Window</span> | <span class="packt_screen">Profiler</span>. Depending on your system, this can open the <span class="packt_screen">Profiler</span> in a new window or as a tab. </li>
<li>In the <span class="packt_screen">Profiler</span> window or tab, use the <span class="packt_screen">Add Profiler</span> button to add any Profilers not loaded by default. The Profilers that are already loaded will appear in gray and the unloaded Profilers will appear in black.</li>
<li>Put your game in game mode.</li>
<li>Scroll through the Profilers and, using the <em>x</em> in the top-right corner of the Profiler box, close the Profilers that provide little or no data on your game. For example, the <span class="packt_screen">Network Operations</span> and <span class="packt_screen">Network Messages</span> Profilers are not applicable to the Cucumber Man game. You might leave the following Profilers in your <span class="packt_screen">Profiler</span> window:
<ul>
<li><span class="packt_screen">CPU Usage</span></li>
<li><span class="packt_screen">GPU Usage</span></li>
<li><span class="packt_screen">Rendering</span></li>
<li><span class="packt_screen">Memory</span></li>
<li><span class="packt_screen">Audio</span></li>
<li><span class="packt_screen">Physics</span></li>
<li><span class="packt_screen">UI</span></li>
<li><span class="packt_screen">Global Illumination</span></li>
</ul>
</li>
<li>Let your game run for at least a minute or more, then exit the game. It does not matter whether you play the game while it is running or just sit back and watch the cucumber beetles search for and eat cucumbers. You will have the Profiler data available to you even after the game stops.</li>
</ol>
<p>We can examine each Profiler to help determine how our game is performing and identify any performance problems. Let's look at the <span class="packt_screen">GPU Usage</span> Profiler by clicking on it in the <span class="packt_screen">Profiler</span> window. When we select a Profiler, detailed information is provided in the bottom section of the <span class="packt_screen">Profiler</span> window. </p>
<p>By reviewing the detailed information provided, such as the GPU Usage information shown here, we can determine component-level performance. In the following example, we can see that our <kbd>Camera.Renderer</kbd> takes the greatest draw on the GPU. We can also drill down to greater fidelity by clicking the gray triangles to the left of each component:</p>
<div class="CDPAlignCenter CDPAlign"><img height="249" width="491" src="assets/f7968f26-4cbf-4403-b0b9-ab3157beb81f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting more out of the Profilers</h1>
                </header>
            
            <article>
                
<p>The <span class="packt_screen">Profiler</span> window has several controls, segmented into left, center, and right sections of the interface. As you can see from the following screenshot, the <span class="packt_screen">Add Profiler</span> drop-down button consumes the left-most section of the <span class="packt_screen">Profiler</span> window's tool bar. We can use that button to add additional Profilers to the window:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f2a02fb2-5b96-403a-8f77-88ee4cbdb1fd.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Profiler Toolbar</div>
<p>The center section of the interface contains four functions, detailed here:</p>
<ul>
<li><span>Record</span><span>: This button is enabled by default and is used to record or not record the active game's Profile information. When troubleshooting a specific section of your game, this button makes it easy to start and stop recording.</span></li>
<li><span class="packt_screen">Deep Profile</span>: This function, when enabled, will Profile all script usage including function calls.</li>
<li><span class="packt_screen">Profile Editor</span>: This function allows you to toggle the profiling of the Profiler.</li>
<li><span class="packt_screen">Editor</span>: You can use this function to designate an IP address for the Profiler and log data to be sent. The default is for it to be sent to the editor.</li>
</ul>
<p>The right-most section of the <span class="packt_screen">Profiler</span> window's tool bar includes controls to <span class="packt_screen">Clear</span>, <span class="packt_screen">Load</span>, and <span class="packt_screen">Save</span> the Profiler information. If you selected a frame, the frame information will be displayed. You also have the ability to step through the frames using navigational buttons in this section.</p>
<div class="packt_infobox">Don't be surprised if your game performance is noticeably impacted when using the profiling tools.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing scripts</h1>
                </header>
            
            <article>
                
<p>Unity games run several frames per second and many of our scripts are executed each frame. Even uncomplicated games, such as the Cucumber Man, can have several scripts running every frame, causing the computer's CPU to stay very busy. The goal is to ensure our scripts are not causing any unnecessary CPU load.</p>
<p>Our game has 145 scripts, but most of them are part of the standard asset package and are not assigned to any game objects. The scripts we want to review are the ones we put in the <kbd>Assets</kbd> | <kbd>Custom Scripts</kbd> folder. Reviewing that folder reveals that there are only 14 scripts:</p>
<ul>
<li>BeetleManager</li>
<li>BeetleNPC</li>
<li>BeetlePatrol</li>
<li>CameraFollower</li>
<li>CherryControl</li>
<li>CherryManager</li>
<li>CucumberManager</li>
<li>CucumberManManager</li>
<li>HealthManager</li>
<li>PlayerController</li>
<li>PlayerMotor</li>
<li>PointsManager</li>
<li>ThrowCherry</li>
<li>VictoryManager</li>
</ul>
<p>Our goal is to reduce the number of instructions the CPU has to execute, especially when we are dealing with several executions per frame and multiple frames per second. Here are some things to check when reviewing your Unity scripts:</p>
<ul>
<li>Ensure all function calls are necessary.</li>
<li>As appropriate, move function calls out of the <kbd>Update()</kbd> method. </li>
<li>As appropriate, move statements out of loops to limit the number of times they are executed.</li>
<li>Use NPCs only as needed. Our game is relatively simple and we do not have hoards of cucumber beetles. You might try an experiment where there are 10,000 cucumber beetles in your game. Since each one of them has AI-associated code, the CPU will be very busy.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimized code example</h1>
                </header>
            
            <article>
                
<p>The following script is not optimized. Review the script to see what can be done to optimize it. Then, review the information provided after the script:</p>
<pre>public class CucumberManager : MonoBehavior {<br/>     public static int currentCucumberCount;<br/>     Text Cucumber_Count;<br/>     public GameObject[] cucumbers;<br/><br/>     void Update() {<br/>          Cucumber_Count = GetComponent&lt;Text&gt;();<br/>          currentCucumberCount = 1;<br/>          cucumbers = GameObject.FindGameObjectsWithTag("Cucumber");<br/>          Cucumber_Count.text = cucumbers.Length.ToString();<br/>          currentCucumberCount = cucumbers.Length;<br/>     }<br/>}</pre>
<p>Hopefully you were able to spot the inefficient, unoptimized component of the script. In the preceding example, all the statements other than the variable declarations occur in the <kbd>Update()</kbd> method. Consider the optimized version of the following script:</p>
<pre>public class CucumberManager : MonoBehavior {<br/>     public static int currentCucumberCount;<br/>     Text Cucumber_Count;<br/>     public GameObject[] cucumbers;<br/><br/>     void Awake() {<br/>          Cucumber_Count = GetComponent&lt;Text&gt;();<br/>          currentCucumberCount = 1;<br/>     }<br/><br/>      void Update() {<br/>           cucumbers = GameObject.FindGameObjectsWithTag("Cucumber");<br/>           Cucumber_Count.text = cucumbers.Length.ToString();<br/>           currentCucumberCount = cucumbers.Length;<br/>      }<br/>}</pre>
<p>In the optimized version of this script, the <kbd>GetComponent()</kbd> method call and the <kbd>currentCucumberCount</kbd> variable initialization are moved over to the <kbd>Awake()</kbd> method. Those statements only need to run once. Putting them inside the <kbd>Update()</kbd> method would have caused undue strain on the CPU.</p>
<p>It is important for a game's overall performance to have optimized scripts. Checking for script optimization at the end of a project is a good idea. Ideally, you will ensure your scripts are optimized as your write, as opposed to reviewing them later. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing graphics rendering</h1>
                </header>
            
            <article>
                
<p>Three graphics rendering concepts that should be explored when aiming to enhance game performance are occlusion culling, lighting, and mesh renderers. Each of these concepts are covered in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Occlusion culling</h1>
                </header>
            
            <article>
                
<p>Cameras are a critical game object in our Unity games. They allow the player to see the game environment. Unity works diligently during gameplay to render objects within a camera's frustum. Graphics rendering can represent a tremendous performance issue. It is therefore important that we pay special attention to our camera's o<span>cclusion culling</span> <span>parameter. When enabled, Unity will not render objects that are occluded, or not seen by the camera. An example would be objects inside a building. If the camera can currently only see the external walls of the building, then none of the objects inside those walls can be seen. So, it makes sense to not render those. We only want to render what is absolutely necessary to help ensure our game has smooth gameplay and no lag. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lighting</h1>
                </header>
            
            <article>
                
<p><span>When we create our scenes in Unity, we have three options for lighting. We can use real-time dynamic light, the baked lighting approach, or a mixture of real-time and baked. Our games perform more efficiently with baked lighting compared to real-time dynamic lighting, so if performance is a concern, try using baked lighting where you can.</span></p>
<p><span>Area lights are distinct from the other types of light in that they can only be baked. This means that real-time rendering will not take place during gameplay. The reason for this is to conduct all the processing regarding area lights prior to gameplay. This processing, if accomplished in a game in real time, would likely result in sufficient lag. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mesh renderer</h1>
                </header>
            
            <article>
                
<p><span>The mesh renderer</span> <span>component of a game object can be viewed in the Inspector panel. There are multiple settings that can be adjusted to enhance performance.</span></p>
<p><span>The</span> C<span>ast Shadows</span> <span>setting can be set to On, Off, Two-Sided, or Shadows Only. The default is On, so you should disable this for all objects that do not need to cast shadows. </span></p>
<p><span>The</span> r<span>eceive shadows</span> <span>is a toggle that tells Unity whether you want that object to receive shadows or not. As you would expect, this takes extra processing to display during the game. So, if you do not need an object to receive shadows, deselect this for greater performance.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional optimizations </h1>
                </header>
            
            <article>
                
<p>Two additional areas where you can optimize your game is with level of detail and using static colliders. Both of these concepts are discussed in the sections that follow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Level of detail</h1>
                </header>
            
            <article>
                
<p>Level of detail refers to how much detail is rendered on any given game object. The greater the number of polygons, the greater the level of detail your game objects will have. In order to reduce render times, you should consider what elements of detail need to be part of the 3D model and which ones can simply be included in the texture.</p>
<p>There are also <strong>level of detail</strong> (<strong>LOD</strong>) models. This is when you use multiple models of the same object in a game, each with a different level of detail. Think about a game where the player stands on the coast, looking at the horizon. A ship that is 12 miles away does not need the same level of detail as when it is just a few yards away. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static colliders</h1>
                </header>
            
            <article>
                
<p><span>Static colliders are game objects with a collider but without a rigidbody. As the name suggests, these game objects do not move. Because the physics engine knows these objects will not move, pre-calculations can be made to make the game more efficient.</span></p>
<p>So, to increase efficiency, you should strive to use static colliders when possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating builds</h1>
                </header>
            
            <article>
                
<p><span>Creating a build for your game is not complicated when you are working on your own projects. You essentially ensure your assets (for example, 3D models, textures, animations, and scripts) are on your computer and you use Unity to create the build. This process is much more complicated when you are working on large and distributed teams.  This section covers the individual developer where all assets are on a single computer.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the Unity build process</h1>
                </header>
            
            <article>
                
<p>The Unity build process seems pretty easy. We can simply select <span class="packt_screen">File | Build &amp; Run</span> from the top menu and get great results. Unity actually does a lot of work to create a build. Here are the basic steps the Unity game engine takes to create a build of your game:</p>
<ol>
<li>Generates a blank build copy of your game</li>
<li>Sequences through the scene list, optimizing them before integrating them with the build</li>
<li>Calculates and stores data regarding what assets are needed for each scene</li>
</ol>
<p>There are additional aspects of the build process that we should be aware of. For example, if we assign the EditorOnly tag to a game object, it will not be integrated into the build. </p>
<p>Once you have completed your game, you can select the <span class="packt_screen">Build &amp; Run</span> or <span class="packt_screen">Build Settings</span> options from the <span class="packt_screen">File</span> pull-down menu:</p>
<div class="CDPAlignCenter CDPAlign"><img height="145" width="105" src="assets/ec3ce22c-4007-433c-a364-4c7f5c7ab74b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Build settings</h1>
                </header>
            
            <article>
                
<p>We access the <span class="packt_screen">Build Settings</span> dialog window via the<span> </span><span class="packt_screen">File</span> | <span class="packt_screen">Build &amp; Run</span> <span>top menu option. With that interface open, displayed as follows, we can make several decisions regarding our build:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="339" width="360" src="assets/42684fa6-03d7-4485-829e-baaf079cc427.png"/></div>
<p>The top section of the <span class="packt_screen">Build Settings</span> interface lists the Scenes that will be included in the build. You can use the <span class="packt_screen">Add Open Scenes</span> button to quickly add those scenes to the build. You can also select and deselect scenes to ensure you only include the scenes needed for the build. </p>
<p>In the next section of <span>the</span> <span class="packt_screen">Build Settings</span> <span>interface, </span> you'll select a platform. Each of the platform options is covered in the next few sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PC, Mac, and Linux standalone</h1>
                </header>
            
            <article>
                
<p>For this platform group, you will need to select <span class="packt_screen">Mac OS X</span>, <span class="packt_screen">Windows</span>, or <span class="packt_screen">Linux</span>. As you can see from the following screenshot, each operating system selection has its own set of options:</p>
<div class="CDPAlignCenter CDPAlign"><img height="366" width="324" src="assets/ee2912fb-21d4-497c-8eab-3ceaf213ff37.png"/></div>
<p>For <span class="packt_screen">Mac OS X</span>, you will decide whether this is a development build or not. If it is, you will have the additional options of <span class="packt_screen">Autoconnect Profiler</span>, <span class="packt_screen">Script Debugging</span>, and <span class="packt_screen">Scripts Only Build</span>. </p>
<p>For <span class="packt_screen">Windows</span>, <span>you will select whether it is a 32-bit or 64-bit build and select whether you want to copy the PDB files. You will also decide whether this is a development build or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler</span><span>,</span> <span class="packt_screen">Script Debugging</span><span>, and</span> <span class="packt_screen">Scripts Only Build</span><span>. </span></p>
<p>For Linux<span>, </span><span>you will select whether it is a 32-bit, 64-bit, or Universal build. You will also decide whether this is a development build or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler</span><span>,</span> <span class="packt_screen">Script Debugging</span><span>, and</span> <span class="packt_screen">Scripts Only Build</span><span>. Lastly, you will select whether your build will support </span><span class="packt_screen">Headless Mode</span>.</p>
<div class="packt_infobox">Headless mode refers to a server-based game that does not contain visual elements.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">iOS</h1>
                </header>
            
            <article>
                
<p>When developing for iOS devices (iPad, iPad Pro, iPad Mini, iPhone, iPod Touch) you need to have Xcode installed on your computer. Xcode is also required for developing for macOS devices.</p>
<div class="packt_tip">You can obtain the latest version of Xcode here: <a href="https://developer.apple.com/develop/">https://developer.apple.com/develop/</a>.</div>
<p>Using the <span class="packt_screen">Build Settings</span> <span>interface, you can identify your version of Xcode and decide whether you want to run it as a release or in debug mode. You can decide whether you want your Xcode project to directly reference the Unity iOS runtime library from the Unity Editor's install location. This is accomplished by selecting the <span class="packt_screen">Symlink Unity libraries</span> checkbox. You should not use this for your final build:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="168" width="319" src="assets/7b3beafd-3f06-4156-b0c3-b6d5c1909a2c.png"/></div>
<p><span>You will also decide whether this is a development build or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler</span><span>,</span> <span class="packt_screen">Script Debugging</span><span>, and</span> <span class="packt_screen">Scripts Only Build</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">tvOS</h1>
                </header>
            
            <article>
                
<p>As you can see here, the options for tvOS are the same as iOS:</p>
<div class="CDPAlignCenter CDPAlign"><img height="155" width="310" src="assets/39e877b4-fe9b-42cf-969b-939340b924c0.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Android</h1>
                </header>
            
            <article>
                
<p>When developing for Android devices, you have several <span class="packt_screen">Texture Compression</span> options to choose from. You can also identify <span class="packt_screen">16-bit</span>, <span class="packt_screen">32-bit</span>, or 32-bit half resolution as the <span class="packt_screen">ETC2 fallback</span>. You can use the internal <span class="packt_screen">Build System</span> or Gradle, which is a build tool used in Android Studio and elsewhere:</p>
<div class="CDPAlignCenter CDPAlign"><img height="239" width="294" src="assets/8a0c9d51-6aca-4b79-9af1-5072d1b6f30a.png"/></div>
<p><span>You will also decide whether this is a development build or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler</span><span>,</span> <span class="packt_screen">Script Debugging</span><span>, and</span> <span class="packt_screen">Scripts Only Build</span><span>.</span></p>
<div class="packt_infobox">You can learn more about developing for Android devices here: <a href="https://developer.android.com/">https://developer.android.com/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTML 5/WebGL</h1>
                </header>
            
            <article>
                
<p>When developing for HTML 5/Web GL, you <span>will decide whether this is a <span class="packt_screen">Development Build</span> or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler </span><span>and</span> <span class="packt_screen">Scripts Only Build</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="102" width="290" src="assets/af3bdee8-929d-4e05-afb1-84925ccfc556.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Facebook</h1>
                </header>
            
            <article>
                
<p>When developing a Unity game that will be published on Facebook, you will need the Facebook SDK and an App ID. For Target Platform, you can select Gameroom (Windows) or WebGL:</p>
<div class="CDPAlignCenter CDPAlign"><img height="231" width="351" src="assets/a985aa8d-b02b-458f-8ee7-4466f6d05ede.png"/></div>
<p><span>You</span> <span>will also decide whether this is a development build or not. If it is, you will have the additional options of</span> <span class="packt_screen">Autoconnect Profiler </span><span>and</span> <span class="packt_screen">Scripts Only Build</span>.</p>
<div class="packt_tip packt_infobox">Consult the following URL for instructions on how to register and configure a Facebook app: <a href="https://developers.facebook.com/docs/apps/register">https://developers.facebook.com/docs/apps/register</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Xbox One</h1>
                </header>
            
            <article>
                
<p>Access to the Xbox One player is handled through the Microsoft ID@Xbox program. </p>
<div class="packt_infobox">Visit the following link to learn how to develop games for Xbox One: <a href="https://www.xbox.com/en-US/developers">https://www.xbox.com/en-US/developers</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayStation 4 and PlayStation Vita</h1>
                </header>
            
            <article>
                
<p>Access to PlayStation 4 and PlayStation Vita players is handled through Dev NET and requires a Unity Plus or Unity Pro license.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Player Settings</h1>
                </header>
            
            <article>
                
<p>Using the  <span class="packt_screen">Edit</span> | <span class="packt_screen">Project Settings</span> | <span class="packt_screen">Player</span> menu option, you have access to the Unity <span class="packt_screen">Player Settings</span> in the <span class="packt_screen">Inspector</span> panel. In this context, the term player does not refer to the person playing the game, but to the software that runs the game. </p>
<p>As you can see in the following screenshot, there are data fields for the name of the company and the game's title. Icons and cursors are also uploaded here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="225" width="345" src="assets/12d6aca0-86c6-4c3b-bf5b-1e0bcb93ac76.png"/></div>
<p>Beneath the general settings area of the <span class="packt_screen">PlayerSettings</span> <span>interface are six buttons. As you can see in the following image, there is one button for each of the platforms that Unity can generate a player for. This does not include Xbox or PlayStation players:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="147" width="255" src="assets/53aae3d3-9d7d-458c-b997-96deac20defe.png"/></div>
<p>For each of the platforms, there is a set of player configuration settings sections. This includes the following:</p>
<ul>
<li><span class="packt_screen">Resolution and Presentation</span></li>
<li><span><span class="packt_screen">Icon</span></span></li>
<li><span class="packt_screen">Splash Image</span></li>
<li><span class="packt_screen">Debugging and crash reporting</span></li>
<li><span class="packt_screen">Other Settings</span></li>
</ul>
<p><span>Not every settings section will be applicable to all platform types. Also, the Other Settings content varies based on the platform you are developing for.</span></p>
<p><span>If you are developing for multiple platforms, you will need to review the settings for each platform type. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we focused on optimization and deployment. We learned how t<span>o diagnose Unity games for performance problems and how to optimize scripts and graphic rendering. We also explored how to deploy our Unity games, including learning about the Unity build process, how to create a standalone player, and how to deploy games to multiple platforms.</span></p>
<p>In <a href="e8f846b8-9476-4203-9e96-83d8556c62b5.xhtml" target="_blank">Chapter 14</a>, <em>Virtual Reality</em>, <span>we will examine Unity's capabilities with regards to virtual reality. We will start with a quick introduction to virtual reality including hardware requirements, and then look at how to create a virtual reality game using the Unity game engine. We will also look at the available starter content from the Unity Asset Store.</span></p>


            </article>

            
        </section>
    </body></html>