- en: '*Chapter 15*: Working with Modularity'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 15 章*：使用模块化'
- en: Let me state at the beginning of this chapter – modular application development
    is hard work! We want to split a large system into smaller modules and isolate
    them from each other. However, then we will have difficulties when integrating
    these modules and making them communicate with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在本章的开头声明——模块化应用程序开发是一项艰巨的工作！我们希望将大型系统拆分成更小的模块并将它们彼此隔离。然而，在集成这些模块并使它们相互通信时，我们将会遇到困难。
- en: One of the fundamental design goals of ABP Framework is modularity. It provides
    the necessary infrastructure to build truly modular systems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架的一个基本设计目标是模块化。它提供了构建真正模块化系统的必要基础设施。
- en: This chapter will start with what modularity means and the levels of modularity
    in the .NET platform. In the largest part of the chapter, we will explore the
    Payment module that I've built for the EventHub reference solution. We will learn
    how the module is structured, the key points of application module development,
    and how to install the module into the main application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从模块化的含义和 .NET 平台的模块化级别开始。在章节的大部分内容中，我们将探讨我为 EventHub 参考解决方案构建的 Payment 模块。我们将学习模块的结构、应用程序模块开发的关键点以及如何将模块安装到主应用程序中。
- en: 'This chapter consists of the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主要主题：
- en: Understanding modularity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模块化
- en: Building the Payment module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Payment 模块
- en: Installing the Payment module into EventHub
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Payment 模块安装到 EventHub
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can clone or download the source code of the EventHub project from GitHub:
    [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 GitHub 上克隆或下载 EventHub 项目的源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).
- en: If you want to follow the examples in this chapter, you need to have an IDE/editor
    that supports ASP.NET Core development.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随本章的示例，你需要有一个支持 ASP.NET Core 开发的 IDE/编辑器。
- en: Finally, if you want to create modules with the ABP CLI, you should install
    it on your computer, as explained in the *Installing the ABP CLI* section of [*Chapter
    2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting Started with ABP Framework*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想使用 ABP CLI 创建模块，你应该按照 [*第 2 章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)
    中 *安装 ABP CLI* 部分的说明，在你的计算机上安装它。
- en: Understanding modularity
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模块化
- en: The term **module** is one of the most overused and overloaded concepts in the
    software industry. In this section, I want to explain what I mean by modularity
    in .NET and ABP Framework.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**可重用性**：构建一个模块并在多个应用程序中重用它，可以减少代码重复并节省时间。'
- en: 'Modularity is a software design technique to separate a large solution''s code
    base into smaller, isolated modules that can then be developed independently.
    There are two main reasons behind modular application development:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化是一种软件设计技术，用于将大型解决方案的代码库分解成更小、独立的模块，然后可以独立开发。模块化应用程序开发背后的两个主要原因是：
- en: '**Reducing complexity**: Splitting a large code base into a smaller and isolated
    set of modules makes it easy to develop and maintain the solution.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低复杂性**：将大型代码库拆分成更小、独立的模块集合，使得开发和维护解决方案变得容易。'
- en: '**Reusability**: Building a module and reusing it across multiple applications
    reduces code duplication and saves time.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是软件行业中用得最多、最复杂的概念之一。在本节中，我想解释在 .NET 和 ABP 框架中我所说的模块化是什么。
- en: 'In the next sections, I will discuss two different modularity levels from technical
    and design perspectives: class libraries (NuGet packages) and application modules.
    Let''s begin with class libraries.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将从技术和设计角度讨论两种不同的模块化级别：类库（NuGet 包）和应用模块。让我们从类库开始。
- en: Class libraries and NuGet packages
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类库和 NuGet 包
- en: Most programming languages and frameworks have the concept of a module. In general,
    a module is a set of code files (classes and other resources) developed and shipped
    (deployed) together.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言和框架都有模块的概念。一般来说，模块是一组代码文件（类和其他资源），它们被开发和一起分发（部署）。
- en: A module provides some components and services for a larger application. A module
    may depend on other modules and can use the components and services provided by
    the dependent modules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块为更大的应用程序提供一些组件和服务。一个模块可能依赖于其他模块，并可以使用依赖模块提供的组件和服务。
- en: In .NET, an assembly is a typical way to create a module. We can create a **class
    library project** and then use it within other libraries and applications. We
    can create NuGet packages for the class libraries and publish them on [NuGet.org](http://NuGet.org)
    publicly. If the library is not public, we can host a private NuGet server in
    our own company. A NuGet package system makes it extremely easy to add a library
    to a project. There are thousands of packages already published on [NuGet.org](http://NuGet.org).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，组件（assembly）是创建模块的一种典型方式。我们可以创建一个**类库项目**，然后在其他库和应用程序中使用它。我们可以为类库创建NuGet包，并在[NuGet.org](http://NuGet.org)上公开发布。如果库不是公开的，我们可以在自己的公司中托管一个私有NuGet服务器。NuGet包系统使得将库添加到项目中变得极其容易。在[NuGet.org](http://NuGet.org)上已经发布了成千上万的包。
- en: ABP Framework itself is designed to be modular. It consists of hundreds of NuGet
    packages; each provides different infrastructure features for your applications.
    Some example packages are `Volo.Abp.Validation`, `Volo.Abp.Authorization`, `Volo.Abp.Caching`,
    `Volo.Abp.EntityFrameworkCore`, `Volo.Abp.BlobStoring`, `Volo.Abp.Auditing`, and
    `Volo.Abp.Emailing`. You can use any package you need in your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架本身被设计成模块化的。它由数百个NuGet包组成；每个包都为您的应用程序提供不同的基础设施功能。一些示例包包括`Volo.Abp.Validation`、`Volo.Abp.Authorization`、`Volo.Abp.Caching`、`Volo.Abp.EntityFrameworkCore`、`Volo.Abp.BlobStoring`、`Volo.Abp.Auditing`和`Volo.Abp.Emailing`。您可以在应用程序中使用您需要的任何包。
- en: You can refer to the *Understanding modularity* section of [*Chapter 5*](B17287_05_Epub_AM.xhtml#_idTextAnchor146),
    *Exploring the ASP.NET Core and ABP Infrastructure* to learn about package-based
    ABP modules. The next section will discuss application modules, which typically
    consist of multiple packages (class library projects).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考[*第5章*](B17287_05_Epub_AM.xhtml#_idTextAnchor146)的*理解模块化*部分，*探索ASP.NET
    Core和ABP基础设施*，以了解基于包的ABP模块。下一节将讨论应用程序模块，通常由多个包（类库项目）组成。
- en: Application modules
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序模块
- en: 'We can think of an application module as a vertical slice of an application.
    An application module has the following attributes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将应用程序模块视为应用程序的一个垂直切片。应用程序模块具有以下属性：
- en: Defines some business objects (for example, aggregates, entities, and value
    objects)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一些业务对象（例如，聚合、实体和值对象）
- en: Implements business logic for the business objects it defines
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现它定义的业务对象所用的业务逻辑
- en: Provides database integration and mappings for the business objects
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为业务对象提供数据库集成和映射
- en: Contains application services, data transfer objects, and HTTP APIs (controllers)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含应用程序服务、数据传输对象和HTTP API（控制器）
- en: Can have user interface components and pages related to the functionality it
    provides
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以包含与它提供的功能相关的用户界面组件和页面
- en: May need to add new items to the application menu, layout, or toolbars on the
    UI
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能需要在UI的应用程序菜单、布局或工具栏中添加新项目
- en: Publishes and consumes distributed events
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和消费分布式事件
- en: May have more features and other details you expect from a regular application
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能具有更多功能和您期望从常规应用程序中获得的其他详细信息
- en: 'There are several *isolation levels* for an application module based on your
    requirements and goals. Four common examples are listed here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求和目标，应用程序模块有几种隔离级别。以下列出了四个常见示例：
- en: '**Tightly coupled modules**: A module can be a part of a large monolith application
    with a single database. You can use that module''s entities and services in other
    modules and perform database queries by joining the tables of that module. In
    this way, your modules become tightly coupled to each other.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合的模块**：一个模块可以是具有单个数据库的大型单体应用程序的一部分。您可以使用该模块的实体和服务在其他模块中使用，并通过连接该模块的表执行数据库查询。这样，您的模块就紧密耦合在一起了。'
- en: '**Bounded contexts**: A module can be a part of a large monolith application,
    but it hides its internal domain objects and database tables from other modules.
    Other modules can only use its integration services and subscribe to the events
    published by that module. They can''t use the database tables of the module in
    SQL queries. The module may even use a different kind of DBMS for its specific
    requirements. That is the bounded context pattern in domain-driven design. Such
    a module is a good candidate to convert to a microservice if you want to convert
    your monolith application to a microservice solution in the future.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界上下文**：一个模块可以是大型单体应用程序的一部分，但它隐藏其内部领域对象和数据库表，使其对其他模块不可见。其他模块只能使用其集成服务并订阅该模块发布的事件。它们不能在SQL查询中使用该模块的数据库表。该模块甚至可能使用不同类型的DBMS来满足其特定需求。这就是领域驱动设计中的边界上下文模式。如果将来您想将单体应用程序转换为微服务解决方案，这样的模块是转换为微服务的良好候选。 '
- en: '**Generic modules**: Generic modules are designed to be application-independent.
    They can be integrated into different kinds of applications. The application that
    uses the generic module can have some functionalities depending on that module,
    and it may need some integration code. A generic module may provide some options
    and customization points but doesn''t make assumptions about the final application.
    Infrastructure modules, such as identity management and multi-language modules,
    fall into this category. Also, the Payment module, which is explained in the *Building
    the Payment module* section, is a generic module.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用模块**：通用模块被设计为与应用程序无关。它们可以集成到不同类型的应用程序中。使用通用模块的应用程序可能依赖于该模块的一些功能，并且可能需要一些集成代码。通用模块可能提供一些选项和自定义点，但不对最终应用程序做出假设。例如，身份管理和多语言模块等基础设施模块属于此类。此外，在*构建支付模块*部分中解释的支付模块也是一个通用模块。'
- en: '**Plugin modules**: A plugin module is a completely isolated and reusable application
    module. Other modules have no direct dependency on that module. You can easily
    add this module to or remove it from an existing solution without affecting the
    other modules and your application. If other modules need to use that module,
    they use some standard abstractions provided in a shared library. In this case,
    the module implements the abstractions and can be replaced by another module that
    implements the same abstractions. Even if the other modules use that module somehow,
    they can continue to work as expected when removing that module. That means the
    module should be optional and removable for the application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件模块**：插件模块是一个完全隔离且可重用的应用程序模块。其他模块对该模块没有直接依赖。您可以轻松地将此模块添加到现有解决方案中或从现有解决方案中移除，而不会影响其他模块和您的应用程序。如果其他模块需要使用该模块，它们将使用共享库中提供的某些标准抽象。在这种情况下，该模块实现了这些抽象，可以被实现相同抽象的另一个模块所替换。即使其他模块以某种方式使用该模块，在移除该模块时，它们也可以继续按预期工作。这意味着该模块应该是可选的并且可以移除的，以便于应用程序。'
- en: 'One of ABP Framework''s main goals is to provide a convenient infrastructure
    to develop any kind of application module. It provides the necessary infrastructure
    details to build a truly modular system. It also provides some pre-built application
    modules you can directly reuse in your applications. Some examples are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ABP框架的主要目标之一是提供一个方便的基础设施来开发任何类型的应用程序模块。它提供了构建真正模块化系统所需的基础设施详细信息。它还提供了一些预构建的应用程序模块，您可以直接在您的应用程序中使用。以下是一些示例：
- en: An **account module** provides authentication features, such as login, register,
    forgot password, and social login integrations.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**账户模块**提供认证功能，例如登录、注册、忘记密码和社交登录集成。'
- en: An **identity module** manages users, roles, and their permissions in your system.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份模块**管理您系统中的用户、角色及其权限。'
- en: A **tenant management** module allows you to create and manage tenants in an
    SaaS/multi-tenant system.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**租户管理**模块允许您在SaaS/多租户系统中创建和管理租户。'
- en: A **CMS Kit** module can be used to add fundamental **Content Management System**
    (**CMS**) features into your application, such as pages, tags, comments, and blogs.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMS Kit**模块可用于将基本**内容管理系统（CMS**）功能添加到您的应用程序中，例如页面、标签、评论和博客。'
- en: Account, identity, tenant management, and some other modules are pre-installed
    (as NuGet packages) when creating a new ABP solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 账户、身份、租户管理和一些其他模块在创建新的ABP解决方案时预安装（作为NuGet包）。
- en: All pre-built modules are designed to be extensible and customizable. However,
    if you need to fully change a module based on your requirements, it is always
    possible to download the module's source code and include it in your solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有预构建的模块都设计为可扩展和可定制的。然而，如果你需要根据你的需求完全更改一个模块，总是可以下载模块的源代码并将其包含在你的解决方案中。
- en: In the next section, we will see how to build a new application module with
    its own entities, services, and pages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用自己的实体、服务和页面构建一个新的应用程序模块。
- en: Building the Payment module
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建`Payment`模块
- en: You can already investigate the source code of the pre-built ABP modules to
    see how they are built and used in your application. I suggest it because you
    can see different implementation details of modular development. However, this
    section will explore the Payment module, which has been created as a simple yet
    real-world example for this book. It is used by the EventHub solution to receive
    payment when an organization wants to upgrade to a premium account. It is not
    possible to show the step-by-step development of that module in a book. We will
    investigate the fundamental points so that you can understand the module structure
    and build your own modules. Let's start with creating a new application module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以调查预构建的ABP模块的源代码，看看它们是如何构建和在你的应用程序中使用的。我建议这样做，因为你可以看到模块化开发的不同的实现细节。然而，本节将探讨`Payment`模块，它已被创建为本书的一个简单但真实的示例。它被EventHub解决方案用于当组织想要升级到高级账户时接收支付。在书中不可能展示该模块的逐步开发过程。我们将研究基本点，以便你能够理解模块结构并构建你自己的模块。让我们从创建一个新的应用程序模块开始。
- en: Creating a new application module
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序模块
- en: 'The ABP CLI''s `new` command provides an option to create a new solution to
    build a reusable application module. See the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ABP CLI的`new`命令提供了一个选项来创建一个新的解决方案以构建可重用的应用程序模块。请看以下示例：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I''ve specified to use the module template (`-t module`) with the module name
    as `Payment`. If you open the solution, you will see the solution structure, as
    shown in the following figure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我指定使用模块模板（`-t module`），模块名称为`Payment`。如果你打开解决方案，你会看到解决方案结构，如下面的图所示：
- en: '![Figure 15.1 – A fresh application module created by the ABP CLI'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 – 由ABP CLI创建的新应用程序模块'
- en: '](img/Figure_15.1_B17287.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.1_B17287.jpg)'
- en: Figure 15.1 – A fresh application module created by the ABP CLI
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – 由ABP CLI创建的新应用程序模块
- en: 'The module startup template has too many projects because it supports multiple
    UI and database options and contains some test/demo projects. Let''s eliminate
    some of the projects:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 模块启动模板包含太多的项目，因为它支持多个UI和数据库选项，并包含一些测试/演示项目。让我们删除一些项目：
- en: The projects in the `host` folder are some demo applications to run the module
    in different architecture options. These projects are not parts of the module
    and are just for manual testing. We will install this module into the EventHub
    solution and test it there, so I deleted all host projects.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`文件夹中的项目是一些演示应用程序，用于在不同的架构选项中运行模块。这些项目不是模块的一部分，只是用于手动测试。我们将把这个模块安装到EventHub解决方案中并在那里测试它，所以我删除了所有主机项目。'
- en: I deleted the `Blazor.*` projects since my main UI will be MVC/Razor Pages.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我删除了`Blazor.*`项目，因为我的主要UI将是MVC/Razor Pages。
- en: I deleted the MongoDB-related projects since I only want to support EF Core
    with my module.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我删除了与MongoDB相关的项目，因为我只想用我的模块支持EF Core。
- en: Finally, I deleted the `angular` folder (not shown in *Figure 15.1*) since I
    don't want an Angular UI for this module.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我删除了`angular`文件夹（在*图15.1*中没有显示），因为我不想为这个模块使用Angular UI。
- en: 'After the cleanup, there are 12 projects in the module solution. Four of them
    are for unit and integration testing, so the module consists of eight projects
    that will be deployed. These eight projects are class library projects, so they
    can''t be run individually. They need to be used by an executable application,
    such as EventHub:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 清理后，模块解决方案中有12个项目。其中四个用于单元和集成测试，因此该模块由八个将部署的项目组成。这八个项目是类库项目，因此它们不能单独运行。它们需要由一个可执行应用程序使用，例如EventHub：
- en: '![Figure 15.2 – The Payment module after the cleanup'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.2 – 清理后的`Payment`模块'
- en: '](img/Figure_15.2_B17287.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.2_B17287.jpg)'
- en: Figure 15.2 – The Payment module after the cleanup
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 – 清理后的`Payment`模块
- en: This solution structure and layers were already explained in the *Structuring
    a .NET solution based on DDD* section of [*Chapter 9*](B17287_09_Epub_AM.xhtml#_idTextAnchor300),
    *Understanding Domain-Driven Design*. So, I won't repeat it all here. However,
    we will change this structure because we want to provide multiple application
    layers for the Payment module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案结构和层在[*第9章*](B17287_09_Epub_AM.xhtml#_idTextAnchor300)，*理解领域驱动设计*的*根据DDD结构化.NET解决方案*部分中已经解释过了。所以，这里我不会重复全部内容。然而，我们将改变这个结构，因为我们想为支付模块提供多个应用层。
- en: Restructuring the Payment module solution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新构建支付模块解决方案
- en: 'We will install this Payment module to the EventHub solution. Remember from
    [*Chapter 4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the Reference
    Solution*, that the EventHub solution has two UI applications:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个支付模块安装到EventHub解决方案中。记得从[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*，中了解到EventHub解决方案有两个UI应用程序：
- en: A public website that the end users of the system use to create and attend events.
    This application has an MVC/Razor Pages UI.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面向最终用户的公共网站，用户可以通过它创建和参加活动。该应用程序具有MVC/Razor Pages UI。
- en: An admin web application that is used by the administrative users of the EventHub
    system. This application is a Blazor WebAssembly application.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由EventHub系统的管理用户使用的管理Web应用程序。该应用程序是一个Blazor WebAssembly应用程序。
- en: 'To support the same architecture, we will provide two UI application layers
    for the Payment module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持相同的架构，我们将为支付模块提供两个UI应用层：
- en: An application layer with the MVC/Razor Pages UI that is used by the EventHub
    public website. End users will make payments with that UI.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含MVC/Razor Pages UI的应用层，该UI被EventHub公共网站使用。最终用户将通过该UI进行支付。
- en: An application layer with the Blazor WebAssembly UI that is used by the EventHub
    admin application. Administrative users will see the payment reports with that
    UI.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含Blazor WebAssembly UI的应用层，该UI被EventHub管理应用程序使用。管理用户将通过该UI查看支付报告。
- en: 'The following figure shows the final Payment solution structure after I added
    the admin-side layers and organized the solution folders:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了我在添加了管理端层并组织了解决方案文件夹后的最终支付解决方案结构：
- en: '![Figure 15.3 – The Payment module solution with admin-side'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 – 带有管理端面的支付模块解决方案'
- en: '](img/Figure_15.3_B17287.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.3_B17287.jpg)'
- en: Figure 15.3 – The Payment module solution with admin-side
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 带有管理端面的支付模块解决方案
- en: I added the `Payment.Admin.Application`, `Payment.Admin.Application.Contracts`,
    `Payment.Admin.Blazor`, `Payment.Admin.HttpApi`, and `Payment.Admin.HttpApi.Client`
    projects. I also added the `Payment.BackgroundServices` project to perform some
    periodic background workers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了`Payment.Admin.Application`、`Payment.Admin.Application.Contracts`、`Payment.Admin.Blazor`、`Payment.Admin.HttpApi`和`Payment.Admin.HttpApi.Client`项目。我还添加了`Payment.BackgroundServices`项目以执行一些周期性后台工作。
- en: The solution folders reflect the overall structure – the `admin` application
    (with Blazor UI) and `www` (public) application (with MVC/Razor Pages UI). The
    `common` folder is used in both applications, so we share the same domain layer
    and database integration code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案文件夹反映了整体结构——`admin`应用程序（带有Blazor UI）和`www`（公共）应用程序（带有MVC/Razor Pages UI）。`common`文件夹在两个应用程序中都被使用，所以我们共享相同的领域层和数据库集成代码。
- en: We've learned about the overall structure of the Payment solution. In the next
    section, you will learn the details of the payment process.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了支付解决方案的整体结构。在下一节中，你将了解支付过程的细节。
- en: Understanding the payment process
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解支付过程
- en: The only responsibility of the Payment module is to take a payment from the
    user. It internally uses PayPal as the payment gateway. The Payment module is
    generic and can be used by any kind of application. The application that uses
    the Payment module should include some integration logic that starts the payment
    process and handles the payment result. In this section, I will explain the process
    based on the EventHub integration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 支付模块的唯一责任是从用户那里收取支付。它内部使用PayPal作为支付网关。支付模块是通用的，可以被任何类型的应用程序使用。使用支付模块的应用程序应包含一些集成逻辑，以启动支付过程并处理支付结果。在本节中，我将基于EventHub集成来解释这个过程。
- en: The EventHub application uses the Payment module to get a payment from a user
    to upgrade a free organization account to a premium organization account. As you
    can guess, premium organizations have more rights in the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: EventHub应用程序使用支付模块从用户那里获取支付，以将免费组织账户升级为高级组织账户。正如你所猜到的，高级组织在应用程序中拥有更多权利。
- en: 'If you are the owner of an organization and visit the organization details
    page, you will see an **Upgrade to Premium** button on the page, as shown in the
    following figure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – The EventHub organization details page'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.4_B17287.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – The EventHub organization details page
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Upgrade to Premium** button, you are redirected to
    the pricing page:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – The EventHub pricing page'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.5_B17287.png)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – The EventHub pricing page
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the account types and their differences. When we click the
    **Upgrade to Premium** button here, we are redirected to the pre-checkout page,
    which is defined by the Payment module:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The pre-checkout page'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.6_B17287.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – The pre-checkout page
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The pre-checkout page is normally located inside the Payment module and is developed
    to be application-independent. We can redirect the user to the pre-checkout page
    with a URL such as `/Payment/PreCheckout?paymentRequestId=3a002186-cb04-eb46-7310-251e45fc6aed`.
    However, we should first obtain a payment request ID using the `CreateAsync` method
    of the `IPaymentRequestAppService` service. This is done in the `Pages/Pricing.cshtml.cs`
    file of the `EventHub.Web` project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The EventHub application overrides the view (UI) part to make it fit better
    into EventHub''s UI design. This is an example of customizing a module in a final
    application. The EventHub application defines `PreCheckout.cshtml` and `PostCheckout.cshtml`
    files under the `Pages/Payment` folder, as shown in the following figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Overriding the Payment module''s checkout views'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.7_B17287.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – Overriding the Payment module's checkout views
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: They automatically override the corresponding Payment pages (because they are
    located exactly within the same path defined by the Payment module). These pages
    have no `.cshtml.cs` files here because we don't want to change the behavior of
    the page; we just want to change the view side.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the main components and the flow used for the payment
    process:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – The payment flow'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.8_B17287.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – The payment flow
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When we click the **Upgrade to Premium** button on the Pricing page (in *Figure
    15.5*), it redirects to the Checkout page of the Payment module. When we click
    the **Checkout** button (in *Figure 15.6*) on that page, we are redirected to
    PayPal, the payment system used and integrated by the Payment module. Once we
    complete the payment on PayPal, we are redirected back to the post-checkout page
    of the application, which shows a thank you message to the user.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: When a payment process succeeds, the Payment module publishes a distributed
    event named `PaymentRequestCompletedEto` (defined in the `Payment.Domain.Shared`
    project). The EventHub application subscribes to this event (with the `PaymentRequestEventHandler`
    class inside the `EventHub.Domain` project). It finds the user and organization
    related to the completed payment, upgrades the organization, and sends an email
    to thank the user for upgrading the account.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当支付过程成功时，支付模块发布一个名为 `PaymentRequestCompletedEto` 的分布式事件（在 `Payment.Domain.Shared`
    项目中定义）。EventHub 应用程序订阅此事件（在 `EventHub.Domain` 项目中的 `PaymentRequestEventHandler`
    类内部）。它找到与完成支付相关的用户和组织，升级组织，并发送电子邮件感谢用户升级账户。
- en: There can be an error when returning from PayPal to our application in some
    rare cases, where we cannot know whether the payment process has succeeded. For
    such cases, the Payment module provides a `PaymentRequestController` (in the `Payment.HttpApi`
    project). If the operation succeeds, the same `PaymentRequestCompletedEto` event
    is published so that the EventHub application can upgrade the organization account
    asynchronously.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见情况下，从 PayPal 返回到我们的应用程序时可能会出现错误，我们无法知道支付过程是否成功。对于此类情况，支付模块提供了一个 `PaymentRequestController`（位于
    `Payment.HttpApi` 项目中）。如果操作成功，将发布相同的 `PaymentRequestCompletedEto` 事件，以便 EventHub
    应用程序可以异步升级组织账户。
- en: In the next section, we will see how the Payment module provides options to
    configure it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到支付模块如何提供配置选项。
- en: Providing configuration options
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供配置选项
- en: 'The Payment module uses PayPal, so it needs the PayPal account information
    that the application must configure. It follows the options pattern (see the *Implementing
    the options pattern* section of [*Chapter 5*](B17287_05_Epub_AM.xhtml#_idTextAnchor146),
    *Exploring the ASP.NET Core and ABP Infrastructure*) and provides the `PayPalOptions`
    class that can be configured by the application, as shown in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 支付模块使用 PayPal，因此它需要应用程序必须配置的 PayPal 账户信息。它遵循选项模式（见 [*第 5 章*](B17287_05_Epub_AM.xhtml#_idTextAnchor146)，*探索
    ASP.NET Core 和 ABP 基础设施）中的 *实现选项模式* 部分），并提供了一个 `PayPalOptions` 类，该类可以被应用程序配置，如下例所示：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We generally get the values from the configuration (the `appsettings.json`
    file). The Payment module can get the option values from the `Payment:PayPal`
    key if you''ve defined it, as in the following example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常从配置（`appsettings.json` 文件）中获取值。如果你已经定义了它，支付模块可以从 `Payment:PayPal` 键获取选项值，如下例所示：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is made possible with the following code, located in the `PaymentDomainModule`
    class of the `Payment.Domain` project:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下代码实现，该代码位于 `Payment.Domain` 项目的 `PaymentDomainModule` 类中：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Getting the values from the configuration by default is a good practice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下从配置中获取值是一种良好的做法。
- en: I've introduced the main points of the Payment module's structure. Its code
    base is not so different from a typical ABP application. You can explore its source
    code to understand how it internally works. In the next section, we will see how
    it is installed in the EventHub application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经介绍了支付模块结构的主要要点。其代码库与典型的 ABP 应用程序没有太大区别。你可以探索其源代码来了解其内部工作原理。在下一节中，我们将看到它如何在
    EventHub 应用程序中安装。
- en: Installing the Payment module into EventHub
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将支付模块安装到 EventHub
- en: A module itself is not a runnable project. It should be installed into a larger
    application and work as part of it. In this section, we will see how the Payment
    module is installed in the EventHub solution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模块本身不是一个可运行的项目。它应该安装到更大的应用程序中，并作为其一部分工作。在本节中，我们将看到支付模块是如何在 EventHub 解决方案中安装的。
- en: Setting the project dependencies
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目依赖项
- en: The Payment module consists of more than 10 projects in its solution (see *Figure
    15.3*). Similarly, the EventHub solution has a lot of projects with three applications
    – the admin-side, the public, and the account (`IdentityServer`) applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 支付模块在其解决方案中包含超过 10 个项目（见 *图 15.3*）。同样，EventHub 解决方案包含许多项目，有三个应用程序——管理端、公共端和账户（`IdentityServer`）应用程序。
- en: 'I want to integrate the Payment module into the EventHub solution in all layers.
    Typically, each layer of the EventHub solution should depend on (use) the corresponding
    layer of the Payment module. The following table shows all the dependencies of
    the EventHub projects to the Payment module projects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我想将支付模块集成到 EventHub 解决方案的所有层中。通常，EventHub 解决方案中的每一层都应该依赖于（使用）支付模块的相应层。以下表格显示了
    EventHub 项目对支付模块项目的所有依赖关系：
- en: '![Figure 15.9 – EventHub and Payment module project dependencies'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 15.9 – EventHub and Payment module project dependencies]'
- en: '](img/Figure_15.9_B17287.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_15.9_B17287.jpg]'
- en: Figure 15.9 – EventHub and Payment module project dependencies
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 – EventHub和支付模块项目依赖
- en: So, we should add project references one by one. For example, we add the `Payment.Domain`
    project dependency to the `EventHub.Domain` project. This way, we can use Payment
    module entities in our application's domain layer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该逐个添加项目引用。例如，我们将`Payment.Domain`项目依赖项添加到`EventHub.Domain`项目中。这样，我们就可以在我们的应用程序域层中使用支付模块的实体。
- en: 'Visual Studio doesn''t properly support adding a local project dependency to
    a project from outside of a solution (I call it an external project dependency).
    However, we can manually add `ProjectReference` elements into the `csproj` file
    of the target project. So, we can add the following line into the `EventHub.Domain.csproj`
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio不支持从解决方案外部（我称之为外部项目依赖）向项目添加本地项目依赖项。然而，我们可以手动将`ProjectReference`元素添加到目标项目的`csproj`文件中。因此，我们可以将以下行添加到`EventHub.Domain.csproj`文件中：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we add such an external project dependency, Visual Studio cannot automatically
    resolve it. We should open a command-line terminal and run the `dotnet restore`
    command. This command is only required when you add a new dependency or remove
    an existing dependency. In addition, if you want to build the EventHub solution
    with the Payment module, you can use the `dotnet build /graphBuild` command. While
    this is rarely needed, it can save the day when Visual Studio cannot resolve some
    types in the dependent module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加这样的外部项目依赖项时，Visual Studio无法自动解析它。我们应该打开命令行终端并运行`dotnet restore`命令。此命令仅在您添加新依赖项或删除现有依赖项时需要。此外，如果您想使用支付模块构建EventHub解决方案，可以使用`dotnet
    build /graphBuild`命令。虽然这很少需要，但它可以在Visual Studio无法解析依赖模块中的某些类型时救命。
- en: 'Once we add a project reference, we should also add the ABP module dependency.
    The following code block shows the `PaymentDomainModule` dependency of the `EventHubDomainModule`
    class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了项目引用，我们也应该添加ABP模块依赖。以下代码块显示了`EventHubDomainModule`类的`PaymentDomainModule`依赖项：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We should manually set up all the project dependencies, as explained here. The
    next step is to configure the database tables for the Payment module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应手动设置所有项目依赖项，如这里所述。下一步是配置支付模块的数据库表格。
- en: Configuring the database integration
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数据库集成
- en: The Payment module needs some database tables to work properly. We can use the
    main EventHub database to store the Payment module's tables. With this approach,
    we will have a single database for the system. Alternatively, we can create a
    separate database for the Payment module so that we have two databases. The EventHub
    solution prefers the first approach since it is simpler to implement and manage.
    However, I will also show how we would implement the separate database approach.
    Let's begin with the single database approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 支付模块需要一些数据库表格才能正常工作。我们可以使用主EventHub数据库来存储支付模块的表格。采用这种方法，我们将为系统拥有一个单一数据库。或者，我们可以为支付模块创建一个单独的数据库，这样我们就有两个数据库。EventHub解决方案更喜欢第一种方法，因为它更容易实现和管理。然而，我还会展示我们如何实现单独的数据库方法。让我们从单一数据库方法开始。
- en: Using a single database
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单个数据库
- en: In this section, I will show you how we create the Payment tables in the main
    database of the EventHub application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示我们如何在EventHub应用程序的主数据库中创建支付表格。
- en: 'The EventHub solution has an `EventHubDbContext` class inside the `EventHub.EntityFrameworkCore`
    project, which is the main class that maps the entities to the database tables.
    The Payment module defines a `ConfigurePayment` extension method that we call
    from the `OnModelCreating` method of our `DbContext` class to include the Payment
    database mapping model in our main database model (see the `EventHubDbContext`
    class in the `EventHub.EntityFrameworkCore` project):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: EventHub解决方案在`EventHub.EntityFrameworkCore`项目中包含一个`EventHubDbContext`类，这是将实体映射到数据库表格的主要类。支付模块定义了一个`ConfigurePayment`扩展方法，我们从`DbContext`类的`OnModelCreating`方法中调用它，以将支付数据库映射模型包含到我们的主数据库模型中（请参阅`EventHub.EntityFrameworkCore`项目中的`EventHubDbContext`类）：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, `builder.ConfigurePayment()` is defined by the Payment module (in the
    `PaymentDbContextModelCreatingExtensions` class of the `Payment.EntityFrameworkCore`
    project). After adding this line inside the `OnModelCreating` method, we can add
    a new database migration to the EventHub solution using the following command
    in a command-line terminal (we run this command in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`builder.ConfigurePayment()` 由支付模块定义（在 `Payment.EntityFrameworkCore` 项目的
    `PaymentDbContextModelCreatingExtensions` 类中）。在 `OnModelCreating` 方法内添加此行后，我们可以使用以下命令行终端中的命令将新的数据库迁移添加到
    EventHub 解决方案中（我们在 `EventHub.EntityFrameworkCore` 项目的 `root` 文件夹中运行此命令）：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command creates a new migration file. Then, we can apply the new migration
    against the database using the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个新的迁移文件。然后，我们可以使用以下命令对数据库应用新的迁移：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's all. The Payment module will use the main EventHub database to store
    its data. This way, we will have a single database that contains all the tables
    of the application. In the next section, we will discuss the separate database
    approach.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了。支付模块将使用主 EventHub 数据库来存储其数据。这样，我们将有一个包含应用程序所有表的单一数据库。在下一节中，我们将讨论单独的数据库方法。
- en: Using a separate database
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单独的数据库
- en: In this section, we will see how to change the EventHub solution to use a separate
    database for the Payment module. The EventHub solution uses PostgreSQL as the
    database provider. We will use Microsoft's SQL Server for the Payment module.
    This way, you will learn how to work with multiple database providers in a single
    application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何将 EventHub 解决方案更改为为支付模块使用单独的数据库。EventHub 解决方案使用 PostgreSQL 作为数据库提供者。我们将使用
    Microsoft 的 SQL Server 作为支付模块。这样，你将学习如何在单个应用程序中与多个数据库提供者一起工作。
- en: 'I made the changes in a separate branch and created a draft **Pull Request**
    (**PR**) on GitHub so that you can see all the changes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一个单独的分支中做出了这些更改，并在 GitHub 上创建了一个草稿 **Pull Request**（**PR**），这样你就可以看到所有更改：
- en: 'GitHub branch URL: [https://github.com/volosoft/eventhub/tree/payment-sepr-db](https://github.com/volosoft/eventhub/tree/payment-sepr-db)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GitHub 分支 URL: [https://github.com/volosoft/eventhub/tree/payment-sepr-db](https://github.com/volosoft/eventhub/tree/payment-sepr-db)'
- en: 'PR URL: [https://github.com/volosoft/eventhub/pull/74](https://github.com/volosoft/eventhub/pull/74)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PR URL: [https://github.com/volosoft/eventhub/pull/74](https://github.com/volosoft/eventhub/pull/74)'
- en: Here, I will point out the fundamental changes I've made. You can see the PR
    on GitHub for all the changes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将指出我做出的基本更改。你可以在 GitHub 上的 PR 中查看所有更改。
- en: 'To begin with, I''ve created a second `DbContext` class, named `EventHubPaymentDbContext`,
    in the `EventHub.EntityFrameworkCore` project to manage the database migrations:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在 `EventHub.EntityFrameworkCore` 项目中创建了一个名为 `EventHubPaymentDbContext` 的第二个
    `DbContext` 类，以管理数据库迁移：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This class replaces `IPaymentDbContext` (defined by the Payment module) using
    the `[ReplaceDbContext]` attribute and implementing the `IPaymentDbContext` interface.
    It also declares the `[ConnectionStringName]` attribute to use the `Payment` connection
    string name instead of `Default` in the `appsettings.json` files. Finally, it
    calls the `modelBuilder.ConfigurePayment()` extension method of the Payment module
    to configure the database mappings.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用 `[ReplaceDbContext]` 属性替换了由支付模块定义的 `IPaymentDbContext`，并实现了 `IPaymentDbContext`
    接口。它还声明了 `[ConnectionStringName]` 属性，在 `appsettings.json` 文件中使用 `Payment` 连接字符串名称而不是
    `Default`。最后，它调用了支付模块的 `modelBuilder.ConfigurePayment()` 扩展方法来配置数据库映射。
- en: The Payment module was designed to be independent of any specific `Volo.Abp.EntityFrameworkCore`
    package, which is DBMS-agnostic. Since I wanted to use a SQL Server database,
    I've added the `Volo.Abp.EntityFrameworkCore.SqlServer` package dependency to
    the `EventHub.EntityFrameworkCore` project. I also added `AbpEntityFrameworkCoreSqlServerModule`
    to the `DependsOn` attribute of the `EventHubEntityFrameworkCoreModule` class
    since ABP requires it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 支付模块被设计成独立于任何特定的 `Volo.Abp.EntityFrameworkCore` 包，它是数据库管理系统无关的。由于我想使用 SQL Server
    数据库，我已经将 `Volo.Abp.EntityFrameworkCore.SqlServer` 包依赖项添加到 `EventHub.EntityFrameworkCore`
    项目中。我还将 `AbpEntityFrameworkCoreSqlServerModule` 添加到 `EventHubEntityFrameworkCoreModule`
    类的 `DependsOn` 属性中，因为 ABP 需要它。
- en: 'EF Core''s command-line tool requires creating a `DbContext` factory class
    to create an instance of the related `DbContext` class when we run its commands.
    You can see the `EventHubPaymentDbContextFactory` class in the source code. It
    uses the `Payment` connection string and the `UseSqlServer` extension method to
    configure SQL Server as the database provider. With this change, we should add
    the `Payment` connection string in the `EventHub.DbMigrator` project''s `appsettings.json`
    file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core 的命令行工具需要创建一个 `DbContext` 工厂类，以便在运行其命令时创建相关 `DbContext` 类的实例。您可以在源代码中看到
    `EventHubPaymentDbContextFactory` 类。它使用 `Payment` 连接字符串和 `UseSqlServer` 扩展方法来配置
    SQL Server 作为数据库提供程序。通过这个更改，我们应该在 `EventHub.DbMigrator` 项目的 `appsettings.json`
    文件中添加 `Payment` 连接字符串：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ABP will automatically obtain the `Payment` connection string for the new `DbContext`
    class because it has the `ConnectionStringName` attribute (the value of `PaymentDbProperties.ConnectionStringName`
    is `Payment`). I also need to add the `Payment` connection string to all the `appsettings.json`
    files in which I have defined the `Default` connection string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 将自动获取新 `DbContext` 类的 `Payment` 连接字符串，因为它具有 `ConnectionStringName` 属性（`PaymentDbProperties.ConnectionStringName`
    的值是 `Payment`）。我还需要将 `Payment` 连接字符串添加到所有我已经定义了 `Default` 连接字符串的 `appsettings.json`
    文件中。
- en: 'I should register the new `EventHubPaymentDbContext` class to the dependency
    injection system and configure it. To do that, I''ve changed the `ConfigureServices`
    method of the `EventHubEntityFrameworkCoreModule` class, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该将新的 `EventHubPaymentDbContext` 类注册到依赖注入系统中并配置它。为此，我已更改 `EventHubEntityFrameworkCoreModule`
    类的 `ConfigureServices` 方法，如下所示：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AddAbpDbContext<EventHubPaymentDbContext>()` call registers the new `DbContext`
    class. I also added the `Configure<EventHubPaymentDbContext>(…)` block to use
    SQL Server for this `DbContext` class. Other `DbContext` classes will continue
    to use PostgreSQL (the `UseNpgsql()` call globally configures all `DbContext`
    classes).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAbpDbContext<EventHubPaymentDbContext>()` 调用注册了新的 `DbContext` 类。我还添加了 `Configure<EventHubPaymentDbContext>(…)`
    块来为这个 `DbContext` 类使用 SQL Server。其他 `DbContext` 类将继续使用 PostgreSQL（全局配置所有 `DbContext`
    类的 `UseNpgsql()` 调用）。'
- en: 'The `EventHub.DbMigrator` application executes database migrations for the
    main database. Now, we''ve got a second database and we want to change the `EventHub.DbMigrator`
    application so that it also executes database migrations for the Payment module''s
    database. The change is simple; I''ve added the following code block inside the
    `EntityFrameworkCoreEventHubDbSchemaMigrator` class''s `MigrateAsync` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventHub.DbMigrator` 应用程序为主数据库执行数据库迁移。现在，我们有了第二个数据库，我们想要更改 `EventHub.DbMigrator`
    应用程序，使其也执行支付模块数据库的数据库迁移。更改很简单；我在 `EntityFrameworkCoreEventHubDbSchemaMigrator`
    类的 `MigrateAsync` 方法内部添加了以下代码块：'
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class is used by the `EventHub.DbMigrator` application while migrating
    the databases. So, by adding this code block, the new database is also migrated
    when I run the `EventHub.DbMigrator` application.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在 `EventHub.DbMigrator` 应用程序迁移数据库时使用。因此，通过添加这个代码块，当运行 `EventHub.DbMigrator`
    应用程序时，新的数据库也会被迁移。
- en: 'As a final change, I will remove the Payment tables from the main EventHub
    database and the following line from the `EventHubDbContext` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的更改，我将从主 EventHub 数据库中移除支付表格，并从 `EventHubDbContext` 类中移除以下行：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, I can use EF Core''s command-line tool to create a database migration
    (in the `root` folder of the `EventHub.EntityFrameworkCore` project):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以使用 EF Core 的命令行工具创建数据库迁移（在 `EventHub.EntityFrameworkCore` 项目的 `root` 文件夹中）：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Differing from standard usage, I added the `--context EventHubDbContext` parameter.
    I specify the `DbContext` type because there are two `DbContext` classes in the
    `EventHub.EntityFrameworkCore` project. Once it creates the migration (which drops
    the Payment tables), I can apply changes to the database using the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准用法不同，我添加了 `--context EventHubDbContext` 参数。我指定 `DbContext` 类型，因为 `EventHub.EntityFrameworkCore`
    项目中有两个 `DbContext` 类。一旦创建迁移（删除支付表格），我就可以使用以下命令对数据库应用更改：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, the main database has no Payment tables. But we haven''t created the payment
    database yet. To do that, I can use EF Core''s command-line tool to create a database
    migration for the payment database (in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，主数据库没有支付表格。但我们还没有创建支付数据库。为此，我可以使用 EF Core 的命令行工具为支付数据库创建数据库迁移（在 `EventHub.EntityFrameworkCore`
    项目的 `root` 文件夹中）：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, in addition to the `context` parameter that specifies the `EventHubPaymentDbContext`
    type, I set the `output-dir` parameter to specify the folder to create the migrations
    classes in it. The default folder name is `Migrations`, but this is used by the
    `EventHubDbContext` class, so I can''t use it. I specify `MigrationsPayment` as
    the folder name. The following figure shows the new migration folder in the `EventHub.EntityFrameworkCore`
    project:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，除了指定`EventHubPaymentDbContext`类型的`context`参数之外，我还设置了`output-dir`参数以指定创建迁移类的文件夹。默认文件夹名称是`Migrations`，但这个名称被`EventHubDbContext`类使用，所以我不能使用它。我将文件夹名称指定为`MigrationsPayment`。以下图显示了`EventHub.EntityFrameworkCore`项目中的新迁移文件夹：
- en: '![Figure 15.10 – The migration folder for the Payment module'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10 – 支付模块的迁移文件夹'
- en: '](img/Figure_15.10_B17287.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.10_B17287.jpg)'
- en: Figure 15.10 – The migration folder for the Payment module
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 – 支付模块的迁移文件夹
- en: 'Now, I can use the following command (in the `root` folder of the `EventHub.EntityFrameworkCore`
    project):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以在`EventHub.EntityFrameworkCore`项目的`root`文件夹中使用以下命令：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If I check the database, I can see the Payment module''s table (it has a single
    database table):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我检查数据库，我可以看到支付模块的表（它只有一个数据库表）：
- en: '![Figure 15.11 – The Payment module''s table in its own database'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11 – 支付模块在其自己的数据库中的表'
- en: '](img/Figure_15.11_B17287.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.11_B17287.jpg)'
- en: Figure 15.11 – The Payment module's table in its own database
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 – 支付模块在其自己的数据库中的表
- en: The separate database configuration is done. Now, the Payment module will use
    the new SQL Server database while the rest of the application will continue to
    work with the main PostgreSQL database.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的数据库配置已完成。现在，支付模块将使用新的SQL Server数据库，而应用程序的其他部分将继续与主PostgreSQL数据库一起工作。
- en: Using DbMigrator
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DbMigrator
- en: I've used the `dotnet ef` command-line tool to update the database schema. However,
    we can also run the `DbMigrator` application to apply the changes to the databases.
    Since we've also changed the `EntityFrameworkCoreEventHubDbSchemaMigrator` class
    to support the second database, `DbMigrator` can migrate the database schemas
    for both databases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用`dotnet ef`命令行工具更新了数据库模式。然而，我们也可以运行`DbMigrator`应用程序以将更改应用到数据库中。由于我们还将`EntityFrameworkCoreEventHubDbSchemaMigrator`类更改为支持第二个数据库，因此`DbMigrator`可以迁移两个数据库的模式。
- en: By creating new migration `DbContext` classes, as explained here, you can set
    up other modules to use their own databases. I added the new `DbContext` class
    in the same `EventHub.EntityFrameworkCore` project; however, we could create a
    new project for the new `DbContext` class and manage the migrations inside it.
    In that case, we don't need to specify the context and the `output-dir` parameters
    for the EF Core commands. However, I suggest going with a single project to minimize
    the projects within the solution, as it already has a lot.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建新的迁移`DbContext`类，如这里所述，您可以设置其他模块使用它们自己的数据库。我在同一个`EventHub.EntityFrameworkCore`项目中添加了新的`DbContext`类；然而，我们也可以为新的`DbContext`类创建一个新的项目，并在其中管理迁移。在这种情况下，我们不需要为EF
    Core命令指定上下文和`output-dir`参数。然而，我建议使用单个项目以最小化解决方案中的项目数量，因为它已经有很多了。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I started by explaining what modularity means and what bounded
    context, tightly coupled, generic, and plugin modules are. We've learned how to
    create a new module using the ABP CLI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我首先解释了模块化的含义以及边界上下文、紧密耦合、通用和插件模块是什么。我们学习了如何使用ABP CLI创建一个新的模块。
- en: We then explored the structure of the Payment module and understood how it is
    integrated into the EventHub solution. We've learned the steps of manually installing
    the Payment module to the EventHub solution by setting up the project dependencies.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了支付模块的结构，并了解了它是如何集成到EventHub解决方案中的。我们学习了通过设置项目依赖关系手动将支付模块安装到EventHub解决方案中的步骤。
- en: Finally, we've seen two approaches to using the payment database tables. The
    single database approach is simple and shares the same database between the EventHub
    application and the Payment module. On the other hand, the separate database approach
    allows us to use a dedicated database for the payment tables, making it possible
    to use a different DBMS for the Payment module than the main application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了两种使用支付数据库表的方法。单一数据库方法简单，EventHub应用程序和支付模块共享相同的数据库。另一方面，单独的数据库方法允许我们为支付表使用专用数据库，使得可以在支付模块中使用与主应用程序不同的DBMS。
- en: 'I suggest checking the source code of the Payment module and the EventHub solutions
    to understand all the details of their structure. I also suggest you check the
    ABP documentation to understand modularity better and learn the best practices
    to build reusable, generic application modules: [https://docs.abp.io/en/abp/latest/Best-Practices/Index](https://docs.abp.io/en/abp/latest/Best-Practices/Index).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您检查支付模块和EventHub解决方案的源代码，以了解它们结构的所有细节。我还建议您查阅ABP文档，以更好地理解模块化，并学习构建可重用、通用应用模块的最佳实践：[https://docs.abp.io/en/abp/latest/Best-Practices/Index](https://docs.abp.io/en/abp/latest/Best-Practices/Index).
- en: In the next chapter, we will explore multi-tenancy, which is used to build SaaS
    applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多租户的概念，这是构建SaaS应用的关键。
