<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor318"/>9</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor319"/>Exploring Domain-Driven Design and Semantics</h1>
<p>The previous chapter ended with a promise to provide a method to deal with a pivotal format and the design of an evolution-ready, functionally correct entity when no standard exists in this precise domain. This is the subject of our present chapter.</p>
<p>In order to reach this objective, a very important prerequisite is to keep thinking in <em class="italic">functional terms</em>. I know most of you will certainly have a technical background and may wonder when we are finally going to get to the code. Having you wait this long without doing anything technical has been done on purpose and is part of the pedagogical journey provided by the reading of this book. You have to stick to functional and business-related concepts as long as you can because, as soon as you transform this knowledge into software, it gets solidified and way harder to modify afterward. I promise that, as soon as the next chapter, we will start getting our hands dirty with some technical decisions. Then, in a few chapters, we will put some code together to actually show in very concrete terms what all this translates into. But for now, let’s stick to business functions only and think about our format without any relationship to anything technical, just like we are taught by clean architecture. This is the main guarantee we have to build the right information system. Actually, if you remember only one thing from this whole book, I would love it to be this practice: think as long as you need to understand your problem from the functional point of view, and only then start thinking about how to deal with it from a technical point of view. Delay implementation as much as possible; think of data, not databases; think of models and business rules, not attributes and methods.</p>
<p>If you do so, you will soon have some questions about the vocabulary used in the business domain. A technical approach has the huge drawback of constraining the approach. But we should at least recognize that it pushes us into being extremely precise, as computers are as dumb as a box of rocks, so they oblige us to be explicit in information designation. Considering semantics and using a method called <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>) will<a id="_idIndexMarker447"/> help us to be precise in functional terms, but without depending on anything technical that would hinder our evolution later on; this way, we get the best of both worlds.</p>
<p>Once the principles of this method are understood, again, we will turn back to our long-run example and apply DDD to our sample information system in order to draw its bounded contexts and describe its ubiquitous language (we will soon explain these two important concepts).</p>
<p>Finally, the chapter will explain how all of this applies to clean information systems as we try to design them, and what the links to the concepts of service and API are, which we have exposed in the previous chapter. There, we will talk about the importance of the life cycle analysis of a business entity and discuss a few recent orientations in information systems architecture.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>A functional approach to a functional problem</li>
<li>The importance of semantics</li>
<li>DDD</li>
<li>Application to clean information system architecture</li>
<li>Link to the API and services<a id="_idTextAnchor320"/></li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor321"/>A functional approach to a functional problem</h1>
<p>As<a id="_idIndexMarker448"/> explained in the introduction, it is of utmost importance to use a functional approach to solve the problem of designing a pivotal format. In the four-layer CIGREF map, all layers are a consequence of the one above. Hence, starting with layer 3 (software) without having a correct design of the context studied in layer 2 (business capabilities) is bound to create malfunctioning software. This is made much worse by the fact that once turned into software, the error will be fixed in code and possibly shared through APIs used by many users and machines all over your information system or external ones, which may make it almost impossible to correct the design error.</p>
<p>The vast majority of IT problems come from this lack of business alignment that we have talked about a lot and, right now, we are at the root of the problem: the design of the business entities. When we do not have any dedicated standard to rely on and spare us of a complex reasoning process, filled with risks of misunderstandings that may have important consequences, we will have to pay particular attention to any details, which, in practice, means extensive and guaranteed access to experts of the business domain.</p>
<p>A standard <a id="_idIndexMarker449"/>is generally expressed in technical terms in order to be extremely precise and irrefutable, but it represents, in a shared, acknowledged way, a functional concept. For example, RFC 7519 describes what a JSON Web Token is, and what the issuer, subject, expiration time, and all other attributes are for, but it does so in a very constrained way (with a precise definition of <code>iss</code>, <code>sub</code>, and <code>exp</code>, for the information we have cited previously. This way, we can say that a norm both lives in layers 2 and 3 of the CIGREF map and binds them together. This is why norms and standards are so important because they are the concrete actors of business/IT alignment. To give a second example, OpenAPI is also a great illustration of how norms and standards bridge the potential gap between functional and software approaches, by providing a list of all functions that should be accessible through an API on a given business domain, while, at the same time, giving a precise JSON or YAML-based technical description of what this means in the data streams that will be exchanged between servers.</p>
<p>A pivotal format should aim at the same result by joining the functional aspect and the technical representation of it. This is why it is important to describe it with technical means, whatever they are. These technical means can be XML Schema or DTD if you are using SOAP web services, or OpenAPI if you are designing API and their components; they can even be a simple Excel file showing the exact names and structures of the data messages you intend to move around your system. The only important thing is that it is technically written, but not technically restrictive.</p>
<p>The phrase “technically written, but not technically restrictive,” may seem paradoxical, so, let me explain this. The technical writing of the norm is important because it ensures preciseness (nobody wants a vague description of something important). This is why a new API has got to be described in an OpenAPI contract. This way, there is no place for argument over how an attribute is written, with capital letters or not, or only the first one; for example, it is written in computerized text in the OpenAPI JSON or YAML, so there is no possible discussion. However, at the same time, attention should be paid to the fact that the pivotal format (like any norm) should never be constrained by any technical issues. We all agree that a norm to represent, say, countries, would not make any sense if the authors of the norm used some Java primitives that would make it difficult to use the norm with another platform. It would be a limited, technical way of doing it, but definitely not a real norm. The same should be applied to your pivotal format design and it should never expose anything from your technical implementation, even if it is expressed in a functional way.</p>
<p>By the way, this<a id="_idIndexMarker450"/> is yet another reason for always designing from the functional point of view before thinking of software. If you force yourself during this period to let go of the database choice, for example, you reduce the possibility of creating a pivotal format that is bound to your database orientation. I understand this might sound a bit unrealistic and you might wonder how someone could bind the design of data to a database. Well, the devil lies in details and there are sadly many ways—some subtler than others—to fall into this trap:</p>
<ul>
<li>One might express data attributes with types that are only available in some databases and not others. If we are used to talking about <code>VARCHAR(n)</code>, for example, we might imply in our data design that there is a limit to the size of an attribute, though it is not justified from the functional point of view. Everyone has seen an application that truncates family names when they are too long, although this creates an incorrect data value.</li>
<li>The same can happen for date formats. The norm-referenced ISO 8601 (also nicknamed as ISO-Time) makes a clear difference between administrative dates and instants, but most databases do not. If we think in SQL terms, we might miss this essential difference.</li>
<li>Identifiers can be badly influenced by the well-known standard database mechanisms. The autogeneration of identifiers by SQL databases, based on counters, is quite practical but these identifiers scale very poorly and are one cause for the lack of distribution of such databases. <strong class="bold">Globally unique identifiers</strong> (<strong class="bold">GUIDs</strong>) are <a id="_idIndexMarker451"/>better and, quite often, used by more modern systems such as NoSQL databases. However, both will definitely be the wrong choice if you need to assign a unique identifier for an entity representing a patient in a health information system since the largely acknowledged (and sometimes legally required) identifier in this particular case is a national security number.</li>
</ul>
<p>There are actually so many other cases where some technical knowledge can waste the design of a pivotal format that I have personally formed the habit of always designing them by animating groups only made of Product Owners, even going as far as detecting those with a technical background and excluding them from the design group in some cases. I still could badly influence the process, as I have a technical approach, but I generally help <a id="_idIndexMarker452"/>design pivotal formats on business domains I do have not much experience with, so, it is easy to play the role of a complete beginner, knowing nothing about the business domain and then focusing only on this comprehension. Also, I know from experience how early technical thinking can have a negative impact, so I always think of what could go wrong because of this.</p>
<p>Sometimes, the coupling can be extremely subtle. For example, let’s take a URL such as <code>https://demoeditor.com/library/books/978-2409002205</code>. It sounds like a great identifier, since it is based on norms only (URLs, ISBNs for books, and a DNS for the host) and there is apparently nothing else. However, one could argue that prefixing with the (<code>https://</code>) scheme is already a hint for how we are going to technically access these functional entities, in this case, through web-based APIs. Luckily, a solution always exists and, in this case, this<a id="_idIndexMarker453"/> is through resorting to <code>urn:com:demoeditor:library:books:978-2409002205</code>.</p>
<p>At this point in the book, you should hopefully be convinced that taking the functional point of view on a problem is always the best option and that the technical aspects should come afterward. This being said we need some method to analyze a problem from a functional point of view only, and this is how semantics can be<a id="_idTextAnchor322"/> used.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor323"/>The importance of semantics</h1>
<p>In the <a id="_idIndexMarker454"/>previous section, we demonstrated how to use a technically-backed but not technically-coupled approach to define entity formats that will be precise. However, we have not yet touched upon the functional analysis itself and, looking at our example URN, <code>urn:com:demoeditor:library:books:978-2409002205</code>, we can spot what needs further analysis in the different parts of the string:</p>
<ul>
<li><code>urn</code>: This is the scheme of the URI. It is here just to state that this is a unified resource name.</li>
<li><code>com:demoeditor</code>: This is the reverse of <code>demoeditor.com</code>, the domain name of our sample company. The information is there to serve as a prefix to differentiate the entities from another vendor that would have entities with the same name, and it is reversed in order to keep the information in a logical reading order from the coarsest to the most granular.</li>
<li><code>978-2409002205</code>: This is a sample ISBN. Again, as soon as we can, and this is essential inside pivotal formats, we turn it back to an existing standard. There are norms for virtually every single piece of information!</li>
<li><code>library</code> and <code>books</code> are the parts of the URN that bear some functional value and we have not yet explained where they come from. Let’s say for now that <code>library</code> is the domain (the management unit of books and other entities related) and <code>books</code> is the chosen name to talk about these resources that <code>DemoEditor</code> manages. We will come back later to this.</li>
</ul>
<p><code>x24b72</code> instead of <code>books</code> and they would not mind at all; whereas introducing misunderstanding in the terms used by your information system is bound to create problems at some point.</p>
<p>Let me tell you of an anecdote on this: I was consulting at a company in the information domain and one of the workshops I had with them was about designing a pivotal format around the people who bought the information. Marketing people and salespersons were there and, at some point, their voices started to rise as they disagreed on terms that were used differently. Their argument was about the relationship between a <em class="italic">prospect</em> and a <em class="italic">customer</em>. Marketing explained that customers are the best prospects since they already know the company, whereas the salespersons replied that the commercial pipe was quite clear concerning the fact that a cold lead becomes a hot lead, then a prospect, and then a customer if he buys something, leaving—by definition—the status of prospect. In fact, they both were right and something was simply missing in the model: the fact that “customer” and “prospect” are not names of entities, but business rules. If one includes in the model the notion of product proposition, then things get clearer: a customer of a given product is indeed a great prospect for another product in the catalog of the same company, but they are still not a customer for this second product.</p>
<p>Reading this, you<a id="_idIndexMarker457"/> might say that this situation was benign and that no harm was done since the discussion cleared out the problem. This would lead to ignoring two things. First, this misunderstanding created some real tensions between marketing and commerce and incomplete future sales reports, which lasted for months before I had the chance to spot the problem in the workshop organized by the CTO of the company. Second, when there is just an oral misunderstanding, this is indeed fine, but the real problem is that this mistake has been solidified into the information system (remember that you should never start working on layer 3 before having a good understanding of the analysis context in layer 2). If this was just a mistake in a single company, that would not be so bad, but even ERP editors (I will not cite any names) make the same mistake right into their default database models! Several of them sport data tables named <code>customers</code> and <code>suppliers</code>, which can cause lots of trouble.</p>
<div><div><img alt="Figure 9.1 – Bad semantics" src="img/B21293_09_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Bad semantics</p>
<p>What happens in<a id="_idIndexMarker458"/> this case when a given company you work with is not only one of your customers but also one of your suppliers? This happens very often in the negotiation market, and, generally, people would not make this mistake. However, in this ERP, which I will not cite, the editor clearly did not do the job of understanding all of the markets they wanted to address and tried to propose a generic model that was not adapted to any company where this situation would happen. Of course, how do you think the consultants handled the problem when discovered? You got it: they tried to compensate for the layer 2 problem using layer 3 tricks. In a particular case, I remember, the consultants first started creating a database trigger that, when a customer changed address or bank coordinates, would replicate the modified information into the <code>suppliers</code> data table. Then, a few months later since the problem happened, they implemented the same trigger to modify the <code>customers</code> data table when a supplier was the modifier and created an infinite loop that crashed the database!</p>
<p>Things would have <a id="_idIndexMarker459"/>been so much easier if the data tables had been designed with a single <code>actors</code> data table (or <code>individuals</code> or <code>organizations</code> if you only deal with this kind of actors; again, semantics matters). The notion of a customer would simply arise from a business rule that states that an <em class="italic">actor</em> is a <em class="italic">customer</em> if a record exists in the <code>orders</code> data table pointing at this actor, and with a value date not older than 18 months. The same would be applicable to a supplier, which would be a business rule stating that an <em class="italic">actor</em> is a <em class="italic">supplier</em> if a record exists in the <code>incoming-orders</code> data table linked to this actor, or if an entry in the <code>equipment</code> data table has a guaranteed owner pointing at this actor.</p>
<div><div><img alt="Figure 9.2 – Correct semantics" src="img/B21293_09_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Correct semantics</p>
<p>Those business rules are, of course, purely arbitrary ones, but notice that the entity schema does not change a bit if the rules evolve. This may be the most important thing in this model. If, at some point, marketing decides that the rule should be that the customers list <a id="_idIndexMarker460"/>contains only the actors with whom we have done business in the past 12 months instead of 18, what will happen? Here starts the real problems in the bad design, as you will have to create a migration routine to get your customers out of the table and activate the archive procedure. Since you may have orders pending, the risk is to lose a pointer to the right data and so many other things can go awry. With the right model design, on the other hand, what should we do? Well, simply modify the business rule! If it is in code, you can change <code>18</code> to <code>12</code> and recompile. If you were careful enough beforehand, this business rule is in a custom property somewhere and you will not even have to recompile or deploy anything. Also, if you had a reporting API producing the list of customers, then it is your lucky day: you modify this implementation and, without any other action, the behavior is changed everywhere in your system!</p>
<p>You might think that these examples are too easy and that this approach will not stand the complexity of a real system; it is actually quite the contrary because this approach is based on designing the business complexity in the software model. In the preceding example, for instance, we could very well have a different business definition of the addresses and the owner of the information system could decide that addresses should not be shared between customers and suppliers, or maybe only in some cases. For example, some addresses would be used only for the customers, such as the delivery address. No problem: we would adjust the model by keeping the addresses separate from the actors, and then add the “type” information to them, in order for the delivery address to be pointed at by the actors only when they are customers. We could even add some authorization rules on this to ensure that this address is never even read when the actor is seen as a supplier! Again, a good design would have allowed all this to be smooth but you have to get this clean design. Also, this happens to be one of the hardest bits of your architect job – gathering domain experts and coming up with something close to perfection. Fortunately, methods exist to structure this job. It is time to int<a id="_idTextAnchor324"/>roduce DDD.</p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor325"/>DDD</h1>
<p>DDD (please note the last <em class="italic">D</em> is <em class="italic">not</em> for <em class="italic">development</em>, but indeed <em class="italic">design</em>) is a complete method for<a id="_idIndexMarker461"/> functional design that has been created and documented by Eric Evans, in his foundational book, <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, released in 2003 and, since then, has been famously known as <em class="italic">the blue book</em>. This important piece of work has influenced many software designers, despite it being quite a difficult read. Through its hundreds of pages, this book dispenses lots of best practices in modeling data and functional design. It is oriented<a id="_idIndexMarker462"/> towards software but everything it says can help, even before the first line of code, and it is a wealth of advice for understanding your business functions before you even start thinking about automating them through IT solutions.</p>
<p>That being said, our goal here is not to talk too much about the book, or to unroll the complete method. You have to read it yourself if you want to get the full advantage of such a seminal work, or watch Eric Evans’ excellent presentation at <a href="https://youtu.be/lE6Hxz4yomA">https://youtu.be/lE6Hxz4yomA</a>, where the expert explains the essentials of the method, which are as follows:</p>
<ul>
<li>Creative collaboration of domain experts and software experts</li>
<li>Exploration and experimentation</li>
<li>Emerging models shaping and reshaping the ubiquitous language</li>
<li>Explicit context boundaries</li>
<li>Focus on the core domain</li>
</ul>
<p>What we will now do is show how some tools from the book can be used in order to help our design of a pivotal format, aiming at a nice business/IT alignment. Going back to our sample company, how could we describe what we are doing from a general point of view? One could say we are in the business domain called <em class="italic">book edition</em>. We need a subdomain for authoring and another one for selling. These two can be considered core domains since this is the bread and butter of our sample company: supervising the writing of books and selling them. There will also be some supporting subdomains such as human resources or accounting: those are not directly implicated in the core value-addition work of the company but are nonetheless absolutely necessary for it to work correctly.</p>
<p>The word “edition” here refers to literature in general but editors and salespeople do not have the same vocabulary for books: the former talk about a <em class="italic">work</em> and the latter about a <em class="italic">product</em>. Still, this is a similar entity. Also, they will not use the same attributes. Editors will be very interested in the number of chapters, the progress made in the writing, and other such attributes of a book, which is mostly a work in progress for them (when they go to sales, their job is basically done). On the other hand, a salesperson will check attributes such as the price of the book and maybe even the weight to calculate the transportation fees. Again, there are attributes, however, that are of interest for both roles: the number of pages, the ISBN of the book, the date of publication, and so on.</p>
<p>To solve these apparent paradoxes in the naming and potential difficulties in the separated management of attributes, DDD proposes two concepts.</p>
<p>The first one <a id="_idIndexMarker463"/>is the concept of <strong class="bold">ubiquitous language</strong>. DDD<a id="_idIndexMarker464"/> recognizes that different names can be used in different contexts for the same functional entity, and thus can account for local jargon while keeping a unique name shared between all actors of the information system. In our example, that could be “books,” which is something sufficiently significant and still widely accepted to designate what editors call “works” and salespeople call “products.” To be perfectly clear, DDD does not recommend finding a single expression for each concept and abandoning all others, but rather deciding on a given expression that will be shared by all actors of the model (hence the ubiquitous qualification). Local jargons are not forbidden, because they are generally useful for fast communication inside a given context, but the <em class="italic">standard</em> expression should be used every time there is the slightest risk related to misunderstanding.</p>
<p>The second concept introduced by <a id="_idIndexMarker465"/>DDD is the <strong class="bold">bounded context</strong>, which is the perimeter containing entities and business rules, inside of which the vocabulary is consistent. We talked about this context in which the alternate vocabulary can be used without causing trouble if limited to the actors of this context only; this context is indeed what is called the bounded context. Finding the bounded context in a complete business domain is important because it helps define where the interactions are and, as a consequence, where it is most important to be perfectly clear on the language. Bounded contexts can be aligned to business subdomains, but this is not mandatory. As we will see in the next chapter, the question of the entity life cycle has to be taken into account as well.</p>
<p>To summarize this graphically, see <em class="italic">Figure 9</em><em class="italic">.3</em> for bounded contexts for our edition domain:</p>
<div><div><img alt="Figure 9.3 – Bounded contexts in Edition DDD" src="img/B21293_09_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Bounded contexts in Edition DDD</p>
<p>Since we<a id="_idIndexMarker466"/> obey an <strong class="bold">Agile approach</strong> to the design and development <a id="_idIndexMarker467"/>of our sample information system, we will not go further into the design than this very first step for now. Once we have applied this first level of knowledge to the creation of a first version of the data referential (see <a href="B21293_10.xhtml#_idTextAnchor344"><em class="italic">Chapter 10</em></a>), we will dig a bit deeper as needed. Indeed, trying to cover the whole business domain would take too long and too many pages without adding anything to the understanding of the method. Before we move on, let us refresh our knowledge of <strong class="bold">data referential</strong>. Data referential is <a id="_idIndexMarker468"/>a service that is dedicated to handling data for a particular functional entity but also metadata, data history, authorization, governance, and many other functions as a complement to the traditional database that only handles persistence. Data referential is the basis for good <strong class="bold">maste<a id="_idTextAnchor326"/>r </strong><strong class="bold">data management</strong>.</p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor327"/>Application to clean information system architecture</h1>
<p>Now that we<a id="_idIndexMarker469"/> are clear on the semantics <a id="_idIndexMarker470"/>and the domain decomposition of our business model, we can take a step forward in the design (though technical questions will only be introduced in the next chapter) and start envisioning how these entities are going to be introduced to the IT system. Until now, everything we said could be applied to a non-software-based information system. Starting from this section, we will admit the reality of there not being any such <a id="_idIndexMarker471"/>information systems in design anymore and that <em class="italic">every </em>company is now a software company. Since we <a id="_idIndexMarker472"/>are talking about entities, and their pivotal format is considered as designed, the next step is to talk about the way they will be manipulated—and thus stored—by t<a id="_idTextAnchor328"/>he information system.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor329"/>Using entities in referential applications</h2>
<p>The <a id="_idIndexMarker473"/>very first question about storing and manipulating functional entities is about their decomposition. Since complex business attributes may have hundreds of attributes to qualify them, it is of course necessary to at least categorize them, and, if possible, create a tree-like structure to classify them. Entities always have some base attributes that are used by everyone in the information system, and the rest of the data attributes are mostly related to one subdomain, or, at least, one of these domains can be selected for each as the ideal maintainer of the data quality. This decomposition is often used to represent data referential as flowers (see <em class="italic">Figure 9</em><em class="italic">.4</em>), with the core of the flower containing the shared data and the petals around the core containing the subdomain-related data. As a petal is always attached to the core, <em class="italic">Figure 9</em><em class="italic">.4</em> shows that peripheral data has no meaning without identifying the core data of an entity. It also states that petals can be independent and that a flower without some of the petals might still be useful to some users. Finally, the metaphor shows that, if the core of the flower is thrown away, the petals go away with it.</p>
<p>The application of this approach to our <code>book</code> entity should be quite obvious, following what we had said before:</p>
<div><div><img alt="Figure 9.4 – Metaphor of a flower for referential" src="img/B21293_09_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Metaphor of a flower for referential</p>
<p>Though we had<a id="_idIndexMarker474"/> only talked about the two main petals before, there might be some others around the flower, such as the one about the physical production of the books, and the one about <a id="_idIndexMarker475"/>the storage of the printed units. Again, since this book is about the method and not about designing an IT system for a real book editing company, we will not go into these details; but you should definitely at least get to know all the petals in an entity flower when you design one for real, even if you do not get all the details of each petals<a id="_idTextAnchor330"/> in your first analysis.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor331"/>Managing the life cycle of entities</h2>
<p>Also, since <a id="_idIndexMarker476"/>we question the design of the storage, it is important to include time in the equation, as was explained in <a href="B21293_04.xhtml#_idTextAnchor121"><em class="italic">Chapter 4</em></a>. A common mistake once an entity is designed is to think that we need to store and manipulate the data attributes that have appeared during this phase. However, there are many other things around the entity that have an impact on storage. Time is, of course, the first one and an important entity generally needs to have all its states in time persisted and not the last known one. In some cases, versions and branches of entities might have to be handled. Metadata on the entity (who created it, which state it is in, etc.) might be seen as a dedicated <a id="_idIndexMarker477"/>petal for history, but it generally is a complete set of data attached to the entity and available for all petals while still not being at the core of the flower, since it is not always necessary to have this metadata.</p>
<p>If we stick to<a id="_idIndexMarker478"/> time, traceability of the data change is, of course, the obvious thing we think about, but taking time into account is much more than just storing the changes of each attribute each time they are modified: it is about modeling the evolution of the entity in time as an element of business<a id="_idIndexMarker479"/> knowledge as well and making it possible to understand not only how the data changed (addresses an array with index 1 removed and another entity added) but what was the functional reason behind it (e.g., the person moved out and recorded their change of address). This is what<a id="_idIndexMarker480"/> is called the <strong class="bold">entity life cycle</strong>. Designing it is harder than listing the attributes of an entity because it is not a usual design activity and also because there are many ways to introduce time, each one complementary to the others. For example, it may be used to think of the statuses the entity will go through in its lifetime (created, draft, valid, etc., until it reaches the archived state). However, there may be times when having a design closer to what would be the business process centered on an important entity will be easier to communicate.</p>
<p><em class="italic">Figure 9</em><em class="italic">.5</em> shows how the time criteria could be introduced on the <code>book</code> entity and what the life cycle would look like if we start from different steps in the life of a book, from the edition domain point of view (not the reader, of course, as this would lead to a completely different information system):</p>
<div><div><img alt="Figure 9.5 – The life cycle of a book" src="img/B21293_09_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The life cycle of a book</p>
<p>As you can see, the top part of the diagram shows what will happen in the lifetime of the book in the editing company. It always starts from an idea, even if this phase is extremely short, such as the idea coming from a meeting with a candidate author. In this case, the process will directly jump to the second phase. Phases look quite linear here, but that does not mean they have to be. For example, when a second edition is created, the writing and correcting phase will start again, but generally speaking, this diagram helps to envision the entity not only as the sum of data attributes but as a living object in the information system.</p>
<p>The evolution <a id="_idIndexMarker481"/>of an entity in time, of<a id="_idIndexMarker482"/> course, has an impact on many aspects of its data, but also on the business rules that apply to it. In the diagram, I only showed a few examples of such impact:</p>
<ul>
<li>Tags associated with the book in order to categorize them will evolve at first, but soon will be fixed and cannot evolve afterward, as it would create problems if the subject of a book evolved too much once the salespersons have started talking about it on salons, social media or to resellers.</li>
<li>Actors working on a book will, of course, evolve throughout its life cycle: marketing will create the vision of the book, editors will help the authors create it, and at some point, after the content is reviewed and validated, the main actors will be the salespersons, until the book reaches archiving, when editors will work a bit on the book again.</li>
<li>An example of a business rule has been provided, though there are always many in an important entity of the information system. In this diagram, I showed that the business rule is <em class="italic">public</em>, which is false as long as the book is not validated by the reviewers and becomes true after, with the particular case (not shown here) that, once public, a book cannot go back to being private, as people have been informed about it.</li>
</ul>
<p>The notion of <code>status</code> attribute that an editor would change on the <code>book</code> entity instance. But it may also be bound to a business rule stating that a book can become <em class="italic">ready to publish</em> once the following tasks have been completed:</p>
<ol>
<li>Its main editor or two editors have given their vote for it.</li>
<li>The author has signed their contract and, in particular, the financial amendments.</li>
<li>The printing company has approved the provided files.</li>
</ol>
<p>Business rules <a id="_idIndexMarker483"/>can also cascade on each<a id="_idIndexMarker484"/> other. For example, we could authorize payment of an author only if their bank details have been validated for less than three months, which means verifying the bank owning the account, which means, in turn, checking the SWIFT number is correct, and so on.</p>
<p>Finally, all of this is complicated further by the fact that some business rules may be stabilized as data at some point. This happens for performance reasons, where the computations are so long that it becomes acceptable that the result of the calculation is not always up-to-date (which happens when reading the value is more frequent than computing its result anew). There might also be some functional reasons as to why a state evolves against business rules and then gets fixed, without the possibility of going back for regulatory reasons (typically, this is what happens when an entity reaches an <code>archived</code> state: its content is then removed from the database and placed in archives, so, returning to an <code>active</code> state is not possible, since the data is now only accessible by archivists). In this case, the state overrides the business rule itself (or the business rule starts reading the recorded state and continues calculations if it i<a id="_idTextAnchor332"/>s not overridden by this state).</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor333"/>Relation between subdomains and time</h2>
<p>This notion<a id="_idIndexMarker485"/> of a life cycle is also important because it helps define important entities, and thus subdomains, in your information system. For example, a book is definitely a major entity in the domain because, as we have shown, it has a life cycle. Authors also have a life cycle in the information system because, as they are created in it, their contact data will change, they will hopefully write several books, and, at some point, will be erased from the database after a given time of inactivity (under which there is certainly a regulatory business rule, such as the GDPR in Europe, for example). However, tags are not an important entity, as they do not have a life cycle outside of books. Sure, a tag might disappear, but this will only be a result of there being no more books in this category. It is even <a id="_idIndexMarker486"/>easier to decide that the addresses of authors are definitely not a major entity, as they will never exist outside of an author, and they will always disappear with their parent entity.</p>
<p>The definition <a id="_idIndexMarker487"/>of the entity itself can evolve over time, which is completely natural in an Agile approach where we do not try to have everything conceptualized at first as we know that things <a id="_idIndexMarker488"/>will get clearer in time, and we should just prepare for the changes that will be added in the next versions (while still knowing enough of the business to ensure compatibility and smooth evolution of the system). The cutting of subdomains should normally never evolve in time. Additional domains may appear following a change of strategy of the company owning the information system, but there should be something majorly important to justify such a low-level change.</p>
<p>Now that we have seen DDD in action and its relation to a correctly structured information system, we are going to talk more specifically about the consequence of all of <a id="_idTextAnchor334"/>this in the design of API contracts.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor335"/>Link to the API and services</h1>
<p>We <a id="_idIndexMarker489"/>spent a lot of time talking about the entity from the point of view of its evolution and not with a data focus, but this is done on purpose because we generally take too much time defining the attributes and not enough thinking about the business entity as a whole, living object. Now that this is done, let’s use the final section of this chapter to come back to the notion of services and API that we h<a id="_idTextAnchor336"/>ave detailed in the previous chapter.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor337"/>Including time in an API</h2>
<p>One of the first consequences of thinking about the entity as a whole, including its history, is that the writing methods on a corresponding API should not work exactly the same. As reading methods, they are similar to the following:</p>
<ul>
<li><code>GET on /api/entity</code>: This is used to read the list of entities</li>
<li><code>GET on /api/entity/{id}</code>: This is used to read a given entity</li>
</ul>
<p>However, if you want to take action and be able to access history, you should add some methods such as the following:</p>
<ul>
<li><code>GET on /api/entity/{id}?valuedate={date}</code>: This is used to read a given entity state at a given date</li>
<li><code>GET on /api/entity/{id}/history</code>: This is used to read the full history of a given entity</li>
</ul>
<p>Changes<a id="_idIndexMarker490"/> should also be made to the writing parts of the API, with one method that does not change:</p>
<ul>
<li><code>POST on /api/entity</code>: This will always be about creating an entity instance. (Do not forget to follow the standards and send a <code>201</code> HTTP status code, together with a <em class="italic">Location</em> response header containing the URL of the resource just created.)</li>
</ul>
<p>However, the traditional calls for an API are limited when you think in terms of a complete life cycle:</p>
<ul>
<li><code>PUT on /api/entity/{id}</code>: This should not be allowed as it destroys the eventual consistency and the ability to avoid locks, as was explained before.</li>
<li><code>DELETE on /api/entity/{id}</code>: This should also be adjusted, not in its exposition but in how it works. Most of the time, since the resource is not really removed but only made unavailable by reaching an <code>archived</code> or <code>disabled</code> status, the equivalent modification call could be used in the same way and be more explicit.</li>
</ul>
<p>Also, an existing but lesser-known verb should be used in order to act on the state of the entity:</p>
<ul>
<li><code>PATCH on /api/entity/{id}</code>: This together with a request body content, following <code>RFC 6902</code> (JSON Patch), should be used to write the data in a progressive, eventually consistent, and lock-free way (optimistic and pessimistic locks have been explained in <a href="B21293_05.xhtml#_idTextAnchor164"><em class="italic">Chapter 5</em></a>)</li>
<li><code>PATCH on /api/entity/{id}?valuedate={date}</code>: This can also be allowed in some cases where the history of the entity does not strictly follow the flow of orders in the API server, and the value date should be taken into account</li>
</ul>
<p>We will come<a id="_idIndexMarker491"/> back to these definitions in the next chapter, <em class="italic">Master Data Managemen<a id="_idTextAnchor338"/>t</em>, and show the implementation of them.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor339"/>Aligning an API to subdomains and the consequences</h2>
<p>If you use a<a id="_idIndexMarker492"/> strict service architecture, all major entities, and thus all business subdomains, should have their dedicated process. However, since we said they should have their own API (minor entities will be under the major entities of the domain they are related to; for example, addresses will be in <code>/api/authors/{id}/addresses</code>), which equates to the fact that one API should always have its own process. Also, if you follow the rule of one process in one Docker container, you will have the equivalence of one API to one Docker service (scalability taken into account, as a service is a set of Docker containers of the same image).</p>
<p class="callout-heading">Note</p>
<p class="callout">Docker is the most known implementation of the principle of containerization for software installation. This technology allows the deployment of instances of self-contained <strong class="bold">black boxes</strong> of <a id="_idIndexMarker493"/>software, which contain every dependency needed and remain isolated from other instances, while not necessitating a heavy mechanism such as virtualization.</p>
<p>If you consider that all calls should go through an API since they are the guarantee of unique business rules management and source of truth for a given API, then that means that nobody but the API exposition will ever access the application layer. In this case, why bother to separate these two layers? In the next chapter, we will follow this simple rule and implement API business codes directly inside the ASP.NET controllers. If you’re wondering about validations and how they can be done as soon as possible, then deserialization will take care of a good part of all this, and preconditions inside the implementation code will do the rest.</p>
<p>We will, of<a id="_idIndexMarker494"/> course, keep things separated for everything that is a dependency, such as persistence and logging. However, as far as the business behavior is concerned, everything will be handled in the API code itself, in just one big block. This might seem like something that is not obvious given the principle of clear separation of responsibilities, but this has been done on purpose in this book and in particular in the code associated with it. It does not mean that cutting down into layers, as explained at <a href="https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer">https://timdeschryver.dev/blog/treat-your-net-minimal-api-endpoint-as-the-application-layer</a>, is useless, but simply that the first versions of a sound and evolving information system can very well start with a very simple implementation of a restricted API, leaving it to future versions to evolve to an extended API content and something <a id="_idTextAnchor340"/>more sophisticated for its implementation.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor341"/>API testability</h2>
<p>One last<a id="_idIndexMarker495"/> thing on the API and its alignment with entities: nothing beats a nice Postman collection for manually testing the content of an API and then using these requests as the basis for a set of automated tests. There sure are other tools for specialized testing purposes but, in my personal experience, I have not yet found something as versatile as Postman for API discovery and testing.</p>
<p class="callout-heading">Note</p>
<p class="callout">Postman is the reference tool for API testing. A collection is a set of HTTP calls that can be tested manually or in an automatic, sequential way.</p>
<p>If you can gather what your clients, internal team, and partners, external or public, do specifically with your API and integrate their <a id="_idIndexMarker496"/>code into your <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) Postman collections, then this is definitely the best way to ensure non-regression and backward compatibility. Sure, it will not replace unit tests and integration tests, but the former is a development tool, and the latter a QA tool. Everything in between will be beautifully held at <a id="_idIndexMarker497"/>the API level, which then becomes your interaction level but unifies with the testing interface of your model since it is aligned with the API. Whatever your level of interop, regression testing is best done at the API level.</p>
<p>If you completely follow the preceding principles, you end up with a perfect alignment of the following:</p>
<ul>
<li>One business subdomain</li>
<li>One major entity</li>
<li>One API contract (in OpenAPI format)</li>
<li>One Git repository for the code implementing this API</li>
<li>One process for the delivery of this code</li>
<li>One Docker image for the deployment</li>
<li>One orchestrator service for the running of API calls in a coordinated way</li>
<li>On<a id="_idTextAnchor342"/>e Postman collection for the tests of the API</li>
</ul>
<h1 id="_idParaDest-198"><a id="_idTextAnchor343"/>Summary</h1>
<p>Here we are, finally reaching the point where we will get into the code! The previous chapters paved the way for a global understanding of most of the constraints of creating an evolution-capable, feature-rich information system. In this chapter, we saw how we should enter details about the data of entities and also their life cycle to create a clean and future ready architecture.</p>
<p>DDD and the method shown previously using semantics will hopefully help you find the best way to structure important entities in your information system. The right schema makes exposing these entities through APIs easier and more loaded with functional value. This approach also allows the evolution of the system in the smoothest possible way, as technical evolutions and functional ones should be separated if the design has been correct. This way, not only is the information system better in its current form but it will also be much easier to evolve.</p>
<p>In the next chapter, we will see how the functional entities that we have designed are going to be implemented in the technical layers. We will not go into the code details right away, but we will start with how the data will be organized in the logical servers, how the entity life cycle that we talked about will be implemented in the software applications that will be put in place, and why master data management and data governance are important for ensuring that these nice functionally correct pivotal formats we designed in this chapter are efficiently exploited.</p>
</div>
</body></html>