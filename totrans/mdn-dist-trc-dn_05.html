<html><head></head><body>
<div id="_idContainer082">
<h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.2.1">Configuration and Control Plane</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we learned how to enable auto-instrumentation with a few lines of code and leverage collected telemetry to debug issues and monitor performance. </span><span class="koboSpan" id="kobo.3.2">Auto-collected traces and metrics provide the basis for your observability solution, but they are rarely sufficient without an application context. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we’ll learn how to customize telemetry collection – enrich, adjust, or control its volume. </span><span class="koboSpan" id="kobo.3.4">We will dive into the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.5.1">Controlling costs </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">with sampling</span></span></li>
<li><span class="koboSpan" id="kobo.7.1">Enriching and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">filtering telemetry</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Customizing </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">context propagation</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Building a processing pipeline with the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">OpenTelemetry Collector</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you will be able to choose a sampling strategy and configure it in your system, efficiently enrich auto-generated traces with custom attributes, and propagate your context between services. </span><span class="koboSpan" id="kobo.13.2">We’ll see also how to suppress noisy spans </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and metrics.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">The code for this chapter is available in the book’s repository on GitHub at </span><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/tree/main/chapter5</span></a><span class="koboSpan" id="kobo.18.1">, which has the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">following structure:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.21.1">sampling</span></strong><span class="koboSpan" id="kobo.22.1"> application contains sampling </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">code snippets</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">memes</span></strong><span class="koboSpan" id="kobo.26.1"> application is an improved version of the meme service from </span><a href="B19423_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.27.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.28.1">, </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Native Monitoring in .NET</span></em><span class="koboSpan" id="kobo.30.1">, which contains enrichment and context </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">propagation examples</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.32.1">To run samples and perform analysis, we’ll need the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">following tools:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">.NET SDK 7.0 </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">or later</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">docker-compose</span></strong></span></li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.39.1">Controlling costs with sampling</span></h1>
<p><span class="koboSpan" id="kobo.40.1">Tracing all operations gives us the ability</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.41.1"> to debug individual issues</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.42.1"> in the system, even very rare ones, but it could be impractical from a performance and telemetry </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">storage perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">The performance impact of optimized and succinct instrumentation is usually low, but telemetry ingestion, processing, storage, queries, and other observability experiences could be </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">very costly.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Observability vendors’ pricing models vary – some charge for the volume of ingested traces, others for the number of events, traces, or hosts reporting data. </span><span class="koboSpan" id="kobo.46.2">The ingestion cost usually includes retaining telemetry for 1 to 3 months. </span><span class="koboSpan" id="kobo.46.3">Data retrieval and scanning are also billed by some vendors. </span><span class="koboSpan" id="kobo.46.4">Essentially, costs associated with sending and retrieving telemetry grow along with </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">telemetry volume.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">Realistically, we’re going to be interested in a very small fraction of traces – ones that record failures, long requests, and other rare cases. </span><span class="koboSpan" id="kobo.48.2">We may also query a subset of traces for </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">analytics purposes.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">So, collecting all traces comes at a relatively small performance hit and could be reasonable, but storing all of them on an observability backend is </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">rarely justified.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.52.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.53.1">You might consider using traces as audit logs</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.54.1"> and then need every operation to be recorded. </span><span class="koboSpan" id="kobo.54.2">However, we need traces to debug and resolve incidents in production, which implies a fast query time, potentially short retention, and traces being accessible by every on-call person. </span><span class="koboSpan" id="kobo.54.3">Audit logs usually need a different privacy and retention policy. </span><span class="koboSpan" id="kobo.54.4">They also don’t necessarily require fast and </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">random access.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.56.1">Sampling</span></strong><span class="koboSpan" id="kobo.57.1"> is a technique that allows recording</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.58.1"> a subset of traces, thus reducing storage costs. </span><span class="koboSpan" id="kobo.58.2">There are two main approaches to sampling: </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">head-based</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.60.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">tail-based</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.63.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.64.1">Both head-based and tail-based sampling rely on trace context propagation that needs to happen regardless of the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">sampling decision.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">Let’s take a closer look at different sampling approaches and see how and when to </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">apply them.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.68.1">Head-based sampling</span></h2>
<p><span class="koboSpan" id="kobo.69.1">With head-based sampling, the decision to record</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.70.1"> or not record a trace is done when the trace is started by the application process and is usually random (or based on information available beforehand). </span><span class="koboSpan" id="kobo.70.2">The assumption here is that under high-scale problems that need attention happen frequently enough to record at least some occurrences. </span><span class="koboSpan" id="kobo.70.3">In other words, problems that are never recorded are too rare and are likely less important. </span><span class="koboSpan" id="kobo.70.4">“Too rare” and “frequently enough” here totally depend on </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">application requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">Head-based sampling algorithms try to be consistent so that we can capture all spans or none of them in any trace. </span><span class="koboSpan" id="kobo.72.2">It’s achieved by either following upstream sampling decisions or making independent, but consistent, decisions on each service. </span><span class="koboSpan" id="kobo.72.3">Let’s learn more about these approaches and also check how we can implement custom </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">sampling solutions.</span></span></p>
<h3><span class="koboSpan" id="kobo.74.1">Parent-based sampling</span></h3>
<p><span class="koboSpan" id="kobo.75.1">With the </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">parent-based</span></strong><span class="koboSpan" id="kobo.77.1"> sampling approach, the component</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.78.1"> that starts a trace makes a sampling decision</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.79.1"> and propagates it, and all downstream services follow. </span><span class="koboSpan" id="kobo.79.2">The decision is propagated using a sampling bit in </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">traceparent</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">For example, as we saw in </span><a href="B19423_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.82.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.83.1">, </span><em class="italic"><span class="koboSpan" id="kobo.84.1">Observability Needs of Modern Applications</span></em><span class="koboSpan" id="kobo.85.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">traceparent</span></strong><span class="koboSpan" id="kobo.87.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">00-trace1-span1-01</span></strong><span class="koboSpan" id="kobo.89.1"> indicates that upstream services recorded this span, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">00-trace2-span2-00</span></strong><span class="koboSpan" id="kobo.91.1"> indicates that the span was not recorded. </span><span class="koboSpan" id="kobo.91.2">To enable this behavior in OpenTelemetry, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">ParentBasedSampler</span></strong><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">When all services follow the parent decision, the sampling probability (or percentage or recorded traces) configured on the first component applies to all </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">downstream services.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.95.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.96.1">With using parent-based sampling, the component that makes decision needs to be fully trusted – if it starts to record all traces, it might overload your telemetry collection pipeline and could cause your observability backend costs to skyrocket. </span><span class="koboSpan" id="kobo.96.2">You would normally make sampling decisions on your API gateway or frontend and would never trust sampling decisions coming from an </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">external client.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">The root component still needs to make independent sampling decision. </span><span class="koboSpan" id="kobo.98.2">Even though this decision can be random and other services would follow, it’s a good idea to stick to OpenTelemetry (or your observability vendor) sampling algorithms</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.99.1"> and keep them consistent</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.100.1"> across </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">the system.</span></span></p>
<h3><span class="koboSpan" id="kobo.102.1">Probability sampling</span></h3>
<p><span class="koboSpan" id="kobo.103.1">Another approach</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.104.1"> involves making a sampling decision on every service</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.105.1"> but doing it consistently, so </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">trace</span></strong><span class="koboSpan" id="kobo.107.1"> that’s recorded on one service would be recorded on another if they have the same sampling </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">rate configured.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">To achieve this, the </span><strong class="bold"><span class="koboSpan" id="kobo.110.1">probability sampling</span></strong><span class="koboSpan" id="kobo.111.1"> algorithm calculates the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">sampling score</span></strong><span class="koboSpan" id="kobo.113.1"> as a hash function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">trace-id</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">If the score is smaller</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.116.1"> than the probability, the span is recorded, otherwise, </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">it’s dropped.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.118.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.119.1">Probability sampling reduces your costs by only recording a fraction of the traces. </span><span class="koboSpan" id="kobo.119.2">Unexpected loads or bursts of traffic result in prorated growth in the volume of recorded traces. </span><span class="koboSpan" id="kobo.119.3">OpenTelemetry for .NET does not support a fixed-rate sampler out of the box, but you can configure the collector to do it or your observability vendor may </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">provide one.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Probability sampling is implemented in OpenTelemetry with </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">TraceIdRatioBasedSampler</span></strong><span class="koboSpan" id="kobo.123.1"> and can be configured with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">SetSampler</span></strong><span class="koboSpan" id="kobo.125.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">TracerProviderBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.129.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
builder.Services.AddOpenTelemetry()
  .WithTracing(tp =&gt; tp
</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">    .SetSampler(new TraceIdRatioBasedSampler(0.1))</span></strong><span class="koboSpan" id="kobo.132.1">
    .AddOtlpExporter());</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs"><span class="koboSpan" id="kobo.133.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.134.1">We set the probability to </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">0.1</span></strong><span class="koboSpan" id="kobo.136.1"> in this example, which means that 10% of all traces will </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">be recorded.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">And if we want to configure parent-based sampling on downstream components, we should set an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">ParentBasedSampler</span></strong><span class="koboSpan" id="kobo.140.1"> instead, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">following example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.142.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
tp.SetSampler(
   new ParentBasedSampler(new AlwaysOffSampler()))</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs"><span class="koboSpan" id="kobo.144.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.145.1">We need to provide a sampler that’s used when there is no parent trace context – in this example, we’re sampling out all the requests that come without </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">traceparent</span></strong><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">We could customize parent-based samplers</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.148.1"> further – set samplers to handle different</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.149.1"> cases: when the parent is remote or local, and whether the parent is recorded </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">or not.</span></span></p>
<h3><span class="koboSpan" id="kobo.151.1">Consistent sampling</span></h3>
<p><span class="koboSpan" id="kobo.152.1">Assuming all services</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.153.1"> have the same sampling probability</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.154.1"> configured, all spans in a trace will be recorded or dropped consistently – there will be no partial traces. </span><span class="koboSpan" id="kobo.154.2">However, using the same rate for all services is not always practical. </span><span class="koboSpan" id="kobo.154.3">You might want to configure higher sampling probability on a new service, or for one that has a small load. </span><span class="koboSpan" id="kobo.154.4">We can do it using a probability sampler by configuring it to different rates on </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">different services.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">As a result, we should expect that some tracers will be recorded partially. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.157.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.158.1">.1</span></em><span class="koboSpan" id="kobo.159.1"> shows an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">partial trace:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.161.1"><img alt="Figure 5.1 – Services with different sampling probabilities" src="image/B19423_05_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.162.1">Figure 5.1 – Services with different sampling probabilities</span></p>
<p><span class="koboSpan" id="kobo.163.1">Service A starts a trace – it generates trace-id and makes a sampling decision by calculating the score and comparing it to the sampling probability configured on </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">Let’s say the score is </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">0.1</span></strong><span class="koboSpan" id="kobo.167.1"> – it’s smaller than the probability (</span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">0.2</span></strong><span class="koboSpan" id="kobo.169.1">), so the request is sampled in, and we should record the corresponding span and its local children. </span><span class="koboSpan" id="kobo.169.2">Then </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Service A</span></strong><span class="koboSpan" id="kobo.171.1"> calls </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">Service B</span></strong><span class="koboSpan" id="kobo.173.1">, which has a smaller sampling probability, </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">0.01</span></strong><span class="koboSpan" id="kobo.175.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Service B</span></strong><span class="koboSpan" id="kobo.177.1"> calculates the score – it’s the same, so the decision is to not record the span or its local children. </span><span class="koboSpan" id="kobo.177.2">But then </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Service B</span></strong><span class="koboSpan" id="kobo.179.1"> calls </span><strong class="bold"><span class="koboSpan" id="kobo.180.1">Service C</span></strong><span class="koboSpan" id="kobo.181.1">, which records </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">corresponding spans.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">As a result, for this trace, we’ll have spans from </span><strong class="bold"><span class="koboSpan" id="kobo.184.1">Service A</span></strong><span class="koboSpan" id="kobo.185.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.186.1">C</span></strong><span class="koboSpan" id="kobo.187.1">, but not from </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Service B</span></strong><span class="koboSpan" id="kobo.189.1">. </span><span class="koboSpan" id="kobo.189.2">If this </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">trace-id</span></strong><span class="koboSpan" id="kobo.191.1"> had a different score, for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">0.005</span></strong><span class="koboSpan" id="kobo.193.1">, all services would record corresponding spans and we’d have a </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">complete trace.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Probability sampling relies on </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">trace-id</span></strong><span class="koboSpan" id="kobo.197.1"> being random and that the same hash function is used to calculate the score for each span. </span><span class="koboSpan" id="kobo.197.2">This is the case if you use vanilla OpenTelemetry in the same language on all your services and don’t customize ID generation or configure vendor-specific samplers. </span><span class="koboSpan" id="kobo.197.3">If your </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">trace-id</span></strong><span class="koboSpan" id="kobo.199.1"> is not random or if you have to use different sampling algorithms, we need a slightly different approach called </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">consistent sampling</span></strong><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">It’s experimental and not implemented in .NET at </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the moment.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">The approach relies</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.204.1"> on sampling score</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.205.1"> propagation: the component that starts the trace calculates the sampling score using any algorithm and propagates it to downstream services via </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">tracestate</span></strong><span class="koboSpan" id="kobo.207.1">. </span><span class="koboSpan" id="kobo.207.2">Downstream services don’t need to calculate the score again – they read it from </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">tracestate</span></strong><span class="koboSpan" id="kobo.209.1"> and make a sampling decision by comparing this score to their </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">configured probability.</span></span></p>
<h3><span class="koboSpan" id="kobo.211.1">Custom sampler</span></h3>
<p><span class="koboSpan" id="kobo.212.1">You can implement</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.213.1"> your own samplers. </span><span class="koboSpan" id="kobo.213.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">DebugSampler</span></strong><span class="koboSpan" id="kobo.215.1"> records all activities</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.216.1"> that have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">debug</span></strong><span class="koboSpan" id="kobo.218.1"> flag in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">tracestate</span></strong><span class="koboSpan" id="kobo.220.1"> header and uses the probability sampler for all other activities. </span><span class="koboSpan" id="kobo.220.2">With this sampler, you can force the trace to be recorded, by sending a request with valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">traceparent</span></strong><span class="koboSpan" id="kobo.222.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">tracestate: myapp=debug:1</span></strong><span class="koboSpan" id="kobo.224.1"> headers, which can be useful when testing or </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">reproducing problems:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.226.1">DebugSampler.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">
class DebugSampler : Sampler
{
    private readonly static Sampler On
      = new AlwaysOnSampler();
    private readonly static Regex DebugFlag
      = new Regex("(^|,)myapp=debug:1($|,)",
                  RegexOptions.Compiled);
    private readonly Sampler _default;
    public DebugSampler(double probability)
    {
        _default =
           new TraceIdRatioBasedSampler(probability);
    }
    public override SamplingResult ShouldSample(
      in SamplingParameters parameters)
    {
        var tracestate =
           parameters.ParentContext.TraceState;
        if (tracestate != null &amp;&amp;
             DebugFlag.IsMatch(tracestate))
           return On.ShouldSample(parameters);
        return _default.ShouldSample(parameters);
    }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs"><span class="koboSpan" id="kobo.228.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/sampling/DebugSampler.cs</span></a></p>
<p><span class="koboSpan" id="kobo.229.1">The sampler implements a </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">ShouldSample</span></strong><span class="koboSpan" id="kobo.231.1"> method, which takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">SamplingParameters</span></strong><span class="koboSpan" id="kobo.233.1"> in and </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">SamplingResult</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Sampling parameters</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.238.1"> include parent</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.239.1"> trace context and additional details such as creation-time attributes, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Activity</span></strong><span class="koboSpan" id="kobo.241.1"> name, kind, </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">tracestate</span></strong><span class="koboSpan" id="kobo.243.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">and links.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">SamplingResult</span></strong><span class="koboSpan" id="kobo.246.1"> is a struct that contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">SamplingDecision</span></strong><span class="koboSpan" id="kobo.248.1"> enum that takes one of three </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">possible values:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Drop</span></strong><span class="koboSpan" id="kobo.251.1">: Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">Activity</span></strong><span class="koboSpan" id="kobo.253.1">, but don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">record it.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">RecordAndSample</span></strong><span class="koboSpan" id="kobo.256.1">: Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Activity</span></strong><span class="koboSpan" id="kobo.258.1">, record it, and set the sampling flag on </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">trace context.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">RecordOnly</span></strong><span class="koboSpan" id="kobo.261.1">: Create </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">Activity</span></strong><span class="koboSpan" id="kobo.263.1"> and record it, but don’t set a sampling flag on trace context. </span><span class="koboSpan" id="kobo.263.2">Built-in samplers never return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">RecordOnly</span></strong><span class="koboSpan" id="kobo.265.1"> decision, but you can implement a custom sampler and return such a decision to a trace request locally without forcing downstream services to follow it (if they respect </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">parent decisions).</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">SamplingResult</span></strong><span class="koboSpan" id="kobo.268.1"> also contains updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">tracestate</span></strong><span class="koboSpan" id="kobo.270.1"> values and attributes – samplers can set them, and they will be used on the activity-to-be-created. </span><span class="koboSpan" id="kobo.270.2">We can configure this sampler</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.271.1"> in the same way</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.272.1"> as before, by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">SetSampler</span></strong><span class="koboSpan" id="kobo.274.1"> method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">TracerProviderBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1"> instance.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.277.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.278.1">With OpenTelemetry, an activity is created for every sampling decision. </span><span class="koboSpan" id="kobo.278.2">But in .NET, it’s possible to prevent a sampled-out </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">Activity</span></strong><span class="koboSpan" id="kobo.280.1"> from being </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">created altogether.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">We’ll learn more about sampling in vanilla .NET in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.283.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.284.1">, </span><em class="italic"><span class="koboSpan" id="kobo.285.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.286.1">, and will see some examples of how instrumentations can suppress activity creation later in </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">this chapter.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.288.1">Tail-based sampling</span></h2>
<p><span class="koboSpan" id="kobo.289.1">With tail-based sampling, the decision is made after the trace</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.290.1"> ends and could consider trace duration, presence of errors, or any other information available on spans. </span><span class="koboSpan" id="kobo.290.2">As you can imagine, we should first buffer all spans in the trace and then send all of them to the observability provider or drop all of them. </span><span class="koboSpan" id="kobo.290.3">Tail-based sampling must happen across different services and can only be done by an external component such as the OpenTelemetry Collector. </span><span class="koboSpan" id="kobo.290.4">The tail-sampling processor in the Collector is highly configurable and supports multiple sampling policies, including rate-limiting, latency, and status-code-based policies. </span><span class="koboSpan" id="kobo.290.5">You can combine multiple policies together. </span><span class="koboSpan" id="kobo.290.6">It’s not really possible to know when a trace ends, so the Collector starts buffering spans after the first span in that trace is received for a configurable time period and then makes a decision based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">available data.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">The tail-based sampling processor in collector allows the creation of composite sampling strategies. </span><span class="koboSpan" id="kobo.292.2">For example, you can configure probability sampling on your .NET services to minimize performance impact and then apply rate limiting on the collector to control telemetry volume and observability </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">backend costs.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">You could also configure a higher sampling probability to collect more traces with bigger latency, errors, or specific attributes. </span><span class="koboSpan" id="kobo.294.2">Buffering is currently limited to a single instance of the Collector, so if spans from the same trace end up on different collectors, tail-based sampling may produce partial traces, but still would capture parts corresponding to failure or increased latency. </span><span class="koboSpan" id="kobo.294.3">Since tail-based sampling has to buffer spans, it is memory-consuming and requires additional compute resources, and works well for short traces. </span><span class="koboSpan" id="kobo.294.4">As usual, it makes sense to compare the costs of managing the Collector setup with the savings </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">it brings.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.296.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.297.1">With non-probabilistic sampling, usage analysis based on traces is skewed and could be misleading. </span><span class="koboSpan" id="kobo.297.2">Metrics collected inside the application independently of traces could still be your source </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">of truth.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Depending on your needs, you may combine different approaches – for example, collect all data but keep it in a cold(ish) storage, only using a more expensive</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.300.1"> backend for a small subset </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">of traces.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Now you’re ready to choose a sampling strategy and implement it in your system! </span><span class="koboSpan" id="kobo.302.2">Let’s move and explore how to enrich spans with </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">additional context.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.304.1">Enriching and filtering telemetry</span></h1>
<p><span class="koboSpan" id="kobo.305.1">Traces and metrics coming</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.306.1"> from auto-instrumentation</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.307.1"> describe the technical side of an operation. </span><span class="koboSpan" id="kobo.307.2">While we can always add more spans with custom context (and we’ll learn how to do it in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.308.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.309.1">, </span><em class="italic"><span class="koboSpan" id="kobo.310.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.311.1">), it could be more practical to add custom context to </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">auto-collected telemetry.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Application-specific context is necessary to track usage and contains essential information that helps to detect and </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">investigate issues.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">For example, if we take our meme service, it would be very helpful to have the meme name and size on spans. </span><span class="koboSpan" id="kobo.315.2">With this, we’d be able to find the most popular memes, correlate meme upload and download requests, plan capacity, make cache optimizations, or reason </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">about partitioning.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">The easiest way to add a meme name is via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Activity.SetTag</span></strong><span class="koboSpan" id="kobo.319.1"> method. </span><span class="koboSpan" id="kobo.319.2">For example, we can the following code on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Meme</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1"> page:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.322.1">Meme.cshtml.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.323.1">
public async Task&lt;IActionResult&gt; OnGet([FromQuery] string
  name)
{
  </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Activity.Current?.SetTag("meme_name", name);</span></strong><span class="koboSpan" id="kobo.325.1">
    ...
</span><span class="koboSpan" id="kobo.325.2">}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs"><span class="koboSpan" id="kobo.326.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs</span></a></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.328.1"> here is created</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.329.1"> by ASP.NET Core. </span><span class="koboSpan" id="kobo.329.2">It was enabled with OpenTelemetry ASP.NET Core</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.330.1"> instrumentation – if tracing was disabled, </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.332.1"> would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">null</span></strong><span class="koboSpan" id="kobo.334.1"> here, so we should always guard </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Activity.Current</span></strong><span class="koboSpan" id="kobo.336.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">null</span></strong><span class="koboSpan" id="kobo.338.1"> check or use </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">null coalescence.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">We also check whether the activity is recorded – if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">IsAllDataRequested</span></strong><span class="koboSpan" id="kobo.342.1"> flag is </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">true</span></strong><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">There is no point in recording attributes on a sampled-out activity, so it’s an optimization. </span><span class="koboSpan" id="kobo.344.3">While it’s very small in this case, it’s a good practice to use it to avoid any unnecessary string allocations or prevent heavier operations needed to retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">attribute value.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">Finally, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">SetTag</span></strong><span class="koboSpan" id="kobo.348.1"> – a method that takes the string tag name and nullable object value. </span><span class="koboSpan" id="kobo.348.2">We’ll talk more about the Activity API and tags in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.349.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.350.1">, </span><em class="italic"><span class="koboSpan" id="kobo.351.1">Tracing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.352.1">Your Code</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.354.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.355.1">A tag</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.356.1"> in the .NET Activity API is the same as the OpenTelemetry </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">span</span></strong><span class="koboSpan" id="kobo.358.1"> attribute. </span><span class="koboSpan" id="kobo.358.2">Tags came from OpenTracing and were not renamed for backward-compatibility reasons. </span><span class="koboSpan" id="kobo.358.3">This book uses </span><em class="italic"><span class="koboSpan" id="kobo.359.1">tag</span></em><span class="koboSpan" id="kobo.360.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">attribute</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.362.1"> interchangeably.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">With this approach, we can add meme names to all ASP.NET Core activities. </span><span class="koboSpan" id="kobo.363.2">But what about HTTP client and MySQL activities? </span><span class="koboSpan" id="kobo.363.3">Having meme names on them would </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">be handy.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">In the general case, it can be done</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.366.1"> with a span processor, but some instrumentations</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.367.1"> provide extensibility hooks allowing them to enrich </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">their activities.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">Let’s look at each of </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">these approaches.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.371.1">Span processors</span></h2>
<p><span class="koboSpan" id="kobo.372.1">The span processor</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.373.1"> is a component of the OpenTelemetry export pipeline. </span><span class="koboSpan" id="kobo.373.2">When OpenTelemetry is notified about activity start or stop events, it synchronously calls the corresponding method on the processor. </span><span class="koboSpan" id="kobo.373.3">By implementing our own processor and adding it to the tracer provider, we can intercept all activities and add attributes from </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.375.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">ThreadLocal</span></strong><span class="koboSpan" id="kobo.377.1">, or another context available globally. </span><span class="koboSpan" id="kobo.377.2">We could also overwrite or remove attributes or filter </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">out activities.</span></span></p>
<h3><span class="koboSpan" id="kobo.379.1">Enriching</span></h3>
<p><span class="koboSpan" id="kobo.380.1">Before we do this for the meme</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.381.1"> name, we need to decide how to pass it to the processor. </span><span class="koboSpan" id="kobo.381.2">Since we want meme names to be on all spans from all services, it would be a good case for baggage. </span><span class="koboSpan" id="kobo.381.3">Baggage, as we saw in </span><a href="B19423_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.382.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.383.1">, </span><em class="italic"><span class="koboSpan" id="kobo.384.1">Observability Needs of Modern Applications</span></em><span class="koboSpan" id="kobo.385.1">, represents application-specific context propagated </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">between services.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">So, let’s go ahead and add the meme name to the baggage on the frontend </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Meme</span></strong><span class="koboSpan" id="kobo.389.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">Upload</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.391.1"> pages:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.392.1">Meme.cshtml.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
Activity.Current.SetTag("meme_name", name);
</span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Baggage.SetBaggage("meme_name", name);</span></strong></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs"><span class="koboSpan" id="kobo.395.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Pages/Meme.cshtml.cs</span></a></p>
<p><span class="koboSpan" id="kobo.396.1">Setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">Baggage</span></strong><span class="koboSpan" id="kobo.398.1"> does not always affect an activity that has started beforehand and is current now – it’s a side effect of </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.400.1">, and we’ll dig into this in </span><a href="B19423_06.xhtml#_idTextAnchor098"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.402.1">, </span><em class="italic"><span class="koboSpan" id="kobo.403.1">Tracing Your Code</span></em><span class="koboSpan" id="kobo.404.1">. </span><span class="koboSpan" id="kobo.404.2">So, we’re going to keep setting meme name tags on activities on the frontend pages. </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">Baggage</span></strong><span class="koboSpan" id="kobo.406.1"> uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">AsyncLocal</span></strong><span class="koboSpan" id="kobo.408.1"> underneath, so we can now reliably use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">the processor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.410.1">MemeNameEnrichingProcessor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
class MemeNameEnrichingProcessor : BaseProcessor&lt;Activity&gt;
{
    public override void OnEnd(Activity activity)
    {
        var name = GetName(activity);
        if (name != null)
            activity.SetTag("meme_name", name);
    }
    private string? </span><span class="koboSpan" id="kobo.411.2">GetName(Activity activity)
    {
</span><strong class="bold"><span class="koboSpan" id="kobo.412.1">        if (Baggage.Current.GetBaggage()</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.413.1">             .TryGetValue("meme_name", out var name))</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.414.1">            </span></strong><strong class="bold"><span class="koboSpan" id="kobo.415.1">return name;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.416.1">        return activity.GetBaggageItem("meme_name");</span></strong><span class="koboSpan" id="kobo.417.1">
    }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs"><span class="koboSpan" id="kobo.418.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/MemeNameEnrichingProcessor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.419.1">We’re overriding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">OnEnd</span></strong><span class="koboSpan" id="kobo.421.1"> method here – we first get the meme name</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.422.1"> from the baggage and add it as a tag to the activity. </span><span class="koboSpan" id="kobo.422.2">We don’t need to check whether the activity is </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">null</span></strong><span class="koboSpan" id="kobo.424.1"> since the processor won’t be called in such a case, but we might still need to check whether it’s sampled in because, as we’ll see soon, sampled-out activities can still sometimes reach </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">your processor.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.426.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.427.1">We get a name from </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Baggage.Current</span></strong><span class="koboSpan" id="kobo.429.1">, but if it’s not there, we also check </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Activity.Baggage</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">The reason is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">Baggage</span></strong><span class="koboSpan" id="kobo.433.1"> type lives in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.435.1"> namespace and can be used beyond tracing. </span><span class="koboSpan" id="kobo.435.2">But ASP.NET Core is not aware of it and populates </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Baggage</span></strong><span class="koboSpan" id="kobo.437.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">Activity</span></strong><span class="koboSpan" id="kobo.439.1">. </span><span class="koboSpan" id="kobo.439.2">As a rule of thumb, always set </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">Baggage</span></strong><span class="koboSpan" id="kobo.441.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Baggage.SetBaggage</span></strong><span class="koboSpan" id="kobo.443.1">, but read it from </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Baggage</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.445.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">Activity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">The last step is to register this processor on </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">TracerProvider</span></strong><span class="koboSpan" id="kobo.450.1"> on the frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">storage services:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.452.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
</span><strong class="bold"><span class="koboSpan" id="kobo.454.1">    .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()</span></strong><span class="koboSpan" id="kobo.455.1">
    …);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.456.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.457.1">That’s it – the frontend adds a meme name to </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Baggage</span></strong><span class="koboSpan" id="kobo.459.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Baggage</span></strong><span class="koboSpan" id="kobo.461.1"> is automatically propagated to </span><strong class="bold"><span class="koboSpan" id="kobo.462.1">storage</span></strong><span class="koboSpan" id="kobo.463.1">. </span><span class="koboSpan" id="kobo.463.2">Whenever any activity ends, the enriching processor stamps the meme name </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">By the way, we can also use the processor</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.466.1"> to remove unwanted tags by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">SetTag</span></strong><span class="koboSpan" id="kobo.468.1"> with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">null</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> value.</span></span></p>
<h3><span class="koboSpan" id="kobo.471.1">Filtering</span></h3>
<p><span class="koboSpan" id="kobo.472.1">Sometimes you want to drop</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.473.1"> some activities – for example, those that represent retrieving static files on a frontend or requests from </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">web crawlers.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">Dropping an activity after it has started in the middle of a trace breaks causation. </span><span class="koboSpan" id="kobo.475.2">It should be only done for activities that don’t have </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">any children.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">Some instrumentations provide a hook to suppress activities so they are never even created – we’ll see some examples of it later in </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">But instrumentations don’t always</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.480.1"> support suppression, and filtering out already started activities might be the only option. </span><span class="koboSpan" id="kobo.480.2">Let’s see how to do it with </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">a processor:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.482.1">StaticFilesFilteringProcessor.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.483.1">
public class StaticFilesFilteringProcessor :
    BaseProcessor&lt;Activity&gt;
{
    public override void OnEnd(Activity activity)
    {
        if (activity.Kind == ActivityKind.Server &amp;&amp;
            activity.GetTagItem("http.method") as string
                                              == "GET" &amp;&amp;
            activity.GetTagItem("http.route") == null)
            </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">activity.ActivityTraceFlags &amp;=</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.485.1">              ~ActivityTraceFlags.Recorded;</span></strong><span class="koboSpan" id="kobo.486.1">
     }
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs"><span class="koboSpan" id="kobo.487.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.488.1">In this processor, we check whether the activity has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">Server</span></strong><span class="koboSpan" id="kobo.490.1"> kind (describes an incoming request), a </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">GET</span></strong><span class="koboSpan" id="kobo.492.1"> method, and does not have a route. </span><span class="koboSpan" id="kobo.492.2">We can only check route presence in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">OnEnd</span></strong><span class="koboSpan" id="kobo.494.1"> callback as the route is calculated after the </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">activity starts.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Hence, we unset the recording flag on </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Activity</span></strong><span class="koboSpan" id="kobo.498.1"> so it will be dropped later in the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">exporting pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">You may come up with a better heuristic to identify static files, and if it doesn’t require a route, you could suppress such activities using ASP.NET Core instrumentation options, as we’ll see a </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">bit later.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">To register this processor, add it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">TracerProviderBuilder</span></strong><span class="koboSpan" id="kobo.504.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">AddProcessor</span></strong><span class="koboSpan" id="kobo.506.1"> method. </span><span class="koboSpan" id="kobo.506.2">Make sure to add processors in the order you want them </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">to run:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.508.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
</span><strong class="bold"><span class="koboSpan" id="kobo.510.1">    .AddProcessor&lt;StaticFilesFilteringProcessor&gt;()</span></strong><span class="koboSpan" id="kobo.511.1">
    .AddProcessor&lt;MemeNameEnrichingProcessor&gt;()
    …
);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs"><span class="koboSpan" id="kobo.512.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/StaticFilesFilteringProcessor.cs</span></a></p>
<p><span class="koboSpan" id="kobo.513.1">We just learned how to filter</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.514.1"> and enrich activities with processors; let’s now see what we can do with </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">instrumentation options.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.516.1">Customizing instrumentations</span></h2>
<p><span class="koboSpan" id="kobo.517.1">Instrumentations</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.518.1"> may provide configuration options allowing to customize telemetry collection. </span><span class="koboSpan" id="kobo.518.2">For example, you can configure recording exception events with HTTP client and ASP.NET Core instrumentations through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">RecordException</span></strong><span class="koboSpan" id="kobo.520.1"> flag on the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">configuration options:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.522.1">
AddHttpClientInstrumentation(o =&gt; o.RecordException = true)</span></pre>
<p><span class="koboSpan" id="kobo.523.1">Instrumentations can also provide callbacks allowing to populate attributes from instrumentation-specific contexts such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">request</span></strong><span class="koboSpan" id="kobo.525.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">response</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.527.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">Let’s use it to set a request size on incoming HTTP requests on storage, so we can analyze meme sizes using ASP.NET Core instrumentation </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">enrichments hooks:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.530.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
AddAspNetCoreInstrumentation(o =&gt;
{
    o.EnrichWithHttpRequest = (activity, request) =&gt;
        activity.SetTag("http.request_content_length",
                       request.ContentLength);
    o.EnrichWithHttpResponse = (activity, response) =&gt;
        activity.SetTag("http.response_content_length",
                        response.ContentLength);
    o.RecordException = true;
})</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs"><span class="koboSpan" id="kobo.532.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/storage/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.533.1">In addition to ASP.NET Core, you can find similar hooks for HTTP, gRPC, and SQL client instrumentations available in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">opentelemetry-dotnet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> repo.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">The same instrumentations</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.537.1"> also provide hooks that prevent </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">Activity</span></strong><span class="koboSpan" id="kobo.539.1"> from being created. </span><span class="koboSpan" id="kobo.539.2">For example, if we wanted to suppress activities created for static files instead of dropping them in the processor, we could write something </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.541.1">Program.cs</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.542.1">AddAspNetCoreInstrumentation(o =&gt; o.Filter =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.543.1">    ctx =&gt; !IsStaticFile(ctx.Request.Path))</span></strong><span class="koboSpan" id="kobo.544.1">
...
</span><span class="koboSpan" id="kobo.544.2">static bool IsStaticFile(PathString requestPath)
{
    return requestPath.HasValue &amp;&amp;
        (requestPath.Value.EndsWith(".js") ||
         requestPath.Value.EndsWith(".css"));
}</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.545.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.546.1">If you consider suppressing or enriching individual activities based on dynamic context, instrumentation hooks, when available, are the best option. </span><span class="koboSpan" id="kobo.546.2">If you want to enrich all activities with ambient context, processors would be the right choice. </span><span class="koboSpan" id="kobo.546.3">Let’s now see how to populate static context</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.547.1"> on all activities </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">with resources.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.549.1">Resources</span></h2>
<p><span class="koboSpan" id="kobo.550.1">An OpenTelemetry resource describes</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.551.1"> a service instance – it’s a set of static attributes describing the service name, version, namespace, instance, or any other static property. </span><span class="koboSpan" id="kobo.551.2">OpenTelemetry defines semantic conventions for Kubernetes, generic containers, clouds, processes, OS, devices, and other common </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">resource kinds.</span></span></p>
<p><span class="koboSpan" id="kobo.553.1">You can configure resources explicitly or through environment variables. </span><span class="koboSpan" id="kobo.553.2">For example, we already used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">OTEL_SERVICE_NAME</span></strong><span class="koboSpan" id="kobo.555.1"> environment variable to configure the service name. </span><span class="koboSpan" id="kobo.555.2">We can set </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">OTEL_RESOURCE_ATTRIBUTES</span></strong><span class="koboSpan" id="kobo.557.1"> to a list of comma-separated key-value pairs (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">region=westus,tag=foo</span></strong><span class="koboSpan" id="kobo.559.1">) to specify any </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">custom resources.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">Explicit configuration can be done with </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">ResourceBuilder</span></strong><span class="koboSpan" id="kobo.563.1">, which we should register </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">TraceProviderBuilder</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.567.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.568.1">
var env = new KeyValuePair&lt;string, object&gt;("env",
  builder.Environment.EnvironmentName);
var resourceBuilder = ResourceBuilder.CreateDefault()
    .AddService("frontend", "memes", "1.0.0")
    .AddAttributes(new[] { env });
...
</span><span class="koboSpan" id="kobo.568.2">Builder.Services.AddOpenTelemetry()
  .WithTracing(builder =&gt; builder
    .SetResourceBuilder(resourceBuilder)
  ...
</span><span class="koboSpan" id="kobo.568.3">);</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.569.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.570.1">Note that environment variable detection is done by default, but you can turn it off by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">ResourceBuilder.CreateEmpty</span></strong><span class="koboSpan" id="kobo.572.1"> instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">CreateDefault</span></strong><span class="koboSpan" id="kobo.574.1"> factory method. </span><span class="koboSpan" id="kobo.574.2">Resources are populated on each of the signals, and we can configure different resources for traces, metrics, and logs </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">We’re ready to run the meme service</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.577.1"> and check out the result. </span><span class="koboSpan" id="kobo.577.2">Go ahead and run it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">compose up --build</span></strong><span class="koboSpan" id="kobo.579.1">. </span><span class="koboSpan" id="kobo.579.2">After the application starts, hit the frontend at </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">http://locahost:5051</span></strong><span class="koboSpan" id="kobo.581.1"> and upload and download some memes. </span><span class="koboSpan" id="kobo.581.2">Now, you should be able to see new attributes – meme names on all spans and content size on incoming requests on storage. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.582.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.583.1">.2</span></em><span class="koboSpan" id="kobo.584.1"> shows an example of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">GET</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.586.1"> request:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.587.1"><img alt="Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes" src="image/B19423_05_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.588.1">Figure 5.2 – Auto-collected ASP.NET Core activity with custom attributes</span></p>
<p><span class="koboSpan" id="kobo.589.1">We also get new resource attributes</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.590.1"> on every exported span, as well as exception events on incoming and outgoing HTTP spans, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.591.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.592.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.594.1"><img alt="Figure 5.3 – Resource attributes and exception events" src="image/B19423_05_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.595.1">Figure 5.3 – Resource attributes and exception events</span></p>
<p><span class="koboSpan" id="kobo.596.1">Here, we can see </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">service.version</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">service.namespace</span></strong><span class="koboSpan" id="kobo.600.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">service.instance.id</span></strong><span class="koboSpan" id="kobo.602.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">env</span></strong><span class="koboSpan" id="kobo.604.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">region</span></strong><span class="koboSpan" id="kobo.606.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">tag</span></strong><span class="koboSpan" id="kobo.608.1"> attributes coming from our application, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">host.name</span></strong><span class="koboSpan" id="kobo.610.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">os.type</span></strong><span class="koboSpan" id="kobo.612.1"> are added later on by the OpenTelemetry Collector </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">resource detector.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">With resource attributes, processors and baggage, instrumentation hooks, and flags, you can customize telemetry</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.615.1"> auto-collection, enrich activities with custom attributes, add events, and record exceptions. </span><span class="koboSpan" id="kobo.615.2">You can also change or remove attributes and suppress or filter out activities. </span><span class="koboSpan" id="kobo.615.3">But what about metrics, can we </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">customize them?</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.617.1">Metrics</span></h2>
<p><span class="koboSpan" id="kobo.618.1">Auto-collected metrics</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.619.1"> are not as customizable as traces. </span><span class="koboSpan" id="kobo.619.2">With OpenTelemetry SDK, we can only enrich them using static resource attributes, but OpenTelemetry Collector provides processors that can add, remove, or rename attribute names and values, aggregate across attributes, change data types, or massage metrics in </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">other ways.</span></span></p>
<p><span class="koboSpan" id="kobo.621.1">Still, you can filter out specific instruments or their attributes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">MeterProviderBuilder.AddView</span></strong><span class="koboSpan" id="kobo.623.1"> method. </span><span class="koboSpan" id="kobo.623.2">For example, you can drop an instrument with a specific name using the </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.625.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.626.1">
WithMetrics(builder =&gt; builder.AddView(
  "process.runtime.dotnet.jit.il_compiled.size",
  </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">MetricStreamConfiguration.Drop</span></strong><span class="koboSpan" id="kobo.628.1">));</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.629.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.630.1">Prometheus replaces the dot with an underscore and the corresponding instrument appears as </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">process_runtime_dotnet_jit_il_compiled_size</span></strong><span class="koboSpan" id="kobo.632.1"> there. </span><span class="koboSpan" id="kobo.632.2">Check the corresponding OpenTelemetry instrumentation documentation to find the original name of the instrument. </span><span class="koboSpan" id="kobo.632.3">For example, .NET runtime instrumentation documentation can be found here:  </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">git</span></span><a href="http://hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md"><span class="No-Break"><span class="koboSpan" id="kobo.634.1">hub.com/open-telemetry/opentelemetry-dotnet-contrib/blob/main/src/OpenTelemetry.Instrumentation.Runtime/README.md</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.635.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.636.1">You can also specify attributes</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.637.1"> you want on the instrument – OpenTelemetry will use only those specified and will drop other attributes. </span><span class="koboSpan" id="kobo.637.2">It can be done to save costs on unused attributes or to remove high-cardinality attributes added </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">by mistake.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">For example, this code removes </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">http.scheme</span></strong><span class="koboSpan" id="kobo.641.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">http.flavor</span></strong><span class="koboSpan" id="kobo.643.1"> from the ASP.NET Core request </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">duration metric:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.645.1">Program.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
AddView("http.server.duration",
    new MetricStreamConfiguration(){
    TagKeys = new [" {"http.host", "http.method",
       "http.scheme", "http.target", "http.status_code" }
})</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs"><span class="koboSpan" id="kobo.647.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/Program.cs</span></a></p>
<p><span class="koboSpan" id="kobo.648.1">We just saw how to enrich traces</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.649.1"> and metrics with application-specific context, and update or remove attributes using different mechanisms available in OpenTelemetry. </span><span class="koboSpan" id="kobo.649.2">Let’s continue exploring OpenTelemetry configuration and learn how to configure </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">context propagation.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.651.1">Customizing context propagation</span></h1>
<p><span class="koboSpan" id="kobo.652.1">When instrumenting</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.653.1"> new systems, using W3C trace context propagation is the default and the easiest option – it does not need any explicit configuration since .NET and OpenTelemetry use it by default. </span><span class="koboSpan" id="kobo.653.2">However, existing systems may employ legacy context </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">propagation conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">To support them, we can configure a custom global propagator on OpenTelemetry using </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">Sdk.SetDefaultTextMapPropagator</span></strong><span class="koboSpan" id="kobo.657.1">. </span><span class="koboSpan" id="kobo.657.2">For example, if one of your old client applications still uses some variation of custom correlation ID, you can still read it from request headers and convert it to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">trace-id</span></strong><span class="koboSpan" id="kobo.659.1">-compatible format (or move it </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">to baggage).</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">You can use a composite propagator and support multiple standards at once as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">this example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.663.1">XCorrelationIdPropagator.cs</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.664.1">
Sdk.SetDefaultTextMapPropagator(
  new CompositeTextMapPropagator(new TextMapPropagator[] {
    new B3Propagator(true),
    new XCorrelationIdPropagator(),
    new BaggagePropagator()}));
DistributedContextPropagator.Current =
  DistributedContextPropagator.CreateNoOutputPropagator();</span></pre>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs"><span class="koboSpan" id="kobo.665.1">https://github.com/PacktPublishing/Modern-Distributed-Tracing-in-.NET/blob/main/chapter5/memes/frontend/XCorrelationIdPropagator.cs</span></a></p>
<p><span class="koboSpan" id="kobo.666.1">Here, we configured the B3 propagator from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">OpenTelemetry.Extensions.Propagators</span></strong><span class="koboSpan" id="kobo.668.1"> package, a custom one for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">x-correlation-id</span></strong><span class="koboSpan" id="kobo.670.1"> support, and also one for baggage. </span><span class="koboSpan" id="kobo.670.2">Note that we also disabled native ASP.NET Core and HTTP client propagation by setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">DistributedContextPropagator.Current</span></strong><span class="koboSpan" id="kobo.672.1"> to the no-output propagator. </span><span class="koboSpan" id="kobo.672.2">If we don’t do it, they will keep extracting and injecting </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">Trace-Context</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.674.1"> headers.</span></span></p>
<p><span class="koboSpan" id="kobo.675.1">When using composite</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.676.1"> context propagators, make sure to resolve collisions and define priority in case you get multiple conflicting combinations of trace context in the same request – we’ll talk more about it in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.677.1">Chapter 16</span></em></span><span class="koboSpan" id="kobo.678.1">, </span><em class="italic"><span class="koboSpan" id="kobo.679.1">Instrumenting </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.680.1">Brownfield Applications</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.682.1">Processing a pipeline with the OpenTelemetry Collector</span></h1>
<p><span class="koboSpan" id="kobo.683.1">As we’ve seen before, the OpenTelemetry Collector</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.684.1"> is another component</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.685.1"> that’s capable of controlling, enriching, filtering, converting, routing, aggregating, sampling, and processing telemetry in any other possible way. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.686.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.687.1">.4</span></em><span class="koboSpan" id="kobo.688.1"> shows the main </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">Collector components:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.690.1"><img alt="Figure 5.4 – OpenTelemetry Collector pipeline" src="image/B19423_05_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.691.1">Figure 5.4 – OpenTelemetry Collector pipeline</span></p>
<p><span class="koboSpan" id="kobo.692.1">Receivers get telemetry from different sources, and processors massage data and pass it over </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">to exporters.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">Since the collector</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.695.1"> is a separate process, potentially running</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.696.1"> on a different machine, it does not have a dynamic context, such as a specific HTTP request header, which you might want to stamp on spans. </span><span class="koboSpan" id="kobo.696.2">Such context can only be added inside </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">But the collector could have more context about the environment the application runs in – for example, it can enrich telemetry with Kubernetes or cloud provider context. </span><span class="koboSpan" id="kobo.698.2">It can also receive telemetry in any format and convert it into </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">OpenTelemetry signals.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">The Collector supports a variety of receivers including Docker stats, statsd, or containerd for metrics, Kubernetes events, syslog, or journald for logs, and many others. </span><span class="koboSpan" id="kobo.700.2">Collector processors can enrich, filter, or change attribute names and values on any signal. </span><span class="koboSpan" id="kobo.700.3">One of the common use cases is sensitive </span><span class="No-Break"><span class="koboSpan" id="kobo.701.1">data redaction.</span></span></p>
<p><span class="koboSpan" id="kobo.702.1">You can find available Collector components</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.703.1"> in the OpenTelemetry Registry, </span><a href="https://opentelemetry.io/registry"><span class="koboSpan" id="kobo.704.1">https://opentelemetry.io/registry</span></a><span class="koboSpan" id="kobo.705.1">; just make sure to check the stability level for each component you </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">consider using.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">In many cases, it’s not a question of whether to configure and customize your telemetry pipeline in-process or with Collector – it’s both. </span><span class="koboSpan" id="kobo.707.2">Collector can help you migrate from one observability stack to another, provide safety</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.708.1"> belts on telemetry</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.709.1"> collection, and offload some work from </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">your application.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.711.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.712.1">In previous chapters, we explored telemetry auto-collection, and now we have learned how to customize this telemetry. </span><span class="koboSpan" id="kobo.712.2">We learned about different sampling approaches – head-based and tail-based. </span><span class="koboSpan" id="kobo.712.3">Head-based sampling makes the decision to record a trace (or span) when it starts with a certain probability. </span><span class="koboSpan" id="kobo.712.4">Children can follow parent decisions and then traces are always complete, but it’s not possible to control the volume of traces on individual services. </span><span class="koboSpan" id="kobo.712.5">To overcome this, downstream services can configure different rates and use consistent sampling to maximize the number of complete traces. </span><span class="koboSpan" id="kobo.712.6">Some traces become partial but are still useful for monitoring individual services or groups </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.714.1">Probability sampling captures a percentage of all traces and is great to mitigate performance overhead. </span><span class="koboSpan" id="kobo.714.2">If you need predictable costs, you should consider rate-based sampling. </span><span class="koboSpan" id="kobo.714.3">It’s implemented in the OpenTelemetry Collector or by observability vendors. </span><span class="koboSpan" id="kobo.714.4">The OpenTelemetry Collector can also do tail-based sampling and record failures and long traces with </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">higher probability.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">Auto-instrumentations collect generic information, so we need to add application-specific context to gain a much deeper level of observability. </span><span class="koboSpan" id="kobo.716.2">Enrichment can be done inside the process with resources – static attributes describing your service instance, or with span processors, instrumentation hooks, or configuration options that can capture dynamic context. </span><span class="koboSpan" id="kobo.716.3">We can add, remove, or change attributes, and we can use baggage to propagate application-specific context within </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">We can sometimes suppress activities with instrumentation hooks or flags or filter them out using processors. </span><span class="koboSpan" id="kobo.718.2">Filtering activities that have already started should be done with caution as it will break the correlation between dropped activity’s ancestors and successors. </span><span class="koboSpan" id="kobo.718.3">It should only be done for activities that don’t </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">have children.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Metrics allow some customization too – we can enrich them with resource attributes, drop specific instruments, or limit attributes populated </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">by instrumentations.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">We also looked at context propagation customization, which can provide interoperability with custom and legacy correlation solutions you </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">might have.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Finally, we talked about Collector features that can be used in addition to in-process configuration – environment resource detection or filtering and massaging telemetry. </span><span class="koboSpan" id="kobo.724.2">It can also provide rate-limiting sampling and protect your telemetry pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">from overloading.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">In this chapter, you learned to choose a sampling strategy and implement it, enrich traces with application context, and customize context propagation. </span><span class="koboSpan" id="kobo.726.2">It concludes our auto-instrumentation journey; from now on, we’re going to explore instrumentation internals and learn how to write our own. </span><span class="koboSpan" id="kobo.726.3">In the next chapter, we’ll focus on </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">creating activities.</span></span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.728.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.729.1">How would you build a general-purpose sampling solution that also captures failures and long-running traces in a </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">distributed application?</span></span></li>
<li><span class="koboSpan" id="kobo.731.1">How would you record retries on the HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">client spans?</span></span></li>
<li><span class="koboSpan" id="kobo.733.1">Configure rate-limiting sampling on the </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">OpenTelemetry Collector.</span></span></li>
</ol>
</div>
</body></html>