- en: Chapter 4. Comparing Approaches for Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we have centered upon the C# language and its evolution.
    However, this evolution is not the only one in .NET framework as far as languages
    are concerned. Other languages have kept evolving as well (and this is independent
    of the fact that many more compilers have increased the list of languages for
    which there is a .NET version nowadays). Especially, there are two members of
    the .NET language ecosystem, F# and TypeScript, which are becoming increasingly
    popular among the programmer community, and we're going to—briefly—introduce them
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, we will review some of the most relevant aspects of both languages,
    with C# as a reference in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: With this goal, our purpose is to roughly underline the most crucial programming
    structures in such a way that you can establish a comparison between the ways
    you code usual and everyday programming tasks but using different languages.
  prefs: []
  type: TYPE_NORMAL
- en: I'd like to add a note about VB.NET and why I'm not including it here. Even
    considering that VB.NET has evolved in parallel with the rest of the languages
    of the .NET ecosystem, (and VB.NET followers, please forgive me, but this is a
    tendency that most of you must have noticed for sure), the truth is that there's
    more hype around F# and JavaScript languages (and TypeScript, for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: That tendency is especially clear when we talk about future expectations. VB.NET
    users can be confident that while Microsoft doesn't say the opposite, VB.NET will
    keep on running as expected, and will be a language of the previously mentioned
    language's ecosystem, with all the goodness and advantages that a developer is
    used to find inside Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to F# and TypeScript, both have something in common: they belong
    to the category of functional languages (although TypeScript uses classes, which
    later on "compile" to functions). The first one will serve us as a comparison
    with C#, since it''s a compiled language, unlike TypeScript, which is an interpreted
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The list of functional languages of all types keeps on growing. Wikipedia maintains
    a pretty comprehensive list of most of them at [https://en.wikipedia.org/wiki/Category:Functional_languages](https://en.wikipedia.org/wiki/Category:Functional_languages).
  prefs: []
  type: TYPE_NORMAL
- en: So, we'll review the differences between both approaches to programming and
    identify those programming structures that are intended to obtain the same results,
    each one expressed in its own style. Also, note that there are a number of applications
    out there to solve problems (especially mathematical and engineering ones) with
    an implementation of an F# DLL, since possibilities increase with every version
    as the language grows.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the continuous growth of TypeScript adoption has been clearly
    stated with the announcement by Google that TypeScript has been the language used
    in the building of their new version of the Angular framework (Angular 2.0), available
    since September 2016\. That's a quite unexpected collaboration!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Foundations of functional languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# as a fully functional language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equivalence of typical programming structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript inception and main purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic structures and programming characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript support in Visual Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A functional language is one that avoids changing the state and mutable data
    and mainly focuses its statements on the evaluation of code as mathematical functions.
    So, the entire programming experience is based on functions (or procedures) to
    construct its program flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note how different this approach is from object-oriented languages for whom
    everything is an object (some OOP languages have primitive types, such as Java,
    but, in general, types can always be considered objects).
  prefs: []
  type: TYPE_NORMAL
- en: The next graphic shows some popular Imperative Languages as opposed to pure
    Functional Languages and the place F# (and Scala) occupy between the two models.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, the flow of the program''s goal keeps declaring functions
    that relate or base themselves in other functions until the goal is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional languages](img/image00483.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A functional language does not have the side-effects of other imperative programming
    languages since the state does not change and the same call will return the same
    results as long as the function calls are made with the same arguments. Eliminating
    these kinds of side-effects can make the behavior much more predictive, and that's
    precisely one of the most important motivations for their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this advantage also implies a consideration: not all programs can
    be developed without these effects, especially those that require changing the
    state and the creation of I/O procedures.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, as a discipline, has its roots in *Lambda Calculus*,
    originally developed as a formal system to express computation in terms of function
    abstractions, and it was first developed by Alonzo Church in the late twenties
    in the context of research on the foundations of mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two points should be noted here:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Calculus is a universal model of computation equivalent to the *Turing
    Machine*, as stated by Wikipedia. Furthermore, Turing himself refers to this work
    in his seminal paper on State Machines. There are interesting works that relate
    to both and explain their differences, although they're not the goal of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even considering they're not the same as the lambda expressions we've seen so
    far in the C# language, there's a direct connection given that the Lambda Terms
    or Lambda Expressions used in Lambda Calculus refer to binding a variable in a
    function pretty much in the way we've seen in previous examples. For more information
    on Lambda Calculus, refer to [https://en.wikipedia.org/wiki/Lambda_calculus](https://en.wikipedia.org/wiki/Lambda_calculus).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: F# 4 and .NET Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first version of the F# language showed up in 2005, although it was something
    that you had to download and install separately. The language evolution process
    was originally managed by Don Syme from Microsoft Research, although nowadays,
    it uses an open development and engineering process, basically monitored by the
    F# Software Foundation, founded in 2013, which became a 501C3 nonprofit organization
    in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the current version is 4.0, and it appeared in January 2016 along
    with several improvements in the tooling linked to Visual Studio. However, support
    for F# programming can be found also in **Xamarin Studio**, **Mono**, **MonoDevelop**,
    **SharpDevelop**, **MBrace**, and **WebSharper**.
  prefs: []
  type: TYPE_NORMAL
- en: According to **Syme**, F# originated from ML and has influences from other functional
    languages, mainly from **OCaml**, **C#**, **Python**, **Haskell**, **Scala**,
    and **Erlang**. To be more precise, Syme explains that from the syntactic point
    of view, the main influence comes from OCaml, while the object model aspect is
    inspired from C# and .NET.
  prefs: []
  type: TYPE_NORMAL
- en: F# is defined as a strongly typed, multi-paradigm, and functional-first programming
    language that encompasses functional, imperative, and object-oriented programming
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: It uses type inference from its inception in the way we've already seen from
    version 3.0 in C# when using the `var` keyword. However, F# admits explicit type
    annotations, and it requires it in certain situations. However, exceptions apart,
    every expression in F# is linked to a static type. If the function or expression
    doesn't return any value, the return type is named `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: The inevitable Hello World demo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, let''s start with the mandatory Hello World program, but first, keep in
    mind that you will have to activate F# tools in Visual Studio if you did not do
    that at installation time. (If you didn''t, when accessing the F# language section,
    you''ll be offered this activation.) Once activation is ready, you will be presented
    with a new type of project linked to this language in the way shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The inevitable Hello World demo](img/image00484.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To start with, you can pick up the tutorial, which is a comprehensive collection
    of the different aspects of the language— it's pretty well structured—or just
    use a console application for that matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you opt for the tutorial, you can mark a section of the code you want to
    test, and if you right-click on that area, you''ll be presented with two options
    for execution: **Execute In Interactive** and **Debug In Interactive**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The inevitable Hello World demo](img/image00485.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To visualize the results, we can—of course—create an executable and launch it
    in a console window, but for this scenario, F# Interactive Window is more suitable.
    For completeness, keep in mind that you can call the compiler (named `fsc.exe`)
    using the **build** option in Visual Studio just like you would with any other
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll start with writing very simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output in the **F# Interactive** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The inevitable Hello World demo](img/image00486.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we''ve done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `let` keyword in order to assign an arithmetic expression
    to variable `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we used the same keyword for another variable, variable `b`, which uses
    the previous definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `printfn` function of the F# library produced an output to the
    standard I/O, formatting the result in a manner similar to what we do in C#, just
    changing the `{0}..{1}` and so on, expressions into `%i` or the letter corresponding
    to the type of the value to be printed (`f` for float, `s` for strings, `d` for
    double, `A` for generic printing including arrays and tuples, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note how the interactive window presents an echo of the members implied in the
    process, indicating its type as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that since F# is considered another member of the Visual Studio
    family, it has its own area of configuration in the **Tools/Properties** dialog
    box, as shown in the next screenshot. In addition, another entry in this dialog
    allows you to configure behaviors of the **F# Interactive** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The inevitable Hello World demo](img/image00487.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Identifiers and scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scope of an identifier indicates the area of code where such an identifier
    is usable. All identifiers, either functions or values, are scoped (valid) starting
    at the end of their definition until the end of the section in which they act.
    Additionally, in F#, you don't have to explicitly return any value, since the
    result of the computation is automatically assigned the corresponding identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to create intermediate values for a computation, you denote it
    with indentation (by convention, the size of the indentation is 4, but the user
    can opt for any other value). Every indentation defines a new scope, and the end
    of every scope is marked by the end of the indentation. For example, let''s think
    of a function to calculate the hypotenuse of a right triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the `hypo` function, which receives two arguments of type `float`
    (note that we can explicitly indicate types with the syntax `arg:type`). Then,
    we declare `legsSquare` to be the sum of the squares of both triangle's legs,
    and this is done with a new level of indentation. Finally, we just calculate the
    square root of this intermediate variable without any other indication, which
    means that `System.Math.Sqrt(legsSquare)` is the return value.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note how we make a reference to `System.Math` directly since it's included
    in the references of the project. Alternatively, you can use the `open` keyword
    to indicate a reference to `System` (such as `open System`), and then, you can
    use the `Math` static class in an unqualified way.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `printfn` to format the output and make sure there's only one
    value to include in the formatted output string by enclosing the call to `hypo`
    in the parenthesis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the **F# Interactive** window will show the formatted result, as
    is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifiers and scope](img/image00488.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In F#, lists are ordered collections of immutable elements of the same type.
    Its generation admits many language-compatible options, but the initial style
    is very simple. If you go through the tutorial a bit, you''ll discover the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are introduced to the range operator: (`..`), which denotes a sequence
    of elements deductible for the compiler. Due to the echo feature of the Interactive
    window, we just have to mark that line and select **Interactive Window** to view
    the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists](img/image00489.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The range operator also admits the increment descriptor (..), allowing you
    to define a different, collective type, called sequence (`seq`) that supports
    many of the same functions as lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a sequence of elements starting with `5`, going through `15`,
    and increasing in steps of three (the output being the following):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same manner as earlier, let''s mark the following sentence and proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An array of tuples is created, each containing a number from 0 to 99 and its
    corresponding squares. There are a few things to notice in this sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning something in squared brackets means that the expression inside it
    should be evaluated to an array (similar to JavaScript). We've seen this in the
    previous sentence as well, but this time, inside the brackets, we see a `for..in`
    loop and a `->` symbol, which indicate the generated value for each step in the
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: This generated value turns out to be a tuple, since it's enclosed in parenthesis—a
    very powerful and expressive syntax.
  prefs: []
  type: TYPE_NORMAL
- en: List objects contain several useful methods to manipulate their inner collections.
    One of them is `List.map`, which permits you to apply a function to each element
    in the list and returns a new list with the calculated results.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note how close the philosophy of this approach reminds what
    we saw in C# when using generic's collections and passing a lambda expression
    to their methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `initialList` contains three float numbers, for which we want to calculate
    the square root. So, we generate another list (`sqrootList`) by calling `List.map`
    and passing to it as an argument an anonymous function that gets a value and returns
    its square root. The last argument is `initialList`. Note that the argument of
    `map` is just like a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once more, the output in the **F# Interactive** windows is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists](img/image00490.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Function declarations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We''ve seen how to use anonymous functions and how they can be passed as arguments
    to some methods. To declare a named function, you can use a similar syntax as
    what you used with variables but by specifying the arguments it can receive, following
    the function''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `func1` is the name of the function, and `x` the argument to be
    passed, which can, optionally, be enclosed in parenthesis. Later on, we can combine
    the previous declaration with an assignment to a variable, which you can see if
    you continue to analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, remember that arguments can be annotated (indicating its type explicitly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need to indicate code structures inside the function, we will use indentation
    the way we saw in a previous sample along with the required expression to be evaluated
    (and that''s what `func3` does here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the difference between lists in relation with tuples, which are defined
    enclosed in parenthesis. Furthermore, a list can be generated using expressions
    that include loops, as you can see in the following code, which uses such a construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have two `for` loops nested using the `for..in..do` syntax. Also,
    note the presence of the `yield` keyword, just like in C#. The previous code generates
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Function declarations](img/image00491.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And the list goes on...
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another important feature of F# is the pipeline operator (`|>`). It serves
    to pass a value to a function but by *piping* the result. The definition is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means: take a parameter `x` and apply it to function `f`. In this way,
    the parameter is passed before the function and we can express chains of calculations
    in a very suitable manner. For instance, we can define a sum function and use
    it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After the execution, we''ll obtain a value of 10 for `chainOfSums`. For example,
    consider that we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This means, take `numberList`, apply it to `List.map` of the function enclosed
    in parentheses (which calculates the square of every number in the list), and
    assign the result to the squares identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to link several operations in a sequence over the same collection,
    we can concatenate the operator, as the next sample in the tutorial shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another useful structure when managing collections is the `match..with` construct.
    It's used with the `|` operator to indicate different options, much like what
    we would do in a `switch` and `case` statement in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this in simple way, let''s try the typical recursive function to calculate
    the factorial of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note the presence of the `rec` keyword as a modifier of the function's declaration
    in order to indicate that the function is recursive. The variable to test (`n`)
    goes in between the `match..with` structure and the `|` operator separates the
    distinct cases to be tested. Also, look at how the underscore operator (`_`) is
    used to indicate what to do with any other value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **F# Interactive** window, once more, will show the correct results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pattern matching](img/image00492.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Classes and types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: F# can work well with classes and types, and by itself, it is considered a typed
    language. Actually, you can declare elements of any supported type using type
    abbreviations and type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, we just establish aliases of existing types. You can declare
    these aliases using the `type` keyword followed by an identifier (the alias) and
    assign it to the type it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that the second definition declares a new type construct made of two parts
    (`string` and `int`) that can be used later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common usage of types is to declare type definitions, indicating members
    as pairs of values (`key : type`) enclosed in curly braces, as the `RecordTypes`
    module of the tutorial reminds us (we reproduce it here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we launch the previous code in the **F# Interactive** window, we will get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes and types](img/image00493.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `contact1` identifier is qualified as `val (value)`. This
    value can also be used to declare further types based on the previous one. This
    is the purpose of the following declaration in the tutorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `contact2` is based on `contact1`, but there are two changed values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next definition makes things quite clear as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used to convert the `ContactCard` type into a string as we check the
    output in the **F# Interactive** window after adding another sentence to test
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classes and types](img/image00494.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Casting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In F#, casting sentences have their own specific operators. The two possible
    operations depend on the type of casting required (downcasting if you go from
    general to particular in the hierarchy, or upcasting if you proceed in the opposite
    way). As it happens, with C#, the hierarchy starts with `System.Object`, although
    there is an alias, `obj`, which we can use in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the behavior in relation to the compiler, let''s remember that upcasting
    is a safe operation because the compiler always knows the ancestors of the type
    to be converted. It is represented by a colon, followed by a greater-than sign
    (`:>`). For example, the following operation is legitimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Casting](img/image00495.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `someObject` identifier is declared in parenthesis as the
    result of a conversion from a literal string to `obj`. As a result, in the next
    sentence, Intellisense in V. Studio reminds us that `System.Object` declares exactly
    those members that appear in the contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the last 5 or 6 years, there has been a growing hype around the languages
    used to build websites and web applications. As you surely know, the reason was
    mainly related to the proliferation of mobile devices of all types: tablets, phones,
    IoT devices, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel to this, back in 2008, a new effort for standardization emerged at
    the W3C ([http://www.w3.org](http://www.w3.org), the entity that takes care of
    most of the Internet language's specs) in order to update these languages of the
    Web and make them more suitable for this decade's needs. Announcements like the
    elimination of Flash components (or Silverlight, for that matter) on platforms
    such as MacOS or iOS only fostered these attempts.
  prefs: []
  type: TYPE_NORMAL
- en: For the first time in many years, a bunch of companies invested in the creation
    of this new Open Web that would be capable of holding any kind of content in a
    flexible, adaptable, easy-to-use, and responsive way.
  prefs: []
  type: TYPE_NORMAL
- en: All these efforts came to an end in 2015, with the final recommendation of HTML5
    ([https://www.w3.org/TR/html5/](https://www.w3.org/TR/html5/)) along with a number
    of specifications related to the CSS3 presentation syntax (it's not a language,
    remember). They adopted a *most-needed* approach in the writing and testing process,
    starting with those whose implementation was a due requirement, such as Media
    Queries (very important in mobile devices, as you know).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the expected new version of the JavaScript language was published by
    ECMA ([http://www.ecma-international.org/](http://www.ecma-international.org/))
    and it received the name ECMAScript 2015 (previously named ES6 in the specification
    and testing processes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Important decisions were taken in the creation of the HTML, CSS, and JavaScript
    standards: preserving backward compatibility, applying good practices and principles
    (such as the S.O.L.I.D. principles), and above all, making these specifications
    *a continuous process of development and integration, for which the consensus
    of companies is key*. So, after this first release of the specifications, the
    work continued in all these areas, except now, engineers of the main user agents''
    manufacturers collaborated directly with W3C and ECMA in order to make the HTML,
    CSS, and JavaScript engines faster, more reliable, and up to date. The most evident
    applications that came up as a result are generally called modern browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: The new JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, a new JavaScript was born, which included many of the features that were
    long awaited by developers, such as classes, interfaces, scope variables, packages
    (finally, the concept of namespace shows up in the language, eliminating the need
    for closures), and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the new requirements, a set of libraries (a big one, by the way)
    appeared to help the developer in their daily tasks (they're numbered by hundreds,
    of thousands today).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence, the JavaScript language appeared to be the number one preference
    according to quite a few developer surveys carried out last year. One was carried
    out by the most popular code reference website among developers today: StackOverflow,
    which researched and published it with quite insightful results; you can read
    it at [http://stackoverflow.com/research/developer-survey-2015](http://stackoverflow.com/research/developer-survey-2015).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The poll is very wide and covers a lot of different aspects, with thousands
    of developers having participated. The following figure showing the language''s
    ranking is pretty important:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The new JavaScript](img/image00496.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All this is great, but support for these features in browsers immediately became
    an important issue. Actually, support is insufficient and only a few browsers
    (the modern browsers, which we mentioned earlier), such as Chrome's latest versions,
    Microsoft Edge, and Firefox's recent updates, give enough coverage of the great
    amount of news and functionality proposed by the new standards.
  prefs: []
  type: TYPE_NORMAL
- en: To make matters even worse, versions of the same type of browser are not coincidental,
    since they might depend on the device we use to open a website. In order to finalize
    the list of problems linked to this situation, developers started to build big
    applications in which, not just dozens or hundreds but several thousands of lines
    of JavaScript were required.
  prefs: []
  type: TYPE_NORMAL
- en: So, the need for a new tool to build these sites and applications arose, and—once
    again—our admired Anders Hejlsberg decided to do something serious about it. The
    solution he proposed is called TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript: a superset of JavaScript'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what''s TypeScript and why is it a solution for these problems? The first
    question is answered on its own site at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
    TypeScript is, as the ineffable Wikipedia states:'
  prefs: []
  type: TYPE_NORMAL
- en: Typescript is a free and open source programming language developed and maintained
    by Microsoft. It is a strict superset of JavaScript, and adds optional static
    typing and class-based object-oriented programming to the language. TypeScript
    may be used to develop JavaScript applications for client-side or server-side
    (Node.js) execution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And, how does TypeScript achieve these goals? Again, Wikipedia reminds us that:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is designed for development of large applications and transcompiles
    to JavaScript. As TypeScript is a superset of JavaScript, any existing JavaScript
    programs are also valid TypeScript programs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![TypeScript: a superset of JavaScript](img/image00497.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, we can start writing or use already existing JavaScript, knowing that it
    will be 100% compatible with older browsers. However, the term transcompiles requires
    a bit of explanation. Since JavaScript (any version of it) is an interpreted,
    functional language, the one in charge of its execution will always be the JavaScript
    runtime embedded in the browser or user agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, transcompiling (or just transpiling, like most people call it) is the process
    of converting TypeScript code into pure JavaScript that can be interpreted correctly
    by browsers. The advantage is double: on the one hand, we can decide which version
    of JavaScript we want (JavaScript 3, 5, or 2015), and on the other hand, when
    used with a tool such as Visual Studio (or even Visual Studio Code, Emacs, Vim,
    Sublime Text, and Eclipse via a plug-in provided by Palantir Technologies, and
    so on), we''ll get all the benefits of Intellisense, code completion, dynamic
    analysis, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, once those tools are configured, they can use Roselyn services to supply
    Intellisense, type inference, and all the goodness we all know and love from other
    languages. By convention (although it's not mandatory), TypeScript files have
    a `.ts` extension.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly is TypeScript?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The official answer to this question is that it is a superset of JavaScript
    that transpiles (generates after compilation) to valid JavaScript for whatever
    version you want to support: 3.0, 5.0 of ECMAScript 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it allows you to work with features that won't be available until
    the next releases of the specification or—even if they are—features that are not
    yet supported in the majority of browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides, the language starts with JavaScript, so any piece of JavaScript is
    also valid TypeScript. The big difference is that you work with a language that
    offers generally the same type of editing and compiling services that we''ve seen
    in this book related to Roslyn in particular: code completion, peek definitions,
    type checking, refactoring, code analysis, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Main features and coalitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another main feature is that the project was built to comply with any browser,
    any host, and any operating system. Actually, the TypeScript transpiler is written
    in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the two most important characteristics that this architecture
    provide are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A whole set of tools enabled by static types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of using features in the future, with the confidence that the
    resulting code will work in every browser (or server).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all these possibilities, a joint venture between Microsoft and Google appeared
    (to be precise, between the TypeScript team and Google's Angular Team) to work
    together in the new versions of Angular (2.0+).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, we recommend that you download and install the latest version of
    the library, which is accompanied by some project templates. These templates cover
    the use of TypeScript with Apache/Cordova, with Node.js, or plain HTML.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the latest version of TypeScript by searching for its name in
    the **Tools/Extensions and Updates** menu. There's another way to install it,
    by visiting the official site for the language located at [https://www.typescriptlang.org/](https://www.typescriptlang.org/),
    which also contains extra documentation, demos, and a REPL to test code snippets
    online.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current version that I''m using in this book is 1.8.4, but most likely,
    by the time the book is published, you''ll have access to versions higher than
    2.0\. After accepting to download the installable file, you''ll be presented with
    a confirmation dialog box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the tools](img/image00498.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to try a more complete and self-explanatory test of TypeScript,
    you can create a new project named `HTML Application` with TypeScript which you'll
    find in `Templates/TypeScript` after the previous installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution generates a web page, which shows a clock that changes the time
    every second. The review of the code structure is very informative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `app.ts` file is defining a class (`Greeter`). The class
    has a state, defined using three fields, two of which relate to the user interface,
    so they are created as `HTMLElement`.
  prefs: []
  type: TYPE_NORMAL
- en: The `constructor` method is in charge of the initialization. It gets an `HTMLElement`
    argument and creates a new `<span>` element next to it in order to display the
    time every second after reading it from the system's time. The value is assigned
    to the `innerText` argument of `<span>`, so it shows the current time from the
    beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have two methods: `start()` and `stop()`. The first uses a lambda
    and assigns the value of the `timerToken` field to a `setInterval` method, which
    receives a function to be called periodically. The return value is useful if you
    want to cancel the process at anytime, as we will do in slightly modifying the
    demo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is shown in the `HTMLElement` interface linked to it; note that
    only one element in the user interface is involved: a `div` element with its ID
    `content`.'
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism that turns on the clock is expressed after the definition of the
    `Greeter` class. In the `onload` event, the content element is linked to a new
    instance of the `Greeter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To summarize, the class' purpose is to define a behavior and associate that
    behavior with a part of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can stop the clock simply by including a button (or any other `HTMLElement`
    interface) and making a slight change in the TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `stop()` is already defined, there''s no need to change the `Greeter`
    class. We assign a call to the `stop()` method to the button''s `click` event,
    and that''s all that is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the tools](img/image00499.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Transpiling to different versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio gives us the option to choose which version of JavaScript will
    be generated after the process of transpilation. You just have to go to **Project**
    | **Properties** and select the **TypeScript Build** tab. You'll learn how you're
    offered several options on how you would like the transpiler to behave. One of
    them shows a ComboBox with the available final JavaScript options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note that other options are available on JSX, managing comments, combining
    JavaScript, and so on in the way shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transpiling to different versions](img/image00500.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A comparison of both files (`.ts` and `.js`) will make it clear how neat and
    concise (and object-oriented) the TypeScript code is in relation to the pure JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: However, the benefits don't end there. This is just the beginning, since most
    advantages are related to the creation process in the editor, Intellisense, type
    inference, and the like...
  prefs: []
  type: TYPE_NORMAL
- en: Advantages in the IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we pass the cursor over a definition of the previous code, observe how
    every element is recognized by its type: the class itself and its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advantages in the IDE](img/image00501.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s not just about recognizing the initialization values. If we change a
    member''s value in the code and assign it to a different (non-compatible) type,
    the IDE will complain about this circumstance again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Advantages in the IDE](img/image00502.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even within `HTMLElements`, you can find this kind of Intellisense, since a
    walk over the `innerText` property of the `span` element will tell you that the
    property is a string value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To end with this example and change the functionality so that we can stop the
    clock, we only need to add any suitable element in the UI and assign it a call
    to `Greeter.stop()`, for example, with the following code to the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the TypeScript code, the following is the `window.onload` assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for the sake of completeness, I''m including the whole code of the TypeScript
    file after the proposed modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will work like a charm. So, we can follow the OOP paradigm, create classes,
    define interfaces, and so on and still be working with pure JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: A note on TypeScript's object-oriented syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this basic demo, the `Greeter` class is defined using the new `class` keyword
    available in ECMAScript 2015\. You can declare a state for the class by defining
    its members, followed by the corresponding type—either it is another type (such
    as an `HTMLElement`) or a primitive type, such as `number`.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor gets the element passed to it, assigns it a text, and creates
    a new `span` element that will be the receiver of every new string the `start()`
    method generates in order to update the current time. Once that span is initialized,
    the preliminary state of the class is ready to start working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, two methods are defined: one to start the clock and another to stop
    it. Note that the clock is implemented using the `setInterval` function of JavaScript.
    The way to stop the interval process from keeping on running is by using a reference
    to the return value of that function. This is why `timerToken` is part of the
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, observe the declaration of the callback function passed to `setInterval`,
    since it is another lambda expression, which creates a new string containing the
    current time every half second.
  prefs: []
  type: TYPE_NORMAL
- en: There's another important thing to note. How does the demo work if there's no
    `app.js` file yet? Well, if you press the **Show all files** button in the **Solution
    Explorer** menu, you'll see that an `app.js` file has indeed been created, and
    prototype inheritance has been used to define the functionality, only that it's
    been created using the JavaScript 3 syntax, thus allowing older browsers to work
    with it without incompatibilities.
  prefs: []
  type: TYPE_NORMAL
- en: More details and functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, we've seen another approach to programming, this time, linked
    to the browser's universal language. With TypeScript, Microsoft takes a major
    step forward in covering its ecosystem of languages, and many companies are adopting
    it as an advanced solution that allows programming today with tomorrow's languages,
    as proclaimed by its slogan.
  prefs: []
  type: TYPE_NORMAL
- en: In this introduction, our purpose was only to present the language and its main
    features and integration with Visual Studio. In [Chapter 8](part0044.xhtml#aid-19UOO2
    "Chapter 8. Open Source Programming"), *Open Source Programming*, we'll cover
    more aspects of the language so you can have a better idea of its possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We skimmed the surface of some of the most typical characteristics of the F#
    and TypeScript languages, which are now part of the .NET language ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Both are functional languages, but—as you saw—the differences between them are
    evident. In the first case, we saw how declarations are made and understood the
    important role of operators in the language.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered some of the most typical uses and looked for equivalent expressions
    in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: As for TypeScript, we saw how it has become a superset of JavaScript, allowing
    the programmer to work using an OOP coding style while still transpiling the resulting
    code in a way that provides backward browser compatibility, even reaching version
    3 of the language.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored the fundamental role that Visual Studio plays in editing this
    code, so we included some screenshots from the TypeScript Editor to prove this
    point. We'll see more about it in [Chapter 8](part0044.xhtml#aid-19UOO2 "Chapter 8. Open
    Source Programming"), *Open Source Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go deeper into programmability using Reflection
    and Interop Applications, which allow us to use other well-known tools, such as
    the Microsoft Office Suite, directly in our applications.
  prefs: []
  type: TYPE_NORMAL
