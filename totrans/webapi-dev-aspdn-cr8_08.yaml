- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security and Identity in ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18971_07.xhtml#_idTextAnchor272), we discussed some more advanced
    topics of EF Core, such as `DbContext` pooling, performance optimization, and
    concurrency control. At this point, you should have the skills to create a web
    API application that accesses the database using EF Core. However, the application
    is not secure. Without any authentication, anyone who knows the URL can access
    the API, potentially exposing sensitive data to the public. To ensure the security
    of the web API application, we must take additional steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Security is a broad topic, and it is a crucial aspect of any application. In
    this chapter, we will explore some of the security features that ASP.NET Core
    provides, including authentication, authorization, and some best practices for
    securing your web API application. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving deeper into authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users and roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Identity API endpoints in ASP.NET Core 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other security topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you will have a basic understanding of the security
    features in ASP.NET Core. You will also know how to implement authentication and
    various authorization types in your web API applications, such as role-based authorization,
    claim-based authorization, and policy-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8).
    You can use VS Code or VS 2022 to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and authorization are two important aspects of security. Although
    these two terms are often used together, they are distinct concepts. Before we
    dive into the code, it is important to gain an understanding of the differences
    between authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: We have already built some web API applications. However, these APIs will be
    publicly available to anyone who knows the URL. For some resources, we want to
    restrict access to only authenticated users. For example, we have a resource that
    contains some sensitive information that should not be available to everyone.
    In this case, the application should be able to identify the user who is making
    the request. If the user is anonymous, the application should not allow the user
    to access the resource. This is where authentication comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: For some scenarios, we also want to restrict access to some specific users.
    For example, we want to allow authenticated users to read the resource, but only
    admin users to update or delete the resource. In this case, the application should
    be able to check whether the user has the required permissions to execute the
    operation. This is where authorization is used.
  prefs: []
  type: TYPE_NORMAL
- en: Long story short, authentication is used to know who the user is, while authorization
    is used to know what the user can do. Together, these processes are used to ensure
    that the user is who they claim to be and that they have the required permissions
    to access the resource.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core provides the Identity framework, which has a rich set of features
    for authentication and authorization. In this chapter, we will explore how to
    use the Identity framework to implement authentication and authorization in ASP.NET
    Core. We will also introduce some third-party authentication providers.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a scenario where we want to build a web API application that allows
    users to register and log in. For a specific endpoint, we only want to allow authenticated
    users to access the resource. In this section, we will explore how to implement
    this scenario. From this example, you will learn how to implement a basic authentication
    and authorization system in ASP.NET Core; this will help you prepare for the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the following resources in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST /account/register`: This resource will be used to register a new user.
    The user should send the username and password in the request body. After validating
    the username and password, the application will create a new user in the database
    and return a JWT token to the user. This JWT token will be used to authenticate
    the user in subsequent requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST /account/login`: This resource will be used to log into an existing user.
    After the user sends the username and password, the application will validate
    the credentials and return a JWT token to the user if the credentials are valid.
    The JWT token will be used to authenticate the user in subsequent requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /WeatherForecast`: This resource will be used to get the weather forecast.
    It only allows authenticated users to access the resource. The user should send
    the JWT token in the Authorization header to authenticate the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There should be more endpoints to manage users, such as updating the user profile,
    deleting the user, resetting the password, and more. However, we are not building
    a complete application in this chapter. To keep things simple, we will only focus
    on the minimal features required to demonstrate the authentication and authorization
    features in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: What is JWT?
  prefs: []
  type: TYPE_NORMAL
- en: 'JWT stands for *JSON Web Token*. It is an industry standard for representing
    claims securely between two parties. The RFC for JWT is RFC 7519: [https://www.rfc-editor.org/rfc/rfc7519](https://www.rfc-editor.org/rfc/rfc7519).
    A JWT token consists of three parts: header, payload, and signature. So, typically,
    a JWT token looks like `xxxxx.yyyyy.zzzzz`. The header contains the algorithm
    used to sign the token, the payload contains the claims, and the signature is
    used to verify the integrity of the token. For more information about JWT, see
    [https://jwt.io/introduction](https://jwt.io/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sample project with authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we must prepare the project and add any necessary NuGet packages.
    Additionally, we need to configure the database context to enable us to store
    user information in the database. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new ASP.NET Core web API project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it’s time to add the required NuGet packages. We will use ASP.NET Core
    Identity to implement the authentication. ASP.NET Core Identity is a membership
    system that provides authentication and authorization features. It is a part of
    the ASP.NET Core framework. We need to install the following NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Identity.EntityFrameworkCore`: This package is used for
    the EF Core implementation of ASP.NET Core Identity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.SqlServer`: This package is used to connect
    to SQL Server.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Tools`: This package is used to enable the necessary
    EF Core tools.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Authentication.JwtBearer`: This package is used to enable
    JWT authentication.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ASP.NET Core Identity package already comes with the default project template,
    so we do not need to install it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will add the database context. We will use EF Core to access the database.
    But first, we need an entity model to represent the user. Create a new folder
    named `Authentication` and add a new class named `AppUser` to it. The `AppUser`
    class inherits from the `IdentityUser` class, which is provided by ASP.NET Core
    Identity, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `IdentityUser` class already contains the properties that we need to represent
    a user for most of the scenarios, such as `UserName`, `Email`, `PasswordHash`,
    `PhoneNumber`, and others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to create a database context to access the database. Add a new
    class named `AppDbContext` to the `Authentication` folder. The `AppDbContext`
    class inherits from the `IdentityDbContext` class, which is provided by ASP.NET
    Core Identity, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we can see, this `AppDbContext` is purely for ASP.NET Core Identity. If you
    have other entities in your application, you can create a separate `DbContext`
    for them if you want to. You can use the same connection string for both `DbContexts`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will need to create a few models for registering and logging in users
    because, when we register a user, we need to send the username, password, and
    email address. When we log a user in, we need to send the username and password.
    It would be good if we had separate models for these different scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new class named `AddOrUpdateAppUserModel` in the `Authentication`
    folder. This class will be used to represent the user when we register a new user.
    The `AddOrUpdateAppUserModel` class should contain the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, create a new class named `LoginModel` in the `Authentication` folder,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you add additional properties to the `AppUser` class, you need to add the
    corresponding properties for the `AddOrUpdateAppUserModel` as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to configure the authentication service. First, let’s update
    the `appsettings.json` file to provide the configurations for JWT tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the configurations as per your requirements. Because we use the same
    web API to issue and validate the JWT token, we use the same URL for the `ValidAudiences`
    and `ValidIssuer` properties. The `Secret` property is used to sign the JWT token.
    You can use any string as the secret. In this case, we can use a GUID value. Also,
    please note that this is for demo purposes only. In a real-world application,
    you should store the secret in a secure location, such as Azure Key Vault.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the code in the `Program.cs` file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we configured the authentication service to use JWT tokens.
    The `AddIdentityCore()` method adds and configures the identity system for the
    specified `User` type. We also added `AppDbContext` and `AppUser` to the service
    collection and specified that we want to use EF Core to store the user data. The
    `AddDefaultTokenProviders()` method adds the default token providers for the application,
    which are used to generate tokens. The `Services.AddAuthentication()` method configures
    the authentication service to use JWT tokens. The `AddJwtBearer()` method configures
    the JWT bearer authentication handler, including the token validation parameters.
    We use some configurations from the `appsettings.json` file to configure the token
    validation parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we need to call the `UseAuthentication()` and `UseAuthorization()`
    methods to enable authentication and authorization in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, it’s time to create and update the database. We have already created the
    database context and the user entity. So, now, we need to create the database.
    To do that, just run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the commands are executed successfully, you should see the database created
    with the following tables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The database tables created by ASP.NET Core Identity](img/B18971_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The database tables created by ASP.NET Core Identity
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to check whether the database has been created is to add the following
    code to the `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can use either of the methods to check whether the database is created in
    the development environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The data for the users will be stored in these tables, which is convenient when
    using the default tables provided by ASP.NET Core Identity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s apply the `Authorize` attribute to enable authentication and authorization
    for `WeatherForecastController`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `WeatherForecastController` by adding an `[Authorize]` attribute, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This attribute will ensure that the user is authenticated before accessing
    the controller. If the user is not authenticated, the controller will return a
    `401 Unauthorized` response. Test this by running the application and calling
    the `/WeatherForecast` endpoint. You should see a `401` response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2 – When the user is not authenticated, the controller returns a
    401 response](img/B18971_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – When the user is not authenticated, the controller returns a 401
    response
  prefs: []
  type: TYPE_NORMAL
- en: The `Authorize` attribute can be applied to the controller or the action method.
    If the attribute is applied to the controller, all the action methods in the controller
    will be protected. If the attribute is applied to the action method, only that
    action method will be protected.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `AllowAnonymous` attribute to allow anonymous access to
    the controller or action method. Note that the `AllowAnonymous` attribute overrides
    the `Authorize` attribute. So, if you apply both attributes to the controller
    or action method, the `AllowAnonymous` attribute will take precedence, which means
    that the controller or action method will be accessible to all the users.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add `AccountController` to handle the authentication requests. For
    example, we need to provide a `/account/register` endpoint. When the user sends
    the username and password, the application will create a record of the user in
    the database and generate a JWT token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To generate a JWT token, we need to provide the following information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`appsettings.json` file as described in the previous steps.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, create a new controller named `AccountController` to handle the authentication
    requests. Create a new class named `AccountController` in the `Controllers` folder.
    The `AccountController` class should inherit from the `ControllerBase` class,
    as shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We use the `UserManager` class to manage the users. The `UserManager` class
    is provided by ASP.NET Core Identity. We also need to inject the `IConfiguration`
    interface to get the configuration values from the `appsettings.json` file.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new method named `Register()` in the `AccountController` class. This
    method will be used to register a new user. The `Register()` method should accept
    an `AddOrUpdateAppUserModel` object as a parameter, as shown in the following
    code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we are using the `JwtSecurityTokenHandler` class to generate
    the JWT token. The `JwtSecurityTokenHandler` class is provided by the `System.IdentityModel.Tokens.Jwt`
    NuGet package. First, we get the configuration values from the `appsettings.json`
    file. Then, we create a `SymmetricSecurityKey` object using the secret key. The
    `SymmetricSecurityKey` object is used to sign the token.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we created a `SecurityTokenDescriptor` object, which contains the following
    properties:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Subject`: The subject of the token. The subject can be any value, such as
    the username, email address, and so on.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expires`: The expiration date of the token.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Issuer`: The issuer of the token.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Audience`: The audience of the token.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SigningCredentials`: The credentials to sign the token. Note that we use the
    `HmacSha256Signature` algorithm to sign the token. It is a 256-bit HMAC cryptographic
    algorithm for digital signatures. If you encounter an error such as `IDX10603:
    The algorithm: ''HS256'' requires the SecurityKey.KeySize to be greater than ''128''
    bits.`, please check the secret key in the `appsettings.json` file. The secret
    key should be at least 16 characters long (16 * 8 = 128).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we used the `JwtSecurityTokenHandler` class to create and write the
    token to a string value.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can test the `Register()` method. Use `dotnet run` to run the application.
    You can use the Swagger UI or any other tools to test the API. Send a `POST` request
    with the following JSON data to the `http://localhost:5056/account/register` endpoint:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the response similar to the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Registering a new user](img/B18971_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Registering a new user
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the `Register()` method returns a JWT token. The token is valid
    for 1 day. We can use this token to authenticate the user in the future. If you
    check the database, you will see that a new user has been created in the `AspNetUsers`
    table, and the password is hashed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The new user has been created in the database](img/B18971_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – The new user has been created in the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the token value and send a `GET` request to the `/WeatherForecast` endpoint.
    You need to attach the `Bearer` token to the request header, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Sending a request with the Bearer token](img/B18971_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Sending a request with the Bearer token
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you attach the bearer token to the request, please note that there is a
    prefix of `Bearer` before the token value. So, the actual format should be
  prefs: []
  type: TYPE_NORMAL
- en: '`Authorization:` `Bearer <token>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, it works! Your API is now secured. The next step is to create a login method
    to authenticate the user. It is quite straightforward. Create a new method named
    `Login` in the `AccountController` class. The `Login()` method should accept an
    `AddOrUpdateAppUserModel` object as a parameter, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We use the `UserManager` class to find the user by the username. If the user
    is found, we use the `CheckPasswordAsync()` method to check the password. If the
    password is correct, we generate a new token and return it to the client. If the
    user is not found or the password is incorrect, we return an error message to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created a web API project with basic authentication and authorization.
    We also created a controller to handle account-related operations. Note that in
    this example, we have not implemented any specific authorization rules. All authenticated
    users can access the `WeatherForecast` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss the details of the JWT token.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the JWT token structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JWT token is a string value. It is composed of three parts, separated by
    a dot (`.`):'
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The header and payload are encoded using the `Base64Url` algorithm. We can
    use `jwt.io` to decode the token. Copy the token in the response body and paste
    it into the `Encoded` field on the `jwt.io` website. You will see the decoded
    token, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Decoding the JWT token](img/B18971_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Decoding the JWT token
  prefs: []
  type: TYPE_NORMAL
- en: 'The header contains the algorithm used to sign the token. In our case, we use
    the `HmacSha256Signature` algorithm. So, the decoded header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The payload contains the claims of the token and some other additional data.
    In our case, the decoded payload is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some recommended (but not mandatory) registered claim names defined
    in RFC7519:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sub`: The `sub` (subject) claim identifies the principal that is the subject
    of the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nbf`: The `nbf` (not before) claim identifies the time before which the token
    *must not* be accepted for processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp`: The `exp` (expiration time) claim identifies the expiration time on
    or after which the token *must not* be accepted for processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iat`: The `iat` (issued at) claim identifies the time at which the token was
    issued'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iss`: The `iss` (issuer) claim identifies the principal that issued the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aud`: The `aud` (audience) claim identifies the recipients that the token
    is intended for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in our case, we use the same value for the `iss` and `aud` claims
    because we use the same web API to issue and validate the token. In a real-world
    application, normally, there is a separate authentication server to issue the
    token so that the `iss` and `aud` claims have different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature is used to verify the token to make sure the token does not tamper.
    There are various algorithms to generate the signature. In our case, we use the
    `HmacSha256Signature` algorithm, so the signature is generated using the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HMACSHA256(base64UrlEncode(header) + "." +` `base64UrlEncode(payload), secret)`'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the token typically looks like `xxxxx.yyyyy.zzzzz`, which can be
    easily passed in the HTTP request header, or stored in the local storage of the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we have a secured API. You can find a sample client application
    named `AuthenticationDemoClient` in the `samples\chapter8\AuthenticationDemo\BasicAuthenticationDemo\end`
    folder. The client application is a simple console application. It uses the `HttpClient`
    class to send HTTP requests to the API. The main code is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Get weather forecast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, the client application sends a request to the login API to get the token.
    Then, it attaches the token to the request header and sends the request to the
    weather forecast API. If the token is valid, the API will return the data.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Swagger UI to support authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You probably prefer to use the Swagger UI to test the APIs. The default configuration
    of the Swagger UI does not support authorization. We need to update the `AddSwaggerGen()`
    method in the `Program` class to support authorization. Update the `Program` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds the `Bearer` security definition to the Swagger UI.
    The `AddSecurityRequirement` method adds the `Authorization` header to the Swagger
    UI. Now, when you run the application, you will see the **Authorize** button in
    the Swagger UI. Click the **Authorize** button; you will see a pop-up window that
    allows you to enter the token, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Entering the token in the Swagger UI](img/B18971_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Entering the token in the Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the token in the **Value** field. Then, click the **Authorize** button.
    Now, you can test the APIs using the Swagger UI directly:'
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: You need to add the `Bearer` prefix to the token with a space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – The Swagger UI is authorized](img/B18971_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – The Swagger UI is authorized
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about the configuration for the Swagger UI here:
    [https://github.com/domaindrivendev/Swashbuckle.AspNetCore](https://github.com/domaindrivendev/Swashbuckle.AspNetCore).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the implementation of a web API project that supports
    authentication and authorization, including the creation of a controller to handle
    the login request. Additionally, we explored how to generate a JWT token and validate
    it, as well as how to use a console application to access the project resource
    and how to configure the Swagger UI to test the APIs with authorization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn more about authorization in ASP.NET Core.
    We will explore a couple of authorization types, including role-based authorization,
    claim-based authorization, and policy-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Delving deeper into authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization is the process of determining whether a user is allowed to perform
    a specific action. In the previous section, we implemented a web API project that
    enables simple authentication and authorization. By using the `Authorize` attribute,
    only authenticated users can access the API. However, in many scenarios, we need
    to implement granular authorization. For example, some resources are only accessible
    to the administrator, while some resources are accessible to normal users. In
    this section, we will explore how to implement granular authorization in ASP.NET
    Core, including role-based authorization, claim-based authorization, and policy-based
    authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can find the starter app and the completed app in this book’s GitHub repository
    at `chapter8/AuthorizationDemo/RoleBasedAuthorizationDemo`. The starter app is
    similar to the application we created in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with the starter app. Don’t forget to create the database and run
    the migrations using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static class AppRoles{    public const string Administrator = "Administrator";    public
    const string User = "User";    public const string VipUser = "VipUser";}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Program` class, we need to explicitly call the `AddRoles()` method
    after the `AddIdentityCore()` method. The updated code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you use the `AddIdentity()` method, you do not need to call the `AddRoles()`
    method. The `AddIdentity()` method will call the `AddRoles()` method internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to check whether the roles exist in the database. If not, we will
    create the roles. Add the code, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `dotnet run` to run the application. You will see that the roles are created
    in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Roles in the database](img/B18971_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Roles in the database
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AccountController` class, we have a `Register()` method that is used
    to register a new user. Let’s update the `Register()` method to assign the `User`
    role to the new user. The updated code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we can create a new action to register an administrator or a VIP
    user. You can check the code in the completed app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can register a new administrator using any HTTP client you like. After
    the users are created, you can view the users and their roles in the database,
    as shown in *Figure 8**.10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Users and their roles in the database](img/B18971_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Users and their roles in the database
  prefs: []
  type: TYPE_NORMAL
- en: The data of the `AspNetUserRoles` table is used to store the relationship between
    users and roles. The `UserId` column is the primary key of the `AspNetUsers` table,
    while the `RoleId` column is the primary key of the `AspNetRoles` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the method that is used to generate the JWT token.
    When we generate the token, we need to include the roles of the user in the token.
    We can use the `GetRolesAsync()` method to get the roles and then add them to
    the claims. The updated code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Try to run the application and register a new user or log in with an existing
    user. Copy the token in the response and paste it to the `jwt.io` website to decode
    the payload. You will see that the roles are included in the token, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s update the `WeatherForecastController` class to implement role-based
    authorization. Add a new action for administrators, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Authorize` attribute is used to specify the role that is allowed to access
    the API. In the preceding code, only authenticated users with the `Administrator`
    role can access the API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can test the API. If you use the token of a normal user to access the
    `/WeatherForecast/admin` endpoint, you will get a 403 Forbidden response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Generally, the `administrator` role should have permission to access all resources.
    But in our current application, the administrator user cannot access the `/WeatherForecast`
    endpoint. There are multiple ways to fix this.
  prefs: []
  type: TYPE_NORMAL
- en: The first way is that when we register a new administrator, we can assign the
    `Administrator` role to the user and also assign the `User` role (or any other
    roles) to the user. This way, the administrator user can access all resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also update the `Authorize` attribute to allow multiple roles, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means that the user must have at least one of the specified
    roles to access the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you apply multiple `Authorize` attributes with specified roles
    to an action, the user must have all the roles to access the API. For example,
    consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code states that the user must have both the `User` and `VipUser`
    roles to access the API. If the user has only one of the roles, the user will
    get a 403 Forbidden response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this, we can also define a policy to specify the roles that are allowed
    to access the API. For example, in the `Program` class, we can add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can update the `Authorize` attribute to use the policy like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the `policy.RequireRole()` method has multiple roles in parameters, the user
    must have at least one of the roles to access the API. You can check the code
    in the completed app.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve implemented role-based authorization in ASP.NET Core. In the
    next section, we will learn how to implement claim-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Claim-based authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user is authenticated, the user will have a set of claims that are used
    to store the information about the user. For example, the user can have a claim
    that specifies the user’s role. So, technically, roles are also claims, but they
    are special claims that are used to store the roles of the user. We can store
    other information in the claims, such as the user’s name, email address, date
    of birth, driving license number, and more. Once we’ve done this, the authorization
    system can check the claims to determine whether the user is allowed to access
    the resource. Claim-based authorization provides more granular access control
    than role-based authorization, but it can be more complex to implement and manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the starter app and the completed app in the `chapter8/AuthorizationDemo/ClaimBasedAuthorizationDemo`
    folder in this book’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with the starter app. Don’t forget to create the database and run
    the migrations using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: public static class AppClaimTypes{    public const string DrivingLicenseNumber
    = "DrivingLicenseNumber";    public const string AccessNumber = "AccessNumber";}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, create a new `AppAuthorizationPolicies` class to define the authorization
    policies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can add the claims to the token when the user logs in. Update the
    `GenerateToken` method in the `AccountController` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can add any claims to the token. In the preceding code, we added the `Country`,
    `AccessNumber`, and `DrivingLicenseNumber` claims to the token.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Imagine that we have a requirement that only users who have their driving licenses
    can access the resource. We can implement this by adding the following code to
    the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, the difference between role-based authorization and claim-based authorization
    is that claim-based authorization uses `policy.RequireClaim()` to check the claims,
    while role-based authorization uses `policy.RequireRole()` to check the roles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can update the `Authorize` attribute so that it uses the
    policy, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application and test the `/WeatherForecast/driving-license` endpoint.
    You will get a `401` Unauthorized response because the user does not have the
    `DrivingLicenseNumber` claim. Register a user or log in to get the token. Then,
    add the token to the `Authorization` header and call the `/WeatherForecast/driving-license`
    endpoint again. You will get a 200 OK response with `drivingLicenseNumber` in
    the response body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The token now contains the claims, as shown in the following JSON response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the simplest way to implement claim-based authorization. The current
    approach only checks whether the token contains the claim; it does not check the
    value of the claim. We can check the values as well. The `RequireClaim()` method
    also has an overload that accepts `allowedValues` as a parameter. For example,
    we have a resource that can only be accessed by users based in New Zealand. We
    can update the `Program` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The action in the controller looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can test the API by calling the `/WeatherForecast/country` endpoint. Now,
    only users who have the `Country` claim with the value of `New Zealand` can access
    the resource.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similar to roles, we can apply multiple policies to a resource. For example,
    we can require the user to have both the `DrivingLicense` and `AccessNumber` claims
    to access the resource. Just like roles, you can add two policies to the `Authorize`
    attribute, which means that the user must have both the `DrivingLicense` and `AccessNumber`
    claims to access the resource. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to use the `RequireAssertion()` method, which allows us to execute
    a custom logic to check the claims. Update the `Program` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `context` parameter contains the `User` property
    that contains the claims. We can use the `HasClaim()` method to check whether
    the user has the claim. Then, we can return `true` if the user has both the `DrivingLicenseNumber`
    and `AccessNumber` claims; otherwise, we return `false`. You can also use the
    `context.User.Claims` property to get the claims and check the values per your
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The action in the controller looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to implement claim-based authorization in ASP.NET
    Core. We also learned how to use the `RequireAssertion()` method to check the
    claims. If we need a more complex authorization logic, we can use policy-based
    authorization. But first, let’s learn how authorization works in ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the authorization process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we learned how to implement role-based authorization
    and claim-based authorization. Let’s delve deeper into the details. You may have
    noticed that when we use role-based authorization or claim-based authorization,
    we need to call the `AddPolicy()` method in the `AddAuthorization` method. The
    signature of the `AddPolicy()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddPolicy()` method accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `name` parameter, which is the name of the policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `configurePolicy` parameter, which is a delegate that accepts an `AuthorizationPolicyBuilder`
    parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can press *F12* to check the source code of the `AuthorizationPolicyBuilder`
    class. You will find that it has some methods to configure the policy, such as
    `RequireRole()`, `RequireClaim()`, and others. The source code of the `RequireRole`
    method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code of the `RequireClaim()` method is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Both the `RequireRole()` and `RequireClaim()` methods call the `Requirements.Add()`
    method under the hood. So, what is the `Requirements` object?
  prefs: []
  type: TYPE_NORMAL
- en: 'We are getting closer to the core of authorization in ASP.NET Core. The definition
    of the `Requirements` object is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Requirements` object in the `AuthorizationPolicyBuilder` class is a list
    of `IAuthorizationRequirement` objects. The `IAuthorizationRequirement` interface
    is just a marker service, and it does not have any methods. Let’s press *F12*
    on the `RolesAuthorizationRequirement` class and the `ClaimsAuthorizationRequirement`
    class. We will see their source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, both the `RolesAuthorizationRequirement` and `ClaimsAuthorizationRequirement`
    classes implement the `IAuthorizationRequirement` interface. They also implement
    the `AuthorizationHandler<TRequirement>` class, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So, each implementation of the `AuthorizationHandler<TRequirement>` class implements
    the `HandleRequirementAsync()` method to check the requirements. For example,
    the `RolesAuthorizationRequirement` class consists of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When a `RolesAuthorizationRequirement` instance is instantiated, it accepts
    a collection of roles from the constructor. Then, it uses the `HandleRequirementAsync()`
    method to check whether the user is in the role. If the user is in the role, it
    calls the `context.Succeed()` method to set the `Succeeded` property to `true`.
    Otherwise, it sets the `Succeeded` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If you check the implementation of the `ClaimsAuthorizationRequirement` class,
    you will find it is similar to the `RolesAuthorizationRequirement` class. It accepts
    `claimType` and a set of `allowValues` and checks whether the user has the claim,
    and whether the claim value is in the `allowValues` set.
  prefs: []
  type: TYPE_NORMAL
- en: The next question is – who is responsible for calling these methods?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the `Program` class to understand the middleware pipeline.
    We have the `app.UseAuthorization()` method in the `Program` file, which is used
    to add the authorization middleware. Press *F12* on the `UseAuthorization` method.
    We’ll be able to view its source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue to press *F12* to check the source code of `AuthorizationMiddleware`.
    You will see the following code in the `Invoke()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are closer. The `AuthorizationMiddleware` class gets the policies from
    the endpoint metadata and then calls the `IPolicyEvaluator.AuthenticateAsync()`
    method to check whether the user is authenticated, after which it calls the `IPolicyEvaluator.AuthorizeAsync()`
    method to check whether the user is authorized. The `IPolicyEvaluator` interface
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The default implementation of `IPolicyEvaluator` has been injected into the
    DI container by the ASP.NET Core framework. You can find the source code of the
    `PolicyEvaluator` class here: `https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/PolicyEvaluator.cs`.
    You will see it has an `IAuthorizationService` object injected into it, which
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With that, we’ve found the `IAuthorizationRequirement` class we described earlier!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the source code of the default implementation of `IAuthorizationService`
    here: [https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs](https://source.dot.net/#Microsoft.AspNetCore.Authorization/DefaultAuthorizationService.cs).
    It is also injected into the DI container by the framework. The core code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we end up with the following call stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the authorization policy (requirement) in the `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the authorization policy to the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the authorization middleware to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request comes in with the `Authorization` header, which can be retrieved
    from the `HttpContext` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AuthorizationMiddleware` calls the `IPolicyEvaluator.AuthorizeAsync()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `IPolicyEvaluator.AuthorizeAsync()` method calls the `IAuthorizationService.AuthorizeAsync()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `IAuthorizationService.AuthorizeAsync()` method calls the `IAuthorizationHandler.HandleAsync()`
    method to check whether the user is authorized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we understand the call stack, we can easily implement an authorization
    policy by implementing the `IAuthorizationRequirement`, `IAuthorizationHandler`,
    and `IAuthorizationService` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Policy-based authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we explained that both role-based authorization and
    claim-based authorization are implemented by the `IAuthorizationRequirement`,
    `IAuthorizationHandler`, and `IAuthorizationService` interfaces under the hood.
    If we have more complex authorization logic, we can use policy-based authorization
    directly, which allows us to define custom authorization policies to execute complex
    authorization logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have a scenario where we need to support the following authorization
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: The special premium content can be accessed by the user who has a `Premium`
    subscription and is also based in New Zealand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users who have a `Premium` subscription, but are not based in New Zealand, cannot
    access the special premium content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There may be other complex authorization logic in the real world. Let’s implement
    the aforementioned authorization logic using policy-based authorization. You can
    find the sample code in the `/``samples/chapter8/AuthorizationDemo/PolicyBasedAuthorization`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add two classes to the `Authentication` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These classes define the claim types and authorization policies we need. You
    can also use strings directly in the code, but it is recommended to use constants
    to avoid typos.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `AccountController` class, update the `GenerateToken()` method with
    a new claim, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a new claim, `AppClaimTypes.Subscription`, with a value of `Premium`
    to the token. This claim represents the user’s subscription type. We also added
    a new claim, `ClaimTypes.Country`, to the token. This claim represents the user’s
    country. In the real world, you can get the user’s subscription type and country
    from the database. Let’s assume we have the subscription type and country information
    in the token for simplicity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the `Login()` method in the `AccountController` class to add the
    country to the claims and create another method for New Zealand users, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, this is a simplified implementation for demonstration purposes. In the
    real world, generally, there is only one login endpoint, and the country information
    is retrieved from the database or other sources, such as IP addresses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to implement the authorization policy. Create a new class named
    `SpecialPremiumContentRequirement` in the `Authorization` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class implements the `IAuthorizationRequirement` interface. The `Country`
    property represents the country where the premium content can be accessed. We
    can use this property to check whether the user is authorized to access the premium
    content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to implement the `AuthorizationHandler` interface. Create a `SpecialPremiumContentAuthorizationHandler`
    class in the `Authorization` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This handler is used to check whether the requirement is satisfied. If the user
    has a `Premium` subscription and is based in the country where the premium content
    can be accessed, the requirement is satisfied. Otherwise, the requirement is not
    satisfied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to register the authorization policy and the authorization handler.
    Update the `Program` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we registered the authorization policy, `AppAuthorizationPolicies.SpecialPremiumContent`,
    with the `SpecialPremiumContentRequirement` requirement. The `SpecialPremiumContentRequirement`
    requirement is satisfied if the user has a `Premium` subscription and is based
    in New Zealand. We also registered the `SpecialPremiumContentAuthorizationHandler`
    handler as a singleton service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to apply the authorization policy to the controller. Open
    the `WeatherForecastController` class and add a new action, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This action can only be accessed by users who have a `Premium` subscription
    and are based in New Zealand. If the user does not have a `Premium` subscription
    or is not based in New Zealand, the authorization policy will not be satisfied,
    and the user will not be able to access the action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can test the application as we did in the previous section. The application
    has two login endpoints – one for New Zealand users and one for Australian users.
    If you log in as a New Zealand user, you can access the `WeatherForecast/special-premium`
    endpoint. Otherwise, you will get a `403` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some points to note for policy-based authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use one `AuthorizationHandler` instance to handle multiple requirements.
    in the `HandleAsync()` method, you can use `AuthorizationHandlerContext.PendingRequirements`
    to get all the pending requirements and then check them one by one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have multiple `AuthorizationHandler` instances, they will be invoked
    in any order, which means you cannot expect the order of the handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to call `context.Succeed(requirement)` to mark the requirement as satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if the requirement is not satisfied? There are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, you do not need to call `context.Fail()` to mark the failed requirement
    because there may be other handlers to handle the same requirement, which may
    be satisfied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to make sure the requirement fails and indicate that the whole
    authorization process fails, you can call `context.Fail()` explicitly, and set
    the `InvokeHandlersAfterFailure` property to `false` in the `AddAuthorization()`
    method, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this section, we explored the three types of authorization available in
    ASP.NET Core: role-based, claim-based, and policy-based. We examined the source
    code to gain a deeper understanding of how authorization works. With this knowledge,
    you should now be able to confidently use the authorization features of ASP.NET
    Core. Next, we will learn how to manage users and roles.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing users and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we implemented the authentication and authorization
    features. Generally, the application should also provide a way to manage users
    and roles. ASP.NET Core Identity provides a set of APIs to manage users and roles.
    In this section, we will introduce how to use these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we learned that the `IdentityDbContext` class is used to store the
    user and role information. So, we do not need to create a new database context
    class. Similarly, we can use `UserManager` and `RoleManager` to manage users and
    roles without having to write any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common operations for managing users by using the `UserManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateAsync(TUser user,` `string password)` | Creates a user with the given
    password. |'
  prefs: []
  type: TYPE_TB
- en: '| `UpdateUserAsync(TUser user)` | Updates a user. |'
  prefs: []
  type: TYPE_TB
- en: '| `FindByNameAsync(string userName)` | Finds a user by name. |'
  prefs: []
  type: TYPE_TB
- en: '| `FindByIdAsync(string userId)` | Finds a user by ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `FindByEmailAsync(string email)` | Finds a user by email. |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteAsync(TUser user)` | Deletes a user. |'
  prefs: []
  type: TYPE_TB
- en: '| `AddToRoleAsync(TUser user,` `string role)` | Adds the user to a role. |'
  prefs: []
  type: TYPE_TB
- en: '| `GetRolesAsync(TUser user)` | Gets a list of roles for the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `IsInRoleAsync(TUser user,` `string role)` | Checks whether the user has
    a role. |'
  prefs: []
  type: TYPE_TB
- en: '| `RemoveFromRoleAsync(TUser user,` `string role)` | Removes the user from
    a role. |'
  prefs: []
  type: TYPE_TB
- en: '| `CheckPasswordAsync(TUser user,` `string password)` | Checks whether the
    password is correct for the user. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChangePasswordAsync(TUser user, string currentPassword,` `string newPassword)`
    | Changes the user’s password. The user must provide the correct current password.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GeneratePasswordResetTokenAsync(TUser user)` | Generates a token for resetting
    the user’s password. You need to specify `options.Token.PasswordResetTokenProvider`
    in the `AddIdentityCore()` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `GenerateEmailConfirmationTokenAsync(TUser user)` | Generates a token for
    confirming the user’s email. You need to specify `options.Tokens.EmailConfirmationTokenProvider`
    in the `AddIdentityCore()` method. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConfirmEmailAsync(TUser user,` `string token)` | Checks whether the user
    has a valid email confirmation token. If the token matches, this method will set
    the `EmailConfirmed` property of the user to `true`. |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – Common operations for managing users
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common operations for managing roles by using the `RoleManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateAsync(TRole role)` | Creates a role |'
  prefs: []
  type: TYPE_TB
- en: '| `RoleExistsAsync(string roleName)` | Checks whether the role exists |'
  prefs: []
  type: TYPE_TB
- en: '| `UpdateAsync(TRole role)` | Updates a role |'
  prefs: []
  type: TYPE_TB
- en: '| `DeleteAsync(TRole role)` | Deletes a role |'
  prefs: []
  type: TYPE_TB
- en: '| `FindByNameAsync(string roleName)` | Finds a role by name |'
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Common operations for managing roles
  prefs: []
  type: TYPE_NORMAL
- en: These APIs encapsulate the database operations, so we can use them to manage
    users and roles easily. Some of the methods return a `Task<IdentityResult>` object.
    The `IdentityResult` object contains a `Succeeded` property to indicate whether
    the operation is successful. If the operation is not successful, you can get the
    error messages by using the `Errors` property.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover all the APIs in this book. You can find more information in
    the ASP.NET Core documentation. Next, we will learn about the new built-in Identity
    API endpoints in ASP.NET Core 8.0.
  prefs: []
  type: TYPE_NORMAL
- en: New Identity API endpoints in ASP.NET Core 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to implement authentication and authorization
    using the built-in Identity APIs in ASP.NET Core. We developed a couple of endpoints
    to register, log in, and manage users and roles. ASP.NET Core 8.0 introduces a
    new set of features to simplify authentication for web APIs. In this section,
    we will introduce these new endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this new feature is only for simple authentication scenarios. The
    token generated by the Identity API endpoints is opaque, not a JWT token, which
    means it is intended to be used by the same application only. However, it is still
    a choice for a quick start. In ASP.NET Core 8.0, we can use a new `MapIdentityApi()`
    method to map the Identity API endpoints without writing any implementation as
    we did in the previous sections. Let’s learn how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, follow *steps 1* to *5* in the *Creating a sample project with authentication
    and authorization* section to create a new web API project named `NewIdentityApiDemo`.
    Note that you do not need to install the `Microsoft.AspNetCore.Authentication.JwtBearer`
    package because we will not use JWT tokens in this sample project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the authorization policy service and register `DbContext` in the `Program.cs`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to create the database and the migration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the Identity API endpoints in the `Program.cs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AddIdentityApiEndpoints()` method adds a set of common identity services
    to the application by calling the `AddIdentityCore<TUser>()` method under the
    hood. It also configures authentication to support identity bearer tokens and
    cookies, so we do not need to explicitly call the `AddIdentityCore<AppUser>()`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map the Identity API endpoints in the `Program.cs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code maps the Identity API endpoints to the `/identity` path.
    You can change it to any path you like, such as `api/accounts`, `/users`, and
    so on. Note that as we use an `AppUser` instead of the default `IdentityUser`,
    we must specify the `AppUser` type in the `MapIdentityApi()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apply the `[Authorize]` attribute to the `WeatherForecastController` class,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using `dotnet run`. You will see the new Identity API endpoints
    in the Swagger UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Identity API endpoints in the Swagger UI](img/B18971_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Identity API endpoints in the Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can explore the new Identity API endpoints. Send a `POST` request
    with the following body to the `/identity/register` endpoint to register a new
    user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get a response that contains the access token and refresh token:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, you can use the access token to request the protected `/weatherforecast`
    endpoint with the `Authorization` header, as we introduced in the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: This new feature also provides endpoints such as `refreshToken`, `confirmEmail`,
    `resetPassword`, `2fa`, and others. Feel free to explore them on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding OAuth 2.0 and OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we learned how to implement authentication and authorization using
    built-in Identity APIs in ASP.NET Core. However, you may encounter some terms
    such as OAuth 2.0 and OpenID Connect when you work on a real project. It would
    be helpful to understand what they are and how to use them in ASP.NET Core. It
    is worth authoring a full book on OAuth 2.0 and OpenID Connect. In this section,
    we will introduce some basic concepts surrounding OAuth 2.0 and OpenID Connect,
    as well as some third-party authentication and authorization providers.
  prefs: []
  type: TYPE_NORMAL
- en: What is OAuth 2.0?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with a real example. When you use LinkedIn, you may see a window
    that prompts you to sync your contacts from Outlook, Gmail, Yahoo, or other email
    services. This is because LinkedIn would like to know your contacts so that it
    can recommend you to invite your friends to join LinkedIn or to connect with them.
    This is a typical example where OAuth 2.0 is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Syncing contacts on LinkedIn](img/B18971_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Syncing contacts on LinkedIn
  prefs: []
  type: TYPE_NORMAL
- en: 'If you fill in your email address and click the **Continue** button, you will
    be redirected to the email service provider’s website. For example, I use Outlook,
    so I will see a window like this because I have multiple accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Prompting to log into Outlook](img/B18971_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Prompting to log into Outlook
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the URL in the address bar. It will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The URL contains the **client ID** of the application, which is used to identify
    the application. It also contains the **redirect URL** so that the authorization
    server can redirect the user back to the application after the user grants permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to log into the email service provider’s website and authorize LinkedIn
    to access your contacts. If you have already logged in, you will see this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Authorizing LinkedIn to access your contacts](img/B18971_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Authorizing LinkedIn to access your contacts
  prefs: []
  type: TYPE_NORMAL
- en: After you authorize LinkedIn, you will be redirected back to LinkedIn. LinkedIn
    will get the contacts from the email service provider and show them to you.
  prefs: []
  type: TYPE_NORMAL
- en: We do not want to allow LinkedIn to know the password of our email address.
    In this case, OAuth 2.0 and OpenID Connect are used to authorize LinkedIn to access
    our contacts without knowing our password.
  prefs: []
  type: TYPE_NORMAL
- en: 'OAuth 2.0 implements a **delegated authorization** model. It allows a client
    to access a protected resource on behalf of a user. There are some entities involved
    in the OAuth 2.0 model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource owner**: The user who owns the protected resource. In our example,
    the resource owner is the user who owns the email address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: The client application that wants to access the protected resource.
    In our example, the client is LinkedIn. Note that this client is not the user’s
    browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource server**: The server that hosts the protected resource. In our example,
    the resource server is the email service provider – for example, Outlook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization server**: The server that handles the delegated authorization.
    In our example, the authorization server is Microsoft Identity Platform. An **Authorization**
    server has at least two endpoints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **authorization endpoint** is used to interact with the end user and obtain
    an authorization grant
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **token endpoint** is used with the client to exchange an authorization
    grant for an access token:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – OAuth 2.0 flow](img/B18971_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – OAuth 2.0 flow
  prefs: []
  type: TYPE_NORMAL
- en: Note that the client (LinkedIn) must register itself as a known client to the
    authorization server (Microsoft) before it can access the protected resource.
    The client must provide a **client ID** and a **client secret** to the authorization
    server to prove its identity. That is why we can see LinkedIn’s Microsoft Graph
    Connector in *Figure 8**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common steps of OAuth 2.0 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The client requests access to a protected resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client redirects the user to the authorization server, such as Microsoft,
    Google, and so on. Specifically, it redirects to the authorization endpoint of
    the authorization server. After the user is authenticated, the authorization server
    will prompt the user, asking something like “Hi, I have a **known** client named
    LinkedIn, which wants to access my APIs using your privileges. Specifically, it
    wants to access your contacts so that it can send emails on your behalf. Do you
    want to grant access to LinkedIn?” This is what *Figure* *8**.14* shows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the user accepts the request, the authorization server will generate an
    **authorization code**, which is just an opaque string that confirms the user
    did grant access to the client (LinkedIn). The authorization server will redirect
    the user back to the client (LinkedIn).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization code is sent to the client (LinkedIn) as a query string parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client (LinkedIn) now has an authorization code. Next, it will use the authorization
    code, client ID, and client secret to request an **access token** from the token
    endpoint of the authorization server. It may ask something like “Hi, I am LinkedIn.
    This user has granted me access to the contacts of this email address. This is
    my client credentials (client id and client secret). I also have an authorization
    code. Can I get access to this?”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server will verify the client credentials and the authorization
    code. If all is good, it will generate an access token and send it back to the
    client (LinkedIn). The access token is a string that can be used to access the
    protected resource. It is usually a JWT token. It may also contain the **scope**,
    which is the permission that the client (LinkedIn) has been granted. For example,
    it may be **Contacts.Read**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client (LinkedIn) can now use this access token to access the protected
    resource. It may ask something like “Hi, I am LinkedIn. I have an access token.
    Can I access the contacts of this email address?” The resource server checks the
    access token and if it is valid, it will return the protected resource to the
    client (LinkedIn).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this way, the client can access the protected resource without knowing the
    user’s password. Because the access token has a scope, it can only access the
    protected resource within the scope. For example, if the scope is `Contacts.Read`,
    the client can only read the contacts, but it cannot modify the contacts. This
    mechanism provides a good balance between security and usability.
  prefs: []
  type: TYPE_NORMAL
- en: What is OpenID Connect?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth was initially designed and released in 2006 and later revised and standardized
    in 2012 as OAuth 2.0\. OAuth 2.0 solves the problem of delegated authorization.
    However, there are some other scenarios that OAuth 2.0 cannot solve. For example,
    your API may need to know the identity of the user who is accessing the API, but
    users may not want to create an account for your API. They may already have an
    account in some other services, such as Microsoft, Google, and others. In this
    case, it would be more convenient if the user could use their existing account
    to access your API. However, OAuth 2.0 was not designed to implement sign-in with
    an existing account. This is where a new specification named OpenID Connect comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect is an authentication layer on top of OAuth 2.0 that was designed
    by the OpenID Foundation in 2014\. OpenID Connect is like an extension of OAuth
    2.0 that adds and defines some new features to retrieve the identity of the user,
    including profile information such as the user’s name, email address, and so on.
    OpenID Connect uses similar terminology and concepts as OAuth 2.0, such as **client**,
    **resource owner**, **authorization server**, and others. However, keep in mind
    that OpenID Connect is not a replacement for OAuth 2.0\. Instead, it is a specification
    that extends OAuth 2.0 to support authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many popular identity providers, such as Microsoft, Google, Facebook, and others,
    have implemented OpenID Connect so that you can integrate your API application
    with their identity provider. Then, users can use their existing account to sign
    into your API application. Here is an example of how OpenID Connect works on [Medium.com](http://Medium.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Medium.com sign-in with multiple identity providers](img/B18971_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Medium.com sign-in with multiple identity providers
  prefs: []
  type: TYPE_NORMAL
- en: If you click **Sign in with Google**, you will be redirected to Google to sign
    in. Then, you will be redirected back to Medium.com so that you can use your existing
    Google account to sign in to Medium.com. This is what OpenID Connect does.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to OAuth 2.0, OpenID Connect also generates an access token. It also
    introduces a new token called **ID token**, which is a JWT token that contains
    the identity of the user. The client application can inspect and validate the
    ID token to extract identity information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with other identity providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many identity providers support OpenID Connect so that you can integrate your
    API application with these platforms. Here are some popular identity providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft**: Microsoft provides Microsoft Identity Platform for authentication
    and authorization. For more information, see [https://learn.microsoft.com/zh-cn/azure/active-directory/develop/](https://learn.microsoft.com/zh-cn/azure/active-directory/develop/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google**: Sign in with Google is a service that helps you quickly and easily
    manage user authentication and share the user’s profile information with your
    application. For more information, see [https://developers.google.com/identity/gsi/web/guides/overview](https://developers.google.com/identity/gsi/web/guides/overview).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facebook**: Facebook Login is a convenient way for people to log into your
    application using their Facebook account. For more information, see [https://developers.facebook.com/products/facebook-login/](https://developers.facebook.com/products/facebook-login/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth0**: Auth0 is a cloud-based identity management platform that provides
    authentication, authorization, and related security services for web, mobile,
    and legacy applications. For more information, see [https://auth0.com/docs/quickstart/backend](https://auth0.com/docs/quickstart/backend).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Okta**: Okta is also a cloud-based identity platform that allows organizations
    to manage and secure user authentication and authorization across multiple applications
    and services. For more information, see [https://www.okta.com/](https://www.okta.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In March 2021, Okta acquired Auth0\. However, the two companies will continue
    to operate separately. Generally, Auth0 targets smaller companies and is known
    for its developer-friendly features, but Okta is considered to be more focused
    on large enterprises and offers more advanced features such as network integration,
    single sign-on, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to build an identity provider yourself, there are also some open-source
    projects that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IdentityServer`: `IdentityServer` is one of the most flexible and standards-compliant
    OpenID Connect and OAuth 2.0 frameworks for ASP.NET Core. It is widely used by
    many companies to secure their applications and APIs. Note that `IdentityServer`
    is open-source, but it is not free now. The last free version is IdentityServer4,
    which was released in 2021, but it is no longer maintained. Duende Software now
    provides a commercial version of `IdentityServer`. For more information, see [https://duendesoftware.com/products/identityserver](https://duendesoftware.com/products/identityserver).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OpenIddict`: `OpenIddict` is an open-source OpenID Connect stack for ASP.NET
    Core. It provides a versatile solution to implement OpenID Connect client, server,
    token validation, and more. However, it is not a turnkey solution. You need to
    write some custom code to implement some business logic, such as an authorization
    controller, and more. For more information, see [https://github.com/openiddict/openiddict-core](https://github.com/openiddict/openiddict-core).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyCloak`: `KeyCloak` is an open-source identity and access management solution.
    It provides features such as single sign-on, user federation, strong authentication,
    user management, fine-grained authorization, and more. It is container-based,
    so it can easily be deployed in a containerized environment. For more information,
    see [https://www.keycloak.org/](https://www.keycloak.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not cover the details of how to integrate with these identity providers
    in this book. Please refer to the documentation instead.
  prefs: []
  type: TYPE_NORMAL
- en: Other security topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, security is a very broad topic.
    In this section, we will briefly introduce some other security topics.
  prefs: []
  type: TYPE_NORMAL
- en: Always use Hypertext Transfer Protocol Secure (HTTPS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTPS is a protocol that provides secure communication between a client and
    a server. It is a combination of the HTTP and **Secure Sockets Layer/Transport
    Layer Security** (**SSL/TLS**) protocols. HTTPS is used to encrypt communication
    between the client and the server, ensuring that sensitive data transmitted over
    the internet is secure and cannot be intercepted by unauthorized third parties.
    Google Chrome and other modern browsers will display a warning if you try to access
    a website that does not use HTTPS. Therefore, it is very important to use HTTPS
    for all your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The default ASP.NET Core web API template can use both HTTP and HTTPS. It is
    recommended to use HTTPS only. So, we need to configure the project to redirect
    all HTTP requests to HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to add the following code to the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This code applies the `UseHttpsRedirection` middleware to redirect HTTP requests
    to HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the application locally, ASP.NET Core will automatically generate
    a self-signed certificate and use it to encrypt communication. However, when you
    deploy the application to a production environment, you need to use a certificate
    issued by a trusted **certificate authority** (**CA**), such as DigiCert, Comodo,
    GeoTrust, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using a strong password policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default password policy we implemented in previous sections is not secure
    enough. Users can use any password, which might be a security risk. It is important
    to force users to use strong, unique passwords that are difficult for others to
    guess or crack. Generally, a good password should be a combination of uppercase
    and lowercase letters, numbers, and special characters. The length of the password
    should be at least 8 characters. We can define a password policy to enforce these
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify the password policy in the `Program` class. Add the following
    code after the `AddAuthentication()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is easy to understand. In this example, we require the password
    to contain at least one uppercase letter, one lowercase letter, one number, and
    one special character, and the length of the password should be at least 8 characters.
    We also require the user’s email to be unique. So, if a user tries to register
    with an email that is already in use, the registration will fail. Now, the user’s
    password should be hard to guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also enforce the password policy when the user fails to log in. For
    example, if the user fails to log in three times, the account will be locked for
    5 minutes. This can help prevent brute-force attacks. To enable this feature,
    add the following code after the `AddAuthentication()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This change works when we use `SignInManager.CheckPasswordSignInAsync()` method
    to sign in. In previous examples, we used `UserManager`. So, we need to update
    the `Login()` method in the `AuthenticationController` class. First, we need to
    inject `SignInManager` into the controller. Then, we must update the `AuthenticationController`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `SignInManager.CheckPasswordSignInAsync()` method
    to sign in, which has a parameter named `lockoutOnFailure` that specifies whether
    the account should be locked out when the user fails to log in. The default value
    is `false`, so we need to use `true` to enable the lockout feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you use `AddIdentityCore<AppUser>()` in `Program.cs`, as we mentioned
    in the previous section, `SignInManager` is not available by default. In this
    case, you need to explicitly add the `SignInManager` service to the `ConfigureServices()`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test the application. Run the application using `dotnet run` and create
    a new user using the `Register` API. You will find that if the password is too
    simple, you will get an error message. Here is a sample request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a `400` response with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If you attempt to log in with an incorrect password more than three times, you
    will be locked out of the system for 5 minutes. During this period, you will not
    be able to access the system, even if you enter the correct password. After those
    5 minutes have elapsed, you will be able to log in again.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing two-factor authentication (2FA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2FA is a security process that requires users to provide two different forms
    of authentication to verify their identity. Besides the common username and password,
    2FA adds an extra layer of security by requiring users to provide a second authentication
    factor, such as a code sent to their mobile phone or authenticator app, fingerprint,
    face recognition, and so on. This makes it harder for hackers to gain access to
    user accounts. Even if the hacker gets the user’s password, they still cannot
    get the second factor. 2FA is widely used in banking and financial services to
    protect users’ sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-factor authentication** (**MFA**) is a superset of 2FA. It requires
    users to provide more than two factors to verify their identity. There are two
    types of MFA:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MFA Time-based One-Time Password** (**TOTP**): MFA TOTP is a type of MFA
    that requires users to provide a code generated by an authenticator app (such
    as Google Authenticator or Microsoft Authenticator). The code is valid for a short
    period, usually 30 seconds. After the code expires, the user needs to generate
    a new code. This type of MFA is widely used in banking and financial services.
    If you use a bank app, you might have seen this type of MFA. It requires the server
    and authenticator app to have an accurate time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFA Fast Identity Online 2** (**FIDO2**): MFA FIDO2 is a type of MFA that
    requires users to authenticate using a hardware key, such as a USB key or a biometric
    device (such as a fingerprint scanner). It has become more popular in recent years.
    However, ASP.NET Core does not support FIDO2 directly yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MFA SMS**: MFA SMS is no longer recommended because there are many security
    issues with SMS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about MFA, please refer to [https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/mfa).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing rate-limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rate-limiting is a security mechanism that limits the number of requests a client
    can make to a server. It can prevent malicious clients from making too many requests,
    which can cause a **denial of service** (**DoS**) attack. ASP.NET Core provides
    a built-in rate-limiting middleware. We explained how to use it in [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170).
  prefs: []
  type: TYPE_NORMAL
- en: Using model validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Model validation is a security mechanism that prevents malicious users from
    sending invalid data to the server. We should always validate the data sent by
    the client. In other words, the client is not trusted. For example, we expect
    a property in the model to be an integer, but what if the client sends a string?
    The application should be able to handle this situation and reject the request
    directly before executing any business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a built-in model binding and model validation mechanism.
    Model binding is used to convert the data sent by the client to the corresponding
    model. The data sent by the client can be in different formats, such as JSON,
    XML, form fields, or query strings. Model validation is used to check whether
    the data sent by the client is valid. We used model validation in the previous
    sections. For example, here is the code we used to register a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ModelState.IsValid` property represents whether the model is valid. So,
    how does ASP.NET Core validate the model? Look at the `AddOrUpdateAppUserModel`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the validation attributes to specify the validation rules. For example,
    `Required` is a built-in attribute annotation that specifies that the property
    is required. Here are some of the most commonly used ones besides `Required`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreditCard`: This specifies that the property must be a valid credit card
    number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailAddress`: This specifies that the property must be a valid email address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Phone`: This specifies that the property must be a valid phone number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Range`: This specifies that the property must be within a specified range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegularExpression`: This specifies that the property must match a specified
    regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringLength`: This specifies that the property must be a string with a specified
    length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Url`: This specifies that the property must be a valid URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Compare`: This specifies that the property must be the same as another property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If these built-in attributes cannot meet your requirements, you can also create
    custom attributes. For example, you can create an `Adult` attribute to validate
    the age of the user based on the user’s birthday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the `Adult` attribute in the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manually validate the model in the controller. For example, you
    can check whether the user’s email is unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `AddModelError()` method to add a validation
    error to the model. The `ModelState.IsValid` property will return `false` if there
    is any validation error. In [*Chapter 16*](B18971_16.xhtml#_idTextAnchor671),
    we will discuss how to use the `ProblemDetails` class to return error information
    to the client and how to use `FluentValidation` to validate the model for more
    complex scenarios. You can refer to that chapter for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Using parameterized queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We explained how to use EF Core to execute SQL queries in previous chapters.
    Generally, if you use LINQ to query data, EF Core will generate parameterized
    queries for you. However, you need to take care of SQL injection attacks when
    you use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FromSqlRaw()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SqlQeuryRaw()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecuteSqlRaw()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These methods allow you to execute raw SQL queries without sanitizing the input.
    So, please make sure you sanitize the query statements before executing them.
  prefs: []
  type: TYPE_NORMAL
- en: Using data protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data protection is a security mechanism that prevents malicious users from accessing
    sensitive data. For example, if you store the user’s password in the database,
    you should encrypt it before storing it. Another example is the user’s credit
    card number, which should also be encrypted before it is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that if the database is compromised, the attacker can
    easily access the user’s sensitive data. In other words, the database is not trusted,
    just like the client. Data protection is another big topic, but it is beyond the
    scope of this book. ASP.NET Core provides a built-in data protection mechanism.
    If you would like to learn more about it, please refer to the official documentation:
    [https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction](https://learn.microsoft.com/en-us/aspnet/core/security/data-protection/introduction).'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping secrets safe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secrets are sensitive data that should not be exposed to the public. In our
    applications, we may have many secrets, such as the database connection string,
    the API keys, the client secrets, and so on. In the previous chapters, we often
    stored them in the `appsettings.json` file. However, we need to emphasize that
    this is not a good practice. These secrets should be stored in a safe place, such
    as Azure Key Vault, AWS Secrets Manager, or `kube-secrets`. Never upload them
    to the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce **continuous integration/continuous deployment** (**CI/CD**)
    and explain how to store secrets safely in [*Chapter 14*](B18971_14.xhtml#_idTextAnchor585).
  prefs: []
  type: TYPE_NORMAL
- en: Keeping the framework up to date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The .NET Core framework is an open-source project. It is constantly being updated.
    We should always keep the framework up to date, including the NuGet packages.
    Note the life cycle of the .NET Core framework. Use the latest version of the
    framework as much as possible. If you are using an older version, you should consider
    upgrading it. You can find the life cycle of the .NET Core framework here: [https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Open Web Application Security Project (OWASP) Top 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OWASP is a nonprofit organization that provides information about web application
    security. It publishes a list of the most common web application security risks,
    which is called the OWASP Top 10\. You can find the OWASP Top 10 here: [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/).
    You should check the list regularly to make sure your application is not vulnerable
    to any of the risks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, OWASP provides a free resource called *DotNet Security Cheat Sheet*,
    where you can find the best practices for securing .NET Core applications. You
    can find it here: [https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the security and identity features of ASP.NET
    Core. We mainly learned how to use its built-in authentication and authorization
    mechanisms. We learned how to use the Identity framework to manage users and roles,
    and also explained role-based authorization, claim-based authorization, and policy-based
    authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we introduced OAuth 2.0 and OpenID Connect, which are the most popular
    authentication and authorization standards. After that, we explained several security
    practices, such as using HTTPS, strong passwords, parameterized queries, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Again, security is a big topic, and we cannot cover all the details in one chapter.
    Please treat security as a continuous process, and always keep your application
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get starssseted with testing, which is an important
    part of any software project. We will learn how to write unit tests for ASP.NET
    Core applications.
  prefs: []
  type: TYPE_NORMAL
