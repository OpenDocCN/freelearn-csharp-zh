<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-145">
    <a id="_idTextAnchor146">
    </a>
    
     9
    
   </h1>
   <h1 id="_idParaDest-146">
    <a id="_idTextAnchor147">
    </a>
    
     Managing Application Settings
    
   </h1>
   <p>
    
     In the dynamic world of web applications, the ability to adapt to different environments and requirements is crucial.
    
    
     ASP.NET Core 9 provides a robust configuration system that allows developers to manage settings and behavior effectively.
    
    
     This chapter will explore the importance of application settings, how to manage them using the configuration system, and how to make your applications adaptable
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     In this chapter, we will focus on the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding
     
     <strong class="source-inline">
      
       IConfiguration
      
     </strong>
     
      concepts
     
     
      
       and abstractions
      
     
    </li>
    <li>
     
      Working with
     
     
      
       configuration providers
      
     
    </li>
    <li>
     
      Learning about the
     
     
      
       Options pattern
      
     
    </li>
    <li>
     
      Working with dynamic configurations
     
     
      
       and behaviors
      
     
    </li>
   </ul>
   <p>
    
     ASP.NET Core 9 provides a robust configuration system that allows developers to effectively manage configurations and behaviors.
    
    
     This chapter will explore the importance of application configurations, how to manage them using the configuration system, and how to make your applications adaptive
    
    
     
      at runtime.
     
    
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor148">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To support the learning of this chapter, the following tools must be present in your
    
    
     
      development environment:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Docker
      
     </strong>
     
      : The Docker engine must be installed on your operating system and have a SQL Server container running.
     
     
      You can find more details about Docker and SQL Server containers in
     
     <a href="B21788_05.xhtml#_idTextAnchor078">
      
       <em class="italic">
        
         Chapter 5
        
       </em>
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Postman
      
     </strong>
     
      : This tool will be used to execute requests to APIs of the
     
     
      
       developed application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Redis Insight
      
     </strong>
     
      : This tool is used to connect to a Redis server
     
     
      
       database (
      
     
     <a href="https://redis.io/insight/">
      
       
        https://redis.io/insight/
       
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     You will also need access to an
    
    
     
      Azure subscription.
     
    
   </p>
   <p>
    
     The code examples used in this chapter can be found in the book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter09
      
     
    </a>
   </p>
   <h1 id="_idParaDest-148">
    <a id="_idTextAnchor149">
    </a>
    
     Understanding IConfiguration concepts and abstractions
    
   </h1>
   <p>
    
     In the dynamic world of web applications, the ability to adapt to different environments and requirements is crucial, in addition to security requirements that have become increasingly essential in applications that run on different
    
    
     
      cloud providers.
     
    
   </p>
   <p>
    
     Most web applications have some type of configuration managed in files or classes, in order to centralize parameters that are used throughout the application flow.
    
    
     With each change in configurations or even application behaviors, a new version of the software must be generated.
    
    
     Furthermore, when working with remote teams, it is essential to maintain the correct management of configurations and sensitive data and not keep these parameters versioned in the application
    
    
     
      version control.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 provides powerful ways to manage application configurations in addition to enabling the use of other features, such as changing application behaviors without the need to generate new versions of
    
    
     
      the software.
     
    
   </p>
   <p>
    
     We will start learning about these resources via the fundamentals of configuration management through the
    
    
     <strong class="source-inline">
      
       IConfiguration
      
     </strong>
    
    
     
      interface.
     
    
   </p>
   <h2 id="_idParaDest-149">
    <a id="_idTextAnchor150">
    </a>
    
     IConfiguration interface
    
   </h2>
   <p>
    
     ASP.NET Core 9 has
    
    <a id="_idIndexMarker704">
    </a>
    
     the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, which aims to provide a mechanism for managing application settings and configurations in a unified manner, allowing access to diverse configuration sources such as JSON files, environment variables,
    
    
     
      and arguments.
     
    
   </p>
   <p>
    
     Among the main concepts regarding the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, we have
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Configuration sources
      
     </strong>
     
      : Support multiple
     
     <a id="_idIndexMarker705">
     </a>
     
      configuration sources, which can be combined and layered.
     
     
      Common sources include JSON files (such as
     
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
     
      ), environment variables, command-line arguments, and
     
     
      
       user secrets.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Hierarchical configuration
      
     </strong>
     
      : Configuration settings are organized in a hierarchical structure.
     
     
      This
     
     <a id="_idIndexMarker706">
     </a>
     
      means that settings can be nested into sections, making complex settings easier
     
     
      
       to manage.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Options pattern
      
     </strong>
     
      : The Options pattern
     
     <a id="_idIndexMarker707">
     </a>
     
      uses
     
     <strong class="source-inline">
      
       IConfiguration
      
     </strong>
     
      to bind configuration settings to strongly
     
     
      
       typed objects.
      
     
    </li>
   </ul>
   <p>
    
     In
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , we used the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file to manage the connection string with the SQL Server database and retrieved the value of this configuration through the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     class.
    
    
     This practice brings several benefits, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Flexibility
      
     </strong>
     
      :
     
     <strong class="source-inline">
      
       IConfiguration
      
     </strong>
     
      allows you to extract configuration values from multiple sources, offering flexibility
     
     <a id="_idIndexMarker708">
     </a>
     
      in how you manage configurations across different environments (development,
     
     
      
       test, production)
      
     
    </li>
    <li>
     <strong class="bold">
      
       Centralized management
      
     </strong>
     
      : Centralizes configuration management, making it easier to maintain and update
     
     <a id="_idIndexMarker709">
     </a>
     
      settings without spreading them across
     
     
      
       the application
      
     
    </li>
    <li>
     <strong class="bold">
      
       Environment-specific settings
      
     </strong>
     
      : Supports environment-specific configuration, allowing you to
     
     <a id="_idIndexMarker710">
     </a>
     
      customize settings based on the environment in which the application
     
     
      
       is running
      
     
    </li>
    <li>
     <strong class="bold">
      
       Strongly typed configuration
      
     </strong>
     
      : Through the
     
     <a id="_idIndexMarker711">
     </a>
     
      Options pattern, it supports configuration settings linked to strongly typed classes, improving type safety and
     
     
      
       reducing errors
      
     
    </li>
   </ul>
   <p>
    
     The following code examples
    
    <a id="_idIndexMarker712">
    </a>
    
     demonstrate a configuration defined in the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file; this value is then retrieved through the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, in the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <ul>
    <li>
     
      The following is the content of the
     
     
      <strong class="source-inline">
       
        appsettings.json
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=myServerAddress;
      Database=myDataBase;User Id=myUsername;
      Password=myPassword;"
  }
}</pre>
    </li>
    <li>
     
      The following is the content of the
     
     
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddRazorPages();
string connectionString = <strong class="bold">builder.Configuration</strong>
<strong class="bold">  .GetConnectionString("DefaultConnection");</strong>
builder.Services.AddDbContext&lt;MyDbContext&gt;(options =&gt;
  // options.UseSqlServer(connectionString));
  var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
app.UseStaticFiles();
app.UseRouting();
app.MapRazorPages();
app.Run();</pre>
    </li>
   </ul>
   <p>
    
     As we can
    
    <a id="_idIndexMarker713">
    </a>
    
     see in the highlighted line of the previous code snippet, the connection string is obtained from the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file using the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, using the
    
    <strong class="source-inline">
     
      GetConnectionString
     
    </strong>
    
     method and informing the configuration name
    
    
     
      or key.
     
    
   </p>
   <p>
    
     As the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     lifecycle considers the application lifecycle, all the complexity of obtaining settings through files such as
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     or other data sources is abstracted, simply using the methods available in the interface to obtain the desired parameters throughout the ASP.NET Core
    
    
     
      9 application.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface is also available in the
    
    <strong class="bold">
     
      dependency injection container
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DIC
     
    </strong>
    
     ), allowing you
    
    <a id="_idIndexMarker714">
    </a>
    
     to reference it in the constructor of any application class that will have its dependencies
    
    
     
      resolved dynamically.
     
    
   </p>
   <p class="callout-heading">
    
     IConfiguration methods
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface
    
    <a id="_idIndexMarker715">
    </a>
    
     provides several extension methods that offer different ways to obtain configuration data in ASP.NET Core 9 applications.
    
    
     See the following link for more
    
    
     
      details:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0">
     
      
       https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration?view=net-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The process of obtaining configurations in JSON files is a standard model for use in ASP.NET Core 9 applications.
    
    
     However, there are other ways of managing configurations, and for this possibility, there is the concept of providers, which we will explore in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-150">
    <a id="_idTextAnchor151">
    </a>
    
     Working with configuration providers
    
   </h1>
   <p>
    
     Configuration providers
    
    <a id="_idIndexMarker716">
    </a>
    
     allow configurations to be obtained from various sources, such as JSON files, environment variables,
    
    
     
      and more.
     
    
   </p>
   <p>
    
     Through configuration providers, we have greater flexibility and the ability to prepare our applications to run in different environments (such as development, test, or production) in an appropriate way without the need to implement string replacement logic in JSON files, in addition to bringing greater reliability
    
    
     
      and security.
     
    
   </p>
   <p>
    
     Next, we will understand how to add other configuration providers to our ASP.NET Core
    
    
     
      9 applications.
     
    
   </p>
   <h2 id="_idParaDest-151">
    <a id="_idTextAnchor152">
    </a>
    
     Adding configuration providers
    
   </h2>
   <p>
    
     Configuration providers
    
    <a id="_idIndexMarker717">
    </a>
    
     are used to read configuration data from various sources.
    
    
     This flexibility allows you to manage your application’s configuration settings in a consistent and
    
    
     
      centralized manner.
     
    
   </p>
   <p>
    
     This makes it possible to use configuration sources such as databases and even
    
    
     
      cloud services.
     
    
   </p>
   <p>
    
     In ASP.NET Core 9, there are already some configuration providers integrated by default, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       JSON configuration provider
      
     </strong>
     
      : Reads
     
     <a id="_idIndexMarker718">
     </a>
     
      configuration
     
     <a id="_idIndexMarker719">
     </a>
     
      data from JSON files such
     
     
      
       as
      
     
     
      <strong class="source-inline">
       
        appsettings.json
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Environment variable configuration provider
      
     </strong>
     
      : Reads configuration data from
     
     <a id="_idIndexMarker720">
     </a>
     
      
       environment
      
     
     
      <a id="_idIndexMarker721">
      </a>
     
     
      
       variables
      
     
    </li>
    <li>
     <strong class="bold">
      
       Command-line configuration provider
      
     </strong>
     
      : Reads
     
     <a id="_idIndexMarker722">
     </a>
     
      configuration
     
     <a id="_idIndexMarker723">
     </a>
     
      data from
     
     
      
       command-line arguments
      
     
    </li>
    <li>
     <strong class="bold">
      
       Memory configuration provider
      
     </strong>
     
      : Allows
     
     <a id="_idIndexMarker724">
     </a>
     
      you to add
     
     <a id="_idIndexMarker725">
     </a>
     
      in-memory configuration data, useful for
     
     
      
       unit testing
      
     
    </li>
   </ul>
   <p>
    
     During the implementation of example applications in this book, we have constantly used the following method in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     
      file:
     
    
    
     <strong class="source-inline">
      
       WebApplication.CreateBuilder(args);
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This method creates an instance of a
    
    <strong class="source-inline">
     
      Builder
     
    </strong>
    
     object, which represents a web application and allows us to add features such as services, middleware, and configurations.
    
    
     It creates a web application builder with some default parameters, so there is no need to define the provider configuration to obtain configuration data from the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p class="callout-heading">
    
     Default builder settings
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      CreateBuilder
     
    </strong>
    
     method defines some standardized parameters for the builder that will be created.
    
    
     You can learn more about these parameters by accessing the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-9.0#default-builder-settings
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     However, observe the following code example from the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file where configuration providers are
    
    
     
      explicitly added:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
 // Add configuration from environment variables
<strong class="bold">builder.Configuration.AddEnvironmentVariables();</strong>
// Add configuration from command-line arguments
<strong class="bold">builder.Configuration.AddCommandLine(args);</strong>
var app = builder.Build();
app.Run();</pre>
   <p>
    
     The preceding code uses two extension methods,
    
    <strong class="source-inline">
     
      AddEnvironmentVariables
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      AddCommandLine
     
    </strong>
    
     , allowing the application to obtain configurations from different providers.
    
    
     These extension methods are natively part of ASP.NET Core 9 applications.
    
    
     For other types of providers, it may be necessary to add NuGet packages to have access to extension methods for
    
    
     
      registering providers.
     
    
   </p>
   <p class="callout-heading">
    
     Built-in ASP.NET Core 9 configuration providers
    
   </p>
   <p class="callout">
    
     ASP.NET Core 9
    
    <a id="_idIndexMarker726">
    </a>
    
     offers several types of providers natively, as presented in the
    
    
     
      documentation:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-9.0#configuration-providers
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In the
    
    <em class="italic">
     
      Working with dynamic configurations and behaviors
     
    </em>
    
     section, we will use a provider to connect to a cloud resource that allows the management of configurations and behaviors in a dynamic and secure way.
    
    
     For now, let’s understand some important fundamentals, such as creating
    
    
     
      custom providers.
     
    
   </p>
   <h2 id="_idParaDest-152">
    <a id="_idTextAnchor153">
    </a>
    
     Creating a custom configuration provider
    
   </h2>
   <p>
    
     Creating a custom
    
    <a id="_idIndexMarker727">
    </a>
    
     configuration provider in ASP.NET Core 9 allows you to load configuration data from sources not natively supported by the framework.
    
    
     This can be useful for integrating with custom configuration stores, third-party services, or even
    
    
     
      proprietary formats.
     
    
   </p>
   <p>
    
     We already understand configuration management in native provisions in ASP.NET Core 9; now, we will create our first
    
    
     
      custom provider.
     
    
   </p>
   <p>
    
     To create a custom provider, you need to create
    
    
     
      two classes:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       ConfigurationSource
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       IConfigurationSource
      
     </strong>
     
      interface represents a source of configuration data.
     
     
      It is responsible for creating an instance of
     
     <strong class="source-inline">
      
       IConfigurationProvider
      
     </strong>
     
      , which will actually load the data.
     
     
      Separating the source and provider interfaces allows for a clear delineation between where configuration data comes from and how it is loaded.
     
     
      Through this approach, we benefit from encapsulating data source configurations and implementing best practices through
     
     <a id="_idIndexMarker728">
     </a>
     
      the
     
     
      <strong class="bold">
       
        Factory
       
      </strong>
     
     
      
       pattern.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       ConfigurationProvider
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       ConfigurationProvider
      
     </strong>
     
      class is an abstract base class that implements
     
     <strong class="source-inline">
      
       IConfigurationProvider
      
     </strong>
     
      .
     
     
      It is responsible for the actual loading and providing of configuration data.
     
     
      This class allows you to
     
     <a id="_idIndexMarker729">
     </a>
     
      define how data is read, cached,
     
     
      
       and accessed.
      
     
    </li>
   </ul>
   <p>
    
     We will start creating a custom provider through the class responsible for creating a custom
    
    
     
      provider instance:
     
    
   </p>
   <pre class="source-code">
using Microsoft.Extensions.Configuration;
public class CustomConfigurationSource :
  <strong class="bold">IConfigurationSource</strong>
{
<strong class="bold">  public IConfigurationProvider Build</strong>
<strong class="bold">    (IConfigurationBuilder builder)</strong>
    {
    return new CustomConfigurationProvider();
  }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      IConfigurationSource
     
    </strong>
    
     interface has only one method,
    
    <strong class="source-inline">
     
      Build()
     
    </strong>
    
     , which is responsible for returning a custom
    
    
     
      provider instance.
     
    
   </p>
   <p>
    
     Despite being simple, this class allows for better separation of responsibilities, with the sole objective of providing an instance of the provider that will have all the necessary mechanisms for interacting with another
    
    
     
      data source.
     
    
   </p>
   <p>
    
     Now, let’s look at the
    
    
     <strong class="source-inline">
      
       CustomConfigurationProvider
      
     </strong>
    
    
     
      class:
     
    
   </p>
   <pre class="source-code">
using Microsoft.Extensions.Configuration;
using System.Collections.Generic;
public class CustomConfigurationProvider :
  <strong class="bold">ConfigurationProvider</strong>
{
  public override void <strong class="bold">Load</strong>()
  {
    var data = new Dictionary&lt;string, string&gt;
    {
      { "MyCustomSetting:Key1", "Value1" },
      { " MyCustomSetting:Key2", "Value2" }
    };
    <strong class="bold">Data = data;</strong>
  }
}</pre>
   <p>
    
     The custom
    
    <a id="_idIndexMarker730">
    </a>
    
     provider implemented in the preceding code has an inheritance from the abstract
    
    <strong class="source-inline">
     
      ConfigurationProvider
     
    </strong>
    
     class, which already has some
    
    
     
      utility implementations.
     
    
   </p>
   <p>
    
     For this provider, we are creating two configurations that will be managed by an object of type
    
    <strong class="source-inline">
     
      Dictionary&lt;string, string&gt;
     
    </strong>
    
     , allowing us to create configurations based on key and value
    
    
     
      in memory.
     
    
   </p>
   <p>
    
     The logic for managing provided information must be implemented by overriding the
    
    <strong class="source-inline">
     
      Load
     
    </strong>
    
     method, inherited from the
    
    
     <strong class="source-inline">
      
       ConfigurationProvider
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     At the end of the
    
    <strong class="source-inline">
     
      Load
     
    </strong>
    
     method, it is necessary to set the value of the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     property, also inherited from the
    
    <strong class="source-inline">
     
      ConfigurationProvider
     
    </strong>
    
     class.
    
    
     The data type of the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     property is
    
    <strong class="source-inline">
     
      Dictionary&lt;string, string?&gt;
     
    </strong>
    
     ; that is, representing a key-value pair.
    
    
     Settings are persisted or serialized in string format.
    
    
     However, even with this feature, it is possible to create strongly typed configurations.
    
    
     We will cover this approach in the
    
    <em class="italic">
     
      Learning the Options
     
    </em>
    
     <em class="italic">
      
       pattern
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     Of course, this is a simple and didactic example.
    
    
     However, we can easily connect the custom provider to a SQL Server database, a storage account, or any other persistence resource.
    
    
     In the book’s code repository, the link to which is in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section, you can analyze another version of a custom provider where the data is persisted in a database.
    
    
     However, the implementation principles are the same as those demonstrated in the previous
    
    
     
      code snippets.
     
    
   </p>
   <p>
    
     For the new provider to be used, simply add the following code to the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     <strong class="bold">
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
builder.Configuration.Add(new CustomConfigurationSource());</pre>
   <p>
    
     You can also use
    
    <a id="_idIndexMarker731">
    </a>
    
     the extension method creation technique learned in
    
    <a href="B21788_08.xhtml#_idTextAnchor132">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     To obtain the settings through the new provider, simply use
    
    <strong class="source-inline">
     
      Configuration
     
    </strong>
    
     property methods, such as the
    
    <strong class="source-inline">
     
      GetValue&lt;T&gt;
     
    </strong>
    
     method, and rename the desired configuration, as demonstrated in the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
string key1 = _configuration.GetValue&lt;string&gt;
  (" MyCustomSetting:Key1");
string key2 = _configuration.GetValue&lt;string&gt;
  (" MyCustomSetting:Key2");</pre>
   <p>
    
     As we can see, the creation of a custom provider does not change the development model already available in ASP.NET Core 9, bringing greater flexibility
    
    
     
      and possibilities.
     
    
   </p>
   <p>
    
     Providers are an excellent abstraction for configuration management.
    
    
     However, ASP.NET Core 9 provides other types, such as the Options pattern, which we will discuss in the next section, making the configuration management model in our applications even
    
    
     
      more powerful.
     
    
   </p>
   <h1 id="_idParaDest-153">
    <a id="_idTextAnchor154">
    </a>
    
     Learning the Options pattern
    
   </h1>
   <p>
    
     ASP.NET Core 9 offers a
    
    <a id="_idIndexMarker732">
    </a>
    
     good way to handle application configurations through the use of the Options pattern.
    
    
     This pattern provides a robust mechanism for managing and accessing configuration settings in a strongly typed manner, improving the maintainability and testability of your code and organizing configuration settings into classes.
    
    
     In this section, we will understand what the Options pattern is and how to
    
    
     
      implement it.
     
    
   </p>
   <h2 id="_idParaDest-154">
    <a id="_idTextAnchor155">
    </a>
    
     What is the Options pattern?
    
   </h2>
   <p>
    
     Every application must
    
    <a id="_idIndexMarker733">
    </a>
    
     interact with some type of configuration, and in the previous chapters, we used the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface to obtain continuous information in the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file.
    
    
     However, this is not the only way to interact with configurations in ASP.NET Core 9, which offers an implementation of the
    
    
     
      Options pattern.
     
    
   </p>
   <p>
    
     The Options pattern is a design pattern that uses classes to represent groups of related configurations, allowing you to link configuration sections from various configuration sources (such as JSON files, environment variables, and so on) to these classes, allowing access to configuration settings, type-safe configuration, leveraging IntelliSense, and
    
    
     
      compile-time checking.
     
    
   </p>
   <p>
    
     In ASP.NET Core 9, the Options pattern has the following
    
    
     
      class hierarchy:
     
    
   </p>
   <div><div><img alt="Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9" src="img/B21788_09_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.1 – Main Options pattern abstraction in ASP.NET Core 9
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     , there are
    
    <a id="_idIndexMarker734">
    </a>
    
     several interfaces for abstracting the Options pattern, in addition to their respective implementations.
    
    
     Let’s briefly understand the purpose of each of the interfaces represented in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      :
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       IOptions&lt;T&gt;
      
     </strong>
     
      : The basic interface used to retrieve configured options.
     
     <strong class="source-inline">
      
       IOptions&lt;T&gt;
      
     </strong>
     
      types are registered as singletons.
     
     
      Then, when starting the application, the configurations are loaded into memory and made available throughout the application
     
     <a id="_idIndexMarker735">
     </a>
     
      using
     
     <strong class="bold">
      
       dependency injection
      
     </strong>
     
      (
     
     <strong class="bold">
      
       DI
      
     </strong>
     
      ).
     
     
      However, if any changes are made to the application so that they can be reflected, the application must
     
     
      
       be restarted.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       IOptionsSnapshot&lt;T&gt;
      
     </strong>
     
      : A variation of
     
     <strong class="source-inline">
      
       IOptions&lt;T&gt;
      
     </strong>
     
      that provides a mechanism that updates configurations with each request.
     
     
      This interface allows application settings to be updated in real time.
     
     
      The lifecycle of this class is scoped; that is, the configurations are loaded with
     
     
      
       each request.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       IOptionsMonitor&lt;T&gt;:
      
     </strong>
     
      An interface that allows you to monitor option changes and provides a way to receive notifications when options are updated.
     
     
      The lifecycle of this interface is singleton, available when the application
     
     
      
       is initialized.
      
     
    </li>
    <li>
     
      Classes that do not have the “
     
     <strong class="source-inline">
      
       I
      
     </strong>
     
      ” prefix represent the concrete implementation of
     
     
      
       each
      
     
     
      <a id="_idIndexMarker736">
      </a>
     
     
      
       interface.
      
     
    </li>
   </ul>
   <p>
    
     The Options pattern offers an excellent option for manipulating configurations without the need to call strings but by creating strongly
    
    
     
      typed configurations.
     
    
   </p>
   <p>
    
     Let’s understand how the Options pattern
    
    
     
      is implemented.
     
    
   </p>
   <h2 id="_idParaDest-155">
    <a id="_idTextAnchor156">
    </a>
    
     Implementing the Options pattern
    
   </h2>
   <p>
    
     As we learned
    
    <a id="_idIndexMarker737">
    </a>
    
     throughout the book’s chapters, it is a good practice to centrally manage configuration information, and in most of the code available in this book, we use basic configurations, such as a database
    
    
     
      connection string.
     
    
   </p>
   <p>
    
     Although the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface provides us with mechanisms for obtaining configurations, in some cases, this can affect the management and responsibilities of each class, which must know exactly the strings it wants to obtain from the
    
    
     
      configuration file.
     
    
   </p>
   <p>
    
     There are practices such as the use of constants; however, working with strongly typed classes to aggregate a set of information can be a
    
    
     
      powerful resource.
     
    
   </p>
   <p>
    
     Let’s imagine the
    
    
     
      following context:
     
    
   </p>
   <p>
    
     Imagine an e-commerce application, where we have different services and resources such as payment and shipping.
    
    
     These resources have a set of distinct settings.
    
    
     In this example, we would have approximately the
    
    
     
      following configurations:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       PaymentGatewayURL
      
     </strong>
     
      : URL of the gateway responsible for processing
     
     
      
       the payment
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       APIKey
      
     </strong>
     
      : API key for using the
     
     
      
       payment gateway
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       Timeout
      
     </strong>
     
      :
     
     
      
       Timeout configuration
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       DefaultCarrier
      
     </strong>
     
      : Default carrier for
     
     
      
       delivering orders
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       FreeShippingThreshold
      
     </strong>
     
      : Free shipping
     
     
      
       threshold setting
      
     
    </li>
   </ul>
   <p>
    
     When developing the e-commerce application, for each configuration, it would be necessary to use the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     class to obtain data from the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file, for
    
    <a id="_idIndexMarker738">
    </a>
    
     example.
    
    
     Let’s look at the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
// Accessing settings directly using IConfiguration
<strong class="bold">string paymentGatewayURL =</strong>
<strong class="bold">  _configuration["PaymentGatewayURL"];</strong>
<strong class="bold">string apiKey = _configuration["APIKey"];</strong>
<strong class="bold">int timeout = _configuration.GetValue&lt;int&gt;("Timeout");</strong>
<strong class="bold">string defaultCarrier = _configuration["DefaultCarrier"];</strong>
<strong class="bold">decimal freeShippingThreshold =</strong>
<strong class="bold">  _configuration.GetValue&lt;decimal&gt;</strong>
<strong class="bold">  ("FreeShippingThreshold");</strong></pre>
   <p>
    
     The preceding settings would be available in the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
{
   "PaymentGatewayURL": "https://payment.aspnetcore9.com",
   "APIKey": "your-api-key",
   "Timeout": 30
   "DefaultCarrier": "UPS",
   "FreeShippingThreshold": 30.00
}</pre>
   <p>
    
     The implementation of the settings recovery code demonstrated is correct.
    
    
     However, in more complex scenarios, it may be difficult to manage different types of configurations; there may be code duplications, which makes maintenance difficult, and if there is a typing error in the configuration key, for example, this problem will only be detected
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     Fortunately, through the abstraction of the Options pattern in ASP.NET Core 9, we have the possibility of grouping configurations in a
    
    
     
      simple way.
     
    
   </p>
   <p>
    
     Based on the preceding example, we
    
    <a id="_idIndexMarker739">
    </a>
    
     basically have two types
    
    
     
      of information:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        PaymentSettings
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        PaymentGatewayURL
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        APIKey
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        Timeout
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        ShipmentSettings
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        DefaultCarrier
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        FreeShippingThreshold
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     This way, we could group the configurations into two distinct classes, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.2 – Grouping configurations" src="img/B21788_09_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.2 – Grouping configurations
    
   </p>
   <p>
    
     The preceding classes only have the properties that will reference the respective configurations in a grouped manner.
    
    
     With this, we will have the following code defining
    
    <strong class="source-inline">
     
      PaymentSettings
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       ShipingmentSettings
      
     </strong>
    
    
     
      classes:
     
    
   </p>
   <pre class="source-code">
public class <strong class="bold">PaymentSettings</strong>
{
    public string PaymentGatewayURL { get; set; }
    public string APIKey { get; set; }
    public int Timeout { get; set; }
}
public class <strong class="bold">Shippingettings</strong>
{
    public string DefaultCarrier { get; set; }
    public decimal FreeShippingThreshold { get; set; }
}</pre>
   <p>
    
     The classes represented
    
    <a id="_idIndexMarker740">
    </a>
    
     in the preceding code only aim to abstract a set of configurations, not having any types of implemented behaviors, but there may be methods
    
    
     
      if necessary.
     
    
   </p>
   <p>
    
     However, the classes that will be used in the Options pattern must follow the
    
    
     
      following rules:
     
    
   </p>
   <ul>
    <li>
     
      
       Being non-abstract
      
     
    </li>
    <li>
     
      Having public
     
     
      
       read-and-write properties
      
     
    </li>
    <li>
     
      Fields are disregarded
     
     
      
       during binding
      
     
    </li>
   </ul>
   <p>
    
     For this example, we will just keep the properties.
    
    
     Additionally, we will change the
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     file, which will have the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
{
     "<strong class="bold">PaymentSettings</strong>": {
      "PaymentGatewayURL":
        "https://payment.aspnetcore9.com",
      "APIKey": "your-api-key",
      "Timeout": 30
    },
    "<strong class="bold">ShippingSettings</strong>": {
      "DefaultCarrier": "UPS",
      "FreeShippingThreshold": 30.00
    }
}</pre>
   <p>
    
     We can see in the
    
    <a id="_idIndexMarker741">
    </a>
    
     preceding code that the settings are grouped by
    
    <strong class="source-inline">
     
      PaymentSettings
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      ShippingSettings
     
    </strong>
    
     , which are exactly the names of the classes, and respectively, the properties also have the
    
    
     
      same names.
     
    
   </p>
   <p>
    
     The Options pattern uses this convention to bind the settings with the class that will abstract this information in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Now, let’s look at the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file with the changes made to use the
    
    
     
      Options pattern:
     
    
   </p>
   <pre class="source-code">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.Configure&lt;PaymentSettings&gt;</strong>
<strong class="bold">  (builder.Configuration.GetSection("PaymentSettings"));</strong>
<strong class="bold">builder.Services.Configure&lt;ShippingSettings&gt;</strong>
<strong class="bold">  (builder.Configuration.GetSection("ShippingSettings"));</strong>
builder.Services.AddRazorPages();
builder.Services.AddSingleton&lt;EcommerceService&gt;();
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
app.UseStaticFiles();
app.UseRouting();
app.MapRazorPages();
app.Run();</pre>
   <p>
    
     As you can see in the highlighted code lines in the preceding code block, the
    
    <strong class="source-inline">
     
      GetSection
     
    </strong>
    
     method is used from the
    
    <strong class="source-inline">
     
      IConfiguration
     
    </strong>
    
     interface, accessed through the
    
    <strong class="source-inline">
     
      Configuration
     
    </strong>
    
     extension method.
    
    
     The
    
    <strong class="source-inline">
     
      GetSection
     
    </strong>
    
     method is a generic implementation, where the type entered determines the return type.
    
    
     The name of the section is entered as
    
    <a id="_idIndexMarker742">
    </a>
    
     a parameter, which, in this case, is the desired
    
    
     
      configuration group.
     
    
   </p>
   <p class="callout-heading">
    
     Extension methods
    
   </p>
   <p class="callout">
    
     In the preceding code example, to facilitate understanding, we are registering the configuration classes using the Options pattern directly in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file.
    
    
     However, it is good practice to create an extension method for registering classes that use the
    
    
     
      Options pattern.
     
    
   </p>
   <p>
    
     When executing these methods, the settings will be loaded into a
    
    <strong class="source-inline">
     
      PaymentSettings
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      ShipmentSettings
     
    </strong>
    
     object and these will be instantiated as a singleton and available in every application through
    
    
     
      the DIC.
     
    
   </p>
   <p>
    
     The following is an example of code where the configurations depend on a given
    
    
     
      service class:
     
    
   </p>
   <pre class="source-code">
public class OrderService
{
    private readonly PaymentSettings _paymentSettings;
    private readonly IPaymentGateway _paymentGateway;
    public OrderService(<strong class="bold">IOptions&lt;PaymentSettings&gt;</strong>
      paymentSettings, IPaymentGateway paymentGateway)
    {
        _paymentettings = paymentSettings.Value;
        _paymentGateway = paymentGateway;
    }
    public async Task&lt;IOrder&gt; Pay(decimal ammount)
    {
       var order = _paymentGateway(ammount,
        _paymentSettings.ApiKey,
        _paymentSettings.PaymentGatewayURL);
    // ..
    }
}</pre>
   <p>
    
     As we noted in the
    
    <strong class="source-inline">
     
      OrderService
     
    </strong>
    
     implementation, we just injected an
    
    <strong class="source-inline">
     
      IOptions
     
    </strong>
    
     interface for the
    
    <strong class="source-inline">
     
      PaymentSettings
     
    </strong>
    
     type.
    
    
     With
    
    <a id="_idIndexMarker743">
    </a>
    
     this, the dependency is resolved by the ASP.NET Core
    
    
     
      9 DIC.
     
    
   </p>
   <p>
    
     Adopting the Options pattern offers several benefits, such as allowing the organization of configuration settings, grouping them into dedicated classes, and the use of strongly
    
    
     
      typed configuration.
     
    
   </p>
   <p>
    
     In addition to improving maintenance and implementation quality, errors can also be detected during compilation time.
    
    
     You can also benefit from using unit tests, which is an
    
    
     
      excellent practice.
     
    
   </p>
   <p>
    
     The Options
    
    <a id="_idIndexMarker744">
    </a>
    
     pattern in ASP.NET Core 9 is a powerful and flexible way to manage configuration settings, supporting environment-specific configurations and making it easier to manage configurations for different
    
    
     
      deployment environments.
     
    
   </p>
   <p>
    
     Now that we have learned how to use the Options pattern to properly deal with application configurations, it is time to understand how to manage these configurations securely in a cloud environment, in addition to learning how to dynamically manipulate behaviors in
    
    
     
      our applications.
     
    
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor157">
    </a>
    
     Working with dynamic configurations and behaviors
    
   </h1>
   <p>
    
     In the ever-evolving landscape of web applications, maintaining flexibility and responsiveness is crucial.
    
    
     As developers, we must ensure that our applications can adapt to changes quickly and securely.
    
    
     Dynamic configurations
    
    <a id="_idIndexMarker745">
    </a>
    
     and behavior management
    
    <a id="_idIndexMarker746">
    </a>
    
     are key strategies that allow us to achieve this flexibility.
    
    
     By managing configurations dynamically, we can update them without redeploying our applications.
    
    
     Additionally, by implementing application behavior management using techniques such as
    
    <strong class="bold">
     
      feature toggles
     
    </strong>
    
     , we can
    
    <a id="_idIndexMarker747">
    </a>
    
     control resource availability in real time, giving us the ability to effortlessly test, deploy, or roll
    
    
     
      back features.
     
    
   </p>
   <p class="callout-heading">
    
     Feature toggles
    
   </p>
   <p class="callout">
    
     Feature toggles
    
    <a id="_idIndexMarker748">
    </a>
    
     or feature flags are a software development technique used to enable or disable specific functionality in a software application at runtime, facilitating
    
    <strong class="bold">
     
      continuous integration and delivery
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI/CD
     
    </strong>
    
     ) by allowing code changes to be merged into the main code
    
    <a id="_idIndexMarker749">
    </a>
    
     base without immediately exposing new functionality to all users.
    
    
     This technique helps in mitigating risks, conducting A/B testing, performing canary releases, and rolling back features without redeploying
    
    
     
      the code.
     
    
   </p>
   <p class="callout">
    
     Access the following article to learn more
    
    <a id="_idIndexMarker750">
    </a>
    
     about the
    
    
     
      technique:
     
    
    <a href="https://martinfowler.com/articles/feature-toggles.html">
     
      
       https://martinfowler.com/articles/feature-toggles.html
      
     
    </a>
   </p>
   <p>
    
     Let’s delve into the details of dynamic configuration management and implement a
    
    
     
      practical example.
     
    
   </p>
   <h2 id="_idParaDest-157">
    <a id="_idTextAnchor158">
    </a>
    
     Working with dynamic settings
    
   </h2>
   <p>
    
     Dynamic settings
    
    <a id="_idIndexMarker751">
    </a>
    
     refer to the ability to modify application configurations at runtime without the need for redeployment.
    
    
     This capability is essential for maintaining application uptime, ensuring quick responses to changes in requirements, and enhancing security by allowing rapid adjustments to
    
    
     
      sensitive configurations.
     
    
   </p>
   <p>
    
     Modern applications must have
    
    <a id="_idIndexMarker752">
    </a>
    
     dynamic configuration management mechanisms to guarantee the quality of the solution, in addition to benefits such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Zero downtime
      
     </strong>
     
      : Update configurations without redeploying the application, ensuring continuous availability.
     
     
      This is an important feature that allows us to bring reliability and a better experience
     
     
      
       to users.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Security
      
     </strong>
     
      : Quickly update security settings and credentials in response
     
     
      
       to threats.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Flexibility
      
     </strong>
     
      : Adjust settings in real time to accommodate changing
     
     
      
       business requirements.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Simplified deployments
      
     </strong>
     
      : Reduce the complexity and risk associated with application deployments by decoupling configuration changes from code changes.
     
     
      In scenarios with many environments, such as development, testing, and production, the application will have different configurations based on the resources of each environment.
     
     
      Having the ability to abstract the management of application configurations improves quality, segregates responsibilities, and maintains continuous
     
     
      
       delivery flow.
      
     
    </li>
   </ul>
   <p>
    
     Several options are available to dynamically manage configurations in ASP.NET Core 9, including configuration files, environment variables, and cloud-based services such as
    
    <strong class="bold">
     
      Azure App Configuration
     
    </strong>
    
     .
    
    
     Azure App Configuration
    
    <a id="_idIndexMarker753">
    </a>
    
     stands out for its robust features and seamless integration with other
    
    
     
      Azure services.
     
    
   </p>
   <p>
    
     Azure App Configuration
    
    <a id="_idIndexMarker754">
    </a>
    
     is a service that provides a centralized way to manage configuration settings and feature flags.
    
    
     It allows applications to dynamically adjust their behavior
    
    
     
      without redeployment.
     
    
   </p>
   <p class="callout-heading">
    
     Azure App Configuration
    
   </p>
   <p class="callout">
    
     Azure App Configuration is a powerful feature available in Microsoft Azure that allows us to manage configurations and feature toggles securely, supporting the deployment of
    
    
     
      cloud-native applications.
     
    
   </p>
   <p class="callout">
    
     For more details about
    
    <a id="_idIndexMarker755">
    </a>
    
     Azure App Configuration, I suggest reading the rich documentation about the
    
    
     
      resource:
     
    
    <a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/">
     
      
       https://learn.microsoft.com/en-us/azure/azure-app-configuration/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     We won’t cover all the details of setting up and using Azure App Configuration in this book.
    
    
     For now, we will use the main resources to exemplify the use of dynamic configurations in
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     Let’s create an application that interacts with Azure App Configuration and uses some patterns already learned in this chapter, such as the
    
    
     
      Options pattern.
     
    
   </p>
   <h3>
    
     Setting up Azure App Configuration
    
   </h3>
   <p>
    
     Azure App
    
    <a id="_idIndexMarker756">
    </a>
    
     Configuration is a cloud-based service that provides a centralized repository for application configurations, enabling dynamic
    
    
     
      configuration management.
     
    
   </p>
   <p>
    
     Let’s create an Azure App Configuration resource before creating an application.
    
    
     You will need access to an Azure subscription, as described in the
    
    <em class="italic">
     
      Technical
     
    </em>
    
     <em class="italic">
      
       requirements
      
     </em>
    
    
     
      section.
     
    
   </p>
   <p>
    
     With access to the Azure subscription, follow these steps to create an Azure App
    
    
     
      Configuration resource:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the Azure portal (
     
     <a href="https://portal.azure.com">
      
       https://portal.azure.com
      
     </a>
     
      ), and in the search field, in the top bar, type
     
     <strong class="source-inline">
      
       App Configuration
      
     </strong>
     
      and click on the icon, as highlighted in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .3
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.3 – Accessing the App Configuration service" src="img/B21788_09_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.3 – Accessing the App Configuration service
    
   </p>
   <ol>
    <li value="2">
     
      On the next screen, click on the
     
     <strong class="bold">
      
       + Create
      
     </strong>
     
      option to add the new resource, as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .4
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.4 – Creating a new App Configuration resource" src="img/B21788_09_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.4 – Creating a new App Configuration resource
    
   </p>
   <ol>
    <li value="3">
     
      On the next screen, we must configure the parameters of the new resource.
     
     
      We will keep the default
     
     <a id="_idIndexMarker757">
     </a>
     
      settings.
     
     
      Use the following parameter suggestions as
     
     
      
       a reference:
      
     
     <ul>
      <li>
       <strong class="bold">
        
         Resource group
        
       </strong>
       
        :
       
       <strong class="source-inline">
        
         rg-aspnetcore8
        
       </strong>
       
        .
       
       
        Be sure to click the
       
       <strong class="bold">
        
         Create new
        
       </strong>
       
        button below the
       
       <strong class="bold">
        
         Resource group
        
       </strong>
       
        field to create the new
       
       
        
         resource group.
        
       
      </li>
      <li>
       <strong class="bold">
        
         Location
        
       </strong>
       
        :
       
       <strong class="bold">
        
         East
        
       </strong>
       
        <strong class="bold">
         
          US 2
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Resource name
        
       </strong>
       
        :
       
       <strong class="source-inline">
        
         &lt;Your
        
       </strong>
       
        <strong class="source-inline">
         
          Last Name&gt;-configuration
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Pricing
        
       </strong>
       
        <strong class="bold">
         
          tier
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="bold">
         
          Standard
         
        </strong>
       
      </li>
      <li>
       
        Leave the
       
       <strong class="bold">
        
         Create replicas
        
       </strong>
       
        
         option unchecked.
        
       
      </li>
     </ul>
    </li>
    <li>
     
      Click on the
     
     <strong class="bold">
      
       Review + Create
      
     </strong>
     
      button then the
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      button, and wait for the resource to
     
     
      
       be created.
      
     
    </li>
    <li>
     
      When you finish creating the new resource, click the
     
     <strong class="bold">
      
       Go to resource
      
     </strong>
     
      button, as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     <em class="italic">
      
       .5
      
     </em>
     
      , or access the
     
     <strong class="bold">
      
       App Configuration
      
     </strong>
     
      list, as described in
     
     <em class="italic">
      
       step 1
      
     </em>
     
      , and click on the
     
     
      
       created resource:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.5 – New App Configuration creation status" src="img/B21788_09_05.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.5 – New App Configuration creation status
    
   </p>
   <p>
    
     Now that we have the configuration management resource created, it’s time to create and configure our application to interact with Azure
    
    
     
      App Configuration.
     
    
   </p>
   <h4>
    
     Creating and connecting an application in Azure App Configuration
    
   </h4>
   <p>
    
     For this example, an
    
    <a id="_idIndexMarker758">
    </a>
    
     ASP.NET Core 9 MVC application will be created and connected to the Azure App Configuration service
    
    
     
      created previously.
     
    
   </p>
   <p>
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Open the terminal, and in a folder of your choice, create a directory
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        DynamicConfiguration
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">mkdir DynamicConfiguration</strong></pre>
    </li>
    <li>
     
      Now, access the directory with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">cd DynamicConfiguration</strong></pre>
    </li>
    <li>
     
      Run the following command to create
     
     
      
       the application:
      
     
     <pre class="source-code">
<strong class="bold">dotnet new mvc -n DynamicConfiguration -o .</strong></pre>
     <p class="list-inset">
      
       The previous command creates an MVC application with the name
      
      <strong class="source-inline">
       
        DynamicConfiguration
       
      </strong>
      
       , defined with the
      
      <strong class="source-inline">
       
        -n
       
      </strong>
      
       parameter and in the current directory, determined by the
      
      <strong class="source-inline">
       
        –o .
       
      </strong>
      
       
        parameter.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     With the application created, we will simply prepare it to integrate with Azure App Configuration.
    
    
     To do this, run the following command in the application directory to open Visual
    
    
     
      Studio Code:
     
    
   </p>
   <pre class="console">
code .</pre>
   <p>
    
     Now, in the root of the project, create an
    
    <strong class="source-inline">
     
      Options
     
    </strong>
    
     folder and then create a file called
    
    <strong class="source-inline">
     
      GlobalOptions.cs
     
    </strong>
    
     .
    
    
     This file must contain the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
namespace DynamicConfiguration.Options;
public class GlobalOptions
{
    public string Title { get; set; }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      GlobalOptions
     
    </strong>
    
     class
    
    <a id="_idIndexMarker759">
    </a>
    
     has only one property called
    
    <strong class="source-inline">
     
      Title
     
    </strong>
    
     that will be obtained through Azure
    
    
     
      App Configuration.
     
    
   </p>
   <p>
    
     When the application starts, it loads the settings as we learned previously, using files such as
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     and environment variables, among other providers that can be configured.
    
    
     However, for our classes, the details of obtaining the configurations are abstracted by ASP.NET Core 9, and, in this case, whatever the provider, when using the Options pattern, we will have the correct separation of responsibility, maintainability, flexibility,
    
    
     
      and extensibility.
     
    
   </p>
   <p>
    
     Let’s change the code of the
    
    <strong class="source-inline">
     
      HomeController
     
    </strong>
    
     class, in the
    
    <strong class="source-inline">
     
      Controllers
     
    </strong>
    
     folder, and add the settings previously created using the Options pattern.
    
    
     The
    
    <strong class="source-inline">
     
      HomeController
     
    </strong>
    
     class code will look like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
public class HomeController : Controller
{
    private readonly ILogger&lt;HomeController&gt; _logger;
    <strong class="bold">private readonly GlobalOptions _globalOptions;</strong>
    public HomeController(ILogger&lt;HomeController&gt; logger<strong class="bold">,</strong>
<strong class="bold">      IOptionsSnapshot&lt;GlobalOptions&gt; globalOptions</strong>)
    {
        _logger = logger;
       <strong class="bold"> _globalOptions = globalOptions.Value;</strong>
    }
    public IActionResult Index()
    {
      <strong class="bold">  ViewData["Title"] = _globalOptions.Title;</strong>
        return View();
    }
    public IActionResult Privacy()
    {
        return View();
    }
    [ResponseCache(Duration = 0,
      Location = ResponseCacheLocation.None,
      NoStore = true)]
    public IActionResult Error()
    {
        return View(new ErrorViewModel {
          RequestId = Activity.Current?.Id ??
          HttpContext.TraceIdentifier });
    }
}</pre>
   <p>
    
     Simple
    
    <a id="_idIndexMarker760">
    </a>
    
     changes were made to the class.
    
    
     Let’s understand each
    
    
     
      of them:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       GlobalOptions field
      
     </strong>
     
      : A new field was created for the class that is of type
     
     <strong class="source-inline">
      
       GlobalOptions
      
     </strong>
     
      ,
     
     
      
       created previously
      
     
    </li>
    <li>
     <strong class="bold">
      
       Change in the constructor
      
     </strong>
     
      : Configurations will be injected through the ASP.NET Core 9 DIC, and that is why we added a parameter of type
     
     <strong class="source-inline">
      
       IOptionsSnapshot&lt;GlobalSettings&gt;
      
     </strong>
     
      .
     
     
      The purpose of using the
     
     <strong class="source-inline">
      
       IOptionsSnapshot&lt;&gt;
      
     </strong>
     
      interface is to allow you to obtain configurations dynamically, as we learned in the
     
     <em class="italic">
      
       What is the Options pattern?
      
     </em>
     
      section.
     
     
      If another interface is used, such as
     
     <strong class="source-inline">
      
       IOptions&lt;&gt;
      
     </strong>
     
      , the parameters will be loaded, but
     
     
      
       not dynamically.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Changing the Index action
      
     </strong>
     
      : We change the
     
     <strong class="source-inline">
      
       Index
      
     </strong>
     
      action where we set the value of the
     
     <strong class="source-inline">
      
       Title
      
     </strong>
     
      property in the
     
     <strong class="source-inline">
      
       ViewData
      
     </strong>
     
      dictionary with the value of the configuration of the
     
     <strong class="source-inline">
      
       Title
      
     </strong>
     
      property of the
     
     <strong class="source-inline">
      
       _globalOptions
      
     </strong>
     
      object.
     
     
      The
     
     <strong class="source-inline">
      
       ViewData["Title"]
      
     </strong>
     
      dictionary is used in the
     
     <strong class="source-inline">
      
       Views/Home/Index.cshtml
      
     </strong>
     
      file to display the
     
     
      
       page title.
      
     
    </li>
   </ul>
   <p>
    
     Now, let’s change the code on the
    
    <strong class="source-inline">
     
      Views/Home/Index.cshtml
     
    </strong>
    
     page to display the title in the body of
    
    
     
      the page:
     
    
   </p>
   <pre class="source-code">
&lt;div class="text-center"&gt;
&lt;h1 class="display-4"&gt;Welcome <strong class="bold">@ViewData["Title"]</strong>&lt;/h1&gt;
&lt;p&gt;Learn about &lt;a
  href="https://learn.microsoft.com/aspnet/core"&gt;
  building Web apps with ASP.NET Core&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</pre>
   <p>
    
     As can be seen in the highlighted code, we are only rendering the value contained in the
    
    
     <strong class="source-inline">
      
       ViewData["Title"]
      
     </strong>
    
    
     
      dictionary.
     
    
   </p>
   <p>
    
     The application is prepared to render data obtained through configuration.
    
    
     Now, it’s time to connect the application to Azure
    
    
     
      App Configuration.
     
    
   </p>
   <p>
    
     First, open the terminal in the application directory and run the following command to add the NuGet package that contains the
    
    
     
      necessary SDK:
     
    
   </p>
   <pre class="console">
dotnet add package Microsoft.Azure.AppConfiguration.AspNetCore</pre>
   <p>
    
     Now, you will need to get the connection string containing the resource from Azure App Configuration.
    
    
     Let’s
    
    <a id="_idIndexMarker761">
    </a>
    
     execute the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Access the Azure
     
     
      
       portal (
      
     
     <a href="https://portal.azure.com">
      
       
        https://portal.azure.com
       
      
     </a>
     
      
       ).
      
     
    </li>
    <li>
     
      In the search field, in the top bar of the portal, type
     
     <strong class="source-inline">
      
       App Configuration
      
     </strong>
     
      and click on
     
     
      
       the option.
      
     
    </li>
    <li>
     
      Then, in the list of configuration resources, click on the previously created resource with the name
     
     <strong class="source-inline">
      
       &lt;Your
      
     </strong>
     
      <strong class="source-inline">
       
        Last Name&gt;-configuration
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      In the side menu, look for the
     
     <strong class="bold">
      
       Access settings
      
     </strong>
     
      option and copy the connection string as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .6
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 9.6 – Getting the connection string from App Configuration" src="img/B21788_09_06.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.6 – Getting the connection string from App Configuration
    
   </p>
   <ol>
    <li value="5">
     
      Now, run the following command in the terminal, in the application directory.
     
     
      The command uses a secret manager to store a secret named
     
     <strong class="source-inline">
      
       ConnectionStrings:AppConfig
      
     </strong>
     
      , which stores the connection string for your App Configuration store.
     
     
      Replace the
     
     <strong class="source-inline">
      
       &lt;your_connection_string&gt;
      
     </strong>
     
      placeholder with your App Configuration store’s connection string.
     
     
      This is a good practice to prevent sensitive data, such as connection strings that are credentials or have passwords, from being persisted in version control, bringing vulnerabilities to
     
     
      
       your application:
      
     
     <pre class="source-code">
<strong class="bold">dotnet user-secrets init</strong>
<strong class="bold">dotnet user-secrets set ConnectionStrings:AppConfig "&lt;your_connection_string&gt;"</strong></pre>
    </li>
   </ol>
   <p>
    
     With the definition of the secret that contains the App Configuration connection string, we will change the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file to add the necessary services and middleware.
    
    
     Let’s look at
    
    <a id="_idIndexMarker762">
    </a>
    
     the changed
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      code:
     
    
   </p>
   <pre class="source-code">
using Microsoft.Extensions.Configuration
  .AzureAppConfiguration;
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">Builder.Services.AddAzureAppConfiguration();</strong>
var connectionString = <strong class="bold">builder.Configuration</strong>
<strong class="bold">  .GetConnectionString("AppConfig")</strong>;
<strong class="bold">builder.Configuration.AddAzureAppConfiguration(options =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    options.Connect(connectionString)</strong>
<strong class="bold">    .Select("DynamicConfiguration:*", LabelFilter.Null)</strong>
<strong class="bold">    .ConfigureRefresh(refreshOptions =&gt;</strong>
<strong class="bold">    refreshOptions.Register("DynamicConfiguration:</strong>
<strong class="bold">      Sentinel", refreshAll: true));</strong>
<strong class="bold">  });</strong>
<strong class="bold">builder.Services.Configure&lt;GlobalOptions&gt;</strong>
<strong class="bold">  (builder.Configuration</strong>
<strong class="bold">  .GetSection("DynamicConfiguration:GlobalOptions"));</strong>
builder.Services.AddControllersWithViews();
var app = builder.Build();
if (!app.Environment.IsDevelopment())
{
  app.UseExceptionHandler("/Home/Error");
  app.UseHsts();
}
// Middleware to refresh configuration
<strong class="bold">app.UseAzureAppConfiguration();</strong>
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapControllerRoute(
name: "default",
pattern: "{controller=Home}/{action=Index}/{id?}");
app.Run();</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker763">
    </a>
    
     App Configuration SDK has excellent abstraction and is simple to integrate into the application.
    
    
     Let’s understand the changes made to the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       builder.Services.AddAzureAppConfiguration()
      
     </strong>
     
      : This method registers the necessary services for Azure App Configuration to work within your ASP.NET Core
     
     
      
       9 application.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       builder.Configuration.GetConnectionString("AppConfig")
      
     </strong>
     
      : This line of code gets the Azure Application Configuration connection string, previously obtained from the Azure portal and added to the application via a secret.
     
     
      Note that getting the connection string is identical to getting it from
     
     <strong class="source-inline">
      
       the appsettings.json
      
     </strong>
     
      file.
     
     
      The big difference in managing configurations through secrets is that they are only kept on the
     
     
      
       local machine.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       builder.Configuration.AddAzureAppConfiguration
      
     </strong>
     
      : This extension method adds Azure App Configuration as a configuration provider to
     
     
      
       your application.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       options.Connect(connectionString)
      
     </strong>
     
      : Connects to the Azure application configuration instance using the previously obtained
     
     
      
       connection string.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       .Select("Dynamic Configuration:*", LabelFilter.Null)
      
     </strong>
     
      : Specifies that all keys with the
     
     <strong class="source-inline">
      
       DynamicConfiguration:
      
     </strong>
     
      prefix should be selected.
     
     
      The
     
     <strong class="source-inline">
      
       LabelFilter.Null
      
     </strong>
     
      parameter indicates that only unlabeled configurations
     
     
      
       are retrieved.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       .ConfigureRefresh
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       ConfigureRefresh
      
     </strong>
     
      method registers keys that you want to monitor for changes in your application
     
     
      
       configuration store.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       refreshOptions.Register("Dynamic Configuration", updateAll: true)
      
     </strong>
     
      : Registers a sentinel key (
     
     <strong class="source-inline">
      
       DynamicConfiguration:Sentinel
      
     </strong>
     
      ) that triggers an update.
     
     
      When the value of this key changes, all settings will be updated (
     
     
      <strong class="source-inline">
       
        refreshAll: true
       
      </strong>
     
     
      
       ).
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       builder.Services.Configure&lt;GlobalOptions&gt;(builder.Configuration.GetSection("DynamicConfiguration: GlobalOptions"))
      
     </strong>
     
      : This line of code binds the configuration created in Azure App Configuration and the
     
     <strong class="source-inline">
      
       GlobalOptions
      
     </strong>
     
      class created previously.
     
     
      With this, it will be possible to obtain the configuration through the DIC using the
     
     
      
       Options pattern.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       UseAzureAppConfiguration
      
     </strong>
     
      : Allows your application to use the application
     
     <a id="_idIndexMarker764">
     </a>
     
      configuration middleware to update
     
     
      
       configuration automatically.
      
     
    </li>
   </ul>
   <p>
    
     In summary, the previous configurations, added to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, allow the application to connect to Azure App Configuration via the
    
    
     
      connection string.
     
    
   </p>
   <p>
    
     The App Configuration SDK works with the concept of pooling.
    
    
     In this case, when obtaining the configurations, a cache is made in the application’s memory, to avoid constant requests to the Azure service and optimize the
    
    
     
      application’s functioning.
     
    
   </p>
   <p>
    
     By default, the time the application queries Azure App Configuration for updates is 30 seconds.
    
    
     It is possible to specify the refresh call time using the
    
    <strong class="source-inline">
     
      refreshOptions.SetCacheExpiration
     
    </strong>
    
     method.
    
    
     A
    
    <strong class="source-inline">
     
      Sentinel
     
    </strong>
    
     parameter was also configured, responsible for determining whether there were changes to
    
    
     
      the settings.
     
    
   </p>
   <p>
    
     It is important as it prevents the SDK from analyzing each configuration individually, and if
    
    <strong class="source-inline">
     
      Sentinel
     
    </strong>
    
     has been changed, all configurations will
    
    
     
      be updated.
     
    
   </p>
   <p>
    
     Now that we’ve
    
    <a id="_idIndexMarker765">
    </a>
    
     learned how Azure App Configuration settings work, let’s create configuration keys in the
    
    
     
      Azure portal:
     
    
   </p>
   <ol>
    <li>
     
      In the Azure portal (
     
     <a href="https://portal.azure.com">
      
       https://portal.azure.com
      
     </a>
     
      ), in the App Configuration resource created previously, select the
     
     <strong class="bold">
      
       Configuration explorer
      
     </strong>
     
      option, as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .7
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration" src="img/B21788_09_07.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.7 – Accessing the Configuration explorer option of Azure App Configuration
    
   </p>
   <ol>
    <li value="2">
     
      Then, click on the
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Key-value
      
     </strong>
     
      option, as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .8
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 9.8 – Adding a new configuration on Azure App Configuration" src="img/B21788_09_08.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.8 – Adding a new configuration on Azure App Configuration
    
   </p>
   <p class="list-inset">
    
     A form will be displayed where we will enter the
    
    
     
      following parameters:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Key
       
      </strong>
     
     
      
       :
      
     
     
      <strong class="source-inline">
       
        DynamicConfiguration:Sentinel
       
      </strong>
     
    </li>
    <li>
     
      <strong class="bold">
       
        Value
       
      </strong>
     
     
      
       :
      
     
     
      <strong class="source-inline">
       
        1
       
      </strong>
     
    </li>
   </ul>
   <ol>
    <li value="3">
     
      Leave the rest
     
     <a id="_idIndexMarker766">
     </a>
     
      of the parameters at
     
     
      
       their defaults.
      
     
    </li>
    <li>
     
      
       Click
      
     
     
      <strong class="bold">
       
        Apply
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Repeat
     
     <em class="italic">
      
       step 2
      
     </em>
     
      and add another key with the
     
     
      
       following configuration:
      
     
     <ul>
      <li>
       
        <strong class="bold">
         
          Key
         
        </strong>
       
       
        
         :
        
       
       
        <strong class="source-inline">
         
          DynamicConfiguration:GlobalOptions:Title
         
        </strong>
       
      </li>
      <li>
       <strong class="bold">
        
         Value
        
       </strong>
       
        :
       
       <strong class="source-inline">
        
         ASP.NET
        
       </strong>
       
        <strong class="source-inline">
         
          Core 9
         
        </strong>
       
      </li>
     </ul>
     <p class="list-inset">
      
       Note the
      
      <strong class="source-inline">
       
        DynamicConfiguration:GlobalOptions:Title
       
      </strong>
      
       key.
      
      
       This key represents a hierarchy following the pattern
      
      <strong class="source-inline">
       
        &lt;Group Settings&gt;:&lt;Section&gt;
       
      </strong>
      
       .
      
      
       In this case, it is the name of the previously created settings class, configuration, or desired property of the configuration
      
      
       
        class format.
       
      
     </p>
    </li>
   </ol>
   <p class="callout-heading">
    
     Labels in Azure App Configuration
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     parameter in Azure Application Configuration is used to differentiate configuration settings based on different contexts
    
    
     
      or environments.
     
    
   </p>
   <p class="callout">
    
     Labels allow you to separate configurations for different environments (for example, development,
    
    
     
      staging, production).
     
    
   </p>
   <p class="callout">
    
     This approach brings benefits, such as
    
    
     
      the following:
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      • Flexibility
     
    </strong>
    
     : Easily switch between different sets
    
    
     
      of configurations
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      • Isolation
     
    </strong>
    
     : Keep settings for different environments or scenarios isolated
    
    
     
      and organized
     
    
   </p>
   <p class="callout">
    <strong class="bold">
     
      • Testing
     
    </strong>
    
     : Safely test new configurations without affecting
    
    
     
      other environments
     
    
   </p>
   <p class="callout">
    
     Settings that do not have a
    
    <strong class="source-inline">
     
      Label
     
    </strong>
    
     parameter will be treated as
    
    
     
      default settings.
     
    
   </p>
   <p class="callout">
    
     To learn more about
    
    <a id="_idIndexMarker767">
    </a>
    
     labels, visit the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core">
     
      
       https://learn.microsoft.com/en-us/azure/azure-app-configuration/howto-labels-aspnet-core
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that the
    
    <a id="_idIndexMarker768">
    </a>
    
     application is integrated with Azure App Configuration, open the terminal and access the application directory.
    
    
     Then, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet run</pre>
   <p>
    
     Now, access the application URL available on your terminal via the following URL:
    
    <strong class="source-inline">
     
      http://localhost:&lt;port&gt;
     
    </strong>
    
     .
    
    
     In the example shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .9
     
    </em>
    
     , the URL is
    
    <strong class="source-inline">
     
      http://localhost:5295
     
    </strong>
    
     .
    
    
     We can also see in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .9
     
    </em>
    
     a welcome message with the value defined in the App
    
    
     
      Configuration resource:
     
    
   </p>
   <div><div><img alt="Figure 9.9 – Application getting settings from Azure App Configuration" src="img/B21788_09_09.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.9 – Application getting settings from Azure App Configuration
    
   </p>
   <p>
    
     As we can see, the configurations are being loaded directly from the
    
    
     
      Azure resource.
     
    
   </p>
   <p>
    
     With the application still running, access the Azure portal (
    
    <a href="http://portal.azure.com">
     
      http://portal.azure.com
     
    </a>
    
     ) and the Azure App
    
    
     
      Configuration resource.
     
    
   </p>
   <p>
    
     Then, access
    
    <a id="_idIndexMarker769">
    </a>
    
     the
    
    <strong class="bold">
     
      Configuration explorer
     
    </strong>
    
     option.
    
    
     We will change
    
    
     
      the settings.
     
    
   </p>
   <p>
    
     To do this, in the settings display grid, click on the three dots (
    
    <strong class="bold">
     
      ...
     
    </strong>
    
     ) as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     and
    
    
     
      click
     
    
    
     <strong class="bold">
      
       Edit
      
     </strong>
    
    
     
      :
     
    
   </p>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 9.10 – Editing configurations" src="img/B21788_09_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.10 – Editing configurations
    
   </p>
   <p>
    
     Provide the
    
    
     
      following settings:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       DynamicConfiguration:GlobalOptions:Title
      
     </strong>
     
      :
     
     <strong class="bold">
      
       ASP.NET Core 9 With
      
     </strong>
     
      <strong class="bold">
       
        Dynamic config
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        DynamicConfiguration:Sentinel
       
      </strong>
     
     
      
       :
      
     
     
      <strong class="bold">
       
        2
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     Wait a few seconds, access the application again, and refresh the page.
    
    
     The page body message was changed, as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .11
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.11 – Application obtaining configurations dynamically" src="img/B21788_09_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.11 – Application obtaining configurations dynamically
    
   </p>
   <p>
    
     Despite being a simple implementation example, using a config server is a good practice in cloud-native applications, as suggested in The Twelve-Factor App methodology
    
    <a id="_idIndexMarker770">
    </a>
    
     (
    
    <a href="https://12factor.net">
     
      https://12factor.net
     
    </a>
    
     ), and ASP.NET Core 9 provides several extensibility mechanisms, such as the one we use when integrating with Azure’s App
    
    
     
      Configuration feature.
     
    
   </p>
   <p>
    
     This approach in large application scenarios in production environments can bring several benefits by offering an immediate response to
    
    
     
      certain changes.
     
    
   </p>
   <p class="callout-heading">
    
     The Twelve-Factor App methodology
    
   </p>
   <p class="callout">
    
     The Twelve-Factor App methodology is a methodology used as a reference in creating
    
    <strong class="bold">
     
      SaaS
     
    </strong>
    
     (
    
    <strong class="bold">
     
      Software as a Service
     
    </strong>
    
     ) application
    
    <a id="_idIndexMarker771">
    </a>
    
     and has 12 factors, technology agnostic, that offer best practices for developing cloud-native solutions.
    
    
     One of the factors is related to configuration management, related to what we learned in this chapter, and you can learn more about this factor through the following
    
    
     
      URL:
     
    
    <a href="https://12factor.net/config">
     
      
       https://12factor.net/config
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Managing configurations on a server such as Azure App Configuration brings several benefits, the most important being security.
    
    
     With the easy integration with ASP.NET Core 9 applications, we can allow our applications to change settings dynamically and even segregate them by environment.
    
    
     This approach is very important in a CI/CD process.
    
    
     We will talk more about CI/CD in
    
    <a href="B21788_10.xhtml#_idTextAnchor162">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Another approach that can be used to bring greater capacity to our applications in addition to improving user experience, among other benefits, is real-time behavior management, which we will learn about in the
    
    
     
      next section.
     
    
   </p>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor159">
    </a>
    
     Connecting an ASP.NET Core 9 application to Azure App Configuration
    
   </h2>
   <p>
    
     Surely at some point, you
    
    <a id="_idIndexMarker772">
    </a>
    
     have already used a mechanism that dynamically changes the behavior of an application.
    
    
     Imagine a scenario where you install, for example, a messaging app that allows users to send videos, photos,
    
    
     
      and audio.
     
    
   </p>
   <p>
    
     These media are automatically downloaded when you receive messages, which requires data consumption on your smartphone.
    
    
     In general, the first action we would take would be to disable the automatic media download option.
    
    
     This setting is found in a settings menu; however, this setting completely changes, in real time, the way the application
    
    
     
      will behave.
     
    
   </p>
   <p>
    
     The aforementioned example is a simple concept of changing the behavior of applications in real time.
    
    
     Likewise, at some point, web applications may have their behavior dynamically managed, and their use
    
    <a id="_idIndexMarker773">
    </a>
    
     brings several benefits, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Controlled releases
      
     </strong>
     
      : Gradually release features to a subset of users to monitor performance and
     
     
      
       user feedback
      
     
    </li>
    <li>
     <strong class="bold">
      
       A/B testing
      
     </strong>
     
      : Conduct experiments by rotating features for different groups of users to determine the
     
     
      
       best approach
      
     
    </li>
    <li>
     <strong class="bold">
      
       Instant rollbacks
      
     </strong>
     
      : Quickly disable a feature if it causes problems, without redeploying
     
     
      
       the application
      
     
    </li>
   </ul>
   <p>
    
     The technique that allows changing the behavior of applications in real time is called feature toggles or
    
    
     
      feature flags
     
    
    
     
      .
     
    
   </p>
   <p>
    
     Feature toggles, also known as feature flags, are a software development technique that allows you to enable or disable features in an application at runtime without deploying new code, bringing flexibility for better risk management and improving the deployment process, enabling teams to release resources to specific users or environments, and improving overall development and
    
    
     
      operational efficiency.
     
    
   </p>
   <p>
    
     In terms of coding, a feature toggle can be represented as shown in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    
     <em class="italic">
      
       .12
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 9.12 – Representation of the feature toggle concept" src="img/B21788_09_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.12 – Representation of the feature toggle concept
    
   </p>
   <p>
    
     As we can see in
    
    
     <em class="italic">
      
       Figure 9
      
     </em>
    
    <em class="italic">
     
      .12
     
    </em>
    
     , the feature toggle is basically a decision point in the application’s source code.
    
    
     This decision point checks whether a certain value, called a toggle, is activated.
    
    
     To check
    
    <a id="_idIndexMarker774">
    </a>
    
     if a toggle is activated, we can obtain this value through a configuration file, environment variables, and even on a remote server, which is the most
    
    
     
      recommended way.
     
    
   </p>
   <p class="callout-heading">
    
     Single Responsibility Principle
    
   </p>
   <p class="callout">
    
     Implementing feature toggles in ASP.NET Core 9 should follow best practices to make your code cleaner, easier to maintain, and more scalable.
    
    
     When using feature toggles, it is bad practice to lump multiple behaviors into a single class, such as handling different features or switching between old and new logic within a service.
    
    
     This approach can lead to code that is difficult to understand and modify.
    
    
     A good practice is to follow the
    
    <strong class="bold">
     
      Single Responsibility Principle
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SRP
     
    </strong>
    
     ), which
    
    <a id="_idIndexMarker775">
    </a>
    
     means that each class should handle only one responsibility or feature.
    
    
     By keeping each class focused on one task, you reduce complexity and make your application easier to maintain
    
    
     
      and extend.
     
    
   </p>
   <p class="callout">
    
     Additionally, using factory methods with DI in ASP.NET Core 9 allows you to easily swap out different implementations based on feature toggles without breaking the SRP.
    
    
     If you need to add a new feature, you can simply create a new class for that feature, isolating the existing logic.
    
    
     To learn more about the
    
    <a id="_idIndexMarker776">
    </a>
    
     SRP, access the following
    
    
     
      URL:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility">
     
      
       https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles#single-responsibility
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     All the details
    
    <a id="_idIndexMarker777">
    </a>
    
     surrounding the use of the feature toggle technique and its respective benefits not only for development teams but also for management and complexity aspects go beyond the scope of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     We already have a basic knowledge of using this technique, and now, it’s time to use it in an ASP.NET Core
    
    
     
      9 application.
     
    
   </p>
   <h3>
    
     Managing feature toggles with Azure App Configuration
    
   </h3>
   <p>
    
     In the previous topic, we used the
    
    <a id="_idIndexMarker778">
    </a>
    
     Azure App Configuration feature for configuration management; however, this service also includes
    
    <a id="_idIndexMarker779">
    </a>
    
     feature flags, which you can use to enable or disable a feature.
    
    
     Through the UI in the Azure portal, we can create and manage the feature flags of
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     Let’s make some changes to the
    
    <strong class="source-inline">
     
      DynamicConfiguration
     
    </strong>
    
     project code, created previously, and add
    
    
     
      feature toggles:
     
    
   </p>
   <ol>
    <li>
     
      Open the terminal and go to the application directory.
     
     
      Then, run the
     
     
      
       following commands:
      
     
     <pre class="source-code">
<strong class="bold">dotnet add package Microsoft.Azure.AppConfiguration.AspNetCore</strong>
<strong class="bold">dotnet add package Microsoft.FeatureManagement.AspNetCore</strong></pre>
    </li>
    <li>
     
      These packages are necessary to incorporate the SDK for managing toggles in
     
     
      
       the application.
      
     
    </li>
    <li>
     
      Open the
     
     <a id="_idIndexMarker780">
     </a>
     
      application in
     
     <a id="_idIndexMarker781">
     </a>
     
      Visual Studio Code, then we will edit the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file, which will have the following
     
     
      
       updated code:
      
     
     <pre class="source-code">
using DynamicConfiguration.Options;
using Microsoft.Extensions.Configuration
  .AzureAppConfiguration;
<strong class="bold">using Microsoft.FeatureManagement;</strong>
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddAzureAppConfiguration();
<strong class="bold">builder.Services.AddFeatureManagement();</strong>
var connectionString = builder.Configuration
  .GetConnectionString("AppConfig");
builder.Configuration
  .AddAzureAppConfiguration(options =&gt;
{
  options.Connect(connectionString)
  .Select("DynamicConfiguration:*", LabelFilter.Null)
  .ConfigureRefresh(refreshOptions =&gt; refreshOptions
  .Register("DynamicConfiguration:Sentinel",
    refreshAll: true))
  .<strong class="bold">UseFeatureFlags(featureFlagsOptions =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    featureFlagsOptions.CacheExpirationInterval =</strong>
<strong class="bold">    TimeSpan.FromSeconds(5);</strong>
<strong class="bold">  });</strong>
});
builder.Services.Configure&lt;GlobalOptions&gt;
  (builder.Configuration.GetSection(
    "DynamicConfiguration:GlobalOptions"));
builder.Services.AddControllersWithViews();
var app = builder.Build();
if (!app.Environment.IsDevelopment())
{
  app.UseExceptionHandler("/Home/Error");
  app.UseHsts();
}
// Middleware to refresh configuration
app.UseAzureAppConfiguration();
app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapControllerRoute(
name: "default",
pattern: "{controller=Home}/{action=Index}/{id?}");
app.Run();</pre>
     <p class="list-inset">
      
       Basically, we
      
      <a id="_idIndexMarker782">
      </a>
      
       make three
      
      <a id="_idIndexMarker783">
      </a>
      
       changes to the
      
      
       <strong class="source-inline">
        
         Program.cs
        
       </strong>
      
      
       
        file:
       
      
     </p>
     <ul>
      <li>
       <strong class="source-inline">
        
         using Microsoft.FeatureManagement
        
       </strong>
       
        : Adding the namespaces necessary to add the SDK’s toggle
       
       
        
         management features.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         builder.Services.AddFeatureManagement()
        
       </strong>
       
        : Adding services to the
       
       
        
         application’s DIC.
        
       
      </li>
      <li>
       <strong class="source-inline">
        
         .UseFeatureFlags
        
       </strong>
       
        : We changed the connection settings with Azure App Configuration, informing us that the toggle management feature will be used.
       
       
        Additionally, a 5-second cache was defined using the
       
       
        <strong class="source-inline">
         
          featureFlagsOptions.CacheExpirationInterval
         
        </strong>
       
       
        
         standard.
        
       
      </li>
     </ul>
    </li>
   </ol>
   <p>
    
     As part of the
    
    <a id="_idIndexMarker784">
    </a>
    
     Azure App Configuration
    
    <a id="_idIndexMarker785">
    </a>
    
     SDK, we can work with toggles directly in the code of controllers or services, using the
    
    <strong class="source-inline">
     
      IFeatureManager
     
    </strong>
    
     interface, the
    
    <strong class="source-inline">
     
      FeatureGate
     
    </strong>
    
     attribute, or
    
    <a id="_idIndexMarker786">
    </a>
    
     a
    
    <strong class="bold">
     
      tag helper
     
    </strong>
    
     directly in views.
    
    
     For this example, we will use a
    
    
     
      tag helper.
     
    
   </p>
   <p class="callout-heading">
    
     Using IFeatureManagement and the FeatureGate attribute
    
   </p>
   <p class="callout">
    
     In some cases, we can analyze
    
    <a id="_idIndexMarker787">
    </a>
    
     whether a toggle is activated or not through the
    
    <strong class="source-inline">
     
      IFeatureManagement
     
    </strong>
    
     interface, which is injected into a class and provides us with methods to test the values, such as
    
    
     
      the following:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public class MyController :
     
    </strong>
    
     <strong class="source-inline">
      
       Controller
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      private readonly
     
    </strong>
    
     <strong class="source-inline">
      
       IFeatureManager _featureManager;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public
     
    </strong>
    
     <strong class="source-inline">
      
       MyController(IFeatureManager featureManager)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      _featureManager =
     
    </strong>
    
     <strong class="source-inline">
      
       featureManager;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      private async
     
    </strong>
    
     <strong class="source-inline">
      
       Task MyMethod()
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      if (await
     
    </strong>
    
     <strong class="source-inline">
      
       _featureManager
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       IsEnableAsync("FeatureToggleName"))
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       Console.WriteLine("New Approach");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       else
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       Console.WriteLine("Legacy Approach");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     In the same way, it is possible
    
    <a id="_idIndexMarker788">
    </a>
    
     to annotate an action or controller with the
    
    
     <strong class="source-inline">
      
       FeatureGate
      
     </strong>
    
    
     
      attribute:
     
    
   </p>
   <p class="callout">
    
     <strong class="source-inline">
      
       using Microsoft.FeatureManagement.Mvc;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      [
     
    </strong>
    
     <strong class="source-inline">
      
       FeatureGate("FeatureToggleName)]
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public class MyController :
     
    </strong>
    
     <strong class="source-inline">
      
       Controller
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      // ....
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     This way, it is possible to benefit from the use of toggle management with different implementations but the
    
    
     
      same concept.
     
    
   </p>
   <p>
    
     Let’s change the
    
    <a id="_idIndexMarker789">
    </a>
    
     application to use a
    
    <a id="_idIndexMarker790">
    </a>
    
     tag helper, which will use the feature toggle.
    
    
     Follow the
    
    
     
      next steps:
     
    
   </p>
   <ol>
    <li>
     
      In Visual Studio Code, edit the
     
     <strong class="source-inline">
      
       Views/_ViewImports.cshtml
      
     </strong>
     
      file and add the following code to the file, below the
     
     
      
       existing code:
      
     
     <pre class="source-code">
@addTagHelper *, Microsoft.FeatureManagement
  .AspNetCore</pre>
     <p class="list-inset">
      
       This code adds a tag helper from the Azure App
      
      
       
        Configuration SDK.
       
      
     </p>
    </li>
    <li>
     
      Then, open the
     
     <strong class="source-inline">
      
       Views/Home/Index.cstml
      
     </strong>
     
      file and use the
     
     
      
       following code:
      
     
     <pre class="source-code">
&lt;div class="text-center"&gt;
&lt;h1 class="display-4"&gt;Welcome @ViewData["Title"]&lt;/h1&gt;
&lt;p&gt;Learn about &lt;a
  href="https://learn.microsoft.com/aspnet/core"&gt;
  building Web apps with ASP.NET Core&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
<strong class="bold">&lt;feature name="NewFeature"&gt;</strong>
&lt;div style="background-color: silver;
  border: dotted 1px #000000"&gt;
&lt;h3&gt;New Feature using Toggles and
  the Azure App Configuration&lt;/h3&gt;
&lt;/div&gt;
<strong class="bold">&lt;/feature&gt;</strong></pre>
     <p class="list-inset">
      
       Note the use of the
      
      <a id="_idIndexMarker791">
      </a>
      
       feature tag, which will basically obtain information on whether a toggle is enabled.
      
      
       If yes, the new
      
      <strong class="source-inline">
       
        div
       
      </strong>
      
       tag will be displayed on
      
      
       
        the screen.
       
      
     </p>
     <p class="list-inset">
      
       Now that everything
      
      <a id="_idIndexMarker792">
      </a>
      
       is configured in the application, let’s add the feature toggle in Azure
      
      
       
        App Configuration.
       
      
     </p>
    </li>
    <li>
     
      Open the Azure portal (
     
     <a href="https://portal.azure.com">
      
       https://portal.azure.com
      
     </a>
     
      ) and access the App Configuration resource created in the
     
     
      
       previous section.
      
     
    </li>
    <li>
     
      Then, click on the
     
     <strong class="bold">
      
       Feature manager
      
     </strong>
     
      menu,
     
     <strong class="bold">
      
       Create
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Feature flag
      
     </strong>
     
      , as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .13
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.13 – Adding a new feature flag" src="img/B21788_09_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.13 – Adding a new feature flag
    
   </p>
   <ol>
    <li value="5">
     
      On the next screen, set the
     
     <strong class="bold">
      
       New feature flag
      
     </strong>
     
      field to the
     
     <strong class="source-inline">
      
       NewFeature
      
     </strong>
     
      value and leave the rest at their
     
     
      
       default values.
      
     
    </li>
    <li>
     
      Click on the
     
     
      <strong class="bold">
       
        Apply
       
      </strong>
     
     
     
     
      
       button.
      
     
     <p class="list-inset">
      
       A new feature flag will be created and disabled, as shown in
      
      
       <em class="italic">
        
         Figure 9
        
       </em>
      
      
       <em class="italic">
        
         .14
        
       </em>
      
      
       
        :
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 9.14 – Application using a disabled feature flag" src="img/B21788_09_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.14 – Application using a disabled feature flag
    
   </p>
   <p class="list-inset">
    
     We did this
    
    <a id="_idIndexMarker793">
    </a>
    
     configuration on
    
    <a id="_idIndexMarker794">
    </a>
    
     purpose.
    
    
     Now, run the application again using the
    
    <strong class="source-inline">
     
      dotnet run
     
    </strong>
    
     command, executed through the terminal in the application directory and you’ll see there is no changes on the application.
    
    
     The reason the new
    
    <strong class="source-inline">
     
      Div
     
    </strong>
    
     tag was not displayed is that we created the toggle as
    
    
     <strong class="source-inline">
      
       Enabled= false
      
     </strong>
    
    
     
      .
     
    
   </p>
   <ol>
    <li value="7">
     
      Keep the application running, access the Azure portal again, and enable the toggle by clicking on the
     
     <strong class="bold">
      
       Enabled
      
     </strong>
     
      column in the grid, as shown in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     
      <em class="italic">
       
        .15
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <p class="IMG---Figure">
   </p>
   <div><div><img alt="Figure 9.15 – Enabling the feature flag" src="img/B21788_09_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.15 – Enabling the feature flag
    
   </p>
   <ol>
    <li value="8">
     
      Access the application again, and we can see in
     
     
      <em class="italic">
       
        Figure 9
       
      </em>
     
     <em class="italic">
      
       .16
      
     </em>
     
      that a new HTML element has been added to
     
     
      
       the page:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 9.16 – Application behavior changed at runtime" src="img/B21788_09_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 9.16 – Application behavior changed at runtime
    
   </p>
   <p>
    
     By understanding and implementing dynamic configurations and feature toggles, we can create robust, flexible, and responsive ASP.NET Core
    
    
     
      9 applications.
     
    
   </p>
   <p>
    
     In this chapter, we have used Azure App Configuration as a feature flag manager.
    
    
     However, ASP.NET Core 9 has integrations with several other types of toggle management servers using the same techniques learned in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     The combination of configuration management techniques and feature flags is very powerful for different application contexts, mainly interacting with cloud resources in a scenario of continuous delivery of value through
    
    
     
      automated mechanisms.
     
    
   </p>
   <p>
    
     We will discuss how to host our applications in cloud environments using automated processes in the
    
    
     
      next chapter.
     
    
   </p>
   <h1 id="_idParaDest-159">
    <a id="_idTextAnchor160">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we delved into good practices for managing application configurations by understanding the concepts and abstractions of the IConfiguration interface.
    
    
     We also worked with concepts related to the ASP.NET Core 9 configuration provider, along with the implementation of the Options pattern.
    
    
     Finally, we worked with changing application configurations and behavior in real time using Microsoft Azure’s Azure App Configurator to implement the concept of feature flags or feature toggles.
    
    
     Working with cloud resources is an important premise for Software Engineers and in the next chapter, we will explore how to deploy applications in a
    
    
     
      Cloud environment.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-160" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor161">
    </a>
    
     Part 4: Hosting, Deploying, and Preparing to the Cloud
    
   </h1>
   <p>
    
     Modern applications are dynamic, and as software engineers, our work doesn’t end after synchronizing the latest code developed.
    
    
     In a scenario where the market is constantly changing, it is necessary for applications to be dynamic enough to meet constant market demands.
    
    
     Therefore, development teams must adapt to the new topics surrounding the modern development model.
    
    
     ASP.NET Core 9 is prepared to provide high-quality solutions, suitable for cloud environments.
    
    
     In this part, we will learn about aspects involving the continuous delivery of solutions through the understanding and implementation of application publishing flows in a cloud environment with the support of automated pipelines such as
    
    <strong class="bold">
     
      Continuous Integration
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Continuous Delivery
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CD
     
    </strong>
    
     ), processes associated with the DevOps culture.
    
    
     We will understand what a cloud-native mindset is and how to direct our solutions to a constantly
    
    
     
      changing market.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B21788_10.xhtml#_idTextAnchor162">
      <em class="italic">
       
        Chapter 10
       
      </em>
     </a>
     <em class="italic">
      
       , Deploying and Hosting Applications
      
     </em>
    </li>
    <li>
     <a href="B21788_11.xhtml#_idTextAnchor183">
      <em class="italic">
       
        Chapter 11
       
      </em>
     </a>
     <em class="italic">
      
       , Cloud-Native Development with
      
     </em>
     <em class="italic">
      
       ASP.NET Core 9
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>