- en: '*Chapter 6*: The .NET Collections'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are an integral part of .NET. There are different ways to use these
    collections. Microsoft .NET makes heavy use of arrays and collections when dealing
    with things such as datasets, arrays, lists, dictionaries, stacks, and queues.
    You will be hard-pressed to write a C# program without having to use the Collections
    Framework. The different ways of using the collections and arrays differ in terms
    of their performance degradation and performance improvement. Therefore, understanding
    when to use arrays and when to use collections will form an important aspect of
    your C# and .NET programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to improve the performance of your collection
    operations. By using `BenchmarkDotNet` with different versions of the code, you
    will be able to see the differences in performance and be in a position to choose
    the best method that suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections`, `System.Collections.Generic`, `System.Collections.Concurrent`,
    and `System.Collections.Specialized` namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable` and `IQueryable`. This section will show you how to develop our
    sample database with sample data that will be used later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deciding between interfaces and concrete classes**: In this section, you
    will benchmark the performance between using classes and interfaces. Then, you
    will be able to decide on the method that best suits your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deciding between using arrays or collections**: There are strengths and weaknesses
    between using arrays and collections. In this section, you will benchmark the
    performance of arrays and collections and decide which to use based on your performance
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessing objects using indexers**: In this section, we will discuss accessing
    objects in the same way we would access items in an array by using indexers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparing IEnumerable and IEnumerator**: In this section, we will benchmark
    iterations using both IEnumerable and IEnumerator. You will see that there is
    a definite performance difference between these ways of enumerating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database query performance**: In this section, we will query a database using
    five different methods, benchmarking their performance to see which method produces
    the fastest performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield` keyword and how it relates to the performance of your applications,
    especially when it comes to iterating through collections and arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning the difference between concurrency and parallelism**: In this section,
    you will understand the difference between concurrency and parallelism, and learn
    when to use one over the other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning the difference between Equals() and ==**: In this section, you will
    understand the differences between the different equality operators, and learn
    when to use one over the other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Studying LINQ performance**: LINQ is a C# query language that is heavily
    utilized when it comes to processing collections, but it can be slow or fast,
    depending on the way you code your queries. In this section, you will learn how
    to benchmark different ways of performing the same types of queries. In doing
    so, you will see the difference in performance between the different ways of writing
    the same queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the different collections available and their uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose between using interfaces and collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the trade-offs between arrays and collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write indexers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose the best form of iteration for your particular needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `yield` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know which equality operator to use for different types of equality checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve LINQ query performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need access to the following tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server (any version) Express or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server Management Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH06)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different collection offerings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is a group of records that can be treated as one logical unit.
    Examples of logical record groups include people, countries, products, ingredients,
    books, authors, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main types of collections, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index-based** collections, such as an array or list. Index-based collections
    contain an internal index. The index can be either numeric or string-based. An
    index-based collection is more commonly accessed using a numerical index. Numerical
    indexes are zero-based. This means that a collection''s index will start at zero
    for the first record and increase in value by the order of one for each subsequent
    record. Collections that can be accessed using numerical indexes include arrays
    and lists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hashtable` and `SortedList` use a key to look up the value stored in a collection.
    So, for example, if you have a collection of products, you can access the product
    you need by using the product code that was assigned as the key when the product
    was added to the key/value pair collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritized** collections, such as a stack or queue. Prioritized collections
    allow you to store and extract records in a particular sequence. A queue uses
    the **First In First First Out** (**FIFO**) sequence, while a stack uses the **Last
    In First Out** (**LIFO**) sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CollectionsUtil` class, which creates collections that ignore the case in
    strings, and the `ListDictionary` class, which is recommended for collections
    that contain less than 10 items. It implements `IDictionary` using a singly linked
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .NET Collections Framework consists of the legacy `System.Collections` namespaces,
    as well as the newer `System.Collections.Generic`, `System.Collections.Concurrent`,
    and `System.Collections.Specialized` namespaces. Before we delve into the performance
    of collections, it is a good idea to reacquaint ourselves with the different collections
    that are available in each of the aforementioned namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Collections namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `System.Collections` namespace contains various classes, structures, and
    interfaces. In this section, we will briefly cover what is available. The collections
    in this namespace are not thread-safe. If you require thread-safe collections,
    it would be better to use the collections in the `System.Collections.Concurrent`
    namespace instead, as advised by Microsoft!
  prefs: []
  type: TYPE_NORMAL
- en: The `ICollection` interface defines the size, enumerators, and synchronization
    methods for all non-generic collections. To compare two objects, you can implement
    the `IComparer` interface. You can represent non-generic key/value pair collections
    using `Idictionary`. To enumerate a non-generic dictionary, you can use the `IDictionaryEnumerator`
    interface. Simple iteration over non-generic collections is provided by the `IEnumerator`
    interface, while equality between objects is implemented via the `IEqualityComparer`
    interface. The `IList` interface is used to implement non-generic collections
    of objects that can be individually accessed using the index. Structural comparison
    of objects and structural equality comparison of objects is implemented using
    the `IStructuralComparable` and `IStructuralEquatable` interfaces, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `ArrayList` class implements the `IList` interface using a dynamic array
    that can grow and shrink in size as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On (`0`) and off (`1`), which are represented by the Boolean values `false`
    and `true`, respectively, are managed by the `BitArray` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare two objects while ignoring string casing, you can use the `CaseInsensitiveComparer`
    class. Use `CaseInsensitiveHashCodeProvider` to generate hash codes using algorithms
    that ignore string casing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're building a strongly typed collection, inherit from the `CollectionBase`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Comparer` class is used to compare two objects for equivalence with case-sensitive
    string comparison.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `DictionaryBase` as the abstract class when developing strongly typed collections
    of key/value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of key/value pairs organized by key-based hash codes is represented
    by the `Hashtable` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Queue` class provides a collection with FIFO access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ReadOnlyCollectionBase` abstract class is used as the base class for strongly
    typed non-generic, read-only collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `SortedList` class to hold a collection of key/value pairs that are
    sorted by the keys and are accessible by key or index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Stack` class if you need LIFO access for your collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare two collection objects structurally, you can use the `StructuralComparisons`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DictionaryEntry` structure defines a dictionary key/value pair that can
    be set or retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`IHashCodeProvider` has now been marked obsolete and is no longer recommended
    by Microsoft for new development. Microsoft recommends that you use the `IEqualityComparer`
    and `IEqualityComparer<T>` interfaces instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We now know what is available in the `System.Collections` namespace. Now, let's
    look at what's available in the `System.Collections.Generic` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Collections.Generic namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The classes and interfaces that are available in the `System.Collections.Generic`
    namespace provide collections that are strongly typed and that perform better
    than the classes within the `System.Collections` namespace. This namespace contains
    many classes, structs, and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `CollectionExtensions` class provides extension methods for generic collections.
    To compare two objects, you can use the `Comparer<T>` class, which implements
    the `IComparer<T>` interface. The `IComparer<T>` interface defines the method
    types to implement to compare two objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `IDictionary<TKey, TValue>` interface provides methods for implementing
    generic dictionaries. For a dictionary to be read-only, it must implement the
    `IReadOnlyDictionary<TKey, TValue>` interface. A collection of keys and values
    is represented by the `Dictionary<TKey, TValue>` class. `Dictionary<TKey, TValue>.KeyCollection`
    cannot be inherited and represents the collection of keys within a `Dictionary<TKey,
    TValue>` collection. Finally, `Dictionary<TKey, TValue>.ValueCollection` cannot
    be inherited and represents the collection of values within a `Dictionary<TKey,
    TValue>` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `IEqualityComparer<T>` interface defines methods that you can use to compare
    objects for equality. A base class for implementations of the `IEqualityComparer<T>`
    interface is provided called `EqualityComparer<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`HashSet<T>` represents a set of values. When a key that''s been used to access
    a collection cannot be found within the collection that''s being searched, then
    a `KeyNotFoundException` is raised. A key/value pair instance is generated using
    the `KeyValuePair` class. For a doubly linked list, use the `LinkedList<T>` class.
    The non-inheritable `LinkedListNode<T>` class represents a node in a collection
    of the `LinkedList<T>` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IList<T>` represents a collection of objects for implementing lists that can
    be accessed by index. Read-only lists implement the `IReadOnlyList<T>` interface.
    When you need a collection that is strongly typed that enables searching, sorting,
    and manipulating lists, then use the `List<T>` class. For FIFO collections, use
    the `Queue<T>` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReferenceEqualityComparere` is an `IEqualityComparer<T>` that uses reference
    equality by calling `ReferenceEquals(Object, Object)` instead of using value equality
    by calling `Equals(Object)` when comparing two object instances.'
  prefs: []
  type: TYPE_NORMAL
- en: A key/value pair collection that's sorted on the key is represented by the `SortedDictionary<TKey,
    TValue>` class. This type of collection is represented by `SortedDictionary<TKey,
    TValue>.KeyCollection`, which cannot be inherited. The values that have been collected
    are represented by `SortedDictionary<TKey, TValue>.ValueCollection`, which cannot
    be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: The `SortedList<TKey, TValue>` class represents a collection of key/value pairs
    that are sorted by key based on the associated `IComparer<T>` implementation.
    A collection of objects that has been maintained in sorted order is represented
    by the `SortedSet<T>` class. The `Stack<T>` class provides LIFO manipulation for
    instances of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: There are several structures available for the various generic collection classes
    that allow you to enumerate the elements in the collection. These structures are
    called enumerators.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronously enumerating over values of a specific type can be done by implementing
    the `IAsyncEnumerable<T>` interface. `IAsyncEnumerator<T>` provides the necessary
    support to iterate over a generic collection. `ICollection<T>` defines the methods
    needed to manipulate generic collections. Strongly typed collections that are
    read-only implement the `IReadOnlyCollection<T>` interface. Sets implement the
    `ISet<T>` interface, while read-only sets implement the `IReadOnlySet<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at what the `System.Collections.Generic` namespace has
    to offer, let's turn our attention to the `System.Collections.Concurrent` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Collections.Concurrent namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The collections in the `System.Collections.Concurrent` namespace are thread-safe.
    Whenever multiple threads are concurrently accessing a collection, use the collections
    in this namespace over the collections in the `System.Collections` and `System.Collections.Generic`
    namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods and explicit interface implementations of these collections
    are not guaranteed to be thread-safe. To ensure thread safety, synchronization
    may be required in these instances.
  prefs: []
  type: TYPE_NORMAL
- en: '`IProducerConsumerCollection<T>` defines methods that form the basis of thread-safe
    collection manipulation in producer/consumer usage (also known as publisher/subscriber
    usage). Higher-level abstractions such as the `BlockingCollection<T>` class can
    use this collection as their underlying storage mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: The `BlockingCollection<T>` class provides blocking and bounding capabilities
    to thread-safe collections that implement the `IProducerConsumerCollection<T>`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Options to control partitioner buffering behavior are specified by the `EnumerablePartitionerOptions`
    enum.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays, lists, and enumerable partitioning strategies are provided by the `Partitioner`
    class. The `Partitioner<Tsource>` class provides a particular manner of splitting
    a data source into multiple partitions, while `OrderablePartioner<Tsource>` splits
    an orderable data source into multiple partitions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Concurrent<T>` class contains a thread-safe unordered list of objects.
    Thread-safe FIFO collections use the `ConcurrentQueue<T>` class, while thread-safe
    LIFO collections use the `ConcurrentStack<T>` class. To concurrently access key/value
    pairs in a thread-safe manner, use the `ConcurrentDictionary<Tkey, Tvalue>` class.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've covered the `System.Collections.Concurrent` namespace. Now,
    let's look at the `System.Collections.Specialized` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The System.Collections.Specialized namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `System.Collections.Specialized` namespace contains specialized and strongly
    typed collections. Let's see what it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: The `CollectionChangedEventManager` class provides a `WeakEventManager` implementation.
    By using the `WeakEventListener` pattern, you can attach listeners for the collection-changed
    event.
  prefs: []
  type: TYPE_NORMAL
- en: To build a collection of strings that ignores the string casing, you can use
    the `CollectionUtils` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `HybrdDictionary` class changes its behavior when the collection is small,
    and when the collection grows in size. It does this by implementing `IDictionary`
    using a `ListDictionary` when the collection is small; it uses a `Hashtable` when
    the collection grows in size and becomes large.
  prefs: []
  type: TYPE_NORMAL
- en: For fewer than 10 items, you can use `ListDictionary`, which implements `IDictionary`
    by using a singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: To hold a collection of the string keys of a collection, use `NameObjectCollectionBase.KeysCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to provide data for the `CollectionChanged` event, use the `NotifyCollectionChangedEventArgs`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: When you have an ordered collection of key/value pairs that you need to be accessible
    via either the key or the index, use `OrderedDictionary`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `StringCollection` class to hold a collection of strings, and
    you can use the `StringEnumerator` class to perform a simple iteration of the
    `StringCollection` class.
  prefs: []
  type: TYPE_NORMAL
- en: To get a hash table of keys and strongly typed string values, use the `StringDictionary`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: To store a Boolean value or small integer in 32 bits of memory, you can use
    the `BitVector32` structure. You can use `BitVector32.Section` of the vector to
    store an integer number.
  prefs: []
  type: TYPE_NORMAL
- en: Indexed collections of key/value pairs are represented by the `IOrderedDictionary`
    interface. The `INotifyCollectionChanged` interface is used to notify listeners
    of dynamic changes to a collection, such as when items are added, modified, or
    removed. The `NotifyCollectionChangedAction` enum describes the action that resulted
    in the `CollectionChanged` event being fired.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at custom collections and write one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create custom collections, you must inherit from `CollectionBase`. The `CollectionBase`
    class has a read-only `ArrayList` property called `InnerList`, and it implements
    the `IList`, `ICollection`, and `IEnumerable` interfaces. Then, you can add your
    own `Add`, `Remove`, `Clear`, and `Count` methods. We''ll do this in our project.
    We will create a very simple custom collection that inherits from `CollectionBase`
    so that you can see how easy it is to create custom collections. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class under the `CustomCollections` folder called `CustomCollections`
    that inherits from `CollectionBase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `Add(object item)` method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method adds an item to `InnerList`, which we have inherited from the `CollectionBase`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Remove(object item)` method to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method removes an item from the inherited `InnerList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Clear()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method clears all the items from `InnerList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns the count of the number of items in `InnerList`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, creating custom collections does not have to be hard. Our implementation
    is very simple and basic. However, such a class can be made to hold specific types
    instead of the generic object type. You could also make your class generic so
    that it accepts classes that implement a specific interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a detailed article by Microsoft on implementing custom collections
    by implementing `ICollection`: [https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.](https://docs.microsoft.com/troubleshoot/dotnet/csharp/implement-custom-collection.)'
  prefs: []
  type: TYPE_NORMAL
- en: As you read through this chapter, you will see different aspects of collections.
    You will also measure their performance. This way, as you create custom collections,
    you can choose the most performant way of doing things for the tasks at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've briefly covered the different collection offerings in the .NET
    Collections Framework, let's look at what Big O notation is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Big O notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Big O notation is used to determine algorithmic efficiency. It determines how
    time scales concerning input. Constant time equates to a Big O notation value
    of O(1). Data operations that scale linearly over time, depending on the size
    of the operation, have a Big O notation value of (*N*), where *N* equals the amount
    of data being processed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you were iterating over several elements in an array or collection,
    you would use O(*N*), which is a linear time, where *N* is the size of the array
    or collection. If an iteration contains pairs such as *x* and *y*, where you iterate
    over *x* in the iteration and then *y* in the iteration, then your Big O notation
    would be O(*N*2). Another scenario would be identifying the amount of time it
    takes to harvest a square plot of land. This could be written as O(*a*), where
    *a* is the area of land. Alternatively, you could write the Big O notation as
    O(*s*2), where *s* is the length of one size.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some rules to consider when using Big O notation:'
  prefs: []
  type: TYPE_NORMAL
- en: Different steps in your algorithm are added together. So, if step 1 takes O(*a*)
    time, and step 2 takes O(*b*) time, then your Big O notation for the algorithm
    will be O(*a+b*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop constants. For example, if you have two operations that are both constants
    in your algorithm, you do not write O(*2N*). The notation remains O(*N*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have different inputs that are different variables, such as collection
    a and collection b, then your Big O notation would be O(*a*b*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop non-dominant terms. So, O(*n*2) is equivalent to O(*n + n*2), which is
    equivalent to (*n*2*+n*2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand what Big O notation is and the various collections available
    to us, let's look at choosing the right collections for our work items.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to performance when working with multiple items of data in memory is
    to choose the correct storage mechanism that offers the fastest processing time
    for your requirements. Here''s the list of the different types of collections
    and their strengths to help you choose the right collections for the right tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Dictionary` is an unordered collection with contiguous storage that is directly
    accessible via a key. A dictionary's lookup efficiency using a key is O(1) and
    its manipulation efficiency is also O(1). Dictionaries are best used for high-performance
    lookups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `HashSet` is unordered, has contiguous storage, and is directly accessible
    via a key. It has a lookup efficiency using a key of O(1), and a manipulation
    efficiency of O(1). `HashSet` is a unique unordered collection, called `Dictionary`,
    except the key and the value are the same object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LinkedList` lets the user have complete control over how it is ordered, does
    not have contiguous storage, and is not directly accessible. It has a lookup efficiency
    value of O(*n*), and a manipulation efficiency of O(1). It's best to use lists
    when you need to insert or remove items and no direct access is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `List` lets the user have complete control over how it is ordered, has contiguous
    storage, and is directly accessible via an index. It has a lookup efficiency using
    an index of O(1), and a lookup efficiency using a value of O(*n*). Its manipulation
    efficiency is O(*n*). It is best to use this list when direct access is required,
    the list is small, and there is no sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Queue` is ordered according to FIFO, has contiguous storage, and only has
    direct access from the front of the queue. It has a lookup efficiency at the front
    of the queue of O(1), and a manipulation index of O(1). It is essentially the
    same as `List<T>`, except it is only processed using FIFO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SortedDictionary` is ordered, does not have contiguous storage, and can be
    directly accessed using a key. It has a lookup efficiency using the key of O(*log
    n*) with a manipulation efficiency of O(*log n*). This collection makes a trade-off
    between speed and ordering and uses a binary search tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SortedList` is ordered, has contiguous storage, and is directly accessible
    via a key. It has a lookup efficiency using the key of O(*log n*) and a manipulation
    efficiency of (O(*n*). The tree is implemented as an array, making lookups faster
    on preloaded data, but slower on loads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SortedSet` is ordered, does not have contiguous storage, and is directly
    accessible via a key. It has a lookup efficiency using a key of O(*log n*), and
    a manipulation efficiency of O(*log n*). It's a unique sorted collection, similar
    to a `SortedDictionary`, except the key and value are the same object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Stack` is ordered according to LIFO, has contiguous storage, and can only
    be directly accessed from the top of the stack. It has a lookup efficiency of
    the top item of O(1) and a manipulation efficiency of O(1)*. It is essentially
    the same as `List<T>`, except it is only processed using LIFO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For mission-critical code, it is advised that you avoid using classes in the
    `System.Collection` namespace. Instead, you should be using the classes from the
    `System.Collections.Generic` namespace. Although this may sound like tried and
    tested advice, you are advised to run benchmark tests to see which method is best
    for your particular scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have been introduced to arrays and collections, we will set up
    our sample database before we continue looking at collections from a performance
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our sample database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be demonstrating the difference between how different
    collection interfaces handle data. For our demonstrations, we require access to
    database data. To do so, we will create a database, add a table to it, and populate
    it with data. We will use SQL Server for our database engine and SQL Server Management
    Studio to develop our sample database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our database, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **SQL Server Management Studio** and connect to your database engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the **Databases** folder in **Object Explorer**, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – SQL Server Management Studio – Object Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – SQL Server Management Studio – Object Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **New Database** from the context menu. This will display the **New
    Database** dialog, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – SQL Server Management Studio – the New Database dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – SQL Server Management Studio – the New Database dialog
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered `SampleData` under **Database name**, click on the **OK**
    button to create the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the database by expanding the `Products`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Table 6.1 – The Products table''s design'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 – The Products table's design
  prefs: []
  type: TYPE_NORMAL
- en: '**Save** the table, and then expand the **Tables** folder. Right-click on the
    **Product** table and select **Edit Top n records**, where *n* will be the number
    of configured records to edit. This is 200 by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the data shown in the following table to the **Product** table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Table 6.2 – The Product table''s row data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_6.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.2 – The Product table's row data
  prefs: []
  type: TYPE_NORMAL
- en: We now have a database with a single table filled with data that we will later
    use in this chapter. Now, let's understand collections from a performance perspective.
    Let's start by looking at how we decide between using arrays or collections.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between interfaces and concrete classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show that declaring a collection using an interface
    declaration rather than a concrete class declaration provides better time-based
    performance. We will accomplish this by benchmarking the generation of collections
    using an `IList` interface, as well as by using a `List` concrete class, so that
    you can see the difference in the performance of the different approaches. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `CH06_Collections` project, add a new folder called `ConcreteVsInterface`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `ConcreteVsInterface` folder, add the `ITax` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This interface defines a contract that various concrete tax classes will have
    to adhere to. It enforces impact analysis since a change in this interface will
    be felt by all the classes that implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `BaseTax` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This abstract class implements the `ITax` interface but marks `Calculate(decimal
    amount)` as abstract so that its implementation is left up to the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `TaxRate` enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TaxRate` enum provides the different types of tax rates for UK income tax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `TaxtType` enum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TaxType` interface provides the different kinds of UK taxes. Add the `BaseRate`
    class. This class will inherit from the `BaseTax` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This constructor sets the properties contained within `BaseClass` to the values
    applicable to basic rate income tax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the `Calculate(decimal amount)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method checks if the percentage is less than one and throws an exception
    if it is not. The lower and upper amounts a person earns that are taxed are checked.
    If the amount is outside of this range, then zero is returned. The amount of tax
    on earnings is then returned and the method exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `TaxMan`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our class is now configured to perform benchmarking using `BenchmarkDotNet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BasicRateInterface()` method declares a list of `BasicRate` objects using
    the `IList` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BasicRateConcrete()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BasicRateConcrete()` method declares a list of `BasicRate` objects using
    the concrete `List` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, comment out the code in the `Main` method and add the
    following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line of code will run our benchmarks. Do a release build, and then run
    the executable from the command line. You should see the following output or similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The BenchmarkDotNet summary report showing the time difference
    between assigning IList<T> and List<T>'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – The BenchmarkDotNet summary report showing the time difference
    between assigning IList<T> and List<T>
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the report, memory utilization is the same for both the interface
    and the concrete class implementations. But the faster instantiation time is obtained
    by assigning `IList<T>` instead of `List<T>`. Although the value will not be noticeable
    to the naked eye, it will become more noticeable over some time if there are a
    large number of assignments, such as when a large data iteration is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at array and collection performance.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between using arrays or collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll discuss the pros and cons of using arrays and collections.
    We will also perform various benchmarks that measure array and collection performance.
    Armed with benchmark information, you can then make informed decisions as to whether
    arrays or collections are best suited to your specific needs. We will start by
    looking at arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downsides to using arrays are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are fixed in size, meaning that once the size of the array has been changed,
    its size cannot be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since arrays are fixed in size, they are not recommended for efficient memory
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays can only hold heterogeneous data types, and data types can be primitive
    and object types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data elements of the `object` type can hold different types of data elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays lack many useful methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits of using arrays are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays have a small memory footprint and have undergone some serious performance
    improvements in C# 9.0 and .NET 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as arrays are fast and have undergone speed improvements, they are
    recommended when performance matters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The downside to using collections is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to performance, they are not recommended over arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits of using arrays are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Collections effectively wrap arrays; `generic List<T>` is a good example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are growable, which means that we can shrink and grow our collections as
    required. Because of this, collections are recommended over arrays when it comes
    to efficient memory utilization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data elements (item data) in a collection can be homogeneous and heterogeneous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection classes have ready-made method support for most operations and can
    easily be extended. By this, we mean that arrays lack some useful methods that
    we get for free when we use collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is recommended that you do not use the collections in the `System.Collections`
    namespace. Instead, you are encouraged to use the collections in the `System.Collections.Generic`
    namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The standard collection that most programmers will be familiar with is the generic
    `List<T>` class. In this section, we will create a new project. Then, we will
    build up a `uint` array and a `List<uint>` collection and iterate through them.
    This process will be benchmarked using `BenchmarkDotNet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be benchmarking adding items, iterating through, and retrieving items
    from arrays and collections. So, let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class under the project root called `ArraysVsCollections` with the
    following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `using` statements give us what we need to work with arrays and collections
    and benchmark them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The array of `int` and the list of `int` will be used to benchmark adding, getting,
    and iterating arrays and collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `GlobalSetup()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GlobalSetup()` method is attributed to the `[GlobalSetup]` attribute. This
    informs `BenchmarkDotNet` to run this method before all other benchmark methods.
    It initializes the array and collection with a size of `1000` and adds a value
    of `i` in the current iteration to both the array and collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we will not be utilizing the `GlobalCleanup()` method, we will add
    it for completeness so that you know how to perform cleanup operations when benchmarking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GlobalCleanup()` method is where you would provide your cleanup logic if
    it were needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `ArrayAdd1000Logic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ArrayAdd1000Logic()` method declares an array of 1000 `int` values and
    later proceeds to add integer values to each element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `CollectionAdd1000Logic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CollectionAdd1000Logic ()` method declares a list of `int` elements. Then,
    it loops 1,000 times using a `for` loop and adds the current value to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ArrayIterationLogic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ArrayIterationLogic()` method declares an `int` variable and assigns it
    a value of `0`. A `for` loop is used to iterate 1,000 times and add the value
    of the array at the index position to the `res` value. Once the iteration is over,
    the `res` variable is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `CollectionIterationLogic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CollectionIterationLogic()` declares an `int` variable and assigns it a value
    of `0`. A `for` loop is used to iterate 1,000 times and add the value of the array
    at the index position to the `res` value. Once the iteration is over, the `res`
    variable is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ArrayGetElement500Logic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ArrayGetElement500Logic()` method returns the value of the array at position
    `500`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `CollectionGetElement500Logic()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CollectionGetElement500Logic()` method returns the value of the collection
    at position `500`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code in the `Main` method with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This call will run our benchmarks. Release build your code and run it from
    the console. You should see a report with similar timings to those shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The BenchmarkDotNet summary report for array and collection
    operations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – The BenchmarkDotNet summary report for array and collection operations
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the performance in terms of time, adding items to an array is faster
    than adding items to a collection. Iterating a collection is faster than iterating
    over an array and getting an item from an array using its index is faster than
    getting a collection from a collection by its index. Based on these findings,
    you need to decide what your requirements are, and then choose the best type based
    on these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at indexers.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing objects using indexers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexes enable objects in classes to be accessed in the same way you access
    items in an array. An indexer will have a modifier, a return type, the `this`
    keyword to indicate the object of the current class, and an argument list. You
    will always use the `this` keyword when creating an indexer. Indexer is the term
    given to a parameterized property. The index is created using the `get` and `set`
    accessors. You are not allowed to use the `ref` or `out` keywords to modify indexer
    parameters. A minimum of one parameter should be specified. An indexer cannot
    be static since it is an instance member. However, the indexer properties can
    be static. You would implement an indexer if you need to operate on a group of
    elements. The main difference between a property and an indexer is that you identify
    and access a property by its name. On the other hand, with an indexer, it is identified
    by its signature and accessed using indexes. Moreover, you can overload indexers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a simple indexer example. In this example, we will have a
    class that has a constructor that takes a size. This size will set the size of
    an internal array of strings. We will be able to get the index of a string in
    the array by name and get an item from the array by index using indexers. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `Indexers` and add a `using` statement to `System namespace`.
    Then, add the following array and constructor at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `_items` array will contain several strings. The size of the array is set
    by the value that's passed into the constructor that initializes the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the indexer to get a string by index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indexer uses an `int` value to get an item from the array and set the value
    of the array at the given index. Items are only set and retrieved if the index
    is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the index by passing it into the `IsValidIndex(int index)` method,
    which returns a `bool`. Let''s add the `IsValidIndex(int index)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns `true` if the index is greater than -1 and less than the
    length of the array. Otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the index that takes a `string` and returns the string''s index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indexer takes a `string`. Then, it looks up the index for the string and
    returns the index. There is no setter for this index.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, add the `IndexerExample()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method creates a new `Indexer` object with an internal array size of `1000`.
    Then, it loops 1,000 times and sets the value of each item in the array. After
    that, it prints out the value of the array at position 500 and prints out the
    value of `Item 500`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the code in the `Main` method, and then add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This statement calls the method that executes our `Indexer` method. You should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That concludes our look at indexers. As you can see, they are pretty simple.
    You can use any data item that you like for an indexer. However, it will be up
    to you to see how well such indexers perform. Now, let's look at the difference
    between the `IEnumerable` and `IEnumerator` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing IEnumerable and IEnumerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IEnumerable` and `IEnumerator` interfaces can both be used for iteration
    but in different ways. Let's understand each in brief.
  prefs: []
  type: TYPE_NORMAL
- en: 'An object of the `IEnumerable` type will know how to traverse the collection
    that it holds, regardless of what its internal structure is like. There is one
    method that makes up an enumerable: `GetEnumerator()`. It returns as an instance
    of a class that implements the `IEnumerable` interface. Iteration is normally
    carried out using a `foreach` loop. Iterations of an enumerable are carried out
    using a `foreach` loop. However, an enumerable does not remember its location
    when iterating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects of the `Ienumerator` type declare two methods: `MoveNext()` and `Reset()`.
    There is one property called `Current` that gets the current item in the list
    that''s being enumerated. The `MoveNext()` method moves to the next record in
    a collection and returns a Boolean value indicating the end of the collection.
    `Reset()` will reset the position to the first item in the collection. The `Current`
    property is called through an object that implements the `IEnumerable` interface,
    which returns the current element in the collection. An enumerator remembers its
    current location and uses a `while` loop when iterating.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see which method of enumeration is fastest. Will it be looping using an
    enumerable, or will it be looping using an iterator?
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `IEnumerableVsIEnumerable` with the following `using`
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `using` statements provide the elements we will need to build and test
    the performance between `IEnumerable` and `IEnumerator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are declaring a list of `int` values that will hold several year values.
    Our constructor then initializes the array with the years `1970` to `1979`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `IterateEnumerator1970to1975()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method iterates over the values `1970` to `1975` and prints the values
    out to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the current year is greater than `1975`, then the enumerator is passed into
    the `IterateEnumerator1976To1979(IEnumerator<int> years)` method, which we will
    add now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes in an enumerator and iterates through it. On each iteration,
    it prints the current year to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the end of the `Main` method in the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line of code calls a method that will run our example and show how an enumerator
    remembers where it is in the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `IEnumerableVsIEnumeratorExample()` method to the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method runs our code. If you do a debug build and run the code, then you
    should see the years *1970* to *1979* printed to the output window.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen an enumerator in action, we will add two methods to the
    `IEnumerableVsIEnumerator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BenchmarkIEnumerabled()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses an enumerable and a `foreach` loop to iterate through the years
    and write them to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BenchmarkIEnumerator()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses an enumerator and a `while` loop to iterate through the years
    and write them to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment out the code in the `Main` method in the `Program` class, and then
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line of code detects our benchmarks and runs them to produce a summary
    report on performance. Do a release build and run the program from the command
    prompt. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator'
  prefs: []
  type: TYPE_NORMAL
- en: is faster than IEnumerable
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – The BenchmarkDotNet summary report showing that IEnumerator is
    faster than IEnumerable
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, even though `IEnumerable` and `IEnumerator` both perform iterations
    on the same collection, they do so in different ways. And by viewing the benchmarking
    summary report, we can see that the clear winner in terms of performance is the
    `IEnumerator` interface. Now, let's look at the difference between `IEnumerable`,
    `IEnumerator`, and `IQueryable`, and the effects these differences have on performance
    when performing LINQ queries on a database.
  prefs: []
  type: TYPE_NORMAL
- en: Database query performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how `IEnumerator` is different from and performs
    faster than `IEnumerable` when iterating through an in-memory collection. Now,
    let''s query a database and iterate through the resulting collection using various
    benchmarked techniques. To do so, we''ll follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class called `IEnumeratorVsIQueryable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be connecting to a SQL Server database, and we will have information
    we need to keep secret. Our `secret.json` files do not get checked into version
    control. So, right-click on the project and select **Manage User Secrets** from
    the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dialog box will pop up, informing you that additional packages are required.
    Click on **Yes**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – A dialog box, informing you that additional packages are required
    to manage user secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – A dialog box, informing you that additional packages are required
    to manage user secrets
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will then open the `secrets.json` file in a new tab. This is where
    you will add your user secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Package Manager Console and add the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.SqlServer`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Tools`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.EnvironmentVariables`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.Configuration.UserSecrets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.Extensions.OptionsConfigurationExtensions`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These packages allow you to connect to and extract data from our SQL Server
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `secrets.json` file with the connection string to the database
    that we created at the start of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This connection string will be used to connect to our database, perform a query
    that returns some data, and allow us to iterate through that data and perform
    some operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Configuration`. In that folder, add a class called `SecretsManager`
    with an empty static constructor and the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need these `using` statements for our file I/O and system configuration,
    such as obtaining secrets from a `secrets.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line at the top of the `SecretsManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line declares our static configuration property, which is used to obtain
    the configuration data within our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code gets the environment variables for the .NET Core environment. Then,
    it gets the code to see if it is running in a software development environment.
    The configuration is built for the environment it will be running in. If we are
    in development, then we must add our `secrets` class as defined by the `T` variable.
    Switch to the `Product` class in the `Models` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `using` statement for `System.ComponentModel.DataAnnotations`. Change
    the struct to a class, and add the `[Key]` attribute to the `Id` property. We
    need these changes since we are using Entity Framework to connect to a database
    and extract data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `DatabaseSettings` class to the `Configuration` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has a single property called `ConnectionString` that will hold our
    connection string to our `SampleData` database. Notice that the name of the class
    and property match the name of the JSON section and property!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add `appsettings.json` to the root of your project with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file contains the same layout as the `secrets.json` file and the `DatabaseSettings`
    class. This file is used to store our connection string. In development, it is
    set in our `secrets` file, while in production, it is set in Azure. Now that we
    have our database configuration in place, we can add our benchmarking code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class to the root of the project called `DatabaseQueryAndIteration`
    that implements `IDisposable` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code declares our class and defines the fact that it implements `IDisposable`.
    It is also configured to be benchmarked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `IDisposable` interface in our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code disposes of our managed resources and suppresses the call to the class
    finalizer method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have everything in place to benchmark the methods in this class, access
    database resources, and clean up after ourselves. Add the following code to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The _`context` variable provides us with our database access. The `GlobalSetup()`
    method gets our connection string from our secrets file and creates a new `DatabaseContext`
    using the safely stored connection string. The `GlobalSetup()` method will run
    before our benchmarks. The `GlobalCleanup()` method calls the `Dispose(disposing)`
    method to clean up our managed resources after our benchmarks have finished running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `QueryDb()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `QueryDb()` method performs a simple LINQ query on the database by selecting
    products with an ID that's greater than `1`. Then, it iterates each product in
    the `lQueryable<Product>` list and writes the product name out to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `QueryDbAsList()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QueryDbAsList()` performs the same query as `QueryDb()`, except the processed
    type is of the `List<Product>` type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `QueryDbAsIEnumerable()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `QueryDbAsIEnumerable()` method performs the same query as `QueryDbAsList`,
    but the processed type is of the `Ienumerable<Product>` type instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `QueryDbAsIEnumerator()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QueryDbAsIEnumerator()` does the same as the previous methods but operates
    on the `IEnumerator<Product>` type and iterates using a `while` loop instead of
    a `foreach` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final method in this class is the `QueryDbAsIQueryable()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is the same as `QueryDb` but explicitly operates on the `IQueryable<Product>`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code in the `Main` method within the `Program` class with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code runs our benchmarks. Do a release build of the code and run the executable
    from the command line. You should see a summary report similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The different times and memory allocations of various database
    query types using LINQ'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – The different times and memory allocations of various database
    query types using LINQ
  prefs: []
  type: TYPE_NORMAL
- en: In terms of memory usage, the worst performer is the `QueryDb()` method, followed
    by the `QueryDbAsList()` method. `QueryDbAsIEnumerable()` and `QueryDbAsIQueryable()`
    are both slightly better than the previous two. However, the best performing method
    in terms of memory allocation out of all five methods is the `QueryDbAsIEnumerator()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Speedwise, the `QueryDb()` method was the worst again, followed by `QueryDbAsIEnumerable()`,
    then `QueryDbAsList()`, and then `QueryDbAsIQueryable()`. And again, the best
    performer in terms of speed is the `QueryDbAsIEnumerator()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the best performing method for querying and iterating
    a database in terms of both speed and memory usage is the `QueryDbAsIEnumerator()`
    method. Now, let's look at the `yield` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the yield keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `yield` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield return <expression>;`: This returns the value of the expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield break;`: This will exit from the iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using the `yield` keyword, there are some restrictions to be aware of.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use the `yield` keyword in `unsafe` blocks of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use the `ref` or `out` parameters for methods, operators, or accessors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return using the `yield` keyword in a `try-catch` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use the `yield` keyword in anonymous methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `yield` in a `try` block if the `try` block is followed by the `finally`
    block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `yield break` in a `try-catch` block but not the `finally` block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a class that shows the `yield` keyword
    in action. Then, we will benchmark two ways to return an `IEnumerable<long>` consisting
    of 1 million items, and show the vast difference in performance between them.
    Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `Yield` to the root of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class will benchmark the use of the `yield` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `YieldSample()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `YieldSample()` method will be called from our `Program` class. It will
    run all three methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Countdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method loops from `10` to `0`. Each iteration is returned using the `yield`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DoCountdown()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DoCountdown()` method prints the countdown from `10` to `0` to the console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class called `Month`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class holds the name of a month of the year and its number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `Months` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class returns a collection of `Month` objects using the `yield` keyword.
    Switch back to the `Yield` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `PrintMonthsOfYear()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method iterates through the months of the year and prints them out to the
    console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `BreakIteration()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method iterates `20` times. A check is made upon each iteration. If the
    value is less than `15`, the result is yielded and the variable is incremented.
    Otherwise, the iteration is exited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DoBreakIteration()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DoBeakIteration()` method iterates through `BreakIteraton()` and writes
    the value to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, add a method called `Yield()`, and call it from your
    `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method runs our `yield` keyword examples. Do a debug build and step through
    the code so that you can see how it behaves. You will see that each time the `yield`
    keyword is encountered, it returns to the calling method. Then, it continues the
    iteration from where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add our benchmarking to test the performance of the `yield` keyword.
    Add the `GetValues()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method creates a collection of `long` values using a generic `List`. It
    iterates 1 million items and adds them to the collection. Once complete, the collection
    is returned to the caller as an `IEnumerable<long>` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetValuesYield()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method iterates through 1 million items and returns a collection of `IEnumerable<long>`.
    The iteration uses the `yield` keyword, so each iteration is returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetValuesBenchmark()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method benchmarks the `GetValues()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetValuesYieldBenchmark()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method benchmarks the `GetValuesYield()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code in the `Main` method in the `Program` class with the following
    line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line of code runs our benchmarks. Do a release build and then run the
    executable from the command line. You should see the following summary report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits
    of using the yield keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The BenchmarkDotNet summary report showing the performance benefits
    of using the yield keyword
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the report, building a list of 1 million `long` values is
    much slower compared to using the `yield` keyword. The `yield` keyword significantly
    speeds up how collections are processed. That's a 13,102,611.27 ns / 14.50 ns
    = 903,628.26 times increase in performance! So, you can see that the use of the
    `yield` keyword is very beneficial to the performance of your computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the difference between concurrency and
    parallelism and the effects they have on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the difference between concurrency and parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency and parallelism are often mistaken for the same thing, but they
    are different. Concurrency does many tasks at the same time using multi-threading.
    Multi-threading allots time to various threads based on time/context switching.
    This presents the illusion that the computer is doing multiple things at the same
    time. But it is, in reality, only doing one thing. Parallelism, on the other hand,
    does many things all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is used to manage multiple computations simultaneously. It accomplishes
    this using interleaving operations. The benefit of concurrency is that it increases
    the amount of work that can be completed over time. It uses context switching
    to perform interleaving operations. Concurrency can work with a single processor.
    You are already aware of concurrency at work, as you will have had multiple applications
    running at the same time. All these programs are making use of concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The main usage of concurrency is to have usable applications that are non-blocking.
    For example, if you have an application that performs a long-running operation,
    this operation can be run on a background thread to allow the user to still use
    the application and get work done. So, concurrency is not necessarily about performance
    – it is more about not blocking your users from being able to do what they intend
    with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelism performs multiple computations at the same time in parallel to each
    other. To accomplish parallelism, multiple processors are required. The benefit
    of using parallelism is increased computational processing speed. Running document
    crawlers over a cluster and performing parallel queries and big data are examples
    of using parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal of parallelism is performance. In other words, the intention of
    using parallelism is to complete an operation in the shortest amount of time.
    An example of parallelism in use would be data-intensive number crunching for
    report generation.
  prefs: []
  type: TYPE_NORMAL
- en: You should never mix concurrency with performance. If you do, your design will
    either be bad or over-engineered. So, if you want user interfaces to be non-blocking,
    use concurrency. However, if you want non-UI tasks to complete in the shortest
    possible time, use parallelism. Later in this book, we will devote whole chapters
    to concurrency, parallelism, and asynchronous processing. But for now, let's turn
    our attention to the difference between `Equals()` and `==`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the difference between Equals() and ==
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `==` operator compares object references, known as shallow comparison, while
    the `Equals()` method compares object content, known as deep comparison. Both
    the operator and the method can be overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you overload the `==` operator, then you should overload the `Equals()` method
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `==` operator returns `true` in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Value Type Value == Value Type Value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reference Type Instance == Reference Type Instance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String == String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Equals()` method returns `true` in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReferenceType.Equals(ReferenceType)` both refer to the same object reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValueType.Equals(ValueType)` are both the same type and have the same value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add a new class called `Equality` to the root of the *CH06_Collections*
    project to demonstrate the difference in performance between the `==` operator
    and the `Equals()` method. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Equality` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our class has been configured to perform benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have our value types, reference types, and string types in place that
    will have their equality tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `GlobalSetup()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method assigns our variables in preparation for our equality benchmarks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ValueOperatorValue()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ValueOperatorValue()` method benchmarks the equality checking of two values
    using the `equality` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ValueEqualsValue()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ValueEqualsValue()` method benchmarks the equality checking of two values
    using the `Equals(value)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReferenceOperatorReference()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReferenceOperatorReference()` method benchmarks the equality checking of
    two reference values using the equality operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReferenceEqualsReference()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ReferenceEqualsReference()` method benchmarks the equality checking of
    two values using the `Equals(reference)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `StringOperatorString()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `StringOperatorString()` method benchmarks the equality testing of two strings
    using the `==` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `StringEqualsString()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `StringEqualsString()` method benchmarks the equality testing of two strings
    using the `Equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `BenchmarkRunner.Run<Equality>();` to the `Main` method of the `Program`
    class, do a `Release` build, and then run your executable from the command line.
    You should end up with the following benchmark report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The BenchmarkDotNet summary report for various equality checks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_6.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The BenchmarkDotNet summary report for various equality checks
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, it is quicker to test value type equality using the `==` operator,
    quicker to use the `==` operator to test reference type equality, and quicker
    to use `Equals(string)` when comparing strings.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have completed this chapter. But before we move on to [*Chapter
    7*](B16617_07_Final_SB_Epub.xhtml#_idTextAnchor139), *LINQ Performance*, let's
    summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the different types of collections and their
    usage. We saw that we should prefer using generic collections over non-generic
    collections. Then, we briefly touched on Big O Notation and how to use it to determine
    algorithmic efficiency. After that, we looked at choosing the right type of collection
    for what we needed.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set up a sample database to test the querying and iteration of
    data using further on in the chapter. Then, we looked at how to choose between
    using interfaces and concrete classes and choosing between arrays and collections.
    Next, we looked at indexers and then moved on to look at `IEnumerable<T>`, `IEnumerator<T>`,
    and `IQueryable<T>` and their performance.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic we looked at was using the `yield` keyword. We touched on the
    differences between concurrency and parallelism and mentioned that these will
    be looked at in more depth in later chapters. Finally, we looked at the difference
    between the `==` operator and the `Equals()` method in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at LINQ performance. But for now, see
    if you can answer the following questions, and check out the *Further reading*
    section to solidify what you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: List the different namespace collections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Big O notation used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does algorithmic efficiency measure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it preferable to use `IList<T>` or `List<T>` in terms of instantiation speed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should we use collections or arrays?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does an indexer do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method of iteration is fastest on an in-memory collection between `IEnumerable<T>`
    and `IEnumerator<T>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of memory and speed performance, what database query method performs
    best?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When building a collection using iteration, what is the quickest way to build
    the collection up and return the results?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Indexers*: [https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/](https://docs.microsoft.com/dotnet/csharp/programming-guide/indexers/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ConsoleSecrets*: [https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Equality Operators*: [https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators](https://docs.microsoft.com/dotnet/standard/design-guidelines/equality-operators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interesting Performance Implications of C# 9 Records Equality Check*: [https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919](https://gmanvel.medium.com/interesting-performance-implications-of-c-9-records-equality-check-f0d0a3612919).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improving Struct Equality Performance in C#:* [http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C](http://dontcodetired.com/blog/post/Improving-Struct-Equality-Performance-in-C).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*String Equality and Performance in C#:* [https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/](https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance Implications of Default Struct Equality in C#:* [https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/](https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Performance Best Practices in C#:* [https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a](https://kevingosse.medium.com/performance-best-practices-in-c-b85a47bdd93a).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*8 Techniques to Avoid GC Pressure and Improve Performance in C# .NET*: [https://michaelscodingspot.com/avoid-gc-pressure/](https://michaelscodingspot.com/avoid-gc-pressure/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
