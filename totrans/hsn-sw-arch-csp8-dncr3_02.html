<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Understanding the Importance of Software Architecture</h1>
                </header>
            
            <article>
                
<p><span>Nowadays, </span><span>s</span>oftware architecture is one of the most discussed topics <span>in the software industry</span>, and for sure, its importance will grow more in the future. The more we build complex and fantastic solutions, the more we need great software architectures to maintain them. That is the reason why you decided to read this book. That is the reason why we decided to write it.</p>
<p>For sure, it is not an easy task to write about this <span>important </span>topic, which offers so many alternative techniques and solutions. The main objective of this book is not just to build an exhaustive and never-ending list of available techniques and solutions, but also to show how various families of techniques are related and how they impact, in practice, the construction of a maintainable and sustainable solution.</p>
<p>The attention on how to create actual efficacious enterprise solutions increases as users <span>always</span> need more new features in their applications. Moreover, the need to deliver frequent <span>application </span>versions (due to a quickly changing market) increases the obligation to have sophisticated software architecture and development techniques.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The history of software development and the definition of software architecture</li>
<li>Software processes currently used by success enterprises</li>
<li>The process for gathering requirements</li>
</ul>
<p>By the end of this chapter, you will be able to understand exactly what the mission of a software architecture is. You will also learn what Azure is and how to create your account in the platform. Besides considering this is an introductory chapter, you will get an overview of software processes, models, and other techniques that will enable you to conduct your team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter will guide you on how to create an account in Azure, hence no code will be provided.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is software architecture?</h1>
                </header>
            
            <article>
                
<p>If you are reading this book today, you should thank the computer scientists who decided to consider software development as an engineering area. This happened in the last century and, more specifically, at the end of the sixties, when they proposed that the way we develop software is quite similar to the way we construct buildings. That is why we have the name <strong>software architecture</strong>. Like in the design of a building, the main goal of a software architect is to ensure that the software application is implemented well. But a good implementation requires the design of a great solution. Hence, in a professional development project, you have to do the following things:</p>
<ul>
<li style="font-weight: 400">Define the customer requirements for the solution.</li>
<li style="font-weight: 400">Design a great solution to meet those requirements.</li>
<li style="font-weight: 400">Implement the designed solution.</li>
<li style="font-weight: 400">Validate the solution with your customer.</li>
<li style="font-weight: 400">Deliver the solution in the working environment.</li>
</ul>
<p>Software engineering defines these activities as the software development life cycle. All of the theoretical software development process models (waterfall, spiral, incremental, agile, and so on) are somehow related to this cycle. No matter which model you use, if you do not work with <span><span>the essential tasks presented earlier </span></span>during your project, you will not deliver acceptable software as a solution.</p>
<p class="mce-root"/>
<p>The main point about designing great solutions is totally connected to the purpose of this book. You have to understand that <span>great</span><span> </span><span>real-world solutions bring with them a few fundamental constraints:</span></p>
<ul>
<li style="font-weight: 400">The solution needs to meet user requirements.</li>
<li style="font-weight: 400">The solution needs to be delivered on time.</li>
<li style="font-weight: 400">The solution needs to adhere to the project budget.</li>
<li style="font-weight: 400">The solution needs to deliver good quality.</li>
<li style="font-weight: 400">The solution needs to guarantee a safe and efficacious future evolution.</li>
</ul>
<p>Great solutions need to be sustainable and you have to understand that there is no sustainable software without great software architecture. N<span>owadays, g</span>reat software architectures depend on both tools and environments to perfectly <span>fit </span>users' requirements. To explain this, this book will use some great tools provided by Microsoft:</p>
<ul>
<li style="font-weight: 400"><strong>Azure</strong>: This is the cloud platform from Microsoft, where you will find all of the components it provides to build advanced software architecture solutions.</li>
<li style="font-weight: 400"><strong>Azure DevOps</strong>: This is the application life cycle management environment where you can build solutions using the latest approach for developing software, that is, DevOps.</li>
<li style="font-weight: 400"><strong>C#</strong>: This is one of the most used programming languages in the world. C# runs on small devices up to huge servers in different operating systems and environments.</li>
<li style="font-weight: 400"><strong>.NET Core</strong>: This is an open source development platform that is maintained by the Microsoft and .NET community on GitHub.</li>
<li style="font-weight: 400"><strong>ASP.NET Core</strong>: This is an open source multi-platform environment developed using .NET Core to build web applications and is hosted in the cloud or even on standard servers (on-premises).</li>
</ul>
<p>Being a software architect means understanding the aforementioned and a lot of other technologies. This book will guide you on a journey where you, as a software architect working in a team, will provide optimal solutions with the tools listed. Let's start this journey by creating your Azure account.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Azure account</h1>
                </header>
            
            <article>
                
<p><span><strong>Microsoft Azure</strong> is one of the best cloud solutions currently available on the market. It is important to know that, inside Azure, we will find a bunch of components that can help us in the architecture of twenty-first century solutions.</span></p>
<p><span>This subsection will guide you in creating an Azure account. If you already have one, you can skip this part:</span></p>
<ol>
<li><span>You can access the Azure portal using this URL: <a href="https://azure.microsoft.com">https://azure.microsoft.com</a>. Here, you will find a website, as follows. The translation to your native language will probably be set automatically:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa88fc72-7b40-4f25-8dc3-b9c8bbb30eaa.png"/></p>
<ol start="2">
<li>Once you have accessed this portal, it is possible to sign up. If you have never done this before, it is possible to sign up for free, so you will be able to use some Azure features without spending any money.</li>
</ol>
<ol start="3">
<li>Once you finish the form, you will be able to access the Azure panel. As you can see in the following screenshot, the panel shows a dashboard that you can customize, and a menu on the left, where you can set up the Azure components you are going to use in your solution. Throughout this book, we will come back to this screenshot to set up the components that create great opportunities for modern software architecture:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/77427f81-0c99-469f-b7ae-74168f7d3cda.png"/></p>
<p>Once you have your Azure account created, you are ready to understand how a software architect can conduct a team to develop software taking advantage of all of the opportunities offered by Azure. However, it is important to keep in mind that <span>a software architect needs to understand something more than specific technologies because, nowadays, this role is played by people who are expected to define how the software will be delivered. A software architect not only architects the base of software, but they also determine how the whole software development and deployment process is conducted.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Software development process models</h1>
                </header>
            
            <article>
                
<p>As a software architect, it is really important for you to understand some of the common development processes that are currently used in most enterprises. A software development process <span>defines how</span> people in a team produce and deliver software. In general, this process is connected with a software engineering theory, called <strong>software development process models</strong>. From the time software development was defined as an engineering process, many process models for developing software have been proposed. Let's take a look at the ones that are currently common.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing traditional software development process models</h1>
                </header>
            
            <article>
                
<p>Some of the models introduced in the software engineering theory are already considered traditional and quite obsolete. This book does not aim to cover all of them, but here, we will give a brief explanation of the ones that are still used in some companies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the waterfall model principles</h1>
                </header>
            
            <article>
                
<p>This topic may appear strange in a software architecture book of 2019, but yes, you may still find companies where the most traditional software process model still remains the guideline for software development. This process executes all fundamental tasks <span>in sequence. </span>Any software development project consists of the following steps:</p>
<ul>
<li>Requirements specification</li>
<li>Software design</li>
<li>Programming</li>
<li>Tests and delivery</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's look at a diagrammatic representation of this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/02ccc8d0-249d-4c4b-8459-5d646954db0c.png" style="width:32.67em;height:24.75em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The waterfall development cycle (https://en.wikipedia.org/wiki/Waterfall_model)</div>
<p><span>Often, t</span>he use of waterfall models causes problems related to delays in the delivery of a functional version of the software and user dissatisfaction due to the poor quality of the final product.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing the incremental model</h1>
                </header>
            
            <article>
                
<p>Incremental development is an approach that tries to overcome the biggest problem of the waterfall model: the user can test the solution only at the end of the project. The idea of this model is to give <span>the users </span><span>opportunities to interact with the solution as early as possible so that they can give useful feedback, which will help during the development of the software.</span></p>
<p><span>However, also in this model, the limited number of increments and the project's </span><span>bureaucracy </span><span>can causes problems in the interaction between developers and customers:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/27b7fa01-3c5e-4a47-83ad-125d6ea491fe.png" style="width:41.50em;height:21.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">The incremental development cycle (https://en.wikipedia.org/wiki/Incremental_build_model)</div>
<p>The incremental model was introduced as an alternative to the waterfall approach and it mitigated the problems related to the lack of communication with the customer. For big projects, fewer increments is still a problem. Besides, at the time the incremental approach was used on a large scale, mainly at the end of the last century, many problems related to project bureaucracy were reported, due to the large amount of documentation required. This scenario caused the rise of a very important movement in the software development industry—<strong>agile</strong>. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding agile software development process models</h1>
                </header>
            
            <article>
                
<p>At the beginning of this century, developing software was considered one of the most chaotic activities in engineering. The number of software projects that failed was incredibly high and this fact proved the need for a different approach to deal with the flexibility required by software development projects. So, in 2001, the Agile Manifesto was introduced to the world and, from that time, various agile process models were proposed. Some of them have survived up till now and are still very common.</p>
<p class="mce-root"/>
<div class="packt_infobox">Please check out this link for the Agile Manifesto: <a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a>.</div>
<p>One of the biggest differences between agile models and traditional models is the way developers interact with the customer. The message that all agile models transmit is that the faster you deliver software to the user, the better. This idea is <span>sometimes </span>confusing for software developers who understand this as—<em>let's try coding and that's all folks!</em> However, there is an important observation of the Agile Manifesto that many people do not read when they start working with agile:</p>
<div class="packt_quote">"That is, while there is value in the items on the right, we value the items on the left more."</div>
<div class="packt_quote CDPAlignRight CDPAlign">– Agile Manifesto, 2001</div>
<p>A software architect <span>always </span>needs to remember this. Agile processes do not mean a lack of discipline. Moreover, when you use the agile process, you understand that there is no way to have good software developed without discipline. On the other hand, as a software architect, you need to understand that <em>soft</em> means flexibility. A software project that does not deal with flexibility tends to get ruined over time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting into the Scrum model</h1>
                </header>
            
            <article>
                
<p>Scrum is an agile model for the management of software development projects. The model comes from lean principles and is definitely one of the widely used approaches for developing software nowadays.</p>
<div class="packt_figref packt_infobox CDPAlignLeft CDPAlign">Please check this link for more information about the Scrum framework: <a href="https://docplayer.net/78853722-Scrum-insights-for-practitioners.html">https://docplayer.net/78853722-Scrum-insights-for-practitioners.html</a>.</div>
<p>The basis of Scrum is that you have a flexible backlog of user needs that needs to be discussed in each agile cycle, called a <strong>Sprint</strong>. <span>The Sprint Goal is determined by the Scrum Team, composed by the Product Owner, the Scrum Master, and the Development Team. </span>The <strong><span>Product Owner</span></strong> is responsible for prioritizing what will be delivered in that sprint. During the sprint, this person will help the team to develop the required features. The person who leads the team in the Scrum process is called <strong>Scrum Master</strong>. All of the meetings and processes are conducted by this person.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>It is important to notice that the Scrum process does not discuss how the software needs to be implemented and which activities will be done. So, again, you have to remember the software development basis, discussed at the beginning of this chapter. That means Scrum needs to be implemented together with a process model. DevOps is one of the approaches that may help you with the use of a software development process model together with Scrum. We will discuss this later in this book, in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling aspects to be gathered to design high-quality software</h1>
                </header>
            
            <article>
                
<p>Fantastic! You just started a software development project. Now, it is time to use all of your knowledge to deliver the best software you can. Probably, your next question is—<em>how do I start?</em> Well, as a software architect, you are going to be the one to answer it. And be sure your answer is going to evolve in each software project you lead:</p>
<ol>
<li><span>Defining a software development process is obviously the first thing to do. This is generally done during the project planning process.</span></li>
<li><span>Besides, another very important thing to do is to gather the software requirements. No matter which software development process <span>you decide</span> to use, collecting real user needs is a part of a very difficult and continuous job. Of course, there are techniques to help you with this. And be sure that gathering requirements will help you to detect important aspects of software architecture.</span></li>
</ol>
<p>These two activities are considered by most experts in software development as the key to having success at the end of the development project journey. As a software architect, you need to enable them to happen so that you will not have problems while guiding your team.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the requirements gathering process</h1>
                </header>
            
            <article>
                
<p>There are different ways to represent the requirements. The most traditional approach consists of you having to write a perfect specification before the beginning of the analysis. Agile methods suggest that you need to write stories as soon as you are ready to start a development cycle.</p>
<div class="packt_tip">Remember: you do not write requirements for the user, you write them for you and your team. The user just needs the job done!</div>
<p>The truth is that no matter the approach you decide to adopt in your projects, you will have to follow some steps to gather requirements. This is what we call <strong>requirements engineering.</strong></p>
<div class="packt_figref packt_infobox CDPAlignLeft CDPAlign">Please check out this image of the requirements engineering process for more information: <a href="https://www.slideshare.net/MohammedRomi/ian-sommerville-software-engineering-9th-edition-ch-4">https://www.slideshare.net/MohammedRomi/ian-sommerville-software-engineering-9th-edition-ch-4</a>.</div>
<p>During this process, you need to be sure that the solution is feasible. In some cases, the feasibility analysis is a part of the project planning process too, and by the time you start the requirements elicitation, you will have the feasibility report already done. So, let's check the other parts of this process, which will give you a lot of important information for the software architecture. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practicing the elicitation of user needs</h1>
                </header>
            
            <article>
                
<p>There are a lot of ways to detect what exactly the user needs for a specific scenario. In general, this can be done using techniques that will help you to understand what we call user requirements. Here, you have a list of common techniques:</p>
<ul>
<li><strong>The power of imagination</strong>: If you are an expert in the area where you are providing solutions, you may use your own imagination to find new user requirements. Brainstorming can be conducted together so that a group of experts can define user needs.</li>
<li><strong>Questionnaires</strong>: This tool is useful for detecting common and important requirements such as the number and <span>kind of </span>users, peak system usage, and the commonly-used <strong>operating system</strong> (<strong>OS</strong>) and web browser. </li>
<li><strong>Interviews</strong>: Interviewing the users helps you as an architect to detect user requirements that perhaps questionnaires and your imagination will not cover.</li>
<li><strong>Observation</strong>: There is no better way to understand the daily routine of a user than being with them for a day.</li>
</ul>
<p>As soon as you apply one or more of these techniques, you will have great and valuable information, that is, the user's needs. At that moment, you will be able to analyze them and detect the user and system requirements.</p>
<p class="mce-root"/>
<div class="packt_tip">Remember: You can use these techniques in any situation where the real need is to gather requirements, no matter if it is for the whole system or for a single story.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing requirements</h1>
                </header>
            
            <article>
                
<p>As soon as you detect user needs, it is time to begin the analysis of the requirements. At that time, you can use techniques such as the following:</p>
<ul>
<li><strong>Prototyping</strong>: Prototypes are really good to clarify and to materialize the system requirements. Today, we have many tools that can help you to mock interfaces. A really nice open source tool is the <strong>Pencil Project</strong>. You will find further information about it at <a href="https://pencil.evolus.vn/">https://pencil.evolus.vn/</a>. </li>
<li><strong>Use cases</strong>: The <strong>Unified Modeling Language</strong> (<strong>UML</strong>) use case model is an option if you need detailed documentation. The model is composed of a detailed specification and a diagram. <strong>Argo UML</strong> is another open source tool that can help you out with this:</li>
</ul>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d8421f8e-0455-4626-a7d2-af8177559d80.png" style="width:44.42em;height:20.33em;"/></p>
<p>While you are analyzing the requirements of the system, you will be able to clarify exactly what the users' needs are. This is really helpful when you are not sure about the real problem you will solve and is pretty much better than just starting to program the system. It is time that you will invest in having better code in the near future.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the specifications</h1>
                </header>
            
            <article>
                
<p><span>After you finish the analysis, it is important to register it as a specification. This document can be written using traditional requirements or user stories, which are commonly used in agile projects.</span></p>
<p>Requirements specification represents the technical contract between the user and the team. There are some basic rules that this document needs to follow:</p>
<ul>
<li>All stakeholders need to understand exactly what is written in the technical contract, even if they are not technicians.</li>
<li>The document needs to be clear.</li>
<li>You need to classify each requirement.</li>
<li>Use a simple feature to represent each requirement.</li>
<li>Ambiguity and controversy need to be avoided.</li>
</ul>
<p>Besides, some information can help the team to understand the context of the project they are going to work on. Here, you have some tips about it:</p>
<ul>
<li>Write an introductory chapter to give a full idea of the solution.</li>
<li>Create a glossary to make understanding easier.</li>
<li>Describe the kind of user the solution will cover.</li>
<li>Write functional and non-functional requirements.</li>
<li>Attach documents that can help the user to understand rules.</li>
</ul>
<p>If you decide to write user stories, a good tip to follow is to write short sentences representing each moment in the system with each user, as follows:</p>
<pre><span>As &lt;user&gt;, I want &lt;feature&gt;, so that &lt;reason&gt;</span></pre>
<p>This approach will explain exactly the reason why that feature will be implemented. Besides that, you will have a good tool to later analyze the stories that are more critical and prioritize the success of the project. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reviewing the specification</h1>
                </header>
            
            <article>
                
<p>Once you have the specification written, it is time to confirm with the stakeholders whether they agree with it. This can be conducted in a review meeting or can be done online using collaboration tools. </p>
<p class="mce-root"/>
<p>This is when you present all of the prototypes, documents, and information you have gathered. As soon as everybody agrees with the specification, you are ready to start studying the best way to implement this part of your project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using design thinking as a helpful tool</h1>
                </header>
            
            <article>
                
<p>During your career as a software architect, you will find many projects where your customer will bring you a solution <em>ready for development</em>. This is quite complicated once you consider that as the correct solution and, most of the time, there will be architectural and functional mistakes that will cause problems in the solution in the future. There are some cases where the problem is worse—when the customer does not know the best solution for the problem. Design thinking can help us with this.</p>
<p><strong>Design thinking</strong> is a process that allows you to collect data directly from the users, focusing on achieving the best results to solve a problem. During this process, the team will have the opportunity to discover all <em>personas</em> that will interact with the system. This will have a wonderful impact on the solution since you can develop the software by focusing on the user experience, which can have a fantastic impact on the results.</p>
<p>The process is based on the following steps:</p>
<ul>
<li><strong>Empathize</strong>: In this step, you have to execute field research to discover the user's concerns. <span>This is where you find out about the users of the system. </span>The process is good for making you understand why and for whom you are developing this software. </li>
<li><strong>Define</strong>: Once you have the users' concerns, it is time to define their needs to solve them.</li>
<li><strong>Ideate:</strong> The needs will provide an opportunity to brainstorm some possible solutions.</li>
<li><strong>Prototype</strong>: These solutions can be developed as prototypes to confirm whether they are good ones.</li>
<li><strong>Test</strong>: Testing the prototypes will help you to understand the prototype that is most connected to the real needs of the users.</li>
</ul>
<p>What you have to understand is that design thinking can be a fantastic option to discover real requirements. As a software architect, you are committed to helping your team to use the correct tools at the correct time. </p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding the principles of scalability, robustness, security, and performance</h1>
                </header>
            
            <article>
                
<p>Detecting requirements is a task that will let you understand the software you are going to develop. However, as a software architect, you don't have to only pay attention to the functional requirements for that system. Understanding the non-functional requirements is really important and one of the primordial activities for a software architect.</p>
<p>We are going to discuss <span>this </span>more in <a href="a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml">Chapter 2</a>, <em>Functional and Nonfunctional Requirements</em>, but at this point, it is good to know that the principles of scalability, robustness, security, and performance need to be applied for the requirements gathering process. Let's take a look at each concept:</p>
<ul>
<li><strong>Scalability</strong>: <span>As a software developer,</span> globalization gives you the opportunity to have your solution running all over the world. This is fantastic, but you, as a software architect, need to design a solution that provides that possibility. Scalability is the possibility for an application to increase its processing power as soon as it is necessary, due to the number of resources that are being consumed.</li>
<li><strong>Robustness</strong>: No matter how scalable your application <span>is</span>, if it is not able to guarantee a stable and always-on solution, you are not going to get any peace. Robustness is really important for critical solutions, where you do not have the opportunity for maintenance at any time, due to the kind of problem that the application solves. In many industries, the software cannot stop and lots of routines run when nobody is available (<span>overnight</span>, holidays, and so on). Designing a robust solution will give you the freedom to live while your software is running well.</li>
<li><strong>Security</strong>: This is another really important area that needs to be discussed after the requirements stage. Everybody is worried about security and laws dealing with it are being proposed in different parts of the world. You, <span>as a software architect, </span>have to understand that security needs to be provided by design. This is the only way to cope with all of the needs that the security community is discussing right now.</li>
<li><strong>Performance</strong>: The process of understanding the system you are going to develop <span>will </span>probably give you a good idea of what your efforts will need to be to get the desired performance from the system. This topic needs to be discussed with the user to identify most of the bottlenecks you will face during the development stage.</li>
</ul>
<p>It is worth mentioning that all these concepts are requirements for this new generation of solutions that the world needs. What will differentiate good software for incredible software surely is the amount of work done to meet the project requirements.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Some cases where the requirements gathering process impacted system results</h1>
                </header>
            
            <article>
                
<p>All of the information discussed up to this point in the chapter is useful if you want to design software following the principles of good engineering. This discussion is not related to developing by using traditional or agile methods but focuses on building software professionally or as an amateur.</p>
<p>Besides, it is good to know about some cases where the lack of activities you read about caused some trouble for the software project. The following cases intend to describe what went wrong and how the preceding techniques could have helped the development team to solve the problems. In most cases, simple action could guarantee better communication between the team and the customer and this easy communication flow could transform a big problem into a real solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 1 – my website is too slow to open that page!</h1>
                </header>
            
            <article>
                
<p>Performance is one of the biggest problems that you as a software architect will live through during your career. The reason why this aspect of any software is so problematic is that we do not have infinite computational resources to solve problems. Besides, the cost of computation is still high, especially if you are talking about software with a high number of simultaneous users.</p>
<p>You cannot solve performance problems by writing requirements. However, you won't end up in trouble if you write them correctly. The idea here is that requirements have to present the desired performance of a system. A simple sentence, describing this, can help the entire team that works on the project:</p>
<div class="packt_quote">Non-functional requirement: Performance – any web page of this software will respond in at least 2 seconds.</div>
<p>The preceding sentence just makes everybody (users, testers, developers, architects, managers, and so on) sure that any web page has a target to achieve. This is a good start, but it is not enough. With this, a great environment to both develop and deploy your application is important. This is where .NET Core can help you a lot. Especially if you are talking about web apps, ASP.NET Core is considered one of the fastest options to deliver solutions today. </p>
<p class="mce-root"/>
<p>If you talk about performance, you<span>, as a software architect,</span> should consider the use of the techniques listed in the following sections. It is good to mention that ASP.NET Core will help you to use them easily, together with some <strong>Platform as a Service</strong> (<strong><span>PaaS</span></strong>) solutions delivered by Microsoft Azure. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding caching</h1>
                </header>
            
            <article>
                
<p>Caching is a great technique to avoid queries that can consume time and, in general, give the same result. For instance, if you are fetching the <span>available car </span>models in a database, the number of cars in the database can increase but they will not change. Once you have an application that constantly accesses car models, a good practice is to cache that information.</p>
<p>It is important to understand that a cache is stored in the backend and that cache is shared by the whole application (<em>in-memory caching</em>). A single point of attention here is when you are working on a scalable solution, you can configure a <em>distributed cache</em> to solve it using the Azure platform. In fact, ASP.NET Core provides both of them, so you can decide on the one that bests fits your needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applying asynchronous programming</h1>
                </header>
            
            <article>
                
<p>When you develop ASP.NET Core applications, you need to keep in mind that this app needs to be designed for simultaneous access by many users. Asynchronous programming lets you do this simply, giving you the keywords <kbd>async</kbd> and <kbd>await</kbd>.</p>
<p>The basic concept behind these keywords is that <kbd>async</kbd> enables any method to run in a different thread from the one that calls it. On the other hand, <kbd>await</kbd> lets you synchronize the call of an asynchronous method without blocking the thread that is calling it. This easy-to-develop pattern will make your application run <span>without performance bottlenecks and better responsiveness. This book will cover more about this subject in <a href="a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml">Chapter 2</a>, <em>Functional and Nonfunctional Requirements</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with object allocation</h1>
                </header>
            
            <article>
                
<p>One very good tip to avoid a lack of performance is to understand how the Garbage Collector works. The Garbage Collector<strong> </strong>is the engine that will free memory automatically when you finish using it. There are some very important aspects of this topic, due to the complexity that the GC has.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Some types of objects are not collected by the GC. The list includes any object that interacts with I/O, such as files and streaming. If you do not correctly <span>use </span>the C# syntax to create and destroy this kind of object, you will have memory leaks, which will deteriorate your application performance.</p>
<p><span>The incorrect way of working with I/O objects:</span></p>
<pre><span>System.IO.StreamWriter file = n</span><span class="hljs-keyword">ew </span><span>System.IO.StreamWriter(</span><span class="hljs-string">@"C:\sample.txt"</span><span>);<br/></span><span>file.WriteLine("Just writing a simple line");<br/></span></pre>
<p><span>The correct way of working with I/O objects:</span></p>
<div>
<pre><span class="hljs-keyword">using</span><span> (System.IO.StreamWriter file = n</span><span class="hljs-keyword">ew </span><span>System.IO.StreamWriter(</span><span class="hljs-string">@"C:\sample.txt"</span><span>))<br/>{<br/>    </span><span>file.WriteLine("Just writing a simple line");<br/>}</span></pre></div>
<p>Even though the preceding practice is mandatory for I/O objects, it is totally recommended that you keep doing this in all disposable objects. This will help the GC and will keep your application running with the right amount of memory. </p>
<p><span>Another important aspect that you need to know about is that the time spent by the GC to collect objects that will interfere with the performance of your app. Because of this, avoid allocating large objects. This can cause you trouble waiting for the GC to finish its task.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting better database access</h1>
                </header>
            
            <article>
                
<p>One of the most common performance Achilles' heel is database access. The reason why this is still a big problem is the lack of attention while writing queries or lambda expressions to get information from the database. This book will cover Entity Framework Core in <a href="8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml">Chapter 6</a>, <em>Interacting with Data in C# – Entity Framework Core</em>, but it is important to know what to choose, the correct data information to read from a database, and filtering columns and lines is imperative for an application that wants to deliver performance.</p>
<p>The good thing is that best practices related to caching, asynchronous programming, and object allocation fit completely in the environment of databases. It is only a matter of choosing the correct pattern to get better-performance software.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 2 – the user's needs are not properly implemented</h1>
                </header>
            
            <article>
                
<p>The more technology is used in a wide variety of areas, the more difficult it is to deliver exactly what the user needs. Maybe this sentence sounds weird to you, but you have to understand that developers, in general, study to develop software, but they rarely study to deliver the needs of a specific area. Of course, it is not easy to learn how to develop software, but it is even more difficult to understand a need in a particular area. Software development nowadays delivers software to all possible types of industries. The question here is <em>how can a developer, being a software architect or not, evolve enough to deliver software in the area they are responsible for?</em></p>
<p>Gathering software requirements definitely will help you in this tough task. Moreover, writing them will make you understand and organize the architecture of the system. There are several ways to minimize the risks of implementing something different from what the user really needs:</p>
<ul>
<li>Prototyping the interface to achieve the understanding of the user interface <span>faster</span></li>
<li>Designing the data flow to detect gaps between the system and the user operation</li>
<li>Frequent meetings to be updated on the current needs and aligned to the incremental deliveries</li>
</ul>
<p>Again, as a software architect, you will have to define how the software will be implemented. Most of the time, you are not going to be the one who programs it, but you will always be the one responsible for this. For this reason, some techniques can be useful to avoid the wrong implementation:</p>
<ul>
<li>Requirements are reviewed with the developers to guarantee that they understand what they need to develop</li>
<li>Code inspection to validate a <span>predefined </span>code standard </li>
<li>Meetings to eliminate impediments</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case 3 – the usability of the system does not meet user needs</h1>
                </header>
            
            <article>
                
<p>Usability is a key point for the success of a software project. The way the software is presented and how it solves a problem can help the user to decide whether they want to use it or not. As a software architect, you have to keep in mind that delivering software with good usability is mandatory nowadays.</p>
<p>There are basic concepts of usability that this book does not intend to cover. But a good way to meet the correct user needs when it comes to usability is by understanding who is going to use the software. Design thinking can help you a lot with that, as was discussed earlier in this chapter. </p>
<p>Understanding the user will help you to decide whether the software is going to run on a web page, or a cell phone, or even in the background. This understanding is very important to a software architect because the elements of a system will be better presented if you <span>correctly</span><span> </span><span>map who will use them.</span></p>
<p>On the other hand, if you do not care about that, you will just deliver software that works. This can be good for a short time, but it will not <span>exactly</span><span> </span><span>meet</span> <span>the real needs that made a person ask you to architect software. You have to keep in mind the options and understand that good software is designed to run on many platforms and devices.</span></p>
<p>You will be happy to know that C# is an incredible cross-platform option for that. So, you can develop solutions to run your apps in Linux, Windows, Android, and iOS. You can run your applications on big screens, tablets, cell phones, and even drones! You can embed apps on boards for automation or in HoloLens for mixed reality. Software architects have to be open-minded to design exactly what their users need.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study – detecting user needs</h1>
                </header>
            
            <article>
                
<p class="mce-root">The case study of this book will take you on a journey of creating the software architecture for a travel agency called <strong>World Wild Travel Club</strong> (<strong><span>WWTravelClub</span></strong>). The purpose of this case study is to make you understand the theory explained in each chapter, plus to provide the during the process of reading this book to develop an enterprise application with Azure, Azure DevOps, C#, .NET Core, ASP.NET Core, and other technologies that will be introduced in this book.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Book case study – introducing World Wild Travel Club</h1>
                </header>
            
            <article>
                
<p><strong>World Wild Travel Club</strong> (<strong>WWTravelClub</strong>) is a travel agency that was created to change the way people make decisions about their vacations and other trips around the world. To do so, they are developing an online service where every detail of a trip experience will be assisted by a club of experts specifically selected for each destination.</p>
<p>The concept of this platform is that you can be both a visitor and a destination expert at the same time. The more you participate as an expert in a destination, the higher the points you will score. These points can be exchanged for tickets that people buy online using the platform.</p>
<p>The customer came with the following requirements for the platform. It is important to know that, in general, customers do not bring the requirements ready for development. That is why the requirements gathering process is so important:</p>
<ul>
<li style="font-weight: 400">Common user view:
<ul>
<li style="font-weight: 400">Promotional packages on the home page</li>
<li style="font-weight: 400">Search for packages</li>
<li style="font-weight: 400">Details for each package:
<ul>
<li style="font-weight: 400">Buy a package</li>
<li style="font-weight: 400">Buy a package with a club of experts included:
<ul>
<li style="font-weight: 400">Comment on your experience</li>
<li style="font-weight: 400">Ask an expert</li>
<li style="font-weight: 400">Evaluate an expert</li>
</ul>
</li>
</ul>
</li>
<li style="font-weight: 400">Register as a common user</li>
</ul>
</li>
<li style="font-weight: 400">Destination expert view:
<ul>
<li style="font-weight: 400">The same view as the common user view</li>
<li style="font-weight: 400">Answer the questions asking for your destination expertise</li>
<li style="font-weight: 400">Manage the points you scored answering questions:
<ul>
<li style="font-weight: 400">Exchange points for tickets</li>
</ul>
</li>
</ul>
</li>
<li style="font-weight: 400">Administrator view:
<ul>
<li style="font-weight: 400">Manage packages</li>
<li style="font-weight: 400">Manage common users</li>
<li style="font-weight: 400">Manage destination experts</li>
</ul>
</li>
</ul>
<p class="mce-root"/>
<p>To finish this, it is important to note that WWTravelClub intends to have more than 100 Destination Experts per package and will offer around 1,000 different packages all over the world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Book case study – understanding user needs and system requirements</h1>
                </header>
            
            <article>
                
<p>To summarize the user needs of WWTravelClub, you can read the following user stories:</p>
<ul>
<li><kbd>US_001</kbd>: As a common user, I want to view promotional packages on the home page, so that I can easily find my next vacation.</li>
<li><kbd>US_002</kbd>: As a common user, I want to search for packages I cannot find on the home page so that I can explore other trip opportunities.</li>
<li><kbd>US_003</kbd>: As a common user, I want to see the details of a package, so that I can decide which package to buy.</li>
<li><kbd>US_004</kbd>: As a common user, I want to register myself, <span>so that I can start buying the package.</span></li>
<li><kbd>US_005</kbd>: As a registered user, I want to buy a package, <span>so that I can process the payment.</span></li>
<li><kbd>US_006</kbd>: As a registered user, I want to buy a package <span>with a club of experts included</span>,<span> </span><span>so that I can have an exclusive trip experience.</span></li>
<li><kbd>US_007</kbd>: As a registered user, I want to ask for an expert, so <span>that </span>I can get the best of my trip.</li>
<li><kbd>US_008</kbd>: As a registered user, I want to comment on my experience, so <span>that</span><span> </span>I can give feedback from my trip.</li>
<li><kbd>US_009</kbd>: As a registered user, I want to evaluate an expert who helps me, so <span>that</span><span> </span>I can share with others how fantastic they were.</li>
<li style="font-weight: 400"><kbd>US_010</kbd>: As a registered user, I want to register as a Destination Expert View, so <span>that</span><span> </span>I can help people who travel to my city.</li>
<li style="font-weight: 400"><kbd>US_011</kbd>: As an expert user, I want to answer questions about my city, so <span>that</span><span> I can score points to be exchanged in the future.</span></li>
<li style="font-weight: 400"><kbd>US_012</kbd>: As an expert user, I want to exchange points for tickets, so <span>that</span><span> I can travel around the world more.</span></li>
<li style="font-weight: 400"><kbd>US_013</kbd>: As an administrator user, I want to manage packages, so that users can have fantastic opportunities to travel.</li>
<li style="font-weight: 400"><kbd>US_014</kbd>: As an administrator user, I want to manage registered users, so that <span>WWTravelClub can guarantee good service quality.</span></li>
<li style="font-weight: 400"><kbd>US_015</kbd>: As an administrator user, I want to manage expert users, so that all of the questions regarding our destinations are answered.</li>
<li><kbd>US_016</kbd>: As an administrator user, I want to offer more than 1,000 packages around the world, so that different countries can experience WWTravelClub service.</li>
<li><kbd>US_017</kbd>: As an administrator user, I want to have more than 1,000 users simultaneously accessing the website, so that I can support all of the needs of my users.</li>
<li><kbd>US_018</kbd>: As a user, I want to access WWTravelClub in my native language, so that I can easily understand the package offered.</li>
<li><kbd>US_019</kbd>: As a user, I want to access WWTravelClub in the Chrome, Firefox, and Edge web browsers, so that I can use the web browser of my preference.</li>
<li><kbd>US_020</kbd>: As a user, I want to buy packages safely, so that only WWTravelClub will have my credit card information.</li>
</ul>
<p>Notice that while you start writing the stories, information related to non-functional requirements such as security, environment, performance, and scalability can be included.</p>
<p>However, some system requirements may be omitted when you write user stories and need to be included in the software specification. These requirements can be related to legal aspects, hardware and software prerequisites, or even points of attention for the correct system delivery. They need to be mapped and listed as well as user stories. The list of <span>WWTravelClub system requirements is presented in the following. Notice that requirements are written in the future because the system does not exist yet:</span></p>
<div style="margin-left: 2em">
<ul>
<li><kbd>SR_001</kbd>: The system will use Microsoft Azure components to deliver the scalability required.</li>
<li><kbd>SR_002</kbd>: The system will respect <strong>General Data Protection Regulation</strong> (<span><strong>GDPR</strong>)</span> requirements.</li>
<li><kbd>SR_003</kbd>: The system will run on the Windows, Linux, iOS, and Android platforms.</li>
<li><kbd>SR_004</kbd>: <span>Any web page of this system will respond in at least 2 secon</span><span>ds.</span></li>
</ul>
</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned the purpose of a software architect in a software development team. Also, this chapter covered the basics of software development <span>process </span>models and the requirements gathering process. You <span>also </span>had the opportunity to learn about how to create your Azure account, which will be used during the case study of this book, which was presented to you in the previous section. Moreover, you even learned about functional and non-functional requirements and how to create them using user stories. These techniques will surely help you deliver a better software project.</p>
<p>In the next chapter, you will have the opportunity to understand how functional and non-functional requirements are important for software architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the expertise that a software architect needs to have?</li>
<li>How can Azure help a software architect?</li>
<li>How does a software architect decide the best software development <span>process </span>model to use in a project?</li>
<li>How does a software architect contribute to gathering requirements?</li>
<li>What kind of requirements does a software architect need to check in a requirement specification?</li>
<li>How does design thinking help a software architect in the process of gathering requirements?</li>
<li>How do user stories help a software architect in the process of writing requirements?</li>
<li>What are good techniques to develop very good performance software?</li>
<li>How does a software architect check whether a user requirement is correctly implemented?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>Here, you have some books and links you may consider reading to gather more information about this chapter:</span></p>
<ul>
<li><a href="https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers">https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers</a></li>
<li><a href="https://azure.microsoft.com/en-us/overview/what-is-azure/">https://azure.microsoft.com/en-us/overview/what-is-azure/</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/devops/">https://azure.microsoft.com/en-us/services/devops/</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/core/about">https://docs.microsoft.com/en-us/dotnet/core/about</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/">https://docs.microsoft.com/en-us/aspnet/core/</a></li>
<li><a href="https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core">https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core</a></li>
<li><a href="https://agilemanifesto.org/">https://agilemanifesto.org/</a></li>
<li><a href="https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038">https://www.amazon.com/Software-Engineering-10th-Ian-Sommerville/dp/0133943038</a></li>
<li><a href="https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/">https://www.amazon.com/Software-Engineering-Practitioners-Roger-Pressman/dp/0078022126/</a></li>
<li><a href="https://scrumguides.org/">https://scrumguides.org/</a></li>
<li><a href="https://www.packtpub.com/application-development/professional-scrummasters-handbook">https://www.packtpub.com/application-development/professional-scrummasters-handbook</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices">https://docs.microsoft.com/en-us/aspnet/core/performance/performance-best-practices</a></li>
<li><a href="https://www.microsoft.com/en-us/hololens">https://www.microsoft.com/en-us/hololens</a></li>
<li><a href="https://en.wikipedia.org/wiki/Incremental_build_model">https://en.wikipedia.org/wiki/Incremental_build_model</a></li>
<li><a href="https://en.wikipedia.org/wiki/Waterfall_model">https://en.wikipedia.org/wiki/Waterfall_model</a></li>
</ul>


            </article>

            
        </section>
    </body></html>