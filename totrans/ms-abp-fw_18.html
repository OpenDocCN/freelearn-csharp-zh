<html><head></head><body>
		<div id="_idContainer114">
			<h1 id="_idParaDest-305"><em class="italic"><a id="_idTextAnchor429"/>Chapter 14</em>: Building HTTP APIs and Real-Time Services</h1>
			<p>Exposing an HTTP API endpoint is a fairly common way of allowing client applications to consume your application functionalities. Building HTTP APIs makes your application open to any client since almost all devices that connect to a network already implement the HTTP protocol.</p>
			<p>In this chapter, you will learn about options to create HTTP APIs for your solutions. You will also see how ABP makes it easy to consume your HTTP APIs from client applications by using ABP's dynamic and generated client-side proxies. Finally, we will explain how you can use Microsoft's <strong class="bold">SignalR</strong> library in ABP applications to implement real-time server-client communication. Here is a list of topics covered in this chapter:</p>
			<ul>
				<li>Building HTTP APIs</li>
				<li>Consuming HTTP APIs</li>
				<li>Using SignalR with ABP Framework</li>
			</ul>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor430"/>Technical requirements</h1>
			<p>If you want to follow the examples in this chapter, you need to have an IDE/editor that supports ASP.NET Core development. We will use the ABP CLI at some points, so you need to install the ABP CLI, as explained in <a href="B17287_02_Epub_AM.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with ABP Framework</em>.</p>
			<p>You can download the example application from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>. It contains some of the examples given in this chapter.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor431"/>Building HTTP APIs</h1>
			<p>In this section, we will begin with ASP.NET Core's standard approach for creating HTTP APIs. Then we will see how <a id="_idIndexMarker911"/>ABP can automatically convert standard application services to HTTP API endpoints. But first, let's see how we can create API-only solutions with ABP Framework.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor432"/>Creating an HTTP API project</h2>
			<p>When you create a new application or module with ABP Framework's startup solution templates, it already <a id="_idIndexMarker912"/>contains HTTP APIs for all the functionality provided by the application. However, it is also possible to create an HTTP API endpoint without an application UI if you want to.</p>
			<p>You can use the <strong class="source-inline">-u none</strong> parameter when you create a new solution using ABP Framework, as shown in the following example:</p>
			<p class="source-code">abp new ApiDemo -u none</p>
			<p><strong class="source-inline">ApiDemo</strong> is our solution name here. In this way, we have a solution with an HTTP API endpoint but without a UI. The following figure shows the solution opened in Visual Studio:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/Figure_14.01_B17287.jpg" alt="Figure 14.1 – An HTTP API solution created by the ABP CLI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – An HTTP API solution created by the ABP CLI</p>
			<p>We should first run the <strong class="source-inline">ApiDemo.DbMigrator</strong> application to create the database, so the HTTP API properly works. To do that, right-click the <strong class="source-inline">ApiDemo.DbMigrator</strong> project, click the <strong class="bold">Set as Startup Project</strong> action, then hit <em class="italic">Ctrl</em> + <em class="italic">F5</em> to run it. If you are not using Visual Studio, open <a id="_idIndexMarker913"/>a command-line terminal in the root directory of the <strong class="source-inline">ApiDemo.DbMigrator</strong> project and execute the <strong class="source-inline">dotnet run</strong> command.</p>
			<p>Now, you can run the <strong class="source-inline">ApiDemo.HttpApi.Host</strong> project to start the HTTP API application. The HTTP API application shows Swagger UI by default, as shown in the following figure:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/Figure_14.02_B17287.jpg" alt="Figure 14.2 – Swagger UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Swagger UI</p>
			<p>Swagger UI is a very useful tool to explore and test our HTTP API endpoints. We can use the <strong class="bold">Authorize</strong> button to <a id="_idIndexMarker914"/>log in to the application (the default username is <strong class="source-inline">admin</strong>, and the default password is <strong class="source-inline">1q2w3E*</strong>), so we can also test the APIs that require authorization.</p>
			<p>For example, we can use the <strong class="source-inline">/api/identity/roles</strong> endpoint to get a list of roles defined in the system. This endpoint requires authorization, so log in first with the <strong class="bold">Authorize</strong> button. After login, find the <strong class="source-inline">/api/identity/roles</strong> endpoint under the <strong class="bold">Role</strong> group, click to <a id="_idIndexMarker915"/>expand it, click the <strong class="bold">Try it out</strong> button, then the <strong class="bold">Execute</strong> button to call the endpoint. When you call it, the server returns a JSON value as shown in the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "totalCount": 1,</p>
			<p class="source-code">  "items": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "name": "admin",</p>
			<p class="source-code">      "isDefault": false,</p>
			<p class="source-code">      "isStatic": true,</p>
			<p class="source-code">      "isPublic": true,</p>
			<p class="source-code">      "concurrencyStamp": </p>
			<p class="source-code">          "1f23ae3a-85d8-4656-b094-00e605e28e4e",</p>
			<p class="source-code">      "id": "92692d73-4acb-ca9f-4838-39ff4cdf25e4",</p>
			<p class="source-code">      "extraProperties": {}</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>So, we've learned how to create and launch an HTTP API solution with ABP Framework. Now, let's see how we can add new APIs using ASP.NET Core's standard controllers.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor433"/>Creating ASP.NET Core controllers</h2>
			<p>ASP.NET Core's controllers <a id="_idIndexMarker916"/>provide a convenient infrastructure to create HTTP APIs. The following example exposes HTTP endpoints to get the product list and update a product:</p>
			<p class="source-code">[ApiController]</p>
			<p class="source-code">[Route("products")]</p>
			<p class="source-code">public class ProductController : ControllerBase</p>
			<p class="source-code">{</p>
			<p class="source-code">    [HttpGet]</p>
			<p class="source-code">    public async Task&lt;ProductDto&gt; GetListAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // TODO: implement</p>
			<p class="source-code">    }</p>
			<p class="source-code">    [HttpPut]</p>
			<p class="source-code">    [Route("{id}")]</p>
			<p class="source-code">    public async Task UpdateAsync(Guid id, ProductUpdateDto</p>
			<p class="source-code">                                  input)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // TODO: implement</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ProductController</strong> class is inherited from the <strong class="source-inline">ControllerBase</strong> class. It is suggested to inherit your API controller classes from the <strong class="source-inline">ControllerBase</strong> class instead of the <strong class="source-inline">Controller</strong> class since it contains some view-related functionality that is unnecessary for API Controllers. Alternatively, you can inherit your API controller classes from the <strong class="source-inline">AbpControllerBase</strong> class, which provides some common ABP services as pre-injected properties for you.</p>
			<p>Adding the <strong class="source-inline">[ApiController]</strong> attribute on top of the controller class enables ASP.NET Core's default <a id="_idIndexMarker917"/>API-specific behaviors (such as automatic HTTP 400 responses and attribute routing requirement), so it is also suggested.</p>
			<p>In this example, the <strong class="source-inline">[Route]</strong> attribute defines the URL of the APIs while the <strong class="source-inline">HttpGet</strong> and <strong class="source-inline">HttpPut</strong> attributes determine the HTTP method associated with the API endpoints.</p>
			<p>ABP is 100% compatible with ASP.NET Core's standard structures, so you can refer to Microsoft's documentation <a id="_idIndexMarker918"/>to learn all the details of creating API Controllers: <a href="https://docs.microsoft.com/en-us/aspnet/core/web-api">https://docs.microsoft.com/en-us/aspnet/core/web-api</a>.</p>
			<p>When you implement layering in your solution, you generally find yourself creating controller classes, which wrap <a id="_idIndexMarker919"/>your application services. For example, assume that you have <strong class="source-inline">IProductAppService</strong>, which already implements the product-related use cases, and you want to expose its methods as HTTP API endpoints. The following example defines a controller that redirects all requests to the underlying application service:</p>
			<p class="source-code">[ApiController]</p>
			<p class="source-code">[Route("products")]</p>
			<p class="source-code">public class ProductController : ControllerBase</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IProductAppService _productAppService;</p>
			<p class="source-code">    public ProductController(</p>
			<p class="source-code">        IProductAppService productAppService)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _productAppService = productAppService;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    [HttpGet]</p>
			<p class="source-code">    public async Task&lt;ProductDto&gt; GetListAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        return await _productAppService.GetListAsync();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    [HttpPut]</p>
			<p class="source-code">    [Route("{id}")]</p>
			<p class="source-code">    public async Task UpdateAsync(Guid id, </p>
			<p class="source-code">                                  ProductUpdateDto input)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        await _productAppService.UpdateAsync(id, input);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>If we didn't use ABP <a id="_idIndexMarker920"/>Framework, we'd need to write such controllers to be able to define the route, HTTP method, and other HTTP-related details for the endpoint. However, ABP Framework can automatically expose your application services as HTTP API endpoints, as explained in the next section.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor434"/>Understanding the Auto API Controllers</h2>
			<p>ABP's Auto API Controller system converts your application services to API controllers by convention. To enable <a id="_idIndexMarker921"/>Auto API Controllers, we should configure <strong class="source-inline">AbpAspNetCoreMvcOptions</strong> as shown in the following code block:</p>
			<p class="source-code">Configure&lt;AbpAspNetCoreMvcOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.ConventionalControllers.Create(</p>
			<p class="source-code">        typeof(ApiDemoApplicationModule).Assembly);</p>
			<p class="source-code">});</p>
			<p>That configuration code is located in the UI or HTTP API layer of the solution (the <strong class="source-inline">ApiDemoHttpApiHostModule</strong> class of the <strong class="bold">ApiDemo.HttpApi.Host</strong> project for this example). The <strong class="source-inline">options.ConventionalControllers.Create</strong> method takes an <strong class="source-inline">Assembly</strong> object, finds all the application service classes inside that <strong class="source-inline">Assembly</strong>, and exposes them as controllers using pre-defined conventions. When you create a new ABP solution <a id="_idIndexMarker922"/>from the startup template, you already have that configuration inside your solution, so you don't need to configure it yourself.</p>
			<p>Assume that we have defined an application service as in the following example:</p>
			<p class="source-code">public class ProductAppService</p>
			<p class="source-code">    : ApiDemoAppService, IProductAppService</p>
			<p class="source-code">{</p>
			<p class="source-code">    public Task&lt;ProductDto&gt; GetListAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // TODO: implement</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public Task UpdateAsync(Guid id, </p>
			<p class="source-code">                            ProductUpdateDto input)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // TODO: implement</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Remember that the <strong class="source-inline">ProductAppService</strong> class is defined in the <strong class="source-inline">ApiDemo.Application</strong> project and the <strong class="source-inline">IProductAppService</strong> interface is defined in the <strong class="source-inline">ApiDemo.Application.Contracts</strong> project. We can run the application without any additional configuration to see the new HTTP API endpoints on Swagger UI:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/Figure_14.03_B17287.jpg" alt="Figure 14.3 – Auto API Controller on Swagger UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – Auto API Controller on Swagger UI</p>
			<p>ABP Framework configured ASP.NET Core so <strong class="source-inline">ProductAppService</strong> becomes a controller. ABP Framework determines the HTTP method automatically by the name of the related C# method. For <a id="_idIndexMarker923"/>example, methods starting with the <strong class="source-inline">Get</strong> prefix are considered HTTP GET methods. Routes are also automatically determined by convention. You can refer to the ABP documentation to learn about all the conventions <a id="_idIndexMarker924"/>and customization options for the HTTP method and route determination: <a href="https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers">https://docs.abp.io/en/abp/latest/API/Auto-API-Controllers</a>.</p>
			<p class="callout-heading">When to Define Controllers Manually</p>
			<p class="callout">When you use ABP Framework, you generally don't need to define the API controllers manually. However, you can still write the controllers in a standard way if you want to do so. An advantage of writing manual controllers is that you can fully use HTTP layer capabilities to define and shape your APIs.</p>
			<p>ABP Framework converts all the application services to API controllers in the configured assembly. If you want to disable it for a specific application service, you can use the <strong class="source-inline">[RemoteService]</strong> attribute with the <strong class="source-inline">false</strong> parameter as shown in the following example:</p>
			<p class="source-code">[RemoteService(false)]</p>
			<p class="source-code">public class ProductAppService</p>
			<p class="source-code">     : ApiDemoAppService, IProductAppService</p>
			<p class="source-code">{ /* ... */ }</p>
			<p>ABP Framework also enables ASP.NET Core's API explorer feature for the application service. In this way, your <a id="_idIndexMarker925"/>API endpoints become discoverable and are shown on Swagger UI. If you want to expose the HTTP endpoint but disable the API explorer, you can set the <strong class="source-inline">IsMetadataEnabled</strong> parameter of the <strong class="source-inline">[RemoteService]</strong> attribute to <strong class="source-inline">false</strong>, for example, <strong class="source-inline">[RemoteService(IsMetadataEnabled = false)]</strong>.</p>
			<p>As we've learned in this section, ABP can automate exposing your application services to remote clients, while you can still use your existing skills to create standard ASP.NET Core controllers whenever you need them. In the next section, we will explore the ways you consume your HTTP APIs from client applications.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor435"/>Consuming HTTP APIs</h1>
			<p>Consuming your HTTP APIs from your client applications typically requires a lot of common and repetitive <a id="_idIndexMarker926"/>logic to apply. You deal with authorization, object serialization, exception handling, and more in every HTTP request to the server. ABP Framework can completely automate that process via dynamic and generated (static) client-side proxies.</p>
			<p>We've already covered the practical usage of ABP's client-side proxy system in the <em class="italic">Consuming HTTP APIs</em> section of <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>, and in the <em class="italic">Consuming HTTP APIs</em> section of <a href="B17287_13_Epub_AM.xhtml#_idTextAnchor407"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with the Blazor WebAssembly UI</em>. So, I won't repeat it here but will bring it all together and fill in the missing points.</p>
			<p>Let's start with dynamic client proxies.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor436"/>Using ABP's dynamic client-side proxies</h2>
			<p>The dynamic proxy system <a id="_idIndexMarker927"/>allows us to consume server-side HTTP APIs with a simple configuration. The <em class="italic">dynamic</em> name states that the proxy code is generated dynamically at runtime.</p>
			<p>ABP's dynamic client proxy system supports two types of client applications: .NET and JavaScript.</p>
			<h3>Using dynamic .NET client proxies</h3>
			<p>ABP's startup solution separates the application layer into two projects. The project that ends with <strong class="source-inline">Application.Contracts</strong> contains the interfaces and <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>) for our <a id="_idIndexMarker928"/>application services, while the project ending with <strong class="source-inline">Application</strong> contains the implementation of these interfaces. The following <a id="_idIndexMarker929"/>figure shows the <strong class="source-inline">IProductAppService</strong> interface and the <strong class="source-inline">ProductAppService</strong> class inside the <strong class="source-inline">Application.Contracts</strong> and the <strong class="source-inline">Application</strong> projects in an example solution:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/Figure_14.04_B17287.jpg" alt="Figure 14.4 – The application layer, separated into two projects&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – The application layer, separated into two projects</p>
			<p>Separating the contracts from the implementation has an advantage: we can reuse the <strong class="source-inline">ApiDemo.Application.Contracts</strong> project from a .NET client application without making the client application reference the implementations of the application services.</p>
			<p>A .NET client application can reference the <strong class="source-inline">ApiDemo.Application.Contracts</strong> project and configure ABP's dynamic .NET client proxy system to be able to consume the HTTP APIs, just like consuming a local service. The following example shows that configuration, which is done in a client application (that configuration exists in the <strong class="source-inline">ApiDemoHttpApiClientModule</strong> class of the <strong class="source-inline">ApiDemo.HttpApi.Client</strong> project):</p>
			<p class="source-code">public override void ConfigureServices(</p>
			<p class="source-code">    ServiceConfigurationContext context)</p>
			<p class="source-code">{</p>
			<p class="source-code">    context.Services.AddHttpClientProxies(</p>
			<p class="source-code">        typeof(ApiDemoApplicationContractsModule).Assembly</p>
			<p class="source-code">    );</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">AddHttpClientProxies</strong> method takes an <strong class="source-inline">Assembly</strong> and creates dynamic proxies for all the application service interfaces in that <strong class="source-inline">Assembly</strong>. Here, we pass the assembly of the <strong class="source-inline">ApiDemo.Application.Contracts</strong> project by using the module class inside it. When you create <a id="_idIndexMarker930"/>a new ABP solution, you will see that configuration in the <strong class="source-inline">HttpApi.Client</strong> project. So, any .NET client application that references the <strong class="source-inline">HttpApi.Client</strong> project can directly consume your HTTP APIs without any configuration.</p>
			<p>With such a simple single configuration, we can inject any application service interface into the <strong class="source-inline">ApiDemo.Application.Contracts</strong> project and use it as we use a local service. See the <em class="italic">Consuming HTTP APIs</em> section of <a href="B17287_13_Epub_AM.xhtml#_idTextAnchor407"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with the Blazor WebAssembly UI</em>, for example usage in a Blazor WebAssembly client application.</p>
			<p>Once we configure and use the dynamic .NET client proxies, ABP does all the heavy logic and performs an HTTP request to the server for us. Surely, ABP should know the server's root URL to make the request. We can define it in the <strong class="source-inline">appsettings.json</strong> file of the client application as shown in the following example (there is an example of how to do that inside the <strong class="source-inline">ApiDemo.HttpApi.Client.ConsoleTestApp</strong> project):</p>
			<p class="source-code">{</p>
			<p class="source-code">  "RemoteServices": {</p>
			<p class="source-code">    "Default": {</p>
			<p class="source-code">      "BaseUrl": "http://localhost:53929/"</p>
			<p class="source-code">    } </p>
			<p class="source-code">  } </p>
			<p class="source-code">}</p>
			<p>As you can understand from this example, we can actually define multiple server endpoints. In this way, a client application can consume APIs from more than one server. The <strong class="source-inline">Default</strong> configuration one is used by default. You can add a second remote service configuration as shown in the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "RemoteServices": {</p>
			<p class="source-code">    "Default": {</p>
			<p class="source-code">      "BaseUrl": "http://localhost:53929/"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "BookStore": {</p>
			<p class="source-code">      "BaseUrl": "http://localhost:48392/"</p>
			<p class="source-code">    } </p>
			<p class="source-code">  } </p>
			<p class="source-code">}</p>
			<p>Then you should <a id="_idIndexMarker931"/>specify the <strong class="source-inline">remoteServiceConfigurationName</strong> parameter to the <strong class="source-inline">AddHttpClientProxies</strong> method to map the configurations:</p>
			<p class="source-code">context.Services.AddHttpClientProxies(</p>
			<p class="source-code">    typeof(BookStoreApplicationContractsModule).Assembly,</p>
			<p class="source-code">    remoteServiceConfigurationName: "BookStore"</p>
			<p class="source-code">);</p>
			<p>You can add retry logic on failure to the dynamic client proxies. Please refer to the documentation <a id="_idIndexMarker932"/>for more configuration options: <a href="https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients">https://docs.abp.io/en/abp/latest/API/Dynamic-CSharp-API-Clients</a>.</p>
			<p>ABP Framework provides a special API endpoint from the server application that exposes the API definition to the clients. This endpoint contains the mapping between the application service contracts and the HTTP API endpoints of the application. The URL of that endpoint is <strong class="source-inline">/api/abp/api-definition</strong> on the server. Client applications first read that <a id="_idIndexMarker933"/>API definition endpoint to learn how to make HTTP calls to the server.</p>
			<p>As you've seen, ABP makes it extremely easy to consume HTTP APIs from .NET clients. In the next section, we will look at consuming HTTP APIs in a JavaScript client.</p>
			<h3>Using dynamic JavaScript client proxies</h3>
			<p>Like the .NET dynamic client proxies, ABP dynamically creates proxies to consume your HTTP API endpoints from <a id="_idIndexMarker934"/>JavaScript applications. ABP Framework provides a special endpoint that returns a JavaScript file that contains proxy functions for all of your HTTP API endpoints. The URL of the endpoint is <strong class="source-inline">/Abp/ServiceProxyScript</strong>. This URL is already added to the application layout by the current theme, so you can directly consume the HTTP APIs.</p>
			<p>The following code block is a part of the service proxy script endpoint that contains the proxy functions for the <strong class="source-inline">ProductAppService</strong> class that we previously created in the <em class="italic">Understanding the Auto API Controllers</em> section of this chapter:</p>
			<p class="source-code">apiDemo.products.product.getList = function(ajaxParams) {</p>
			<p class="source-code">  return abp.ajax($.extend(true, {</p>
			<p class="source-code">    url: abp.appPath + 'api/app/product',</p>
			<p class="source-code">    type: 'GET'</p>
			<p class="source-code">  }, ajaxParams));</p>
			<p class="source-code">};</p>
			<p class="source-code">apiDemo.products.product.update = </p>
			<p class="source-code">    function(id, input, ajaxParams) {</p>
			<p class="source-code">  return abp.ajax($.extend(true, {</p>
			<p class="source-code">    url: abp.appPath + 'api/app/product/' + id + '',</p>
			<p class="source-code">    type: 'PUT',</p>
			<p class="source-code">    dataType: null,</p>
			<p class="source-code">    data: JSON.stringify(input)</p>
			<p class="source-code">  }, ajaxParams));</p>
			<p class="source-code">};</p>
			<p>As you can see in that example, ABP Framework has created two JavaScript functions for the <strong class="source-inline">ProductAppService</strong> class's methods. For example, we can call the <strong class="source-inline">getList</strong> function to get a list of <a id="_idIndexMarker935"/>the products, as shown in the following example:</p>
			<p class="source-code">apiDemo.products.product.getList()</p>
			<p class="source-code">  .then(function(result){</p>
			<p class="source-code">    // TODO: Process the result...</p>
			<p class="source-code">  });</p>
			<p>It's that easy! Authorization, validation, exception handling, <strong class="bold">CSRF</strong> (<strong class="bold">Cross-Site Request Forgery</strong>), and the other details are handled by ABP Framework. The result value will be the <a id="_idIndexMarker936"/>product list (array) returned by the server. You can see the <em class="italic">Using dynamic client proxies</em> section of <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>, for more examples and information about this topic.</p>
			<p>In the next section, we will explore an alternative way to use dynamic client proxies.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor437"/>Using ABP's static (generated) client proxies</h2>
			<p>The dynamic proxy system completely automates proxy generation to consume HTTP endpoints from the <a id="_idIndexMarker937"/>client applications. It generates code at runtime based on dynamically obtained endpoint configuration.</p>
			<p>On the other hand, the static client proxy system (that comes with ABP v5.0) doesn't require obtaining the API definitions at runtime since it generates the client proxy code at development time. The disadvantage of the static proxy system is that you need to re-generate the client proxy code whenever a server API changes. However, static proxies are slightly faster than dynamic proxies since the code generation is done at development time and no runtime information is required.</p>
			<p>In some scenarios, such as when your client consumes HTTP APIs of multiple microservices behind an API gateway, the dynamic client proxy system can't directly work because the API gateway cannot combine and return the API definitions of all microservices from a single endpoint. In such cases, using static client proxies that were generated at development time can save us.</p>
			<p>In any case if you want <a id="_idIndexMarker938"/>to use the static client proxies, you use the ABP CLI to generate the client code. The following section shows how to use the ABP CLI to generate static C# client proxy code.</p>
			<h3>Generating static C# client proxies</h3>
			<p>In order to create static proxies, the client application/project should have a reference to the application <a id="_idIndexMarker939"/>service interfaces defined by the server because the client proxies implement the same interfaces and are used just like the dynamic proxies. So, in practice, the client application should reference the <strong class="source-inline">Application.Contracts</strong> project of the target application.</p>
			<p>The server application should be running when we use the ABP CLI to generate the proxy classes since the ABP CLI gets the API definition from the server. Once the server is up and running, use the <strong class="source-inline">generate-proxy</strong> command in the root folder of the client application/project, as shown in the following example:</p>
			<p class="source-code">abp generate-proxy -t csharp -u https://localhost:44367</p>
			<p><strong class="source-inline">https://localhost:44367</strong> is the server application's URL here. The <strong class="source-inline">-t</strong> parameter specifies the client language, which is <strong class="source-inline">csharp</strong> for this example.</p>
			<p>The following figure shows the newly added project files after running the <strong class="source-inline">generate-proxy</strong> command:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/Figure_14.05_B17287.jpg" alt="Figure 14.5 – Generated client proxy files&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5 – Generated client proxy files</p>
			<p>First of all, the ABP CLI adds the <strong class="source-inline">app-generate-proxy.json</strong> file, which contains the API definition obtained from the <strong class="source-inline">https://localhost:44367/api/abp/api-definition</strong> endpoint for this example. ABP Framework then uses this file to get information about the API endpoint and make proper HTTP calls.</p>
			<p>The <strong class="source-inline">ProductClientProxy.Generated.cs</strong> file contains the proxy class, which implements the <strong class="source-inline">IProductAppService</strong> interface for this example. In this way, we can inject the <strong class="source-inline">IProductAppService</strong> interface into any class and use it just like a local service. ABP performs the necessary HTTP API calls for us.</p>
			<p><strong class="source-inline">ProductClientProxy.cs</strong> is a partial class to add your additional methods and customize the class. The <strong class="source-inline">ProductClientProxy.Generated.cs</strong> file is re-generated whenever <a id="_idIndexMarker940"/>you execute the <strong class="source-inline">generate-proxy</strong> command, so your changes are overwritten if you edit that class. However, the <strong class="source-inline">ProductClientProxy.cs</strong> file can be safely edited since ABP won't touch it again. It is left for you to customize the class.</p>
			<p>In the next section, we will generate JavaScript proxies to consume HTTP APIs from a browser application.</p>
			<h3>Generating static JavaScript client proxies</h3>
			<p>The ABP CLI can generate HTTP API client proxies for JavaScript clients, just like .NET clients. We can <a id="_idIndexMarker941"/>specify the <strong class="source-inline">-t</strong> parameter as <strong class="source-inline">js</strong> for JavaScript code generation:</p>
			<p class="source-code">abp generate-proxy -t js -u https://localhost:44367</p>
			<p>The JavaScript client proxy system works on jQuery and is compatible with ABP's MVC/Razor Pages UI. We've already seen the usage of JavaScript client code generation in the <em class="italic">Using static client proxies</em> section of <a href="B17287_12_Epub_AM.xhtml#_idTextAnchor356"><em class="italic">Chapter 12</em></a>, <em class="italic">Working with MVC/Razor Pages</em>. Please refer to that chapter to remember its usage.</p>
			<h3>Generating static Angular client proxies</h3>
			<p>While not covered in this book, ABP has a first-class Angular UI integration option. The ABP CLI's <strong class="source-inline">generate-proxy</strong> command <a id="_idIndexMarker942"/>also works natively with Angular UI. You can specify the <strong class="source-inline">-t</strong> parameter as <strong class="source-inline">ng</strong> to generate TypeScript proxy code for Angular:</p>
			<p class="source-code">abp generate-proxy -t ng -u https://localhost:44367</p>
			<p>The ABP CLI creates services and DTO classes on the Angular side, so you can directly inject proxies and consume the HTTP APIs without dealing with low-level HTTP details. Please refer <a id="_idIndexMarker943"/>to the ABP documentation to learn more about Angular client proxies: <a href="https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies">https://docs.abp.io/en/abp/latest/UI/Angular/Service-Proxies</a>.</p>
			<h3>Generating proxies for other client types</h3>
			<p>ABP provides client proxy generation for the client types it supports out of the box. It is suggested to use the <a id="_idIndexMarker944"/>ABP CLI's code generation for the <a id="_idIndexMarker945"/>supported client types. However, you may use another type of language, framework, or library on the client side and may want to generate the client proxies instead of manually writing them. In this case, you can use another tool that supports your platform since the ABP startup solution is compatible with Swagger/OpenAPI specifications. There are many tools around that can read the Swagger/OpenAPI specification and generate client-side proxy code for you. For example, the NSwag tool can generate client proxies for many different languages.</p>
			<p>We've learned how to consume server-side HTTP APIs from our client applications with ABP Framework. In the next section, we will learn how to establish a real-time communication channel with the server using Microsoft's SignalR library.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor438"/>Using SignalR with ABP Framework</h1>
			<p>Building REST-style HTTP APIs is good to consume server-side functionalities from client applications. However, it is limited – only the client application can call server APIs, and the server cannot <a id="_idIndexMarker946"/>normally start an operation on <a id="_idIndexMarker947"/>the client. WebSocket technology makes it possible to establish a two-way communication channel between the browser and the server to send messages to each other independently. So, with WebSocket, the server can notify the browser, send data, and trigger an action on the application.</p>
			<p>SignalR is a library by Microsoft that runs on WebSocket technology and simplifies the communication between the server and the client by abstracting WebSocket details. You can directly call the methods defined on the client from the server and vice versa.</p>
			<p>ABP Framework does not add much value to SignalR since it is already easy to use. However, it provides a simple integration package that automates some common tasks for you. In the next two sections, we will see how to install and configure SignalR in your solutions. Let's start with ABP's server-side <a id="_idIndexMarker948"/>SignalR <a id="_idIndexMarker949"/>integration package.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor439"/>Using the ABP SignalR integration package</h2>
			<p><strong class="source-inline">Volo.Abp.AspNetCore.SignalR</strong> is the NuGet package that adds the SignalR library to your server-side ABP <a id="_idIndexMarker950"/>application. You can install it using the ABP CLI. Open a command-line terminal in the root directory of the project where you want to add a server-side SignalR endpoint and execute the following command:</p>
			<p class="source-code">abp add-package Volo.Abp.AspNetCore.SignalR</p>
			<p>The ABP CLI will install the NuGet package and add ABP module dependency for you. It also adds SignalR to dependency injection and configures the hub endpoint. So, you don't need an additional configuration after the installation. The next sections explain how to create SignalR hubs and do additional configuration when you need to.</p>
			<h3>Creating hubs</h3>
			<p>SignalR hubs are used to create a high-level pipeline to handle client-server communication. You should <a id="_idIndexMarker951"/>define at least one hub to use SignalR. Creating a hub is pretty easy; just define a new class derived from the <strong class="source-inline">Hub</strong> base class:</p>
			<p class="source-code">public class MessagingHub : Hub</p>
			<p class="source-code">{</p>
			<p class="source-code">}</p>
			<p>ABP automatically registers the hub to the dependency injection system and configures the endpoint mapping. The URL of this example hub will be <strong class="source-inline">/signalr-hubs/messaging</strong>. The hub URL starts with <strong class="source-inline">/signalr-hubs/</strong> and continues with the hub class name converted to <em class="italic">kebab-case</em> without the <strong class="source-inline">Hub</strong> suffix. You can use the <strong class="source-inline">[HubRoute]</strong> attribute on top of the hub class to specify a different URL, as shown in the following example:</p>
			<p class="source-code">[HubRoute("/the-messaging-hub")]</p>
			<p class="source-code">public class MessagingHub : Hub</p>
			<p class="source-code">{</p>
			<p class="source-code">    //...</p>
			<p class="source-code">}</p>
			<p>As an alternative to the <strong class="source-inline">Hub</strong> class, you can inherit your hub from the <strong class="source-inline">AbpHub</strong> class. The <strong class="source-inline">AbpHub</strong> class provides some <a id="_idIndexMarker952"/>common services (such as <strong class="source-inline">ICurrentUser</strong>, <strong class="source-inline">ILogger</strong>, and <strong class="source-inline">IAuthorizationService</strong>) pre-injected as base properties, so you don't need to inject them manually.</p>
			<h3>Configuring hubs</h3>
			<p>ABP automatically maps your hubs and does the basic configuration. If you want to customize the hub <a id="_idIndexMarker953"/>configuration, you can do it in the <strong class="source-inline">ConfigureServices</strong> method of your module class, as shown in the following example:</p>
			<p class="source-code">Configure&lt;AbpSignalROptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.Hubs.AddOrUpdate(</p>
			<p class="source-code">        typeof(MessagingHub),</p>
			<p class="source-code">        config =&gt; //Additional configuration</p>
			<p class="source-code">        {</p>
			<p class="source-code">            config.RoutePattern = "/the-messaging-hub";</p>
			<p class="source-code">            config.ConfigureActions.Add(hubOptions =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                hubOptions.LongPolling.PollTimeout =</p>
			<p class="source-code">                    TimeSpan.FromSeconds(30);</p>
			<p class="source-code">            });</p>
			<p class="source-code">        }</p>
			<p class="source-code">    );</p>
			<p class="source-code">});</p>
			<p>This example configures <strong class="source-inline">MessagingHub</strong>, sets a custom route, and changes the <strong class="source-inline">LongPolling</strong> options.</p>
			<p>Using the ABP SignalR integration <a id="_idIndexMarker954"/>package doesn't add much value but simplifies integrating and configuring the SignalR library on the server side of our ABP applications. In the next section, we will see ways of connecting to a SignalR hub from a client application.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor440"/>Configuring SignalR clients</h2>
			<p>Connecting to a SignalR hub from a client application depends on your client type. In this section, I will explain <a id="_idIndexMarker955"/>how to install the SignalR client library to an ABP application with the ASP.NET Core MVC UI. Please refer to Microsoft's documentation for <a id="_idIndexMarker956"/>other client types, such as TypeScript or .NET clients: <a href="https://docs.microsoft.com/en-us/aspnet/core/signalr">https://docs.microsoft.com/en-us/aspnet/core/signalr</a>.</p>
			<p>To install SignalR in an ABP application with the ASP.NET Core MVC UI, first, add the <strong class="source-inline">@abp/signalr</strong> NPM package to your web project with the following command:</p>
			<p class="source-code">npm install @abp/signalr</p>
			<p>This command will install the package and update the <strong class="source-inline">package.json</strong> file in the web project. You should then run the ABP CLI's <strong class="source-inline">install-libs</strong> command to copy SignalR's JavaScript file under your project's <strong class="source-inline">wwwroot/libs</strong> folder.</p>
			<p>After the installation, you can use SignalR in your pages by importing SignalR's JavaScript file. You can use ABP's <strong class="source-inline">abp-script</strong> tag helper with the pre-defined bundle contributor for SignalR, as in the following example:</p>
			<p class="source-code">@using Volo.Abp.AspNetCore.Mvc.UI.Packages.SignalR</p>
			<p class="source-code">@section scripts {</p>
			<p class="source-code">    &lt;abp-script type=</p>
			<p class="source-code">        "typeof(SignalRBrowserScriptContributor)" /&gt;</p>
			<p class="source-code">}</p>
			<p>Using <strong class="source-inline">SignalRBrowserScriptContributor</strong> is the suggested approach since it always adds the script file from the right path with the right version, so you don't need to change it when you upgrade the SignalR package.</p>
			<p>Using SignalR with ABP <a id="_idIndexMarker957"/>Framework is no different from using it in a regular ASP.NET Core application. So, please refer to Microsoft's documentation if you are new to SignalR: <a href="https://docs.microsoft.com/en-us/aspnet/core/signalr">https://docs.microsoft.com/en-us/aspnet/core/signalr</a>. You can also find a fully working example in ABP's official samples: <a href="https://docs.abp.io/en/abp/latest/Samples/Index">https://docs.abp.io/en/abp/latest/Samples/Index</a>.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor441"/>Summary</h1>
			<p>In this chapter, you've learned different methods for server-client communication with ABP Framework and ASP.NET Core. ABP Framework automates that communication wherever possible.</p>
			<p>We started by creating REST-style HTTP APIs with the standard ASP.NET Core controllers and learned how ABP can automatically create such controllers using the application services.</p>
			<p>We then explored various ways of consuming the HTTP APIs from different clients. It becomes very simple to call server-side APIs from a client application when you use the dynamic or static client proxies of ABP Framework. While you can always go your own way, using the fully integrated client proxies is the best way to consume your own HTTP APIs.</p>
			<p>Finally, we saw how we can install SignalR in your ABP applications using the pre-built integration packages. SignalR, with the WebSocket technology, makes it possible to establish a two-way communication channel between the server and the client, so the server can also send messages to the client whenever it needs to.</p>
			<p>In the next chapter, we will learn about one of the most powerful structures of ABP Framework: modular application development.</p>
		</div>
	</body></html>