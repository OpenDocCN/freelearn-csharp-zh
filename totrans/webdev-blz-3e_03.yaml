- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Managing State – Part 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理状态 – 第1部分
- en: In this chapter, we will start looking at managing state. There is also a continuation
    of this chapter in *Chapter 11*, *Managing State – Part 2*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始探讨状态管理。本章的续篇是*第11章*，*管理状态 – 第2部分*。
- en: There are many different ways of managing state or persisting data. As soon
    as we leave a component, the state is gone. If we click the counter button from
    the sample pages, see the counter count up and then navigate away, we don’t know
    how many times we’ll need to click the counter button and have to start over.
    You can’t imagine how many times I have clicked that counter button over the years.
    It is such a simple yet powerful demo of Blazor and was a part of Steve’s original
    demo back in 2017.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 管理状态或持久化数据的方法有很多。一旦我们离开组件，状态就会消失。如果我们从示例页面点击计数器按钮，看到计数器计数增加然后导航离开，我们就不知道需要点击计数器按钮多少次，并不得不从头开始。您无法想象我多年来点击那个计数器按钮的次数。这是一个简单而强大的Blazor演示，也是Steve在2017年原始演示的一部分。
- en: To get started quickly, I have split this chapter in two. In this chapter, we
    are focusing on data access, and we will come back to more state management in
    the second part. Since this book focuses on Blazor, we will not explore how to
    connect to databases but create simple JSON storage instead.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速入门，我已经将本章分为两部分。在本章中，我们将专注于数据访问，而在第二部分中，我们将回到更多状态管理。由于本书专注于Blazor，因此我们不会探索如何连接到数据库，而是创建简单的JSON存储。
- en: In the first edition, we used Entity Framework to connect to a database, but
    there were people who were not used to working with Entity Framework, and they
    got stuck pretty fast. Using Entity Framework is a book all in itself, so I have
    opted not to include that in this book to remove any added complexity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一版中，我们使用Entity Framework连接到数据库，但有些人不习惯使用Entity Framework，他们很快就陷入了困境。使用Entity
    Framework本身就是一本书，所以我选择不将其包含在本书中，以消除任何额外的复杂性。
- en: In the repo on GitHub, you can find more examples of storing data in databases
    such as `RavenDB` or `MSSQL`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上的repo中，您可以找到更多将数据存储在数据库中的示例，例如`RavenDB`或`MSSQL`。
- en: We will use a common pattern called the **repository pattern**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个称为**仓储模式**的通用模式。
- en: We will also create an API to access the data from the JSON repository.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个API来访问JSON存储库中的数据。
- en: By the end of this chapter, you will have learned how to create a JSON repository
    and an API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何创建JSON存储库和API。
- en: 'We will cover the following main topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Creating a data project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据项目
- en: Adding the API to Blazor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将API添加到Blazor
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Make sure you have followed the previous chapters or use the `Chapter02` folder
    on GitHub as the starting point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经遵循了前面的章节，或者使用GitHub上的`Chapter02`文件夹作为起点。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter03)找到本章结果的源代码。
- en: Creating a data project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据项目
- en: 'There are many ways of persisting data: document databases, relational databases,
    and files, to name a few. To avoid complexity in the book, we will use the simplest
    way of creating blog posts for our project by storing them as JSON in a folder.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据的方式有很多：文档数据库、关系数据库和文件，仅举几例。为了避免本书的复杂性，我们将使用最简单的方式为我们的项目创建博客文章，将它们存储在文件夹中的JSON中。
- en: To save our blog posts, we will use JSON files stored in a folder, and to do
    so, we need to create a new project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存我们的博客文章，我们将使用存储在文件夹中的JSON文件，为此，我们需要创建一个新的项目。
- en: Creating a new project
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目
- en: We can create a new project from within Visual Studio (to be honest, that’s
    how I would do it), but to get to know the .NET CLI, let’s do it from the command
    line instead.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从Visual Studio内部创建一个新的项目（说实话，我会这样做），但为了了解.NET CLI，让我们从命令行操作。
- en: 'To create a new project, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的项目，请按照以下步骤操作：
- en: Open a PowerShell prompt.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开PowerShell提示符。
- en: Navigate to the `MyBlog` folder.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`MyBlog`文件夹。
- en: 'Create a class library (`classlib`) by typing the following command:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令创建一个类库（`classlib`）：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `dotnet` tool should now have created a folder called `Data`.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dotnet`工具现在应该已经创建了一个名为`Data`的文件夹。'
- en: 'We also need to create a project where we can put our models:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个项目，以便我们可以放置我们的模型：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the new projects to our solution by running the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will look for any solution in the current folder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We call the projects `Data` and `Data.Models` so their purpose will be easy
    to understand and they will be easy to find.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The default project has a `class1.cs` file – feel free to delete the file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create data classes to store our information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Creating data classes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we need to create a class for our blog post. To do that, we will go back
    to Visual Studio:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MyBlog` solution in Visual Studio (if it is not already open).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should now have a new project called `Data` in our solution. We might get
    a popup asking if we want to reload the solution; click **Reload** if so.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `Data.Models` project and select **Add** | **Class**. Name
    the class `BlogPost.cs` and click **Add**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Data.Models` project and select **Add** | **Class**. Name
    the class `Category.cs` and click **Add**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Data.Models` project and select **Add** | **Class**. Name
    the class `Tag.cs` and click **Add**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Data.Models` project and select **Add** | **Class**. Name
    the class `Comment.cs` and click **Add**.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Category.cs` and replace the content with the following code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Category` class contains `Id` and `Name`. It might seem strange that the
    `Id` property is a string, but this is because we will support multiple data storage
    types, including MSSQL, RavenDB, and JSON. A string is a great datatype to support
    all of these. `Id` is also nullable, so if we create a new category, we send in
    null as an `Id`.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Tag.cs` and replace the content with the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Tag` class contains an `Id` and `Name`.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Comment.cs` and replace the content with the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `comment` class could be part of the `Blogpost` class, but to use the same
    classes for different database types, we add comments as a separate entity referencing
    the blog post.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `BlogPost.cs` and replace the content with the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this class, we define the content of our blog post. We need an `Id` to identify
    the blog post, a title, some text (the article), and the publishing date. We also
    have a `Category` property in the class, which is of the `Category` type. In this
    case, a blog post can have only one category, and a blog post can contain zero
    or more tags. We define the `Tag` property with `List<Tag>`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: We have now created a couple of classes that we will use. I have kept the complexity
    of these classes to a minimum since we are here to learn about Blazor.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a way to store and retrieve the blog post information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will create an API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: We will create one API that has direct database access and one that will retrieve
    data through a Web API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Creating an API*, we will get back to creating the Web API.
    Why are we creating two APIs?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: We are not creating two APIs; we are creating a service with direct database
    access and a client that goes over the web and then uses direct database access.
    But we will use the same interface for both scenarios, making it possible to use
    one on the server and the other on the client.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是创建两个API；我们正在创建一个具有直接数据库访问的服务和一个通过网络进行操作然后使用直接数据库访问的客户端。但我们将使用相同的接口来处理这两种情况，使得在服务器上使用一个，在客户端使用另一个成为可能。
- en: In a real-world application, it would make more sense to access all the data
    in one way, not use both. But the point is to show that it is possible to mix
    and match and pick what is right for your scenario.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，以统一的方式访问所有数据会更合理，而不是使用两种方式。但重点是展示混合匹配并选择适合你场景的正确方式。
- en: 'We will start with the API with direct database access:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从具有直接数据库访问的API开始：
- en: Right-click on the `Data.Models` project, select **Add** | **New Folder**, and
    name it `Interfaces`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Data.Models`项目，选择**添加** | **新建文件夹**，并将其命名为`Interfaces`。
- en: Right-click on the `Interfaces` folder and select **Add** | **Class**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`Interfaces`文件夹，选择**添加** | **类**。
- en: In the list of different templates, select **Interface** and name it `IBlogApi.cs`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的模板列表中，选择**接口**，并将其命名为`IBlogApi.cs`。
- en: 'Open `IBlogApi.cs` and replace its content with the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`IBlogApi.cs`，并将其内容替换为以下内容：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alright, so here’s the deal with this `IBlogApi` thing. It’s basically our cheat
    sheet for handling all the blog stuff, like posts, comments, tags, and categories.
    Need to grab some posts or zap one out of existence? This interface is your go-to.
    It’s all about making our lives easier when we’re coding the blog, and keeping
    things tidy and straightforward.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，关于这个`IBlogApi`的事情是这样的。它基本上是我们处理所有博客内容的速查表，比如帖子、评论、标签和分类。需要获取一些帖子或者将其从存在中删除？这个接口就是你的首选。它主要是为了让我们在编写博客时生活更轻松，保持事情整洁和直接。
- en: Now, we have an interface for the API with the methods we need to list blog
    posts, tags, and categories, as well as to save (create/update) and delete them.
    Next, let’s implement the interface.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个API接口，其中包含了我们需要列出博客帖子、标签和分类，以及保存（创建/更新）和删除它们的方法。接下来，让我们实现这个接口。
- en: Implementing the interface
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: The idea is to create a class that stores our blog posts, tags, comments, and
    categories as JSON files on our file system. We will start with implementing the
    direct access implementation. This is the one we can use when accessing information
    directly from the database and not through a Web API. We will use the direct access
    implementation when running our components on the server and accessing the database
    and our Web API will also use it to access the database, but we will come back
    to that in *Chapter 7*, *Creating an API*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建一个类，将我们的博客帖子、标签、评论和分类作为JSON文件存储在我们的文件系统中。我们将从实现直接访问实现开始。当我们直接从数据库访问信息而不是通过Web
    API时，我们可以使用这个直接访问实现。当我们在服务器上运行我们的组件并访问数据库时，我们的Web API也将使用它来访问数据库，但我们将回到第7章，创建API。
- en: 'To implement the interface for the direct database access implementation, follow
    these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现直接数据库访问实现的接口，请按照以下步骤操作：
- en: First, to be able to access our data models, we need to add a reference to our
    `Data` models. Expand the `Data` project and right-click on the **Dependencies**
    node. Select **Add Project reference** and check the `Data.Models` project. Click
    **OK**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了能够访问我们的数据模型，我们需要在我们的`Data`模型中添加一个引用。展开`Data`项目，右键点击**依赖项**节点。选择**添加项目引用**，并勾选`Data.Models`项目。点击**确定**。
- en: Right-click on the **Dependencies** node once again, but select **Manage NuGet
    Packages**. In the **Browse** tab, search for `Microsoft.Extensions.Options` and
    click **Install**.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键点击**依赖项**节点，但选择**管理NuGet包**。在**浏览**选项卡中，搜索`Microsoft.Extensions.Options`并点击**安装**。
- en: We need a class to hold our settings.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个类来保存我们的设置。
- en: 'In the `Data` project, add a new class called `BlogApiJsonDirectAccessSetting.cs`
    and replace its content with:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Data`项目中，添加一个名为`BlogApiJsonDirectAccessSetting.cs`的新类，并将其内容替换为：
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the class where we hold our settings and the folders we will be using
    for storing our JSON files. `IOptions` is configured in `program` during the configuration
    of dependencies and is injected into all the classes that ask for a specific type.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个保存我们的设置以及我们将用于存储JSON文件的文件夹的类。`IOptions`在配置依赖项期间在`program`中配置，并注入到所有请求特定类型的类中。
- en: Next, we need to create a class for our API. Right-click on the `Data` project,
    select **Add** | **Class**, and name the class `BlogApiJsonDirectAccess.cs`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的 API 创建一个类。右键单击 `Data` 项目，选择 **添加** | **类**，并将类命名为 `BlogApiJsonDirectAccess.cs`。
- en: 'Open `BlogApiJsonDirectAccess.cs` and replace the code with the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BlogApiJsonDirectAccess.cs` 文件，并将代码替换为以下内容：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the start of our JSON direct access class. It references the `IBlogAPI`
    and we will implement each method the interface wants.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们的 JSON 直接访问类的开始。它引用了 `IBlogAPI`，我们将实现接口想要的所有方法。
- en: The error list should contain many errors since we haven’t implemented the methods
    yet. We are inheriting from the `IBlogApi`, so we know what methods to expose.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误列表应该包含许多错误，因为我们还没有实现这些方法。我们正在继承自 `IBlogApi`，因此我们知道要公开哪些方法。
- en: To be able to read settings, we also add a way to inject `IOptions`. By getting
    the settings this way, we don’t have to add any code – it can come from a database,
    a settings file, or even be hard coded.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够读取设置，我们也添加了一种注入 `IOptions` 的方式。通过这种方式获取设置，我们不需要添加任何代码——它可以从数据库、设置文件，甚至可以硬编码。
- en: This is my favorite way to get settings because this part of the code itself
    doesn’t know how to do it – instead, we add all our configurations using dependency
    injection.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我最喜欢的获取设置的方式，因为代码的这一部分本身并不知道如何实现——相反，我们通过依赖注入添加所有配置。
- en: 'Add the following code to the `BlogApiJsonDirectAccess` class:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `BlogApiJsonDirectAccess` 类中：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We get the injected setting and ensure we have the correct folder structure
    for our data.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们获取注入的设置并确保我们有正确的数据文件夹结构。
- en: 'Now, it’s time to implement the API, but first, we need a couple of helper
    methods that can load the data from our file system. To do this, we add the following
    code to our class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候实现 API 了，但首先，我们需要一些辅助方法来从我们的文件系统中加载数据。为此，我们将以下代码添加到我们的类中：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `LoadAsync` method is a generic method that allows us to load blog posts,
    tags, comments, and categories using the same method. It will load data from the
    file system whenever we ask for it. This would be a great place to put in some
    cache logic, but this is closer to what the implementation would look like if
    we used a database (we would always ask the database).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadAsync` 方法是一个泛型方法，允许我们使用相同的方法加载博客文章、标签、评论和类别。它将在我们请求时从文件系统中加载数据。这是一个放置一些缓存逻辑的好地方，但如果我们使用数据库（我们总是会询问数据库），实现将更接近这个样子。'
- en: 'Next, we will add a couple of methods to help manipulate the data, namely `SaveAsync`
    and `Delete`. Add the following methods:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加几个帮助方法来操作数据，即 `SaveAsync` 和 `Delete`。添加以下方法：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These methods are also generic to share as much code as possible and avoid repeating
    the code for every type of class (`BlogPost`, `Category`, `Comment,` and `Tag`).
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法也是泛型的，以便尽可能多地共享代码并避免为每种类型的类（`BlogPost`、`Category`、`Comment` 和 `Tag`）重复代码。
- en: 'Next, it’s time to implement the API by adding the methods to get blog posts.
    Add the following code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，是时候通过添加获取博客文章的方法来实现 API 了。添加以下代码：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `GetBlogPostsAsync` method takes a couple of parameters we will use later
    for paging. It will get the blog posts from our JSON storage and return the posts
    we are asking for, skipping and taking the right amount for our paging.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetBlogPostsAsync` 方法接受一些参数，我们将在稍后用于分页。它将从我们的 JSON 存储中获取博客文章，并返回我们请求的文章，跳过并取回正确的数量以供分页使用。'
- en: We also have a method that returns the current blog post count, which we will
    use for paging. Last but not least, we have `GetBlogPostAsync` for getting a single
    blog post from our JSON storage.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还有一个返回当前博客文章计数的函数，我们将用它来进行分页。最后但同样重要的是，我们有 `GetBlogPostAsync` 用于从我们的 JSON
    存储中获取单个博客文章。
- en: 'Now, we need to add the same methods for categories. To do this, add the following
    code:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为类别添加相同的方法。为此，添加以下代码：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Category` methods don’t have any support for paging. Otherwise, they should
    look familiar as they do almost the same as the blog post methods.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Category` 方法没有分页支持。否则，它们应该看起来很熟悉，因为它们几乎与博客文章方法相同。'
- en: 'Now, it’s time to do the same thing for tags. Add the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候为标签做同样的事情了。添加以下代码：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, the `tag` code is basically a copy of the code for categories.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，`tag` 代码基本上是类别代码的副本。
- en: 'We also need a way to retrieve the comments for a blog post. We will not create
    a method to retrieve one `comment`; we always get all the comments for a specific
    post. Add the following method:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来检索博客文章的评论。我们不会创建一个检索单个 `comment` 的方法；我们总是获取特定文章的所有评论。添加以下方法：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method will get all the comments for a blog post.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将获取博客文章的所有评论。
- en: We also need a couple of methods for saving the data, so next up, we’ll add
    methods for saving blog posts, categories, comments, and tags.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要几个用于保存数据的方法，所以接下来，我们将添加保存博客文章、分类、评论和标签的方法。
- en: 'Add the following code:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first thing we do is to check that the `id` of the item is not null. If
    it is, we create a new `Guid`. This is the `id` of the new item. And this is also
    going to be the name of the JSON files stored on the file system.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先要做的是检查项目的 `id` 是否为空。如果是，我们创建一个新的 `Guid`。这是新项目的 `id`。这将是存储在文件系统上的 JSON 文件的名称。
- en: 'We now have a method for saving and getting items. But sometimes, things don’t
    go as planned, and we need a way to delete the items that we have created. Next
    up, we will add some delete methods. Add the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了保存和获取项目的方法。但有时事情并不按计划进行，我们需要一种方法来删除我们创建的项目。接下来，我们将添加一些删除方法。添加以下代码：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code we just added calls the `DeleteAsync` method, which deletes the blog
    post, tag, category, etc.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码调用了 `DeleteAsync` 方法，该方法删除了博客文章、标签、分类等。
- en: Our JSON storage is done!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 JSON 存储已完成！
- en: In the end, there will be four folders stored on the file system, one for blog
    posts, one for categories, one for comments, and one for tags.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，文件系统上将有四个文件夹，一个用于博客文章，一个用于分类，一个用于评论，一个用于标签。
- en: The next step is to add and configure the Blazor project to use our new storage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将 Blazor 项目添加并配置为使用我们新的存储。
- en: Adding the API to Blazor
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 API 添加到 Blazor
- en: We now have a way to access JSON files stored on our file system. In the repo
    on GitHub, you can find more ways of storing our data with RavenDB or SQL Server,
    but be mindful to keep the focus on what is important (Blazor).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种访问存储在文件系统上的 JSON 文件的方法。在 GitHub 上的仓库中，你可以找到更多使用 RavenDB 或 SQL Server
    存储我们数据的方法，但请注意保持重点（Blazor）。
- en: 'Now it’s time to add the API to our Blazor Server project:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将 API 添加到我们的 Blazor 服务器项目中：
- en: 'In the `BlazorWebApp` project, **add a project reference** to the `Data` project.
    Open `Program.cs` and add the following namespaces:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BlazorWebApp` 项目中，**添加对 `Data` 项目的项目引用**。打开 `Program.cs` 并添加以下命名空间：
- en: '[PRE19]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code after .AddInteractiveWebAssemblyComponents();:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.AddInteractiveWebAssemblyComponents();` 之后添加以下代码：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are also saying that when we ask for an `IBlogAPI` we will get an instance
    of `BlogApiJsonDirectAccess` back from our dependency injection. We will return
    to dependency injection in *Chapter 4*, *Understanding Basic Blazor Components*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还说明，当我们请求 `IBlogAPI` 时，我们将从我们的依赖注入中获取 `BlogApiJsonDirectAccess` 的实例。我们将在 *第
    4 章*，*理解基本 Blazor 组件* 中返回依赖注入。
- en: Now, we can use our API to access the database in our Blazor project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的 API 来访问 Blazor 项目中的数据库。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us how to create a simple JSON repository for our data.
    We also learned that other alternatives could be found in the GitHub repo if you
    want to look at other options.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了我们如何创建一个简单的 JSON 存储库来存储我们的数据。我们还了解到，如果您想查看其他选项，GitHub 仓库中还有其他替代方案。
- en: We also created an interface to access the data, which we will use some more
    later in the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个接口来访问数据，我们将在本书的后面部分使用它。
- en: In the next chapter, we will learn about components, particularly the built-in
    components in Blazor templates. We will also create our first component using
    the API and repository we made in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习组件，特别是 Blazor 模板中的内置组件。我们还将使用本章中创建的 API 和存储库创建我们的第一个组件。
