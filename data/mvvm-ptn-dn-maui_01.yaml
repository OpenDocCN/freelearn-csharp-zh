- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Is the MVVM Design Pattern?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是MVVM设计模式？
- en: The **MVVM** or **Model-View-ViewModel** pattern is a very commonly used design
    pattern in the .NET ecosystem, where it has proven to be a good fit for front-end
    frameworks that utilize **XAML** to build graphical user interfaces. And it’s
    not hard to see why.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVM**或**模型-视图-视图模型**模式是.NET生态系统中非常常用的设计模式，其中它已被证明非常适合使用**XAML**构建图形用户界面的前端框架。这一点并不难理解。'
- en: This book will provide a good understanding of the MVVM design pattern and how
    to effectively apply it in **.NET MAUI** projects. It’s important to note that
    while we will focus on applying MVVM in the context of .NET MAUI, the MVVM pattern
    itself is not exclusive to the .NET ecosystem. It is a widely used design pattern
    that has gained popularity across various software development ecosystems, including
    frameworks like WPF, WinUI, and others. We’ll delve into various aspects of .NET
    MAUI to understand how it supports and enables the use of MVVM. Throughout the
    book, we’ll be building the “*Recipes!*” app as a practical example, showcasing
    various aspects of the MVVM pattern applied in .NET MAUI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将为您提供对MVVM设计模式及其在**.NET MAUI**项目中有效应用的良好理解。需要注意的是，虽然我们将专注于在.NET MAUI的上下文中应用MVVM，但MVVM模式本身并不仅限于.NET生态系统。它是一个广泛使用的设计模式，在包括WPF、WinUI等在内的各种软件开发生态系统中获得了流行。我们将深入研究.NET
    MAUI的各个方面，以了解它如何支持并启用MVVM的使用。在整个书中，我们将构建“*食谱!*”应用作为实际示例，展示在.NET MAUI中应用MVVM模式的各个方面。
- en: In this chapter, we’ll learn about the MVVM design pattern and its core components.
    We will look into what added value the pattern brings in terms of separation of
    concerns and why this is so important. A sample application will demonstrate the
    added value MVVM can bring to your code. Finally, we’ll discuss some common misconceptions
    about MVVM.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习MVVM设计模式及其核心组件。我们将探讨该模式在关注点分离方面带来的附加价值以及为什么这如此重要。一个示例应用将展示MVVM可以为您的代码带来的附加价值。最后，我们将讨论一些关于MVVM的常见误解。
- en: By the end of this chapter, you will understand what MVVM is, what its main
    components are, and what each component’s role is. You will also see what value
    MVVM adds in terms of the testability and maintainability of your code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解MVVM是什么，其主要组件是什么，以及每个组件的作用。您还将看到MVVM在提高代码的可测试性和可维护性方面带来的价值。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: MVVM’s core components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM的核心组件
- en: Separation of concerns matters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离很重要
- en: MVVM in action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM的实际应用
- en: Common misconceptions about MVVM
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于MVVM的常见误解
- en: Before diving into the details of MVVM in .NET MAUI, it’s essential to familiarize
    ourselves with the core components of the MVVM pattern. In the following section,
    we’ll define the key terminologies to ensure we have a solid foundation and a
    shared understanding moving forward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨.NET MAUI中MVVM的细节之前，熟悉MVVM模式的核心组件至关重要。在接下来的部分中，我们将定义关键术语，以确保我们有一个坚实的基础和共同的了解，以便继续前进。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Although this chapter gives a theoretical overview of MVVM, later there is
    some code showing MVVM in action so you can start seeing the value this pattern
    brings. To implement this sample yourself, you’ll need the following: *Visual
    Studio 2022 (17.3 or greater), or any IDE that allows you to create .NET MAUI
    apps*. Near the end of [*Chapter 2*](B20941_02.xhtml#_idTextAnchor036)*, What
    Is .NET MAUI?*, we’ll be looking at how to get your machine ready for developing
    .NET MAUI apps. The sample code can also be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章提供了MVVM的理论概述，但稍后会有一些代码展示MVVM的实际应用，以便您开始看到这种模式带来的价值。要自己实现此示例，您需要以下条件：*Visual
    Studio 2022（17.3或更高版本），或任何允许您创建.NET MAUI应用的IDE*。在[*第2章*](B20941_02.xhtml#_idTextAnchor036)*，什么是.NET
    MAUI？*的末尾，我们将探讨如何为开发.NET MAUI应用准备您的机器。示例代码也可以在GitHub上找到：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI)。
- en: Looking at MVVM’s core components
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看MVVM的核心组件
- en: MVVM provides a very clear way to separate UI from business logic, promoting
    code reusability, maintainability, and testability while allowing flexible UI
    design and changes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM提供了一种非常清晰的方式来分离UI和业务逻辑，促进代码的可重用性、可维护性和可测试性，同时允许灵活的UI设计和更改。
- en: Having business logic living in the code-behind quickly becomes challenging
    as applications grow in size and complexity. Code-behind refers to the practice
    of placing the business logic within the same file as the user interface elements,
    often resulting in a significant amount of code being invoked through event handlers.
    This frequently results in a tight coupling between UI elements and the underlying
    business logic, as UI elements are directly referenced and manipulated within
    the code. As a result, making adjustments to the UI and performing unit testing
    can become more difficult. Later on in this chapter, in the *MVVM in action* section,
    we will see what it means to have business logic in the code-behind and how that
    complicates maintainability, testing, et cetera.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序规模和复杂性的增长，将业务逻辑放在代码背后（code-behind）很快就会变得具有挑战性。代码背后指的是将业务逻辑放置在与用户界面元素相同的文件中的做法，这通常会导致大量代码通过事件处理器被调用。这通常会导致UI元素和底层业务逻辑之间的紧密耦合，因为UI元素在代码中被直接引用和操作。因此，调整UI和执行单元测试可能会变得更加困难。在本章的“MVVM实战”部分，我们将看到在代码背后放置业务逻辑意味着什么，以及它如何复杂化维护性、测试等。
- en: At first glance, MVVM might be slightly overwhelming or confusing. In order
    to fully understand what the pattern is all about and why it is so popular with
    XAML developers, we first need to dissect the MVVM pattern and look at its core
    components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，MVVM可能有点令人不知所措或困惑。为了完全理解这个模式是什么以及为什么它如此受XAML开发者的欢迎，我们首先需要剖析MVVM模式并查看其核心组件。
- en: 'The name of the pattern already gives away three essential core components:
    the **Model**, the **View**, and the **ViewModel**. There are also two supporting
    elements that are crucial for efficiently using MVVM: **Commands** and **data
    binding**. Each of these elements has its own distinct role and responsibilities.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的名称已经揭示了三个基本的核心组件：**模型**、**视图**和**视图模型**。还有两个对于高效使用MVVM至关重要的辅助元素：**命令**和**数据绑定**。这些元素中的每一个都有自己的独特角色和责任。
- en: 'The following diagram shows MVVM’s core components and how they interact with
    each other:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MVVM的核心组件以及它们之间是如何相互作用的：
- en: '![Figure 1.1 – Core components of MVVM](img/B20941_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – MVVM的核心组件](img/B20941_01_01.jpg)'
- en: Figure 1.1 – Core components of MVVM
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – MVVM的核心组件
- en: If you want to use the MVVM pattern effectively, it’s important that you understand
    not only the responsibilities of each component but also how they interact with
    each other. At a high level, the View knows about the ViewModel, and the ViewModel
    knows about the Model, but the Model is unaware of the ViewModel. This separation
    prevents tight coupling between the UI and business logic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要有效地使用MVVM模式，重要的是你不仅要了解每个组件的责任，还要了解它们之间是如何相互作用的。在较高层次上，视图（View）了解视图模型（ViewModel），而视图模型（ViewModel）了解模型（Model），但模型（Model）对视图模型（ViewModel）并不知情。这种分离防止了UI和业务逻辑之间的紧密耦合。
- en: In order to use the MVVM pattern efficiently and effectively, it is important
    that you understand how to organize your app code into suitable classes and how
    these classes interact with each other. Now, let’s look into the core components.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用MVVM模式，重要的是要了解如何将应用程序代码组织成合适的类，以及这些类是如何相互作用的。现在，让我们来看看核心组件。
- en: Model
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The Model is responsible for representing the data and business logic of the
    application. It encapsulates the data and provides a way to manipulate it. The
    Model can communicate with other components within the application, such as a
    database or a web service.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模型负责表示应用程序的数据和业务逻辑。它封装了数据并提供了一种操作它的方法。模型可以与应用程序内的其他组件通信，例如数据库或Web服务。
- en: It is often implemented using classes that represent the objects in the application’s
    domain, such as customers, orders, or products. These classes typically contain
    properties that represent the attributes of the objects and methods that define
    the behavior of the objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常使用代表应用程序领域对象的类来实现，例如客户、订单或产品。这些类通常包含表示对象属性的属性和定义对象行为的方法。
- en: The Model is designed to be independent of the UI framework used in the application.
    As a result, it can be reused in other applications if needed. It can be maintained
    and tested in isolation, separately from the application’s UI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模型被设计成与应用程序中使用的UI框架独立。因此，如果需要，它可以在其他应用程序中重用。它可以独立于应用程序的UI进行维护和测试。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Often, it’s unclear to developers who are new to MVVM what type of object the
    Model can or should be: **Data Transfer Objects** (**DTOs**), **Plain Old CLR
    Objects** (**POCOs**), domain entities, proxy objects, services, and so on. All
    these types of objects can be seen as the Model.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始接触 MVVM 的开发者来说，往往不清楚模型可以是或应该是哪种类型的对象：**数据传输对象**（**DTOs**）、**普通 CLR 对象**（**POCOs**）、领域实体、代理对象、服务等等。所有这些类型的对象都可以被视为模型。
- en: Moreover, in most cases, the Model is a combination of different types of objects.
    Don’t see the Model as a single thing. In fact, it’s everything ‘outside’ the
    View and ViewModel – it’s the application’s domain and business logic. Ultimately,
    the choice of Model type will depend on the specific requirements, use case, and
    architecture of the application. Some developers may prefer to use DTOs for simplicity
    and ease of use, while others may prefer to use domain entities for better encapsulation
    and consistency with the domain model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在大多数情况下，模型（Model）是不同类型对象的组合。不要将模型视为单一的事物。实际上，它包括视图和 ViewModel 以外的所有“外部”内容——它是应用程序的领域和业务逻辑。最终，模型类型的选取将取决于应用程序的具体需求、用例和架构。一些开发者可能更喜欢使用
    DTOs（数据传输对象）以实现简单易用，而其他人可能更喜欢使用领域实体以实现更好的封装和与领域模型的保持一致。
- en: However, regardless of the specific type of Model being used, it’s important
    to keep the business logic within the Model ‘layer’ and avoid it in the ViewModel.
    This helps to maintain separation of concerns and keeps the ViewModel focused
    on presentation logic, while the Model focuses on business logic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论使用的是哪种具体的模型类型，都重要的是将业务逻辑保持在模型“层”内，并在 ViewModel 中避免它。这有助于保持关注点的分离，并使 ViewModel
    专注于展示逻辑，而模型则专注于业务逻辑。
- en: View
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图（View）
- en: The View is responsible for presenting the data to the user. It consists of
    (UI) elements, such as buttons, labels, collections, and inputs. The View receives
    input or actions from the user and communicates with the ViewModel so it can react
    to those interactions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 视图负责向用户展示数据。它由（UI）元素组成，例如按钮、标签、集合和输入。视图接收来自用户的输入或操作，并与 ViewModel 通信，以便它可以对这些交互做出反应。
- en: In .NET MAUI, the View is often implemented using XAML, which is a markup language
    used to define the UI elements and layouts. The XAML file defines the structure
    of the UI and its bindings to the ViewModel. It’s important to note that while
    the MVVM pattern is often associated with XAML-based UIs, its principles are not
    limited to a specific UI framework. The MVVM pattern can be applied in other UI
    frameworks as well. In .NET MAUI, most apps use XAML for defining the UI, but
    it’s also possible to create the UI entirely in C#. Even when taking this approach,
    developers can still effectively apply the MVVM pattern to separate the concerns
    of the View, ViewModel, and Model.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，视图通常使用 XAML 实现，这是一种用于定义 UI 元素和布局的标记语言。XAML 文件定义了 UI 的结构及其与 ViewModel
    的绑定。需要注意的是，尽管 MVVM 模式通常与基于 XAML 的 UI 相关联，但其原则并不局限于特定的 UI 框架。MVVM 模式也可以应用于其他 UI
    框架。在 .NET MAUI 中，大多数应用程序使用 XAML 定义 UI，但也可以完全使用 C# 创建 UI。即使采用这种方法，开发者仍然可以有效地应用
    MVVM 模式来分离视图、ViewModel 和模型的关注点。
- en: The most important aspect of the View is that it should be designed to be as
    simple as possible, without any business rules or logic. Its main purpose is to
    present data to the user and receive input from them. The View’s focus should
    be on presentation logic, including formatting and layout, and it should not include
    any business logic or application logic to maintain proper separation of concerns
    in MVVM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 视图最重要的方面是它应该尽可能简单，没有任何业务规则或逻辑。其主要目的是向用户展示数据并接收他们的输入。视图的焦点应放在展示逻辑上，包括格式化和布局，并且不应包含任何业务逻辑或应用程序逻辑，以在
    MVVM 中保持适当的关注点分离。
- en: Tip
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: By keeping the View simple and focused on presentation logic, the code can be
    easier to maintain and test. It also enables the UI to be changed without affecting
    the underlying business logic, allowing for greater flexibility in adapting and
    evolving the application over time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持视图简单并专注于展示逻辑，代码可以更容易维护和测试。它还使得在不影响底层业务逻辑的情况下更改 UI 成为可能，从而在适应和随时间演变应用程序方面提供了更大的灵活性。
- en: The View, whether it is implemented using XAML or C#, is the application’s UI
    layer. Essentially, it is the collection of UI components, such as pages and controls,
    that make up the user interface.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 视图（The View），无论它是使用 XAML 还是 C# 实现的，都是应用程序的用户界面层。本质上，它是构成用户界面的 UI 组件集合，例如页面和控制元素。
- en: ViewModel
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewModel
- en: 'The ViewModel sits in between the Model and the View. It’s the “glue” between
    the UI and the business logic. Its responsibility is to expose data to the View
    for display and to handle any user input or UI events. It provides an interface
    for the View to interact with the Model, which contains the actual data and business
    logic of the application. Let’s delve into what the ViewModel does, step by step:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel 位于 Model 和 View 之间。它是 UI 和业务逻辑之间的“粘合剂”。其职责是向 View 暴露数据以供显示，并处理任何用户输入或
    UI 事件。它为 View 提供了一个与包含应用程序实际数据和业务逻辑的 Model 交互的接口。让我们逐步深入了解 ViewModel 的功能：
- en: '**Exposing data**: The ViewModel retrieves data from the Model and exposes
    it to the View through public properties. These properties are usually bound to
    elements in the View, such as text boxes or labels. This way, the data from the
    Model gets displayed on the screen.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**暴露数据**：ViewModel 从 Model 中检索数据并通过公共属性将其暴露给 View。这些属性通常绑定到 View 中的元素，例如文本框或标签。这样，Model
    中的数据就会显示在屏幕上。'
- en: '**Reflecting changes**: Now, you might be wondering what happens when the user
    changes something on the screen. That’s where data binding comes in. Data binding
    is like a live channel of communication between the View and the ViewModel. When
    the user modifies data in the View, the ViewModel is instantly notified and updates
    its properties accordingly. Similarly, if something changes in the ViewModel,
    the View gets updated too.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**反映更改**：现在，你可能想知道当用户在屏幕上更改某些内容时会发生什么。这就是数据绑定发挥作用的地方。数据绑定就像 View 和 ViewModel
    之间的一条实时通信通道。当用户在 View 中修改数据时，ViewModel 会立即得到通知并相应地更新其属性。同样，如果 ViewModel 中发生更改，View
    也会得到更新。'
- en: '**Handling user interactions**: The ViewModel doesn’t just passively provide
    data; it’s also responsible for dealing with user interactions, such as button
    clicks and text input. For example, if there’s a **Save** button on the View,
    the ViewModel needs to know what to do when the user clicks on it.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理用户交互**：ViewModel 不仅被动地提供数据；它还负责处理用户交互，例如按钮点击和文本输入。例如，如果 View 中有一个 **保存**
    按钮，ViewModel 需要知道当用户点击它时应该做什么。'
- en: '**Updating the Model**: When the user interacts with the UI and makes changes,
    the ViewModel plays an essential role in updating the Model. The ViewModel takes
    the user’s changes and translates them into actions that the Model can understand
    and process.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更新 Model**：当用户与 UI 交互并做出更改时，ViewModel 在更新 Model 中发挥着至关重要的作用。ViewModel 接收用户的更改并将它们转换为
    Model 可以理解和处理的行为。'
- en: The ViewModel acts as an intermediary that handles the flow of data and actions
    between the View and the Model, ensuring that the user interface accurately represents
    the underlying data and responds correctly to user interactions. This modular
    approach, where it handles specific responsibilities separately from the View
    and Model, contributes to cleaner and more maintainable code. Finally, it’s essential
    to understand that the ViewModel should not be tied to any specific UI framework.
    Being independent of a UI framework allows it to be shared across different applications
    and facilitates easier testing in isolation from the rest of the application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel 充当中间人，处理 View 和 Model 之间数据和行为的流动，确保用户界面准确反映底层数据并对用户交互做出正确响应。这种模块化方法，即它将特定责任与
    View 和 Model 分开处理，有助于编写更干净、更易于维护的代码。最后，重要的是要理解 ViewModel 不应与任何特定的 UI 框架绑定。独立于
    UI 框架允许它在不同的应用程序之间共享，并便于从应用程序的其他部分独立进行测试。
- en: Commands
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令
- en: 'Commands are an important concept used to represent actions that can be triggered
    by the UI. They are a way for the View to communicate user actions to the ViewModel.
    A Command is an object that implements the `ICommand` interface, which defines
    two methods: `Execute` and `CanExecute`. The `Execute` method is called when the
    Command is triggered, while the `CanExecute` method is used to determine whether
    the Command can be executed in its current state.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是用于表示可以由 UI 触发的行为的重要概念。它是 View 将用户操作传达给 ViewModel 的方式。命令是一个实现 `ICommand` 接口的对象，该接口定义了两个方法：`Execute`
    和 `CanExecute`。当命令被触发时调用 `Execute` 方法，而 `CanExecute` 方法用于确定命令在其当前状态下是否可以执行。
- en: 'Commands can be seen as the equivalent of events in traditional event-driven
    programming. Both Commands and events serve as mechanisms to handle user actions
    or other triggers in an application. For instance, when the user clicks a button
    in the View, a Command in the ViewModel gets triggered, and the ViewModel takes
    appropriate actions such as saving data or fetching new information. Commands
    are highly versatile and are not limited to buttons. They can be associated with
    various UI elements such as menu items, toolbar buttons, or even gesture controls.
    Let’s take a practical example: suppose you have a text editor application. You
    could have a Command associated with the `Execute` method is called and then performs
    the necessary action.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 命令可以看作是传统事件驱动编程中事件的等价物。命令和事件都作为处理应用程序中用户操作或其他触发器的机制。例如，当用户在视图中点击按钮时，ViewModel中的命令被触发，ViewModel采取适当的行动，例如保存数据或获取新信息。命令非常灵活，不仅限于按钮。它们可以与各种UI元素相关联，如菜单项、工具栏按钮，甚至是手势控制。让我们举一个实际例子：假设你有一个文本编辑应用程序。你可以有一个与`Execute`方法关联的命令，当调用该方法时执行必要的操作。
- en: One of the key benefits of using Commands in the MVVM pattern is that they allow
    for better separation of concerns between the View and the ViewModel. By using
    Commands, the View can be designed without knowing anything about the underlying
    functionality that is associated with a particular UI element. This means that
    the ViewModel can handle the entire logic associated with the Command, without
    having to be tightly coupled to the UI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM模式中使用命令的一个关键好处是，它们允许视图和ViewModel之间更好地分离关注点。通过使用命令，视图可以设计而无需了解与特定UI元素相关的底层功能。这意味着ViewModel可以处理与命令相关的所有逻辑，而无需与UI紧密耦合。
- en: In order to bind a Command to a UI element in the View, the Command needs to
    be exposed by the ViewModel as a public property. The View can then bind to this
    property using data binding. When a Command is bound to a UI element in the View,
    the UI element is listening for an event such as a button click to occur. When
    that event is triggered, the Command’s `Execute` method, which contains the code
    that should be executed in response to the event, is called.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将命令绑定到视图中的UI元素，命令需要由ViewModel作为公共属性公开。然后视图可以使用数据绑定绑定到这个属性。当命令绑定到视图中的UI元素时，该UI元素会监听事件，例如按钮点击。当该事件被触发时，包含响应事件的代码的命令的`Execute`方法被调用。
- en: Overall, Commands are a powerful and flexible concept in the MVVM pattern, which
    enables better separation of concerns between the View and the ViewModel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，命令是MVVM模式中一个强大且灵活的概念，它使得视图和ViewModel之间的关注点分离更加有效。
- en: More about Commands
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命令的更多信息
- en: We’ll dive into much more detail about Commands and how to use them in practice
    in [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*, Data Binding Building Blocks
    in .**NET MAUI*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B20941_03.xhtml#_idTextAnchor051)中深入了解命令及其在实际中的应用，即**.NET MAUI**中的数据绑定构建块。
- en: Data binding
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Data binding is a core feature of MVVM that enables the ViewModel to communicate
    with the View and the View with the ViewModel in a loosely coupled manner. Data
    binding allows you to bind data properties in the ViewModel to UI elements in
    the View, such as entry fields, labels, and list views. It is used to synchronize
    the data between the View and the ViewModel. When the data in the ViewModel changes,
    the data binding engine updates the View, and vice versa, depending on how the
    binding is configured. This allows the UI to reflect the current state of the
    application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是MVVM的核心特性，它允许ViewModel以松耦合的方式与视图通信，以及视图与ViewModel之间的通信。数据绑定允许您将ViewModel中的数据属性绑定到视图中的UI元素，例如输入字段、标签和列表视图。它用于同步视图和ViewModel之间的数据。当ViewModel中的数据发生变化时，数据绑定引擎会更新视图，反之亦然，具体取决于绑定的配置方式。这允许UI反映应用程序的当前状态。
- en: 'The binding process involves three components: a **source** object (the ViewModel),
    a **target** object (the UI element), and a **binding expression** that specifies
    how the two objects should be connected.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定过程涉及三个组件：一个**源**对象（ViewModel），一个**目标**对象（UI元素），以及一个**绑定表达式**，该表达式指定了两个对象应该如何连接。
- en: 'Data can flow in different directions: from the ViewModel to the View, the
    other way around, or both. Here are the ways data can flow:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以以不同的方向流动：从ViewModel到视图，反之亦然，或者两者都流动。以下是数据流动的方式：
- en: '**One-way**: From the ViewModel to the View, this allows the values of the
    properties on the ViewModel to be displayed on the View. This type of binding
    is typically used when updates on the ViewModel should automatically update the
    value on the View.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向**: 从视图模型到视图，这允许视图模型上属性的值在视图中显示。这种类型的绑定通常用于当视图模型的更新应自动更新视图上的值时。'
- en: '**One-way-to-source**: The exact opposite of one-way, the data only flows from
    the View to the ViewModel. Values entered in the View will automatically be reflected
    on the ViewModel.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单向到源**: 与单向相反，数据只从视图流向视图模型。在视图中输入的值将自动反映在视图模型上。'
- en: '**One-time**: Like one-way, the data flows from the ViewModel to the View,
    but the data binding engine will not listen for any changes that occur on the
    bound property. Once the initial value is displayed on the UI, any subsequent
    changes to the property will not be reflected on the View. This can have a significant
    positive performance impact when doing a lot of data binding.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次性**: 与单向类似，数据从视图模型流向视图，但数据绑定引擎将不会监听绑定属性上发生的任何更改。一旦初始值在UI上显示，该属性的任何后续更改都不会反映在视图中。这在进行大量数据绑定时可以产生显著的正面性能影响。'
- en: '**Two-way**: Data flows in two ways; from the View to the ViewModel and from
    the ViewModel to the View. Changes made to the data in the UI are automatically
    propagated back to the ViewModel. A common scenario for using two-way data binding
    is when displaying a property in the View that the user can modify. In this case,
    the property is typically bound to an input field using two-way data binding.
    This allows the initial value of the property to be displayed in the input field,
    and any changes made by the user to be automatically reflected to the ViewModel,
    without the need for additional event handling or manual updates.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向**: 数据以两种方式流动；从视图到视图模型，以及从视图模型到视图。对UI中数据的更改会自动传播回视图模型。使用双向数据绑定的常见场景是在视图中显示用户可以修改的属性。在这种情况下，该属性通常使用双向数据绑定绑定到一个输入字段。这允许属性的初始值在输入字段中显示，并且用户所做的任何更改都会自动反映到视图模型，无需额外的事件处理或手动更新。'
- en: Data binding is a very powerful concept and an essential component in the MVVM
    pattern. It allows the ViewModel to expose data and behavior as simple properties
    to the View, in a way that is independent of the UI framework. Through data binding,
    these properties can be bound to the UI in a loosely coupled manner. By using
    data binding, the View and ViewModel in MVVM can be synchronized seamlessly without
    the need for any manual code. The binding mode determines how changes in the data
    are propagated between the View and ViewModel. Additionally, data binding allows
    the View to communicate user input back to the ViewModel through Commands, which
    can then update the Model.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是一个非常强大的概念，是MVVM模式中的一个基本组件。它允许视图模型以简单的属性形式向视图公开数据和行为，这种方式与UI框架无关。通过数据绑定，这些属性可以以松耦合的方式绑定到UI。通过使用数据绑定，MVVM中的视图和视图模型可以无缝同步，无需任何手动代码。绑定模式决定了数据如何在视图和视图模型之间传播。此外，数据绑定还允许视图通过命令将用户输入回传到视图模型，然后视图模型可以更新模型。
- en: More about data binding
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于数据绑定的信息
- en: Everything you need to know about data binding and how to effectively use it
    in .NET MAUI is covered thoroughly in [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*,
    Data Binding Building Blocks in .NET MAUI*, and [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069)*,
    Data Binding in .**NET MAUI*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B20941_03.xhtml#_idTextAnchor051)*数据绑定构建块在.NET MAUI中*和[*第4章*](B20941_04.xhtml#_idTextAnchor069)*.NET
    MAUI中的数据绑定*中，详细介绍了关于数据绑定以及如何在.NET MAUI中有效使用它的所有必要信息。
- en: Now that we have a good understanding of MVVM’s core components and have gained
    insights into each component’s responsibility, let’s discuss in a bit more detail
    why MVVM matters and what value it adds.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对MVVM的核心组件有了很好的理解，并对每个组件的责任有了深入了解，让我们更详细地讨论一下为什么MVVM很重要以及它增加了什么价值。
- en: Separation of concerns matters
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点分离很重要
- en: '**Separation of concerns** is an important principle in software development
    that aims to divide software design and implementation into distinct parts, each
    with a specific and well-defined responsibility. This principle helps developers
    create more maintainable and flexible applications by reducing the complexity
    of each individual component and allowing for more modular and reusable code.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**关注点分离**是软件开发中的一个重要原则，旨在将软件设计和实现划分为具有特定和明确责任的不同部分。这个原则通过降低每个组件的复杂性，允许更模块化和可重用的代码，帮助开发者创建更可维护和灵活的应用程序。'
- en: In practical terms, separation of concerns means that different aspects of a
    system are separated and dealt with independently, without overlapping concerns.
    This is achieved by creating distinct layers or modules, each with its own well-defined
    responsibilities and interfaces, and minimizing the dependencies between them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，关注点分离意味着将系统的不同方面分离并独立处理，不重叠关注点。这是通过创建具有各自明确责任和接口的独立层或模块，并最小化它们之间的依赖关系来实现的。
- en: Let’s consider the example of a restaurant’s management system. In such a system,
    there could be several concerns like table reservation, order taking, kitchen
    operations, and billing. According to the principle of separation of concerns,
    each of these areas should be handled by a separate module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一家餐厅的管理系统为例。在这样的系统中，可能会有几个关注点，如餐桌预订、点餐、厨房操作和结账。根据关注点分离的原则，这些领域中的每一个都应该由一个独立的模块来处理。
- en: Each module has its own set of responsibilities and would communicate with others
    through well-defined interfaces. For example, when a customer orders a dish, the
    order-taking module communicates with the kitchen operations module so that the
    dish can be prepared.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都有自己的责任集，并且会通过定义良好的接口与其他模块进行通信。例如，当顾客点菜时，点餐模块会与厨房操作模块通信，以便准备菜品。
- en: This separation means that if you need to make changes to how table reservations
    work, you can do so without affecting kitchen operations or billing. This separation
    keeps the codebase more organized, easier to maintain, and allows for focused
    testing of individual modules.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离意味着，如果您需要更改餐桌预订的工作方式，您可以在不影响厨房操作或结账的情况下进行更改。这种分离使代码库更加有序，更容易维护，并允许对单个模块进行集中的测试。
- en: Let’s explore how separation of concerns enhances both maintainability and testability.
    These are the two crucial aspects that are vital to the long-term success of any
    software application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下关注点分离如何提高可维护性和可测试性。这两个方面对于任何软件应用的长期成功至关重要。
- en: Maintainability
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: By applying MVVM, we are separating the UI from the business logic and loosely
    coupling the ViewModel with the View. This improves maintainability greatly as
    each component has its distinct role and its distinct concern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用MVVM，我们正在将UI与业务逻辑分离，并将ViewModel与视图松散耦合。这极大地提高了可维护性，因为每个组件都有其独特的角色和关注点。
- en: The View, for example, can be easily altered or updated. UI elements can be
    moved around or replaced with newer, more modern ones without requiring changes
    to the ViewModel, as long as no additional data needs to be displayed. This is
    because the only interface between the View and the ViewModel is through data
    binding. Therefore, updating the View should not affect the ViewModel unless additional
    or altered data needs to be displayed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，视图可以很容易地更改或更新。UI元素可以移动或替换为更现代的元素，而无需更改ViewModel，只要不需要显示额外的数据。这是因为视图和ViewModel之间唯一的接口是通过数据绑定。因此，更新视图不应影响ViewModel，除非需要显示额外的或更改后的数据。
- en: Additionally, when the View requires additional data to be displayed or a UI
    element is updated and requires further data, the ViewModel may need to be updated
    as well. However, if the required data is already available in the Model, the
    ViewModel can translate it between the Model and the View without affecting the
    Model itself. The ViewModel is responsible for managing data flow between the
    Model and the View, ensuring a clear separation of concerns between the different
    layers of the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当视图需要显示额外的数据或UI元素更新需要进一步的数据时，ViewModel可能也需要更新。然而，如果所需数据已经在Model中可用，ViewModel可以在Model和视图之间进行转换，而不会影响Model本身。ViewModel负责管理Model和视图之间的数据流，确保应用程序不同层之间有清晰的关注点分离。
- en: In addition, any changes in the Model’s business logic should not have a significant
    impact on the ViewModel or the View. Since the ViewModel acts as a mediator between
    the Model and the View, it’s responsible for translating the data from the Model
    to be used by the View. Therefore, if any underlying business logic should change,
    the ViewModel can handle the translation without affecting the View, ensuring
    that any changes made to the Model are transparent to the user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Model业务逻辑的任何更改都不应对ViewModel或View产生重大影响。由于ViewModel充当Model和View之间的中介，它负责将Model中的数据转换为View使用。因此，如果任何底层业务逻辑应该发生变化，ViewModel可以处理转换而不影响View，确保对Model所做的任何更改对用户都是透明的。
- en: Even when an update to the Model or ViewModel is needed, thanks to the nature
    of the MVVM pattern, these changes can be easily tested in isolation from each
    other and, most importantly, independently of the UI. This separation enables
    efficient and focused testing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使需要更新Model或ViewModel，由于MVVM模式的特点，这些更改可以轻松地相互独立测试，最重要的是，独立于UI。这种分离使得测试既高效又专注。
- en: Testability
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试性
- en: Testability is a very important factor in software development. Not only do
    tests ensure that the tested code performs its intended function, but it also
    guarantees that it continues to operate as initially designed. When a successful
    set of tests is run, feedback is provided immediately after a code update inadvertently
    breaks the functionality. This is undoubtedly vital for maintaining the quality
    and stability of the codebase. In essence, comprehensive testing plays a crucial
    role in preserving the code’s maintainability, allowing for efficient modifications
    and improvements over time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试性是软件开发中一个非常重要的因素。不仅测试确保测试的代码执行其预期的功能，而且还保证它继续按照最初的设计运行。当运行一组成功的测试时，如果在代码更新时不小心破坏了功能，则会立即提供反馈。这对于维护代码库的质量和稳定性无疑是至关重要的。本质上，全面的测试在保持代码的可维护性方面发挥着关键作用，允许随着时间的推移进行高效的修改和改进。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By designing an application with testability in mind, developers can create
    code that is more reliable, maintainable, and scalable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在设计应用程序时考虑测试性，开发者可以创建更可靠、可维护和可扩展的代码。
- en: Separation of concerns is crucial to achieving testability because it allows
    developers to isolate and test individual components of the application without
    worrying about dependencies on other parts of the system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离对于实现测试性至关重要，因为它允许开发者隔离和测试应用程序的各个独立组件，而无需担心对系统其他部分的依赖。
- en: From the perspective of the MVVM design pattern, separation of concerns and
    testability are closely related. As the View, ViewModel, and Model are being treated
    as distinct components, each component is able to be written and tested independently
    of the others. Because the ViewModel is decoupled from the View and is agnostic
    of any specific UI framework, it is very easy to write automated unit tests for
    it. These automated tests are faster and more reliable than manual or automated
    UI testing, which allows developers to identify errors and regressions early in
    the development process before they become more difficult and expensive to fix.
    Similarly, the Model logic can also be effectively tested in isolation, independently
    of the ViewModel and the View.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从MVVM设计模式的视角来看，关注点的分离和测试性密切相关。由于View、ViewModel和Model被视为不同的组件，每个组件都能够独立于其他组件编写和测试。因为ViewModel与View解耦，并且对任何特定的UI框架都是不可知的，因此很容易为其编写自动单元测试。这些自动测试比手动或自动UI测试更快、更可靠，这允许开发者尽早在开发过程中识别错误和回归，在它们变得难以修复和昂贵之前。同样，Model逻辑也可以在独立于ViewModel和View的情况下进行有效测试。
- en: That’s the theory. Now, let’s take a look at an MVVM example!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是理论。现在，让我们看看一个MVVM示例！
- en: MVVM in action
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM实践
- en: Let’s look at a very simple application that shows the user a quote of the day
    on the screen. When the user clicks a button on the screen, the application will
    fetch a quote of the day from an API and show it onscreen. Once the button is
    clicked, it should be hidden. The code-behind approach will show you how this
    app can be written without using the MVVM pattern, whereas the second example
    shows the same functionality implemented using MVVM with testability in mind.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常简单的应用程序，它会在屏幕上显示用户的每日名言。当用户点击屏幕上的按钮时，应用程序将从API获取每日名言并显示在屏幕上。一旦按钮被点击，它应该被隐藏。代码-behind方法将向您展示如何在不使用MVVM模式的情况下编写此应用程序，而第二个示例则展示了使用MVVM实现相同功能，并考虑了可测试性。
- en: The code-behind approach
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码-behind方法
- en: In the following code snippet, there is no separation of concerns; all the code
    is handled in the code-behind of the XAML page. While this code seems to be doing
    what is expected, there is no easy, fast, or robust way to test whether it works.
    This is because all the logic is handled in the click event handler of the button.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，没有关注点的分离；所有的代码都在XAML页面的代码-behind中处理。虽然这段代码看起来似乎在执行预期的操作，但没有简单、快速或健壮的方法来测试它是否工作。这是因为所有的逻辑都在按钮的点击事件处理器中处理。
- en: 'In `MainPage.xaml`, we define a `Button` and a `Label`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml`中，我们定义了一个`Button`和一个`Label`：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Both button and label controls have a `Name` so that they can be referenced
    from the code-behind. The label, is not visible by default.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 两个按钮和标签控件都有一个`Name`，这样就可以从代码-behind中引用它们。标签默认情况下是不可见的。
- en: 'In the code-behind (`MainPage.xaml.cs`), we handle the button click event as
    follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码-behind（`MainPage.xaml.cs`）中，我们按照以下方式处理按钮点击事件：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On the button click, the `GetQuoteButton` is being hidden and a call to fetch
    a quote is being made. The `QuoteLabel`’s `Text` property is assigned the value
    of the retrieved quote.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮点击时，`GetQuoteButton`被隐藏，并调用获取名言。`QuoteLabel`的`Text`属性被分配了检索到的名言的值。
- en: 'Note that there’s a subtle bug in this code: if the API call fails, the exception
    being thrown would be silently caught, but the `GetQuoteButton`’s visibility won’t
    be restored to being visible, leaving the application unusable. But as there is
    no easy way to test this code, chances are high that this scenario is left unnoticed
    until the application gets to QA where, hopefully, a manual test might pick this
    issue up.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码中有一个微小的错误：如果API调用失败，抛出的异常会被静默捕获，但`GetQuoteButton`的可见性不会被恢复为可见，这会导致应用程序无法使用。但由于没有简单的方法来测试这段代码，这种情况很可能直到应用程序进入QA阶段才被发现，希望手动测试能够发现这个问题。
- en: Using MVVM
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用MVVM
- en: Now, let’s look at how we could transform this application using the MVVM pattern,
    keeping separation of concerns and testability in mind. It might be that not everything
    in this example is clear yet and that’s perfectly fine. While going through this
    book, all of these aspects should become clear very rapidly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用MVVM模式来转换这个应用程序，同时考虑到关注点的分离和可测试性。可能这个例子中的一些内容现在还不清楚，这是完全可以接受的。在阅读这本书的过程中，所有这些方面都应该会很快变得清晰。
- en: Let’s start off by looking at what the Model in this app would be.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看这个应用程序中的模型是什么。
- en: The Model
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'In our sample application, the primary data we are working with is the quote
    that we fetch from an API. The logic that communicates with this API to fetch
    the data can be thought of as the Model. Instead of making the HTTP request directly
    in the code-behind as we previously did, we can encapsulate this logic into a
    separate class. This class will be responsible for fetching the quote and will
    act as our Model. Here’s what that might look like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们正在处理的主要数据是从API获取的名言。与这个API通信以获取数据的逻辑可以被视为模型。我们不再像之前那样直接在代码-behind中发起HTTP请求，而是可以将这个逻辑封装到一个单独的类中。这个类将负责获取名言，并充当我们的模型。下面是这个类的可能样子：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we have created a `QuoteService` class, which contains the logic
    for fetching the quote from the API. This class implements an interface called
    `IQuoteService`. By defining an interface, we are making it easier to swap out
    the implementation or mock this service for testing purposes later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个`QuoteService`类，其中包含从API获取名言的逻辑。这个类实现了一个名为`IQuoteService`的接口。通过定义一个接口，我们使得替换实现或为测试目的模拟此服务变得更加容易。
- en: By having this logic, which was previously in our code-behind, encapsulated
    in a dedicated class already gives us a cleaner separation of concerns.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将之前在代码后部中存在的逻辑封装在一个专门的类中，这已经为我们提供了一个更清晰的关注点分离。
- en: This covers the Model part of the Model-View-ViewModel pattern. Let’s see what
    the ViewModel could look like.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了模型-视图-ViewModel模式中的模型部分。让我们看看ViewModel可能的样子。
- en: The ViewModel
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewModel
- en: 'The ViewModel acts as an intermediary between the View and the Model. It holds
    the data and the Commands that the View will bind to. For our simple application,
    we need the following things in our ViewModel:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel充当视图和模型之间的中介。它持有视图将绑定到的数据和命令。对于我们的简单应用程序，我们需要在ViewModel中包含以下内容：
- en: A property to hold the quote of the day once it is retrieved
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个属性用于在检索到引言后持有每日引言
- en: Two properties to control the visibility of the button and the label
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个属性用于控制按钮和标签的可见性
- en: A Command that will be triggered when the button is clicked; this will be responsible
    for fetching the quote
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在按钮被点击时将被触发的命令；这将负责检索引言
- en: We also need to have a constructor that takes a parameter of type `IQuoteService`.
    This is where dependency injection comes into play.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要有一个接受类型为`IQuoteService`的参数的构造函数。这就是依赖注入发挥作用的地方。
- en: More about dependency injection
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于依赖注入的信息
- en: Dependency injection is key to making classes testable and modular, and is used
    very commonly in MVVM. [*Chapter 7*](B20941_07.xhtml#_idTextAnchor119)*, Dependency
    Injection, Services, and Messaging*, covers this concept in depth.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是使类可测试和模块化的关键，并且在MVVM中非常常用。[*第7章*](B20941_07.xhtml#_idTextAnchor119)*，依赖注入、服务和消息传递*，深入探讨了这一概念。
- en: 'Let’s take a look at what this might look like in code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这可能在代码中是什么样子：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The constructor takes an instance of `IQuoteService` as a parameter. This instance
    is assigned to the `quoteService` field within the class. This way, the ViewModel
    has access to the quote-fetching service, allowing it to retrieve quotes when
    needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个`IQuoteService`实例作为参数。这个实例被分配到类中的`quoteService`字段。这样，ViewModel就可以访问引言检索服务，允许它在需要时检索引言。
- en: Also note that this class implements the `INotifyPropertyChanged` interface,
    and therefore needs to implement the `PropertyChanged` event. Its purpose is essentially
    to make sure the UI gets notified when data on the ViewModel changes so the View
    and ViewModel stay in sync. [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*,
    Data Binding Building Blocks in .NET MAUI,* covers this in much more depth!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个类实现了`INotifyPropertyChanged`接口，因此需要实现`PropertyChanged`事件。其主要目的是确保当ViewModel中的数据发生变化时，UI会得到通知，这样视图和ViewModel就可以保持同步。[*第3章*](B20941_03.xhtml#_idTextAnchor051)*，.NET
    MAUI中的数据绑定构建块*，对此进行了更深入的探讨！
- en: '`QuoteOfTheDay` is the property that holds the retrieved quote. This is just
    a simple property holding a string value. The only thing “special” about it is
    that it triggers the `PropertyChanged` event to inform the data binding engine
    about the updated value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuoteOfTheDay`是持有检索到的引言的属性。这只是一个简单的属性，持有字符串值。它“特殊”的地方在于它会触发`PropertyChanged`事件，以通知数据绑定引擎关于更新值的更新：'
- en: '[PRE4]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two properties that control the visibility of the button and the label
    are `IsButtonVisible` and `IsLabelVisible`, respectively. Again, these are simple
    public properties that trigger the `PropertyChanged` event:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 控制按钮和标签可见性的两个属性分别是`IsButtonVisible`和`IsLabelVisible`。同样，这些也是简单的公共属性，会触发`PropertyChanged`事件：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before we implement the Command that should be invoked when the user clicks
    the buttons, let’s first implement the logic that needs to be executed by said
    Command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现当用户点击按钮时应调用的命令之前，让我们首先实现该命令需要执行的逻辑：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `GetQuote` method is asynchronous, meaning it allows for non-blocking execution,
    which is especially important when fetching data from a network source. It starts
    by setting the `IsButtonVisible` property to `false`, which should hide the button
    on the screen. Next, we’re calling the `GetQuote` method of the `quoteService`
    field, which will go out and fetch a quote. What this service actually does to
    retrieve the quote isn’t important here, as that isn’t the concern of our ViewModel.
    Once we receive a quote back from the `GetQuote` method of `quoteService`, we
    assign this value to the `QuoteOfTheDay` property. The `IsLabelVisible` property
    is set to `true` so that the label displaying the quote becomes visible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetQuote`方法是非同步的，这意味着它允许非阻塞执行，这在从网络源获取数据时尤为重要。它首先将`IsButtonVisible`属性设置为`false`，这应该会隐藏屏幕上的按钮。接下来，我们调用`quoteService`字段的`GetQuote`方法，这将出去获取一个引言。这个服务实际上是如何获取引言的并不重要，因为这不是ViewModel的关注点。一旦我们从`quoteService`的`GetQuote`方法收到引言，我们就将这个值分配给`QuoteOfTheDay`属性。将`IsLabelVisible`属性设置为`true`，以便显示引言的标签变得可见。'
- en: 'Finally, we can create a Command that triggers this method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个触发此方法的命令：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Through `GetQuoteCommand`, we can now call the `GetQuote` method defined on
    the ViewModel.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`GetQuoteCommand`，我们现在可以调用ViewModel上定义的`GetQuote`方法。
- en: With the Model and the ViewModel in place, let’s finally have a look at the
    View.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在Model和ViewModel已经就绪的情况下，我们终于可以看看View了。
- en: The View
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: View
- en: 'Essentially, not a lot of changes are needed to the UI: we still need a button
    that should trigger the retrieval of the `QuoteOfTheDay` and a label to show it.
    As we are no longer going to be accessing the label from the code-behind, there
    is no need to set the `x:Name` property:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对UI的更改并不多：我们仍然需要一个按钮来触发`QuoteOfTheDay`的检索，以及一个标签来显示它。由于我们不再从代码背后访问标签，因此不需要设置`x:Name`属性：
- en: '[PRE8]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, the `Button_Clicked` event handler that we had earlier can be removed
    from the code-behind. And while we are there, we can also assign the `BindingContext`
    of the page to an instance of `MainPageViewModel`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们之前在代码背后使用的`Button_Clicked`事件处理器可以从代码中移除。而且当我们身处其中时，我们还可以将页面的`BindingContext`分配给`MainPageViewModel`的一个实例：
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`BindingContext` is essentially the source that we are going to bind to. With
    this in place, we make some final adjustments to our XAML to include data-binding
    statements:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`BindingContext`基本上是我们将要绑定的源。有了这个，我们对XAML进行一些最后的调整，包括数据绑定语句：'
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These binding statements ‘link’ the public properties exposed on our ViewModel
    to the properties on the UI elements. When the user clicks the button, `GetQuoteCommand`
    on `MainPageViewModel` will be invoked, which in turn will execute the `GetQuote`
    method. While the `GetQuote` method is executed, the `IsButtonVisible` and `IsLabelVisible`
    properties are being updated, and a quote retrieved from `QuoteService` will be
    set as the value of the `QuoteOfTheDay` property. Through data binding, these
    changes will instantly and automatically be reflected on the View.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定语句“链接”了我们ViewModel公开暴露的属性到UI元素的属性上。当用户点击按钮时，`MainPageViewModel`上的`GetQuoteCommand`将被调用，这反过来将执行`GetQuote`方法。在执行`GetQuote`方法的同时，`IsButtonVisible`和`IsLabelVisible`属性正在被更新，从`QuoteService`检索到的引言将被设置为`QuoteOfTheDay`属性的值。通过数据绑定，这些更改将立即自动反映在View上。
- en: That’s it! This is basically the same application as we had before. However,
    this time it is written using the MVVM pattern while keeping separation of concerns
    and testability in mind.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这基本上是我们之前拥有的相同的应用程序。然而，这次它是使用MVVM模式编写的，同时考虑到关注点的分离和可测试性。
- en: The first thing that immediately stands out is the fact that the MVVM example
    has more code to it. That’s mostly because of the ViewModel. Luckily, ViewModels
    should be pretty simple. They should not contain any business logic. In this example,
    the business logic is inside the `QuoteService` class, which the ViewModel calls
    into to get the `QuoteOfTheDay` value. The properties on the ViewModel are there
    to represent the state of the View, such as for controlling the visibility of
    the button and the label, and for holding the `Quote` that `QuoteService` will
    return.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 立即引人注目的是，MVVM示例中的代码更多。这主要是因为ViewModel。幸运的是，ViewModel应该相当简单。它们不应该包含任何业务逻辑。在这个例子中，业务逻辑位于`QuoteService`类中，ViewModel会调用它来获取`QuoteOfTheDay`值。ViewModel上的属性用于表示View的状态，例如控制按钮和标签的可见性，以及保存`QuoteService`将返回的`Quote`。
- en: 'It should be clear by now that every piece in this example has its own responsibility:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该很清楚，这个例子中的每个部分都有自己的职责：
- en: The View – `MainPage_MVVM` – is responsible for the UI layer. It contains the
    visual elements such as a `Label` and a `Button` and lays them out.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图层由 `MainPage_MVVM` 负责。它包含视觉元素，如 `Label` 和 `Button`，并将它们布局。
- en: The single responsibility of `QuoteService` – the Model in this scenario – is
    to fetch a `Quote`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此场景中，`QuoteService` 的单一职责是获取一个 `Quote`。
- en: '`MainPageViewModel` glues it all together. It provides the properties and values
    that the View needs to display, as well as any Commands for handling interactions.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainPageViewModel` 将所有这些粘合在一起。它提供视图所需的属性和值，以及任何用于处理交互的命令。'
- en: Every component has only one reason to change, which makes this code much more
    maintainable, compared to having everything in the code-behind. Not only maintainability,
    but also testability is improved a lot compared to the previous example. Don’t
    take my word for it; let’s explore how we can test the functionality of our app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件只有一个改变的理由，这使得代码比将所有内容放在代码后部更容易维护。与之前的示例相比，不仅可维护性提高了，而且可测试性也得到了很大提升。不要只听我的话；让我们看看我们如何测试我们应用程序的功能。
- en: Testing your ViewModel
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 ViewModel
- en: 'Finally, let’s take a quick look at what this means for testability. The following
    code sample shows some unit tests for `MainPageViewModel`. Again, not everything
    in here might be clear, but everything will be covered thoroughly throughout this
    book. Moreover, [*Chapter 13*](B20941_13.xhtml#_idTextAnchor223)*, Unit Testing*,
    is entirely dedicated to writing unit tests for your ViewModels. In these tests,
    we’re using the `IQuoteService` interface. Mocking is a technique used in unit
    testing to create a fake or simulated object that mimics the behavior of a real
    object. This is especially useful for isolating the code being tested and removing
    dependencies on external elements such as databases or APIs. In the constructor
    of our test class, which runs before each test, we create a new mock instance
    that returns an empty string as a result of the `GetQuote` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速看看这对可测试性意味着什么。以下代码示例展示了 `MainPageViewModel` 的一些单元测试。再次强调，这里可能不是所有内容都清楚，但本书将彻底涵盖所有内容。此外，[*第13章*](B20941_13.xhtml#_idTextAnchor223)*，单元测试*，完全致力于编写
    ViewModels 的单元测试。在这些测试中，我们使用 `IQuoteService` 接口。模拟是单元测试中用来创建一个模仿真实对象行为的假或模拟对象的技术。这对于隔离正在测试的代码和消除对外部元素（如数据库或API）的依赖特别有用。在测试类构造函数中，它在每个测试之前运行，我们创建一个新的模拟实例，该实例的
    `GetQuote` 方法返回一个空字符串：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This mocked instance can be passed in as a parameter when creating a new instance
    of the `MainPageViewModel` class. This allows us to test the ViewModel without
    any external dependencies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟实例可以在创建 `MainPageViewModel` 类的新实例时作为参数传递。这允许我们在没有任何外部依赖的情况下测试 ViewModel。
- en: 'The first snippet shows two tests that test the value of the `IsButtonVisible`
    property:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个片段显示了两个测试，测试 `IsButtonVisible` 属性的值：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first of the preceding tests checks whether the initial value of the `IsButtonVisible`
    property is `true`. We create a new instance of `MainPageViewModel`, passing in
    the mocked `IQuoteService` instance. We can now use our `sut` variable (for system
    under test) to do assertions and see whether everything works as expected. The
    second test checks that as soon as `GetQuoteCommand` is invoked, the `IsButtonVisible`
    property is `false`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的第一个测试检查 `IsButtonVisible` 属性的初始值是否为 `true`。我们创建一个新的 `MainPageViewModel` 实例，传入模拟的
    `IQuoteService` 实例。现在我们可以使用我们的 `sut` 变量（系统正在测试）来进行断言，看看一切是否按预期工作。第二个测试检查一旦调用 `GetQuoteCommand`，`IsButtonVisible`
    属性就变为 `false`。
- en: 'The next test checks whether the `Quote` value returned by the injected `IQuoteService`’s
    `GetQuote` method is being set as the value of the `QuoteOfTheDay` property:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试检查由注入的 `IQuoteService` 的 `GetQuote` 方法返回的 `Quote` 值是否被设置为 `QuoteOfTheDay`
    属性的值：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding test, we define that the `GetQuote` method of the mocked `IQuoteSerivce`
    should return a particular value. After executing `GetQuoteCommand`, the `QuoteOfTheDay`
    property should have the same value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们定义了模拟的 `IQuoteSerivce` 的 `GetQuote` 方法应该返回特定的值。执行 `GetQuoteCommand`
    后，`QuoteOfTheDay` 属性应该具有相同的值。
- en: 'And finally, we have a test that doesn’t test the application’s happy path.
    Instead, it tests whether the `IsButtonVisible` property is set to `true` after
    the `quoteService` failed to retrieve a quote, allowing the user to try again:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个不测试应用程序的“快乐路径”的测试。相反，它测试在`quoteService`未能检索引言后，`IsButtonVisible`属性是否设置为`true`，使用户可以再次尝试：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This test fails, revealing an issue in the implementation: the `GetQuote` method
    of the ViewModel handles any exception from `IQuoteService` silently, but fails
    to re-enable the button, leaving the app in a useless state. Without even running
    the app once, needing to deploy any other components, or needing to rely on the
    availability of the quote of the day API, the app’s behavior is effectively being
    tested and a simple bug could already be identified very early on in the development
    process. These tests ensure that the application is behaving as it was intended
    to, but also that it keeps working like this in the future. If a change to the
    code would introduce different (unexpected) behavior, automated tests would fail,
    informing the developer that they have broken something and need to fix it before
    publishing the app. Unit tests like these are so valuable and very easy to write,
    as long as there is a clear separation of concerns and the application is written
    with testability in mind. The MVVM pattern is perfect for this! Like in this example,
    the ViewModel can be tested in complete isolation as it isn’t tied to the View
    or any specific UI framework. This ViewModel will work in any kind of .NET application!'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败了，揭示了实现中的一个问题：ViewModel中的`GetQuote`方法静默地处理来自`IQuoteService`的任何异常，但未能重新启用按钮，使应用程序处于无用的状态。即使没有运行应用程序一次，不需要部署任何其他组件，也不需要依赖于每日引言API的可用性，应用程序的行为实际上正在被测试，一个简单的错误已经在开发过程的早期就被识别出来了。这些测试确保应用程序按预期运行，但同时也确保它在未来保持这种运行方式。如果代码的更改会引入不同的（意外的）行为，自动化测试将失败，通知开发者他们已经破坏了某些内容，在发布应用程序之前需要修复它。像这样的单元测试非常有价值，并且非常容易编写，只要存在清晰的关注点分离，并且应用程序是以可测试性为前提编写的。MVVM模式对此非常完美！就像这个例子一样，ViewModel可以在完全隔离的情况下进行测试，因为它没有绑定到视图或任何特定的UI框架。这个ViewModel可以在任何类型的.NET应用程序中工作！
- en: 'Compared to the previous example with code-behind implementation, testing becomes
    significantly more challenging: the app has to be deployed, and a UI testing framework
    must be used to launch the app, interact with the UI controls, and validate whether
    the UI shows what is expected. Automated UI tests can be time-consuming to write,
    run, and maintain. However, would you instead want to depend exclusively on manual
    testing and QA, rather than leveraging the benefits of automated testing to ensure
    the quality and reliability of your app’s behavior?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有代码背后实现的先前的例子相比，测试变得具有挑战性：必须部署应用程序，并使用UI测试框架来启动应用程序，与UI控件交互，并验证UI是否显示预期的内容。自动化UI测试的编写、运行和维护可能很耗时。然而，您是否更愿意完全依赖手动测试和QA，而不是利用自动化测试的优势来确保应用程序行为的质量和可靠性？
- en: 'When using the MVVM pattern, it becomes very easy to write unit tests that
    test different areas of the application, as it promotes separation of concerns
    and should be UI framework independent. Testing business logic through automated
    UI tests when everything is in the code-behind becomes very complex, hard to maintain,
    and error-prone very fast. UI tests have their purpose as they can test whether
    the user interface of an application behaves as expected. Both types of tests
    are important and serve different purposes in ensuring the quality of an application.
    But (automated) UI tests should just do that: test the UI. Your ViewModels and
    business logic should already be tested by other automated tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MVVM模式时，编写单元测试来测试应用程序的不同区域变得非常容易，因为它促进了关注点的分离，并且应该是UI框架无关的。当所有内容都在代码背后时，通过自动化UI测试来测试业务逻辑会变得非常复杂，难以维护，并且很快就会出错。UI测试有其目的，因为它们可以测试应用程序的用户界面是否按预期运行。这两种类型的测试都很重要，在确保应用程序质量方面发挥着不同的作用。但是（自动化的）UI测试应该只做这件事：测试UI。您的ViewModel和业务逻辑应该已经通过其他自动化测试进行了测试。
- en: Common misconceptions about MVVM
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于MVVM的常见误解
- en: There are several common misconceptions about MVVM that can lead to misunderstandings
    of its principles and best practices. Let’s dispel some of these and provide clarity
    on the pattern.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MVVM存在一些常见的误解，这些误解可能导致对其原则和最佳实践的误解。让我们消除其中的一些误解，并对该模式提供清晰的解释。
- en: There should be no code in the code-behind
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码背后不应该有代码
- en: While it is true that the main purpose of MVVM is to separate the presentation
    logic from the application logic, it is not necessarily the case that there should
    be *no* code in the code-behind. The code-behind can still be used to handle simple
    UI-related events or for any logic that is tightly coupled with the View.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MVVM的主要目的是将表示逻辑与应用逻辑分离，但这并不意味着代码隐藏中不应该有任何代码。代码隐藏仍然可以用来处理简单的UI相关事件或与视图紧密耦合的任何逻辑。
- en: In fact, there are scenarios where putting some code in the code-behind can
    be more efficient and maintainable than trying to move everything to the ViewModel.
    For example, handling UI animations, scrolling, and controlling focus or complex
    visual behaviors may be easier to implement in the code-behind rather than trying
    to do it through data binding.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在某些情况下，将一些代码放在代码隐藏中可能比尝试将所有内容移动到视图模型中更高效、更易于维护。例如，处理UI动画、滚动、控制焦点或复杂的视觉行为可能比通过数据绑定实现更容易。
- en: To ensure proper separation of concerns in MVVM, it is imperative to avoid including
    business logic in the code-behind of the View. The code-behind should be kept
    to a minimum and remain as simple as possible to maintain the separation between
    the View and the ViewModel.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在MVVM中正确分离关注点，必须避免在视图的代码隐藏中包含业务逻辑。代码隐藏应保持最小化，并尽可能简单，以保持视图和视图模型之间的分离。
- en: The Model should exclusively be a DTO, a domain entity, or a POCO
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型应该是DTO、领域实体或POCO
- en: Although the type of object used for the Model in MVVM has been a topic of debate,
    in my opinion, it is not a critical factor. The main principle of MVVM is to keep
    the business logic out of the View and only have simple validation logic in the
    ViewModel. Thus, the Model can be any object type and is often a combination of
    different types of objects. The Model isn’t a single type of thing; it is everything
    ‘outside’ the View and ViewModel that contains the application’s entities, business
    logic, repositories, and so on. The important thing to remember is that the View
    and ViewModel should not contain any business or persistence logic.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在MVVM中使用模型的对象类型一直是一个有争议的话题，但在我看来，这并不是一个关键因素。MVVM的主要原则是将业务逻辑从视图中移除，并在视图模型中只包含简单的验证逻辑。因此，模型可以是任何对象类型，通常是不同类型对象的组合。模型不是单一类型的事物；它是包含应用程序实体、业务逻辑、存储库等所有“在视图和视图模型之外”的内容。重要的是要记住，视图和视图模型不应包含任何业务或持久化逻辑。
- en: The View and the ViewModel should not know each other
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图（View）和视图模型（ViewModel）之间不应相互了解
- en: While the ViewModel should not have any knowledge of the View in order to maintain
    separation of concerns, the View can have a reference to the ViewModel. It is
    important to note that this does not violate the principles of MVVM, as long as
    the ViewModel is not dependent on the View. The use of ‘compiled bindings’ in
    platforms such as .NET MAUI can provide significant performance improvements,
    but in order for them to work, the View must have knowledge of the type it is
    binding to.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然视图模型不应该了解视图以保持关注点的分离，但视图可以引用视图模型。需要注意的是，只要视图模型不依赖于视图，这并不违反MVVM的原则。在.NET MAUI等平台上使用“编译绑定”可以提供显著的性能提升，但为了使它们能够工作，视图必须了解它所绑定的类型。
- en: More about compiled bindings
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于编译绑定的信息
- en: Curious to find out more about compiled bindings? [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069)*,
    Data Binding in .NET MAUI*, has got you covered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于编译绑定的信息？[*第4章*](B20941_04.xhtml#_idTextAnchor069)*，.NET MAUI中的数据绑定*，为您提供了全面的介绍。
- en: Also, there may be some situations where it’s necessary for the View to directly
    invoke a method on the ViewModel from the code-behind. This can be necessary in
    cases where the UI is very complex, and the Command can’t be easily bound.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能存在一些情况下，视图需要从代码隐藏中直接调用视图模型上的方法。在UI非常复杂且命令无法轻松绑定的情况下，这可能是有必要的。
- en: MVVM is too complex and used only for large applications
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVVM过于复杂，仅适用于大型应用程序
- en: MVVM itself is not necessarily complex, but it may require some learning and
    practice to become proficient with it. Understanding the concept of the separation
    of concerns and implementing it in MVVM can be a bit challenging for developers
    who are not used to working with this design pattern. Additionally, getting the
    bindings right can require some effort, especially when working with large and
    complex Views. However, once you understand it, you will notice that the development
    process becomes simpler and the code becomes more maintainable and testable. Even
    though there might be a learning curve, it is worthwhile to adopt MVVM in application
    development, even for small and simple applications. These kinds of apps need
    to be maintained and updated over time. In the course of time, their business
    logic would also benefit from unit testing, right?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 本身并不一定复杂，但要熟练掌握它可能需要一些学习和实践。对于不习惯使用这种设计模式的开发者来说，理解关注点分离的概念并在 MVVM 中实现它可能有点挑战性。此外，正确设置绑定可能需要一些努力，尤其是在处理大型和复杂的视图时。然而，一旦您理解了它，您会发现开发过程变得更加简单，代码也变得更加易于维护和测试。尽管可能存在学习曲线，但在应用程序开发中采用
    MVVM 仍然值得，即使是小型和简单的应用程序。这类应用程序需要随着时间的推移进行维护和更新。随着时间的推移，它们的业务逻辑也将从单元测试中受益，对吧？
- en: That said, MVVM might be overkill for applications that have a very minimal
    UI, with only a handful of UI elements and little to no business logic being reflected
    on the UI. But then again, looking at the previous sample that only had two UI
    controls, we noticed that it benefited from being testable through applying the
    MVVM design pattern.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对于具有非常简单 UI 的应用程序，例如只有几个 UI 元素并且几乎没有业务逻辑反映在 UI 上的应用程序，MVVM 可能是过度设计。然而，再次审视之前仅包含两个
    UI 控件的示例，我们发现它通过应用 MVVM 设计模式受益于可测试性。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize, the MVVM pattern separates the concerns of data, UI, and logic,
    which makes the application easier to test, modify, and extend. By using the Model
    to represent the data and business logic, the View to present the data to the
    user, and the ViewModel to mediate between the Model and the View, the MVVM pattern
    promotes a clear separation of responsibilities that makes it easier to develop
    and maintain complex applications. Additionally, the use of Commands and data
    binding provides a powerful way to handle user input and keep the UI in sync with
    the application’s state. Understanding the components of MVVM is crucial for building
    successful .NET MAUI applications that are maintainable, scalable, and easy to
    test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，MVVM 模式将数据、UI 和逻辑的关注点分开，这使得应用程序更容易进行测试、修改和扩展。通过使用模型来表示数据和业务逻辑，视图来向用户展示数据，以及视图模型在模型和视图之间进行调解，MVVM
    模式促进了职责的清晰分离，这使得开发和维护复杂应用程序变得更加容易。此外，使用命令和数据绑定提供了一种强大的方式来处理用户输入并保持 UI 与应用程序状态同步。理解
    MVVM 的组件对于构建可维护、可扩展且易于测试的 .NET MAUI 应用程序至关重要。
- en: In [*Chapter 2*](B20941_02.xhtml#_idTextAnchor036)*, What Is .NET MAUI?*, we’ll
    dive into .NET MAUI so that you have a good understanding of this framework. If
    you already have a thorough knowledge of .NET MAUI, you can skip this chapter.
    If you know the basics of it, it should be a good refresher.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B20941_02.xhtml#_idTextAnchor036)*，什么是 .NET MAUI？*中，我们将深入了解 .NET MAUI，以便您对该框架有一个良好的理解。如果您已经对
    .NET MAUI 有深入的了解，您可以跳过这一章。如果您对其基础知识有所了解，这将是一个很好的复习。
