- en: Chapter 1.  Building a Gallery Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 构建画廊应用程序
- en: 'This chapter will walkthrough native development with Xamarin by building an
    iOS and Android application that will read from your local gallery files, and
    display them in a **UITableView** and **ListView.** The following topics will
    be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过构建一个iOS和Android应用程序来演示使用Xamarin的原生开发，该应用程序将读取你的本地画廊文件，并在**UITableView**和**ListView**中显示它们。本章将涵盖以下主题：
- en: 'Expected knowledge:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 预期知识：
- en: Creating iOS provision certificates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建iOS配置证书
- en: iOS development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS开发
- en: Objective-C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C
- en: Creating keystores
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建密钥库
- en: Android development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android开发
- en: Java
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java
- en: 'In this chapter you will learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Creating an iOS project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建iOS项目
- en: Creating a UIViewController and UITableView
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UIViewController和UITableView
- en: Customizing a cell's appearance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义单元格外观
- en: Creating an Android project
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Android项目
- en: Creating an XML interface and ListView
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建XML界面和ListView
- en: Shared projects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享项目
- en: Custom row appearance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义行外观
- en: Bitmap functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位图函数
- en: The ALAssetLibrary
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ALAssetLibrary
- en: Adding the iOS photo screen
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加iOS照片屏幕
- en: Adding the Android photo screen
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Android照片屏幕
- en: Create an iOS project
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建iOS项目
- en: 'Let''s begin our Xamarin journey; we will start by setting up our iOS project
    in Xamarin Studio:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的Xamarin之旅；我们将从在Xamarin Studio中设置我们的iOS项目开始：
- en: Start by opening Xamarin Studio and creating a new iOS project. To do so, we
    simply select **File** | **New** | **Solution** and select an **iOS Single View
    App**; we must also give it a name and add the bundle ID you want in order to
    run your application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开Xamarin Studio并创建一个新的iOS项目。为此，我们只需选择**文件** | **新建** | **解决方案**，然后选择**iOS单视图应用程序**；我们还必须给它一个名称，并添加你想要运行的程序的捆绑ID。
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that for each project, a new bundle ID is created, along with
    a developer provisioning profile for each project.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建议为每个项目创建一个新的捆绑ID，并为每个项目创建一个开发者配置文件。
- en: 'Now that we have created the iOS project, you will be taken to the following
    screen:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了iOS项目，你将被带到以下屏幕：
- en: '![Create an iOS project](img/B05293_01_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![创建iOS项目](img/B05293_01_01.jpg)'
- en: Doesn't this look familiar? Yes, it is our `AppDelegate` file; notice the `.cs`
    on the end; because we are using C#, all our code files will have this extension
    (no more `.h` or `.m` files).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是不是很熟悉？是的，这是我们`AppDelegate`文件；注意末尾的`.cs`；因为我们使用C#，所以所有代码文件都将有这个扩展名（不再有`.h`或`.m`文件）。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Before we go any further, spend a few minutes moving around the IDE, expanding
    the folders, and exploring the project structure; it is very similar to an iOS
    project created in XCode.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，花几分钟在IDE中移动，展开文件夹，并探索项目结构；它与在XCode中创建的iOS项目非常相似。
- en: Creating a UIViewController and UITableView
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UIViewController和UITableView
- en: 'Now that we have our new iOS project, we are going to start by creating a `UIViewController`.
    Right-click on the project file, select **Add** | **New File**, and select **ViewController**
    from the **iOS** menu selection in the left-hand box:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的iOS项目，我们将从创建一个`UIViewController`开始。右键单击项目文件，选择**添加** | **新建文件**，然后在左侧框中从**iOS**菜单选择**ViewController**：
- en: '![Creating a UIViewController and UITableView](img/B05293_01_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建UIViewController和UITableView](img/B05293_01_02.jpg)'
- en: You will notice three files generated, a `.xib`, a `.cs`, and a `.designer.cs`
    file. We don't need to worry about the third file; this is automatically generated
    based upon the other two files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到生成了三个文件，一个`.xib`文件，一个`.cs`文件和一个`.designer.cs`文件。我们不需要担心第三个文件；这个文件是基于其他两个文件自动生成的。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Right-click on the project item and select **Reveal in Finder**,
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击项目项并选择**在Finder中显示**，
- en: '![Creating a UIViewController and UITableView](img/B05293_01_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建UIViewController和UITableView](img/B05293_01_03.jpg)'
- en: This will bring up the finder where you will double-click on the `GalleryCell.xib`
    file; this will bring up the user interface designer in XCode. You should see
    automated text inserted into the document to help you get started.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开Finder，你将双击`GalleryCell.xib`文件；这将打开XCode中的用户界面设计器。你应该在文档中看到自动插入的文本，以帮助你开始。
- en: 'Firstly, we must set our namespace accordingly, and import our libraries with
    using statements. In order to use the iOS user interface elements, we must import
    the `UIKit` and `CoreGraphics` libraries. Our class will inherit the `UIViewController`
    class in which we will override the `ViewDidLoad` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须相应地设置我们的命名空间，并使用using语句导入我们的库。为了使用iOS用户界面元素，我们必须导入`UIKit`和`CoreGraphics`库。我们的类将继承`UIViewController`类，并在其中重写`ViewDidLoad`函数：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our first UI element created is `UITableView`. This will be used to insert into
    the `UIView` of the `UIViewController`, and we also retrieve width and height
    values of the `UIView` to stretch the `UITableView` to fit the entire bounds of
    the `UIViewController`. We must also call `Add` to insert the `UITableView` into
    the `UIView`. In order to fill the list with data, we need to create a `UITableSource`
    to contain the list of items to be displayed in the list. We will also need an
    object called `GalleryModel`; this will be the model of data to be displayed in
    each cell.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个UI元素是`UITableView`。这将用于插入到`UIViewController`的`UIView`中，并且我们也会检索`UIView`的宽度和高度值来拉伸`UITableView`以适应`UIViewController`的整个边界。我们还必须调用`Add`来将`UITableView`插入到`UIView`中。为了填充列表中的数据，我们需要创建一个`UITableSource`来包含要显示在列表中的项目列表。我们还需要一个名为`GalleryModel`的对象；这将是我们要在每个单元格中显示的数据模型。
- en: 'Follow the previous process for adding two new `.cs` files; one will be used
    to create our `UITableSource` class and the other for the `GalleryModel` class.
    In `TableSource.cs`, first we must import the `Foundation` library with the `using`
    statement:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的步骤添加两个新的`.cs`文件；一个将用于创建我们的`UITableSource`类，另一个用于`GalleryModel`类。在`TableSource.cs`中，首先我们必须使用using语句导入`Foundation`库：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now for the rest of our class. Remember, we have to override specific functions
    for our `UITableSource` to describe its behavior. It must also include a list
    for containing the item view-models that will be used for the data displayed in
    each cell:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是其余的类。记住，我们必须为我们的`UITableSource`重写特定函数来描述其行为。它还必须包括一个列表来包含将用于每个单元格中显示的数据的项视图模型：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We must override the `NumberOfSections` function; in our case, it will always
    be one because we are not having list sections:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须重写`NumberOfSections`函数；在我们的情况下，它将始终是1，因为我们没有列表部分：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To determine the number of list items, we return the count of the list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定列表项的数量，我们返回列表的计数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we must add the `GetCell` function; this will be used to get the `UITableViewCell`
    to render for a particular row. But before we do this, we need to create a custom
    `UITableViewCell`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须添加`GetCell`函数；这将用于获取用于渲染特定行的`UITableViewCell`。但在我们这样做之前，我们需要创建一个自定义的`UITableViewCell`。
- en: Customizing a cell's appearance
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义单元格的外观
- en: We are now going to design our cells that will appear for every model found
    in the `TableSource` class. Add a new `.cs` file for our custom `UITableViewCell`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设计将出现在`TableSource`类中每个模型上的单元格。为我们的自定义`UITableViewCell`添加一个新的`.cs`文件。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not going to use a `.xib` and simply build the user interface directly
    in code using a single `.cs` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用`.xib`，而是直接在代码中使用单个`.cs`文件构建用户界面。
- en: 'Now for the implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实施阶段：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our constructor must call the base constructor, as we need to initialize each
    cell with a cell style and cell identifier. We then add a `UIImageView` and two
    `UILabels` for each cell, one for the filename and one for the date. Finally,
    we add all three elements to the main content view of the cell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数必须调用基构造函数，因为我们需要用单元格样式和单元格标识符初始化每个单元格。然后我们为每个单元格添加一个`UIImageView`和两个`UILabel`，一个用于文件名，一个用于日期。最后，我们将所有三个元素添加到单元格的主要内容视图中。
- en: 'When we have our initializer, we add the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有我们的初始化器时，我们添加以下内容：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our first function, `UpdateCell`, simply adds the model data to the view, and
    our second function overrides the `LayoutSubViews` method of the `UITableViewCell`
    class (equivalent to the `ViewDidLoad` function of a `UIViewController`).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数`UpdateCell`简单地将模型数据添加到视图中，我们的第二个函数重写了`UITableViewCell`类的`LayoutSubViews`方法（相当于`UIViewController`的`ViewDidLoad`函数）。
- en: 'Now that we have our cell design, let''s create the properties required for
    the view-model. We only want to store data in our `GalleryItem` model, meaning
    we want to store images as byte arrays. Let''s create a property for the item
    model:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了单元格设计，让我们创建视图模型所需的属性。我们只想在我们的`GalleryItem`模型中存储数据，这意味着我们想将图像存储为字节数组。让我们为项目模型创建一个属性：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now back to our `TableSource` class. The next step is to implement the `GetCell`
    function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的`TableSource`类。下一步是实现`GetCell`函数：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice the cell reuse on the `if` statement; you should be familiar with this
    type of approach, it is a common pattern for reusing cell views and is the same
    as the Objective-C implementation (this is a very basic cell reuse implementation).
    We also call the `UpdateCell` method to pass in the required `GalleryItem` data
    to show in the cell. Let''s also set a constant height for all cells. Add the
    following to your `TableSource` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`if`语句中的单元格重用；你应该熟悉这种类型的方法，这是重用单元格视图的常见模式，与Objective-C实现相同（这是一个非常基本的单元格重用实现）。我们还调用`UpdateCell`方法来传递所需的`GalleryItem`数据以在单元格中显示。让我们也为所有单元格设置一个固定的高度。将以下内容添加到你的`TableSource`类中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So what is next?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来是什么？
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's stop development and have a look at what we have achieved so far. We have
    created our first `UIViewController`, `UITableView`, `UITableViewSource`, and
    `UITableViewCell`, and bound them all together. Fantastic!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停止开发，看看我们到目前为止取得了什么成果。我们已经创建了我们的第一个`UIViewController`、`UITableView`、`UITableViewSource`和`UITableViewCell`，并将它们全部绑定在一起。太棒了！
- en: We now need to access the local storage of the phone to pull out the required
    gallery items. But before we do this, we are going to create an Android project
    and replicate what we have done with iOS.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要访问手机的本地存储以提取所需的画廊项目。但在我们这样做之前，我们将创建一个Android项目并复制我们在iOS中完成的事情。
- en: Creating an Android project
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Android项目
- en: 'Our first step is to create new general Android app:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个新的通用Android应用程序：
- en: '![Creating an Android project](img/B05293_01_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建Android项目](img/B05293_01_04.jpg)'
- en: 'The first screen you will land on is `MainActivity`. This is our starting activity,
    which will inflate the first user interface; take notice of the configuration
    attributes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先到达的屏幕是`MainActivity`。这是我们起始活动，它将填充第一个用户界面；请注意配置属性：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `MainLauncher` flag indicates the starting activity; one activity must
    have this flag set to `true` so the application knows what activity to load first.
    The `icon` property is used to set the application icon, and the `Label` property
    is used to set the text of the application, which appears in the top left of the
    navigation bar:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainLauncher`标志指示起始活动；一个活动必须将此标志设置为`true`，以便应用程序知道要首先加载哪个活动。`icon`属性用于设置应用程序图标，而`Label`属性用于设置出现在导航栏左上角的文本：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The formula for our activities is the same as Java; we must override the `OnCreate`
    method for each activity where we will inflate the first XML interface `Main.xml`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们活动的公式与Java相同；我们必须为每个活动重写`OnCreate`方法，在那里我们将填充第一个XML界面`Main.xml`。
- en: Creating an XML interface and ListView
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建XML界面和ListView
- en: 'Our starting point is the `main.xml` sheet; this is where we will be creating
    the `ListView`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的起点是`main.xml`表单；这是我们将在其中创建`ListView`的地方：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `main.xml` file should already be in the **resource** | **layout** directory,
    so simply copy and paste the previous code into this file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.xml`文件应该已经位于`资源` | `布局`目录中，所以只需将之前的代码复制粘贴到这个文件中。'
- en: Excellent! We now have our starting activity and interface, so now we have to
    create a `ListAdapter` for our `ListView`. An adapter works very much like a `UITableSource`,
    where we must override functions to determine cell data, row design, and the number
    of items in the list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有了我们的起始活动和界面，所以现在我们必须为我们的`ListView`创建一个`ListAdapter`。适配器的工作方式非常类似于`UITableSource`，我们必须重写函数来确定单元格数据、行设计和列表中的项目数量。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Xamarin Studio also has an Android GUI designer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio也拥有一个Android GUI设计器。
- en: 'Right-click on the Android project and add a new empty class file for our adapter
    class. Our class must inherit the `BaseAdapter` class, and we are going to override
    the following functions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击Android项目，为我们的适配器类添加一个新的空类文件。我们的类必须继承`BaseAdapter`类，并且我们将重写以下函数：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before we go any further, we need to create a model for the objects used to
    contain the data to be presented in each row. In our iOS project, we created a
    `GalleryItem` to hold the byte array of image data used to create each `UIImage`.
    We have two approaches here: we could create another object to do the same as
    the `GalleryItem`, or even better, why don''t we reuse this object using a shared
    project?'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要为用于在每一行中展示的数据创建一个模型。在我们的iOS项目中，我们创建了一个`GalleryItem`来保存创建每个`UIImage`所使用的字节数据。这里有两种方法：我们可以创建另一个对象来做与`GalleryItem`相同的事情，或者更好的是，为什么不用共享项目来重用这个对象呢？
- en: Shared projects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享项目
- en: We are going to delve into our first technique for sharing code between different
    platforms. This is what Xamarin wants us to achieve, and reuse as much code as
    possible. The biggest disadvantage when developing natively is two different language,
    and we can't reuse anything.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨在不同平台之间共享代码的第一种技术。这正是Xamarin希望我们实现并尽可能重用代码。原生开发的最大缺点是两种不同的语言，我们无法重用任何东西。
- en: 'Let''s create our first shared project:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个共享项目：
- en: '![Shared projects](img/B05293_01_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![共享项目](img/B05293_01_05.jpg)'
- en: 'Our shared project will be used to contain the `GalleryItem` model, so whatever
    code we include in this shared project can be accessed by both the iOS and Android
    projects:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们共享的项目将用于包含`GalleryItem`模型，因此我们在这个共享项目中包含的任何代码都可以被iOS和Android项目访问：
- en: '![Shared projects](img/B05293_01_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![共享项目](img/B05293_01_06.jpg)'
- en: In the preceding screenshot, have a look at the **Solution** explorer, and notice
    how the shared project doesn't contain anything more than `.cs` code sheets. Shared
    projects do not have any references or components, just code that is shared by
    all platform projects. When our native projects reference these shared projects,
    any libraries being referenced via `using` statements come from the native projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，看看**解决方案**资源管理器，注意共享项目除了`.cs`代码表之外不包含任何其他内容。共享项目没有任何引用或组件，只是所有平台项目共享的代码。当我们的本地项目引用这些共享项目时，通过`using`语句引用的任何库都来自本地项目。
- en: 'Now we must have the iOS and Android projects reference the shared project;
    right-click on the **References** folder and select **Edit References**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须让iOS和Android项目引用共享项目；右键单击**引用**文件夹并选择**编辑引用**：
- en: '![Shared projects](img/B05293_01_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![共享项目](img/B05293_01_07.jpg)'
- en: Select the shared project you just created and we can now reference the `GalleryItem`
    object from both projects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您刚刚创建的共享项目，现在我们可以从两个项目中引用`GalleryItem`对象。
- en: Custom row appearance
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义行外观
- en: 'Let''s get back to the `ListAdapter` implementation and design our `ListView`
    row appearance. Open the **Resources** | **Layout** folder, create a new `.xml`
    file for the cell appearance, call it `CustomCell.xml`, and copy in the following
    XML code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ListAdapter`的实现，并设计我们的`ListView`行外观。打开**资源** | **布局**文件夹，为单元格外观创建一个新的`.xml`文件，命名为`CustomCell.xml`，并复制以下XML代码：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are creating the same layout as the custom cell made for iOS, but in Android
    we will use the `ImageView` and `TextView` objects. Now that we have our custom
    cell, we can implement the the `GetView` function. The `GetView` function is exactly
    like the `GetCell` function in the preceding `UITableSource` implementation. Open
    up the `ListAdapter.cs` file and continue with the list adapter implementation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建与为iOS制作的自定义单元格相同的布局，但在Android中我们将使用`ImageView`和`TextView`对象。现在我们有了自定义单元格，我们可以实现`GetView`函数。`GetView`函数与前面`UITableSource`实现中的`GetCell`函数完全相同。打开`ListAdapter.cs`文件并继续列表适配器实现：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We override the `Count` property and functions `GetItemId` and `GetItem`, to
    return the number of gallery items in our list. These override functions are exactly
    the same as the overrides in Java for any `BaseAdapter` inherited class. Now for
    the `GetView` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写`Count`属性和`GetItemId`和`GetItem`函数，以返回我们列表中画廊项的数量。这些重写函数与Java中任何继承自`BaseAdapter`类的重写完全相同。现在来看`GetView`函数：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice in the `GetView` function we are using the `CustomCell` layout for each
    row; we also have a `private` method for creating our bitmaps from each model's
    byte array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`GetView`函数中，我们正在使用`CustomCell`布局为每一行；我们还有一个`private`方法用于从每个模型的字节数组中创建位图。
- en: If we have a look at the current implementation, what do we notice here?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看当前的实现，我们在这里注意到什么？
- en: We are creating a bitmap every time the cell requires this data again for the
    view; is this efficient? No, we should be reusing bitmaps and memory as much as
    possible.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每次单元格需要再次为视图提供此数据时，我们都在创建位图；这是否高效？不，我们应该尽可能重用位图和内存。
- en: This tends to be a common issue with Android `ListView`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是Android `ListView`的一个常见问题。
- en: What is the most memory efficient way to reuse bitmaps across hundreds of items
    in a `ListView` while scrolling and staying smooth as we move down the list at
    various speeds? How can we tackle this problem? Let's have a look at how we can
    approach this problem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动时，如何在`ListView`中跨数百个项高效地重用位图，同时保持平滑移动？我们如何解决这个问题？让我们看看我们如何解决这个问题。
- en: 'Firstly, we need to implement an object called `ImageHandler`. This will contain
    the logic for retrieving byte arrays from all gallery images on an Android device.
    Create a new file, name it `ImageHandler`, and start importing these namespaces:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要实现一个名为 `ImageHandler` 的对象。这将包含从 Android 设备上的所有图库图像中检索字节数组的逻辑。创建一个新文件，命名为
    `ImageHandler`，并开始导入这些命名空间：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This class will include a function, `GetFiles`, which will create gallery items
    based upon the items pulled from any device''s gallery using the `ContentResolver`
    interface:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本课程将包含一个名为 `GetFiles` 的函数，该函数将使用 `ContentResolver` 接口从任何设备的图库中提取项目，并基于这些项目创建图库项：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using `ContentResolver` (used to access the content model), we resolve **URIs**
    to specific content providers. A content provider provides queries to content,
    in our case image files. We simply create an access query off the main context''s
    `ContentResolver` instance, and we provide an array of columns for the query to
    retrieve (for example, file titles, file data, file size, and so on). The first
    parameter is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ContentResolver`（用于访问内容模型），我们将 URI 解析为特定的内容提供者。内容提供者提供对内容的查询，在我们的例子中是图像文件。我们只需从主上下文的
    `ContentResolver` 实例创建一个访问查询，并为查询提供要检索的列数组（例如，文件标题、文件数据、文件大小等）。第一个参数如下：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is used for retrieving the URI to each piece of content returned from
    the query. Finally, we now have a cursor to iterate through, exactly like an `Enumerable`,
    which will loop to the end until there are no more items, and for each iteration
    we pull the data and URI columns and create a new `GalleryItem`. You will notice
    a little trick here with the `yield` keyword: if we call this function, it will
    actually return the entire `Enumerable` from start to finish. Calling the function
    starts *for each-ing* over the object; the function is called again until it *yields*.
    In the return from calling this function, we get an `Enumerable` of all the items
    retrieved from the query as gallery items with image information and local URI.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于检索查询返回的每个内容片段的 URI。最后，我们现在有一个游标可以遍历，就像一个 `Enumerable`，它将循环到末尾，直到没有更多项目，并且对于每个迭代，我们提取数据列和
    URI 列，并创建一个新的 `GalleryItem`。您会注意到这里有一个使用 `yield` 关键字的技巧：如果我们调用此函数，它实际上会从开始到结束返回整个
    `Enumerable`。调用函数开始 *for each-ing* 对象；函数再次被调用，直到 *yields*。在调用此函数的返回中，我们得到一个 `Enumerable`，其中包含从查询中检索的所有项目，作为具有图像信息和本地
    URI 的图库项。
- en: Bitmap functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位图函数
- en: 'What about the byte data? First, let''s implement our `BitmapHelpers`; these
    will include two global functions to help with bitmap processing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数据怎么办？首先，让我们实现我们的 `BitmapHelpers`；这些将包括两个全局函数，以帮助进行位图处理：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our first function will determine the best sample size by the requested width
    and height. This is a very good technique for reducing the resources required
    to load an image into memory. Our next function is used to create a bitmap for
    the `ImageView` that is passed in from the byte data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数将通过请求的宽度和高度确定最佳采样大小。这是一种非常好的技术，可以减少加载图像到内存所需的资源。我们的下一个函数用于从传入的字节数据创建
    `ImageView` 的位图。
- en: 'The next step is to create this image data using the `private` method `createCompressedImageDataFromBitmap`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `private` 方法 `createCompressedImageDataFromBitmap` 创建这些图像数据：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method will take the image URI and decode the bitmap options in order to
    sample the smallest possible size for the dimensions provided.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将获取图像 URI 并解码位图选项，以便为提供的尺寸采样可能的最小大小。
- en: We have to make sure that we flag `InJustDecodeBounds` so this bitmap is not
    loaded into memory while we are retrieving the options information. This approach
    is very useful for reducing images to the size we require, thus saving memory.
    We then compress the image by 80% into a JPEG and convert the stream into a byte
    array for our `GalleryItem` model.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保设置 `InJustDecodeBounds` 标志，这样在检索选项信息时，此位图不会被加载到内存中。这种方法对于将图像减小到所需的大小非常有用，从而节省内存。然后我们将图像压缩成
    80% 的 JPEG，并将流转换为字节数组，用于我们的 `GalleryItem` 模型。
- en: 'Now let''s go back to the `adapter` class and add this method to fill in the
    items of our `ListAdapter`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `adapter` 类，并添加此方法以填充我们的 `ListAdapter` 的项目：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember we must have a reference in our list adapter to the main context.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们必须在我们的列表适配器中有一个对主上下文的引用。
- en: 'Now for the final piece of the puzzle, connecting the adapter to our list view.
    Open up the `MainActivity.cs` file and update the code list like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是拼图的最后一部分，将适配器连接到我们的列表视图。打开 `MainActivity.cs` 文件，并按如下方式更新代码列表：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: And voila! Try running the application and watching the `ListView` update with
    the images in your device's **Gallery** folder. Congratulations! You have just
    developed your first `Xamarin.Android` application. Now we must replicate this
    approach for the iOS version.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！尝试运行应用程序，并观察`ListView`如何更新为设备**画廊**文件夹中的图像。恭喜！您刚刚开发出了您的第一个`Xamarin.Android`应用程序。现在我们必须为iOS版本复制这种方法。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the challenge with context switching when jumping back and forth between
    Android and iOS; it can get confusing. Luckily, with Xamarin we keep to just one
    programming language, which helps reduce the complexity.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在Android和iOS之间跳转时，切换上下文带来的挑战；这可能会让人困惑。幸运的是，使用Xamarin，我们只需要一种编程语言，这有助于减少复杂性。
- en: The ALAssetLibrary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ALAssetLibrary
- en: Jumping back into our iOS, we are going to use the `ALAssetsLibrary` class and
    call the Enumerate function by passing in the group type `ALAssetsGroupType.SavedPhoto`,
    the enumeration result delegate `GroupEnumerator`, and the error action that will
    be performed if an exception occurs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回到iOS，我们将使用`ALAssetsLibrary`类并通过传递组类型`ALAssetsGroupType.SavedPhoto`、枚举结果代理`GroupEnumerator`和异常发生时将执行的错误操作来调用`Enumerate`函数。
- en: 'Start by adding in a new `.cs` file for our iOS image handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为我们的iOS图像处理器添加一个新的`.cs`文件：
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are not going to use a static class with this object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用一个静态类来处理这个对象。
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In our constructor, we create the new instance of the `ALAssetsLibrary` and
    call the `Enumerate` function; now let''s add the `GroupEnumerator` delegate:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们创建了新的`ALAssetsLibrary`实例并调用了`Enumerate`函数；现在让我们添加`GroupEnumerator`代理：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice the call to notify our event handler. This signals we have reached the
    end of the `asset` library, and we have retrieved all `ALAsset` in our gallery.
    We can now pull out a list of the file names, so we need to add another function
    that will pull out the `ALAsset` object synchronously:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用通知我们的事件处理器的过程。这表明我们已经到达了`asset`库的末尾，并且已经检索了我们画廊中的所有`ALAsset`。现在我们可以提取一个文件名列表，因此我们需要添加另一个同步提取`ALAsset`对象的函数：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we need a public function that will pull all the byte arrays and `NSURL`
    into an `Enumerable` of gallery items that we will use to populate the `UITableView`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个公共函数，该函数将所有字节数组和`NSURL`拉入一个用于填充`UITableView`的画廊项目`Enumerable`中。
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As this is only a demo, we are only going to take the first 100 items. If you
    would like another challenge, remove `Take(100)`, and see if you can adjust the
    code to load thousands of images more efficiently.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个演示，我们只取前100个项目。如果您想接受另一个挑战，请删除`Take(100)`，并看看您能否调整代码以更有效地加载更多的图像。
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s look a bit more closely at this function. We use the `asset` library
    object to pull out all the filenames we have in our gallery, then for each filename
    we pull out the `ALAsset` object, and from this we create a `GalleryItem` object
    for each, which takes the image data as a byte array from the `ALAsset` and the
    `NSURL` of the asset. Now let''s create an instance of the `ImageHandler` inside
    our `TableSource`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个函数。我们使用`asset`库对象提取我们画廊中的所有文件名，然后对于每个文件名，我们提取`ALAsset`对象，并从每个`ALAsset`创建一个`GalleryItem`对象，它从`ALAsset`中获取图像数据作为字节数组以及资产的`NSURL`。现在让我们在`TableSource`内部创建一个`ImageHandler`实例：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Excellent! Now we have our gallery items ready to display inside the table.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们的画廊项目已经准备好在表格中显示了。
- en: 'For the final piece of the iOS project, let''s go back to our `AppDelegate.cs`
    file. We still need to implement the `FinishedLaunching` method. Our root controller
    is going to be a `UINavigationController`, which will use the `MainController`
    as the starting `UIViewController`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS项目的最后一部分，让我们回到我们的`AppDelegate.cs`文件。我们仍然需要实现`FinishedLaunching`方法。我们的根控制器将是一个`UINavigationController`，它将以`MainController`作为起始的`UIViewController`：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We also adjust the window bounds the main screen bounds and call the function
    on the window at the very end of `MakeKeyAndVisible`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调整了窗口边界以匹配主屏幕边界，并在`MakeKeyAndVisible`的末尾调用窗口上的函数。
- en: Adding the iOS photo screen
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加iOS照片屏幕
- en: Now that we have our list page, we want to add another `UIViewController` for
    displaying selected photos. Let's add a new `UIViewController` and call it `PhotoController`.
    In `PhotoController`, we are going to build a screen that simply displays the
    same content in the `PhotoCell`, but a bit larger.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了列表页面，我们想要添加另一个`UIViewController`来显示选定的照片。让我们添加一个新的`UIViewController`并命名为`PhotoController`。在`PhotoController`中，我们将构建一个屏幕，它简单地显示与`PhotoCell`相同的内容，但更大一些。
- en: 'First, let''s add the navigation flow from `MainController` to `PhotoController`.
    We are going to be pushing a new `PhotoController` whenever a row is selected.
    Open up `TableSource.cs` and add the following; at the top, we need to add an
    `EventHandler`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从`MainController`到`PhotoController`添加导航流程。每当行被选中时，我们将推送一个新的`PhotoController`。打开`TableSource.cs`并添加以下内容；在顶部，我们需要添加一个`EventHandler`：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Whenever the row is selected we want to fire this event:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当行被选中时，我们希望触发以下事件：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Whenever the row is selected, we want to fire this event and pass the gallery
    item for the index path row. Now we need to handle this event in the `MainController`
    class to push a new `PhotoController` on the navigation stack, but before we do
    this we need to implement `PhotoController`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每当行被选中时，我们希望触发此事件并传递索引路径行的图库项。现在我们需要在`MainController`类中处理此事件，以便在导航堆栈上推送一个新的`PhotoController`，但在这样做之前，我们需要实现`PhotoController`：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is very similar to our `GalleryCell` presentation, but this controller
    will stack the elements vertically and force the image to scale to fit, keeping
    the image''s correct ratio to avoid any warping. Now let''s add `ViewDidLoad`
    to lay out the views:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的`GalleryCell`展示非常相似，但这个控制器将垂直堆叠元素并强制图像缩放以适应，同时保持图像的正确比例以避免任何扭曲。现在让我们添加`ViewDidLoad`来布局视图：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's nothing new here; we are simply adding the three elements and setting
    our layout constraints accordingly. We stretch all elements to the entire width
    of the view and stack elements down the pages with the image view on top and a
    dynamic size based upon the aspect size of the image.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容；我们只是添加了三个元素，并相应地设置布局约束。我们将所有元素拉伸到视图的整个宽度，并将元素堆叠在页面上，图像视图在顶部，大小根据图像的宽高比动态调整。
- en: 'Finally, the last step is to add the event handler whenever a row is selected.
    We use `ImageHandler` to fetch `ALAsset` by the title (filename) in the gallery
    item, then pass this into the constructor of a new `PhotoController` and update
    the constructor of `MainController`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步是在行被选中时添加事件处理程序。我们使用`ImageHandler`通过图库项中的标题（文件名）获取`ALAsset`，然后将其传递给新`PhotoController`的构造函数，并更新`MainController`的构造函数：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Excellent! Now run the application and try selecting a few items in the list;
    you will be navigated to a new `PhotoController` which will display the selected
    `ALAsset` image with its filename and date information.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在运行应用程序并尝试选择列表中的几个项目；您将被导航到一个新的`PhotoController`，该控制器将显示选中的`ALAsset`图像及其文件名和日期信息。
- en: Adding the Android photo screen
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Android照片屏幕
- en: 'Implementing a photo view for cell selections is very similar, although with
    Android we will be using an intent to create a new activity, which in turn will
    inflate a new view to display the image and details. Let''s start by adding a
    new XML called `photo_view.xml`, and paste in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实现单元格选择的相片视图与之前的方法非常相似，尽管在Android中我们将使用意图来创建新的活动，该活动随后将展开新的视图以显示图像和详细信息。让我们首先添加一个新的XML文件名为`photo_view.xml`，并粘贴以下代码：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The layout is very much the same as the `custom_cell.xml` sheet, although we
    are going to stack items vertically and set the following two properties to keep
    the correct image aspect ratio:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 布局与`custom_cell.xml`表单非常相似，尽管我们将垂直堆叠项目并设置以下两个属性以保持正确的图像宽高比：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure XML sheets do not contain the same IDs as any other XML sheet.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保XML表单不包含任何其他XML表单的相同ID。
- en: 'Now that we have our user interface for the `PhotoActivity`, let''s add the
    new activity:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`PhotoActivity`的用户界面，让我们添加新的活动：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Looking at this new activity, what can we see? Notice the attributes at the
    top:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个新的活动，我们能看到什么？注意顶部的属性：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is no `MainLauncher` tag because this is not our starting activity. We
    then add the `intent.GetExtras` for the image data and strings required to display
    on our `Photo` interface.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有找到`MainLauncher`标签，因为这不是我们的起始活动。然后我们添加`intent.GetExtras`以获取显示在`Photo`界面上的图像数据和字符串。
- en: 'Now we need to make one addition to the `ListAdapter` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向`ListAdapter`类添加一个功能：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When an item in the list is selected, we need to be able to access the selected
    `GalleryItem`. Our next step is to add the `ItemClick` delegate for the `ListView`.
    Open up the `MainActivity` class and add the following to the `OnCreate` function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表中的项目被选中时，我们需要能够访问选中的`GalleryItem`。我们的下一步是向`ListView`添加`ItemClick`委托。打开`MainActivity`类，并在`OnCreate`函数中添加以下内容：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Place this after we set the list adapter. When an item is clicked, we simply
    pull out the gallery item from our adapter by the position passed from the `ItemClickEventArgs`.
    Once we have the gallery item, we create the new `PhotoActivity` intent and pass
    the extras.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置列表适配器之后放置此内容。当点击一个项目时，我们只需通过从`ItemClickEventArgs`传递的位置从我们的适配器中提取画廊项目。一旦我们有了画廊项目，我们就创建新的`PhotoActivity`意图并传递额外的信息。
- en: That is all; run the application and play around selecting cells to display
    the `PhotoActivity`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些；运行应用程序并尝试选择单元格以显示`PhotoActivity`。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a gallery application on both iOS and Android using
    native development with Xamarin. We learnt how to setup projects in Xamarin Studio
    and code using the native frameworks in C#. In the next chapter, we will build
    a text to speech service using `Xamarin.Forms`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Xamarin原生开发在iOS和Android上构建了一个画廊应用程序。我们学习了如何在Xamarin Studio中设置项目并使用C#中的原生框架进行编码。在下一章中，我们将使用`Xamarin.Forms`构建一个文本到语音服务。
- en: Try improving on this code and make this function asynchronous; the more background
    processing we have at this stage, the better. These are the small improvements
    we should take time with, as combining all these small additions can create a
    real difference to the speed of your application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试改进此代码并使此函数异步；在这个阶段，我们拥有的后台处理越多，越好。这些是我们应该花时间进行的小改进，因为结合所有这些小添加可以真正提高您应用程序的速度。
- en: As this is only a demo, we are only going to take the first 100 items. If you would
    like another challenge, remove `Take(100)`, and see if you can adjust the code
    to load thousands of images more  efficiently.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个演示，我们只将取前100项。如果您想接受另一个挑战，请移除`Take(100)`，看看您能否调整代码以更高效地加载数千张图片。
