- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Setup and Theory: Docker and Onion Architecture'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和理论：Docker和洋葱架构
- en: 'This chapter discusses two important building blocks of modern microservices
    architectures, which will be used in most of the book’s examples, as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了现代微服务架构的两个重要构建块，这些构建块将在本书的大部分示例中使用，如下所示：
- en: '**Docker Containers**: Docker containers are a virtualization tool that enables
    your microservices to run on a wide range of hardware platforms, preventing compatibility
    issues.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker容器**：Docker容器是一种虚拟化工具，它使你的微服务能够在广泛的硬件平台上运行，防止兼容性问题。'
- en: '**The Onion Architecture**: The Onion Architecture confines dependencies from
    both the **user interface** (**UI**) and from the deployment platform in drivers
    so that the software modules that encode the whole business knowledge are completely
    independent of the chosen UI, tools, and runtime environment. Moreover, in order
    to optimize the interaction between domain experts and developers, all domain
    entities are implemented as classes in the following way:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**洋葱架构**：洋葱架构将用户界面（**UI**）和部署平台的依赖关系限制在驱动程序中，这样编码整个业务知识的软件模块就完全独立于所选UI、工具和运行时环境。此外，为了优化领域专家和开发者之间的交互，所有领域实体都以下列方式实现为类：'
- en: Each entity interacts with the remainder of the code only through methods that
    represent the behavior of all actual domain entities.
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个实体仅通过表示所有实际领域实体行为的函数与代码的其余部分交互。
- en: Names of entities and entity members are taken from the vocabulary of the application
    domain. The purpose is to build up a common language between developers and users
    called the **ubiquitous language**.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体和实体成员的名称来自应用程序领域的词汇表。目的是在开发者和用户之间建立一个称为**通用语言**的共同语言。
- en: While Docker containers are roughly tied to microservice performance optimization,
    the Onion Architecture is not specific for microservices. However, the Onion Architecture
    described here was designed specifically for use with microservices, as it makes
    wide use of some of the microservice-specific patterns we described in [*Chapter
    2*](Chapter_2.xhtml#_idTextAnchor038)*, Demystifying Microservices Applications*,
    such as publisher-subscriber events, to maximize the independence of software
    modules and to ensure separation between update and query software modules.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker容器与微服务性能优化大致相关，但洋葱架构并不特定于微服务。然而，这里描述的洋葱架构是专门为与微服务一起使用而设计的，因为它广泛使用了我们在[*第2章*](Chapter_2.xhtml#_idTextAnchor038)*，揭秘微服务应用程序*中描述的一些特定于微服务的模式，例如发布-订阅事件，以最大限度地提高软件模块的独立性，并确保更新和查询软件模块之间的分离。
- en: In this chapter, we will introduce a Visual Studio solution template based on
    the Onion Architecture along with code snippets that we will use throughout the
    remainder of the book for implementing any kind of microservice. We will discuss
    both the theory behind it and its pros.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个基于洋葱架构的Visual Studio解决方案模板，以及我们将在这本书的剩余部分中使用的代码片段，用于实现任何类型的微服务。我们将讨论其背后的理论及其优点。
- en: 'More specifically, this chapter covers the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖了以下内容：
- en: The Onion Architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洋葱架构
- en: A solution template based on the Onion Architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于洋葱架构的解决方案模板
- en: Containers and Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和Docker
- en: By the end of the chapter, you should be able to create an application based
    on the Onion Architecture and work with Docker containers, which are the building
    blocks of complex microservices applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够创建一个基于洋葱架构的应用程序，并使用Docker容器，这些容器是复杂微服务应用程序的构建块。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: At a minimum, the Visual Studio 2022 free *Community edition*.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少需要Visual Studio 2022的免费**社区版**。
- en: '**Docker Desktop** for Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Docker Desktop** for Windows ([https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop))'
- en: '**Docker Desktop**, in turn, requires **Windows Subsystem for Linux (WSL)**,
    which can be installed by following these steps:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Docker Desktop**，反过来，需要**Windows Subsystem for Linux (WSL**)，可以通过以下步骤安装：'
- en: Type `powershell` in the Windows 10/11 search bar.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows 10/11的搜索栏中输入`powershell`。
- en: When Windows PowerShell is proposed as a search result, click on **Run as an
    administrator**.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当Windows PowerShell作为搜索结果出现时，点击**以管理员身份运行**。
- en: In the Windows PowerShell administrative console that appears, run the `wsl
    --install` command.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的 Windows PowerShell 管理控制台中，运行 `wsl --install` 命令。
- en: You can find the sample code for this chapter at [https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)找到本章的示例代码。
- en: The Onion Architecture
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 洋葱架构
- en: The Onion Architecture makes a clear distinction between domain-specific code
    and the technical code that handles the UI, storage interaction, and hardware
    resources. This keeps the domain-specific code completely independent of technical
    tools, such as the operating system, web technology, database, and database interaction
    tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 洋葱架构在领域特定代码和处理 UI、存储交互和硬件资源的技术代码之间做出了明确的区分。这使领域特定代码完全独立于技术工具，例如操作系统、网络技术、数据库和数据库交互工具。
- en: 'The whole application is organized into layers, with the outermost layer having
    the sole purpose of providing all the necessary infrastructure (i.e., drivers),
    UI, and test suites, as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序组织成层，最外层只有一个目的，即提供所有必要的基础设施（即驱动程序）、UI 和测试套件，如图所示：
- en: '![Figure 3.1: Basic Onion Architecture](img/B31916_03_1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：基本洋葱架构](img/B31916_03_1.png)'
- en: 'Figure 3.1: Basic Onion Architecture'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：基本洋葱架构
- en: 'In turn, the application-specific code is organized into several more nested
    layers. All layers must satisfy the following constraint:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，应用特定代码组织成几个更嵌套的层。所有层都必须满足以下约束：
- en: Each layer may reference only inner layers. The way this constraint is implemented
    depends on the underlying language and stack. For instance, layers can be implemented
    as packages, namespaces, or libraries. We will implement layers with .NET library
    projects that can be easily turned into NuGet packages, too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层可能只能引用内部层。这种约束的实现方式取决于底层语言和堆栈。例如，层可以实施为包、命名空间或库。我们还将使用 .NET 库项目来实现层，这些项目可以轻松地转换为
    NuGet 包。
- en: So, for instance, in the preceding figure, the outermost layer may reference
    all application-specific libraries, plus all libraries that implement all the
    required drivers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，在先前的图中，最外层可能引用所有应用特定库，以及实现所有所需驱动程序的库。
- en: 'The application-specific code references the functionalities implemented in
    the outermost layer’s drivers through interfaces, while the outermost layer has
    the main function of providing a dependency injection engine that couples each
    of these interfaces with a driver that implements it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定代码通过接口引用最外层驱动程序中实现的功能，而最外层的主要功能是提供一个依赖注入引擎，将每个接口与其实现的驱动程序耦合：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The application-specific layer, in turn, is composed of at least two main layers:
    a layer that contains all domain entity definitions, called the **Domain layer**,
    and a layer that contains the definition of all application operations, called
    the **Application Services** layer, as shown in the following figure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应用特定层反过来又由至少两个主要层组成：一个包含所有领域实体定义的层，称为**领域层**，以及一个包含所有应用操作定义的层，称为**应用服务层**，如图所示：
- en: '![Figure 3.2: Complete Onion Architecture](img/B31916_03_2.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：完整的洋葱架构](img/B31916_03_2.png)'
- en: 'Figure 3.2: Complete Onion Architecture'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：完整的洋葱架构
- en: If needed, the Application Services layer can be split into more sublayers,
    and more layers can be placed between the Application Services and Domain layers,
    but this is rarely done.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，应用服务层可以进一步分为更多子层，并且可以在应用服务和领域层之间放置更多层，但这很少发生。
- en: 'The Domain layer is often split into two sublayers: **the Model layer,** which
    contains the actual domain entity definitions, and the **Domain Services** layer,
    which contains further business rules.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层通常分为两个子层：**模型层**，其中包含实际的领域实体定义，以及**领域服务层**，其中包含更进一步的业务规则。
- en: Throughout this book, we will use just the Application Services and Domain layers.
    We will discuss each of them in a separate subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们将仅使用应用服务和领域层。我们将在单独的小节中讨论每个层。
- en: The Domain layer
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域层
- en: The Domain layer contains the class representation of each domain entity with
    its behavior encoded in the public method of such classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层包含每个领域实体的类表示，其行为编码在这些类的公共方法中。
- en: Moreover, domain entities can be modified just with methods that represent actual
    domain operations. Thus, for instance, we can’t directly access and modify all
    fields of a purchase order; we are limited to manipulating it just through methods
    that represent actual domain operations, such as adding or deleting an item, applying
    a discount, or modifying the delivery date.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，域实体可以通过表示实际域操作的方法进行修改。因此，例如，我们无法直接访问和修改采购订单的所有字段；我们仅限于通过表示实际域操作的方法来操作它，例如添加或删除项目、应用折扣或修改交货日期。
- en: The names of all public methods and properties must be built with the actual
    language used by the domain experts, the previously mentioned **ubiquitous language**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有公共方法和属性的名称必须使用域专家实际使用的语言构建，即之前提到的**通用语言**。
- en: All the preceding constraints have the purpose of optimizing communication between
    developers and experts. In this way, domain experts and developers can discuss
    the public interface of the entity since it uses the same vocabulary and actual
    domain operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述约束的目的是优化开发人员与专家之间的通信。这样，域专家和开发人员可以讨论实体的公共接口，因为它使用相同的词汇和实际域操作。
- en: 'The following is a part of a hypothetical `PurchaseOrde`r entity:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个假设的`PurchaseOrder`实体的部分：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once taken from the constructor, `CreationTime` cannot be modified anymore,
    so it is implemented as a {`get; init;}` property. The list of all items can be
    modified through the `AddItem` and `RemoveItem` methods, which are understandable
    by all domain experts. Finally, we can delay the delivery date but we can’t anticipate
    it. This automatically encodes a domain business rule by enforcing the use of
    the `DelayDeliveryTime` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从构造函数中取出，`CreationTime`就无法再修改，因此它被实现为一个 `{`get; init;`}` 属性。所有项目的列表可以通过`AddItem`和`RemoveItem`方法进行修改，这些方法对所有域专家来说都是可理解的。最后，我们可以延迟交货日期，但不能提前预测。这自动通过强制使用`DelayDeliveryTime`方法来编码域业务规则。
- en: We can improve the `PurchaseOrde`r entity by adding a `PurchaseTotal` **get
    property** that returns the total amount of the purchase, and by adding an `ApplyDiscount`
    method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个返回采购总金额的`PurchaseTotal` **获取属性**以及添加一个`ApplyDiscount`方法来改进`PurchaseOrder`实体。
- en: 'Summing up, we can state the following rule:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总结起来，我们可以提出以下规则：
- en: Domain entity states can only be changed through methods that encode actual
    domain operations and that automatically enforce all business rules.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 域实体状态只能通过编码实际域操作并自动强制执行所有业务规则的方法来更改。
- en: 'These entities differ a lot from the usual **Entity Framework Core** entities
    we are used to for the following reasons:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体与我们所习惯的**Entity Framework Core**实体有很大不同，原因如下：
- en: Entity Framework Core entities are record-like classes with no methods. That
    is, they are just a set of property-value pairs.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core实体是类似记录的类，没有方法。也就是说，它们只是一组属性-值对。
- en: Each Entity Framework Core entity corresponds to a single object related somehow
    to other entities, while domain entities are often trees of nested objects. That
    is why domain entities are usually called **aggregates**.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Entity Framework Core实体对应一个与其它实体有关联的单个对象，而域实体通常是嵌套对象的树。这就是为什么域实体通常被称为**聚合**。
- en: Thus, for instance, the `PurchaseOrder` aggregate contains a main entity and
    a `PurchaseOrderItem` collection. It is worth pointing out that `PurchaseOrderItem`
    cannot be considered a separate domain entity since there are no domain operations
    that involve a single `PurchaseOrderItem`, but `PurchaseOrderItem` can be manipulated
    just as a part of `PurchaseOrder`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，`PurchaseOrder`聚合包含一个主实体和一个`PurchaseOrderItem`集合。值得注意的是，`PurchaseOrderItem`不能被视为一个独立的域实体，因为没有涉及单个`PurchaseOrderItem`的域操作，但`PurchaseOrderItem`可以像`PurchaseOrder`的一部分一样被操作。
- en: 'A similar phenomenon doesn’t occur with flat Entity Framework entities, as
    they lack the concept of domain operations. We may conclude the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种现象在扁平的Entity Framework实体中不会发生，因为它们缺乏域操作的概念。我们可以得出以下结论：
- en: Domain operations on domain entities can force them to merge with dependent
    entities, thus becoming a complex tree of objects called **aggregates**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 域实体上的域操作可以迫使它们与依赖实体合并，从而成为一个称为**聚合**的复杂对象树。
- en: For the remainder of this book, we will refer to domain entities as aggregates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将把域实体称为聚合。
- en: 'So far, we have given entities a strong application domain semantic together
    with the concept of aggregation. These aggregates differ a lot from database tuples
    and also from their object representation provided by ORMS such as Entity Framework
    Core, so we have a mismatch between aggregates and the structures used to persist
    them. This mismatch could be solved in several ways, but all solutions must conform
    to the **persistence ignorance** principle:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经给实体赋予了强大的应用领域语义以及聚合的概念。这些聚合与数据库元组以及ORMS（如Entity Framework Core）提供的对象表示有很大不同，因此聚合与用于持久化的结构之间存在不匹配。这种不匹配可以通过几种方式解决，但所有解决方案都必须符合**持久化无知**原则：
- en: Aggregates must not be impacted by how they might be persisted. They must be
    completely decoupled from the persistence code, and the persistence technique
    must not impose any constraint on the aggregate design.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合不应受其可能如何持久化的影响。它们必须与持久化代码完全解耦，持久化技术不得对聚合设计施加任何约束。
- en: 'We now observe another phenomenon: entities without an identity!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在观察到另一个现象：没有身份的实体！
- en: Two purchase orders with exactly the same dates and items remain two different
    entities; in fact, they must have a different delivery for each of them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个日期和项目完全相同的采购订单仍然是两个不同的实体；实际上，它们必须为每个实体有不同的交货。
- en: However, what happens with two addresses containing exactly the same fields?
    If we consider the semantics of an address, can we say they are two different
    entities?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于包含完全相同字段的两个地址会发生什么？如果我们考虑地址的语义，我们能否说它们是两个不同的实体？
- en: 'Each address denotes a place, and if two addresses have the same fields, they
    denote exactly the same place. Thus, addresses are just like numbers: even though
    we may replicate them several times, each copy always denotes the same abstract
    entity.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个地址表示一个地点，如果两个地址具有相同的字段，它们表示的地点也完全相同。因此，地址就像数字一样：即使我们可能复制它们多次，每个副本始终表示相同的抽象实体。
- en: Therefore, we may conclude that addresses with the same fields are indistinguishable.
    Relational databases use principal keys to verify when two tuples reference the
    same abstract entity, so we may conclude that the principal key of an address
    should be the set of all its fields.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，具有相同字段的地址是不可区分的。关系数据库使用主键来验证两个元组是否引用相同的抽象实体，因此我们可以得出结论，地址的主键应该是所有字段的集合。
- en: In the theory of domain entities, objects similar to addresses are called value
    objects, and their in-memory representation must not contain explicit principal
    keys. An equality operator applied to two instances of them must return `true`
    if and only if all their fields are equal. Moreover, they must be immutable –
    that is, once created, their properties cannot be changed, so the only way to
    modify a value object is to create a new object with some property value changed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域实体理论中，类似于地址的对象被称为值对象，它们在内存中的表示不得包含显式的主键。应用于它们两个实例的相等运算符必须仅在所有字段都相等时返回`true`。此外，它们必须是不可变的——也就是说，一旦创建，它们的属性就不能更改，因此修改值对象的唯一方法是用一些属性值更改创建一个新的对象。
- en: 'In C#, value objects are easily represented with **records**:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，值对象可以用**记录**轻松表示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `init` keyword is what makes record-type properties immutable since it means
    they can only be
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`关键字使得记录类型属性不可变，因为它意味着它们只能'
- en: 'initialized. A modified copy of a record can be created as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化。可以创建如下修改后的记录副本：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we pass all the properties in the constructor instead of using initializers,
    the preceding definition can be simplified as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在构造函数中传递所有属性而不是使用初始化器，则前面的定义可以简化如下：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Typical value objects include costs (represented as a number and a currency
    symbol), locations (represented as longitude and latitude), addresses, and contact
    information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的值对象包括成本（表示为数字和货币符号）、位置（表示为经度和纬度）、地址和联系信息。
- en: In practice, value objects can be represented in databases with the usual tuple
    with a principal key (for instance, an autoincremented integer). Then, a new copy
    of each tuple can be created differently for each occurrence of the same address.
    It is also possible to enforce a unique database copy by defining complex composite
    keys.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，值对象可以用包含主键（例如，一个自增整数）的常规元组在数据库中表示。然后，可以为每个相同地址的出现创建不同的新元组副本。也可以通过定义复杂的复合键来强制执行唯一的数据库副本。
- en: Since aggregates and value objects differ a lot from the entities used by all
    main ORMs such as Entity Framework, when we use ORMS to interact with databases,
    we must translate ORM entities into aggregates and value objects, and vice versa,
    each time we exchange data with an ORM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于聚合和值对象与所有主要ORM（如Entity Framework）使用的实体有很大不同，当我们使用ORM与数据库交互时，我们必须在每次与ORM交换数据时将ORM实体转换为聚合和值对象，反之亦然。
- en: According to general Onion Architecture rules, the Domain layer interacts with
    the actual implementation provided by an ORM through an interface. This is usually
    done with the so-called **repository pattern**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据通用的洋葱架构规则，领域层通过接口与ORM提供的实际实现进行交互。这通常是通过所谓的**仓库模式**来完成的。
- en: According to the repository pattern, a storage service must be provided through
    one separate interface for each aggregate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 根据仓库模式，必须为每个聚合提供一个单独的接口来提供存储服务。
- en: This means the Domain layer must contain a different interface for each aggregate,
    which takes care of retrieving, saving, and deleting the whole aggregate. The
    repository pattern helps keep the code modular and easy to search and update since
    we know we must have one and only one repository interface for each aggregate,
    so we can organize the whole aggregate-related code in a single folder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着领域层必须为每个聚合包含一个不同的接口，该接口负责检索、保存和删除整个聚合。仓库模式有助于保持代码模块化，易于搜索和更新，因为我们知道我们必须为每个聚合只有一个仓库接口，因此我们可以将整个聚合相关代码组织在单个文件夹中。
- en: The actual implementation of each repository is contained in the Infrastructure
    layer of the Onion Architecture in a kind of database (or persistence) driver,
    together with various other drivers that virtualize the interaction with the infrastructure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个仓库的实际实现包含在洋葱架构的基础设施层中的一种数据库（或持久性）驱动程序中，以及各种其他驱动程序，这些驱动程序虚拟化了与基础设施的交互。
- en: Each aggregate repository interface contains methods that return aggregates,
    delete aggregates, and make any other kind of persistency-related operations on
    aggregates.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个聚合仓库接口包含返回聚合、删除聚合以及在对聚合执行任何其他持久性相关操作的方法。
- en: In complex applications, it is best practice to split the Domain layer into
    a Model layer, which contains just aggregates, and an outer Domain Services layer,
    which contains the repository interfaces and the definition of domain operations
    that can’t be implemented as aggregate methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的应用程序中，将领域层拆分为一个仅包含聚合的模型层和一个外部的领域服务层是最佳实践，其中领域服务层包含仓库接口和定义那些不能作为聚合方法实现的领域操作。
- en: In particular, **Domain Services** interfaces handle the tuples used to encode
    the results returned by query microservices. These tuples are not aggregates but
    a mix of data taken from different data tables, so they conform to a completely
    different design pattern. They are returned as record-like objects with no methods
    and just properties that correspond to the database tuples fields. Further **Domain
    Services** interfaces are implemented in the persistence driver of the infrastructure
    layer, too.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，**领域服务**接口处理用于编码查询微服务返回结果的元组。这些元组不是聚合，而是来自不同数据表的数据的混合，因此它们符合完全不同的设计模式。它们作为没有方法、只有与数据库元组字段相对应的属性的记录样对象返回。进一步的**领域服务**接口也在基础设施层持久性驱动程序中实现。
- en: Handling queries and modifications separately and with different design patterns
    is known as the **Command Query Responsibility Segregation (CQRS**) pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 分别处理查询和修改，并使用不同的设计模式，这被称为**命令查询责任分离（CQRS）模式**。
- en: Since, the microservices described in this book are quite simple, in our code
    examples, we will not split the domain layer into the model and domain services
    layers. Therefore, the repository and other domain services interfaces will be
    mixed with aggregates in the same Visual Studio project. However, when implementing
    more complex applications, you should use the division of the domain layer into
    the model and domain services layers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中描述的微服务相当简单，在我们的代码示例中，我们不会将领域层拆分为模型和领域服务层。因此，仓库和其他领域服务接口将与聚合混合在同一Visual
    Studio项目中。然而，在实现更复杂的应用程序时，你应该使用将领域层拆分为模型和领域服务层的做法。
- en: 'Let’s look at some examples of a repository interface. The `PurchaseOrder`
    aggregate might have an associated repository interface that looks as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些仓库接口的示例。`PurchaseOrder`聚合可能有一个相关的仓库接口，看起来如下所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is no update method since updates are implemented by directly calling
    the aggregate methods. The last method in the code shown returns a collection
    of record-like DTOs called `OrderBasicInfoDTO`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更新方法，因为更新是通过直接调用聚合体方法实现的。代码中显示的最后一个方法返回一个名为`OrderBasicInfoDTO`的记录样式的DTO集合。
- en: It is worth pointing out that there are no repository interfaces associated
    with value objects since value objects are handled just as primitive types, such
    as integers, decimals, or strings.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于值对象被像整数、小数或字符串这样的原始类型一样处理，因此与值对象没有关联的存储库接口。
- en: Several changes to different aggregates can be dealt with in a transactional
    way thanks to the **Unit Of Work** pattern, which will be described later on in
    the *Command* subsection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多个不同聚合体的更改可以通过**工作单元**模式以事务方式处理，该模式将在后面的*命令*子节中描述。
- en: More details on how Entity Framework Core supports the implementation of repository
    interfaces and on how domain objects are tied and translated back and forth to
    Entity Framework Core entities will be given in the *A solution template based
    on the Onion Architecture* section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Entity Framework Core如何支持实现存储库接口以及如何将领域对象与Entity Framework Core实体相互绑定和转换的更多细节将在*基于洋葱架构的解决方案模板*部分给出。
- en: Having understood the in-memory representation of domain objects, we can move
    on to the way a microservices-oriented Onion Architecture represents all business
    transactions/operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了领域对象的内存表示后，我们可以继续了解面向微服务的洋葱架构如何表示所有业务事务/操作。
- en: Application services
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用服务
- en: In the *Microservices organization* subsection of[*Chapter 2*](Chapter_2.xhtml#_idTextAnchor038)*,
    Demystifying Microservices Applications*, we saw that microservices architectures
    often use the **CQRS** pattern, which is where some microservices specialize in
    queries and others specialize in updates. That is the strong version of the CQRS
    pattern, but there is also a weaker version that simply requires that queries
    and updates be organized into different modules, possibly belonging to the same
    microservice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](Chapter_2.xhtml#_idTextAnchor038)的*微服务组织*子节[*揭秘微服务应用*]中，我们了解到微服务架构通常使用**CQRS**模式，其中一些微服务专门处理查询，而另一些则专门处理更新。这就是CQRS模式的强版本，但还有一个较弱的版本，它只需将查询和更新组织到不同的模块中，这些模块可能属于同一个微服务。
- en: While it is not always convenient to apply CQRS in its stronger form, its weaker
    form is a must when implementing microservices, as updates involve aggregates
    while queries involve just record-like DTOs, so they require completely different
    types of processing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并不总是方便应用CQRS的较强形式，但在实现微服务时，其较弱形式是必须的，因为更新涉及聚合体，而查询仅涉及记录样式的DTO，因此它们需要完全不同类型的处理。
- en: 'Accordingly, the operations defined in the application services layer of a
    microservice are split into two different types: **queries** and **commands**.
    As we will see, the execution of commands can trigger events, so together with
    commands and queries, application services must also handle so-called **domain
    events**. We will discuss all these different operations in the dedicated subsections
    that follow.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在微服务的应用服务层中定义的操作被分为两种不同类型：**查询**和**命令**。正如我们将看到的，命令的执行可以触发事件，因此与应用服务和查询一起，应用服务还必须处理所谓的**领域事件**。我们将在接下来的专用子节中讨论所有这些不同的操作。
- en: Queries
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: A query object represents one or several similar queries, so it usually has
    one or several methods that take some inputs and return the query results. Most
    query methods just call a single repository method that implements the needed
    query, but in some cases, they may execute several repository methods and then
    they may somehow merge their results.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对象代表一个或多个类似的查询，因此它通常有一个或多个方法，这些方法接受一些输入并返回查询结果。大多数查询方法只是调用一个实现所需查询的单个存储库方法，但在某些情况下，它们可能执行多个存储库方法，然后它们可能会以某种方式合并它们的结果。
- en: During system testing, actual query implementations must be replaced by fake
    implementations, so, usually, each query has an associated interface that is coupled
    with the actual implementation in the dependency injection engine. This way, the
    UI may just require the interface in some constructor, thus enabling testing with
    a fake implementation of the query.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统测试期间，实际的查询实现必须被模拟实现所替代，因此，通常每个查询都有一个与之关联的接口，该接口与依赖注入引擎中的实际实现耦合。这样，UI可能只需要在某个构造函数中提供该接口，从而可以使用查询的模拟实现进行测试。
- en: 'The following is a possible definition of a query that returns all purchase
    orders emitted after a given date, together with its associated interface:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的查询定义，该查询返回在给定日期之后发出的所有采购订单，以及其关联的接口：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The interface inherits from an empty interface whose unique purpose is to mark
    both the interface and its implementation as queries. This way, all queries and
    their associated implementation can be automatically found with the help of reflection
    and added to the dependency injection engine. We will provide the code that discovers
    all queries in the *A solution template based on the Onion Architecture* section
    together with a complete solution template.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口继承自一个空接口，其唯一目的是标记接口及其实现为查询。这样，所有查询及其相关实现都可以通过反射自动找到并添加到依赖注入引擎中。我们将在“基于洋葱架构的解决方案模板”部分提供发现所有查询的代码，以及一个完整的解决方案模板。
- en: As mentioned, the implementation just calls a repository method and passes it
    adequate parameters. An implementation of the repository is passed in the principal
    constructor of the class by the same dependency injection engine that will inject
    the query itself in the constructor of a presentation layer object (a controller,
    in the case of an ASP.NET Core website).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实现只是调用存储库方法并传递足够的参数。存储库的实现是通过与将查询本身注入到表示层对象（在ASP.NET Core网站上是控制器）的构造函数相同的依赖注入引擎传递到类的主体构造函数中的。
- en: Commands
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'Commands work in a slightly different way because, for better code readability,
    each command represents a single application operation. For this reason, each
    command instance represents both the abstract operation and its input. The actual
    operation implementation is contained in a command handler object. The following
    is the code of a hypothetical command that applies a discount to a purchase order:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 命令以略有不同的方式工作，因为为了提高代码的可读性，每个命令代表一个单独的应用程序操作。因此，每个命令实例代表抽象操作及其输入。实际的操作实现包含在命令处理程序对象中。以下是一个假设的命令的代码，该命令将折扣应用于采购订单：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Commands must be immutable; that’s why we implanted them as records. In fact,
    the only operation allowed on them is their execution. Similar to queries, commands
    also implement an empty interface that marks them as commands (in this case, `ICommand`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 命令必须是不可变的；这就是为什么我们将它们实现为记录。实际上，对它们唯一允许的操作是它们的执行。类似于查询，命令也实现了一个空接口，标记它们为命令（在这种情况下，`ICommand`）。
- en: 'Command handlers are implementations of the following interface:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序是实现以下接口的实现：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can, see all command handlers implement the same `HandleAsync` method
    that accepts the command as its single input. Thus, for instance, the handler
    associated with `ApplyDiscountCommand` is something like the following class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有命令处理程序都实现了相同的`HandleAsync`方法，该方法接受命令作为其唯一的输入。因此，例如，与`ApplyDiscountCommand`关联的处理程序可能如下所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All handlers must be added to the dependency injection engine, as shown in
    the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理程序都必须添加到依赖注入引擎中，如下例所示：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This can be done automatically by scanning the application services assembly
    with reflection. We will provide the code that discovers all command handlers
    in the *A solution template based on the Onion Architecture* section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用反射扫描应用程序服务程序集来自动完成。我们将在“基于洋葱架构的解决方案模板”部分提供发现所有命令处理程序的代码。
- en: Each command handler gets or creates aggregates, modifies them by calling their
    methods, and then executes a save instruction to persist all modifications in
    the underlying storage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令处理程序都会获取或创建聚合，通过调用它们的方法来修改它们，然后执行一个保存指令以在底层存储中持久化所有修改。
- en: 'The save operation must be implemented in the storage driver (for instance,
    Entity Framework Core), so, as usual for all Onion Architecture drivers’ operations,
    it is mediated by an interface. The interface that performs the save operations
    and other transaction-related operations is usually called **IUnitOfWork**. A
    possible definition of this interface is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 保存操作必须在存储驱动程序（例如，Entity Framework Core）中实现，因此，对于所有洋葱架构驱动程序的常规操作，它通常通过接口进行中介。执行保存操作和其他事务相关操作的接口通常称为**IUnitOfWork**。此接口的可能定义如下：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s break this down:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`SaveEntitiesAsync` saves all updaters performed so far in a single transaction.
    It returns `true` if the storage engine actually changed after the save operation,
    and `false` otherwise.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SaveEntitiesAsync` 在单个事务中保存迄今为止执行的所有更新器。如果存储引擎在保存操作后实际上发生了变化，则返回 `true`，否则返回
    `false`。'
- en: '`StartAsync` starts a transaction.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StartAsync` 开始一个事务。'
- en: '`CommitAsync` and `RollbackAsync` respectively commit and roll back an opened
    transaction.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommitAsync` 和 `RollbackAsync` 分别提交和回滚一个打开的事务。'
- en: 'All methods that explicitly control the start and end of a transaction are
    useful for enclosing both a get operation and the final `SaveEntitiesAsync` save
    in the same transaction, as in the following simplified flight reservation snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有明确控制事务开始和结束的方法都很有用，可以将获取操作和最终的 `SaveEntitiesAsync` 保存操作封装在同一事务中，如下面的简化航班预订片段所示：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If there are no more available seats, the transaction is aborted, but if there
    are available seats, we are sure that no other passenger can take the available
    seat because both the query and the update are performed in the same transaction,
    thus preventing interference from other reservation operations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的可用座位，事务将被中止，但如果还有可用座位，我们确信没有其他乘客可以占用这个座位，因为查询和更新都是在同一事务中执行的，从而防止其他预订操作的影响。
- en: Of course, the preceding code works if the transaction has an adequate isolation
    level and if the database supports that isolation level. We can use a high enough
    isolation level for all operations in our microservice; otherwise, we are forced
    to pass the isolation level as a `StartAsync` argument.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果事务具有足够的隔离级别并且数据库支持该隔离级别，前面的代码是有效的。我们可以为微服务中的所有操作使用足够高的隔离级别；否则，我们被迫将隔离级别作为
    `StartAsync` 参数传递。
- en: Now, we are ready to explain why domain events are needed, and how they are
    handled.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备解释为什么需要领域事件，以及它们是如何被处理的。
- en: Domain events
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域事件
- en: 'We may define **domain events** as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样定义**领域事件**：
- en: '**Domain events** are events originating from something happening in the microservice
    domain and are handled within the boundaries of the microservice itself. This
    means they involve communications based on the publisher-subscriber pattern between
    two chunks of code of the same microservice.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域事件**是从微服务领域中发生的事情产生的，并且是在微服务本身的边界内被处理的。这意味着它们涉及同一微服务两段代码之间的基于发布者-订阅者模式的通信。'
- en: Therefore, they must not be confused with the events involved in the communications
    between different microservices, which are called **integration events** to distinguish
    them from domain events.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它们不应与涉及不同微服务之间通信的事件混淆，这些事件被称为**集成事件**，以区分领域事件。
- en: 'Why use events inside the boundaries of a microservice? The reason is always
    the same: to ensure a better decoupling between parts. Here, the parts involved
    are aggregates. The code of each aggregate must be completely independent of other
    aggregates to ensure modularity and modifiability, so relations between aggregates
    are either mediated by command handlers or by some publisher-subscriber pattern.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在微服务的边界内使用事件？原因始终相同：为了确保部分之间的更好的解耦。在这里，涉及的部件是聚合。每个聚合的代码必须完全独立于其他聚合，以确保模块化和可修改性，因此聚合之间的关系要么由命令处理器中介，要么由某种发布者-订阅者模式中介。
- en: 'Accordingly, if the interaction between two aggregates is somehow decided by
    the code of a command handler, the same command handler might take care of processing
    the data of both of them and then somehow update them. However, if the interaction
    is tied to the processing within an aggregate method, we are forced to use events
    because we can’t make an aggregate aware of all the other aggregates that need
    to be informed about some of its data changes. Summing up, we may state the following
    principle:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果两个聚合之间的交互由命令处理器的代码决定，同一个命令处理器可能会负责处理它们的数据，然后以某种方式更新它们。然而，如果交互与聚合方法内的处理相关联，我们被迫使用事件，因为我们无法让聚合意识到所有需要通知其数据更改的其他聚合。总结一下，我们可以提出以下原则：
- en: Domain events are triggered just inside aggregate methods because other kinds
    of interactions are better handled by command handlers’ code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件仅在聚合方法内部触发，因为其他类型的交互更适合由命令处理器的代码来处理。
- en: 'Another important principle is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的原则是以下内容：
- en: Events triggered inside an aggregate method must not interfere with the ongoing
    method processing because these might undermine the contract between the aggregate
    and the command handlers that manipulate it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在聚合方法内部触发的事件不应干扰正在进行的方法处理，因为这些可能会破坏聚合与操作它的命令处理器之间的契约。
- en: Accordingly, each aggregate stores all events inside of it in an events list,
    and then the command handler decides when to execute these handlers. Typically,
    all events of all aggregates processed by a command handler are executed just
    before the handler saves all changes by calling `unitOfWork.SaveEntitiesAsync()`.
    However, this is not a general rule.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个聚合将所有事件存储在其内部的事件列表中，然后命令处理器决定何时执行这些处理器。通常，命令处理器处理的所有聚合的事件都在处理器通过调用`unitOfWork.SaveEntitiesAsync()`保存所有更改之前执行。然而，这并不是一个普遍的规则。
- en: Events are handled in a similar way to commands, the only difference being that
    each command has just one associated handler, while each event may have several
    subscriptions attached to it. Luckily, this difficulty can be easily handled with
    some advanced features of the .NET dependency injection engine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的处理方式与命令类似，唯一的区别是每个命令只有一个关联的处理程序，而每个事件可能有多个订阅附加到它。幸运的是，这种困难可以通过.NET依赖注入引擎的一些高级功能轻松解决。
- en: 'More specifically, events are classes marked with the empty `IEventNotification`
    interface, while event handlers are an implementation of the following interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，事件是带有空`IEventNotification`接口的类，而事件处理器是实现以下接口的：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All data structures involved are completely analogous to the ones needed to
    handle commands. However, now we must add some enhancements to associate each
    event with all its handlers. The following generic class does the trick:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的数据结构都与处理命令所需的数据结构完全类似。然而，现在我们必须添加一些增强功能，以将每个事件与其所有处理器关联起来。以下泛型类就做到了这一点：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `IEventNotification` is an empty interface used just to mark a class as
    representing an event.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`IEventNotification`是一个空接口，仅用于标记一个类表示事件。
- en: 'If we add the preceding generic class to the dependency injection engine with
    `service.AddScoped(typeof(EventTrigge<>))`, then whenever we require a specific
    instance of this class (say, for the `MyEvent` event generic argument), the dependency
    injection engine will automatically retrieve all `IEventHandler<MyEvent>` implementations
    and will pass it in the constructor of the `EventTrigger<MyEvent>` instance being
    returned. After that, we may launch all subscribed handlers with something like
    the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`service.AddScoped(typeof(EventTrigger<>))`将前面的泛型类添加到依赖注入引擎中，那么每次我们需要这个类的特定实例（比如，对于`MyEvent`事件泛型参数）时，依赖注入引擎将自动检索所有`IEventHandler<MyEvent>`实现，并将它们传递给返回的`EventTrigger<MyEvent>`实例的构造函数。之后，我们可以使用类似以下的方式启动所有已订阅的处理程序：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is worth pointing out that the `IEventNotification` interface must be defined
    in the domain layer since it must use aggregates, while all other interfaces and
    classes connected to events are defined in the application services DLL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`IEventNotification`接口必须在领域层中定义，因为它必须使用聚合，而所有其他与事件相关的接口和类都定义在应用程序服务DLL中。
- en: As an example of an event, let’s consider a purchase order aggregate of an e-commerce
    application. When the purchase order is finalized by calling its `Finalize` method,
    if the purchase is greater than a given threshold, then an event must be created
    for adding some scores to the user profiles that the user can spend to get discounts
    on further purchases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事件的一个例子，让我们考虑一个电子商务应用程序的采购订单聚合。当通过调用其`Finalize`方法最终确定采购订单时，如果采购金额超过一个给定的阈值，那么必须创建一个事件来为用户添加一些分数到用户资料中，用户可以用这些分数在后续采购中获得折扣。
- en: 'The following figure exemplifies what happens:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了发生的情况：
- en: '![Figure 3.3: Domain event example](img/B31916_03_3.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：领域事件示例](img/B31916_03_3.png)'
- en: 'Figure 3.3: Domain event example'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：领域事件示例
- en: As in the case of command handlers, all event handlers defined in the application
    services DLL can be automatically discovered and added to the dependency injection
    engine through reflection. We will show how to do it in the next section, which
    will propose a general .NET solution template for the Onion Architecture.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像命令处理器的情况一样，在应用程序服务DLL中定义的所有事件处理器都可以通过反射自动发现并添加到依赖注入引擎中。我们将在下一节中展示如何实现，该节将提出一个用于洋葱架构的通用.NET解决方案模板。
- en: A solution template based on the Onion Architecture
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于洋葱架构的解决方案模板
- en: In this section, we describe a solution template based on the Onion Architecture
    that we will use throughout the remainder of the book, which you can find in the
    `ch03` folder of the book’s GitHub repository ([https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)).
    This template shows how to put into practice what you have learned about the Onion
    Architecture.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了一个基于洋葱架构的解决方案模板，我们将在本书的其余部分使用该模板，您可以在书的 GitHub 仓库的 `ch03` 文件夹中找到它（[https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)）。此模板展示了如何将您所学的洋葱架构知识付诸实践。
- en: 'The solution contains two .NET library projects, called `ApplicationServices`
    and `DomainLayer`, which implement, respectively, the application services and
    domain layers of an Onion Architecture:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案包含两个 .NET 库项目，分别称为 `ApplicationServices` 和 `DomainLayer`，它们分别实现了洋葱架构的应用服务和领域层：
- en: '![Figure 3.4: Solution template based on the Onion Architecture](img/B31916_03_4.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：基于洋葱架构的解决方案模板](img/B31916_03_4.png)'
- en: 'Figure 3.4: Solution template based on the Onion Architecture'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：基于洋葱架构的解决方案模板
- en: As prescribed by the Onion Architecture, the `ApplicationServices` project has
    a reference to the `DomainLayer` architecture project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据洋葱架构的规定，`ApplicationServices` 项目引用了 `DomainLayer` 架构项目。
- en: 'In `ApplicationServices`, we added the following folders:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ApplicationServices` 中，我们添加了以下文件夹：
- en: '`Queries` to place all queries and query interfaces'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Queries` 用于放置所有查询和查询接口'
- en: '`Commands` to place all command classes'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Commands` 用于放置所有命令类'
- en: '`CommandHandlers` to place all command handlers'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommandHandlers` 用于放置所有命令处理程序'
- en: '`EventHandlers` to place all event handlers'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventHandlers` 用于放置所有事件处理程序'
- en: '`Tools`, which contains all Onion Architecture-related interfaces used by the
    application services we described in the previous section'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tools` 包含了我们在上一节描述的应用服务所使用的所有洋葱架构相关的接口'
- en: '`Extensions`, which contains the `HandlersDIExtensions.AddApplicationServices()`
    extension method that adds all queries, event handlers, and command handlers defined
    in the project to the dependency injection engine'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extensions` 包含了 `HandlersDIExtensions.AddApplicationServices()` 扩展方法，该方法将项目中定义的所有查询、事件处理程序和命令处理程序添加到依赖注入引擎中'
- en: All the preceding folders can be organized into subfolders to increase the code
    readability.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述文件夹都可以组织成子文件夹，以增加代码的可读性。
- en: 'In the `DomainLayer` project, we added the following folders:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DomainLayer` 项目中，我们添加了以下文件夹：
- en: '`Models` to place all aggregates and value objects'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Models` 用于放置所有聚合和值对象'
- en: '`Events` to place all events that may be raised by the aggregates'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Events` 用于放置所有可能由聚合引发的事件'
- en: '`Tools`, which contains all Onion Architecture-related interfaces used by the
    domain we described in the previous section, and some further utility classes'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tools` 包含了我们在上一节描述的领域所使用的所有洋葱架构相关的接口，以及一些额外的实用类'
- en: 'The `Extensions` folder of the `ApplicationServices` project contains just
    one file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationServices` 项目的 `Extensions` 文件夹中只包含一个文件：'
- en: '![Figure 3.5: ApplicationServices extensions](img/B31916_03_5.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：ApplicationServices 扩展](img/B31916_03_5.png)'
- en: 'Figure 3.5: ApplicationServices extensions'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：ApplicationServices 扩展
- en: 'The `HandlersDIExtensions` static class contains two overloads of an extension
    method, which adds all queries, command handlers, event handlers, and the `EventMediator`
    class to the dependency injection engine:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlersDIExtensions` 静态类包含一个扩展方法的两个重载，该扩展方法将所有查询、命令处理程序、事件处理程序和 `EventMediator`
    类添加到依赖注入引擎中：'
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It uses three different private methods that scan the assembly with reflection,
    looking respectively for queries, command handlers, and event handlers. The full
    code is available in the `ch03` folder of the GitHub repository associated with
    the book. Here, we analyze just `AddAllCommandHandlers` to show the basic ideas
    exploited by all three methods:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用三个不同的私有方法通过反射扫描程序集，分别查找查询、命令处理程序和事件处理程序。完整的代码可以在与本书相关的 GitHub 仓库的 `ch03`
    文件夹中找到。在这里，我们仅分析 `AddAllCommandHandlers` 以展示所有三种方法所利用的基本思想：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First of all, we collect all nonabstract classes that implement the `ICommandHandler`
    empty interface. This interface was specifically added to all command handlers
    to retrieve all of them with reflection. Then, for each of them, we retrieve the
    `ICommandHandler<T>` that it implements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们收集所有实现 `ICommandHandler` 空接口的非抽象类。这个接口被特别添加到所有命令处理器中，以便通过反射检索所有这些处理器。然后，对于每个处理器，我们检索它实现的
    `ICommandHandler<T>`：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, if we find such an interface, we add the pair to the dependency injection
    engine:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们找到这样的接口，我们将该对添加到依赖注入引擎中：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Tools` folder of the `ApplicationServices` project contains the files
    shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationServices` 项目的 `Tools` 文件夹包含以下文件：'
- en: '![Figure 3.6: ApplicationServices tools](img/B31916_03_6.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：ApplicationServices 工具](img/B31916_03_6.png)'
- en: 'Figure 3.6: ApplicationServices tools'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：ApplicationServices 工具
- en: 'We already analyzed all interfaces and classes contained in the preceding `Tools`
    folder, except `EventMediator` in the previous section. Let’s recall them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了前面 `Tools` 文件夹中包含的所有接口和类，除了上一节中的 `EventMediator`。让我们回顾一下它们：
- en: '`IQuery` and `ICommand` are empty interfaces that mark, respectively, queries
    and commands'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IQuery` 和 `ICommand` 是空接口，分别标记查询和命令'
- en: '`ICommandHandler<T>` and `IEventHandler<T>` are the interfaces that must be
    implemented, respectively, by command handlers and event handlers'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICommandHandler<T>` 和 `IEventHandler<T>` 是必须分别由命令处理器和事件处理器实现的接口'
- en: '`EventTrigger<T>` is the class that does the magic of collecting all event
    handlers associated with the same event, `T`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventTrigger<T>` 是一个收集与同一事件 `T` 相关的所有事件处理器的类'
- en: '`EventMediator` is a utility class that solves a practical problem. A command
    handler that needs to trigger all event handlers associated with an event, `T`,
    must inject `EventTrigger<T>` in its constructor. However, the point is that a
    command discovers that it needs to trigger the `T` event just when it finds the
    `T` event in the event lists of an aggregate, so it should inject all possible
    `EventTrigger<T>` in its constructor.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventMediator` 是一个实用类，用于解决实际问题。需要触发与事件 `T` 相关的所有事件处理器的命令处理器必须在构造函数中注入 `EventTrigger<T>`。然而，关键点是命令发现它需要触发
    `T` 事件，正是在它找到聚合体的事件列表中的 `T` 事件时，因此它应该在构造函数中注入所有可能的 `EventTrigger<T>`。'
- en: To overcome this problem, the `EventMediator` class uses `IServiceProvide`r
    to require the event handlers associated with a list of events it is passed in
    its `TriggerEvents(IEnumerable<IEventNotification> events)` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，`EventMediator` 类使用 `IServiceProvider` 在其 `TriggerEvents(IEnumerable<IEventNotification>
    events)` 方法中要求传递给它的与事件列表相关的事件处理器。
- en: 'Accordingly, it is enough to inject `EventMediator` in the constructor of each
    command handler so that whenever it finds a nonempty event list, `L`, in an aggregate,
    it can simply call the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只需在每个命令处理器的构造函数中注入 `EventMediator`，这样每当它在一个聚合体中找到一个非空的事件列表 `L` 时，它就可以简单地调用以下操作：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once `EventMediator` receives the preceding call, it scans the event list to
    discover all the events contained in it, then for each of them, it requires the
    corresponding `EventTrigger<T>` to get all associated event handlers, and finally,
    it executes all retrieved handlers, passing them the corresponding events.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `EventMediator` 收到前面的调用，它将扫描事件列表以发现其中包含的所有事件，然后对于每个事件，它要求相应的 `EventTrigger<T>`
    获取所有相关的事件处理器，最后，它执行所有检索到的处理器，并将相应的事件传递给它们。
- en: 'To perform its job, the `EventMediator` class requires `IServiceProvider` in
    its constructor:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行其工作，`EventMediator` 类在其构造函数中需要 `IServiceProvider`：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, it uses this service provider to require each needed `EventTrigger<T>`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它使用这个服务提供者来要求每个需要的 `EventTrigger<T>`：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, it invokes the `EventTrigger<T>.Trigger` methods with reflection:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它通过反射调用 `EventTrigger<T>.Trigger` 方法：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is the full code of the `EventMediator` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `EventMediator` 类的完整代码：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Tools` folder of the `DomainLayer` project contains the following files:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`DomainLayer` 项目的 `Tools` 文件夹包含以下文件：'
- en: '![Figure 3.7: DomainLayer tools](img/B31916_03_7.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：DomainLayer 工具](img/B31916_03_7.png)'
- en: 'Figure 3.7: DomainLayer tools'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：DomainLayer 工具
- en: '`IEventNotification` and `IRepository` are empty interfaces that mark, respectively,
    events and repository interfaces. We already discussed them in the previous section.
    We also already discussed `IUnitOfWork`, which is the interface needed by command
    handlers to persist changes and handle transactions.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEventNotification` 和 `IRepository` 是空接口，分别标记事件和存储库接口。我们已经在上一节中讨论了它们。我们也已经讨论了
    `IUnitOfWork`，这是命令处理器需要用来持久化更改和处理事务的接口。'
- en: '`Entity<T>` is a class that all aggregates must inherit from:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entity<T>` 是所有聚合必须继承的类：'
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding class contains two minimized code regions. The `K` generic parameter
    is the type of the aggregate’s `Id` principal key.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个类包含两个最小化代码区域。泛型参数 `K` 是聚合的 `Id` 主键的类型。
- en: The `IsTransient()` method returns `true` if the aggregate has not been assigned
    a principal key yet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsTransient()` 方法返回 `true` 如果聚合尚未分配主键。'
- en: '`Override Equal region` contains the code that overrides the `Equal` method
    and defines equality and inequality operators. The redefined `Equal` method considers
    equal two instances if and only if they have the same principal key.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Override Equal region` 包含覆盖 `Equal` 方法并定义相等和不等运算符的代码。重新定义的 `Equal` 方法认为两个实例相等当且仅当它们具有相同的主键。'
- en: '`Domain events handling region` handles the list of events triggered during
    all calls to the aggregate methods. The exploded code is shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Domain events handling region` 处理在调用聚合方法期间触发的事件列表。展开的代码如下所示：'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We don’t need an abstract class for value objects because, as discussed in the
    previous section, the .NET `record` type perfectly represents all value type features.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为值对象提供一个抽象类，因为，如前所述，.NET 的 `record` 类型完美地代表了所有值类型特性。
- en: Before discussing in more detail how to connect the two library projects of
    the template with the actual storage drivers and with an actual UI, we need to
    understand how to handle the mismatch between aggregates and record-like ORM classes.
    We will do this in the dedicated subsection that follows.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地讨论如何将模板的两个库项目与实际的存储驱动程序和实际的 UI 连接之前，我们需要了解如何处理聚合和类似记录的 ORM 类之间的不匹配。我们将在下面的专用子节中这样做。
- en: Matching aggregates and ORM entities
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配聚合和 ORM 实体
- en: There are several techniques to match ORM entities and aggregates. The simplest
    one consists of implementing the aggregates with the ORM entities themselves.
    The main difficulty with this approach is that aggregates do not expose the properties
    that must match the database fields as public properties. However, since they
    usually expose them as private fields, we may try to use these private fields
    for the database field mapping if the chosen ORM supports mapping with private
    properties.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以将 ORM 实体和聚合匹配起来。最简单的一种是使用 ORM 实体本身实现聚合。这种方法的主要困难是聚合不公开必须与数据库字段匹配的属性作为公共属性。然而，由于它们通常将它们作为私有字段公开，如果选择的
    ORM 支持使用私有属性进行映射，我们可以尝试使用这些私有字段进行数据库字段映射。
- en: Entity Framework Core supports the mapping with private fields, but if we are
    looking for complete independence from the database driver, we can’t rely on this
    peculiarity of Entity Framework Core. Moreover, this approach forces us to define
    the ORM entities in the domain layer since they are also aggregates. This means
    that we can’t decorate the class member with ORM-specific attributes and that
    we need to worry about how the class will be used by the ORM while defining each
    aggregate, thus undermining independence from a specific storage driver.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core 支持使用私有字段进行映射，但如果我们正在寻找完全独立于数据库驱动程序，我们不能依赖于 Entity Framework
    Core 的这一特性。此外，这种方法迫使我们定义 ORM 实体在域层中，因为它们也是聚合。这意味着我们不能在定义每个聚合时用 ORM 特定的属性装饰类成员，并且我们需要担心
    ORM 如何使用该类，从而破坏了对特定存储驱动程序的独立性。
- en: 'A better approach is the **state object** approach:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是 **状态对象** 方法：
- en: We associate each aggregate with an interface that stores the state of the aggregate
    in its properties. This way, instead of using private backing fields, the aggregate
    uses the properties of this interface.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个聚合与一个接口关联，该接口将其状态存储在其属性中。这样，而不是使用私有支持字段，聚合使用该接口的属性。
- en: The state interface is passed in the constructor of the aggregate and then stored
    in a private `readonly` property.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态接口传递给聚合的构造函数，然后存储在一个私有的 `readonly` 属性中。
- en: The ORM entity associated with the aggregate implements this interface. This
    way, the database driver adapts to the aggregates and not vice versa, thus achieving
    the required independence of the Domain layer from the database driver.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与聚合关联的 ORM 实体实现了此接口。这样，数据库驱动器适应聚合，而不是反过来，从而实现了领域层对数据库驱动器的所需独立性。
- en: When the domain layer requires either a new fresh aggregate or an aggregate
    already stored in the database through a repository interface method, the database
    implementation of the repository method creates or retrieves the corresponding
    ORM entity and then creates a new aggregate, passing this ORM entity in its constructor
    as a state object.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当领域层需要通过存储库接口方法获取一个新的聚合或已存储在数据库中的聚合时，存储库方法的数据库实现创建或检索相应的 ORM 实体，然后创建一个新的聚合，将其作为状态对象传递给其构造函数。
- en: When the aggregates are modified, all their modifications are reflected on their
    state objects, which, being ORM entities, are tracked by the ORM. Therefore, when
    we instruct the ORM to save all changes, all aggregates’ changes are automatically
    passed to the underlying database because these changes are stored in tracked
    objects.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当聚合被修改时，所有修改都会反映在其状态对象上，这些对象作为 ORM 实体被 ORM 跟踪。因此，当我们指示 ORM 保存所有更改时，所有聚合的更改会自动传递到底层数据库，因为这些更改存储在跟踪对象中。
- en: 'The following figure shows the preceding flow:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面的流程：
- en: '![Figure 3.8: Aggregates lifecycle](img/B31916_03_8.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：聚合生命周期](img/B31916_03_8.png)'
- en: 'Figure 3.8: Aggregates lifecycle'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：聚合生命周期
- en: 'Let’s try to modify our previous `PurchaseOrder` aggregate by using the following
    state interface:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用以下状态接口修改我们之前的 `PurchaseOrder` 聚合：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modifications are straightforward and do not increase the complexity of the
    code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 修改很简单，不会增加代码的复杂性：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we are ready to understand how to connect the two projects of our template
    with an actual database driver and an actual UI.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好了解如何将模板中的两个项目与实际的数据库驱动器和实际的 UI 连接起来。
- en: A complete solution based on the Onion Architecture
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于洋葱架构的完整解决方案
- en: The *ch03* folder of the book’s GitHub repository ([https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp))
    contains a complete solution, which, together with the application services and
    domain layer libraries, also features a database driver based on Entity Framework
    Core and a presentation layer based on an ASP.NET Core Web API project.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍 GitHub 仓库的 *ch03* 文件夹（[https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp](https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp)）包含一个完整的解决方案，该解决方案与应用程序服务和领域层库一起，还包含基于
    Entity Framework Core 的数据库驱动器和基于 ASP.NET Core Web API 项目的表示层。
- en: The purpose of this project is to show how to use the general Onion Architecture
    template described in this section in an actual solution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的目的是展示如何在实际解决方案中使用本节中描述的通用洋葱架构模板。
- en: 'The following figure shows the complete solution:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了完整的解决方案：
- en: '![Figure 3.9: A complete solution based on the Onion Architecture](img/B31916_03_9.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：基于洋葱架构的完整解决方案](img/B31916_03_9.png)'
- en: 'Figure 3.9: A complete solution based on the Onion Architecture'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：基于洋葱架构的完整解决方案
- en: 'The `DBDrive`r project is a .NET library project where we added a dependency
    on the following Nuget packages:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBDrive`r 项目是一个 .NET 库项目，我们在其中添加了对以下 Nuget 包的依赖：'
- en: '`Microsoft.EntityFrameworkCore.SqlServer`: This package loads both Entity Framework
    Core and its SQL Server provider'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.SqlServer`：此包加载了 Entity Framework Core 和其 SQL
    Server 提供程序'
- en: '`Microsoft.EntityFrameworkCore.Tools`: This package provides all tools for
    scaffolding and handling database migrations'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Microsoft.EntityFrameworkCore.Tools`：此包提供了所有用于生成和处理数据库迁移的工具'
- en: Since the `DBDriver` project must provide a storage driver, it also has a dependency
    on the domain library project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `DBDriver` 项目必须提供存储驱动器，它也依赖于领域库项目。
- en: The `WebApi` project is an ASP.NET Core Web API project. It works as the outermost
    layer of the Onion Architecture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebApi` 项目是一个 ASP.NET Core Web API 项目。它作为洋葱架构的最外层。'
- en: The outermost layer of the Onion Architecture (in our example, `WebApi`) must
    have a dependency on the application services directory and all drivers’ projects
    (in our example, just `DBDrive`r).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 洋葱架构的最外层（在我们的例子中，`WebApi`）必须依赖于应用程序服务目录和所有驱动器项目（在我们的例子中，仅为 `DBDrive`r）。
- en: 'We added some folders and classes to the `DBDriver` project that should be
    used in all drivers based on Entity Framework Core. The following figure shows
    the project structure:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `DBDriver` 项目添加了一些文件夹和类，这些文件夹和类应该用于所有基于 Entity Framework Core 的驱动程序。以下图显示了项目结构：
- en: '![Figure 3.10: DBDriver project structure](img/B31916_03_10.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10：DBDriver 项目结构](img/B31916_03_10.png)'
- en: 'Figure 3.10: DBDriver project structure'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：DBDriver 项目结构
- en: 'Here is the description of all the folders:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有文件夹的描述：
- en: '`Entities`: Put all your Entity Framework Core entities here, possibly organized
    in subfolders.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entities`：将所有你的 Entity Framework Core 实体放在这里，可能组织在子文件夹中。'
- en: '`Repositories`: Put all repository implementations here, possibly organized
    in subfolders.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repositories`：将所有仓库实现放在这里，可能组织在子文件夹中。'
- en: '`MainDbContext`: This is the skeleton of the project Entity Framework DB context,
    which also contains the implementation of the `IUnitOfWork` interface.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainDbContext`：这是项目实体框架数据库上下文的骨架，同时也包含了 `IUnitOfWork` 接口的实现。'
- en: '`Extensions`: This folder contains two extension classes. `RepositoryExtensions`
    just provides the `AddAllRepositories` extension method, which discovers all repository
    implementations and adds them to the dependency injection engine. Its code is
    similar to one of the `AddAllCommandHandlers` extension methods that we described
    in the previous subsection, so we will not describe it here. `DBExtension` contains
    just the `AddDbDriver` extension method, which adds all implementations provided
    by `DBDriver` to the dependency injection engine.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extensions`：这个文件夹包含两个扩展类。`RepositoryExtensions` 只提供 `AddAllRepositories` 扩展方法，该方法发现所有仓库实现并将它们添加到依赖注入引擎中。它的代码类似于我们在前一小节中描述的
    `AddAllCommandHandlers` 扩展方法之一，所以我们在这里不会描述它。`DBExtension` 只包含 `AddDbDriver` 扩展方法，该方法将
    `DBDriver` 提供的所有实现添加到依赖注入引擎中。'
- en: 'The implementation of the `AddDbDriver` extension method is straightforward:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDbDriver` 扩展方法的实现很简单：'
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It accepts the database connection string as its only input and adds the `MainDbContext`
    Entity Framework context as implementation for the `IUnitOfWork` interface with
    the usual `AddDbContext` Entity Framework Core extension method. Then, it calls
    the `AddAllRepositories` method to add all repository implementations provided
    by `DBDriver`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受数据库连接字符串作为其唯一输入，并使用常规的 `AddDbContext` Entity Framework Core 扩展方法将 `MainDbContext`
    实体框架上下文作为 `IUnitOfWork` 接口的实现。然后，它调用 `AddAllRepositories` 方法来添加 `DBDriver` 提供的所有仓库实现。
- en: 'Here is the `MainDbContext` class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `MainDbContext` 类：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The class is defined as internal since it must not be visible outside of the
    database driver. All entity configurations must be placed inside the `OnModelCreating`
    method as usual.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该类被定义为内部定义，因为它必须在数据库驱动程序外部不可见。所有实体配置都必须像往常一样放在 `OnModelCreating` 方法内部。
- en: 'The implementation of `IUnitOfWork` is minimized. The exploded code is shown
    here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUnitOfWork` 的实现被最小化了。展开的代码如下所示：'
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `IUnitOfWork` implementation is straightforward since it consists of a one-to-one
    coupling with `DBContext` methods.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUnitOfWork` 的实现很简单，因为它与 `DBContext` 方法具有一对一的耦合。'
- en: Since we expose just `IUnitOfWork` in the dependency injection engine, all repositories
    that need `MainDbContext` for their job must require `IUnitOfWork` in their constructors,
    and then they must cast it to `MainDbContext`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在依赖注入引擎中仅公开 `IUnitOfWork`，因此所有需要 `MainDbContext` 来完成其工作的仓库必须在它们的构造函数中要求
    `IUnitOfWork`，然后它们必须将其转换为 `MainDbContext`。
- en: Having discussed what we need to know about `DBDriver`, let’s move to the Web
    API project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了关于 `DBDriver` 我们需要了解的内容之后，让我们转向 Web API 项目。
- en: Connecting the outermost project of an Onion Architecture is easy. We just need
    to call the extension method exposed by the application services, which injects
    all application services implementations in the dependency injection engine, and
    we need to call the extension methods of all drivers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到洋葱架构的最外层项目很容易。我们只需要调用应用程序服务公开的扩展方法，该方法将所有应用程序服务实现注入到依赖注入引擎中，并且我们需要调用所有驱动程序的扩展方法。
- en: 'In our case, we need to add just two calls to `Program.cs`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只需要在 `Program.cs` 中添加两个调用：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At this point, in the case of the ASP.NET Core project, all that remains is
    to acquire the command handlers for the commands that we need in the constructors
    of our controllers. After that, each action method must just use the input that
    it received to build adequate commands, and then it must invoke the handler associated
    with each command.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，对于ASP.NET Core项目来说，剩下的只是获取我们控制器构造函数中需要的命令处理器。之后，每个操作方法只需使用它接收到的输入来构建适当的命令，然后必须调用与每个命令关联的处理程序。
- en: The short description of how to handle the outermost layer of an Onion Architecture
    completes our short introduction to this architecture, but we will find examples
    throughout the remainder of the book since we will use them for most of our code
    examples.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对洋葱架构最外层的处理方法的简要描述完成了我们对这种架构的简要介绍，但我们将在整个书籍的其余部分找到示例，因为我们将在大多数代码示例中使用它们。
- en: 'Let’s move on to another important building block of microservices architecture:
    containers!'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨微服务架构的另一个重要构建块：容器！
- en: Containers and Docker
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和Docker
- en: We’ve already discussed the advantages of having microservices that don’t depend
    on the environment where they run; microservices can be moved from busy nodes
    to idle nodes without constraints, thus achieving a better load balance and, consequently,
    better usage of the available hardware.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了拥有不依赖于运行环境的微服务的优势；微服务可以在没有限制的情况下从繁忙的节点移动到空闲节点，从而实现更好的负载均衡，并因此更好地利用可用硬件。
- en: However, if we need to mix legacy software with newer modules or if we would
    like to use the best stack for each module, with the ability to mix several development
    stack implementations, we are faced with the problem that each different stack
    has different hardware/software prerequisites. In these cases, the independence
    of each microservice from the hosting environment can be restored by deploying
    each microservice, together with all its dependencies, on a private virtual machine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们需要将遗留软件与较新的模块混合使用，或者如果我们希望为每个模块使用最佳的堆栈，并且能够混合几种开发堆栈实现，我们将面临每个不同的堆栈都有不同的硬件/软件先决条件的问题。在这些情况下，可以通过在每个微服务上部署每个微服务及其所有依赖项来恢复每个微服务与托管环境的独立性。
- en: 'However, starting a virtual machine with its private copy of the operating
    system takes a lot of time, and microservices must be started and stopped quickly
    to reduce load-balancing and fault recovery costs. Luckily, microservices can
    rely on a lighter form of virtualization technology: containers. Containers provide
    a lightweight and efficient form of virtualization. Unlike traditional virtual
    machines that virtualize an entire machine, including the operating system, containers
    virtualize at the operating system’s filesystem level, sitting on top of the host
    operating system kernel. They use the operating system of the host machine (kernel,
    DLLs, and drivers) and use the operating system’s native features to isolate processes
    and resources, creating an isolated environment for the images they run.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，启动带有其操作系统私有副本的虚拟机需要花费很多时间，而微服务必须快速启动和停止以减少负载均衡和故障恢复成本。幸运的是，微服务可以依赖一种更轻量级的虚拟化技术：容器。容器提供了一种轻量级且高效的虚拟化形式。与传统虚拟机不同，虚拟机虚拟化整个机器，包括操作系统，容器在操作系统的文件系统级别进行虚拟化，位于宿主操作系统内核之上。它们使用宿主机的操作系统（内核、DLL和驱动程序），并使用操作系统的本地功能来隔离进程和资源，为它们运行的镜像创建一个隔离的环境。
- en: 'The following figure shows how containers work:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了容器的工作原理：
- en: '![Figure 3.11: Container basic principles](img/B31916_03_11.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：容器基本原理](img/B31916_03_11.png)'
- en: 'Figure 3.11: Container basic principles'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：容器基本原理
- en: Containers are run by the containers’ runtime from **images** that encode their
    content. The same image can create several identical containers. Images are stored
    in **image registries** that identify them through both an image name and an image
    version. In turn, images are created by commands in a text file that specify both
    the container’s content and properties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 容器由容器运行时从**镜像**中运行，这些镜像编码了它们的内容。相同的镜像可以创建多个相同的容器。镜像存储在**镜像仓库**中，通过镜像名称和版本来识别它们。反过来，镜像是通过文本文件中的命令创建的，这些命令指定了容器的内容和属性。
- en: 'More specifically, names are URLs whose domain part is the registry domain,
    and the path part is composed of a namespace that includes related images and
    a repository name. The version is attached to this URL with a colon and is called
    `tag` since it can be any string. Summing up, the name and version are encoded
    as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，名称是 URL，其域名部分是注册表域，路径部分由一个包含相关图像的命名空间和存储库名组成。版本附加到该 URL 上，并用冒号分隔，称为 `tag`，因为它可以是任何字符串。总结来说，名称和版本编码如下所示：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Thus, for instance, the ASP.NET CORE 9.0 runtime Docker image’s full URL is
    as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，ASP.NET CORE 9.0 运行时 Docker 镜像的完整 URL 如下所示：
- en: '[PRE34]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `mcr.microsoft.com` is the registry domain, `dotnet` is the namespace,
    `asp.net` is the repository name, and `9.0` is the tag.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mcr.microsoft.com` 是注册表域，`dotnet` 是命名空间，`asp.net` 是存储库名，`9.0` 是标签。
- en: 'Any runtime that needs to create containers downloads its image from a registry,
    possibly providing credentials, and then uses the downloaded images to create
    the containers. The following figure shows the whole process of container creation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 任何需要创建容器的运行时都会从注册表中下载其图像，可能提供凭证，然后使用下载的图像来创建容器。以下图显示了容器创建的整个过程：
- en: '![Figure 3.12: Containers/images lifecycle](img/B31916_03_12.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12：容器/镜像生命周期](img/B31916_03_12.png)'
- en: 'Figure 3.12: Containers/images lifecycle'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：容器/镜像生命周期
- en: In the remainder of the book, we will use Docker containers as a de facto standard.
    Each Docker image is generated by specifying changes to apply to another preexisting
    image with the **Docker containers description language**. The instructions for
    creating a Docker image are contained in a file that must be named **Dockerfile**
    (without any file extension).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的剩余部分，我们将使用 Docker 容器作为事实上的标准。每个 Docker 镜像都是通过指定对另一个现有图像的更改来生成的，这些更改使用 **Docker
    容器描述语言**。创建 Docker 镜像的指令包含在一个必须命名为 **Dockerfile**（不带任何文件扩展名）的文件中。
- en: 'Each **Dockerfile** usually starts with a `FROM` instruction that specifies
    the preexisting image to modify, as shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **Dockerfile** 通常以一个 `FROM` 指令开始，该指令指定要修改的现有图像，如下所示：
- en: '[PRE35]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The tag with the ASP.NET CORE version to use is specified after the image URL,
    preceded by a colon, as shown in the preceding code. Images taken from private
    repositories must be specified with their complete URL, which starts with the
    domain of the registry. Images without their complete URL are allowed only when
    they are hosted on the Docker free public registry, `hub.docker.com/r/`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像 URL 之后指定要使用的 ASP.NET CORE 版本的标签，前面有一个冒号，如前述代码所示。从私有仓库获取的图像必须指定其完整的 URL，该
    URL 以注册表的域开始。没有完整 URL 的图像只有在它们托管在 Docker 免费公共注册表 `hub.docker.com/r/` 上时才允许。
- en: 'The following figure shows the hierarchical organization of Docker images:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 Docker 镜像的层次组织结构：
- en: '![Figure 3.13: Hierarchy of images and containers](img/B31916_03_13.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13：图像和容器的层次结构](img/B31916_03_13.png)'
- en: 'Figure 3.13: Hierarchy of images and containers'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：图像和容器的层次结构
- en: 'The `FROM` statement specifies the environment you are in, called the **build
    stage**. After that, you can deal with the image as if it were a filesystem by
    copying files from your computer into it and by executing shell commands:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM` 语句指定了您所在的环境，称为 **构建阶段**。之后，您可以像处理文件系统一样处理图像，通过将文件从您的计算机复制到其中并执行 shell
    命令：'
- en: '![Figure 3.14: Building the image](img/B31916_03_14.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14：构建镜像](img/B31916_03_14.png)'
- en: 'Figure 3.14: Building the image'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：构建镜像
- en: In all copy operations, you can use relative paths on your computer. They are
    assumed to be relative to the directory that contains the `Dockerfile` file.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有复制操作中，您可以在计算机上使用相对路径。它们被认为是相对于包含 `Dockerfile` 文件的目录的相对路径。
- en: 'Here are the main `Dockerfile` commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了主要的 `Dockerfile` 命令：
- en: WORKDIR <path in the image file system>
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WORKDIR <镜像文件系统中的路径>
- en: This instruction defines the current directory in the image filesystem. If the
    directory doesn’t exist, it is created. After that, you can use relative paths
    also in the image filesystem.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此指令定义了图像文件系统中的当前目录。如果目录不存在，则创建它。之后，您也可以在图像文件系统中使用相对路径。
- en: COPY <path in your computer> <path in the image>
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COPY <计算机中的路径> <镜像中的路径>
- en: Copy one or more files into the image filesystem. If the source path denotes
    a folder, the whole folder is recursively copied; otherwise, a single file is
    copied. In any case, the directory or file copied takes the name specified in
    the image path.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将一个或多个文件复制到图像文件系统中。如果源路径表示一个文件夹，则整个文件夹将被递归复制；否则，将复制单个文件。在任何情况下，复制的目录或文件都采用图像路径中指定的名称。
- en: Copy <path1> <path2> … ./ (or [<path1>, <path2>, …, ./]
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制 <path1> <path2> … ./（或 [<path1>, <path2>, …, ./]
- en: The content specified by all source paths is copied into the image’s current
    directory. Source file names are not changed.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有源路径指定的内容都将复制到图像的当前目录。源文件名不会更改。
- en: Copy –-from=<image name or url>:<version> …
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制 –-from=<image name or url>:<version> …
- en: This works like the previous copy commands but files are taken from the image
    specified by the name/URL after `from=`. A name can be specified instead of a
    URL only if the image is contained in your computer or the Docker public repository.
    If no version is specified, `latest` is assumed as the default version name.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与之前的复制命令类似，但文件是从`from=`之后指定的名称/URL指定的图像中获取的。只有当图像包含在您的计算机或Docker公共仓库中时，才能指定名称而不是URL。如果没有指定版本，则默认假设为`latest`版本名称。
- en: RUN <command> <arg1> <arg2> ...
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RUN <command> <arg1> <arg2> ...
- en: This executes the specified shell command with the specified arguments in the
    current directory of the image.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在图像的当前目录中执行指定的shell命令及其参数。
- en: CMD [<command>, <arg1>, <arg2>, ...]
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMD [<command>, <arg1>, <arg2>, ...]
- en: '[PRE36]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This specifies what happens when the container is executed. More specifically,
    it declares both the command and arguments to run when the container is executed.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了容器执行时会发生什么。更具体地说，它声明了在容器执行时要运行的命令和参数。
- en: EXPOSE <port1> <port2>
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EXPOSE <port1> <port2>
- en: This declares all ports supported by the container. Network traffic should be
    redirected into the container only through the ports declared here, but traffic
    directed to other ports is not blocked.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这声明了容器支持的所有端口。网络流量应仅通过此处声明的端口重定向到容器，但不会阻止重定向到其他端口的流量。
- en: A Dockerfile can also build intermediary images as a step to define the final
    image. For instance, an image containing the whole .NET SDK can be created with
    the only purpose of compiling a .NET solution. Then, the final binaries will be
    copied with the `Copy –-from=…` instruction in the final image, which contains
    just the .NET runtime. We will analyze this possibility in more detail when discussing
    Visual Studio support for Docker.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile也可以作为定义最终图像的步骤来构建中间图像。例如，可以创建包含整个.NET SDK的图像，其唯一目的是编译.NET解决方案。然后，最终二进制文件将通过`Copy
    –-from=…`指令复制到最终图像中，该图像仅包含.NET运行时。当讨论Visual Studio对Docker的支持时，我们将更详细地分析这种可能性。
- en: Let’s move on to a very simple example to familiarize ourselves with both Dockerfile
    instructions and the shell commands that manipulate Docker images and containers.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续一个非常简单的例子，以便熟悉Dockerfile指令以及操作Docker图像和容器的shell命令。
- en: 'Docker Desktop: a simple example'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Desktop：一个简单示例
- en: In order to operate with Docker on a client computer, you need to install **Doker
    Desktop**. Please refer to the instructions in the *Technical requirements* section
    for its installation. As described in the *Technical requirements* section, all
    examples suppose a Windows machine with WSL installed and Docker Desktop configured
    for Linux containers.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端计算机上使用Docker，您需要安装**Doker Desktop**。请参阅*技术要求*部分中的安装说明。正如*技术要求*部分所述，所有示例都假设有一个安装了WSL并配置了Linux容器的Windows机器。
- en: 'Once you have installed Docker Desktop, you will have the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker Desktop后，您将拥有以下内容：
- en: The Docker runtime, so you can instantiate containers from images, and run them
    on your computer.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker运行时，您可以从图像实例化容器，并在您的计算机上运行它们。
- en: A Docker client, so you can compile Dockerfiles into images, and execute other
    Docker-related shell commands.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端，您可以使用它将Dockerfile编译成图像，并执行其他与Docker相关的shell命令。
- en: A Docker local registry. All images compiled on your computer will be placed
    here. From here, you can move them to other registries. Moreover, before creating
    containers on your machine, you need to download their images here.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker本地仓库。您在计算机上编译的所有图像都将放置在这里。从这里，您可以将其移动到其他仓库。此外，在您的机器上创建容器之前，您需要在这里下载它们的图像。
- en: In order to show the power of Docker, we will start with a simple Java example.
    You will see that you don’t need either the Java runtime or Java SDK to compile
    and run a simple Java program because everything needed is downloaded into the
    image being built.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Docker 的强大功能，我们将从一个简单的 Java 示例开始。你会看到，你不需要 Java 运行时或 Java SDK 来编译和运行一个简单的
    Java 程序，因为所有需要的都下载到了正在构建的镜像中。
- en: Let’s start by creating a folder in which to place all the files needed to build
    the image. Let’s call it `SimpleExample`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个文件夹来放置构建镜像所需的所有文件。让我们称它为 `SimpleExample`。
- en: 'In this folder, place a `Hello.java` file containing the following simple code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件夹中，放置一个包含以下简单代码的 `Hello.java` 文件：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, in the same folder, we need just a Dockerfile with the following content:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个文件夹中，我们只需要一个包含以下内容的 Dockerfile：
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`eclipse-temurin` is a Java SDK. This will enable us both to compile and execute
    Java code in our image and our containers. Then, the code copies everything in
    our folder into the newly created `/var/www/java` path in the image being built.
    Please remember that relative paths on the source are evaluated with respect to
    the position of the Dockerfile.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`eclipse-temurin` 是一个 Java SDK。这将使我们能够在我们的镜像和容器中编译和执行 Java 代码。然后，代码将我们的文件夹中的所有内容复制到正在构建的镜像中的新创建的
    `/var/www/java` 路径。请记住，源中的相对路径是根据 Dockerfile 的位置评估的。'
- en: Finally, we move to the `var/www/java` folder and run the Java compiler, which
    will create a `.jar` file in the same folder. The `CMD` instruction specifies
    invoking the Java command on the previously created `.jar` file when a container
    based on this image will be executed.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们移动到 `var/www/java` 文件夹并运行 Java 编译器，它将在同一文件夹中创建一个 `.jar` 文件。`CMD` 指令指定在基于此镜像的容器执行时调用之前创建的
    `.jar` 文件中的 Java 命令。
- en: Now, we need a Linux shell opened in our `SimpleExample` folder to execute Docker
    commands. Right-click on the image of the `SimpleExample` folder by simultaneously
    pressing the *shift* key, and choose the option to open a Linux shell from the
    menu that appears.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `SimpleExample` 文件夹中打开一个 Linux shell 来执行 Docker 命令。同时按住 *shift* 键，右键单击
    `SimpleExample` 文件夹的图标，并从出现的菜单中选择打开 Linux shell 的选项。
- en: 'As a first step, we need to *build* our `Dockerfile` instructions to create
    an image. This is done with the `build` command, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要 *构建* 我们的 `Dockerfile` 指令来创建一个镜像。这通过 `build` 命令完成，如下所示：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first argument specifies the location of the Dockerfile, while the `-t`
    option specifies a tag (an image URL) to attach to the image, in our case, `simpleexample`.
    Since the image will be placed in our local Docker Desktop registry, it is enough
    to specify the repository part of the URL, but if you have several local images,
    you can also add a namespace to better classify your images. Usually, at this
    stage, no version tag is added, and Docker assumes the `latest` default tag.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定 Dockerfile 的位置，而 `-t` 选项指定要附加到镜像的标签（镜像 URL），在我们的例子中是 `simpleexample`。由于镜像将被放置在我们的本地
    Docker Desktop 注册表中，指定 URL 的存储库部分就足够了，但如果你有多个本地镜像，你也可以添加一个命名空间来更好地分类你的镜像。通常，在这个阶段，不会添加版本标签，Docker
    假设 `latest` 默认标签。
- en: 'Remember: all image names must be lowercase!'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：所有镜像名称必须是小写！
- en: The compilation might take a few seconds. If you look at the console while it
    is compiling, you can see that other images are recursively downloaded, because
    each image is built upon other images, and so on.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 编译可能需要几秒钟。如果你在编译时查看控制台，你可以看到其他镜像正在递归下载，因为每个镜像都是建立在其他镜像之上的，依此类推。
- en: Now, issue the `docker images` command to see all images defined on your local
    registry. You should see `simpleexample` among them. Images are also listed in
    the UI that appears when you double-click on the Docker Desktop icon on your desktop.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `docker images` 命令以查看本地注册表上定义的所有镜像。你应该在其中看到 `simpleexample`。镜像也列在当你双击桌面上的
    Docker Desktop 图标时出现的 UI 中。
- en: 'Now, let’s create a container based on the newly created images. The `run`
    command creates a container based on a given image and immediately executes it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们基于新创建的镜像创建一个容器。`run` 命令基于给定的镜像创建一个容器并立即执行它：
- en: '[PRE40]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `--name` option specifies a name for the container while the other argument
    is the name of the image we want to use to create the container. The container
    prints the string we put in our Java class and then exits quickly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`--name` 选项指定容器的名称，而其他参数是我们想要用来创建容器的镜像名称。容器打印出我们放在 Java 类中的字符串，然后快速退出。'
- en: 'Let’s list all executing containers with `docker ps`. No container has been
    listed since our container finished its execution. However, we can see also all
    non-running containers with the `--all` option:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`docker ps`列出所有正在运行的容器。自从我们的容器完成执行后，没有列出任何容器。然而，我们也可以使用`--all`选项看到所有非运行容器：
- en: '[PRE41]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s re-execute our container. If we re-execute the `run` command, we will
    create another container, so the right way to re-execute a sleeping container
    is as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新执行我们的容器。如果我们重新执行`run`命令，我们将创建另一个容器，所以重新执行休眠容器的正确方法是以下这样：
- en: '[PRE42]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, in this case, no string is printed on the console because `restart`
    runs the container into another process. You might find this strange but it is
    not, because containers usually run a never-ending loop that might block your
    shell.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，控制台没有打印任何字符串，因为`restart`将容器运行到另一个进程中。你可能觉得这很奇怪，但并不奇怪，因为容器通常运行一个永不结束的循环，这可能会阻塞你的shell。
- en: 'Neverending containers can be stopped with something like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 永无止境的容器可以用类似以下的方法停止：
- en: '[PRE43]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you have finished with your container, you can remove it with the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成你的容器后，你可以使用以下命令删除它：
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, you can remove also the image used to create the container with the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你也可以使用以下命令删除创建容器时使用的镜像：
- en: '[PRE45]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You have learned a lot of useful Docker shell commands. The next section is
    dedicated to the description of some more advanced useful commands.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了很多有用的Docker shell命令。下一节将专门介绍一些更高级的有用命令。
- en: A few more Docker commands and options
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些更多的Docker命令和选项
- en: During microservice operations, Docker containers are moved from one hardware
    node to another to balance the load. Unfortunately, when a container is removed
    to create it elsewhere, all files saved in its filesystem are lost. For this reason,
    some portions of the container’s filesystem are mapped to external storage, typically
    provided by network disk units.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务操作期间，Docker容器会在不同的硬件节点之间移动以平衡负载。不幸的是，当容器被移除以在其他地方创建时，其文件系统中保存的所有文件都会丢失。因此，容器文件系统的一部分被映射到外部存储，通常由网络磁盘单元提供。
- en: 'This is possible because the `run` command has the option to map a directory
    in the host machine (say, `S`) to a directory in the container’s internal storage
    space (say, `D`) so that files written to `D` are actually saved in `S`, and remain
    safe also after the container has been removed. This operation is called **bind
    mount**, and the option to add it to the `run` command is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`run`命令有一个选项可以将主机机器上的目录（比如`S`）映射到容器内部存储空间中的目录（比如`D`），这样写入`D`的文件实际上保存在`S`中，并且在容器删除后仍然安全。这个操作称为**绑定挂载**，将其添加到`run`命令的选项如下：
- en: '[PRE46]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Another option allows the mapping of each port exposed by the container to
    an actual port on the host computer:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项允许将容器公开的每个端口映射到主机计算机的实际端口：
- en: '[PRE47]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This option can be repeated several times to map more than one port. Without
    this option, it would be impossible to redirect network traffic inside the container.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项可以重复多次以映射多个端口。没有此选项，将无法将网络流量重定向到容器内部。
- en: 'The `-e` option passes operating system environment variables to the container.
    The code running in the container can easily ask the values of these variables
    to the operating system, so they are the preferred way to configure an application:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e`选项将操作系统环境变量传递给容器。容器中运行的代码可以轻松地向操作系统询问这些变量的值，因此它们是配置应用程序的首选方式：'
- en: '[PRE48]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Another useful option of the `run` command is the `-d` option (*d* stands for
    *detached*):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令的另一个有用选项是`-d`选项（*d*代表*detached*）：'
- en: '[PRE49]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this option is provided, the container is launched detached from the current
    shell prompt, that is, in a different process. This way, a container that hosts
    a never-ending program, such as a web server, doesn’t block the shell prompt.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供此选项时，容器将从当前shell提示符分离启动，即在不同的进程中。这样，托管永不结束程序（如Web服务器）的容器不会阻塞shell提示符。
- en: 'Each image can be attached to an indefinite number of tags that can be used
    as alternative names:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都可以附加到无限数量的标签，这些标签可以用作替代名称：
- en: '[PRE50]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tagging is the first step for pushing a local image into a public registry.
    Suppose we have an image called `myimage` that we would like to push to a private
    registry we have on Azure, say, `myregistry.azurecr.io/`. Suppose we would like
    to place this image in the `mypath/mymage` path of this registry, that is, to
    `myregistry.azurecr.io/mypath/mymage`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 标记是将本地镜像推送到公共仓库的第一步。假设我们有一个名为 `myimage` 的镜像，我们希望将其推送到我们在 Azure 上的私有仓库，例如 `myregistry.azurecr.io/`。假设我们希望将此镜像放置在仓库的
    `mypath/mymage` 路径中，即 `myregistry.azurecr.io/mypath/mymage`。
- en: 'As a first step, we tag our image with its final URL:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们使用以下方式对我们的镜像进行标记：
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, it is enough to execute a `push` operation that uses the new tag attached
    to the image:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行一个使用附加到镜像的新标记的 `push` 操作就足够了：
- en: '[PRE52]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Pulling public registry images to our local registry instead is straightforward:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将公共仓库镜像拉取到我们的本地仓库是直接的：
- en: '[PRE53]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Before interacting with a registry that requires a login, we must perform a
    login operation. Each registry has its own login procedure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在与需要登录的仓库交互之前，我们必须执行登录操作。每个仓库都有自己的登录过程。
- en: 'The simplest way to log in to an Azure registry is by using the Azure CLI.
    You can download its installer here: [https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 登录 Azure 仓库是最简单的方式。您可以从这里下载其安装程序：[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows)。
- en: 'As a first step, log in to your Azure account with the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，使用以下方式登录到您的 Azure 账户：
- en: '[PRE54]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This command should start your default browser and should drive you through
    the manual login procedure in your Azure account. Once logged in to your Azure
    account, you can log in to your private registry by typing the following command:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应启动您的默认浏览器，并引导您通过 Azure 账户的手动登录过程。一旦登录到 Azure 账户，您可以通过输入以下命令登录到您的私有仓库：
- en: '[PRE55]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `<registryname>` is the unique name of your Azure registry, not its complete
    URL. After logging in, you can freely work with your Azure registry.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<registryname>` 是您 Azure 仓库的唯一名称，而不是其完整 URL。登录后，您可以自由地使用您的 Azure 仓库。
- en: Visual Studio has native support for Docker. Let’s analyze all the possibilities
    offered by this support.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 对 Docker 有原生支持。让我们分析这种支持提供的所有可能性。
- en: Visual Studio support for Docker
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 对 Docker 的支持
- en: 'Visual Studio support for Docker can be enabled by simply selecting the **Enable
    container support** checkbox in the appropriate Visual Studio project options.
    Let’s experiment with an ASP.NET Core MVC project. After the project selection
    and after having chosen the project name, say, `DockerTest`, you should arrive
    at the following option page:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在适当的 Visual Studio 项目选项中简单地选择 **启用容器支持** 复选框，可以启用 Docker 对 Visual Studio 的支持。让我们用
    ASP.NET Core MVC 项目进行实验。在项目选择之后，并在选择了项目名称，例如 `DockerTest` 之后，你应该到达以下选项页面：
- en: '![Figure 3.15: Enabling Docker support](img/B31916_03_15.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15：启用 Docker 支持](img/B31916_03_15.png)'
- en: 'Figure 3.15: Enabling Docker support'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：启用 Docker 支持
- en: Please check the **Enable container support** checkbox.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 请检查 **启用容器支持** 复选框。
- en: If you forgot to enable Docker support here, you can always right-click on the
    project icon in Visual Studio Solution Explorer and then select **Add** -> **Docker
    support**.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在这里忘记了启用 Docker 支持，您始终可以在 Visual Studio 解决方案资源管理器中的项目图标上右键单击，然后选择 **添加**
    -> **Docker 支持**。
- en: 'The project contains a Dockerfile:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含一个 Dockerfile：
- en: '![Figure 3.16: Visual Studio Dockerfile](img/B31916_03_16.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16：Visual Studio Dockerfile](img/B31916_03_16.png)'
- en: 'Figure 3.16: Visual Studio Dockerfile'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：Visual Studio Dockerfile
- en: Click on the Dockerfile; it should contain the definition of four images. In
    fact, the final image is built in four stages.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Dockerfile；它应该包含四个镜像的定义。实际上，最终镜像是在四个阶段中构建的。
- en: 'The first stage defines the .NET runtime and the ports used by the application
    in the final image:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段定义了最终镜像中应用程序使用的 .NET 运行时和端口：
- en: '[PRE56]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The name `base` after `AS` will be called by other `FROM` instructions in the
    same file. The second stage performs the project build by using the `dotnet` SDK:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，`AS` 后面的 `base` 名称将被其他 `FROM` 指令调用。第二阶段通过使用 `dotnet` SDK 执行项目构建：
- en: '[PRE57]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `ARG` instruction defines a variable that can be recalled as `$BUILD_CONFIGURATION`
    in other instructions. Here, it is used to define the chosen configuration for
    the build. You can replace its value with `Debug` to compile in Debug mode.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 指令定义了一个变量，可以在其他指令中以 `$BUILD_CONFIGURATION` 的形式调用。在这里，它被用来定义构建时选择的配置。您可以用
    `Debug` 替换其值以在调试模式下编译。'
- en: The first `Copy` instruction just copies the project file in the `/src/DockerTest`
    directory of the image. Then, Nuget packages are restored and all source files
    are copied from the directory containing the Dockerfile to the current image directory,
    `/src`. Finally, we move into `/src/DockerTest` and perform a build. The build
    output files are placed in the `/app/build` directory in the image.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条`Copy`指令仅将图像`/src/DockerTest`目录中的项目文件复制。然后，Nuget包被还原，并将包含Dockerfile的目录中的所有源文件复制到当前图像目录`/src`。最后，我们进入`/src/DockerTest`并执行构建。构建输出文件放置在图像中的`/app/build`目录。
- en: 'The third stage is built on top of the `build` image and simply publishes the
    project files in the `/app/publish` folder:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段是在`build`图像之上构建的，并且简单地发布`/app/publish`文件夹中的项目文件：
- en: '[PRE58]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We could have merged stages 2 and 3 into a single stage but it is convenient
    to split stages into smaller stages because intermediary images are cached, so
    in subsequent builds, when the image input does not change, cached images are
    used instead of recomputing them.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将阶段2和3合并为一个阶段，但将阶段拆分成更小的阶段更方便，因为中间图像被缓存，所以在后续构建中，当图像输入没有变化时，将使用缓存图像而不是重新计算它们。
- en: 'Finally, the fourth and last stage is built on top of the first stage since
    it just needs the .NET runtime, and simply copies the published files from the
    image created in the third stage:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第四个也是最后一个阶段是在第一个阶段之上构建的，因为它只需要.NET运行时，并且简单地从第三阶段创建的图像中复制已发布的文件：
- en: '[PRE59]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, place a breakpoint in the `Index` method of the `HomeController.cs` file
    and run the solution. Visual Studio automatically builds the Dockerfile and runs
    the image.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`HomeController.cs`文件的`Index`方法中设置一个断点并运行解决方案。Visual Studio会自动构建Dockerfile并运行图像。
- en: The breakpoint will be hit since Visual Studio is able to perform debugging
    inside the container images!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Visual Studio能够在容器图像内执行调试，因此断点将被触发！
- en: 'While the application is running, for each container, Visual Studio shows logs,
    environment variables, bind mounts, and other information:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，对于每个容器，Visual Studio会显示日志、环境变量、绑定挂载以及其他信息：
- en: '![Figure 3.17: Visual Studio Containers console](img/B31916_03_17.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17：Visual Studio容器控制台](img/B31916_03_17.png)'
- en: 'Figure 3.17: Visual Studio Containers console'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17：Visual Studio容器控制台
- en: 'You can get also an interactive shell inside each container where you can explore
    the container’s filesystem, execute shell commands, and perform diagnostics and
    performance measurement operations, by simply opening a Linux shell and issuing
    the following command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在容器内部获得一个交互式shell，你可以在其中探索容器的文件系统，执行shell命令，并执行诊断和性能测量操作，只需打开一个Linux shell并输入以下命令：
- en: '[PRE60]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In our case, let’s list all running containers with `docker ps` to get our
    container ID:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，让我们使用`docker ps`列出所有正在运行的容器以获取我们的容器ID：
- en: '[PRE61]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, run the following:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令：
- en: '[PRE62]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, you are in the container filesystem! Let’s try some shell commands, such
    as `Is`, for instance. When you have finished with the container, it is enough
    to run `exit` to return to your host computer console.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经进入了容器文件系统！让我们尝试一些shell命令，例如`Is`，例如。当你完成容器操作后，只需运行`exit`命令即可返回到你的主机计算机控制台。
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter described two important building blocks of microservices architectures:
    the Onion Architecture and Docker containers. The chapter described the basic
    principles of the Onion Architecture and how both the Application Services and
    Domain layers are organized. More specifically, we described commands, queries,
    events, and their handlers together with aggregates and value objects.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了微服务架构的两个重要构建块：洋葱架构和Docker容器。本章描述了洋葱架构的基本原则以及应用程序服务和领域层的组织方式。更具体地说，我们描述了命令、查询、事件及其处理程序，以及聚合和值对象。
- en: Moreover, you learned how to use the preceding concepts in a Visual Studio solution
    thanks to the Visual Studio solution templates provided.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于Visual Studio提供的解决方案模板，你学会了如何在Visual Studio解决方案中使用上述概念。
- en: The chapter explained the importance of containers, how to build a Dockerfile,
    and how to use Docker shell commands in practice. Finally, the chapter described
    Visual Studio support for Docker.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了容器的重要性、如何构建Dockerfile以及如何在实践中使用Docker shell命令。最后，本章描述了Visual Studio对Docker的支持。
- en: The next chapter focuses on Azure functions and their main triggers.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍Azure函数及其主要触发器。
- en: Questions
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it true that the Domain layer project must have a reference to the database
    driver project?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 域层项目必须引用数据库驱动程序项目，这是真的吗？
- en: No, it is false. References to drivers must be added to the infrastructure layer.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这是错误的。必须将驱动程序的引用添加到基础设施层。
- en: Which solution projects are among the application services references?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些解决方案项目包含在应用服务的引用中？
- en: Only those projects that are part of the Domain Layer.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 只有那些属于域层的项目。
- en: Which solution projects are among the references of the outermost layer project
    of an Onion Architecture?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些解决方案项目包含在洋葱架构最外层项目的引用中？
- en: Application Services, Db Drivers, and all infrastructure drivers.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务、数据库驱动程序以及所有基础设施驱动程序。
- en: Is it true that an aggregate always corresponds to a unique database table?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个聚合体总是对应一个唯一的数据库表，这是真的吗？
- en: No, it is false.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这是错误的。
- en: Why are domain events needed?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要域事件？
- en: They are needed to decouple the code of different aggregates.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 它们被需要来解耦不同聚合的代码。
- en: What is the purpose of the `WORKDIR` Dockerfile instruction?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WORKDIR` Dockerfile 指令的目的是什么？'
- en: To set the image current directory.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 设置镜像当前目录。
- en: How is it possible to pass environment variables to a container?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将环境变量传递给容器？
- en: Through the -e options of the docker run command.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 docker run 命令的 -e 选项。
- en: What is the right way to persist the storage of Docker containers?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是持久化存储 Docker 容器的正确方法？
- en: Volume binds is the way to persist the storage of Docker containers.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 卷绑定是持久化存储 Docker 容器的方式。
- en: Further reading
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More on queries, commands, and the domain layer can be found here: [https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于查询、命令和域层的信息可以在这里找到：[https://udidahan.com/2009/12/09/clarified-cqrs/](https://udidahan.com/2009/12/09/clarified-cqrs/)
- en: 'More information on Docker can be found on Docker’s official website: [https://docs.docker.com/](https://docs.docker.com/)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 Docker 的信息可以在 Docker 的官方网站找到：[https://docs.docker.com/](https://docs.docker.com/)
- en: Join our community on Discord
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区。
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/PSMCSharp](https://packt.link/PSMCSharp)'
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/B31916_Discord-QR-Code.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有黑色方块的二维码 AI生成的内容可能不正确。](img/B31916_Discord-QR-Code.png)'
