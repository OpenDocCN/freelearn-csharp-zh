- en: Dependency Injection System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入系统
- en: Dependency injection is the basic building block of ASP.NET Core. This chapter
    shows how you can use dependency injection in order to resolve the dependencies
    of the classes inside an ASP.NET Core application. It also describes how you can
    deal with the dependency injection life cycle, and it provides some examples of
    how to keep the classes loosely coupled. The first part of this chapter will give
    you some basic theoretical ideas about dependency injection, while the second
    part will show you how to use it in any ASP.NET Core project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是 ASP.NET Core 的基本构建块。本章展示了如何使用依赖注入来解决 ASP.NET Core 应用程序内部类的依赖关系。它还描述了如何处理依赖注入的生命周期，并提供了一些如何保持类松耦合的示例。本章的第一部分将向您介绍一些关于依赖注入的基本理论概念，而第二部分将展示如何在任何
    ASP.NET Core 项目中使用它。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is dependency injection?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: Why implement the dependency injection pattern in real-world applications?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在现实世界的应用程序中实现依赖注入模式？
- en: Overview of the dependency injection life cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入生命周期的概述
- en: How to implement dependency injections in ASP.NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 ASP.NET Core 中实现依赖注入
- en: Dependency inversion principle
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The *dependency inversion principle* is part of the SOLID principles that were
    established by Robert C. Martin. The purpose of the SOLID principles is to provide
    some guidelines to developers on how to design code in a way that is more understandable,
    flexible, and maintainable. The dependency inversion principle, in particular,
    affirms that a high-level component should not depend directly on an individual
    component that is concentrated on a precise procedure (low-level component); instead,
    they should depend on an abstraction. Therefore, abstractions should not depend
    on any implementation details.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖倒置原则* 是由罗伯特·C·马丁（Robert C. Martin）确立的 SOLID 原则的一部分。SOLID 原则的目的是为开发者提供一些指导，以帮助他们在设计代码时使其更易于理解、灵活和可维护。特别是，依赖倒置原则断言，高级组件不应直接依赖于专注于特定过程（低级组件）的个别组件；相反，它们应该依赖于抽象。因此，抽象不应依赖于任何实现细节。'
- en: A low-level component usually performs simple operations and provides simple
    functionalities. A high-level component, on the other hand, manages a set of individual
    components by orchestrating them. Real-world systems typically have more than
    two levels of abstractions. The concept of a high-level component is relative
    to the subject module; therefore, a high-level component for one component might
    be a low-level component for another. The concept of *abstraction* is particularly
    prevalent when we talk about SOLID principles. An abstract component is usually
    an interface or an abstract class. Therefore, it is an element that does not have
    any concrete implementation. In summary, the *dependency inversion principle*
    states that every element inside our application should only refer to *abstractions.*
    Let's look at a concrete example of the *dependency inversion principle* that
    has been applied to a system. The schema describes an add-to shopping bag e-commerce
    process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 低级组件通常执行简单的操作并提供简单的功能。另一方面，高级组件通过协调它们来管理一组个别组件。现实世界系统通常具有超过两个抽象级别。当我们谈论 SOLID
    原则时，*抽象* 的概念尤其普遍。一个抽象组件通常是一个接口或抽象类。因此，它是一个没有具体实现的元素。总之，*依赖倒置原则* 声明，我们应用程序中的每个元素都应该只引用
    *抽象*。让我们看看一个具体的应用了 *依赖倒置原则* 的系统示例。该图描述了一个添加到购物袋的电子商务过程。
- en: 'It is composed of three different classes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它由三个不同的类别组成：
- en: The `AddToShoppingBagHandler` handles the requests from the client and sends
    information to `PaymentService`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddToShoppingBagHandler` 处理来自客户端的请求并将信息发送到 `PaymentService`。'
- en: The `PaymentService` manages information about payment methods.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PaymentService` 管理有关支付方式的信息。'
- en: The `CurrencyConverter` component provides conversions between different currencies.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrencyConverter` 组件提供不同货币之间的转换。'
- en: 'The following diagram describes the standard sequence of processing the preceding
    mentioned classes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了处理前面提到的类标准的处理顺序：
- en: '![](img/e7b87f01-066f-4e46-aa2c-e27cc7e89647.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7b87f01-066f-4e46-aa2c-e27cc7e89647.png)'
- en: 'If we apply the dependency inversion principle, the direction of our dependencies
    will change. To be compliant with the dependency inversion principle, we should
    introduce some abstractions between our components, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用依赖倒置原则，依赖的方向将改变。为了符合依赖倒置原则，我们应该在组件之间引入一些抽象，如下所示：
- en: '![](img/7f52ceb7-1d44-485c-87e9-127e2f8f7682.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f52ceb7-1d44-485c-87e9-127e2f8f7682.png)'
- en: By comparing the two schemas, we deduce that the direction of the dependencies
    are inverted. The `AddToShoppingBagHandler` class now uses the `IPaymentService`
    interface, and the `PaymentService` type is the concrete implementation of the
    `IPaymentService` interface*.*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较这两个架构，我们得出结论，依赖的方向被反转了。`AddToShoppingBagHandler`类现在使用`IPaymentService`接口，而`PaymentService`类型是`IPaymentService`接口的具体实现。
- en: However, this schema is not yet complete. Moreover, it is not yet compliant
    with the second statement of the dependency inversion principle. We should make
    sure that our abstractions don't depend on the implementations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个架构还不完整。此外，它还没有符合依赖倒置原则的第二条陈述。我们应该确保我们的抽象不依赖于实现。
- en: 'Consequently, if we think in terms of architectural boundaries, our schema
    changes as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们从架构边界的角度思考，我们的架构将如下改变：
- en: '![](img/2fc9cc77-5198-4a08-a0db-1ed23a81f705.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2fc9cc77-5198-4a08-a0db-1ed23a81f705.png)'
- en: Each rounded rectangle represents a boundary. The classes and the abstractions
    within the same rectangle are part of the same boundary. In the .NET ecosystem,
    each border is a project, and our interfaces are the bridge between high-level
    and low-level classes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个圆形矩形代表一个边界。同一矩形内的类和抽象是同一边界的一部分。在.NET生态系统中，每个边界都是一个项目，我们的接口是高级和低级类之间的桥梁。
- en: A common inaccuracy is to place the interfaces and the implementation classes
    within the same boundary. In .NET, this would mean putting the `IPaymentService`
    interface and `PaymentService` in the same project*.* This approach is not necessarily
    wrong, but it does not respect the *dependency inversion principle*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是将接口和实现类放在同一个边界内。在.NET中，这意味着将`IPaymentService`接口和`PaymentService`放在同一个项目中。这种方法并不一定错误，但它并不尊重**依赖倒置原则**。
- en: In conclusion, the dependency inversion principle is used to build very flexible
    systems, and it helps us to design a more readable, flexible, and maintainable
    code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，依赖倒置原则用于构建非常灵活的系统，它帮助我们设计出更易读、灵活和可维护的代码。
- en: The dependency inversion principle is often confused with the idea of dependency
    injection because the two concepts are strongly related. If dependency inversion
    defines a principle to improve our systems, dependency injection is a concrete
    implementation of that principle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则经常与依赖注入的概念混淆，因为这两个概念密切相关。如果依赖倒置定义了一个改进我们系统的原则，那么依赖注入就是这个原则的具体实现。
- en: The dependency inversion principle becomes very useful when we want to test
    our code, especially for the unit testing technique. Unit tests usually cover
    a particular function in our application, so it is necessary to isolate our classes
    and methods. Dependency inversion comes in handy because we can mock our abstraction
    and isolate our subject under testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要测试我们的代码时，特别是对于单元测试技术，依赖倒置原则变得非常有用。单元测试通常覆盖我们应用程序中的特定功能，因此我们需要隔离我们的类和方法。依赖倒置非常有用，因为我们可以在测试中模拟我们的抽象并隔离正在测试的主题。
- en: Benefits of dependency injection
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的好处
- en: 'Dependency injection is described as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的描述如下：
- en: '"A set of software design patterns that enable us to develop a loosely coupled
    code."'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '"一套软件设计模式，使我们能够开发出松耦合的代码。"'
- en: 'The objective of dependency injection is to implement a loosely coupled code
    and, as a consequence, write maintainable code. In the book, *Dependency Injection
    in .NET*, Mark Seemann describes a bright, real-life example of a loosely coupled
    code. He compares tightly coupled code with cheap hotel hairdryers: some hostels,
    hotels, and locker rooms bind their hairdryers directly on the wall without a
    plug to stop guests from stealing them. If the hairdryer stops working, the owner
    has to cut the power and call a technician, who has to disconnect the hairdryer
    and replace it with a new one. This approach is a very tedious procedure.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的目标是实现松散耦合的代码，并因此编写可维护的代码。在《.NET中的依赖注入》这本书中，Mark Seemann描述了一个明亮的、现实生活中的松散耦合代码的例子。他将紧密耦合的代码与便宜的酒店吹风机进行比较：一些旅舍、酒店和更衣室将吹风机直接绑定在墙上，没有插头以防止客人偷走。如果吹风机停止工作，所有者必须切断电源并叫技术人员，技术人员必须断开吹风机并更换一个新的。这种方法是一个非常繁琐的程序。
- en: On the other hand, if the hairdryer is plugged into the wall, the owner has
    to replace it with a new one. This is a metaphor for *dependency injection.*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果吹风机插在墙上，所有者必须更换一个新的。这是一个关于*依赖注入*的隐喻。
- en: 'The first case is a *tightly coupled code*: our high-level component (the wall)
    uses a low-level part (the hairdryer) directly. In the second case, we have a
    third actor, which is the plug: the high-level element (the wall) directly uses
    the plug (the abstraction). The hairdryer, which is our low-level component, also
    uses the plug.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例是一个*紧密耦合的代码*：我们的高级组件（墙壁）直接使用低级部分（吹风机）。在第二个案例中，我们有一个第三方演员，即插头：高级元素（墙壁）直接使用插头（抽象）。我们的低级组件吹风机也使用插头。
- en: The second case is *more flexible and maintainable* because we can plug anything
    into the plug, and if the hairdryer breaks, we can replace it easily.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个案例*更灵活且易于维护*，因为我们可以将任何东西插入插头，如果吹风机坏了，我们可以轻松地更换它。
- en: 'This is what *dependency injection* is all about. It comes with a lot of benefits
    for our code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*依赖注入*的全部内容。它为我们的代码带来了许多好处：
- en: '**Late binding**: Third-party services can be plugged in and swapped with other
    services. This may be useful when you change one third-party dependency for another.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后期绑定**：第三方服务可以被插入并与其他服务交换。当你更换一个第三方依赖项时，这可能很有用。'
- en: '**Parallel development**: Different teams can develop code at the same time
    by defining interaction contracts (interfaces) between components.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行开发**：不同的团队可以通过定义组件之间的交互契约（接口）同时开发代码。'
- en: '**Maintainability**: The code is easy to maintain and manage.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：代码易于维护和管理。'
- en: '**Testability**: As mentioned earlier, dependency injection helps us to deal
    with the isolation of the dependencies of unit tests.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：如前所述，依赖注入帮助我们处理单元测试的依赖项隔离。'
- en: The more our codebase grows, the more these benefits are useful. For small codebases,
    dependency injection can be seen as a useless overhead, but it becomes crucial
    when we deal with distributed and large codebases. In the next section, we will
    see how to apply the concept of dependency injection to the
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码库不断增长，这些好处就越有用。对于小型代码库，依赖注入可能看起来是一个无用的开销，但当我们处理分布式和大型代码库时，它变得至关重要。在下一节中，我们将看到如何将依赖注入的概念应用到
- en: Dependency injection in ASP.NET Core
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core中的依赖注入
- en: The dependency injection concept is a fundamental part of ASP.NET Core. A dependency
    injection system comes out of box with the ASP.NET Core framework, and it is the
    preferred way to instantiate components in our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的概念是ASP.NET Core的一个基本组成部分。依赖注入系统是ASP.NET Core框架自带的功能，并且是我们应用程序中实例化组件的首选方式。
- en: ASP.NET Core usually describes types that are managed by the dependency injection
    container as *services.* Therefore*,* all the servicesare stored in the built-in
    container that is represented by the `IServiceProvider` interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core通常将依赖注入容器管理的类型描述为*服务*。因此，*所有服务*都存储在由`IServiceProvider`接口表示的内置容器中。
- en: 'In the next part of the chapter, we will see some examples of dependency injection.
    As a first step, let''s create a new class in the `SampleAPI` project inside the
    `Controllers` folder, called `ValuesController.cs`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分，我们将看到一些依赖注入的示例。作为第一步，让我们在`SampleAPI`项目中的`Controllers`文件夹内创建一个新的类，命名为`ValuesController.cs`：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding snippet of code declares a `ValuesController` class, with a simple
    `Get` method. It is possible to call the route by executing the following CLI
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段声明了一个 `ValuesController` 类，其中包含一个简单的 `Get` 方法。可以通过执行以下 CLI 命令来调用路由：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is also possible by calling the following endpoint: `https://localhost:5001/values`.
    As a second step, we need to create a new `PaymentService.cs` file with the following
    code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过调用以下端点来实现：`https://localhost:5001/values`。作为第二步，我们需要创建一个新的 `PaymentService.cs`
    文件，包含以下代码：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `PaymentService.cs` file defines the `IPaymentService` interface, which
    describes a `GetMessage` signature. In addition, the `IPaymentService` interface
    is implemented by the `PaymentService` class that returns a string. In the same
    way, we are defining an `ExternalPaymentService` class, which implements the `IPaymentService`
    interface with different behavior. The next section describes how to register
    the `IPaymentService` interface in order to use the `PaymentService` class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`PaymentService.cs` 文件定义了 `IPaymentService` 接口，该接口描述了一个 `GetMessage` 签名。此外，`IPaymentService`
    接口由返回字符串的 `PaymentService` 类实现。同样，我们定义了一个 `ExternalPaymentService` 类，该类以不同的行为实现了
    `IPaymentService` 接口。下一节将描述如何注册 `IPaymentService` 接口以使用 `PaymentService` 类。'
- en: Registering services using the dependency injection container
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖注入容器注册服务
- en: 'We can register the `IPaymentService` interface in `ConfigureServices` in the
    `Startup` class by adding the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Startup` 类的 `ConfigureServices` 中注册 `IPaymentService` 接口，添加以下代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code shows a simple instantiation of a service using the ASP.NET
    Core container. I've omitted some parts of the `Startup` class in order to make
    the code more readable. The runtime executes the `services.AddTransient<IPaymentService,
    PaymentService>()` method in order to map the `IPaymentService` interface with
    the concrete implementation that was described in the `PaymentService` class.
    The `AddTransient` method also defines the scope of our service. We will go into
    detail about scopes later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了使用 ASP.NET Core 容器实例化服务的一个简单示例。为了使代码更易读，我省略了 `Startup` 类的一些部分。运行时执行 `services.AddTransient<IPaymentService,
    PaymentService>()` 方法，以便将 `IPaymentService` 接口与在 `PaymentService` 类中描述的具体实现进行映射。`AddTransient`
    方法还定义了我们的服务的作用域。我们将在本章后面详细讨论作用域。
- en: We should also note that the dependency injection container requires the concrete
    class (`PaymentService`) in order to implement the abstraction (`IPaymentService`)
    and add the instance to the container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，依赖注入容器需要具体的类（`PaymentService`）来实现抽象（`IPaymentService`）并将其实例添加到容器中。
- en: Registering services conditionally
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有条件地注册服务
- en: 'In a real-world application, it is common practice to conditionally register
    some services depending on their environment variables. This practice is useful
    when we want to initialize third-party dependencies differently, such as a data
    source. The following code shows how to register services conditionally, based
    on the environment:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，根据环境变量有条件地注册一些服务是一种常见的做法。当我们想要以不同的方式初始化第三方依赖项，例如数据源时，这种做法非常有用。以下代码展示了如何根据环境有条件地注册服务：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The example uses the `IWebHostEnvironment` interface to detect the `IsDevelopment()`
    environment. In this case, it initializes `PaymentService`. Otherwise, it initializes
    the `ExternalPaymentService` implementation. This practice is widespread in testing
    environments, especially when initializing testing services or a data source.
    It is common in broad business applications to register services conditionally
    for testing and development purposes. In [Chapter 10](266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml),
    *Implementing the RESTful HTTP Layer*, we will see some concrete examples that
    have been applied to integration testing. It is essential to keep testing environments
    isolated in order to avoid false-positive results. Furthermore, registering services
    conditionally also helps us to improve the flexibility of our code. In the next
    subsections, we will see how to use constructor injection and action injection
    in order to resolve the dependencies of the controller classes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用`IWebHostEnvironment`接口来检测`IsDevelopment()`环境。在这种情况下，它会初始化`PaymentService`。否则，它会初始化`ExternalPaymentService`实现。这种做法在测试环境中很常见，尤其是在初始化测试服务或数据源时。在广泛的企业应用中，为了测试和开发目的，通常会在条件注册服务。在第10章[Implementing
    the RESTful HTTP Layer](266d98e8-df54-4024-aefb-b5871b3b35fa.xhtml)中，我们将看到一些具体的应用实例，这些实例已经应用于集成测试。保持测试环境隔离对于避免假阳性结果至关重要。此外，条件注册服务也有助于我们提高代码的灵活性。在接下来的小节中，我们将看到如何使用构造函数注入和操作注入来解决控制器类的依赖关系。
- en: Constructor injection
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: 'We have just seen how we can initialize services in our `Startup` class, but
    how can we consume these services? By default, the built-in dependency injection
    container of ASP.NET Core uses the constructor injectionpattern to retrieve services*.*
    We can modify `ValueController` to use `IPaymentServices` by adding the interface
    as a parameter of the controller constructor:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何在我们的`Startup`类中初始化服务，但如何消费这些服务呢？默认情况下，ASP.NET Core内置的依赖注入容器使用构造函数注入模式来检索服务*。我们可以通过将接口作为控制器构造函数的参数来修改`ValueController`以使用`IPaymentServices`：`public
    ValuesController(IPaymentService paymentService, string[] paymentTypes = new string[]
    { 1, 2, 3 })`。
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, we can inject the `IPaymentService` interface into the constructor
    of our class. It should be noted that to be compliant with constructor injection*,*
    the constructor has to abide by the following rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以在我们类的构造函数中注入`IPaymentService`接口。需要注意的是，为了符合构造函数注入*规范*，构造函数必须遵守以下规则：
- en: '**The constructor should be public**: If our constructor is not public, the
    reflection process cannot access the constructor.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数应该是公共的**：如果我们的构造函数不是公共的，反射过程无法访问构造函数。'
- en: '**There should be only one applicable constructor**: For example, if we declare
    multiple constructors in our `ValuesController` class, such as `public ValuesController(IPaymentService
    paymentService)` or `public ValuesController(IPaymentService paymentService, string[]
    paymentTypes = new string[] { 1, 2, 3 })`, the runtime would throw `InvalidOperationException`.
    There should be only one constructor that is suitable for dependency injection.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应该只有一个合适的构造函数**：例如，如果我们在我们`ValuesController`类中声明了多个构造函数，比如`public ValuesController(IPaymentService
    paymentService)`或者`public ValuesController(IPaymentService paymentService, string[]
    paymentTypes = new string[] { 1, 2, 3 })`，运行时会抛出`InvalidOperationException`。应该只有一个适合依赖注入的构造函数。'
- en: 'You can only pass arguments that *are not provided* by dependency injection
    if they have a *default value***.** For example, the following constructor is
    suitable for constructor injection: `public ValuesController(IPaymentService paymentService,
    string[] paymentTypes = new string[] { 1, 2, 3 })`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当它们有*默认值*时，您才能传递*未由依赖注入提供的*参数。例如，以下构造函数适合构造函数注入：`public ValuesController(IPaymentService
    paymentService, string[] paymentTypes = new string[] { 1, 2, 3 })`。
- en: The resolution of the dependencies happens during the runtime execution; therefore,
    we need to adhere to these rules in order to avoid pitfalls when we alter the
    dependencies of a controller class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系的解析发生在运行时执行过程中；因此，我们需要遵守这些规则，以避免在更改控制器类的依赖关系时遇到陷阱。
- en: In conclusion, dependency injection provides a smart way to resolve the dependencies
    of classes. You should also try to be compliant with the **Single Responsibility
    Principle** (**SRP**). The SRP states that a class should have responsibility
    for a single part of the functionality. Classes with a lot of injected dependencies
    are probably not compliant with the SRP. Avoiding these kinds of bad design practices
    improves the maintainability of our code, and avoids our classes being tightly
    coupled with static functionalities, which prevent them from being testable. Let's
    proceed with the next section that covers the action method injection technique.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，依赖注入提供了一种智能的方式来解决类的依赖问题。你也应该尽量遵守**单一职责原则**（**SRP**）。SRP指出，一个类应该只负责功能的一部分。拥有大量注入依赖的类可能不符合SRP。避免这些不良的设计实践可以提高我们代码的可维护性，并避免我们的类与静态功能紧密耦合，这会阻止它们被测试。接下来，我们将继续下一节，该节将介绍动作方法注入技术。
- en: Action method injection
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作方法注入
- en: 'A valid alternative to constructor injection is the action method injection.
    Sometimes, controllers use some dependencies in only one action method. In those
    cases, it may be useful to inject our dependency just in this action method, in
    order to improve the performance of our code. To perform anaction method injection,
    we should use the `[FromServices]` attribute. For example, look at the following
    snippet of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入的一个有效替代方案是动作方法注入。有时，控制器只在一个动作方法中使用一些依赖项。在这些情况下，将我们的依赖项仅注入到这个动作方法中，可能有助于提高我们代码的性能。要执行动作方法注入，我们应该使用`[FromServices]`属性。例如，看看以下代码片段：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The example, as aforementioned, uses the action method injection. We are injecting
    our service into the `Get` action method which is the only consumer of the dependency.
    Although constructor injection is widely adopted, the action method injection
    technique becomes useful when you don't use the dependency on the whole controller.
    This only guarantees a lazy resolution of the dependencies when the action method
    is invoked. We should also note that this approach is strictly dependent on the
    MVC stack, because the resolution of the service is performed in the model-binding
    phase of the execution; therefore, it is only supported in the action method and
    in the filter classes. The next section will be focused on the services life cycle
    types that are provided by ASP.NET Core.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，该示例使用了动作方法注入。我们将服务注入到`Get`动作方法中，这是唯一的依赖项消费者。尽管构造函数注入被广泛采用，但当你在整个控制器中不使用依赖项时，动作方法注入技术变得很有用。这仅保证了在动作方法被调用时依赖项的延迟解析。我们还应该注意，这种方法严格依赖于MVC堆栈，因为服务的解析是在执行过程中的模型绑定阶段完成的；因此，它仅支持在动作方法和过滤器类中。下一节将专注于ASP.NET
    Core提供的服务生命周期类型。
- en: Services life cycle
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务生命周期
- en: A key point to master when we deal with dependency injection is the services
    life cycle. The services life cycle is an essential concept about performance,
    because a wrong service life cycle may cause complicated performance degradation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理依赖注入时，我们需要掌握的一个关键点是服务生命周期。服务生命周期是关于性能的一个基本概念，因为错误的服务生命周期可能会导致复杂的性能下降。
- en: 'The object lifetime in .NET is simple: the object is *instantiated*, *used*,
    and finally *disposed of* by the garbage collector. The *dispose* phase is the
    most relevant in terms of performance. In a dependency injection process, the
    consumer of a specific dependency does not control its lifetime. Indeed, dependencies
    are usually initialized by the dependency injection container, and they continue
    to exist until all their consumers hold them.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，对象的生命周期很简单：对象被*实例化*，*使用*，最后由垃圾回收器*销毁*。在性能方面，*销毁*阶段是最相关的。在依赖注入过程中，特定依赖项的消费者不控制其生命周期。实际上，依赖项通常由依赖注入容器初始化，并且它们会一直存在，直到所有消费者都持有它们。
- en: A typical performance issue that engineers face in large applications is the
    *memory leak*. The garbage collector fails to clean objects because they are still
    referred to as consumers. Consequently, the memory of the server increases until
    it reaches saturation. It is not easy to find and solve these kinds of performance
    issues. In a .NET ecosystem, tools such as dotMemory can help you to analyze the
    instances of the objects that are created by your application, and eventually
    detect performance issues of this type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，工程师面临的一个典型性能问题是 *内存泄漏*。垃圾收集器无法清理对象，因为它们仍然被消费者引用。结果，服务器的内存不断增加，直到达到饱和。找到和解决这类性能问题并不容易。在.NET生态系统中，像dotMemory这样的工具可以帮助您分析应用程序创建的对象实例，并最终检测到这类性能问题。
- en: Speaking of dependency injection, the default life cycle types in ASP.NET Core
    are *transient*, *scoped*, and *singleton*. Let's discuss them more in detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 说到依赖注入，ASP.NET Core中的默认生命周期类型是 *瞬态*、*作用域* 和 *单例*。让我们更详细地讨论它们。
- en: Transient life cycle
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瞬态生命周期
- en: The services define the transient life cycle using the `.AddTransient()` method.
    Every time the consumer requires the initialization of a transient service, the
    dependency injection container returns a new instance. The transient life cycle
    is the safest life cycle, because it returns a new instance each time, and instances
    are not shared between consumers. It is also, however, the least efficient, because
    it can create a huge number of instances, especially in the web environment.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通过使用 `.AddTransient()` 方法定义了瞬态生命周期。每次消费者需要初始化瞬态服务时，依赖注入容器都会返回一个新的实例。瞬态生命周期是最安全的生命周期，因为它每次都返回一个新的实例，实例之间不会在消费者之间共享。然而，它也是最不高效的，因为它可能会创建大量的实例，尤其是在网络环境中。
- en: Scoped life cycle
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域生命周期
- en: The services define the scoped life cycle `.AddScoped()` method. Scoped instances
    are created once per request. The scoped life cycle is preferable compared to
    the transient life cycle regarding performance, but it is less efficient than
    the singleton life cycle. A scoped approach is usually applied to repository classes
    and services, and each request to the server will cause the creation of a new
    instance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 服务定义了作用域生命周期 `.AddScoped()` 方法。作用域实例在每个请求中只创建一次。与瞬态生命周期相比，作用域生命周期在性能上更可取，但它的效率低于单例生命周期。通常将作用域方法应用于仓库类和服务，每次对服务器的请求都会导致创建一个新的实例。
- en: Singleton life cycle
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例生命周期
- en: In the singleton life cycle, each time a consumer asks for a new instance, the
    same instance is provided. This is the most efficient life cycle because there
    is only a single instance, so the amount of consumed memory is minimal. However,
    it is recommended that you only use the singleton life cycle for thread-safe components.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在单例生命周期中，每次消费者请求一个新实例时，都会提供相同的实例。这是最有效的生命周期，因为只有一个实例，所以消耗的内存量最小。然而，建议您仅对线程安全组件使用单例生命周期。
- en: Life cycle madness
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期疯狂
- en: 'The term *life cycle madness* is a quote from Jeffrey Richter''s *CLR via C#*,
    and its chapter about threading. Understanding the life cycle of dependencies
    is important in order to avoid performance issues in our application. Above all,
    we should avoid the following cases:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: “生命周期疯狂”这个术语来自Jeffrey Richter的《CLR via C#》，其中关于线程的章节。理解依赖项的生命周期对于避免我们应用程序中的性能问题非常重要。首先，我们应该避免以下情况：
- en: '**Consuming scoped dependencies in a singleton consumer**:As previously mentioned,
    a scoped life cycle means that a new instance is created for each request. When
    we try to consume a scoped instance in a singleton life cycle, the runtime will
    throw an exception as follows: `InvalidOperationException: Cannot consume scoped
    service ''Services.MyScopedService'' from singleton ''Services.MySingletonService''`.
    This is because the runtime cannot create a scoped service for each request when
    it is referred to by a singleton instance.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在单例消费者中消费作用域依赖项**：如前所述，作用域生命周期意味着每个请求都会创建一个新的实例。当我们尝试在单例生命周期中消费作用域实例时，运行时会抛出以下异常：`InvalidOperationException:
    Cannot consume scoped service ''Services.MyScopedService'' from singleton ''Services.MySingletonService''`。这是因为当单例实例引用它时，运行时无法为每个请求创建作用域服务。'
- en: '**Consuming transient dependencies in a singleton consumer**:Similarly, if
    we use a transient dependency inside a singleton instance, the runtime will not
    create a new instance of the transient service each time. Furthermore, the transient
    service will be initialized only once because it is declared in a singleton. Also,
    the runtime *will not throw an exception*, because a new instance of the transient
    service is not requested, as the singleton always uses the same one.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在单例消费者中消费瞬态依赖项**：同样，如果我们在一个单例实例中使用瞬态依赖项，运行时不会每次都创建瞬态服务的新的实例。此外，由于瞬态服务是在单例中声明的，它将只初始化一次。而且，运行时*不会抛出异常*，因为单例始终使用同一个实例。'
- en: In order to prevent possible bugs and runtime errors, it is important to avoid
    the situation in which a singleton refers to a scoped or transient service. In
    the first case, the runtime will throw an exception, while in the second case,
    the singleton consumer will always use the same instance. These behaviors must
    be avoided in order to prevent any memory issues and performance degradation inside
    our APIs. The following subsection explains how to use dependency injection in
    the middleware classes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止可能的错误和运行时错误，避免单例引用scoped或瞬态服务的情况非常重要。在第一种情况下，运行时会抛出异常，而在第二种情况下，单例消费者将始终使用同一个实例。这些行为必须避免，以防止在我们的API内部出现内存问题和性能下降。以下小节将解释如何在中间件类中使用依赖注入。
- en: Injecting services into middleware
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将服务注入中间件
- en: 'As discussed earlier, middleware can instantiate dependencies through a dependency
    injection container. We should take the life cycle of the middleware into consideration:
    they are initialized once per application lifetime. As a consequence, if we try
    to consume a *scoped* or *transient* *instance* into our middleware we shouldn''t
    inject them through the constructor of the middleware, because this will cause
    some dependency resolution issues. A good way to avoid this is to use the parameter
    injection in the `Invoke` or `InvokeAsync` methods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，中间件可以通过依赖注入容器实例化依赖项。我们应该考虑中间件的寿命：它们在每个应用程序生命周期中只初始化一次。因此，如果我们尝试在我们的中间件中消费*scoped*或*瞬态*实例，我们不应该通过中间件的构造函数注入它们，因为这会导致一些依赖项解析问题。避免这种情况的一个好方法是使用`Invoke`或`InvokeAsync`方法中的参数注入：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The other middleware implementation injects `IPaymentService` in the `InvokeAsync`
    method. Unlike the middleware constructor, the `InvokeAsync` method is called
    for each request. Consequently, it is suitable for both a *scoped life cycle*
    and a *transient life cycle*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个中间件实现将`IPaymentService`注入到`InvokeAsync`方法中。与中间件构造函数不同，`InvokeAsync`方法对每个请求都会被调用。因此，它既适用于*scoped生命周期*也适用于*瞬态生命周期*。
- en: When you want to inject a transientservice or a scoped service into middleware,
    you should inject them in the `Invoke` or `InvokeAsync` methods in order to avoid
    life cycle problems. Furthermore, middleware is a cross-cutting component, which
    means that the application runs them at every request. Therefore, you must pay
    extra attention when you implement middleware, in order to avoid spreading performance
    issues across all of the applications.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将一个transientservice或scoped service注入到中间件中时，你应该在`Invoke`或`InvokeAsync`方法中注入它们，以避免生命周期问题。此外，中间件是一个横切组件，这意味着应用程序在每次请求时都会运行它们。因此，在实现中间件时，你必须格外小心，以避免将性能问题传播到所有应用程序中。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has shown us how to deal with the ASP.NET Core default dependency
    injection engine. The chapter provides various examples that are related to dependency
    injection, how to use dependency injection in controllers and middleware, and
    describes the life cycle concepts of the registered services. The next chapter
    will discuss the controllers and the action methods in detail. It will show you
    how to use these in order to serialize data and expose it as a web service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何处理ASP.NET Core默认的依赖注入引擎。本章提供了与依赖注入相关的各种示例，包括如何在控制器和中间件中使用依赖注入，以及描述已注册服务的生命周期概念。下一章将详细讨论控制器和操作方法。它将向您展示如何使用这些方法来序列化数据并将其作为Web服务公开。
