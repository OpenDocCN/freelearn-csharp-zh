- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Presenting ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to implement a web application and a web-based
    presentation layer. More specifically, you will learn about ASP.NET Core and how
    to implement a web application presentation layer based on ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core is a .NET framework for implementing web applications. The ASP.NET
    Core Web API was partially described in previous chapters, so this chapter will
    focus mainly on ASP.NET Core in general and on ASP.NET Core MVC. More specifically,
    this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the presentation layers of web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of ASP.NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how ASP.NET Core MVC creates the response HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the connection between ASP.NET Core MVC and design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will review and provide further details on the structure of the ASP.NET Core
    framework, which we discussed in part in earlier chapters. Here, the main focus
    is on how to implement web-based presentation layers based on the so-called **Model
    View Controller** (**MVC**) architectural pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We will also analyze how server-side HTML is created with ASP.NET Core MVC’s
    **Razor** template language.
  prefs: []
  type: TYPE_NORMAL
- en: Each concept is explained using code examples, and *Chapter 18*, *Implementing
    Frontend Microservices with ASP.NET Core*, is dedicated to the description of
    a frontend microservice implemented with ASP.NET Core MVC. For a complete practical
    example of how to put into practice the general principles discussed in this and
    the next chapter, please refer to the *A frontend microservice* section in *Chapter
    21*, *Case Study*.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the free Visual Studio 2022 Community edition, ideally
    with all the database tools installed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the presentation layers of web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses an architecture for implementing the presentation layers
    of web applications based on the ASP.NET Core framework. The presentation layers
    of web applications are based on three techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile or desktop native applications that exchange data with servers through
    REST or SOAP services**: We will discuss desktop applications in *Chapter 19*,
    *Client Frameworks: Blazor*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-Page Applications** (**SPAs**): These are HTML-based applications
    whose dynamic HTML is created on the client, either in JavaScript or with the
    help of WebAssembly (a kind of cross-browser assembly that can be used as a high-performance
    alternative to JavaScript). Like native applications, SPAs exchange data with
    the server through HTTP-based APIs, but they have the advantage of being independent
    of the device and its operating system, since they run in a browser. *Chapter
    19*, *Client Frameworks: Blazor*, describes the Blazor SPA framework, which is
    based on WebAssembly, since it is based itself on a .NET runtime compiled in WebAssembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML pages created by the server whose content depends on the data to be
    shown to the user**: The ASP.NET Core MVC framework, which will be discussed in
    this chapter, is a framework for creating such dynamic HTML pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remainder of this chapter focuses on how to create HTML pages on the server
    side and, more specifically, on ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of ASP.NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core is based on the concept of the generic host, as explained in the
    *Using generic hosts* subsection of *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*. The basic architecture of ASP.NET Core was outlined
    in the *A short introduction to ASP.NET Core* subsection of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth remembering that the host configuration consists mainly of adding
    services to the **Dependency Injection** (**DI**) engine through the `Services`
    property of a host builder instance, whose type implements the `IServiceCollection`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `IServiceCollection` interface implemented by `builder.Services` defines
    all the services that can be injected into object constructors through DI.
  prefs: []
  type: TYPE_NORMAL
- en: Services can be defined either by calling the various overloads of `AddTransient`
    and `AddSingleton` directly in `Program.cs`, or by grouping these calls in some
    `IServiceCollection` extension methods, which are then called in `Program.cs`.
    The way services are handled in .NET is explained in detail in the *Using generic
    hosts* section of *Chapter 11*. Here, it is worth pointing out that, together
    with singleton and transient services, ASP.NET Core also supports another kind
    of service lifetime, session lifetime, which is the lifetime of a single web request
    served by the ASP.NET Core application. Session-scoped services are declared with
    `AddScoped` overloads that are completely analogous to the overloads of `AddTransient`
    and `AddSingleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Session-scoped services are useful for storing data that are specific to a single
    request that must be used throughout the whole request by several application
    components. A typical example of a .NET session-scoped service is the Entity Framework
    Core `DBContexts`. In fact, all operations performed on the various aggregates
    involved in the request must use the same request-specific `DBContext` so that
    all changes can be saved to the database in a single transaction, with a unique
    `SaveChanges` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications of session-scoped `DBContext`s and other services are
    described in more detail in *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, all applications define most of the application configuration through
    the host builder so that after the host is built with `var app = builder.Build()`,
    you need to call `app.Run()` or `await app.RunAsync()` to launch the application.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core host instead performs another configuration step after it has
    been built; it defines the so-called ASP.NET Core HTTP request processing pipeline,
    which will be described in more detail in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core contains an internal web server called Kestrel that has just the
    basic web server functionalities. So in simple applications such as IoT applications,
    or worker microservices, we can avoid the overhead of a fully optional complex
    web server like IIS, Apache, or NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: If ASP.NET Core is used to implement the application layer of a frontend microservice/application
    or a classic website, Kestrel can be interfaced with all major web servers that
    proxy their request to Kestrel.
  prefs: []
  type: TYPE_NORMAL
- en: In version 8, by default, Kestrel supports all protocols up to and including
    version HTTP/3.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, Kestrel passes all requests to a set of configurable modules that you
    can assemble according to your needs. Each module takes care of a functionality
    that you may or may not need. Examples of such functionalities include authorization,
    authentication, static file processing, protocol negotiation, and CORS handling.
    Since most of the modules apply transformations to the incoming request and the
    final response, these modules are usually referred to as **middleware**.
  prefs: []
  type: TYPE_NORMAL
- en: You can put together all the **middleware** modules you need by inserting them
    into a common processing framework called the **ASP.NET Core pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, ASP.NET Core requests are processed by pushing a context
    object through a pipeline of ASP.NET Core modules, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_17_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: ASP.NET Core pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: The object that is inserted into the pipeline is an `HttpContext` instance that
    contains the data of the incoming request. More specifically, the `Request` property
    of `HttpContext` contains an `HttpRequest` object whose properties represent the
    incoming request in a structured way. There are properties for headers, cookies,
    the request path, parameters, form fields, and the request body.
  prefs: []
  type: TYPE_NORMAL
- en: The various modules can contribute to the construction of the final response
    that is written in an `HttpResponse` object, contained in the `Response` property
    of the `HttpContext` instance. The `HttpResponse` class is similar to the `HttpRequest`
    class, but its properties refer to the response being built.
  prefs: []
  type: TYPE_NORMAL
- en: Some modules can build an intermediate data structure that is then used by other
    modules in the pipeline. In general, such intermediary data can be stored in custom
    entries of the `IDictionary<object, object>`, which is contained in the `Items`
    property of the `HttpContext` object. However, there is a predefined property,
    `User`, that contains information about the currently logged-in user. The logged-in
    user is not computed automatically, so it must be computed by an authentication
    module. The *ASP.NET Core service authorization* subsection of *Chapter 15*, *Applying
    Service-Oriented Architectures with .NET*, explained how to add the standard module
    that performs JWT-based authentication into the ASP.NET Core pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also has a `Connection` property that contains information on
    the underlying connection established with the client, as well as a `WebSockets`
    property that contains information on possible WebSocket-based connections established
    with the clients.'
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also has a `Features` property that contains `IDictionary<Type,
    object>`, which specifies the features supported by the web server that hosts
    the web application and by the pipeline. Features can be set using the `.Set<TFeature>(TFeature
    o)` method and retrieved using the `.Get<TFeature>()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Web server features are automatically added by the framework, while all other
    features are added by pipeline modules when they process `HttpContext`.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpContext` also gives us access to the DI engine through its `RequestServices`
    property. You can get an instance of a type managed by the dependency engine by
    calling the `.RequestServices.GetService(Type t)` method or, even better, the
    `.GetRequiredService<TService>()` extension method that is built on top of it.'
  prefs: []
  type: TYPE_NORMAL
- en: However, as we will see in the remainder of this chapter, all types managed
    by the DI engine are usually automatically injected into constructors, so these
    methods are only used when we’re building custom **middleware** or other customizations
    of the ASP.NET Core engine.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpContext` instance that is created for processing a web request is not
    only available to modules but also to the application code, through DI. It is
    sufficient to insert an `IHttpContextAccessor` parameter into the constructor
    of a class that is automatically dependency injected, and then access its `HttpContext`
    property. All controllers that inherit from `Controller` or `ControllerBase` (see
    later in this section) expose an `HttpContext` property that contains the request
    `HttpContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A middleware module is any class with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to pass `InvokeAsync` directly as a lambda to `app.Use`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In general, each piece of middleware processes the `HttpContext` instance that
    was passed by the previous module in the pipeline, and then it calls `await _next.Invoke(context)`
    to invoke the modules in the remainder of the pipeline. When the other modules
    have finished their processing and the response for the client has been prepared,
    each module can perform further post-processing of the response in the code that
    follows the `_next.Invoke(context)` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules are registered in the ASP.NET Core pipeline by calling the `UseMiddleware<T>`
    method of the built host, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Middleware modules are inserted into the pipeline in the same order when `UseMiddleware`
    is called. Since each functionality that’s added to an application might require
    several modules and operations other than adding modules, you usually define an
    `IApplicationBuilder` extension such as `UseMyFunctionality`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After that, the whole functionality can be added to the application by calling
    `app.UseMyFunctionality(...)`. For instance, the ASP.NET Core MVC functionality
    can be added to the ASP.NET Core pipeline by calling `app.UseEndpoints(....)`.
  prefs: []
  type: TYPE_NORMAL
- en: Often, functionalities that are added with each `app.Use...` require that some
    .NET types are added to the application DI engine. In these cases, we also define
    an `IServiceCollection` extension named `AddMyFunctionality`, which must be called
    by `builder.Services` in `Program.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, ASP.NET Core MVC requires a call such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t need to change the default MVC options, you can simply call `builder.Services.AddControllersWithViews()`.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes another important feature of the ASP.NET Core
    framework – namely, how to handle application configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: Loading configuration data and using it with the options framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding how ASP.NET Core applications handle configuration is crucial
    for effective application setup. In the default .NET template where an ASP.NET
    Core application starts, it reads configuration information (such as a database
    connection string) from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files, where `EnvironmentName` is a string value that depends on where the application
    is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical values for the `EnvironmentName` string are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Production` is used for production deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Development` is used during development'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Staging` is used when the application is tested in staging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two JSON trees that were extracted from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files are merged into a unique tree, where the values contained in `[EnvironmentName].json`
    override the values contained in the corresponding paths of `appsettings.json`.
    This way, the application can be run with different configurations in different
    deployment environments. In particular, you can use a different database connection
    string and, hence, a different database instance in each different environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_17_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: Configuration files merging'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration information can also be passed from other sources. Given a lack
    of space, we list here all the other possibilities without discussing them:'
  prefs: []
  type: TYPE_NORMAL
- en: XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.ini` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system environment variables. The variable name is the name of the
    setting prefixed by the `ASPNETCORE_` string, while the variable value is the
    setting value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments of a `dotnet` command that invokes the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An in-memory collection of key-value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON format is, in my opinion, the most practical and readable, but JSON,
    XML, and `.ini` are substantially equivalent, and choosing among them is just
    a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: In memory, collections of key-value pairs offer the possibility of taking data
    from a database, so they are useful options for those parameters that need to
    be changed by an administrator while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, command-line arguments and environment variables are good options when
    the application can’t easily access disk storage – for instance, in the case of
    deployments running in a Kubernetes cluster. In fact, environment variables can
    be passed as parameters in the Kubernetes `.yaml` files (see the *ReplicaSets
    and Deployments* section of *Chapter 20, Kubernetes*). They are also an acceptable
    choice for passing sensitive data that it is not adequate to store in files in
    a plain format.
  prefs: []
  type: TYPE_NORMAL
- en: From version 8 onward, ASP.NET Core allows you to set Kestrel HTTP and HTTPS
    listening ports as configuration variables. More specifically, `HTTP_PORTS` contains
    a semicolon-separated list of all Kestrel HTTP listening ports, while `HTTPS_PORTS`
    contains a semicolon-separated list of all HTTPs listening ports whose defaults
    are the usual HTTP and HTTPs ports, that is, `80` and `443`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `[EnvironmentName]` string itself is taken from the `ENVIRONMENT` configuration
    setting. Clearly, since it is needed to decide which configuration files to use,
    it cannot be contained in a configuration file, so it must be taken from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable, or from the arguments of the `dotnet` command
    used to launch the application.
  prefs: []
  type: TYPE_NORMAL
- en: When the application is deployed to IIS instead of being launched as a standalone
    program, `ASPNETCORE_ENVIRONMENT` can’t be passed on the `dotnet` command line.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it can be set in the IIS application settings. This can be done
    after the applications have been deployed, by clicking on the Configuration Editor
    and then selecting the `system.webServer/aspNetCore` section. In the window that
    opens, select `environmentVariables`, and then add the `ASPNETCORE_ENVIRONMENT`
    variable with its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_17_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: Changing ASPNETCORE_ENVIRONMENT in IIS'
  prefs: []
  type: TYPE_NORMAL
- en: However, when the application is modified and deployed again, the setting is
    reset to its default value, which is `Production`, and it must be set again.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better choice is to modify the publish profile in Visual Studio, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During Visual Studio deployment, Visual Studio’s **Publish** wizard creates
    an XML publish profile. Once the preferred deployment type (Azure, Web Deploy,
    folder, and so on) has been chosen, and before publishing, you can edit the publish
    settings by choosing **Edit** from the **More actions** dropdown in the window
    that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have your publish file properly set, in Visual Studio **Solution Explorer**,
    open the profile that you just prepared with the Visual Studio wizard. Profiles
    are saved in the `Properties/PublishProfiles/<profile name>.pubxml` path of the
    project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, edit the profile with a text editor, and add an XML property such as `<EnvironmentName>Staging</EnvironmentName>`.
    Since all the already defined publish profiles can be selected during the application’s
    publication, you can define a different publish profile for each of your environments,
    and then, you can select the one you need during each publication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The value you must set `ASPNETCORE_ENVIRONMENT` to during deployment can also
    be specified in the Visual Studio ASP.NET Core project file (`.csproj`) of your
    application, by adding the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest way to do `ASPNETCORE_ENVIRONMENT`, but not the most modular,
    since we are forced to change the application code before publishing to a different
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the environment either in the publish profile or the project file
    works only for deployment types based on direct communication between Visual Studio
    and the web server, as in other deployment types, Visual Studio cannot inform
    the web server on how to set `ASPNETCORE_ENVIRONMENT` or on how to pass the environment
    when the application is launched. At the time of writing, the techniques described
    work just for Web Deploy or when publishing on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'During development in Visual Studio, the value to give to `ASPNETCORE_ENVIRONMENT`
    when the application is run can be specified in the `Properties\launchSettings.json`
    file of the ASP.NET Core project. The `launchSettings.json` file contains several
    named groups of settings. These settings configure how to launch the web application
    when it is run from Visual Studio. You can choose to apply all the settings of
    a group by selecting the group name with the drop-down list next to Visual Studio’s
    run button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_17_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.4: Choice of launch settings group'
  prefs: []
  type: TYPE_NORMAL
- en: Your selection from this drop-down list will be visible on the run button, with
    the default selection being **IIS Express**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a development environment setup, as illustrated in this typical `launchSettings.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The named groups of settings are under the `profiles` properties. There, you
    can choose where to host the application (`IIS Express`), where to launch the
    browser, and the values of some environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The current environment that’s been loaded from the `ASPNETCORE_ENVIRONMENT`
    operating system environment variable is available in the `app.Environment` property
    during the ASP.NET Core pipeline definition.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.Environment.IsEnvironment(string environmentName)` checks whether the
    current value of `ASPNETCORE_ENVIRONMENT` is `environmentName`. There are also
    specific shortcuts for testing development (`.IsDevelopment()`), production (`.IsProduction()`),
    and staging (`.IsStaging()`). The `app.Environment` property also contains the
    current root directory of the ASP.NET Core application (`.WebRootPath`) and the
    directory reserved for the static files (`.ContentRootPath`) that are served as
    is by the web server (CSS, JavaScript, images, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `launchSettings.json` and all publish profiles can be accessed as children
    of the **Properties** node in Visual Studio Explorer, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19820_17_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.5: Launch settings file'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how to map the merged configuration settings to .NET objects is
    key for effective data management in ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `appsettings.json` and `appsettings.[EnvironmentName].json` have been
    loaded, the configuration tree resulting from their merge can be mapped to the
    properties of .NET objects. For example, let’s suppose we have an `Email` section
    of the `appsettings` file that contains all of the information needed to connect
    to an email server, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the whole `Email` section can be mapped to an instance of the following
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that performs the mapping must be inserted in the host building stage,
    since the `EmailConfig` instance will be available through DI. The code we need
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we’ve configured the preceding settings, classes that need `EmailConfig`
    data must declare an `IOptions<EmailConfig> options` constructor parameter that
    will be provided by the DI engine. An `EmailConfig` instance is contained in `options.Value`.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the option classes’ properties can be applied to
    the same validation attributes we will use for ViewModels (see the *Server-side
    and client-side validation* subsection).
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection describes the basic ASP.NET Core pipeline modules needed
    by an ASP.NET Core MVC application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the ASP.NET Core pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding the ASP.NET Core pipeline is key to customizing application behavior.
    When you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline
    is created in the `Program.cs` file. There, if needed, you can add further middleware
    or change the configuration of the existing middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial pipeline definition code handles errors and performs basic HTTPS
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If there are errors, and if the application is in a development environment,
    the module installed by `UseDeveloperExceptionPage` adds a detailed error report
    to the response. This module is a valuable debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs when the application is not in development mode, `UseExceptionHandler`
    restores the request processing from the path it receives as an argument, that
    is, from `/Home/Error`. In other words, it simulates a new request with the `/Home/Error`
    path. This request is pushed into the standard MVC processing until it reaches
    the endpoint associated with the `/Home/Error` path, where the developer is expected
    to place the custom code that handles the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is not in development, `UseHsts` adds the `Strict-Transport-Security`
    header to the response, which informs the browser that the application must only
    be accessed with HTTPS. After this declaration, compliant browsers should automatically
    convert any HTTP request of the application into an HTTPS request for the time
    specified in the `Strict-Transport-Security` header. By default, `UseHsts` specifies
    30 days as the time in the header, but you can specify a different time and other
    header parameters by passing `UseHsts` a lambda that configures an `options` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`UseHttpsRedirection` causes an automatic redirection to an HTTPS URL when
    an HTTP URL is received, in a way that forces a secure connection. Once the first
    HTTPS secure connection is established, the `Strict-Transport-Security` header
    prevents future redirections that might be used to perform man-in-the-middle attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the remainder of the default pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`UseStaticFiles` makes all files contained in the `wwwroot` folder of the project
    (typically CSS, JavaScript, images, and font files) accessible from the web through
    their actual path.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseCookiePolicy` has been removed in the .NET 5-8 templates, but you can still
    add it manually. It ensures that cookies are processed by the ASP.NET Core pipeline,
    but only if the user has given consent for cookie usage. Consent to cookie usage
    is given through a consent cookie; that is, cookie processing is enabled only
    if this consent cookie is found among the request cookies. This cookie must be
    created by JavaScript when the user clicks a consent button. The whole string
    that contains both the consent cookie’s name and its contents can be retrieved
    from `HttpContext.Features`, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`CanTrack` is `true` only if consent is required and has not been given yet.
    When the consent cookie is detected, `CanTrack` is set to `false`. This way, `showBanner`
    is `true` only if consent is required and has not been given yet. Therefore, it
    tells us whether to ask the user for consent.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`UseAuthentication` enables authentication schemes and only appears if you
    select an authentication scheme when the project is created. More specifically,
    this middleware decodes the authorization tokens (authorization cookies, bearer
    tokens, etc.), and it uses the information it contains to build a `ClaimsPrincipal`
    object that is placed in the `HttpContext.User` property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific authentication schemes can be enabled by configuring the options objects
    in the host building stage, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code specifies a custom authentication cookie name and adds JWT-based
    authentication for the REST services contained in the application. Both `AddCookie`
    and `AddJwtBearer` have overloads that accept the name of the authentication scheme
    before the action, which is where you can define the authentication scheme options.
    Since the authentication scheme name is necessary for referring to a specific
    authentication scheme, when it is not specified, a default name is used:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard name contained in `CookieAuthenticationDefaults.AuthenticationScheme`
    for cookie authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard name contained in `JwtBearerDefaults.AuthenticationScheme` for
    JWT authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name that’s passed into `o.DefaultScheme` selects the authentication scheme,
    used to fill the `User` property of `HttpContext`. Together with `DefaultScheme`,
    other properties also allow more advanced customizations.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about JWT authentication, please refer to the *ASP.NET
    Core service authorization* subsection of *Chapter 15*, *Applying Service-Oriented
    Architectures with .NET*.
  prefs: []
  type: TYPE_NORMAL
- en: If you just specify `builder.Services.AddAuthentication()`, a cookie-based authentication
    with default parameters is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: '`UseAuthorization` enables authorization based on the `Authorize` attribute.
    Options can be configured by adding `builder.Services.AddAuthorization` to the
    host building stage. These options allow you to define the policies for claims-based
    authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseRouting` and `UseEndpoints` handle the so-called ASP.NET Core endpoints.
    An endpoint is an abstraction of a handler that serves specific classes of URLs.
    These URLs are transformed into an `Endpoint` instance with patterns. When a pattern
    matches a URL, an `Endpoint` instance is created and filled with both the pattern’s
    name and the data that was extracted from the URL. This is a consequence of matching
    URL parts with named parts of the pattern. This can be seen in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`UseRouting` adds a module that processes the request path to get the request
    `Endpoint` instance and adds it to the `HttpContext.Features` dictionary under
    the `IEndpointFeature` type. The actual `Endpoint` instance is contained in the
    `Endpoint` property of `IEndpointFeature`.'
  prefs: []
  type: TYPE_NORMAL
- en: Each pattern also contains the handler that should process all the requests
    that match the pattern. This handler is passed to `Endpoint` when it is created.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `UseEndpoints` adds the middleware that executes the route
    determined by the `UseRouting` logic. It is placed at the end of the pipeline,
    since its middleware produces the final response. Splitting the routing logic
    into two separate middleware modules enables authorization middleware to sit in
    between them and, based on the matched endpoint, to decide whether to pass the
    request to the `UseEndpoints` middleware for its normal execution, or whether
    to return a 401 (`Unauthorized`)/403 (`Forbidden`) response immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '`UseAuthorization` must always be placed after both `UseAuthentication` and
    `UseRouting` because it needs both the `HttpContext.User` that is filled by `UseAuthentication`
    and the handler selected by `UseRouting`, in order to verify whether a user is
    authorized to access the selected request handler.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `app.MapControllerRoute` is a shortcut for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shortcut was introduced with the 6.0 version of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: '`MapControllerRoute` defines the patterns associated with the MVC engine, which
    will be described in the next subsection. Other methods define other types of
    patterns. A call such as `.MapHub<MyHub>("/chat")` maps paths to hubs that handle
    **SignalR**, an abstraction built on top of `WebSocket`, whereas `.MapHealthChecks("/health")`
    maps paths to ASP.NET Core components that return application health data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also directly map a pattern to a custom handler with `.MapGet`, which
    intercepts GET requests, and `.MapPost`, which intercepts POST requests. This
    is called **route to code**. The following is an example of `MapGet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can also write `app.MapGet(...)` directly, since there are shortcuts for
    `MapGet`, `MapPost`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: All these shortcuts, together with the new features, have been named **Minimal
    API**. They offer a lean approach for simpler applications, which is relevant
    for architects considering performance optimization and API design, particularly
    in IoT and microservices scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, `MapGet`, `MapPost`, and suchlike have been enhanced, and now they
    have overloads whose lambda returns the result directly to add to the response
    with no need to call `context.Response.WriteAsync`. If the result isn’t a string,
    it is automatically converted into JSON, and the response `Content-Type` is set
    to `application/json`. For more complex needs, Minimal APIs can use the static
    methods of the `Results` class that supports all return types supported by ASP.NET
    Core controllers. The following is an example of `Results` class usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Patterns are processed in the order in which they are defined until a matching
    pattern is found. Since the authentication/authorization middleware is placed
    after the routing middleware, it can process the `Endpoint` request to verify
    whether the current user has the required authorizations to execute the `Endpoint`
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, a 401 (`Unauthorized`) or 403 (`Forbidden`) response is immediately
    returned. Only requests that survive authentication and authorization have their
    handlers executed by the `UseEndpoints` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The Minimal API supports the automatic generation of the OpenAPI metadata we
    described in *Chapter 15*, *Applying Service-Oriented Architectures with .NET.*
    They also support **Ahead-of-Time** (**AOT**) compilation during the application
    publication. This way, applications are immediately compiled in the target CPU
    language, saving the time needed by a just-in-time compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since AOT runs at publication time, it can perform better code optimizations,
    and in particular, it can trim DLL unused code. In general, AOT is not supported
    by controller-based applications since they make greater use of reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Minimal APIs are targeted to simple and fast applications, running
    on small devices such as IoT applications, where, on one hand, speed and reduced
    application size are fundamental, and on the other hand, the benefit of structuring
    code through controllers is negligible. We will not describe Minimal APIs in great
    detail, since this book targets mainly business and enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that in the last .NET version, a new **ASP.NET Core API**
    project was added that scaffolds an application based on the Minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the ASP.NET Core RESTful API described in *Chapter 15*, ASP.NET Core MVC
    also uses attributes placed on controllers or controller methods to specify authorization
    rules. However, an instance of `AuthorizeAttribute` can also be added to a pattern
    to apply its authorization constraints to all the URLs matching that pattern,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The previous code makes the health check path available only to administrative
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth mentioning the `.UseCors()` middleware, which enables the
    application to handle CORS policies. We will discuss it in the *Communication
    with the server* section in *Chapter 19, Client Frameworks: Blazor*.'
  prefs: []
  type: TYPE_NORMAL
- en: Having described the basic structure of the ASP.NET Core framework, we can now
    move on to more MVC-specific features. The next subsection describes controllers
    and explains how they interact with the UI components, known as Views, through
    ViewModels.
  prefs: []
  type: TYPE_NORMAL
- en: Defining controllers and ViewModels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ASP.NET Core MVC, controllers and ViewModels are central to handling requests,
    presenting data, and handling the whole user-application interactions. Let’s start
    by understanding how requests issued at specific paths are passed to controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The various `.MapControllerRoute` calls associate URL patterns with controllers
    and their methods, where controllers are classes that inherit from the `Microsoft.AspNetCore.Mvc.Controller`
    class. Controllers are discovered by inspecting all of the application’s `.dll`
    files and are added to the DI engine. This job is performed by the call to `builder.Services.AddControllersWithViews`
    in the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline module that’s added by `UseEndpoints` takes the controller’s name
    from the `controller` pattern variable, and the name of the controller method
    to invoke from the `action` pattern variable. Since, by convention, all controller
    names are expected to end with the `Controller` suffix, the actual controller
    type name is obtained from the name found in the `controller` variable by adding
    this suffix. Hence, for instance, if the name found in `controller` is `Home`,
    then the `UseEndpoints` module tries to get an instance of the `HomeController`
    type from the DI engine. All of the controller public methods can be selected
    by the routing rules. The use of a controller public method can be prevented by
    decorating it with the `[NonAction]` attribute. All controller methods available
    to the routing rules are called action methods.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers work like the API controllers that we described in the *Implementing
    REST services with ASP.NET Core* subsection in *Chapter 15*, *Applying Service-Oriented
    Architectures with .NET*. The only difference is that API controllers are expected
    to produce JSON or XML, while MVC controllers are expected to produce HTML. For
    this reason, while API controllers inherit from the `ControllerBase` class, MVC
    controllers inherit from the `Controller` class, which, in turn, inherits from
    the `ControllerBase` class and adds its methods, which are useful for HTML generation,
    such as invoking views, as described in the next subsection, and creating a redirect
    response.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers can also use a routing technique similar to one of the API controllers,
    that is, routing based on controllers and controller method attributes. This behavior
    is enabled by calling the `app.MapControllers()` method in the pipeline definition
    code in `Program.cs`. If this call is placed before all other `app.MapControllerRoute`
    calls, then the controller routes have priority over `MapControllerRoute` patterns;
    otherwise, the opposite is true.
  prefs: []
  type: TYPE_NORMAL
- en: '`MapControllerRoute` has the advantage of deciding in a single place the whole
    paths used by the whole application. This way, you can optimize all application
    paths for a search engine, or simply for better user navigation, by changing a
    few lines of code in a single place. For these reasons, `MapControllerRoute` is
    almost always used in MVC applications. However, `MapControllerRoute` is rarely
    used with the REST API because the priority of the REST API is to avoid changes
    in the associations between paths and controllers, since they might prevent existing
    clients from working properly.'
  prefs: []
  type: TYPE_NORMAL
- en: All the attributes we have seen for API controllers can also be used with MVC
    controllers and action methods (`HttpGet`, `HttpPost`, …, `Authorize`, and so
    on). Developers can write their own custom attributes by inheriting from the `ActionFilter`
    class or other derived classes. I will not give details on this right now, but
    these details can be found in the official documentation, which is referred to
    in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: When the `UseEndpoints` module invokes a controller, all of its constructor
    parameters are filled by the DI engine, since the controller instance itself is
    returned by the DI engine, and since DI automatically fills constructor parameters
    with DI in a recursive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action methods take both their input and services from their parameters, so
    it is crucial to understand how these parameters are filled by ASP.NET Core. They
    are taken from the following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables in the pattern matched by the current request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query string parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form parameters (in the case of POST requests)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**), in case of services needed to process the
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the parameters filled with DI are matched by type, all other parameters
    are matched by *name* while ignoring the letter casing. That is, the action method
    parameter name must match the header, query string, form, or pattern variable.
    In turn, pattern variables are filled by matching the pattern with the request
    path.
  prefs: []
  type: TYPE_NORMAL
- en: When the parameter is a complex type, the behavior depends on the source.
  prefs: []
  type: TYPE_NORMAL
- en: If the source is the request body, a **formatter** adequate for the request
    `Content-Type` is selected. **Formatters** are software modules capable of building
    complex entities, starting from a text representation of them. As a default, the
    request body is taken as a source for selected `Content-Types`, such as `application/json`
    and binary MIME types, because each such MIME type requires a different deserialization
    algorithm that is specific to it.
  prefs: []
  type: TYPE_NORMAL
- en: If the source is not the request body, an algorithm called model binding is
    used to fill all complex object public properties instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model binding algorithm searches for a match in each property (remember
    that just properties are mapped; fields are not), using the property name for
    the match. In the case of nested complex types, a match is searched for each nested
    property’s path, and the name associated with the path is obtained by chaining
    all the property names in the path and separating them with dots. For instance,
    a parameter whose name is `Property1.Property2.Property3…Propertyn` is mapped
    with the `Propertyn` property that is in the following path of nested object properties:
    `Property1`, `Property2`, ...., `Propertyn`.'
  prefs: []
  type: TYPE_NORMAL
- en: The name that’s obtained this way must match a header name, pattern variable
    name, query string parameter name, and so on. For instance, an `OfficeAddress`
    property containing a complex `Address` object would generate names like `OfficeAddress.Country`
    and `OfficeAddress.Town`.
  prefs: []
  type: TYPE_NORMAL
- en: The model binding algorithm can also fill collections and dictionaries, but
    due to a lack of space, we can’t describe these cases. However, the *Further reading*
    section contains a link to an excellent Phil Haack post that explains them in
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, simple type parameters are matched with pattern variables and query
    string variables, while complex type parameters are matched with form parameters
    or the request body (depending on their MIME types). However, the preceding defaults
    can be changed by prefixing the parameters with attributes, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[FromForm]` forces a match with form parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromBody]` forces the extraction of data from the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromHeader]` forces a match with a request header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]` forces a match with pattern variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]` forces a match with a query string variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromServices]` forces the use of DI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is worth pointing out that versions 7 and 8 of ASP.NET Core have an enhanced
    Minimal API to support basically the same parameter bindings of a controller’s
    action methods, as well as all the above parameter attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the match, the string that was extracted from the selected source is
    converted into the type of the action method parameter, using the current thread
    culture. If either a conversion fails or no match is found for an obligatory action
    method parameter, then the whole action method invocation process fails, and a
    404 response is automatically returned. For instance, in the following example,
    the `id` parameter is matched with query string parameters or pattern variables,
    since it is a simple type, while `myclass` properties and nested properties are
    matched with form parameters, since `MyClass` is a complex type. Finally, `myservice`
    is taken from DI, since it is prefixed with the `[FromServices]` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If no match is found for the `id` parameter, and if the `id` parameter is declared
    as obligatory in the `MapControllerRoute` pattern, a 404 response is automatically
    returned, since pattern matching fails. It is common to declare parameters as
    not optional when they must match not-nullable single types. If, instead, no `MyService`
    instance is found in the DI container, an exception is thrown because, in this
    case, the failure doesn’t depend on a wrong request but on a design error.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers return an `IActionResult` interface or a `Task<IActionResult>`
    result if they are declared as `async`. `IActionResult` defines the unique method
    with the `ExecuteResultAsync(ActionContext)` signature, which, when invoked by
    the framework, produces the actual response.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each different `IActionResult`, MVC controllers have methods that return
    them. The most commonly used `IActionResult` is `ViewResult`, which is returned
    by a `View` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewResult` is a very common way for a controller to create an HTML response.
    More specifically, the controller interacts with business/data layers to produce
    an abstraction of the data that will be shown on the HTML page. This abstraction
    is an object called a **ViewModel**. The ViewModel is passed as a second argument
    to the `View` method, while the first argument is the name of an HTML template,
    called `View`, that is instantiated with the data contained in the ViewModel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing this up, the MVC controllers’ processing sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The controllers perform some processing to create the ViewModel, which is an
    abstraction of the data to show on the HTML page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the controllers create `ViewResult` by passing a View name and ViewModel
    to the `View` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MVC framework invokes `ViewResult` and causes the template contained in
    the View to be instantiated with the data contained in the ViewModel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result of the template’s instantiation is written in the response with adequate
    headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, the controller performs the conceptual job of HTML generation by building
    a ViewModel, while the View – that is, the template – takes care of all the presentation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Views will be described in greater detail in the next subsection, while the
    Model (ViewModel) View Controller pattern will be discussed in more detail in
    the *Understanding the connection between ASP.NET Core MVC and design principles*
    section in this chapter. Finally, a practical example will be provided in *Chapter
    18*, *Implementing Frontend Microservices with ASP.NET Core*.
  prefs: []
  type: TYPE_NORMAL
- en: Another common `IActionResult` is `RedirectResult`, which creates a redirect
    response, hence forcing the browser to move to a specific URL. Redirects are often
    used once the user has successfully submitted a form that completes a previous
    operation. In this case, it is common to redirect the user to a page where they
    can select another operation.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to return `RedirectResult` is by passing a URL to the `Redirect`
    method. This is the advised way to perform a redirect to a URL that is outside
    the web application. On the other hand, when the URL is within the web application,
    it is advisable to use the `RedirectToAction` method, which accepts the controller’s
    name, the action method name, and the desired parameters for the target action
    method. This method has several overloads, where each overload omits some of the
    above parameters. In particular, the controller name can be omitted if the URL
    we define is handled by the same controller.
  prefs: []
  type: TYPE_NORMAL
- en: The framework uses this data to compute a URL that causes the desired action
    method to be invoked with the parameters provided. This way, if the routing rules
    are changed during the application’s development or maintenance, the new URL is
    automatically updated by the framework, with no need to modify all occurrences
    of the old URL in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to call `RedirectToAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful `IActionResult` is `ContentResult`, which can be created by
    calling the `Content` method. `ContentResult` allows you to write any string to
    the response and specify its MIME type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `File` method returns `FileResult`, which writes binary data in
    the response. There are several overloads of this method that allow the specification
    of a byte array, a stream, or the path of a file, plus the MIME type of the binary
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to describing how actual HTML is generated in Views.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how ASP.NET Core MVC creates the response HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Razor Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ASP.NET Core MVC uses a language called Razor to define the HTML templates
    contained in the Views. Razor views are files that are compiled into .NET classes
    when they’re first used, when the application has been built, or when the application
    has been published. By default, both pre compilation on each build and on publish
    are enabled, but you can also enable runtime compilation so that the Views can
    be modified once they have been deployed. This option can be enabled by checking
    the **Enable Razor runtime compilation** checkbox when the project is created
    in Visual Studio. You can also disable compilation on each build and on publish
    by adding the following code to the web application project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Views can also be precompiled into Views libraries if you choose a Razor view
    library project in the window, which appears once you have chosen an ASP.NET Core
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Also, following the compilation, Views remain associated with their paths, which
    become their full names. Each controller has an associated folder under the **Views**
    folder with the same name as the controller, which is expected to contain all
    the Views used by that controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the folder associated with a possible `HomeController`
    and its Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19820_17_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.6: View folders associated with controllers and the shared folder'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot also shows the **Shared** folder, which is expected
    to contain all the Views or partial views used by several controllers. The controller
    refers to views in the `View` method through their paths without the `.cshtml`
    extension. If the path starts with `/`, the path is interpreted as relative to
    the application root. Otherwise, as a first attempt, the path is interpreted as
    relative to the folder associated with the controller. If no View is found there,
    the View is searched for in the **Shared** folder.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, for instance, the `Privacy.cshtml` View file in the preceding screenshot
    can be referred to from within `HomeController` as `View("Privacy", MyViewModel)`.
    If the name of the View is the same as the name of the action method, we can simply
    write `View(MyViewModel)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Razor views are a mix of HTML code with C# code, plus some Razor-specific statements.
    They usually begin with a header that contains the type of ViewModel that the
    View is expected to receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This declaration may be omitted, but in this case, the view will not be specific
    to a specific type, and we will not be able to use the model property names in
    the Razor code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view may also contain some `using` statements, whose effect is the same
    as the `using` statements of standard code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`@using` statements declared in the special `_ViewImports.cshtml` file – that
    is, in the root of the `Views` folder – are automatically applied to all views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view can also require instances of types from the DI engine in its header,
    with the syntax shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code requires an instance of the `IViewLocalizer` interface and
    places it in the `Localizer` variable. The remainder of the View is a mix of C#
    code, HTML, and Razor control flow statements. Each area of a view can be either
    in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted
    as HTML, while the code in a View area that is in C# mode is interpreted as C#.
  prefs: []
  type: TYPE_NORMAL
- en: The topic that follows explains the Razor flow of control statements.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Razor flow of control statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to write some C# code in an HTML area, you can create a C# area
    with the `@{..}` Razor flow of a control statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows that it is enough to write an HTML tag to create
    an HTML area inside the C# area and so on recursively. As soon as the HTML tag
    closes, you are in C# mode again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to create an HTML area but don’t want to enclose it in an HTML tag,
    we can use the fake `<text>` tag provided by Razor syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'C# code produces no HTML, while HTML code is added to the response in the same
    order in which it appears. You can add text computed with C# code while in HTML
    mode by prefixing any C# expression with `@`. If the expression is complex, in
    that it is composed of a chain of properties and method calls, it must be enclosed
    by parentheses. The following code shows some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `@` itself can be escaped by entering it twice – `@@`.
  prefs: []
  type: TYPE_NORMAL
- en: Types are converted into strings using the current culture settings (see the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section for details on how to set the culture of each request). Moreover, strings
    are automatically HTML-encoded to avoid the `<` and `>` symbols, which might interfere
    with the view HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML encoding can be prevented with the `@HTML.Raw` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In an HTML area, alternative HTML can be selected with the `@if` Razor statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the beginning of each block of a Razor control
    flow statement is in C# mode and remains so until the first HTML open tag is encountered,
    and then, HTML mode starts. C# mode is resumed after the corresponding HTML close
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTML template can be instantiated several times with the `for`, `foreach`,
    `while`, and `do` Razor statements, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Razor views can contain comments that do not generate any code. Any text included
    within `@*...*@` is considered a comment and removed when the page is compiled.
    With a good understanding of controllers and their operational mechanics, let’s
    now turn to how ASP.NET Core MVC generates HTML responses using Razor views.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Razor view properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some standard variables are predefined in each view. The most important variable
    is `Model`, which contains the ViewModel that was passed to the view. For instance,
    if we pass a `Person` model to a view, then `<span>@Model.Name</span>` displays
    the name of the `Person` model that was passed to the view.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewData` variable contains `IDictionary<string, object>`, which is shared
    with the controller that invoked the view; that is, all controllers also have
    a `ViewData` property containing `IDictionary<string, object>`, and every entry
    that is set in the controller is also available in the `ViewData` variable of
    the invoked view. `ViewData` is an alternative to the ViewModel for a controller,
    allowing the passing of information to its invoked view. It is worth mentioning
    that the `ViewData` dictionary can also be accessed as a dynamic object through
    the `ViewBag` property. This means that dynamic `ViewBag` properties are mapped
    to `ViewData` string indices and that their values are mapped to the `ViewData`
    entries corresponding to those indices. Using `ViewData` or `ViewBag` is just
    a matter of preference; neither one has an advantage over the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, `ViewData` is used to store collateral data such as the value-string
    pairs used to populate an HTML Select. For instance, let’s suppose the ViewModel
    model contains `TownId` and `TownName` properties that the user can change, by
    selecting a different town from an HTML Select. In this case, the action method
    might fill the `"AllTowns"` entry of `ViewData` with all possible town ID and
    town name pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Both controllers and Views also contain a `TempData` dictionary, whose entries
    are remembered between two successive requests. Due to a lack of space, we can’t
    discuss its properties and its usage, but the interested among you can refer to
    the official Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-8.0#tempdata)'
  prefs: []
  type: TYPE_NORMAL
- en: The `User` view variable contains the currently logged-in user, that is, the
    same instance contained in the current request’s `Http.Context.User` property.
    The `Url` variable contains an instance of the `IUrlHelper` interface, whose methods
    are utilities for computing the URLs of application pages. For instance, `Url.Action("action",
    "controller", new {par1=valueOfPar1,...})` computes the URL that causes the action
    method, `action`, of `controller` to be invoked, with all the parameters specified
    in the anonymous object passed as its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` variable contains the whole request’s `HttpContext`. The `ViewContext`
    variable contains data about the context of the view invocation, including metadata
    about the action method that invoked the view.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic describes how Razor views enhance HTML tag syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Using Razor tag helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tag helpers in ASP.NET Core MVC are powerful tools for enhancing HTML tags with
    additional functionalities. More specifically, a tag helper either enhances existing
    HTML tags with new tag attributes or defines completely new tags.
  prefs: []
  type: TYPE_NORMAL
- en: While Razor views are compiled, any tag is matched against existing tag helpers.
    When a match is found, the source tag is replaced with HTML created by the tag
    helpers. Several tag helpers may be defined for the same tag. They are all executed
    in an order that can be configured with a priority attribute associated with each
    tag helper.
  prefs: []
  type: TYPE_NORMAL
- en: All tag helpers defined for the same tag may cooperate while each tag instance
    is being processed. This is because they are passed a shared data structure where
    each of them may apply a contribution. Usually, the final tag helper that is invoked
    processes this shared data structure to produce the output HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Tag helpers are classes that inherit from the `TagHelper` class. This topic
    doesn’t discuss how to create new tag helpers, but it does introduce the main
    predefined tag helpers that come with ASP.NET Core MVC. A complete guide on how
    to define tag helpers is available in the official documentation, which is referenced
    in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a tag helper, you must declare the `.dll` file that contains the tag
    helper with a declaration like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you would like to use just one of the tag helpers defined in the `.dll` file,
    you must replace `*` with the tag name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding declaration can be placed either in each view that uses the tag
    helpers defined in the library or, ultimately, in the `_ViewImports.cshtml` file
    in the root of the `Views` folder. By default, `_ViewImports.cshtml` adds all
    predefined ASP.NET Core MVC tag helpers with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The anchor tag is enhanced with attributes that automatically compute the URL
    and invoke a specific action method with given parameters, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Below is an example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML created is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It might appear that there is almost no advantage in using the tag helper. However,
    this isn’t true! The advantage is that whenever the routing rules change, the
    tag helper automatically updates the `href` that it generates to conform to the
    new routing rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar syntax is added to the `form` tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `script` tag is enhanced with attributes that allow us to fall back to
    a different source if the download fails. Typical usage is to download scripts
    from some cloud service to optimize the browser cache and to fall back to a local
    copy of the script if there is a failure. The following code uses the fallback
    technique to download the `bootstrap` JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`asp-fallback-test` contains a JavaScript test that verifies whether the download
    succeeded. In the preceding example, the test verifies whether a JavaScript object
    has been created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All HTML tags that admit an `src` attribute, that is, the `img` and the script
    tags, can be added as an `asp-append-version` attribute set to `true`. The `asp-append-version`
    attribute set to `true` doesn’t change the syntax of the `img` and `script` tags;
    it just adds a hash to the `src` query string to prevent cashing each time the
    image or `script` file changes. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is rendered as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The hash passed in the `v` query parameter is computed from the content of the
    image file, so it changes whenever the image changes, thereby preventing the browser
    from rendering an old cached copy of the image.
  prefs: []
  type: TYPE_NORMAL
- en: The `~/` symbol is not a feature specific to the `img` tag helper and, instead,
    a Razor native feature you can use in all links contained in any tag of a Razor
    file. It stands for the application root. It is not equivalent to the HTML `/`
    symbol that stands for the root of the domain, because ASP.NET Core applications
    can also be placed in subfolders of the domain. So `~/` translates as `/` only
    when the application is placed in the domain root; otherwise, it translates as
    `/{application subfolder name}/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `environment` tag can be used to select different HTML for different environments
    (development, staging, and production). Its typical usage is selecting the debug
    versions of JavaScript files during development, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `cache` tag, which caches its content in memory to optimize
    rendering speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By default, content is cached for 20 minutes, but the tag has attributes that
    must be defined when the cache expires, such as `expires-on="{datetime}"`, `expires-after="{timespan}"`,
    and `expires-sliding="{timespan}"`. Here, the difference between `expires-sliding`
    and `expires-after` is that, in the second attribute, the expiration time count
    is reset each time the content is requested. The `vary-by` attribute causes the
    creation of a different cache entry for each different value passed to `vary-by`.
    There are also attributes such as `vary-by-header`, which creates a different
    entry for each different value assumed by the request header specified in the
    `vary-by-cookie` attribute, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `input` tags – that is, `textarea`, `input`, and `select` – have an `asp-for`
    attribute that accepts a properties path rooted in the view’s ViewModel as their
    value. For instance, if the view has a `Person` ViewModel, we may have something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first thing the preceding code does is assign the value of the `Town` nested
    property to the `value` attribute of the `input` tag. In general, if the value
    is not a string, it is converted into a string using the current request culture.
  prefs: []
  type: TYPE_NORMAL
- en: However, it also sets the name of the input field to `Address.Town` and the
    `id` of the input field to `Address_Town`. This is because dots are not allowed
    in tag `ids`.
  prefs: []
  type: TYPE_NORMAL
- en: A prefix can be added to these standard names by specifying it in `ViewData.TemplateInfo.HtmlFieldPrefix`.
    For instance, if the previous property is set to `MyPerson`, the name becomes
    `MyPerson.Address.Town`.
  prefs: []
  type: TYPE_NORMAL
- en: If the form is submitted to an action method that has the same `Person` class
    as one of its parameters, the name of `Address.Town` that’s given to the `input`
    field will cause the `Town` property of this parameter to be filled with the `input`
    field. In general, the string contained in the `input` field is converted into
    the type of property it has been matched with, using the current request culture.
    Summing this up, the names of `input` fields are created in such a way that a
    complete `Person` model can be recovered in the action method when the HTML page
    is posted.
  prefs: []
  type: TYPE_NORMAL
- en: The same `asp-for` attribute can be used in a `label` tag to cause the label
    to refer to the input field with the same `asp-for` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of an `input/label` pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When no text is inserted into the label, the text shown in the label is taken
    from a `Display` attribute that decorates the property (`Town`, in this example),
    if any; otherwise, the name of the property is used.
  prefs: []
  type: TYPE_NORMAL
- en: If `span` or `div` contains an `asp-validation-for="Address.Town"` error attribute,
    then validation messages concerning the `Address.Town` input will be inserted
    automatically inside that tag. The validation framework will be described in the
    *Understanding the connection between ASP.NET Core MVC and design principles*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to automatically create a validation error summary by adding
    the attribute that follows a `div` or a `span`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the attribute is set to `ValidationSummary.ModelOnly`, only messages that
    are not associated with specific `input` fields will be shown in the summary,
    while if the value is `ValidationSummary.All`, all error messages will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: The `asp-items` attribute can be applied to any `select` tag to automatically
    generate all the `select` options. It must be passed an `IEnumerable<SelectListItem>`,
    where each `SelectListItem` contains both the text and value of an option. `SelectListItem`
    also contains an optional `Group` property that you can use to organize the options
    shown in `select` into groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use `asp-items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When added, option tags are placed before the ones generated by `asp-items`.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic shows how to reuse view code.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing view code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core MVC includes several techniques for reusing view code, with the
    most important being the layout page.
  prefs: []
  type: TYPE_NORMAL
- en: In each web application, several pages share the same structure, for instance,
    the same main menu or the same left or right bar. In ASP.NET Core, this common
    structure is factored out in views called layout pages/views.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19820_17_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.7: Using layout pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each view can specify the view to be used as its layout page with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If no layout page is specified, a default layout page, defined in a `_ViewStart.cshtml`
    file located in the `Views` folder, is used. The default content of `_ViewStart.cshtml`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, the default layout page in the files scaffolded by Visual Studio
    is `_Layout.cshtml`, which is contained in the `Shared` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout page contains the HTML that’s shared with all of its children pages,
    the HTML page headers, and the page references to CSS and JavaScript files. The
    HTML produced by each view is placed inside its layout page, where the layout
    page calls the `@RenderBody()` method, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`ViewData` of each `View` is copied into `ViewData` of its layout page, so
    `ViewData` can be used to pass information to the view layout page. Typically,
    it is used to pass the view title to the layout page, which then uses it to compose
    the page’s title header, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: While the main content produced by each view is placed in a single area of its
    layout page, each layout page can also define several sections placed in different
    areas, where each view can place further secondary content.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, suppose a layout page defines a `Scripts` section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the view can use the previously defined section to pass some view-specific
    JavaScript references, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If an action method is expected to return HTML to an AJAX call, it must produce
    an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout
    page must be used. This is achieved by calling the `PartialView` method instead
    of the `View` method in the controller action method. `PartialView` and `View`
    have exactly the same overloads and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to reuse view code is to factor out a view fragment that’s common
    to several views into another view that is called by all previous views. A view
    can call another view with the `partial` tag, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code invokes `_viewname` and passes it to the object contained
    in `Model.ModelProperty.NestedProperty` as its `ViewModel`. When a view is invoked
    by the `partial` tag, no layout page is used, since the called view is expected
    to return an HTML fragment.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called view is set
    to the `ModelProperty.NestedProperty` string. This way, possible input fields
    rendered in `_viewname.cshtml` will have the same name as if they had been rendered
    directly by the calling view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specifying the ViewModel of `_viewname` through a property of the
    caller view (ViewModel), you can also directly pass an object that is contained
    in a variable or returned by a C# expression by replacing `for` with `model`,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called
    view keeps its default value, that is, the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A view can also call something more complex than another view, that is, another
    controller method that, in turn, renders a view. Controllers that are designed
    to be invoked by views are called **view components**. The following code is an
    example of component invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Parameter names must match the ones used in the view component method. However,
    both the component’s name and parameter names must be translated into kebab case;
    that is, all the characters must be transformed into lowercase if all the characters
    in the original name were in uppercase, although the first letter of the name
    must be preceded by a `-`. For instance, `MyParam` must be transformed into `my-param`.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, view components are either classes that derive from the `ViewComponent`
    class, classes decorated with the `[ViewComponent]` attribute, or classes whose
    names end with the `ViewComponent` suffix. When a component is invoked, the framework
    looks for either an `Invoke` method or an `InvokeAsync` method and passes it all
    the parameters that were defined in the component’s invocation. `InvokeAsync`
    must be used if the method is defined as `async`; otherwise, we must use `Invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a view component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The previously defined component must be invoked with a call such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If the component is invoked by a view of a controller called `MyController`,
    `ViewName` is searched for in the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/Views/MyController/Components/MyTest/ViewName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/Views/Shared/Components/MyTest/ViewName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the connection between ASP.NET Core MVC and design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole ASP.NET Core framework is built on top of the design principles and
    patterns that we analyzed in *Chapter 11*, *Applying a Microservice Architecture
    to Your Enterprise Application*, *Chapter 13*, *Interacting with* *Data in C#
    – Entity Framework Core*, *Chapter 6*, *Design Patterns and .NET 8 Implementation*,
    *Chapter 7*, *Understanding the Different Domains in Software Solutions*, and
    *Chapter 5*, *Implementing* *Code Reusability in C# 12*.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, all framework functionalities are provided through DI so that each
    of them can be replaced by a customized counterpart, without it affecting the
    remainder of the code. Moreover, these providers are not added individually to
    the DI engine; instead, they are grouped into collection properties of option
    objects (see the *Loading configuration data and using it with the options framework*
    subsection) for improved maintainability, and to conform to the Separation of
    Concerns principle, which is a generalization of the Single Responsibility principle.
    In fact, the order in which providers are added to their collection does matter,
    since they are processed in the same order as they are in the collection. Moreover,
    the effect of a provider also depends on the other providers that belong to the
    same collection, so sometimes, it is not enough to replace a provider or add a
    new provider, but it is necessary to also remove/replace other providers to remove
    their side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of providers grouped in collections include all model binders, validation
    providers, and data annotation providers.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, configuration data, instead of being available from a unique dictionary
    created from a configuration file, is organized into option objects thanks to
    the options framework we described in the first section of this chapter. This
    is also an application of the SOLID Interface Segregation principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, ASP.NET Core also applies other patterns that are specific instances
    of the general Separation of Concerns principle, which (as mentioned earlier)
    is a generalization of the Single Responsibility principle. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The middleware modules architecture (the ASP.NET Core pipeline)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factoring out validation and globalization from the application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVC pattern itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will analyze each of these in the various subsections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the ASP.NET Core pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ASP.NET Core pipeline architecture has two important advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: All the different operations that are performed on the initial request are factored
    out into different modules, according to the Single Responsibility principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modules that perform these different operations don’t need to call each
    other because each module is invoked once and for all by the ASP.NET Core framework.
    This way, the code for each module is not required to perform any action that
    is connected to responsibilities that have been assigned to other modules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures maximum independence of functionalities and simpler code. For instance,
    once the authorization and authentication modules are active, no other module
    needs to worry about authorization anymore. Each piece controller code can focus
    on application-specific business stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side and client-side validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic has been completely factored out from the application code
    and has been confined to the definition of validation attributes. The developer
    just needs to specify the validation rule to apply to each model property, by
    decorating the property with an adequate validation attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Validation rules are checked automatically when action method parameters are
    instantiated. Both errors and paths in the model (where they occurred) are then
    recorded in a dictionary that is contained in the `ModelState` controller property.
    The developer has the responsibility for verifying whether there are errors by
    checking `ModelState.IsValid`, in which case the developer must return the same
    ViewModel to the same view so that the user can correct any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error messages are automatically shown in the view, with no action required
    from the developer. The developer is only required to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add `span` or `div` with an `asp-validation-for` attribute next to each input
    field, which will be automatically filled with the possible error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `div` with an `asp-validation-summary` attribute that will be automatically
    filled with the validation error summary. See the *Using Razor tag helpers* section
    for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is sufficient to add some JavaScript references by invoking the `_ValidationScriptsPartial.cshtml`
    view with the `partial` tag, enabling the same validation rules on the client
    side so that errors are shown to the user before the form is posted to the server.
    Some predefined validation attributes are contained in the `S stem.ComponentModel.DataAnnotations`
    and `Microsoft.AspNetCore.Mvc` namespaces and include the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Required` attribute requires the user to specify a value for the property
    that it decorates. An implicit `Required` attribute is automatically applied to
    all non-nullable properties, such as all floats, integers, and decimals, since
    they can’t have a `null` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Range` attribute constrains numeric quantities within a range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They also include attributes that constrain string lengths.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error messages can be inserted directly into the attributes, or attributes
    can refer to the property of the resource types containing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer can define their custom attributes by providing the validation
    code, both in C# and in JavaScript for client-side validation. The definition
    of custom validation attributes is discussed in this article: [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/).'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based validation can be replaced by other validation providers, such
    as the **FluentValidation** library that defines validation rules for each type
    using a fluent interface. It is enough to change a provider in a collection contained
    in the MVC options object. This can be configured through an action passed to
    the `builder.Services.AddControllersWithViews` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'MVC options can be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The validation framework automatically checks whether numeric and date inputs
    are well formatted according to the selected culture.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core globalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In multicultural applications, pages must be served according to the language
    and cultural preferences of each user. Typically, multicultural applications can
    serve their content in a few languages, and they can handle dates and numeric
    formats in several more languages. In fact, while the content in all supported
    languages must be produced manually, .NET has the native capability of formatting
    and parsing dates and numbers in all cultures.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a web application might not support unique content for all English-based
    cultures (en), but it might support all known English-based cultures regarding
    number and date formats (en-US, en-GB, en-CA, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The culture used for numbers and dates in a .NET thread is contained in the
    `Thread.CurrentThread.CurrentCulture` property. Hence, by setting this property
    to `new CultureInfo("en-CA")`, numbers and dates will be formatted/parsed according
    to the Canadian format. `Thread.CurrentThread.CurrentUICulture`, instead, decides
    on the culture of the resource files; that is, it selects a culture-specific version
    of each resource file or view. Accordingly, a multicultural application is required
    to set the two cultures associated with the request thread and organize multilingual
    content into language-dependent resource files and/or views.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Separation of Concerns principle, the whole logic used to
    set the request culture according to the user’s preferences is factored out into
    a specific module of the ASP.NET Core pipeline. To configure this module, as a
    first step, we set the supported date/number cultures, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we set the languages supported for the content. Usually, a version of
    the language that is not specific to any country is selected to keep the number
    of translations small enough, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the culture middleware to the pipeline, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the culture requested by the user is explicitly found among the ones listed
    in `supportedCultures` or `supportedUICultures`, it is used without modifications.
    Otherwise, since `FallBackToParentCultures` and `FallBackToParentUICultures` are
    `true`, the parent culture is tried; that is, for instance, if the required `fr-FR`
    culture is not found among those listed, then the framework searches for its generic
    version, `fr`. If this attempt also fails, the framework uses the cultures specified
    in `DefaultRequestCulture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `culture` middleware searches the culture selected for the
    current user, with three providers that are tried in the order shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: The middleware looks for the `culture` and `ui-culture` query string parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the previous step fails, the middleware looks for a cookie named `.AspNetCore.Culture`,
    the value of which is expected to be as in this example: `c=en-US|uic=en`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If both previous steps fail, the middleware looks for the `Accept-Language`
    request header sent by the browser, which can be changed in the browser settings,
    and which is initially set to the operating system culture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the preceding strategy, the first time a user requests an application page,
    the browser culture is taken (the provider listed in *step 3*). Then, if the user
    clicks a language-change link with the right query string parameters, a new culture
    is selected by provider 1\. Usually, once a language link has been clicked, the
    server also generates a language cookie to remember the user’s choice through
    provider 2.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to provide content localization is to provide a different view
    for each language. Hence, if we would like to localize the `Home.cshtml` view
    for different languages, we must provide views named `Home.en.cshtml`, `Home.es.cshtml`,
    and so on. If no view specific to the `ui-culture` thread is found, the non-localized
    `Home.cshtml` version of the view is chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'View localization must be enabled by calling the `AddViewLocalization` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to store simple strings or HTML fragments in resource files
    specific to all supported languages. The usage of resource files must be enabled
    by calling the `AddLocalization` method in the configure services section, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`ResourcesPath` is the root folder where all resource files will be placed.
    If it is not specified, an empty string is assumed, and the resource files will
    be placed in the web application root. Resource files for a specific view (say,
    the `/Views/Home/Index.cshtml` view) must have a path like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Hence, if `ResourcesPath` is empty, resources must have the `/Views/Home/Index.<culture
    name>.resx` path; that is, they must be placed in the same folder as the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the key-value pairs for all the resource files associated with a view
    have been added, localized HTML fragments can be added to the view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inject `IViewLocalizer` into the view with `@inject IViewLocalizer Localizer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where needed, replace the text in the `View` with access to the `Localizer`
    dictionary, such as `Localizer`[“`myKey`”], where “`myKey`” is a key used in the
    resource files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows an example of the `IViewLocalizer` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If localization fails because the key is not found in the resource file, the
    key itself is returned. Strings used in data annotation, such as validation attributes,
    are used as keys in resource files if data annotation localization is enabled,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Resource files for data annotations applied to a class whose full name is,
    say, `MyWebApplication.ViewModels.Account.RegisterViewModel` must have the following
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: It is worth pointing out that the first segment of the namespace that corresponds
    to the `.dll` application name is replaced with `ResourcesPath`. If `ResourcesPath`
    is empty and you use the default namespaces created by Visual Studio, then the
    resource files must be placed in the same folder that contains the classes they
    are associated with.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to localize strings and HTML fragments in controllers, or wherever
    dependencies can be injected, by associating each group of resource files with
    a type, such as `MyType`, and then injecting either `IHtmlLocalizer<MyType>` for
    HTML fragments or `IStringLocalizer<MyType>` for strings that need to be HTML-encoded.
  prefs: []
  type: TYPE_NORMAL
- en: Their usage is identical to the usage of `IViewLocalizer`. The path of the resource
    files associated with `MyType` is computed, as in the case of data annotations.
    If you would like to use a unique group of resource files for the whole application,
    a common choice is to use the `Startup` class as the reference type (`IStringLocalizer<Startup>`
    and `IHtmlLocalizer<Startup>`). Another common choice is to create various empty
    classes to use as reference types for various groups of resource files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve learned how to manage globalization in our ASP.NET Core projects,
    in the next subsection, we will describe the more important pattern used by ASP.NET
    Core MVC to enforce a *separation of concerns*: the MVC pattern itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVC is a pattern used to implement the presentation layers of a web application.
    The basic idea is to apply a *Separation of Concerns* between the logic of the
    presentation layer and its graphics. Logic is taken care of by controllers, while
    graphics are factored out into views. Controllers and views communicate through
    the model, which is often called the ViewModel to distinguish it from the models
    of the business and data layers.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that the original definition of the MVC pattern proposes
    directly the use of domain models instead of ViewModels, but then, most of the
    MVC web frameworks started using the concept of ViewModel because specifying the
    information to render in a view requires just a projection of the original domain
    model (just some model data possibly organized in a different way) and often additional
    data, such as, for instance, the items per page of a pager, and the items required
    by the type input selected.
  prefs: []
  type: TYPE_NORMAL
- en: However, what is the logic of a presentation layer? In *Chapter 1*, *Understanding
    the Importance of Software Architecture*, we saw that software requirements can
    be documented with use cases that describe the interaction between the user and
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Roughly speaking, the logic of the presentation layer consists of the management
    of use cases; hence, roughly, use cases are mapped to controllers, and every single
    operation of a use case is mapped to an action method of those controllers. Hence,
    controllers take care of managing the protocol of interaction with the user and
    rely on the business layer for any business processing involved during each operation.
  prefs: []
  type: TYPE_NORMAL
- en: Each action method receives data from the user, performs some business processing,
    and, depending on the results of this processing, decides what to show to the
    user and encodes it in the ViewModel. Views receive ViewModels that describe what
    to show to the user and decide the graphics to use, that is, the HTML to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the advantages of separating the logic and user interface into two
    different components? The main advantages are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in graphics do not affect the remainder of the code, so you can experiment
    with various user interface elements to optimize the interaction with the user,
    without putting the reliability of the remainder of the code at risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application can be tested by instantiating controllers and passing the parameters,
    with no need to use testing tools that operate on the browser pages. In this way,
    tests are easier to implement. Moreover, they do not depend on the way graphics
    are implemented, so they do not need to be updated each time the graphics change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to split the job between developers who implement controllers and
    graphic designers who implement views. Often, graphic designers have difficulties
    with Razor, so they might just furnish an example HTML page that developers transform
    into Razor views that operate on the actual data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an example of how to put into practice the general principles discussed
    above, please refer to the *A frontend microservice* section in *Chapter 21*,
    *Case Study*, but it is better to read *Chapter 18*, *Implementing Frontend Microservices
    with ASP.NET Core*, beforehand. There, we’ll look at how to create a frontend
    microservice with ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we analyzed the ASP.NET Core pipeline and various modules that
    comprise an ASP.NET Core MVC application in detail, such as authentication/authorization,
    the options framework, and routing. Then, we described how controllers and Views
    map requests to the response HTML. We also analyzed all the improvements introduced
    in the latest versions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we analyzed all the design patterns implemented in the ASP.NET Core
    MVC framework and, in particular, the importance of the Separation of Concerns
    principle and how ASP.NET Core MVC implements it in the ASP.NET Core pipeline,
    as well as in its validation and globalization modules. We focused in more detail
    on the importance of a Separation of Concerns between the presentation layer logic
    and graphics, as well as how the MVC pattern ensures it.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a full example of how to use ASP.NET Core MVC in the next chapter,
    which deals with frontend microservices and describes a complete frontend microservice,
    whose presentation layer uses ASP.NET Core MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET
    Core project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does the ASP.NET Core pipeline module need to inherit from a base class or implement
    some interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that a tag must have just one tag helper defined for it, as, otherwise,
    an exception is thrown?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you remember how to test if validation errors have occurred in a controller?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the instruction in a layout view for including the output of the main
    view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are secondary sections of the main view invoked in a layout view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a controller invoke a view?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, how many providers are installed in the globalization module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are ViewModels the only way for controllers to communicate with their invoked
    views?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More details on the ASP.NET Core and ASP.NET Core MVC framework are available
    in its official documentation at [https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the Razor syntax can be found at [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?tabs=visual-studio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to model bind collections and dictionaries is explained in this excellent
    Phil Haack post: [http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx](http://haacked.com/archive/2008/10/23/model-binding-to-a-list.aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation of custom tag helpers that were not discussed
    in this chapter can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the creation of custom controller attributes can be found at
    [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The definition of custom validation attributes is discussed in this article:
    [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code175081751210902046.png)'
  prefs: []
  type: TYPE_IMG
