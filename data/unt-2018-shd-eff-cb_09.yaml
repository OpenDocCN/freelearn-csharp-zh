- en: Screen Effects with Unity Render Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity渲染纹理的屏幕效果
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下食谱：
- en: Setting up the screen effects script system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置屏幕效果脚本系统
- en: Using brightness, saturation, and contrast with screen effects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用亮度、饱和度和对比度与屏幕效果
- en: Using basic Photoshop-like Blend modes with screen effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似Photoshop的基本混合模式与屏幕效果
- en: Using the Overlay Blend mode with screen effects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用叠加混合模式与屏幕效果
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most impressive aspects of learning to write shaders is the process
    of creating your own screen effects, also known as post effects. With these screen
    effects, we can create stunning real-time images with Bloom, Motion Blur, HDR
    effects, and so on. Most modern games on the market today make heavy use of these
    screen effects for their depth of field effects, Bloom effects, and even color
    correction effects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编写着色器最令人印象深刻的一面是创建自己的屏幕效果的过程，也称为后期效果。有了这些屏幕效果，我们可以通过泛光、运动模糊、HDR效果等创建令人惊叹的实时图像。如今市场上大多数现代游戏都大量使用这些屏幕效果来实现景深效果、泛光效果，甚至色彩校正效果。
- en: In [Chapter 1](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08), *Post
    Processing Stack*, we discussed how to use this with Unity's built-in Post Processing
    Stack, but in this chapter, you will learn how to build up the script system yourself.
    This system will give you the control to create many kinds of screen effects.
    We will cover `RenderTexture`, what the depth buffer is, and how to create effects
    that give you Photoshop-like control over the final rendered image of your game.
    By utilizing screen effects for your games, you not only round out your shader
    writing knowledge, but you will also have the power to create your own incredible
    real-time renders with Unity from scratch.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](part0026.html#OPEK0-e8c76c858d514bc3b1668fda96f8fa08)“后期处理堆栈”中，我们讨论了如何使用Unity内置的后期处理堆栈，但在这章中，你将学习如何自己构建脚本系统。这个系统将赋予你创建许多种屏幕效果的控件。我们将涵盖`RenderTexture`、深度缓冲区是什么，以及如何创建能够让你对游戏最终渲染图像有类似Photoshop控制效果的方法。通过为你的游戏利用屏幕效果，你不仅完善了你的着色器编写知识，而且还将拥有从零开始使用Unity创建自己令人难以置信的实时渲染的能力。
- en: Setting up the screen effects script system
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置屏幕效果脚本系统
- en: The process of creating screen effects is one in which we grab a full-screen
    image (or texture), use a shader to process its pixels on the GPU, and then send
    it back to Unity's renderer to apply it to the whole rendered image of the game.
    This allows us to perform per-pixel operations on the rendered image of the game
    in real time, giving us a more global artistic control.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建屏幕效果的过程是我们抓取全屏图像（或纹理），使用着色器在GPU上处理其像素，然后将它发送回Unity的渲染器以应用于整个游戏的渲染图像。这使我们能够在实时中对游戏的渲染图像进行逐像素操作，从而给我们提供更全局的艺术控制。
- en: Imagine if you had to go through and adjust each material on each object in
    your game to just adjust the contrast of the final look of your game. While not
    impossible, this would take a bit of labor to perform. By utilizing a screen effect,
    we can adjust the screen's final look as a whole, thereby giving us more Photoshop-like
    control over our game's final appearance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你必须逐个调整游戏中每个对象的材质，仅仅调整游戏最终外观的对比度。虽然不是不可能，但这需要一些劳动来完成。通过利用屏幕效果，我们可以整体调整屏幕的最终外观，从而让我们对游戏最终外观有更多的类似Photoshop的控制。
- en: In order to get a screen effect system up and running, we have to set up a single
    script to act as the courier of the game's current rendered image, or what Unity
    calls the `RenderTexture`. By utilizing this script to pass the `RenderTexture`
    to a shader, we can create a flexible system for establishing screen effects.
    For our first screen effect, we are going to create a very simple grayscale effect
    and make our game look black and white. Let's take a look at how this is done.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让屏幕效果系统运行起来，我们必须设置一个单独的脚本来作为游戏当前渲染图像的使者，或者Unity所说的`RenderTexture`。通过利用这个脚本将`RenderTexture`传递给着色器，我们可以创建一个灵活的系统来建立屏幕效果。对于我们的第一个屏幕效果，我们将创建一个非常简单的灰度效果，使我们的游戏看起来是黑白的。让我们看看这是如何实现的。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to get our screen effects system up and running, we need to create
    a few assets for our current Unity project. By doing this, we will set ourselves
    up for the steps in the following sections:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的屏幕效果系统运行起来，我们需要为我们的当前Unity项目创建一些资产。通过这样做，我们将为以下章节中的步骤做好准备：
- en: In the current project, create a new scene to work in.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前项目中创建一个新的场景来工作。
- en: Create a simple sphere in the scene and assign it a new material (I called mine `RedMat`). This
    new material can be anything, but for our example, we will make a simple red material
    using the Standard Shader.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个简单的球体，并为其分配一个新的材质（我称之为`RedMat`）。这个新材质可以是任何东西，但为了我们的示例，我们将使用Standard
    Shader创建一个简单的红色材质。
- en: Finally, create a new directional light and save the scene.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个新的方向光并保存场景。
- en: We need to create a new C# script and call it `TestRenderImage.cs`. For organization
    purposes, create a folder called `Scripts` from the Project tab to put it in.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的C#脚本并命名为`TestRenderImage.cs`。为了组织目的，从项目选项卡创建一个名为`Scripts`的文件夹来放置它。
- en: 'With all of our assets ready, you should have a simple scene setup, which looks
    similar to the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有资产准备就绪后，你应该有一个简单的场景设置，看起来类似于以下截图：
- en: '![](img/00182.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00182.jpeg)'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to make our grayscale screen effect work, we need a script and shader.
    So, we will complete these two new items here and fill them in with the appropriate
    code to produce our first screen effect. Our first task is to complete the C#
    script. This will get the whole system running. After this, we will complete the
    shader and see the results of our screen effect. Let''s complete our script and
    shader with the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的灰度屏幕效果工作，我们需要一个脚本和着色器。因此，我们将在这里完成这两个新项目，并填充适当的代码以产生我们的第一个屏幕效果。我们的第一个任务是完成C#脚本。这将使整个系统运行。在此之后，我们将完成着色器并查看屏幕效果的结果。让我们按照以下步骤完成我们的脚本和着色器：
- en: 'Open the `TestRenderImage.cs` C# script and begin by entering a few variables
    that we will need to store important objects and data. Enter the following code
    at the very top of the `TestRenderImage` class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TestRenderImage.cs` C#脚本，首先输入一些我们将需要存储重要对象和数据的变量。在`TestRenderImage`类的顶部输入以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order for us to edit the screen effect in real time, when the Unity editor
    isn''t playing, we need to enter the following line of code just above the declaration
    of the `TestRenderImage` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们能够实时编辑屏幕效果，当Unity编辑器没有播放时，我们需要在`TestRenderImage`类的声明上方输入以下代码行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As our screen effect is using a shader to perform the pixel operations on our
    screen image, we have to create a material to run the shader. Without this, we
    can''t access the properties of the shader. For this, we will create a C# property
    to check for a material, and create one if it doesn''t find one. Enter the following
    code just after the declaration of the variables from *step 1*:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的屏幕效果正在使用着色器在我们的屏幕图像上执行像素操作，我们必须创建一个材质来运行着色器。没有这个，我们无法访问着色器的属性。为此，我们将创建一个C#属性来检查材质，并在找不到时创建一个。在*步骤1*的变量声明之后输入以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now want to set up some checks in our script to see if the current target
    platform that we are building the Unity game on actually supports image effects.
    If it doesn''t find anything at the start of this script, then the script will
    disable itself:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想在脚本中设置一些检查，以查看我们正在构建Unity游戏的当前目标平台是否实际上支持图像效果。如果脚本开始时找不到任何东西，那么脚本将禁用自己：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To actually grab the rendered image from the Unity renderer, we need to make
    use of the following built-in function that Unity provides us, called `OnRenderImage()`.
    Enter the following code so that we can have access to the current `RenderTexture`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从Unity渲染器实际获取渲染的图像，我们需要使用Unity为我们提供的以下内置函数，称为`OnRenderImage()`。输入以下代码以便我们可以访问当前的`RenderTexture`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our screen effect has a variable called `grayScaleAmount` with which we can
    control how much grayscale we want for our final screen effect. So, in this case,
    we need to make the value go from `0` to `1`, where `0` is no grayscale effect
    and `1` is a full grayscale effect. We will perform this operation in the `Update()`
    function, which will be called every frame while the game is running:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的屏幕效果有一个名为`grayScaleAmount`的变量，我们可以用它来控制我们想要的最终屏幕效果的灰度程度。因此，在这种情况下，我们需要将值从`0`变为`1`，其中`0`表示没有灰度效果，而`1`表示全灰度效果。我们将在`Update()`函数中执行此操作，该函数将在游戏运行时每帧被调用：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we complete our script by doing a little bit of clean-up on objects
    we created when the script started:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过在脚本开始时创建的对象上进行一些清理来完成我们的脚本：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this point, we can now apply this script to the camera, if it compiled without
    errors, in Unity. Let's apply the `TestRenderImage.cs` script to our main camera
    in our scene. You should see the `grayScaleAmount` value and a field for a shader,
    but the script throws an error to the console window. It says that it is missing
    an instance to an object and so won't process appropriately. If you recall from
    *step 4*, we are doing some checks to see whether we have a shader and if the
    current platform supports the shader. As we haven't given the screen effect script
    a shader to work with, then the `curShader` variable is just null, which throws
    an error. Let's continue with our screen effects system by completing the shader.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以在 Unity 中将此脚本应用于相机，如果它没有错误地编译，让我们将 `TestRenderImage.cs` 脚本应用到场景中的主相机上。你应该看到
    `grayScaleAmount` 值和一个着色器字段，但脚本在控制台窗口中抛出一个错误。它说缺少一个对象实例，因此无法适当地处理。如果你还记得 *步骤 4*，我们正在做一些检查，看看我们是否有着色器以及当前平台是否支持着色器。因为我们没有给屏幕效果脚本提供一个着色器来工作，所以
    `curShader` 变量只是 null，这会抛出一个错误。让我们通过完成着色器来继续我们的屏幕效果系统。
- en: 'Create a new shader called `ScreenGrayscale`. To begin our shader, we will
    populate our `Properties` with some variables so that we can send data to this
    shader:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器，命名为 `ScreenGrayscale`。为了开始我们的着色器，我们将用一些变量填充我们的 `Properties`，这样我们就可以将数据发送到这个着色器：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our shader is now going to utilize pure CG shader code instead of utilizing
    Unity''s built-in Surface Shader code. This will make our screen effect more optimized
    as we need to work only with the pixels of the `RenderTexture.` So, we will delete
    everything inside of the `Pass` that was there before and create a new `Pass`
    block in our shader and fill it with some new `#pragma` statements that we haven''t
    seen before:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在的着色器将利用纯 CG 着色器代码，而不是使用 Unity 内置的 Surface Shader 代码。这将使我们的屏幕效果更加优化，因为我们只需要处理
    `RenderTexture` 的像素。因此，我们将删除 `Pass` 中之前的所有内容，并在我们的着色器中创建一个新的 `Pass` 块，并用一些我们之前未见过的新的
    `#pragma` 语句填充它：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order to access the data being sent to the shader from the Unity editor,
    we need to create the corresponding variables in our `CGPROGRAM`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了访问从 Unity 编辑器发送到着色器的数据，我们需要在我们的 `CGPROGRAM` 中创建相应的变量：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, all we need to do is set up our pixel function, in this case called
    `frag()`. This is where the meat of the screen effect is. This function will process
    each pixel of the `RenderTexture` and return a new image to our `TestRenderImage.cs`
    script:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要设置我们的像素函数，在这个例子中称为 `frag()`。这是屏幕效果的核心所在。这个函数将处理 `RenderTexture` 的每个像素，并将新的图像返回到
    `TestRenderImage.cs` 脚本：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, change the `FallBack` line to the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `FallBack` 行更改为以下内容：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The final shader should look as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的着色器应如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the shader is complete, return to Unity and let it compile to see if any
    errors occurred. If not, assign the new shader to the `TestRenderImage.cs` script
    and change the value of the grayscale amount variable. You should see the game
    view go from a colored version of the game to a grayscale version of the game:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦着色器完成，返回 Unity 并让它编译以查看是否发生了错误。如果没有错误，将新的着色器分配给 `TestRenderImage.cs` 脚本并更改灰度量变量的值。你应该看到游戏视图从彩色游戏版本变为灰度游戏版本：
- en: '![](img/00183.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00183.jpeg)'
- en: 'The following screenshot demonstrates this Screen Effect:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了此屏幕效果：
- en: '![](img/00184.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00184.jpeg)'
- en: With this complete, we now have an easy way to test out new screen effect shaders
    without having to write our whole screen effect system over and over again. Let's
    dive in a little deeper and learn about what's going on with the `RenderTexture`
    and how it is processed throughout its existence.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们现在有一个简单的方法来测试新的屏幕效果着色器，而无需反复编写整个屏幕效果系统。让我们深入了解，了解 `RenderTexture` 在其存在过程中是如何处理的。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To get a screen effect up and running inside of Unity, we need to create a script
    and shader. The script drives the real-time update in the editor and is also responsible
    for capturing the `RenderTexture` from the main camera and passing it to the shader.
    Once the `RenderTexture` gets to the shader, we can use the shader to perform
    per-pixel operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Unity 中实现屏幕效果，我们需要创建一个脚本和着色器。脚本驱动编辑器中的实时更新，并负责从主相机捕获 `RenderTexture` 并传递给着色器。一旦
    `RenderTexture` 到达着色器，我们就可以使用着色器执行逐像素操作。
- en: At the start of the script, we perform a few checks to make sure that the current
    selected build platform actually supports screen effects and the shader itself.
    There are instances where a current platform will not support screen effects or
    the shader that we are using. So, the checks that we do in the `Start()` function
    ensure we don't get any errors if the platform doesn't support the screen system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本开始时，我们执行一些检查以确保当前选定的构建平台实际上支持屏幕效果以及着色器本身。有些情况下，当前平台可能不支持屏幕效果或我们使用的着色器。因此，我们在
    `Start()` 函数中进行的检查确保如果平台不支持屏幕系统，我们不会遇到任何错误。
- en: 'Once the script passes these checks, we initiate the screen effects system
    by calling the built-in `OnRenderImage()` function. This function is responsible
    for grabbing the `renderTexture`, giving it to the shader using the `Graphics.Blit()`
    function, and returning the processed image to the Unity renderer. You can find
    more information on these two functions at the following URLs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本通过这些检查，我们就通过调用内置的 `OnRenderImage()` 函数来初始化屏幕效果系统。这个函数负责获取 `renderTexture`，使用
    `Graphics.Blit()` 函数将其传递给着色器，并将处理后的图像返回给 Unity 渲染器。你可以在以下网址找到有关这两个函数的更多信息：
- en: '`OnRenderImage`: [http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnRenderImage`: [http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnRenderImage.html)'
- en: '`Graphics.Blit`:[http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html](http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Graphics.Blit`:[http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html](http://docs.unity3d.com/Documentation/ScriptReference/Graphics.Blit.html)'
- en: Once the current `RenderTexture` reaches the shader, the shader takes it, processes
    it through the `frag()` function, and returns the final color for each pixel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前的 `RenderTexture` 达到着色器时，着色器将其获取，通过 `frag()` 函数进行处理，并为每个像素返回最终颜色。
- en: You can see how powerful this becomes as it gives us Photoshop-like control
    over the final rendered image of our game. These screen effects work sequentially
    like Photoshop layers on top of what the camera sees. When you place these screen
    effects one after the other, they will be processed in that order. These are just
    the bare bones steps to get a screen effect working, but it is the core of how
    the screen effects system works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这有多么强大，因为它让我们对游戏最终渲染图像有了类似 Photoshop 的控制。这些屏幕效果像 Photoshop 层一样按顺序工作，覆盖在摄像机所看到的内容之上。当你一个接一个地放置这些屏幕效果时，它们将按此顺序进行处理。这些只是让屏幕效果工作起来的基本步骤，但这是屏幕效果系统工作的核心。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Now that we have our simple screen effect system up and running, let''s take
    a look at some of the other useful information we can obtain from Unity''s renderer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个简单的屏幕效果系统正在运行，让我们看看我们可以从 Unity 的渲染器中获得的一些其他有用信息：
- en: '![](img/00185.gif)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00185.gif)'
- en: 'We can actually get the depth of everything in our current game by turning
    on Unity''s built-in Depth mode. Once this is turned on, we can use the depth
    information for a ton of different effects. Let''s take a look at how this is
    done:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以通过打开 Unity 的内置深度模式来获取我们当前游戏中所有事物的深度。一旦打开，我们就可以使用深度信息来实现大量不同的效果。让我们看看如何实现这一点：
- en: 'Duplicate the sphere we created twice and create a plane underneath:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的球体复制两次，并在下面创建一个平面：
- en: '![](img/00186.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00186.jpeg)'
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    and pressing *Ctrl *+ *D*. Once duplicated, rename the script to `SceneDepth`.
    Then double-click on this shader to open it in your script editor.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 `ScreenGreyscale` 代码并按 *Ctrl *+ *D* 复制来创建一个新的着色器。一旦复制，将脚本重命名为 `SceneDepth`。然后双击此着色器以在脚本编辑器中打开它。
- en: 'We will create the main texture (`_MainTex`) property and a property to control
    the power of the scene depth effect. Enter the following code in your shader:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建主纹理 (`_MainTex`) 属性和一个用于控制场景深度效果强度的属性。在你的着色器中输入以下代码：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to create the corresponding variables in our `CGPROGRAM`. We are
    going to add one more variable called `_CameraDepthTexture`. This is a built-in
    variable that Unity has provided us with through the use of the `UnityCG.cginclude`
    file. It gives us the depth information from the camera:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在我们的 `CGPROGRAM` 中创建相应的变量。我们将添加一个名为 `_CameraDepthTexture` 的额外变量。这是一个内置变量，Unity
    通过使用 `UnityCG.cginclude` 文件提供给我们。它为我们提供了来自摄像机的深度信息：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will complete our depth shader by utilizing a couple of built-in functions
    that Unity provides us with, the `UNITY_SAMPLE_DEPTH()` and `linear01Depth()`
    functions. The first function actually gets the depth information from our `_CameraDepthTexture`
    and produces a single float value for each pixel. The `Linear01Depth()` function
    then makes sure that the values are within the `0`-`1` range by taking this final
    depth value to a power we can control, where the mid-value in the `0`-`1` range
    sits in the scene based off of the camera position:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过利用Unity为我们提供的几个内置函数来完成我们的深度着色器，这些函数是`UNITY_SAMPLE_DEPTH()`和`linear01Depth()`。第一个函数实际上从我们的`_CameraDepthTexture`中获取深度信息，并为每个像素生成一个单独的浮点值。然后`Linear01Depth()`函数确保这些值在`0`-`1`范围内，通过将最终的深度值取到我们可以控制的幂，其中`0`-`1`范围内的中值基于相机位置位于场景中：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With our shader complete, let's turn our attention to the Unity editor and create
    a new script to work with. Select our `TestRenderImage` script and duplicate it.
    Name this new script `RenderDepth` and open it up in your script editor.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的着色器完成后，让我们将注意力转向Unity编辑器，并创建一个新的脚本以与之配合。选择我们的`TestRenderImage`脚本并复制它。将这个新脚本命名为`RenderDepth`并在脚本编辑器中打开它。
- en: 'Update the script to have the same class name as we renamed it to in the previous
    step (`RenderDepth`):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本更新为与我们在上一步中重命名的类名相同（`RenderDepth`）：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to add the `depthPower` variable to the script so that we can let users
    change the value in the editor:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在脚本中添加`depthPower`变量，以便我们可以在编辑器中让用户更改该值：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `OnRenderImage()` function then needs to be updated so that it is passing
    the right value to our shader:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的`OnRenderImage()`函数需要更新，以便它向我们的着色器传递正确的值：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To complete our depth screen effect, we need to tell Unity to turn on the depth
    rendering in the current camera. This is done by simply setting the main camera''s
    `depthTextureMode`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的深度屏幕效果，我们需要告诉Unity在当前相机中开启深度渲染。这可以通过简单地设置主相机的`depthTextureMode`来完成：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With all the code set up, save your script and shader and return to Unity to
    let them both compile. Afterward, select the Main Camera, right-click on the TextRenderImage
    component, and select Remove Component. Afterward, attach this new component to
    the object and drag and drop our new shader inside. If no errors are encountered,
    you should see a result similar to the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好所有代码后，保存你的脚本和着色器，并返回Unity让它们都编译。之后，选择主相机，在TextRenderImage组件上右键单击，并选择移除组件。之后，将这个新组件附加到对象上，并将我们新的着色器拖放到里面。如果没有遇到错误，你应该会看到一个类似于以下截图的结果：
- en: '![](img/00187.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00187.jpeg)'
- en: 'Here''s an example of what we can get if we tweak the values even more:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步调整这些值，我们可以得到以下示例：
- en: '![](img/00188.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00188.gif)'
- en: Using brightness, saturation, and contrast with screen effects
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用亮度、饱和度和对比度与屏幕效果结合
- en: Now that we have our screen effects system up and running, we can explore how
    to create more involved pixel operations to perform some of the more common screen
    effects found in games today.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将屏幕效果系统搭建起来并运行，我们可以探索如何创建更复杂的像素操作来执行游戏中今天常见的某些屏幕效果。
- en: Using a screen effect to adjust the overall final colors of your game is crucial
    in giving artists global control over the final look of the game. Techniques such
    as color adjustment sliders allow users to adjust the intensity of the reds, blues,
    and greens of the final rendered game. This concept is also used with techniques
    such as putting a certain tone of color over the whole screen, as seen in something
    like a sepia film effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用屏幕效果来调整游戏的整体最终颜色对于让艺术家对游戏最终外观拥有全局控制至关重要。例如，颜色调整滑块等技术允许用户调整最终渲染游戏中的红色、蓝色和绿色的强度。这一概念也用于像棕褐色调效果这样的技术，在整个屏幕上覆盖某种色调的颜色。
- en: For this particular recipe, we are going to cover some of the more core color
    adjustment operations we can perform on an image. These are brightness, saturation,
    and contrast. Learning how to code these color adjustments gives us a nice base
    from which we can learn the art of screen effects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的配方，我们将介绍一些我们可以在图像上执行的核心颜色调整操作。这些是亮度、饱和度和对比度。学习如何编写这些颜色调整代码为我们提供了一个很好的基础，我们可以从中学习屏幕效果的艺术。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need to create a couple of new assets. We can utilize the same scene
    as our test scene, but we will need a new script and shader:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一些新的资产。我们可以利用与我们的测试场景相同的场景，但我们需要一个新的脚本和着色器：
- en: Create a new scene by going to File | New Scene.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问文件 | 新场景来创建一个新的场景。
- en: 'Add a couple of new objects to the scene, set up some different colored diffuse
    materials, and randomly assign them to the new objects in the scene. This will
    give us a good range of colors to test with our new screen effect:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中添加几个新对象，设置一些不同颜色的漫反射材质，并将它们随机分配给场景中的新对象。这将为我们提供良好的颜色范围来测试我们的新屏幕效果：
- en: '![](img/00189.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00189.jpeg)'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now that we have completed our scene setup and created our new script and shader,
    we can begin to fill in the code necessary to achieve the brightness, saturation,
    and contrast screen effects. We will be focusing on just the pixel operation and
    variable setup for our script and shader, since getting a screen effect system
    up and running is described in the *Setting up the screen effects script system*
    recipe in this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了场景设置并创建了新的脚本和着色器，我们可以开始填写实现亮度、饱和度和对比度屏幕效果的必要代码。我们将专注于脚本和着色器的像素操作和变量设置，因为在本章的*设置屏幕效果脚本系统*食谱中描述了如何设置屏幕效果系统：
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl*
    + *D*. Once duplicated, rename the script to `ScreenBSC`. Then double-click on
    this shader to open it in your script editor.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从项目标签下的`第9章`|`着色器`文件夹中选择`ScreenGreyscale`代码并按*Ctrl* + *D*来复制一个新的着色器。一旦复制，将脚本重命名为`ScreenBSC`。然后双击此着色器以在脚本编辑器中打开它。
- en: 'Editing the shader first makes more sense so that we know what kind of variables
    we will need for our C# script. Let''s begin by entering the appropriate properties
    for our brightness, saturation, and contrast effect. Remember that we need to
    keep the `_MainTex` property in our shader as this is the property that the `RenderTexture`
    targets when creating screen effects:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先编辑着色器更有意义，这样我们就会知道我们的C#脚本需要哪些变量。让我们先输入亮度、饱和度和对比度效果的适当属性。记住，我们需要在着色器中保留`_MainTex`属性，因为这是`RenderTexture`在创建屏幕效果时指向的属性：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As usual, in order for us to access the data coming in from our properties
    in our `CGPROGRAM`, we need to create the corresponding variables in the `CGPROGRAM`,
    replacing the previous ones:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常一样，为了在我们`CGPROGRAM`中访问来自属性的数据，我们需要在`CGPROGRAM`中创建相应的变量，替换之前的变量：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to create the operations that will perform the brightness, saturation,
    and contrast effects. Enter the following new function in our shader, just above
    the `frag()` function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建执行亮度、饱和度和对比度效果的运算。在我们的着色器中，在`frag()`函数之上输入以下新函数：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don't worry if it doesn't make sense just yet; all the code will be explained
    in the *How it works* section of this recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在还不明白也没有关系；所有代码将在本食谱的*工作原理*部分进行解释。
- en: 'Finally, we just need to update our `frag()` function to actually use the `ContrastSaturationBrightness()`
    function. This will process all the pixels of our `RenderTexture` and pass it
    back to our script:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需更新我们的`frag()`函数以实际使用`ContrastSaturationBrightness()`函数。这将处理我们的`RenderTexture`的所有像素，并将其传递回我们的脚本：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the code entered in the shader, return to the Unity editor to let the
    new shader compile. If there are no errors, we can return to our code editor to
    work on our script. Let''s begin by creating a couple of new lines of code that
    will send the proper data to our shader:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中输入代码后，返回Unity编辑器以让新着色器编译。如果没有错误，我们可以返回代码编辑器来工作。让我们开始创建一些新的代码行，将适当的数据发送到我们的着色器：
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 9 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBSC`. Once renamed, double-click
    on it to enter your IDE of choice.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在着色器已经完成，让我们开始编写使效果显示所需的脚本。从项目标签，转到`第9章`|`脚本`文件夹。一旦到达那里，选择`TestRenderImage`脚本并按*Ctrl*
    + *D*进行复制。将新创建的脚本重命名为`RenderBSC`。一旦重命名，双击它以进入您选择的IDE。
- en: 'To modify our script, we need to rename the class to match our filename, `RenderBSC`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要修改我们的脚本，我们需要将类名重命名为与我们的文件名匹配，即`RenderBSC`：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Afterward, we need to add the proper variables that will drive the values of
    our screen effect. In this case, we will need a slider for brightness, a slider
    for saturation, and a slider for contrast:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要添加驱动屏幕效果值的正确变量。在这种情况下，我们需要一个亮度滑块、一个饱和度滑块和一个对比度滑块：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With our variables set up, we now need to tell the script to send the values
    of the variables we created to the shader. We do this in the `OnRenderImage()`
    function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好我们的变量后，我们现在需要告诉脚本将我们创建的变量的值发送到着色器。我们在`OnRenderImage()`函数中这样做：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, all we need to do is clamp the values of the variables within a range
    that is reasonable. These clamp values are entirely preferential, so you can use
    whichever values you see fit:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要将变量的值限制在合理的范围内。这些钳位值完全是主观的，所以你可以使用你认为合适的任何值：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the script completed and shader finished, we simply assign our script
    to our Main Camera and our shader to the script, and you should see the effects
    of brightness, saturation, and contrast by manipulating the property values:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本完成和着色器完成后，我们只需将我们的脚本分配给我们的主相机，将着色器分配给脚本，你应该会看到通过操作属性值实现的亮度、饱和度和对比度效果：
- en: '![](img/00190.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00190.jpeg)'
- en: 'The following screenshot shows a result you can achieve with this screen effect:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用此屏幕效果可以实现的结果：
- en: '![](img/00191.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00191.jpeg)'
- en: 'The following screenshot shows another example of what can be done by adjusting
    the colors of the render image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了通过调整渲染图像的颜色可以实现的另一个示例：
- en: '![](img/00192.gif)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00192.gif)'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we now know how the basic screen effects system works, let's just cover
    the per-pixel operations we created in the `ContrastSaturationBrightness()` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了基本屏幕效果系统的工作原理，那么我们就来了解一下在`ContrastSaturationBrightness()`函数中创建的逐像素操作。
- en: The function starts by taking a few arguments. The first and most important
    is the current `RenderTexture`. The other arguments simply adjust the overall
    effect of the screen effect and are represented by sliders in the screen effect's Inspector
    tab. Once the function receives the `RenderTexture` and the adjustment values,
    it declares a few constant values that we use to modify and compare against the
    original `RenderTexture`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先接受几个参数。第一个也是最重要的参数是当前的`RenderTexture`。其他参数只是简单地调整屏幕效果的整体效果，并在屏幕效果的“检查器”标签页中以滑块的形式表示。一旦函数接收到`RenderTexture`和调整值，它就会声明一些常量值，我们使用这些值来修改并与原始的`RenderTexture`进行比较。
- en: The `luminanceCoeff` variable stores the values that will give us the overall
    brightness of the current image. These coefficients are based on the CIE color
    matching functions and are pretty standard throughout the industry. We can find
    the overall brightness of the image by getting the dot product of the current
    image dotted with these luminance coefficients. Once we have the brightness, we
    simply use a couple of `lerp` functions to blend the grayscale version of the
    brightness operation and the original image, multiplied by the brightness value
    being passed into the function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`luminanceCoeff`变量存储了将给我们提供当前图像整体亮度的值。这些系数基于CIE颜色匹配函数，并且在整个行业中相当标准化。我们可以通过获取当前图像与这些亮度系数的点积来找到图像的整体亮度。一旦我们有了亮度，我们只需使用几个`lerp`函数来混合亮度操作的灰度版本和原始图像，乘以传递给函数的亮度值。'
- en: Screen effects such as this are crucial to achieving high-quality graphics for
    your games as they let you tweak the final look of your game without you having
    to edit each material in your current game scene.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的屏幕效果对于实现你游戏中高质量的图形至关重要，因为它们让你可以调整游戏最终的外观，而无需编辑当前游戏场景中的每个材质。
- en: Using basic Photoshop-like Blend modes with screen effects
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基本的Photoshop-like混合模式与屏幕效果
- en: The screen effects aren't just limited to adjusting the colors of a rendered
    image from our game. We can also use them to combine other images with our `RenderTexture`.
    This technique is no different than creating a new layer in Photoshop and choosing
    a Blend mode to blend two images together or, in our case, a texture with a `RenderTexture`.
    This becomes a very powerful technique as it gives the artists in a production
    environment a way to simulate their blending modes in the game rather than just
    in Photoshop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕效果不仅限于调整我们游戏中渲染图像的颜色。我们还可以使用它们将其他图像与我们的`RenderTexture`结合。这种技术与在Photoshop中创建一个新图层并选择混合模式来混合两个图像或，在我们的情况下，一个纹理与`RenderTexture`没有区别。这成为了一种非常强大的技术，因为它为制作环境中的艺术家提供了一种在游戏中模拟他们的混合模式的方法，而不仅仅是Photoshop中。
- en: For this particular recipe, we are going to take a look at some of the more
    common blend modes, such as Multiply, Add, and Overlay. You will see how simple
    it is to have the power of Photoshop Blend modes in your game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的菜谱，我们将查看一些更常见的混合模式，例如乘法、加法和叠加。您将看到在游戏中拥有Photoshop混合模式的力量是多么简单。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To begin, we have to get our assets ready. So let''s follow the next few steps
    to get our screen effects system up and running for our new Blend mode screen
    effect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须准备好我们的资产。所以让我们遵循接下来的几个步骤，为我们的新混合模式屏幕效果启动屏幕效果系统：
- en: We will need another texture to perform our Blend mode effect. In this recipe,
    we will use a grunge-type texture. This will make the effect very obvious when
    we are testing it out.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要另一个纹理来执行我们的混合模式效果。在这个菜谱中，我们将使用一种磨损类型的纹理。这将使我们在测试时效果非常明显。
- en: 'The following screenshot is the grunge map used in the making of this effect.
    Finding a texture with enough detail and a nice range of grayscale values will
    make for a nice texture to test our new effect:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图是制作此效果时使用的磨损纹理。找到一个具有足够细节和良好灰度值范围的纹理将使我们的新效果测试变得很棒：
- en: '![](img/00193.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00193.jpeg)'
- en: The preceding texture is available in the example code for this book in `Chapter
    9 `| `Textures` folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的纹理可以在本书的示例代码中找到，位于`第9章`|`纹理`文件夹中。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The first Blend mode that we will implement is the Multiply blend mode as seen
    in Photoshop. Let''s begin by modifying the code in our shader first:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的第一种混合模式是Photoshop中看到的乘法混合模式。让我们首先修改我们的着色器中的代码：
- en: Create a new shader by duplicating the `ScreenGreyscale` code by selecting it
    from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing *Ctrl *+
    *D.* Once duplicated, rename the script to `ScreenBlendMode`. Then, double-click
    on this shader to open it in your script editor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`第9章`|`着色器`文件夹下从项目标签中选择`ScreenGreyscale`代码并按*Ctrl* + *D*来复制它，创建一个新的着色器。一旦复制，将脚本重命名为`ScreenBlendMode`。然后，双击此着色器以在脚本编辑器中打开它。
- en: 'We need to add some new properties so that we have a texture to blend with
    and a slider for an opacity value. Enter the following code in your new shader:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加一些新属性，以便我们有一个可以混合的纹理和一个滑块来调整我们想要使用的混合模式的最终数量。在你的新着色器中输入以下代码：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Enter the corresponding variables in our `CGPROGRAM` so that we can access
    the data from our `Properties` block, replacing the previously created variables:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`CGPROGRAM`中输入相应的变量，以便我们可以从我们的`Properties`块访问数据，替换之前创建的变量：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We modify our `frag()` function so that it performs the multiply operation
    on our two textures:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们修改我们的`frag()`函数，以便它对两个纹理执行乘法操作：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save the shader and return to the Unity editor to let the new shader code compile
    and check for errors. If no errors occurred, then we can move on to creating our
    script file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存着色器并返回Unity编辑器，让新的着色器代码编译并检查错误。如果没有发生错误，那么我们可以继续创建我们的脚本文件。
- en: Now that the shader is finished, let's work on the script needed to make the
    effect show up. From the Project tab, go to the `Chapter 09 `| `Scripts` folder.
    Once there, select the `TestRenderImage` script and duplicate it by pressing *Ctrl*
    + *D*. Rename the newly created script to `RenderBlendMode`. Once renamed, double-click
    on it to enter your IDE of choice.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 着色器完成后，让我们开始编写使效果显示所需的脚本。从项目标签中，转到`第09章`|`脚本`文件夹。一旦到达那里，选择`TestRenderImage`脚本并按*Ctrl*
    + *D*复制它。将新创建的脚本重命名为`RenderBlendMode`。一旦重命名，双击它以进入您选择的IDE。
- en: 'Our first step in modifying our script is to rename the class to match our
    filename, `RenderBlendMode`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改我们的脚本的第一步是重命名类以匹配我们的文件名，`RenderBlendMode`：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In our script file, we need to create the corresponding variables. We will
    need a texture so that we can assign one to the shader and a slider to adjust
    the final amount of the Blend mode we want to use:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的脚本文件中，我们需要创建相应的变量。我们需要一个纹理，以便我们可以将其分配给着色器，以及一个滑块来调整我们想要使用的混合模式的最终数量：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then need to send our variable data to the shader through the `OnRenderImage()`
    function:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过`OnRenderImage()`函数将我们的变量数据发送到着色器中：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To complete the script, we simply fill in our `Update()` function so that we
    can clamp the value of the `blendOpacity` variable between a value of `0.0` and
    `1.0`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成脚本，我们只需填写我们的`Update()`函数，以便我们可以将`blendOpacity`变量的值限制在`0.0`和`1.0`之间：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this complete, we assign the screen effect script to our Main Camera (remove
    the previous `Render BSC` script if it is attached) and add our screen effect
    shader to our script so that it has a shader to use for the per-pixel operations.
    In order for the effect to be fully functional, the script and shader look for
    a texture. You can assign any texture to the Texture field in the Inspector for
    the screen effect script. Once this texture is in place, you will see the effect
    of multiplying this texture over the game''s rendered screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将屏幕效果脚本分配给我们的主相机（如果之前附加了`Render BSC`脚本，请将其移除），并将我们的屏幕效果着色器添加到脚本中，以便它有一个用于每个像素操作的着色器。为了使效果完全功能，脚本和着色器会查找一个纹理。您可以在屏幕效果脚本的检查器中将任何纹理分配给纹理字段。一旦这个纹理到位，您将看到将这个纹理乘以游戏渲染截图的效果：
- en: '![](img/00194.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00194.jpeg)'
- en: 'The following screenshot demonstrates the screen effect with a smaller `Blend
    Opacity` option:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了具有较小`Blend Opacity`选项的屏幕效果：
- en: '![](img/00195.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00195.jpeg)'
- en: With our first blend mode set up, we can begin to add a couple of simpler blend
    modes to get a better understanding of how easy it is to add more effects and
    really fine-tune the final result in your game. However, first let's break down
    what is happening here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置好第一个混合模式后，我们可以开始添加几个更简单的混合模式，以更好地理解添加更多效果以及如何轻松地在游戏中微调最终结果。然而，首先让我们分析一下这里发生了什么。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now we are starting to gain a ton of power and flexibility in our screen effects
    programming. I am sure that you are now starting to understand how much you can
    do with this simple system in Unity. We can literally replicate the effects of
    Photoshop layer blending modes in our game to give artists the flexibility they
    need to achieve high-quality graphics in a short amount of time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始在屏幕效果编程中获得大量的功能和灵活性。我相信你现在开始理解你在Unity中可以用这个简单的系统做多少事情。我们实际上可以复制Photoshop图层混合模式的效果到我们的游戏中，为艺术家提供他们需要的灵活性，以便在短时间内实现高质量的图形。
- en: With this particular recipe, we look at how to multiply two images together,
    add two images together, and perform a screen blending mode, using just a little
    bit of mathematics. When working with Blend modes, you have to think on a per-pixel
    level. For instance, when we are using the multiply blend mode, we literally take
    each pixel from the original `RenderTexture` and multiply it by each pixel of
    the Blend texture. The same goes for the add Blend mode. It is just a simple mathematical
    operation of adding each pixel from the source texture, or `RenderTexture`, to
    the Blend texture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的食谱中，我们看看如何将两个图像相乘，将两个图像相加，并执行屏幕混合模式，只需一点数学知识。当使用混合模式时，你必须从每个像素的角度去思考。例如，当我们使用乘法混合模式时，我们实际上是从原始`RenderTexture`中取出每个像素，并将其与混合纹理的每个像素相乘。对于加法混合模式也是如此。它只是将源纹理或`RenderTexture`中的每个像素简单地加到混合纹理上。
- en: The screen Blend mode is definitely a bit more involved, but it is actually
    doing the same thing. It takes each image, `RenderTexture`, and Blend texture,
    inverts them, then multiplies them together, and inverts them again to achieve
    the final look. Just as Photoshop blends its textures together using blend modes,
    we can do the same with screen effects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕混合模式确实要复杂一些，但它实际上在做的是同样的事情。它对每个图像、`RenderTexture`和混合纹理进行反转，然后将它们相乘，再次反转以实现最终的外观。就像Photoshop使用混合模式混合纹理一样，我们也可以用屏幕效果做到同样的事情。
- en: There's more...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Let''s continue this recipe by adding a couple more blend modes to our screen
    effect:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加几个更多的混合模式到我们的屏幕效果中继续这个食谱：
- en: 'In the screen effect shader, let''s add the following code to our `frag()`
    function and change the value we are returning to our script. We will also need
    to comment out the multiply blend so that we don''t return that as well:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕效果着色器中，让我们在我们的`frag()`函数中添加以下代码，并将我们返回给脚本的值更改。我们还需要注释掉乘法混合模式，这样就不会返回它：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Save the shader file in your IDE of choice and `MonoDevelop` and return to
    the Unity editor to let the shader compile. If no errors occurred, you should
    see a result similar to the following screenshot:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器文件保存在你选择的IDE中（例如`MonoDevelop`）并返回Unity编辑器，让着色器进行编译。如果没有错误发生，你应该会看到以下截图类似的结果：
- en: '![](img/00196.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00196.jpeg)'
- en: 'This is a simple add blending mode with a figure of `0.5` set for the `Blend
    Opacity`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个简单的加法混合模式，`Blend Opacity`设置为`0.5`：
- en: '![](img/00197.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00197.jpeg)'
- en: As you can see, this has the opposite effect of multiply because we are adding
    the two images together.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这与乘法的效果相反，因为我们是在将两个图像相加。
- en: 'Finally, let''s add one more blend mode called a screen blend. This one is
    a little bit more involved, from a mathematical standpoint, but still simple to
    implement. Enter the following code in the `frag()` function of our shader:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个名为屏幕混合的更多混合模式。这个混合模式在数学上稍微复杂一些，但仍然易于实现。在着色器的 `frag()` 函数中输入以下代码：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot demonstrates the results of using a screen type Blend
    mode to blend two images together in a screen effect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了使用屏幕类型混合模式将两个图像混合在一起在屏幕效果中的结果：
- en: '![](img/00198.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00198.jpeg)'
- en: 'Here''s a screenshot displaying the effect:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示效果的截图：
- en: '![](img/00199.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00199.jpeg)'
- en: Using the Overlay Blend mode with screen effects
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用屏幕效果与叠加混合模式
- en: For our final recipe, we are going to take a look at another type of blend mode,
    the Overlay Blend mode. This blend mode actually makes use of some conditional
    statements that determine the final color of each pixel in each channel. So, the
    process of using this type of blend mode requires a bit more coding to work. Let's
    take a look at how this is done in the next few recipes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终配方，我们将查看另一种类型的混合模式，即叠加混合模式。这种混合模式实际上使用了一些条件语句来确定每个通道中每个像素的最终颜色。因此，使用这种类型的混合模式需要更多的编码才能工作。让我们看看在接下来的几个配方中是如何实现的。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To begin our Overlay Screen effect, we will need to get the code of our shader
    up and running without errors. We can then modify our script file to feed the
    correct data to the shader:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的叠加屏幕效果，我们需要确保我们的着色器代码没有错误并运行起来。然后我们可以修改我们的脚本文件，以便向着色器提供正确的数据：
- en: Create a new shader by duplicating the `ScreenGreyscale` code and selecting
    it from the Project tab under the `Chapter 9 `| `Shaders` folder and pressing
    *Ctrl* + *D*. Once duplicated, rename the script to `ScreenOverlay`. Then, double-click
    on this shader to open it in your script editor.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制 `ScreenGreyscale` 代码并从 `Chapter 9 | Shaders` 文件夹下的项目标签页中选择它，然后按 *Ctrl*
    + *D* 来创建一个新的着色器。一旦复制完成，将脚本重命名为 `ScreenOverlay`。然后，双击此着色器以在脚本编辑器中打开它。
- en: 'We first need to set up the properties in our `Properties` block. We will use
    the same properties from the previous few recipes in this chapter:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要在 `Properties` 块中设置属性。我们将使用本章前面几个配方中相同的属性：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then need to create the corresponding variables in our `CGPROGRAM`, removing
    the previously created ones:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `CGPROGRAM` 中创建相应的变量，删除之前创建的变量：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In order for the Overlay Blend effect to work, we will have to process each
    pixel from each channel individually. To do this in a shader, we have to write
    a custom function that will take in a single channel, for instance, the red channel,
    and perform the overlay operation. Enter the following code in the shader just
    below the variable declarations:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让叠加混合效果工作，我们必须对每个通道的每个像素进行单独处理。要在着色器中这样做，我们必须编写一个自定义函数，该函数将接受单个通道，例如红色通道，并执行叠加操作。在着色器中变量声明下方输入以下代码：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We need to update our `frag()` function to process each channel of our textures
    in order to perform the blending:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新我们的 `frag()` 函数，以便处理我们的纹理的每个通道，以执行混合：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the code completed in the shader, our effect should be working. Save the
    shader and return to the Unity editor to let the shader compile. Our script is
    already set up; select the Main Camera object. From the Project tab, drag and
    drop the ScreenOverlay shader onto the `Cur Shader` property from the Render Blend
    Mode component in the Inspector tab. Once the shader compiles, you should see
    a result similar to the following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器中完成代码后，我们的效果应该已经开始工作了。保存着色器并返回到 Unity 编辑器，让着色器进行编译。我们的脚本已经设置好了；选择主摄像机对象。从项目标签页，将
    ScreenOverlay 着色器拖放到检查器标签页中的渲染混合模式组件的 `Cur Shader` 属性上。一旦着色器编译完成，你应该会看到一个类似于以下截图的结果：
- en: '![](img/00200.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00200.jpeg)'
- en: 'Here''s a screenshot using a Blend Opacity of `0.5`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `0.5` 混合不透明度的截图：
- en: '![](img/00201.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/00201.jpeg)'
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our overlay blend mode is definitely a lot more involved, but if you really
    break down the function, you will notice that it is simply a multiply blend mode
    and screen blend mode. In this case, we are doing a conditional check to apply
    one or the other blend mode to a pixel.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的叠加混合模式确实更为复杂，但如果你真正分解其功能，你会发现它实际上只是一个乘法混合模式和屏幕混合模式。在这种情况下，我们进行条件检查，以将一个或另一个混合模式应用于像素。
- en: With this particular screen effect, when the overlay function receives a pixel,
    it checks to see whether it is less than `0.5`. If it is, then we apply a modified
    multiply blend mode to that pixel; if it's not, then we apply a modified screen
    blend mode to the pixel. We do this for each pixel for each channel, giving us
    the final RGB pixel values for our screen effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的屏幕效果中，当叠加功能接收到一个像素时，它会检查该像素是否小于`0.5`。如果是，则对该像素应用修改后的乘法混合模式；如果不是，则对该像素应用修改后的屏幕混合模式。我们对每个通道的每个像素都这样做，从而得到屏幕效果的最终RGB像素值。
- en: As you can see, there are many things that can be done with screen effects.
    It really just depends on the platform and amount of memory you have allocated
    for screen effects. Usually, this is determined throughout the course of a game
    project, so have fun and get creative with your screen effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可以使用屏幕效果做很多事情。这实际上完全取决于平台和分配给屏幕效果的内存量。通常，这会在游戏项目的整个过程中确定，所以尽情享受并发挥创意，制作出有趣的屏幕效果。
