<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>16 Mediator and CQRS Design Patterns</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="17">16 Mediator and CQRS Design Patterns</h1>

<h2 data-number="17.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file98.png" style="width:10em"/></p>
<p>This chapter covers the building blocks of the next chapter, which is about <strong>Vertical Slice Architecture</strong>. We begin with a quick overview of Vertical Slice Architecture to give you an idea of the end goal. Then, we explore the <strong>Mediator</strong> design pattern, which plays the role of the middleman between the components of our application. That leads us to the <strong>Command Query Responsibility Segregation</strong> (<strong>CQRS</strong>) pattern, which describes how to divide our logic into commands and queries. Finally, we consolidate our learning by exploring MediatR, an open-source implementation of the Mediator design pattern, and send queries and commands through it to demonstrate how the concepts we have studied so far come to life in real-world application development.In this chapter, we cover the following topics:</p>
<ul>
<li>A high-level overview of Vertical Slice Architecture</li>
<li>Implementing the Mediator pattern</li>
<li>Implementing the CQS pattern</li>
<li>Code smell – Marker Interfaces</li>
<li>Using MediatR as a mediator</li>
</ul>
<p>Let’s begin with the end goal.</p>


<h2 data-number="17.2">A high-level overview of Vertical Slice Architecture</h2>
<p>Before starting, let’s look at the end goal of this chapter and the next. This way, it should be easier to follow the progress toward that goal throughout the chapter.As we covered in <em>Chapter 14</em>, <em>Layering and Clean Architecture</em>, a layer groups classes together based on shared responsibilities. So, classes containing data access code are part of the data access layer (or infrastructure). People represent layers using horizontal slices in diagrams like this:</p>
<figure>
<img alt="Figure 16.1: Diagram representing layers as horizontal slices" src="img/file99.png"/><figcaption aria-hidden="true">Figure 16.1: Diagram representing layers as horizontal slices</figcaption>
</figure>
<p>The “vertical slice” in “Vertical Slice Architecture” comes from that; a vertical slice represents the part of each layer that creates a specific feature. So, instead of dividing the application into layers, we divide it into features. A feature manages its data access code, domain logic, and possibly even presentation code. The key is to loosely couple the features from one another and keep each feature’s components close together. In a layered application, when we add, update, or remove a feature, we must change one or more layers, which too often translates to “all layers.”On the other hand, with vertical slices, we keep features isolated, allowing us to design them independently. From a layering perspective, this is like flipping your way of thinking about software to a 90° angle:</p>
<figure>
<img alt="Figure 16.2: Diagram representing a vertical slice crossing all layers" src="img/file100.png"/><figcaption aria-hidden="true">Figure 16.2: Diagram representing a vertical slice crossing all layers</figcaption>
</figure>
<p>Vertical Slice Architecture does not dictate the use of <strong>CQRS</strong>, the <strong>Mediator</strong> pattern, or <strong>MediatR</strong>, but these tools and patterns flow very well together, as we see in the next chapter. Nonetheless, these are just tools and patterns that you can use or change in your implementation using different techniques; it does not matter and does not change the concept.</p>
<blockquote>
<p>We explore additional ways of building feature-oriented applications in <em>Chapter 18</em>, <em>Request-EndPoint-Response (REPR)</em>, and <em>Chapter 20</em>, <em>Modular Monolith</em>.</p>
</blockquote>
<p>The goal is to encapsulate features together, use CQRS to divide the application into requests (commands and queries), and use MediatR as the mediator of that CQRS pipeline, decoupling the pieces from one another.You now know the plan. We explore Vertical Slice Architecture later. Meanwhile, let’s begin with the Mediator design pattern.</p>


<h2 data-number="17.3">Implementing the Mediator pattern</h2>
<p>The <strong>Mediator</strong> pattern is another GoF design pattern that controls how objects interact with one another (making it a behavioral pattern).</p>

<h3 data-number="17.3.1">Goal</h3>
<p>The mediator’s role is to manage the communication between objects (colleagues). Those colleagues should not communicate together directly but use the mediator instead. The mediator helps break tight coupling between these colleagues.<strong>A mediator is a middleman who relays messages between colleagues</strong>.</p>


<h3 data-number="17.3.2">Design</h3>
<p>Let’s start with some UML diagrams. From a very high level, the Mediator pattern is composed of a mediator and colleagues:</p>
<figure>
<img alt="Figure 16.3: Class diagram representing the Mediator pattern" src="img/file101.png"/><figcaption aria-hidden="true">Figure 16.3: Class diagram representing the Mediator pattern</figcaption>
</figure>
<p>When an object in the system wants to send a message to one or more colleagues, it uses the mediator. Here is an example of how it works:</p>
<figure>
<img alt="Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues" src="img/file102.png"/><figcaption aria-hidden="true">Figure 16.4: Sequence diagram of a mediator relaying messages to colleagues</figcaption>
</figure>
<p>That is also valid for colleagues; a colleague must also use the mediator if they need to talk to each other, as depicted in the following class diagram:</p>
<figure>
<img alt="Figure 16.5: Class diagram representing the Mediator pattern including colleagues’ collaboration" src="img/file103.png"/><figcaption aria-hidden="true">Figure 16.5: Class diagram representing the Mediator pattern including colleagues’ collaboration</figcaption>
</figure>
<p>In this diagram, <code>ConcreteColleague1</code> is a colleague but also the consumer of the mediator. For example, that colleague could send a message to another colleague using the mediator, like this:</p>
<figure>
<img alt="Figure 16.6: Sequence diagram representing colleague1 communicating with colleague2 through the mediator" src="img/file104.png"/><figcaption aria-hidden="true">Figure 16.6: Sequence diagram representing colleague1 communicating with colleague2 through the mediator</figcaption>
</figure>
<p>From a mediator standpoint, its implementation most likely contains a collection of colleagues to communicate with, like this:</p>
<figure>
<img alt="Figure 16.7: Class diagram representing a simple hypothetical concrete mediator implementation" src="img/file105.png"/><figcaption aria-hidden="true">Figure 16.7: Class diagram representing a simple hypothetical concrete mediator implementation</figcaption>
</figure>
<p>Now that we have explored some UML diagrams, let’s look at some code.</p>


<h3 data-number="17.3.3">Project – Mediator (IMediator)</h3>
<p>The Mediator project consists of a simplified chat system using the Mediator pattern. Let’s start with the interfaces:</p>
<div><pre><code>namespace Mediator;
public interface IMediator
{
    void Send(Message message);
}
public interface IColleague
{
    string Name { get; }
    void ReceiveMessage(Message message);
}
public record class Message(IColleague Sender, string Content);</code></pre>
</div>
<p>The system is composed of the following:</p>
<ul>
<li>The <code>IMediator</code> interface represents a mediator that can send messages to colleagues.</li>
<li>The <code>IColleague</code> interface represents a colleague that can receive messages. It also has a <code>Name</code> property so we can output meaningful values.</li>
<li>The <code>Message</code> class represents a message sent by an <code>IColleague</code> implementation.</li>
</ul>
<p>Next, we implement the <code>IMediator</code> interface in the <code>ConcreteMediator</code> class, which broadcasts the messages to all <code>IColleague</code> instances:</p>
<div><pre><code>public class ConcreteMediator : IMediator
{
    private readonly List&lt;IColleague&gt; _colleagues;
    public ConcreteMediator(params IColleague[] colleagues)
    {
        ArgumentNullException.ThrowIfNull(colleagues);
        _colleagues = new List&lt;IColleague&gt;(colleagues);
    }
    public void Send(Message message)
    {
        foreach (var colleague in _colleagues)
        {
            colleague.ReceiveMessage(message);
        }
    }
}</code></pre>
</div>
<p>That mediator is simple; it forwards all the messages it receives to every colleague it knows. The last part of the pattern is the <code>ConcreteColleague</code> class which lets an instance of the <code>IMessageWriter&lt;TMessage&gt;</code> interface output the messages (we explore that interface next):</p>
<div><pre><code>public class ConcreteColleague : IColleague
{
    private readonly IMessageWriter&lt;Message&gt; _messageWriter;
    public ConcreteColleague(string name, IMessageWriter&lt;Message&gt; messageWriter)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
        _messageWriter = messageWriter ?? throw new ArgumentNullException(nameof(messageWriter));
    }
    public string Name { get; }
    public void ReceiveMessage(Message message)
    {
        _messageWriter.Write(message);
    }
}</code></pre>
</div>
<p>That class could hardly be simpler: it takes a name and an <code>IMessageWriter&lt;TMessage&gt;</code> implementation when created, then it stores a reference for future use.The <code>IMessageWriter&lt;TMessage&gt;</code> interface serves as a presenter and controls how the messages are displayed. The <code>IMessageWriter&lt;TMessage&gt;</code> interface is unrelated to the Mediator pattern. Nevertheless, it is a way to manage how a <code>ConcreteColleague</code> object outputs the messages without coupling it with a specific target. Here is the code:</p>
<div><pre><code>namespace Mediator;
public interface IMessageWriter&lt;Tmessage&gt;
{
    void Write(Tmessage message);
} </code></pre>
</div>
<p>The consumer of the system is an integration test defined in the <code>MediatorTest</code> class. The test uses the chat system and asserts the output using a custom implementation of the <code>IMessageWriter</code> interface. Let’s start by analyzing the test:</p>
<div><pre><code>namespace Mediator;
public class MediatorTest
{
    [Fact]
    public void Send_a_message_to_all_colleagues()
    {
        // Arrange
        var (millerWriter, miller) = CreateConcreteColleague("Miller");
        var (orazioWriter, orazio) = CreateConcreteColleague("Orazio");
        var (fletcherWriter, fletcher) = CreateConcreteColleague("Fletcher");</code></pre>
</div>
<p>The test starts by defining three colleagues with their own <code>TestMessageWriter</code> implementation (names were randomly generated).</p>
<div><pre><code>        var mediator = new ConcreteMediator(miller, orazio, fletcher);
        var expectedOutput = @"[Miller]: Hey everyone!
[Orazio]: What's up Miller?
[Fletcher]: Hey Miller!
";</code></pre>
</div>
<p>In the second part of the preceding <code>Arrange</code> block, we create the subject under test (<code>mediator</code>) and register the three colleagues. At the end of that <code>Arrange</code> block, we also define the expected output of our test. It is important to note that we control the output from the <code>TestMessageWriter</code> implementation (defined at the end of the <code>MediatorTest</code> class). Next is the <code>Act</code> block:</p>
<div><pre><code>        // Act
        mediator.Send(new Message(
            Sender: miller,
            Content: "Hey everyone!"
        ));
        mediator.Send(new Message(
            Sender: orazio,
            Content: "What's up Miller?"
        ));
        mediator.Send(new Message(
            Sender: fletcher,
            Content: "Hey Miller!"
        )); </code></pre>
</div>
<p>In the preceding <code>Act</code> block, we send three messages through the <code>mediator</code> instance. Next is the <code>Assert</code> block:</p>
<div><pre><code>        // Assert
        Assert.Equal(expectedOutput, millerWriter.Output.ToString());
        Assert.Equal(expectedOutput, orazioWriter.Output.ToString());
        Assert.Equal(expectedOutput, fletcherWriter.Output.ToString());
    }</code></pre>
</div>
<p>In the <code>Assert</code> block, we ensure that all colleagues receive the messages.</p>
<div><pre><code>    private static (TestMessageWriter, ConcreteColleague) CreateConcreteColleague(string name)
    {
        var messageWriter = new TestMessageWriter();
        var concreateColleague = new ConcreteColleague(name, messageWriter);
        return (messageWriter, concreateColleague);
    }</code></pre>
</div>
<p>The <code>CreateConcreteColleague</code> method is a helper method that encapsulates the creation of the colleagues, enabling us to write the one-liner declaration used in the <code>Arrange</code> section of the test. Next, we look at the <code>IMessageWriter</code> implementation:</p>
<div><pre><code>    private class TestMessageWriter : IMessageWriter&lt;Message&gt;
    {
        public StringBuilder Output { get; } = new StringBuilder();
        public void Write(Message message)
        {
            Output.AppendLine($"[{message.Sender.Name}]: {message.Content}");
        }
    }
} // Closing the MediatorTest class</code></pre>
</div>
<p>Finally, the <code>TestMessageWriter</code> class writes the messages into <code>StringBuilder</code>, making it easy to assert the output. If we were to build a GUI for that, we could write an implementation of <code>IMessageWriter&lt;Message&gt;</code> that writes to that GUI; in the case of a web UI, it could use <strong>SignalR</strong> or write to the response stream directly, for example.To summarize the sample:</p>
<ol>
<li>The consumer (the unit test) sends messages to colleagues through the mediator.</li>
<li>The <code>TestMessageWriter</code> class writes those messages to a <code>StringBuilder</code> instance. Each colleague has its own instance of the <code>TestMessageWriter</code> class.</li>
<li>The code asserts that all colleagues received the expected messages.</li>
</ol>
<p>This example illustrates that the Mediator pattern allows us to break the direct coupling between colleagues. The messages reached colleagues without them knowing about each other.Colleagues should communicate through the mediator, so the Mediator pattern would not be complete without that. Let’s implement a more advanced chatroom to tackle this concept.</p>


<h3 data-number="17.3.4">Project – Mediator (IChatRoom)</h3>
<p>In the previous code sample, we named the classes after the Mediator pattern actors, as shown in <em>Figure 14.7</em>. While this example is very similar, it uses domain-specific names instead and implements a few more methods to manage the system showing a more tangible implementation. Let’s start with the abstractions:</p>
<div><pre><code>namespace Mediator;
public interface IChatRoom
{
    void Join(IParticipant participant);
    void Send(ChatMessage message);
}</code></pre>
</div>
<p>The <code>IChatRoom</code> interface is the mediator, and it defines two methods instead of one:</p>
<ul>
<li><code>Join</code>, which allows <code>IParticipant</code> to join <code>IChatRoom</code>.</li>
<li><code>Send</code>, which sends a message to the others.</li>
</ul>
<div><pre><code>public interface IParticipant
{
    string Name { get; }
    void Send(string message);
    void ReceiveMessage(ChatMessage message);
    void ChatRoomJoined(IChatRoom chatRoom);
}</code></pre>
</div>
<p>The <code>IParticipant</code> interface is the colleague and also has a few more methods:</p>
<ul>
<li><code>Send</code>, to send messages.</li>
<li><code>ReceiveMessage</code>, to receive messages from the other <code>IParticipant</code> objects.</li>
<li><code>ChatRoomJoined</code>, to confirm that the <code>IParticipant</code> object has successfully joined a chatroom.</li>
</ul>
<div><pre><code>public record class ChatMessage(IParticipant Sender, string Content);</code></pre>
</div>
<p>The <code>ChatMessage</code> class is the same as the previous <code>Message</code> class, but it references <code>IParticipant</code> instead of <code>IColleague</code>.Let’s now look at the <code>IParticipant</code> implementation:</p>
<div><pre><code>public class User : IParticipant
{
    private IChatRoom? _chatRoom;
    private readonly IMessageWriter&lt;ChatMessage&gt; _messageWriter;
    public User(IMessageWriter&lt;ChatMessage&gt; messageWriter, string name)
    {
        _messageWriter = messageWriter ?? throw new ArgumentNullException(nameof(messageWriter));
        Name = name ?? throw new ArgumentNullException(nameof(name));
    }
    public string Name { get; }
    public void ChatRoomJoined(IChatRoom chatRoom)
    {
        _chatRoom = chatRoom;
    }
    public void ReceiveMessage(ChatMessage message)
    {
        _messageWriter.Write(message);
    }
    public void Send(string message)
    {
        if (_chatRoom == null)
        {
            throw new ChatRoomNotJoinedException();
        }
        _chatRoom.Send(new ChatMessage(this, message));
    }
}
public class ChatRoomNotJoinedException : Exception
{
    public ChatRoomNotJoinedException()
        : base("You must join a chat room before sending a message.")
    { }
}</code></pre>
</div>
<p>The <code>User</code> class represents our default <code>IParticipant</code>. A <code>User</code> instance can chat in only one <code>IChatRoom</code>. THe program can set the chat room by calling the <code>ChatRoomJoined</code> method. When it receives a message, it delegates it to its <code>IMessageWriter&lt;ChatMessage&gt;</code>. Finally, a <code>User</code> instance can send a message through the mediator (<code>IChatRoom)</code>. The <code>Send</code> method throws a <code>ChatRoomNotJoinedException</code> to enforce that the <code>User</code> instance must join a chat room before sending messages (code-wise: the <code>_chatRoom</code> field must not be <code>null</code>).We could create a <code>Moderator</code>, <code>Administrator</code>, <code>SystemAlerts</code>, or any other <code>IParticipant</code> implementation as we see fit, but not in this sample. I am leaving that to you to experiment with the Mediator pattern.Now let’s look at the <code>ChatRoom</code> class (the mediator):</p>
<div><pre><code>public class ChatRoom : IChatRoom
{
    private readonly List&lt;IParticipant&gt; _participants = new();
    public void Join(IParticipant participant)
    {
        _participants.Add(participant);
        participant.ChatRoomJoined(this);
        Send(new ChatMessage(participant, "Has joined the channel"));
    }
    public void Send(ChatMessage message)
    {
        _participants.ForEach(participant 
            =&gt; participant.ReceiveMessage(message));
    }
}</code></pre>
</div>
<p>The <code>ChatRoom</code> class is slimmer than the <code>User</code> class. It allows participants to join and sends chat messages to registered participants. When joining a <code>ChatRoom</code>, it keeps a reference on the <code>IParticipant</code>, tells that <code>IParticipant</code> that it has successfully joined then sends a <code>ChatMessage</code> to all participants announcing the newcomer.With those few pieces, we have a Mediator implementation. Before moving to the next section, let’s look at the <code>Consumer</code> instance of <code>IChatRoom</code>, which is another integration test. Let’s start with the skeleton of the class:</p>
<div><pre><code>namespace Mediator;
public class ChatRoomTest
{
    [Fact]
    public void ChatRoom_participants_should_send_and_receive_messages()
    {
        // Arrange, Act, Assert blocks here
    }
    private (TestMessageWriter, User) CreateTestUser(string name)
    {
        var writer = new TestMessageWriter();
        var user = new User(writer, name);
        return (writer, user);
    }
    private class TestMessageWriter : IMessageWriter&lt;ChatMessage&gt;
    {
        public StringBuilder Output { get; } = new StringBuilder();
        public void Write(ChatMessage message)
        {
            Output.AppendLine($"[{message.Sender.Name}]: {message.Content}");
        }
    }
}</code></pre>
</div>
<p>In the preceding code, we have the following pieces:</p>
<ul>
<li>The test case is an empty placeholder that we are about to look into.</li>
<li>The <code>CreateTestUser</code> method helps simplify the <code>Arrange</code> section of the test case, similar to before.</li>
<li>The <code>TestMessageWriter</code> implementation is similar to the previous example, accumulating messages in a <code>StringBuilder</code> instance.</li>
</ul>
<p>As a reference, the <code>IMessageWriter</code> interface is the same as the previous project:</p>
<div><pre><code>public interface IMessageWriter&lt;TMessage&gt;
{
    void Write(TMessage message);
}</code></pre>
</div>
<p>Now, let’s explore the test case, starting with the <code>Arrange</code> block, where we create four users with their respective <code>TestMessageWriter</code> instances (names were also randomly generated):</p>
<div><pre><code>// Arrange
var (kingChat, king) = CreateTestUser("King");
var (kelleyChat, kelley) = CreateTestUser("Kelley");
var (daveenChat, daveen) = CreateTestUser("Daveen");
var (rutterChat, _) = CreateTestUser("Rutter");
var chatroom = new ChatRoom();</code></pre>
</div>
<p>Then, in the <code>Act</code> block, our test users join the <code>chatroom</code> instance and send messages:</p>
<div><pre><code>// Act
chatroom.Join(king);
chatroom.Join(kelley);
king.Send("Hey!");
kelley.Send("What's up King?");
chatroom.Join(daveen);
king.Send("Everything is great, I joined the CrazyChatRoom!");
daveen.Send("Hey King!");
king.Send("Hey Daveen");</code></pre>
</div>
<p>Then in the Assert block, Rutter did not join the chatroom, so we expect no message:</p>
<div><pre><code>// Assert
Assert.Empty(rutterChat.Output.ToString());</code></pre>
</div>
<p>Since King is the first to join the channel, we expect him to receive all messages:</p>
<div><pre><code>Assert.Equal(@"[King]: Has joined the channel
[Kelley]: Has joined the channel
[King]: Hey!
[Kelley]: What's up King?
[Daveen]: Has joined the channel
[King]: Everything is great, I joined the CrazyChatRoom!
[Daveen]: Hey King!
[King]: Hey Daveen
", kingChat.Output.ToString());</code></pre>
</div>
<p>Kelley was the second user to join the chatroom, so the output contains almost all messages except the line saying <code>[King]: Has joined the channel</code>:</p>
<div><pre><code>Assert.Equal(@"[Kelley]: Has joined the channel
[King]: Hey!
[Kelley]: What's up King?
[Daveen]: Has joined the channel
[King]: Everything is great, I joined the CrazyChatRoom!
[Daveen]: Hey King!
[King]: Hey Daveen
", kelleyChat.Output.ToString());</code></pre>
</div>
<p>Daveen joined after King and Kelley exchanged a few words, so we expect the conversation to be shorter:</p>
<div><pre><code>Assert.Equal(@"[Daveen]: Has joined the channel
[King]: Everything is great, I joined the CrazyChatRoom!
[Daveen]: Hey King!
[King]: Hey Daveen
", daveenChat.Output.ToString());</code></pre>
</div>
<p>To summarize the test case, we have four users. Three of them joined the same chatroom at a different time and chatted a little. The output is different for everyone since the time you join matters. All participants are loosely coupled, thanks to the Mediator pattern, allowing us to extend the system without impacting the existing pieces. Leveraging the Mediator pattern helps us create maintainable systems; many small pieces are easier to manage and test than a large component handling all the logic.</p>


<h3 data-number="17.3.5">Conclusion</h3>
<p>As we explored in the two preceding projects, a <strong>mediator</strong> allows us to decouple the components of our system. <strong>The mediator is the middleman between colleagues</strong>, and it served us well in the small chatroom samples where each colleague can talk to the others without knowing how and without knowing them.Now let’s see how the Mediator pattern can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: The mediator extracts the communication responsibility from colleagues.</li>
<li><strong>O</strong>: With a mediator relaying the messages, we can create new colleagues and change the existing colleagues’ behaviors without impacting the others. If we need a new colleague, we can register one with the mediator.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: The Mediator pattern divides the system into multiple small interfaces (<code>IMediator</code> and <code>IColleague</code>).</li>
<li><strong>D</strong>: All actors of the Mediator pattern solely depend on other interfaces. We can implement a new mediator and reuse the existing colleagues’ implementations if we need new mediation behavior because of the dependency inversion.</li>
</ul>
<p>Next, we explore CQRS, which allows us to separate commands and queries, leading to a more maintainable application. After all, all operations are queries or commands, no matter how we call them.</p>



<h2 data-number="17.4">Implementing the CQS pattern</h2>
<p><strong>Command-Query Separation (CQS)</strong> is a subset of the <strong>Command Query Responsibility Segregation (CQRS)</strong> pattern.Here’s the high-level difference between the two:</p>
<ul>
<li>With CQS, we divide operations into commands and queries.</li>
<li>With CQRS, we apply the concept to the system level. We separate models for reading and for writing, potentially leading to a distributed system.</li>
</ul>
<p>In this chapter, we stick with CQS and tackle CQRS in <em>Chapter 18</em>, <em>Introduction to Microservices Architecture</em>.</p>

<h3 data-number="17.4.1">Goal</h3>
<p>The goal is to divide all operations (or requests) into two categories: commands and queries.</p>
<ul>
<li><strong>A command mutates the state of an application.</strong> For example, creating, updating, and deleting an entity are commands. In theory, a command should not return a value. In practice, they often do, especially for optimization purposes.</li>
<li><strong>A query reads the state of the application but never changes it.</strong> For example, reading an order, reading your order history, and retrieving your user profile are queries.</li>
</ul>
<p>Dividing operations into mutator requests (write/command) and accessor requests (read/query) creates a clear separation of concerns, leading us toward the SRP.</p>


<h3 data-number="17.4.2">Design</h3>
<p>There is no definite design for this, but for us, the flow of a command should look like the following:</p>
<figure>
<img alt="Figure 16.8: Sequence diagram representing the abstract flow of a command" src="img/file106.png"/><figcaption aria-hidden="true">Figure 16.8: Sequence diagram representing the abstract flow of a command</figcaption>
</figure>
<p>The consumer creates a command object and sends it to a command handler, applying the mutation to the application. I called it <code>Entities</code> in this case, but it could have sent a SQL <code>UPDATE</code> command to a database or a web API call over HTTP; the implementation details do not matter.The concept is the same for a query, but it returns a value instead. Very importantly, the query must not change the state of the application. A query should only read data, like this:</p>
<figure>
<img alt="Figure 16.9: Sequence diagram representing the abstract flow of a query" src="img/file107.png"/><figcaption aria-hidden="true">Figure 16.9: Sequence diagram representing the abstract flow of a query</figcaption>
</figure>
<p>Like the command, the consumer creates a query object and sends it to a handler, which then executes some logic to retrieve and return the requested data. We can replace <code>Entities</code> with anything the handler needs to query the data.Enough talk—let’s look at the CQS project.</p>


<h3 data-number="17.4.3">Project – CQS</h3>
<p><strong>Context</strong>: We need to build an improved version of our chat system. The old system worked so well that we need to scale it up. The mediator was of help to us, so we kept that part, and we picked the CQS pattern to help us with this new, improved design. A participant was limited to a single chatroom in the past, but now a participant must be able to chat in multiple rooms simultaneously.The new system is composed of three commands and two queries:</p>
<ul>
<li>A participant must be able to join a chatroom.</li>
<li>A participant must be able to leave a chatroom.</li>
<li>A participant must be able to send a message into a chatroom.</li>
<li>A participant must be able to obtain the list of participants that joined a chatroom.</li>
<li>A participant must be able to retrieve the existing messages from a chatroom.</li>
</ul>
<p>The first three are commands, and the last two are queries. The system is backed by the following mediator that makes heavy use of C# generics:</p>
<div><pre><code>public interface IMediator
{
    TReturn Send&lt;TQuery, TReturn&gt;(TQuery query)
        where TQuery : IQuery&lt;TReturn&gt;;
    void Send&lt;TCommand&gt;(TCommand command)
        where TCommand : ICommand;
    void Register&lt;TCommand&gt;(ICommandHandler&lt;TCommand&gt; commandHandler)
        where TCommand : ICommand;
    void Register&lt;TQuery, TReturn&gt;(IQueryHandler&lt;TQuery, TReturn&gt; commandHandler)
        where TQuery : IQuery&lt;TReturn&gt;;
}</code></pre>
</div>
<p>If you are not familiar with generics, this might look daunting, but that code is way simpler than it looks. Next, the <code>ICommand</code> interface is empty, which we could have avoided, but it helps describe our intent. The <code>ICommandHandler</code> interface defines the contract a class must implement to handle a command. That interface defines a <code>Handle</code> method that takes the command as a parameter. The generic parameter <code>TCommand</code> represents the type of command the class implementing the interface can handle. Here’s the code:</p>
<div><pre><code>public interface ICommand { }
public interface ICommandHandler&lt;TCommand&gt; 
    where TCommand : ICommand
{
    void Handle(TCommand command);
}</code></pre>
</div>
<p>The <code>IQuery&lt;TReturn&gt;</code> interface is similar to the <code>ICommand</code> interface but has a <code>TReturn</code> generic parameter indicating the query's return type. The IQueryHandler interface is also very similar, but its <code>Handle</code> method takes an object of type <code>TQuery</code> as a parameter and returns a <code>TReturn</code> type. Here’s the code:</p>
<div><pre><code>public interface IQuery&lt;TReturn&gt; { }
public interface IQueryHandler&lt;TQuery, TReturn&gt;
    where TQuery : IQuery&lt;TReturn&gt;
{
    TReturn Handle(TQuery query);
}</code></pre>
</div>
<p>The <code>IMediator</code> interface allows registering command and query handlers using its <code>Register</code> methods. It also supports sending commands and queries through its <code>Send</code> methods. Then we have the <code>ChatMessage</code> class, which is similar to the last two samples (with an added creation date):</p>
<div><pre><code>public record class ChatMessage(IParticipant Sender, string Message)
{
    public DateTime Date { get; } = DateTime.UtcNow;
}</code></pre>
</div>
<p>Next is the updated <code>IParticipant</code> interface:</p>
<div><pre><code>public interface IParticipant
{
    string Name { get; }
    void Join(IChatRoom chatRoom);
    void Leave(IChatRoom chatRoom);
    void SendMessageTo(IChatRoom chatRoom, string message);
    void NewMessageReceivedFrom(IChatRoom chatRoom, ChatMessage message);
    IEnumerable&lt;IParticipant&gt; ListParticipantsOf(IChatRoom chatRoom);
    IEnumerable&lt;ChatMessage&gt; ListMessagesOf(IChatRoom chatRoom);
}</code></pre>
</div>
<p>All methods of the <code>IParticipant</code> interface accept an <code>IChatRoom</code> parameter to support multiple chatrooms. The updated <code>IChatRoom</code> interface has a name and a few basic operations to meet the requirement of a chatroom, like adding and removing participants:</p>
<div><pre><code>public interface IChatRoom
{
    string Name { get; }
    void Add(IParticipant participant);
    void Remove(IParticipant participant);
    IEnumerable&lt;IParticipant&gt; ListParticipants();
    void Add(ChatMessage message);
    IEnumerable&lt;ChatMessage&gt; ListMessages();
}</code></pre>
</div>
<p>Before going into commands and the chat itself, let’s take a peek at the <code>Mediator</code> class:</p>
<div><pre><code>public class Mediator : IMediator
{
    private readonly HandlerDictionary _handlers = new();
    public void Register&lt;TCommand&gt;(ICommandHandler&lt;TCommand&gt; commandHandler)
        where TCommand : ICommand
    {
        _handlers.AddHandler(commandHandler);
    }
    public void Register&lt;TQuery, TReturn&gt; (IQueryHandler&lt;TQuery, TReturn&gt; commandHandler)
        where TQuery : IQuery&lt;TReturn&gt;
    {
        _handlers.AddHandler(commandHandler);
    }
    public TReturn Send&lt;TQuery, TReturn&gt;(TQuery query)
        where TQuery : IQuery&lt;TReturn&gt;
    {
        var handler = _handlers.Find&lt;TQuery, TReturn&gt;();
        return handler.Handle(query);
    }
    public void Send&lt;TCommand&gt;(TCommand command)
        where TCommand : ICommand
    {
        var handlers = _handlers.FindAll&lt;TCommand&gt;();
        foreach (var handler in handlers)
        {
            handler.Handle(command);
        }
    }
}</code></pre>
</div>
<p>The <code>Mediator</code> class supports registering commands and queries as well as sending a query to a handler or sending a command to zero or more handlers.</p>
<blockquote>
<p>I omitted the implementation of <code>HandlerDictionary</code> because it does not add value to the example, it is just an implementation detail, but it would have added unnecessary complexity. It is available on GitHub: <a href="https://adpg.link/2Lsm">https://adpg.link/2Lsm</a>.</p>
</blockquote>
<p>Now to the commands. I grouped the commands and the handlers together to keep it organized and readable, but you could use another way to organize yours. Moreover, since this is a small project, all the commands are in the same file, which would not be viable for something bigger. Remember, we are playing LEGO blocks, this chapter covers the CQS pieces, but you can always use them with bigger pieces like Clean Architecture or other types of architecture.</p>
<blockquote>
<p>We cover ways to organize commands and queries in subsequent chapters.</p>
</blockquote>
<p>Let’s start with the <code>JoinChatRoom</code> feature:</p>
<div><pre><code>public class JoinChatRoom
{
    public record class Command(IChatRoom ChatRoom, IParticipant Requester) : ICommand;
    public class Handler : ICommandHandler&lt;Command&gt;
    {
        public void Handle(Command command)
        {
            command.ChatRoom.Add(command.Requester);
        }
    }
}</code></pre>
</div>
<p>The <code>Command</code> class represents the command itself, a data structure that carries the command data. The <code>Handler</code> class handles that type of command. When executed, it adds the specified <code>IParticipant</code> to the specified <code>IChatRoom</code>, using the <code>ChatRoom</code> and <code>Requester</code> properties (highlighted line). Next feature:</p>
<div><pre><code>public class LeaveChatRoom
{
    public record class Command(IChatRoom ChatRoom, IParticipant Requester) : ICommand;
    public class Handler : ICommandHandler&lt;Command&gt;
    {
        public void Handle(Command command)
        {
            command.ChatRoom.Remove(command.Requester);
        }
    }
}</code></pre>
</div>
<p>That code represents the exact opposite of the <code>JoinChatRoom</code> command, the <code>LeaveChatRoom</code> handler removes an <code>IParticipant</code> from the specified <code>IChatRoom</code> (highlighted line).</p>
<blockquote>
<p>Nesting the classes like this allows reusing the class name <code>Command</code> and <code>Handler</code> for each feature.</p>
</blockquote>
<p>To the next feature:</p>
<div><pre><code>public class SendChatMessage
{
    public record class Command(IChatRoom ChatRoom, ChatMessage Message) : ICommand;
    public class Handler : ICommandHandler&lt;Command&gt;
    {
        public void Handle(Command command)
        {
            command.ChatRoom.Add(command.Message);
            var participants = command.ChatRoom.ListParticipants();
            foreach (var participant in participants)
            {
                participant.NewMessageReceivedFrom(
                    command.ChatRoom, 
                    command.Message
                );
            }
        }
    }
}</code></pre>
</div>
<p>The <code>SendChatMessage</code> feature, on the other hand, handles two things (highlighted lines):</p>
<ul>
<li>It adds the specified <code>Message</code> to <code>IChatRoom</code> (now only a data structure that keeps track of users and past messages).</li>
<li>It also sends the specified <code>Message</code> to all <code>IParticipant</code> instances that joined that <code>IChatRoom</code>.</li>
</ul>
<p>We are starting to see many smaller pieces interacting with each other to create a more developed system. But we are not done; let’s look at the two queries, then the chat implementation:</p>
<div><pre><code>public class ListParticipants
{
    public record class Query(IChatRoom ChatRoom, IParticipant Requester) : IQuery&lt;IEnumerable&lt;IParticipant&gt;&gt;;
    public class Handler : IQueryHandler&lt;Query, IEnumerable&lt;IParticipant&gt;&gt;
    {
        public IEnumerable&lt;IParticipant&gt; Handle(Query query)
        {
            return query.ChatRoom.ListParticipants();
        }
    }
}</code></pre>
</div>
<p>The <code>ListParticipants</code> handler uses the specified <code>IChatRoom</code> and returns its participants (highlighted line). Now, to the last query:</p>
<div><pre><code>public class ListMessages
{
    public record class Query(IChatRoom ChatRoom, IParticipant Requester) : IQuery&lt;IEnumerable&lt;ChatMessage&gt;&gt;;
    public class Handler : IQueryHandler&lt;Query, IEnumerable&lt;ChatMessage&gt;&gt;
    {
        public IEnumerable&lt;ChatMessage&gt; Handle(Query query)
        {
            return query.ChatRoom.ListMessages();
        }
    }
}</code></pre>
</div>
<p>The <code>ListMessages</code> handler uses the specified <code>IChatRoom</code> instance to return its messages.</p>
<blockquote>
<p>Because all commands and queries reference <code>IParticipant</code>, we could enforce rules such as “<code>IParticipant</code> must join a channel before sending messages,” for example. I decided to omit these details to keep the code simple, but feel free to add those features if you want to.</p>
</blockquote>
<p>Next, let’s take a look at the <code>ChatRoom</code> class, which is a simple data structure that holds the state of a chatroom:</p>
<div><pre><code>public class ChatRoom : IChatRoom
{
    private readonly List&lt;IParticipant&gt; _participants = new List&lt;IParticipant&gt;();
    private readonly List&lt;ChatMessage&gt; _chatMessages = new List&lt;ChatMessage&gt;();
    public ChatRoom(string name)
    {
        Name = name ?? throw new ArgumentNullException(nameof(name));
    }
    public string Name { get; }
    public void Add(IParticipant participant)
    {
        _participants.Add(participant);
    }
    public void Add(ChatMessage message)
    {
        _chatMessages.Add(message);
    }
    public IEnumerable&lt;ChatMessage&gt; ListMessages()
    {
        return _chatMessages.AsReadOnly();
    }
    public IEnumerable&lt;IParticipant&gt; ListParticipants()
    {
        return _participants.AsReadOnly();
    }
    public void Remove(IParticipant participant)
    {
        _participants.Remove(participant);
    }
}</code></pre>
</div>
<p>If we take a second look at the <code>ChatRoom</code> class, it has a <code>Name</code> property. It contains a list of <code>IParticipant</code> instances and a list of <code>ChatMessage</code> instances. Both <code>ListMessages()</code> and <code>ListParticipants()</code> return the list <code>AsReadOnly()</code>, so a clever programmer cannot mutate the state of <code>ChatRoom</code> from the outside. That’s it; the new <code>ChatRoom</code> class is a façade over its underlying dependencies.Finally, the <code>Participant</code> class is probably the most exciting part of this system because it is the one that makes heavy use of our Mediator and CQS:</p>
<div><pre><code>public class Participant : IParticipant
{
    private readonly IMediator _mediator;
    private readonly IMessageWriter _messageWriter;
    public Participant(IMediator mediator, string name, IMessageWriter messageWriter)
    {
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        Name = name ?? throw new ArgumentNullException(nameof(name));
        _messageWriter = messageWriter ?? throw new ArgumentNullException(nameof(messageWriter));
    }
    public string Name { get; }
    public void Join(IChatRoom chatRoom)
    {
        _mediator.Send(new JoinChatRoom.Command(chatRoom, this));
    }
    public void Leave(IChatRoom chatRoom)
    {
        _mediator.Send(new LeaveChatRoom.Command(chatRoom, this));
    }
    public IEnumerable&lt;ChatMessage&gt; ListMessagesOf(IChatRoom chatRoom)
    {
        return _mediator.Send&lt;ListMessages.Query, IEnumerable&lt;ChatMessage&gt;&gt;(new ListMessages.Query(chatRoom, this));
    }
    public IEnumerable&lt;IParticipant&gt; ListParticipantsOf(IChatRoom chatRoom)
    {
        return _mediator.Send&lt;ListParticipants.Query, IEnumerable&lt;IParticipant&gt;&gt;(new ListParticipants.Query(chatRoom, this));
    }
    public void NewMessageReceivedFrom(IChatRoom chatRoom, ChatMessage message)
    {
        _messageWriter.Write(chatRoom, message);
    }
    public void SendMessageTo(IChatRoom chatRoom, string message)
    {
        _mediator.Send(new SendChatMessage.Command (chatRoom, new ChatMessage(this, message)));
    }
}</code></pre>
</div>
<p>Every method of the <code>Participant</code> class, apart from <code>NewMessageReceivedFrom</code>, sends a command or a query through the <code>IMediator</code> interface, breaking the tight coupling between the participants and the system’s operations (that is, the commands and queries). The <code>Participant</code> class is also a simple façade over its underlying dependencies, delegating most of the work to the mediator.Now that we have covered the numerous tiny pieces let’s look at how everything works together. I grouped several test cases that share the following setup code:</p>
<div><pre><code>public class ChatRoomTest
{
    private readonly IMediator _mediator = new Mediator();
    private readonly TestMessageWriter _reagenMessageWriter = new();
    private readonly TestMessageWriter _garnerMessageWriter = new();
    private readonly TestMessageWriter _corneliaMessageWriter = new();
    private readonly IChatRoom _room1 = new ChatRoom("Room 1");
    private readonly IChatRoom _room2 = new ChatRoom("Room 2");
    private readonly IParticipant _reagen;
    private readonly IParticipant _garner;
    private readonly IParticipant _cornelia;
    public ChatRoomTest()
    {
        _mediator.Register(new JoinChatRoom.Handler());
        _mediator.Register(new LeaveChatRoom.Handler());
        _mediator.Register(new SendChatMessage.Handler());
        _mediator.Register(new ListParticipants.Handler());
        _mediator.Register(new ListMessages.Handler());
        _reagen = new Participant(_mediator, "Reagen", _reagenMessageWriter);
        _garner = new Participant(_mediator, "Garner", _garnerMessageWriter);
        _cornelia = new Participant(_mediator, "Cornelia", _corneliaMessageWriter);
    }
    // Omited test cases and helpers
}</code></pre>
</div>
<p>The test program setup is composed of the following:</p>
<ul>
<li>One <code>IMediator</code> field initialized with a <code>Mediator</code> instance, which enables all colleagues to interact with each other.</li>
<li>Two <code>IChatRoom</code> fields initialized with <code>ChatRoom</code> instances.</li>
<li>Three <code>IParticipant</code> uninitialized fields, later initialized with <code>Participant</code> instances.</li>
<li>Three <code>TestMessageWriter</code> instances, one per participant.</li>
<li>The constructor registers all handlers with the <code>Mediator</code> instance so it knows how to handle commands and queries. It also creates the participants.</li>
</ul>
<blockquote>
<p>Once again, the names of the participants are randomly generated.</p>
</blockquote>
<p>The <code>TestMessageWriter</code> implementation is a little different and accumulates the data in a list of tuples (<code>List&lt;(IChatRoom, ChatMessage)&gt;</code>) to assess what the participants send:</p>
<div><pre><code>private class TestMessageWriter : IMessageWriter
{
    public List&lt;(IChatRoom chatRoom, ChatMessage message)&gt; Output { get; } = new();
    public void Write(IChatRoom chatRoom, ChatMessage message)
    {
        Output.Add((chatRoom, message));
    }
}</code></pre>
</div>
<p>Here is the first test case:</p>
<div><pre><code>[Fact]
public void A_participant_should_be_able_to_list_the_participants_that_joined_a_chatroom()
{
    _reagen.Join(_room1);
    _reagen.Join(_room2);
    _garner.Join(_room1);
    _cornelia.Join(_room2);
    var room1Participants = _reagen.ListParticipantsOf(_room1);
    Assert.Collection(room1Participants,
        p =&gt; Assert.Same(_reagen, p),
        p =&gt; Assert.Same(_garner, p)
    );
}</code></pre>
</div>
<p>In the preceding test case, Reagen and Garner join Room 1, while Reagen and Cornelia join Room 2. Then Reagen requests the list of participants from Room 1, which outputs Reagen and Garner. Under the hood, it uses commands and queries through a mediator, breaking tight coupling between the colleagues. Here is a sequence diagram representing what happens when a participant joins a chatroom:</p>
<figure>
<img alt="Figure 16.10: Sequence diagram representing the flow of a participant (p) joining a chatroom (c)" src="img/file108.png"/><figcaption aria-hidden="true">Figure 16.10: Sequence diagram representing the flow of a participant (p) joining a chatroom (c)</figcaption>
</figure>
<ol>
<li>The participant (<code>p</code>) creates a <code>JoinChatRoom</code> command (<code>joinCmd</code>).</li>
<li><code>p</code> sends <code>joinCmd</code> through the mediator (<code>m</code>).</li>
<li><code>m</code> finds and dispatches <code>joinCmd</code> to its handler (<code>handler</code>).</li>
<li><code>handler</code> executes the logic (adds <code>p</code> to the chatroom).</li>
<li><code>joinCmd</code> ceases to exist afterward; commands are ephemeral.</li>
</ol>
<p>That means <code>Participant</code> never interacts directly with <code>ChatRoom</code> or other participants.Then a similar workflow happens when a participant requests the list of participants of a chatroom:</p>
<figure>
<img alt="Figure 16.11: Sequence diagram representing the flow of a participant (p) requesting the list of participants of a chatroom (c)" src="img/file109.png"/><figcaption aria-hidden="true">Figure 16.11: Sequence diagram representing the flow of a participant (p) requesting the list of participants of a chatroom (c)</figcaption>
</figure>
<ol>
<li><code>Participant</code> (<code>p</code>) creates a <code>ListParticipants</code> query (<code>listQuery</code>).</li>
<li><code>p</code> sends <code>listQuery</code> through the mediator (<code>m</code>).</li>
<li><code>m</code> finds and dispatches the query to its handler (<code>handler</code>).</li>
<li><code>handler</code> executes the logic (lists the participants of the chatroom).</li>
<li><code>listQuery</code> ceases to exist afterward; queries are also ephemeral.</li>
</ol>
<p>Once again, <code>Participant</code> does not interact directly with <code>ChatRoom</code>.Here is another test case where <code>Participant</code> sends a message to a chatroom, and another <code>Participant</code> receives it:</p>
<div><pre><code>[Fact]
public void A_participant_should_receive_new_messages()
{
    _reagen.Join(_room1);
    _garner.Join(_room1);
    _garner.Join(_room2);
    _reagen.SendMessageTo(_room1, "Hello!");
    Assert.Collection(_garnerMessageWriter.Output,
    line =&gt;
    {
        Assert.Equal(_room1, line.chatRoom);
        Assert.Equal(_reagen, line.message.Sender);
        Assert.Equal("Hello!", line.message.Message);
    }
  );
}</code></pre>
</div>
<p>In the preceding test case, Reagen joins Room 1 while Garner joins Rooms 1 and 2. Then Reagen sends a message to Room 1, and we verify that Garner received it once.The <code>SendMessageTo</code> workflow is very similar to the other one that we saw but with a more complex command handler:</p>
<figure>
<img alt="Figure 16.12: Sequence diagram representing the flow of a participant (p) sending a message (msg)to a chatroom (c)" src="img/file110.png"/><figcaption aria-hidden="true">Figure 16.12: Sequence diagram representing the flow of a participant (p) sending a message (msg)to a chatroom (c)</figcaption>
</figure>
<p>From that diagram, we can observe that we pushed the logic to the <code>Handler</code> class of the <code>SendChatMessage</code> feature. All the other actors work together with limited to no knowledge of each other.This demonstrates how CQS works with a mediator:</p>
<ol>
<li>A consumer (the participant in this case) creates a command (or a query).</li>
<li>The consumer sends that command through the mediator.</li>
<li>The mediator sends that command to one or more handlers, each executing their piece of logic for that command.</li>
</ol>
<p>You can explore the other test cases to familiarize yourself with the program and the concepts.</p>
<blockquote>
<p>You can debug the tests in Visual Studio; use breakpoints combined with <em>Step Into (F11)</em> and <em>Step Over (F10)</em> to explore the sample.</p>
</blockquote>
<p>I also created a <code>ChatModerator</code> instance that sends a message in a “moderator chatroom” when a message contains a word from the <code>badWords</code> collection. That test case executes multiple handlers for each <code>SendChatMessage.Command</code>. I’ll leave you to explore these other test cases yourself so we don’t wander astray from our goal.</p>


<h3 data-number="17.4.4">Conclusion</h3>
<p>The CQS and CQRS patterns suggest dividing the operations of a program into <strong>commands</strong> and <strong>queries</strong>. A command mutates data, and a query fetches data. We can apply the <strong>Mediator</strong> pattern to break the tight coupling between the pieces of a program using CQS, like sending commands and queries.Dividing the program this way helps separate the different pieces and focus on the commands and queries that travel from a consumer through the mediator to one or more handlers. The data contract of commands and queries becomes the program’s backbone, trimming down the coupling between objects and tying them to those thin data structures instead, leaving the central piece (the mediator) to manage the links between them.On the other hand, you may find the codebase more intimidating when using CQS due to the multiple classes. It adds some complexity, especially for a small program like this. However, each type does less (having a single responsibility), making it easier to test than a more sizable class with many responsibilities.Now let’s see how CQRS can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: Dividing an application into commands, queries, and handlers takes us toward encapsulating single responsibilities into different classes.</li>
<li><strong>O</strong>: CQS helps extend the software without modifying the existing code, such as adding handlers and creating new commands.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: CQS makes it easier to create multiple small interfaces with a clear distinction between commands, queries, and their respective handlers.</li>
<li><strong>D</strong>: N/A</li>
</ul>
<p>Now that we have explored CQRS, CQS, and the Mediator pattern, we explore the Marker Interfaces.</p>



<h2 data-number="17.5">Code smell – Marker Interfaces</h2>
<p>We used the empty <code>ICommand</code> and <code>IQuery&lt;TReturn&gt;</code> interfaces in the code samples to make the code more explicit and self-descriptive. Empty interfaces are a sign that something may be wrong: a code smell. We call those <strong>marker interfaces</strong>.In our case, they help identify commands and queries but are empty and add nothing. We could discard them without any impact on our system. On the other hand, we are not performing magic tricks or violating any principles, so they don’t harm but help define the intent. Moreover, we could leverage them to make the code more dynamic, like leveraging dependency injection to register handlers. Furthermore, I designed those interfaces this way as a bridge to the next project.Back to the marker interfaces, here are two types of marker interfaces that are code smells in C#:</p>
<ul>
<li>Metadata</li>
<li>Dependency identifier</li>
</ul>

<h3 data-number="17.5.1">Metadata</h3>
<p>Markers can be used to define metadata. A class “implements” the empty interface, and some consumer does something with it later. It could be an assembly scanning for specific types, a choice of strategy, or something else.Instead of creating marker interfaces to add metadata, try to use custom attributes. The idea behind attributes is to add metadata to classes and their members. On the other hand, interfaces exist to create a contract, and they should define at least one member; empty contracts are like a blank sheet.In a real-world scenario, you may want to consider the cost of one versus the other. Markers are very cheap to implement but can violate architectural principles. Attributes can be as cheap to implement if the mechanism is already implemented or supported by the framework but can cost much more than a marker interface, depending on the scenario. Before deciding, I recommend you evaluate the cost of both options.</p>


<h3 data-number="17.5.2">Dependency identifier</h3>
<p>If you need markers to inject some specific dependency in a particular class, you are most likely cheating the <strong>Inversion of Control</strong> principle. Instead, you should find a way to achieve the same goal using dependency injection, such as by contextually injecting your dependencies.Let’s start with the following interface:</p>
<div><pre><code>public interface IStrategy
{
    string Execute();
}</code></pre>
</div>
<p>In our program, we have two implementations and two markers, one for each implementation:</p>
<div><pre><code>public interface IStrategyA : IStrategy { }
public interface IStrategyB : IStrategy { }
public class StrategyA : IStrategyA
{
    public string Execute() =&gt; "StrategyA";
}
public class StrategyB : IStrategyB
{
    public string Execute() =&gt; "StrategyB";
}</code></pre>
</div>
<p>The code is barebones, but all the building blocks are there:</p>
<ul>
<li><code>StrategyA</code> implements <code>IStrategyA</code>, which inherits from <code>IStrategy</code>.</li>
<li><code>StrategyB</code> implements <code>IStrategyB</code>, which inherits from <code>IStrategy</code>.</li>
<li>Both <code>IStrategyA</code> and <code>IStrategyB</code> are empty marker interfaces.</li>
</ul>
<p>Now, the consumer needs to use both strategies, so instead of controlling dependencies from the composition root, the consumer requests the markers:</p>
<div><pre><code>public class Consumer
{
    public IStrategyA StrategyA { get; }
    public IStrategyB StrategyB { get; }
    public Consumer(IStrategyA strategyA, IStrategyB strategyB)
    {
        StrategyA = strategyA ?? throw new ArgumentNullException(nameof(strategyA));
        StrategyB = strategyB ?? throw new ArgumentNullException(nameof(strategyB));
    }
}</code></pre>
</div>
<p>The <code>Consumer</code> class exposes the strategies through properties to assert its composition later. Let’s test that out by building a dependency tree, simulating the composition root, and then asserting the value of the consumer properties:</p>
<div><pre><code>[Fact]
public void ConsumerTest()
{
    // Arrange
    var serviceProvider = new ServiceCollection()
        .AddSingleton&lt;IStrategyA, StrategyA&gt;()
        .AddSingleton&lt;IStrategyB, StrategyB&gt;()
        .AddSingleton&lt;Consumer&gt;()
        .BuildServiceProvider();
    // Act
    var consumer = serviceProvider.GetRequiredService&lt;Consumer&gt;();
    // Assert
    Assert.IsType&lt;StrategyA&gt;(consumer.StrategyA);
    Assert.IsType&lt;StrategyB&gt;(consumer.StrategyB);
}</code></pre>
</div>
<p>Both properties are of the expected type, but that is not the problem. The <code>Consumer</code> class controls what dependencies to use and when to use them by injecting markers A and B instead of two <code>IStrategy</code> instances. Due to that, we cannot control the dependency tree from the composition root. For example, we cannot change <code>IStrategyA</code> to <code>IStrategyB</code> and <code>IStrategyB</code> to <code>IStrategyA</code>, nor inject two <code>IStrategyB</code> instances or two <code>IStrategyA</code> instances, nor even create an <code>IStrategyC</code> interface to replace <code>IStrategyA</code> or <code>IStrategyB</code>.How do we fix this? Let’s start by deleting our markers and injecting two <code>IStrategy</code> instances instead (the changes are highlighted). After doing that, we end up with the following object structure:</p>
<div><pre><code>public class StrategyA : IStrategy
{
    public string Execute() =&gt; "StrategyA";
}
public class StrategyB : IStrategy
{
    public string Execute() =&gt; "StrategyB";
}
public class Consumer
{
    public IStrategy StrategyA { get; }
    public IStrategy StrategyB { get; }
    public Consumer(IStrategy strategyA, IStrategy strategyB)
    {
        StrategyA = strategyA ?? throw new ArgumentNullException(nameof(strategyA));
        StrategyB = strategyB ?? throw new ArgumentNullException(nameof(strategyB));
    }
}</code></pre>
</div>
<p>The <code>Consumer</code> class no longer controls the narrative with the new implementation, and the composition responsibility falls back to the composition root. Unfortunately, there is no way to do contextual injections using the default dependency injection container, and I don’t want to get into a third-party library for this. But all is not lost yet; we can use a factory to help ASP.NET Core build the <code>Consumer</code> instance, like this:</p>
<div><pre><code>// Arrange
var serviceProvider = new ServiceCollection()
    .AddSingleton&lt;StrategyA&gt;()
    .AddSingleton&lt;StrategyB&gt;()
    .AddSingleton(serviceProvider =&gt;
    {
        var strategyA = serviceProvider.GetRequiredService&lt;StrategyA&gt;();
        var strategyB = serviceProvider.GetRequiredService&lt;StrategyB&gt;();
        return new Consumer(strategyA, strategyB);
    })
    .BuildServiceProvider();
// Act
var consumer = serviceProvider.GetRequiredService&lt;Consumer&gt;();
// Assert
Assert.IsType&lt;StrategyA&gt;(consumer.StrategyA);
Assert.IsType&lt;StrategyB&gt;(consumer.StrategyB);</code></pre>
</div>
<p>From this point forward, we control the program’s composition, and we can swap A with B or do anything else that we want to, as long as the implementation respects the <code>IStrategy</code> contract.To conclude, using markers instead of doing contextual injection breaks the inversion of control principle, making the consumer control its dependencies. That’s very close to using the <code>new</code> keyword to instantiate objects. Inverting the dependency control back is easy, even using the default container.</p>
<blockquote>
<p>If you need to inject dependencies contextually, I started an open source project in 2020 that does that. Multiple other third-party libraries add features or replace the default IoC container altogether if needed. See the <em>Further reading</em> section.</p>
</blockquote>
<p>Next, we start the last part of this chapter. It showcases an open-source tool that can help us build CQS-oriented applications.</p>



<h2 data-number="17.6">Using MediatR as a mediator</h2>
<p>In this section, we are exploring MediatR, an open-source mediator implementation.What is MediatR? Let’s start with its maker’s description from its GitHub repository, which brands it as this:</p>
<blockquote>
<em>“Simple, unambitious mediator implementation in .NET”</em>
</blockquote>
<p>MediatR is a simple but very powerful tool doing in-process communication through messaging. It supports a request/response flow through commands, queries, notifications, and events, synchronously and asynchronously.We can install the NuGet package using the .NET CLI: <code>dotnet add package MediatR</code>.Now that I have quickly introduced the tool, we are going to explore the migration of our Clean Architecture sample but instead use MediatR to dispatch the <code>StocksController</code> requests to the core use cases. We use a similar pattern with MediatR than what we built in the CQS project.</p>
<blockquote>
<p>Why migrate our Clean Architecture sample? The primary reason we are building the same project using different models is for ease of comparison. It is much easier to compare the changes of the same features than if we were building completely different projects.</p>
</blockquote>
<p>What are the advantages of using MediatR in this case? It allows us to organize the code around use cases (vertically) instead of services (horizontally), leading to more cohesive features. We remove the service layer (the <code>StockService</code> class) and replace it with multiple use cases (features) instead (the <code>AddStocks</code> and <code>RemoveStock</code> classes). MediatR also enables a pipeline we can extend by programming behaviors. Those extensibility points allow us to manage cross-cutting concerns, such as requests validation centrally, without impacting the consumers and use cases. We explore request validation in <em>Chapter 17</em>, <em>Getting Started with Vertical Slice Architecture</em>.Let’s jump into the code now to see how it works.</p>

<h3 data-number="17.6.1">Project – Clean Architecture with MediatR</h3>
<p><strong>Context</strong>: We want to break some more of the coupling in the Clean Architecture project we built in <em>Chapter 14</em>, <em>Understanding Layering</em>, by leveraging the <strong>Mediator</strong> pattern and a <strong>CQS</strong> approach.The clean architecture solution was already solid, but MediatR will pave the way to more good things later. The only “major” change is the replacement of the <code>StockService</code> with two feature objects, <code>AddStocks</code> and <code>RemoveStocks</code>, which we explore soon.First, we must install the <code>MediatR</code> NuGet package in the <code>Core</code> project, where the features will live. Moreover, it will transiently cascade to the <code>Web</code> project, allowing us to register MediatR with the IoC container. In the <code>Program.cs</code> file, we can register MediatR like this:</p>
<div><pre><code>builder.Services
    // Core Layer
    .AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssemblyContaining&lt;NotEnoughStockException&gt;())
;</code></pre>
</div>
<p>That code scans the Core assembly for MediatR-compatible pieces and registers them with the IoC Container. The <code>NotEnoughStockException</code> class is part of the core project.</p>
<blockquote>
<p>I picked the <code>NotEnoughStockException</code> class but could have chosen any class from the <code>Core</code> assembly. There are more registration options.</p>
</blockquote>
<p>MediatR exposes the following types of messages (as of version 12):</p>
<ul>
<li><em>Request/response</em> that has one handler; perfect for commands and queries.</li>
<li><em>Notifications</em> that support multiple handlers; perfect for an event-based model applying the Publish-Subscribe pattern where a notification represents an event.</li>
<li><em>Request/response streams</em> that are similar to request/response but stream the response through the <code>IAsyncEnumerable&lt;T&gt;</code> interface.</li>
</ul>
<blockquote>
<p>We cover the Publish-Subscribe pattern in <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>.</p>
</blockquote>
<p>Now that everything we need related to MediatR is “magically” registered, we can look at the use cases that replace the <code>StockService</code>. Let’s have a look at the updated <code>AddStocks</code> code first:</p>
<div><pre><code>namespace Core.UseCases;
public class AddStocks
{
    public class Command : IRequest&lt;int&gt;
    {
        public int ProductId { get; set; }
        public int Amount { get; set; }
    }
    public class Handler : IRequestHandler&lt;Command, int&gt;
    {
        private readonly IProductRepository _productRepository;
        public Handler(IProductRepository productRepository)
        {
            _productRepository = productRepository ?? throw new ArgumentNullException(nameof(productRepository));
        }
        public async Task&lt;int&gt; Handle(Command request, CancellationToken cancellationToken)
        {
            var product = await _productRepository.FindByIdAsync(request.ProductId, cancellationToken);
            if (product == null)
            {
                throw new ProductNotFoundException(request.ProductId);
            }
            product.AddStock(request.Amount);
            await _productRepository.UpdateAsync(product, cancellationToken);
            return product.QuantityInStock;
        }
    }
}</code></pre>
</div>
<p>Since we covered both use cases in the previous chapters and the changes are very similar, we will analyze both together, after the <code>RemoveStocks</code> use case code:</p>
<div><pre><code>namespace Core.UseCases;
public class RemoveStocks
{
    public class Command : IRequest&lt;int&gt;
    {
        public int ProductId { get; set; }
        public int Amount { get; set; }
    }
    public class Handler : IRequestHandler&lt;Command, int&gt;
    {
        private readonly IProductRepository _productRepository;
        public Handler(IProductRepository productRepository)
        {
            _productRepository = productRepository ?? throw new ArgumentNullException(nameof(productRepository));
        }
        public async Task&lt;int&gt; Handle(Command request, CancellationToken cancellationToken)
        {
            var product = await _productRepository.FindByIdAsync(request.ProductId, cancellationToken);
            if (product == null)
            {
                throw new ProductNotFoundException(request.ProductId);
            }
            product.RemoveStock(request.Amount);
            await _productRepository.UpdateAsync(product, cancellationToken);
            return product.QuantityInStock;
        }
    }
}</code></pre>
</div>
<p>As you may have noticed in the code, I chose the same pattern to build the commands as I did with the CQS sample, so we have a class per use case containing two nested classes: <code>Command</code> and <code>Handler</code>. This structure makes for very clean code when you have a 1-on-1 relationship between the command class and its handler.Using the MediatR request/response model, the command (or query) becomes a request and must implement the <code>IRequest&lt;TResponse&gt;</code> interface. The handlers must implement the <code>IRequestHandler&lt;TRequest, TResponse&gt;</code> interface. Instead, we could implement the <code>IRequest</code> and <code>IRequestHandler&lt;TRequest&gt;</code> interfaces for a command that returns nothing (<code>void</code>).</p>
<blockquote>
<p>More options are part of MediatR, and the documentation is complete enough to dig deeper yourself.</p>
</blockquote>
<p>Let’s analyze the anatomy of the <code>AddStocks</code> use case. Here is the old code as a reference:</p>
<div><pre><code>namespace Core.Services;
public class StockService
{
    private readonly IProductRepository _repository;
    // Omitted constructor
    public async Task&lt;int&gt; AddStockAsync(int productId, int amount, CancellationToken cancellationToken)
    {
        var product = await _repository.FindByIdAsync(productId, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(productId);
        }
        product.AddStock(amount);
        await _repository.UpdateAsync(product, cancellationToken);
        return product.QuantityInStock;
    }
    // Omitted RemoveStockAsync method
}</code></pre>
</div>
<p>The first difference is that we moved the loose parameters (highlighted) into the <code>Command</code> class, which encapsulates the whole request:</p>
<div><pre><code>public class Command : IRequest&lt;int&gt;
{
    public int ProductId { get; set; }
    public int Amount { get; set; }
}</code></pre>
</div>
<p>Then the <code>Command</code> class specifies the handler’s expected return value by implementing the <code>IRequest&lt;TResponse&gt;</code> interface, where <code>TResponse</code> is an <code>int</code>. That gives us a typed response when sending the request through MediatR. This is not “pure CQS” because the command handler returns an integer representing the updated <code>QuantityInStock</code>. However, we could call that optimization since executing one command and one query would be overkill for this scenario (possibly leading to two database calls instead of one).I’ll skip the <code>RemoveStocks</code> use case to avoid repeating myself, as it follows the same pattern. Instead, let’s look at the consumption of those use cases. I omitted the exception handling to keep the code streamlined and because <code>try</code>/<code>catch</code> blocks would only add noise to the code in this case and hinder our study of the pattern:</p>
<div><pre><code>app.MapPost("/products/{productId:int}/add-stocks", async (
    int productId, 
    AddStocks.Command command, 
    IMediator mediator, 
    CancellationToken cancellationToken) =&gt;
{
    command.ProductId = productId;
    var quantityInStock = await mediator.Send(command, cancellationToken);
    var stockLevel = new StockLevel(quantityInStock);
    return Results.Ok(stockLevel);
});
app.MapPost("/products/{productId:int}/remove-stocks", async (
    int productId, 
    RemoveStocks.Command command, 
    IMediator mediator, 
    CancellationToken cancellationToken) =&gt;
{
    command.ProductId = productId;
    var quantityInStock = await mediator.Send(command, cancellationToken);
    var stockLevel = new StockLevel(quantityInStock);
    return Results.Ok(stockLevel);
});
// Omitted code
public record class StockLevel(int QuantityInStock);</code></pre>
</div>
<p>In both delegates, we inject an <code>IMediator</code> and a command object (highlighted). We also let ASP.NET Core inject a <code>CancellationToken</code>, which we pass to MediatR. The model binder loads the data from the HTTP request into the objects that we send using the <code>Send</code> method of the <code>IMediator</code> interface (highlighted). Then we map the result into the <code>StockLevel</code> DTO before returning its value and an HTTP status code of <code>200</code> <code>OK</code>. The <code>StockLevel</code> record class is the same as before.This example contains almost the same code as our CQS example, but we used MediatR instead of manually programming the pieces.</p>
<blockquote>
<p>The default model binder cannot load data from multiple sources. Because of that, we must inject <code>productId</code> and assign its value to the <code>command.ProductId</code> property manually. Even if both values could be taken from the body, the resource identifier of that endpoint would become less exhaustive (no <code>productId</code> in the URI).</p>
<blockquote>
<p>With MVC, we could create a custom model binder.</p>
</blockquote>
<blockquote>
<p>With minimal APIs, we could create a static <code>BindAsync</code> method to manually do the model binding, which is not very extensible and would tightly couple the <code>Core</code> assembly with the <code>HttpContext</code>. I suppose we will need to wait for .NET 9+ to get improvements into that field.</p>
</blockquote>
<blockquote>
<p>I’ve left a few links in the <em>further reading</em> section relating to this.</p>
</blockquote>
</blockquote>


<h3 data-number="17.6.2">Conclusion</h3>
<p>With MediatR, we packed the power of a CQS-inspired pipeline with the Mediator pattern into a Clean Architecture application. We broke the coupling between the request delegates and the use case handler (previously a service). A simple DTO, such as a command object, makes endpoints and controllers unaware of the handlers, leaving MediatR as the middleman between the commands and their handlers. Due to that, the handlers could change along the way without impacting the endpoint.Moreover, we could configure more interaction between the command and the handler with <code>IRequestPreProcessor</code>, <code>IRequestPostProcessor</code>, and <code>IRequestExceptionHandler</code>. These allow us to extend the MediatR request pipeline with cross-cutting concerns like validation and error handling.MediatR helps us follow the SOLID principles the same way as the Mediator and CQS patterns combined. The only drawback of the overall design, which has nothing to do with MediatR, is that we used the commands as the DTOs. We could create custom DTOs and map them to command objects. However, you will understand in the next chapter where I was heading with this transitory design.</p>



<h2 data-number="17.7">Summary</h2>
<p>In this chapter, we looked at the Mediator pattern, which allows us to cut the ties between collaborators, mediating the communication between them. Then we studied the CQS pattern, which advises the division of software behaviors into commands and queries. Those two patterns are tools that cut tight coupling between components.Afterward, we updated a Clean Architecture project to use MediatR, an open-source generic mediator that is CQS-oriented. There are many more possible uses than we explored, but this is still a great start. This concludes another chapter exploring techniques to break tight coupling and divide systems into smaller parts.All those building blocks lead us to the next chapter, where we piece those patterns and tools together to explore the Vertical Slice Architecture.</p>


<h2 data-number="17.8">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>What does the CQS stand for, and what is the purpose of this design pattern?</li>
<li>Can we use a mediator inside a colleague to call another colleague?</li>
<li>In CQS, can a command return a value?</li>
<li>How much does MediatR cost?</li>
<li>Imagine a design with a marker interface to add metadata to some classes. Do you think you should review that design?</li>
</ol>


<h2 data-number="17.9">Further reading</h2>
<p>Here are a few links to build on what we have learned in the chapter:</p>
<ul>
<li>MediatR: <a href="https://adpg.link/ZQap">https://adpg.link/ZQap</a></li>
<li>To get rid of setting <code>ProductId</code> manually in the Clean Architecture with MediatR project, you can use the open-source project <code>HybridModelBinding</code> or read the official documentation about custom model binding and implement your own:</li>
</ul>
<ol>
<li>Custom Model Binding in ASP.NET Core: <a href="https://adpg.link/65pb">https://adpg.link/65pb</a></li>
<li>Damian Edward’s MinimalApis.Extensions project on GitHub: <a href="https://adpg.link/M6zS">https://adpg.link/M6zS</a></li>
</ol>
<ul>
<li><code>ForEvolve.DependencyInjection</code> is an open-source project that adds support for contextual dependency injection and more: <a href="https://adpg.link/myW8">https://adpg.link/myW8</a></li>
</ul>


<h2 data-number="17.10">Answers</h2>
<ol>
<li>CQS stands for Command-Query Separation. It's a software design principle that separates operations that change the state of an object (commands) from those that return data (queries). This helps in minimizing side effects and preventing unexpected changes in program behavior.</li>
<li>Yes, you can. The goal of the Mediator pattern is to mediate communication between colleagues.</li>
<li>In the original sense of CQS: no, a command can’t return a value. The idea is that a query reads data while commands mutate data. A command can return a value in a looser sense of CQS. For example, nothing stops a create command from returning the created entity partially or totally. You can always trade a bit of modularity for a bit of performance.</li>
<li>MediatR is a free, open-source project licensed under Apache License 2.0.</li>
<li>Yes, you should. Using Marker Interfaces to add metadata is generally wrong. Nevertheless, you should analyze each use case individually, considering the pros and cons before jumping to a conclusion.</li>
</ol>


</body>
</html>
