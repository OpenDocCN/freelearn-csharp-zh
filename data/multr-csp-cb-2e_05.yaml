- en: Chapter 5. Using C# 6.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 使用 C# 6.0
- en: 'In this chapter, we will look through native asynchronous programming support
    in the C# 6.0 programming language. You will learn the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 C# 6.0 编程语言中的原生异步编程支持。你将学习以下技巧：
- en: Using the `await` operator to get asynchronous task results
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `await` 操作符获取异步任务结果
- en: Using the `await` operator in a lambda expression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 lambda 表达式中使用 `await` 操作符
- en: Using the `await` operator with consequent asynchronous tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `await` 操作符处理后续异步任务
- en: Using the `await` operator for the execution of parallel asynchronous tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `await` 操作符执行并行异步任务
- en: Handling exceptions in asynchronous operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步操作中的异常
- en: Avoiding the use of the captured synchronization context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用捕获的同步上下文
- en: Working around the `async void` method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `async void` 方法
- en: Designing a custom awaitable type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计自定义可等待类型
- en: Using the `dynamic` type with `await`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dynamic` 类型与 `await` 结合
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, you learned about the Task Parallel Library, the latest asynchronous
    programming infrastructure from Microsoft. It allows us to design our program
    in a modular manner, combining different asynchronous operations together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你学习了关于任务并行库（Task Parallel Library，TPL）的内容，这是微软最新的异步编程基础设施。它允许我们以模块化的方式设计程序，将不同的异步操作组合在一起。
- en: Unfortunately, it is still difficult to understand the actual program flow when
    reading such a program. In a large program, there will be numerous tasks and continuations
    that depend on each other, continuations that run other continuations, and continuations
    for exception handling. They are all gathered together in the program code in
    very different places. Therefore, understanding the sequence of which operation
    goes first and what happens next becomes a very challenging problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，阅读这样的程序仍然很难理解实际的程序流程。在一个大程序中，会有许多相互依赖的任务和延续，延续运行其他延续，以及用于异常处理的延续。它们都在程序代码的非常不同的地方聚集在一起。因此，理解哪个操作先执行以及接下来会发生什么成为一个非常具有挑战性的问题。
- en: Another issue to watch out for is whether the proper synchronization context
    is propagated to each asynchronous task that could touch user interface controls.
    It is only permitted to use these controls from the UI thread; otherwise, we would
    get a multithreaded access exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的问题是，是否将适当的同步上下文传播到每个可能接触用户界面控件的异步任务。仅允许从 UI 线程使用这些控件；否则，我们会得到一个多线程访问异常。
- en: Speaking about exceptions, we also have to use separate continuation tasks to
    handle errors that occur inside antecedent asynchronous operation or operations.
    This in turn results in complicated error-handling code that is spread through
    different parts of the code, not logically related to each other.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 说到异常，我们还需要使用单独的延续任务来处理在先前的异步操作或操作中发生的错误。这反过来又导致复杂的错误处理代码散布在代码的不同部分，彼此之间没有逻辑关系。
- en: To address these issues, the authors of C# introduced new language enhancements
    called **asynchronous functions** along with C# version 5.0\. They really make
    asynchronous programming simple, but at the same time, it is a higher level abstraction
    over TPL. As we mentioned in [Chapter 4](ch04.html "Chapter 4. Using the Task
    Parallel Library"), *Using the Task Parallel Library*, abstraction hides important
    implementation details and makes asynchronous programming easier at the cost of
    taking away many important things from a programmer. It is very important to understand
    the concept behind asynchronous functions to create robust and scalable applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，C# 的作者们引入了新的语言增强功能，称为 **异步函数**，与 C# 5.0 版本一起推出。它们确实使异步编程变得简单，但同时也提供了对
    TPL 的高级抽象。正如我们在[第四章](ch04.html "第四章 使用任务并行库")中提到的，*使用任务并行库*，抽象隐藏了重要的实现细节，以简化异步编程，但代价是程序员失去了许多重要的事物。理解异步函数背后的概念对于创建健壮和可扩展的应用程序非常重要。
- en: 'To create an asynchronous function, you first mark a method with the `async`
    keyword. It is not possible to have the `async` property or event accessor methods
    and constructors without doing this first. The code will look as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个异步函数，你首先需要使用 `async` 关键字标记一个方法。如果不这样做，将无法拥有 `async` 属性或事件访问器方法和构造函数。代码将如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another important fact is that asynchronous functions must return the `Task`
    or `Task<T>` type. It is possible to have `async void` methods, but it is preferable
    to use the `async Task` method instead. The only reasonable option to use `async
    void` functions is when using top-level UI control event handlers in your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事实是，异步函数必须返回 `Task` 或 `Task<T>` 类型。虽然可以存在 `async void` 方法，但最好使用 `async
    Task` 方法。唯一合理的使用 `async void` 函数的选项是在你的应用程序中使用顶级 UI 控制事件处理器。
- en: Inside a method marked with the `async` keyword, you can use the `await` operator.
    This operator works with tasks from TPL and gets the result of the asynchronous
    operation inside the task. The details will be covered later in the chapter. You
    cannot use the `await` operator outside the `async` method; there will be a compilation
    error. In addition, asynchronous functions should have at least one `await` operator
    inside their code. However, not having an `await` operator will lead to just a
    compilation warning, not an error.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记有 `async` 关键字的方法内部，你可以使用 `await` 操作符。这个操作符与 TPL 中的任务一起工作，并在任务内部获取异步操作的结果。这些细节将在本章后面进行介绍。你无法在
    `async` 方法外部使用 `await` 操作符；这将导致编译错误。此外，异步函数的代码中至少应该有一个 `await` 操作符。然而，如果没有 `await`
    操作符，只会产生编译警告，而不是错误。
- en: It is important to note that this method returns immediately after the line
    with the `await` call. In case of a synchronous execution, the executing thread
    will be blocked for 2 seconds and then return a result. Here, we wait asynchronously
    while returning a worker thread to a thread pool immediately after executing the
    `await` operator. After 2 seconds, we get the worker thread from a thread pool
    once again and run the rest of the asynchronous method on it. This allows us to
    reuse this worker thread to do some other work while these 2 seconds pass, which
    is extremely important for application scalability. With the help of asynchronous
    functions, we have a linear program control flow, but it is still asynchronous.
    This is both very comfortable and very confusing. The recipes in this chapter
    will help you learn every important aspect of asynchronous functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，此方法在 `await` 调用行之后立即返回。在同步执行的情况下，执行线程将被阻塞 2 秒，然后返回结果。在这里，我们异步等待，同时在执行
    `await` 操作符后立即将工作线程返回到线程池。2 秒后，我们再次从线程池中获取工作线程，并在其上运行异步方法的其余部分。这允许我们在这 2 秒内重用此工作线程来完成其他工作，这对于应用程序的可扩展性至关重要。借助异步函数，我们有一个线性的程序控制流，但它仍然是异步的。这既非常舒适又非常令人困惑。本章中的食谱将帮助你学习异步函数的每一个重要方面。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In my experience, there is a common misunderstanding about how programs work
    if there are two consecutive `await` operators in it. Many people think that if
    we use the await function on one asynchronous operation after another, they run
    in parallel. However, they actually run sequentially; the second one starts only
    when the first operation completes. It is very important to remember this, and
    later in the chapter, we will cover this topic in detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，如果程序中有两个连续的 `await` 操作符，人们通常对程序的工作方式有一个常见的误解。许多人认为，如果我们对一系列异步操作使用 `await`
    函数，它们将并行运行。然而，它们实际上是顺序执行的；第二个操作只有在第一个操作完成后才开始。这一点非常重要，我们将在本章后面详细讨论这个话题。
- en: There are a number of limitations connected with using `async` and `await` operators.
    In C# 5.0, for example, it is not possible to mark the console application's `Main`
    method as `async`; you cannot have the `await` operator inside a `catch`, `finally`,
    `lock`, or `unsafe` block. It is not allowed to have `ref` and `out` parameters
    on an asynchronous function. There are more subtleties, but these are the major
    points. In C# 6.0, some of these limitations have been removed; you can use `await`
    inside `catch` and `finally` blocks due to compiler internal enhancements.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 和 `await` 操作符存在一些限制。例如，在 C# 5.0 中，无法将控制台应用程序的 `Main` 方法标记为 `async`；你无法在
    `catch`、`finally`、`lock` 或 `unsafe` 块中使用 `await` 操作符。不允许在异步函数上有 `ref` 和 `out`
    参数。还有更多细微之处，但这些都是主要点。在 C# 6.0 中，一些这些限制已被移除；由于编译器内部增强，可以在 `catch` 和 `finally` 块中使用
    `await`。
- en: Asynchronous functions are turned into complex program constructs by the C#
    compiler behind the scenes. I intentionally will not describe this in detail;
    the resulting code is quite similar to another C# construct, called **iterators**,
    and is implemented as a sort of state machine. Since many developers have started
    using the `async` modifier almost on every method, I would like to emphasize that
    there is no sense in marking a method `async` if it is not intended to be used
    in an asynchronous or parallel manner. Calling the `async` method includes a significant
    performance hit, and the usual method call is going to be about 40 to 50 times
    faster as compared to the same method marked with the `async` keyword. Please
    be aware of that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，C# 编译器将异步函数转换为复杂的程序结构。我故意不会详细描述这一点；生成的代码与另一种称为 **迭代器** 的 C# 结构非常相似，并且实现为一种状态机。由于许多开发者几乎在每一个方法中都开始使用
    `async` 修饰符，我想强调，如果一个方法不是打算以异步或并行方式使用，那么标记方法为 `async` 没有意义。调用 `async` 方法会带来显著的性能损失，与使用
    `async` 关键字标记的相同方法相比，通常的方法调用将快 40 到 50 倍。请务必注意这一点。
- en: In this chapter, you will learn to use the C# `async` and `await` keywords to
    work with asynchronous operations. We will cover how to await asynchronous operations
    sequentially and parallelly. We will discuss how to use `await` in lambda expressions,
    how to handle exceptions, and how to avoid pitfalls when using the `async void`
    methods. To conclude the chapter, we will dive deep into synchronization context
    propagation and you will learn how to create your own awaitable objects instead
    of using tasks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 C# 的 `async` 和 `await` 关键字来处理异步操作。我们将介绍如何顺序和并行地等待异步操作，讨论如何在 lambda
    表达式中使用 `await`，如何处理异常，以及如何在使用 `async void` 方法时避免陷阱。为了结束本章，我们将深入研究同步上下文传播，您将学习如何创建自己的可等待对象而不是使用任务。
- en: Using the await operator to get asynchronous task results
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 await 操作符获取异步任务结果
- en: This recipe walks you through the basic scenario of using asynchronous functions.
    We will compare how to get an asynchronous operation result with TPL and with
    the `await` operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将引导您了解使用异步函数的基本场景。我们将比较如何使用 TPL 和 `await` 操作符来获取异步操作的结果。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe1`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步完成这个食谱，您将需要 Visual Studio 2015。没有其他先决条件。本食谱的源代码可以在 `BookSamples\Chapter5\Recipe1`
    中找到。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use the `await` operator in order to get asynchronous task results, perform
    the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `await` 操作符获取异步任务结果，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the program.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, we run two asynchronous operations. One of them is standard
    TPL-powered code and the second one uses the new `async` and `await` C# features.
    The `AsynchronyWithTPL` method starts a task that runs for 2 seconds and then
    returns a string with information about the worker thread. Then, we define a continuation
    to print out the asynchronous operation result after the operation is complete
    and another one to print the exception details in case errors occur. Finally,
    we return a task representing one of the continuation tasks and wait for its completion
    in the `Main` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们运行两个异步操作。其中一个是标准的 TPL 代码，另一个使用新的 `async` 和 `await` C# 功能。`AsynchronyWithTPL`
    方法启动一个运行 2 秒的任务，然后返回一个包含有关工作线程信息的字符串。然后，我们定义一个后续操作，在操作完成后打印异步操作的结果，另一个用于在发生错误时打印异常详细信息。最后，我们在
    `Main` 方法中返回一个表示其中一个后续任务的任务，并等待其完成。
- en: In the `AsynchronyWithAwait` method, we achieve the same result by using `await`
    with the task. It is as if we write just the usual synchronous code—we get the
    result from the task, print out the result, and catch an exception if the task
    is completed with errors. The key difference is that we actually have an asynchronous
    program. Immediately after using `await`, C# creates a task that has a continuation
    task with all the remaining code after the `await` operator and deals with exception
    propagation as well. Then, we return this task to the `Main` method and wait until
    it gets completed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsynchronyWithAwait`方法中，我们通过使用`await`与任务一起实现相同的结果。这就像我们只写了常规的同步代码——我们从任务中获取结果，打印结果，并在任务以错误完成时捕获异常。关键的区别是我们实际上有一个异步程序。在`await`使用后立即，C#会创建一个任务，该任务具有一个带有`await`操作符之后所有剩余代码的后续任务，并处理异常传播。然后，我们将此任务返回到`Main`方法并等待其完成。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that depending on the nature of the underlying asynchronous operation and
    the current synchronization context, the exact means of executing asynchronous
    code may differ. We will explain this later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据底层异步操作的性质和当前同步上下文，执行异步代码的确切方式可能不同。我们将在本章后面解释这一点。
- en: Therefore, we can see that the first and the second parts of the program are
    conceptually equivalent, but in the second part the C# compiler does the work
    of handling asynchronous code implicitly. It is, in fact, even more complicated
    than the first part, and we will cover the details in the next few recipes of
    this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到程序的第一部分和第二部分在概念上是等效的，但在第二部分中，C#编译器隐式地处理异步代码的工作。实际上，它比第一部分更复杂，我们将在本章接下来的几个菜谱中详细介绍。
- en: Remember that it is not recommended to use the `Task.Wait` and `Task.Result`
    methods in environments such as the Windows GUI or ASP.NET. This could lead to
    deadlocks if the programmer is not 100% aware of what is really going on in the
    code. This was illustrated in the *Tweaking the execution of tasks with TaskScheduler*
    recipe in [Chapter 4](ch04.html "Chapter 4. Using the Task Parallel Library"),
    *Using the Task Parallel Library*, when we used `Task.Result` in the WPF application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Windows GUI或ASP.NET等环境中不建议使用`Task.Wait`和`Task.Result`方法。如果程序员不是100%清楚代码中真正发生的事情，这可能导致死锁。这在本章4的*使用TaskScheduler微调任务执行*菜谱中得到了说明，当时我们在WPF应用程序中使用了`Task.Result`。
- en: To test how exception handling works, just uncomment the `throw new Exception`
    line inside the `GetInfoAsync` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试异常处理的工作方式，只需取消注释`GetInfoAsync`方法内的`throw new Exception`行。
- en: Using the await operator in a lambda expression
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在lambda表达式中使用`await`操作符
- en: This recipe will show you how to use `await` inside a lambda expression. We
    will write an anonymous method that uses `await` and get a result of the method
    execution asynchronously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将向您展示如何在lambda表达式中使用`await`。我们将编写一个使用`await`的匿名方法，并使用lambda表达式中的`await`操作符异步获取方法执行的结果。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe2`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成此菜谱，你需要Visual Studio 2015。没有其他先决条件。此菜谱的源代码可以在`BookSamples\Chapter5\Recipe2`中找到。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To write an anonymous method that uses `await` and get a result of the method
    execution asynchronously using the `await` operator in a lambda expression, perform
    the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个使用`await`的匿名方法，并使用lambda表达式中的`await`操作符异步获取方法执行的结果，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the program.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we move out the asynchronous function into the `AsynchronousProcessing`
    method, since we cannot use `async` with `Main`. Then, we describe a lambda expression
    using the `async` keyword. As the type of any lambda expression cannot be inferred
    from lambda itself, we have to specify its type to the C# compiler explicitly.
    In our case, the type means that our lambda expression accepts one string parameter
    and returns a `Task<string>` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将异步函数移动到`AsynchronousProcessing`方法中，因为我们不能在`Main`中使用`async`。然后，我们使用`async`关键字描述一个lambda表达式。由于任何lambda表达式的类型都不能从lambda本身推断出来，我们必须明确地将类型指定给C#编译器。在我们的情况下，类型意味着我们的lambda表达式接受一个字符串参数并返回一个`Task<string>`对象。
- en: Then, we define the lambda expression body. One aberration is that the method
    is defined to return a `Task<string>` object, but we actually return a string
    and get no compilation errors! The C# compiler automatically generates a task
    and returns it for us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义lambda表达式体。一个异常是，方法被定义为返回一个`Task<string>`对象，但实际上我们返回一个字符串，并且没有编译错误！C#编译器会自动为我们生成一个任务并返回它。
- en: The last step is to await the asynchronous lambda expression execution and print
    out the result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是等待异步lambda表达式执行并打印出结果。
- en: Using the await operator with consequent asynchronous tasks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`await`运算符与连续的异步任务
- en: This recipe will show you how exactly the program flows when we have several
    consecutive `await` methods in the code. You will learn how to read the code with
    the `await` method and understand why the `await` call is an asynchronous operation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向您展示当我们代码中有多个连续的`await`方法时，程序的确切流程。您将学习如何使用`await`方法阅读代码，并理解为什么`await`调用是一个异步操作。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe3`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步完成这个菜谱，您需要Visual Studio 2015。没有其他先决条件。这个菜谱的源代码可以在`BookSamples\Chapter5\Recipe3`中找到。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To understand a program flow in the presence of consecutive `await` methods,
    perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解存在连续`await`方法时的程序流程，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE8]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the program.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the program runs, we run two asynchronous operations just as we did in
    the first recipe. However, this time, we shall start from the `AsynchronyWithAwait`
    method. It still looks like the usual synchronous code; the only difference is
    the two `await` statements. The most important point is that the code is still
    sequential, and the `Async 2` task will start only after the previous one is completed.
    When we read the code, the program flow is very clear: we see what runs first
    and what goes after. Then, how is this program asynchronous? Well, first, it is
    not always asynchronous. If a task is already complete when we use `await`, we
    will get its result synchronously. Otherwise, the common approach when we see
    an `await` statement inside the code is to note that at this point, the method
    will return immediately and the rest of the code will be run in a continuation
    task. Since we do not block the execution, waiting for the result of an operation,
    it is an asynchronous call. Instead of calling `t.Wait` in the `Main` method,
    we can perform any other task while the code in the `AsynchronyWithAwait` method
    is being executed. However, the main thread must wait until all the asynchronous
    operations complete, or they will be stopped as they run on background threads.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们执行两个异步操作，就像我们在第一个菜谱中所做的那样。然而，这次，我们将从`AsynchronyWithAwait`方法开始。它看起来仍然像是常规的同步代码；唯一的区别是两个`await`语句。最重要的一点是，代码仍然是顺序的，`Async
    2`任务只有在前一个任务完成后才会开始。当我们阅读代码时，程序流程非常清晰：我们看到先运行什么，然后是什么接着运行。那么，这个程序是如何异步的呢？好吧，首先，它并不总是异步的。如果我们使用`await`时任务已经完成，我们将同步地得到其结果。否则，当我们看到代码中的`await`语句时，常见的做法是注意在这个点上，方法将立即返回，其余的代码将在一个延续任务中运行。由于我们没有阻塞执行，等待操作的结果，所以这是一个异步调用。我们可以在`AsynchronyWithAwait`方法执行时执行任何其他任务，而不是在`Main`方法中调用`t.Wait`。但是，主线程必须等待所有异步操作完成，否则它们将在后台线程上运行时被停止。
- en: The `AsynchronyWithTPL` method imitates the same program flow as the `AsynchronyWithAwait`
    method does. We need a container task to handle all the dependent tasks together.
    Then, we start the main task and add a set of continuations to it. When the task
    is complete, we print out the result; we then start one more task, which in turn
    has more continuations to continue work after the second task is complete. To
    test the exception handling, we throw an exception on purpose when running the
    second task and get its information printed out. This set of continuations creates
    the same program flow as in the first method, and when we compare it to the code
    with the `await` methods, we can see that it is much easier to read and understand.
    The only trick is to remember that asynchrony does not always mean parallel execution.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronyWithTPL`方法模仿`AsynchronyWithAwait`方法相同的程序流程。我们需要一个容器任务来处理所有依赖任务。然后，我们启动主任务，并向其添加一组后续任务。当任务完成时，我们打印出结果；然后我们再启动一个任务，该任务在第二个任务完成后继续工作。为了测试异常处理，我们在运行第二个任务时故意抛出异常，并打印出其信息。这组后续任务创建了与第一种方法相同的程序流程，当我们将其与使用`await`方法的代码进行比较时，我们可以看到它更容易阅读和理解。唯一的技巧是要记住，异步并不总是意味着并行执行。'
- en: Using the await operator for the execution of parallel asynchronous tasks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`await`运算符执行并行异步任务
- en: In this recipe, you will learn how to use `await` to run asynchronous operations
    in parallel instead of the usual sequential execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何使用`await`来并行运行异步操作，而不是通常的顺序执行。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe4`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可在`BookSamples\Chapter5\Recipe4`中找到。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the use of the `await` operator for parallel asynchronous task
    execution, perform the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`await`运算符在并行异步任务执行中的用法，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code below the `Main` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the program.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we define two asynchronous tasks running for 3 and 5 seconds, respectively.
    Then, we use a `Task.WhenAll` helper method to create another task that will be
    complete only when all of the underlying tasks get completed. Then, we await the
    result of this combined task. After 5 seconds, we get all the results, which means
    that the tasks were running simultaneously.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个异步任务，分别运行3秒和5秒。然后，我们使用`Task.WhenAll`辅助方法创建另一个任务，该任务只有在所有底层任务都完成后才会完成。然后，我们等待这个组合任务的结果。5秒后，我们得到所有结果，这意味着任务是在同时运行的。
- en: However, there is one interesting observation. When you run the program, you
    might note that both tasks are likely to be served by the same worker thread from
    a thread pool. How is this possible when we have run the tasks in parallel? To
    make things even more interesting, let's comment out the `await Task.Delay` line
    inside the `GetIntroAsync` method and uncomment the `await Task.Run` line, and
    then run the program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个有趣的观察。当你运行程序时，你可能会注意到这两个任务很可能由同一个线程池中的工作线程来服务。当我们并行运行任务时，这是如何可能的呢？为了使事情更有趣，让我们在`GetIntroAsync`方法中注释掉`await
    Task.Delay`行，并取消注释`await Task.Run`行，然后再次运行程序。
- en: 'We will see that in this case, both the tasks will be served by different worker
    threads. The difference is that `Task.Delay` uses a timer under the hood, and
    the processing goes as follows: we get the worker thread from a thread pool, which
    awaits the `Task.Delay` method to return a result. Then, the `Task.Delay` method
    starts the timer and specifies a piece of code that will be called when the timer
    counts the number of seconds specified to the `Task.Delay` method. Then, we immediately
    return the worker thread to a thread pool. When the timer event runs, we get any
    available worker thread from a thread pool once again (which could be the same
    thread that we used first) and run the code provided to the timer on it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在这种情况下，两个任务将由不同的工作线程提供服务。区别在于 `Task.Delay` 在底层使用计时器，处理过程如下：我们从线程池中获取工作线程，并等待
    `Task.Delay` 方法返回结果。然后，`Task.Delay` 方法启动计时器并指定当计时器计算到 `Task.Delay` 方法指定的秒数时将调用的代码片段。然后，我们立即将工作线程返回到线程池。当计时器事件运行时，我们再次从线程池中获取任何可用的工作线程（这可能是我们最初使用的工作线程）并在其上运行提供给计时器的代码。
- en: When we use the `Task.Run` method, we get a worker thread from a thread pool
    and make it block for a number of seconds, provided to the `Thread.Sleep` method.
    Then, we get a second worker thread and block it as well. In this scenario, we
    consume two worker threads and they do absolutely nothing, as they are not able
    to perform any other task while waiting.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Task.Run` 方法时，我们从线程池中获取一个工作线程，并使其阻塞几秒钟，这是提供给 `Thread.Sleep` 方法的。然后，我们获取第二个工作线程并使其也阻塞。在这种情况下，我们消耗了两个工作线程，它们实际上什么也没做，因为它们在等待时无法执行任何其他任务。
- en: We will talk in detail about the first scenario in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using Asynchronous I/O*, where we will discuss a large set
    of asynchronous operations working with data inputs and outputs. Using the first
    approach whenever possible is the key to creating scalable server applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 9 章](ch09.html "第 9 章。使用异步 I/O") *使用异步 I/O* 中详细讨论第一个场景，我们将讨论一组与数据输入和输出一起工作的异步操作。尽可能使用第一种方法是创建可扩展服务器应用程序的关键。
- en: Handling exceptions in asynchronous operations
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作中的异常处理
- en: This recipe will describe how to deal with exception handling using asynchronous
    functions in C#. You will learn how to work with aggregate exceptions in case
    you use `await` with multiple parallel asynchronous operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将描述如何使用 C# 中的异步函数处理异常。您将学习在您使用 `await` 与多个并行异步操作一起时如何处理聚合异常。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe5`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要 Visual Studio 2015。没有其他先决条件。此配方的源代码可以在 `BookSamples\Chapter5\Recipe5`
    中找到。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand handling exceptions in asynchronous operations, perform the following
    steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解异步操作中的异常处理，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中添加以下 `using` 指令：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE14]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE15]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We run four scenarios to illustrate the most common cases of error handling
    using `async` and `await` in C#. The first case is very simple and almost identical
    to the usual synchronous code. We just use the `try`/`catch` statement and get
    the exception's details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行四个场景来展示在 C# 中使用 `async` 和 `await` 进行错误处理的常见情况。第一个场景非常简单，几乎与常规同步代码相同。我们只是使用
    `try`/`catch` 语句来获取异常的详细信息。
- en: A very common mistake is using the same approach when more than one asynchronous
    operations are being awaited. If we use the `catch` block in the same way as we
    did before, we will get only the first exception from the underlying `AggregateException`
    object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的错误是在等待多个异步操作时使用相同的方法。如果我们像以前一样使用 `catch` 块，我们只会从底层的 `AggregateException`
    对象中获取第一个异常。
- en: To collect all the information, we have to use the awaited tasks' `Exception`
    property. In the third scenario, we flatten the `AggregateException` hierarchy
    and then unwrap all the underlying exceptions from it using the `Flatten` method
    of `AggregateException`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集所有信息，我们必须使用已等待任务的`Exception`属性。在第三种情况下，我们使用`AggregateException`的`Flatten`方法来展开`AggregateException`层次结构，然后从中解包所有底层异常。
- en: To illustrate C# 6.0 changes, we use `await` inside `catch` and `finally` blocks
    of the exception handling code. To verify that it was not possible to use `await`
    inside `catch` and `finally` blocks in the previous version of C#, you can compile
    it against C# 5.0 by specifying it in the project properties under the build section
    advanced settings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明C# 6.0的变化，我们在异常处理代码的`catch`和`finally`块中使用`await`。为了验证在C#的先前版本中无法在`catch`和`finally`块中使用`await`，您可以通过在项目属性的构建部分高级设置中指定它来编译它针对C#
    5.0。
- en: Avoiding the use of the captured synchronization context
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用捕获的同步上下文
- en: This recipe discusses the details of the synchronization context behavior when
    `await` is used to get asynchronous operation results. You will learn how and
    when to turn off the synchronization context flow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方讨论了使用`await`获取异步操作结果时同步上下文行为的详细信息。您将了解如何和何时关闭同步上下文流。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe6`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，您需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter5\Recipe6`中找到。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To understand the details of the synchronization context behavior when `await`
    is used and to learn how and when to turn off the synchronization context flow,
    perform the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用`await`时同步上下文行为的详细信息，以及学习如何和何时关闭同步上下文流，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'Add references to the Windows Presentation Foundation Library by following
    these steps:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤添加对Windows Presentation Foundation库的引用：
- en: Right-click on the **References** folder in the project, and select the **Add
    reference…** menu option.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目中的**引用**文件夹，并选择**添加引用…**菜单选项。
- en: 'Add references to these libraries: **PresentationCore**, **PresentationFramework**,
    **System.Xaml**, and **WindowsBase**. You can use the search function in the reference
    manager dialog as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下库的引用：**PresentationCore**、**PresentationFramework**、**System.Xaml**和**WindowsBase**。您可以使用引用管理器对话框中的搜索功能如下：
- en: '![How to do it...](img/B05292_05_01.jpg)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/B05292_05_01.jpg)'
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE16]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE17]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace the `Main` method with the following code snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Main`方法替换为以下代码片段：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the program.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we studied one of the most important aspects of an asynchronous
    function's default behavior. You already know about task schedulers and synchronization
    contexts from [Chapter 4](ch04.html "Chapter 4. Using the Task Parallel Library"),
    *Using the Task Parallel Library*. By default, the `await` operator tries to capture
    synchronization contexts and executes the preceding code on it. As we already
    know, this helps us write asynchronous code by working with user interface controls.
    In addition, deadlock situations, such as those that were described in the previous
    chapter, will not happen when using `await`, since we do not block the UI thread
    while waiting for the result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们研究了异步函数默认行为的一个重要方面。您已经从[第4章](ch04.html "第4章。使用任务并行库") *使用任务并行库* 中了解了任务调度器和同步上下文。默认情况下，`await`运算符会尝试捕获同步上下文并在其上执行前面的代码。正如我们已经知道的，这有助于我们通过操作用户界面控件来编写异步代码。此外，当使用`await`时，由于我们不会在等待结果时阻塞UI线程，因此不会发生死锁等情况，如前一章所述。
- en: This is reasonable, but let's see what can potentially happen. In this example,
    we create a Windows Presentation Foundation application programmatically and subscribe
    to its button-click event. When clicking on the button, we run two asynchronous
    operations. One of them uses a regular `await` operator, while the other uses
    the `ConfigureAwait` method with `false` as a parameter value. It explicitly instructs
    that we should not use captured synchronization contexts to run continuation code
    on it. Inside each operation, we measure the time they take to complete, and then,
    we display the respective time and ratios on the main screen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的，但让我们看看可能会发生什么。在这个例子中，我们通过编程创建了一个Windows Presentation Foundation应用程序，并订阅了其按钮点击事件。当点击按钮时，我们运行两个异步操作。其中一个使用常规的`await`运算符，而另一个使用带有`false`作为参数值的`ConfigureAwait`方法。它明确指示我们不应使用捕获的同步上下文在该上下文中运行后续代码。在每个操作内部，我们测量它们完成所需的时间，然后，在主屏幕上显示相应的时间和比率。
- en: As a result, we see that the regular `await` operator takes much more time to
    complete. This is because we post 100,000 continuation tasks on the UI thread,
    which uses its message loop to asynchronously work with those tasks. In this case,
    we do not need this code to run on the UI thread, since we do not access the UI
    components from the asynchronous operation; using `ConfigureAwait` with `false`
    will be a much more efficient solution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到常规的`await`运算符需要更多的时间来完成。这是因为我们在UI线程上发布了100,000个后续任务，该线程使用其消息循环异步处理这些任务。在这种情况下，我们不需要在UI线程上运行此代码，因为我们没有从异步操作中访问UI组件；使用带有`false`的`ConfigureAwait`将是一个更高效的解决方案。
- en: There is one more thing worth noting. Try to run the program by just clicking
    on the button and waiting for the results. Now, do the same thing again, but this
    time, click on the button and try to drag the application window from side to
    side in a random manner. You will note that the code on the captured synchronization
    context becomes slower! This funny side effect perfectly illustrates how dangerous
    asynchronous programming is. It is very easy to experience a situation like this,
    and it would be almost impossible to debug it if you have never experienced such
    a behavior before.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，还有一件事。尝试通过仅点击按钮并等待结果来运行程序。现在，再次执行同样的操作，但这次，点击按钮并尝试以随机方式拖动应用程序窗口的两侧。你会注意到捕获的同步上下文上的代码变慢了！这个有趣的副作用完美地说明了异步编程是多么危险。这种情况很容易发生，如果你以前从未遇到过这种行为，那么几乎不可能调试它。
- en: To be fair, let's see the opposite scenario. In the preceding code snippet,
    inside the `Click` method, uncomment the commented line and comment out the line
    immediately preceding it. When running the application, we will get a multithreaded
    control access exception because the code that sets the `Label` control text will
    not be posted on the captured context, but it will be executed on a thread pool
    worker thread instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 公平起见，让我们看看相反的情况。在上面的代码片段中，在`Click`方法内部，取消注释被注释的行，并注释掉紧随其后的行。当运行应用程序时，我们将遇到多线程控制访问异常，因为设置`Label`控件文本的代码不会在捕获的上下文中发布，而是会在线程池工作线程上执行。
- en: Working around the async void method
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决`async void`方法的问题
- en: This recipe describes why `async void` methods are quite dangerous to use. You
    will learn in what situations it is acceptable to use this method and what to
    use instead, when possible.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方描述了为什么`async void`方法非常危险。你将了解在什么情况下可以使用此方法，以及在可能的情况下应该使用什么替代方案。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe7`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此配方，你需要Visual Studio 2015。没有其他先决条件。此配方的源代码可以在`BookSamples\Chapter5\Recipe7`中找到。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To learn how to work with the `async void` method, perform the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用`async void`方法，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2015。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE19]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE20]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE21]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the program.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program starts, we start two asynchronous operations by calling the
    two methods, `AsyncTask` and `AsyncVoid`. The first method returns a `Task` object,
    while the other returns nothing since it is declared `async void`. They both return
    immediately since they are asynchronous, but then, the first one can be easily
    monitored with the returned task status or just by calling the `Wait` method on
    it. The only way to wait for the second method to complete is to literally wait
    for some time because we have not declared any object that we can use to monitor
    the state of the asynchronous operation. Of course, it is possible to use some
    kind of shared state variable and set it from the `async void` method while checking
    it from the `calling` method, but it is better to just return a `Task` object
    instead.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，我们通过调用两个方法 `AsyncTask` 和 `AsyncVoid` 来启动两个异步操作。第一个方法返回一个 `Task` 对象，而另一个由于声明为
    `async void` 而不返回任何内容。由于它们是异步的，所以它们都会立即返回，但第一个可以通过返回的任务状态或直接调用其上的 `Wait` 方法来轻松监控。等待第二个方法完成的唯一方法是实际等待一段时间，因为我们没有声明任何可以用来监控异步操作状态的对象。当然，可以使用某种类型的共享状态变量，并在
    `async void` 方法中设置它，同时从 `调用` 方法中检查它，但最好只是返回一个 `Task` 对象。
- en: The most dangerous part is exception handling. In case of the `async void` method,
    an exception will be posted to a current synchronization context; in our case,
    a thread pool. An unhandled exception on a thread pool will terminate the whole
    process. It is possible to intercept unhandled exceptions using the `AppDomain.UnhandledException`
    event, but there is no way to recover the process from there. To experience this,
    we should uncomment the `try`/`catch` block inside the `Main` method and then
    run the program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的部分是异常处理。在 `async void` 方法中，异常将被发送到当前同步上下文；在我们的例子中，是线程池。线程池上的未处理异常将终止整个进程。可以使用
    `AppDomain.UnhandledException` 事件来拦截未处理的异常，但无法从那里恢复进程。为了体验这一点，我们应该取消注释 `Main`
    方法内的 `try`/`catch` 块，然后运行程序。
- en: Another fact about using `async void` lambda expressions is that they are compatible
    with the `Action` type, which is widely used in the standard .NET Framework class
    library. It is very easy to forget about exception handling inside this lambda
    expression, which will crash the program again. To see an example of this, uncomment
    the second commented-out block inside the `Main` method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `async void` lambda 表达式的另一个事实是，它们与 `Action` 类型兼容，这在标准 .NET Framework 类库中广泛使用。很容易忘记这个
    lambda 表达式中的异常处理，这会导致程序再次崩溃。要查看此示例，取消注释 `Main` 方法中第二个注释掉的块。
- en: I strongly recommend using `async void` only in UI event handlers. In all other
    situations, use the methods that return `Task` instead.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议仅在 UI 事件处理器中使用 `async void`。在其他所有情况下，请使用返回 `Task` 的方法。
- en: Designing a custom awaitable type
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计自定义可等待类型
- en: This recipe shows you how to design a very basic awaitable type that is compatible
    with the `await` operator.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程向您展示如何设计一个与 `await` 操作符兼容的非常基本的可等待类型。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2015\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe8`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此过程，你需要 Visual Studio 2015。没有其他先决条件。此过程的源代码可以在 `BookSamples\Chapter5\Recipe8`
    中找到。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To design a custom awaitable type, perform the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设计自定义可等待类型，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，添加以下 `using` 指令：
- en: '[PRE22]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE23]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内添加以下代码片段：
- en: '[PRE24]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the program.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To be compatible with the `await` operator, a type should comply with a number
    of requirements that are stated in the C# language specification. If you have
    Visual Studio 2015 installed, you may find the specifications document inside
    the `C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC#\Specifications\1033`
    folder (assuming you have a 64-bit OS and used the default installation path).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 `await` 操作符兼容，类型应符合 C# 语言规范中声明的若干要求。如果您已安装 Visual Studio 2015，您可以在 `C:\Program
    Files (x86)\Microsoft Visual Studio 14.0\VC#\Specifications\1033` 文件夹中找到规范文档（假设您有一个
    64 位操作系统并使用了默认的安装路径）。
- en: 'In paragraph 7.7.7.1, we find a definition of awaitable expressions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 7.7.7.1 段落中，我们找到了关于可等待表达式的定义：
- en: '*The task of an* `await` *expression is required to be awaitable. An expression*
    `t` *is awaitable if one of the following holds:*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*`await` 表达式的任务是必须可等待的。一个表达式* `t` *是可等待的，如果以下任何一个条件成立：*'
- en: '`t` *is of compile time type dynamic*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` *是编译时类型 dynamic*'
- en: '`t` *has an accessible instance or extension method called* `GetAwaiter` *with
    no parameters and no type parameters, and a return type* `A` *for which all of
    the following hold:*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` *具有一个可访问的实例或扩展方法，名为* `GetAwaiter` *，没有参数和类型参数，返回类型为* `A` *，并且满足以下所有条件：*'
- en: '`A` *implements the interface* `System.Runtime.CompilerServices.INotifyCompletion`
    *(hereafter known as* `INotifyCompletion` *for brevity).*'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A` *实现了接口* `System.Runtime.CompilerServices.INotifyCompletion` *(以下简称为* `INotifyCompletion`
    *以节省篇幅)。*'
- en: '`A` *has an accessible, readable instance property* `IsCompleted` *of type*
    `bool`.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A` *具有一个可访问的、可读的实例属性* `IsCompleted` *，其类型为* `bool`。'
- en: '`A` *has an accessible instance method* `GetResult` *with no parameters and
    no type parameters*.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A` *具有一个可访问的实例方法* `GetResult` *，没有参数和类型参数*。'
- en: This information is enough to get started. First, we define an awaitable type
    `CustomAwaitable` and implement the `GetAwaiter` method. This in turn returns
    an instance of the `CustomAwaiter` type. `CustomAwaiter` implements the `INotifyCompletion`
    interface, has the `IsCompleted` property of the type `bool`, and has the `GetResult`
    method, which returns a `string` type. Finally, we write a piece of code that
    creates two `CustomAwaitable` objects and awaits both of them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息足以开始。首先，我们定义一个可等待类型 `CustomAwaitable` 并实现 `GetAwaiter` 方法。这反过来又返回 `CustomAwaiter`
    类型的实例。`CustomAwaiter` 实现了 `INotifyCompletion` 接口，具有 `bool` 类型的 `IsCompleted` 属性，并具有
    `GetResult` 方法，该方法返回 `string` 类型。最后，我们编写了一段代码，创建了两个 `CustomAwaitable` 对象，并等待它们两个。
- en: Now, we should understand the way `await` expressions are evaluated. This time,
    the specifications have not been quoted to avoid unnecessary details. Basically,
    if the `IsCompleted` property returns `true`, we just call the `GetResult` method
    synchronously. This prevents us from allocating resources for asynchronous task
    execution if the operation has already been completed. We cover this scenario
    by providing the `completeSynchronously` parameter to the constructor method of
    the `CustomAwaitable` object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该了解 `await` 表达式的评估方式。这次，为了避免不必要的细节，没有引用规范。基本上，如果 `IsCompleted` 属性返回 `true`，我们就同步调用
    `GetResult` 方法。这可以防止我们在操作已经完成的情况下为异步任务执行分配资源。我们通过向 `CustomAwaitable` 对象的构造函数方法提供
    `completeSynchronously` 参数来处理这种情况。
- en: Otherwise, we register a callback action to the `OnCompleted` method of `CustomAwaiter`
    and start the asynchronous operation. When it gets completed, it calls the provided
    callback, which will get the result by calling the `GetResult` method on the `CustomAwaiter`
    object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们在 `CustomAwaiter` 的 `OnCompleted` 方法上注册一个回调操作，并开始异步操作。当它完成时，它调用提供的回调，通过在
    `CustomAwaiter` 对象上调用 `GetResult` 方法来获取结果。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This implementation has been used for educational purposes only. Whenever you
    write asynchronous functions, the most natural approach is to use the standard
    `Task` type. You should define your own awaitable type only if you have a solid
    reason why you cannot use `Task` and you know exactly what you are doing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现仅用于教育目的。无论何时您编写异步函数，最自然的方法是使用标准的 `Task` 类型。您应该只定义自己的可等待类型，如果您有充分的理由不能使用 `Task`
    类型，并且确切地知道您在做什么。
- en: There are many other topics related to designing custom awaitable types, such
    as the `ICriticalNotifyCompletion` interface implementation and synchronization
    context propagation. After understanding the basics of how an awaitable type is
    designed, you will be able to use the C# language specification and other information
    sources to find out the details you need with ease. But I would like to emphasize
    that you should just use the `Task` type, unless you have a really good reason
    not to.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计自定义可等待类型相关的许多其他主题，例如 `ICriticalNotifyCompletion` 接口实现和同步上下文传播。在了解如何设计可等待类型的基本原理之后，您将能够轻松地使用
    C# 语言规范和其他信息源来查找您需要的详细信息。但我想强调，除非您有充分的理由不使用 `Task` 类型，并且确切地知道您在做什么，否则您应该只使用 `Task`
    类型。
- en: Using the dynamic type with await
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态类型与 await
- en: This recipe shows you how to design a very basic type that is compatible with
    the `await` operator and the dynamic C# type.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何设计一个与 `await` 操作符和动态 C# 类型兼容的非常基本的类型。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: To step through this recipe, you will need Visual Studio 2015\. You will need
    Internet access to download the NuGet package. There are no other prerequisites.
    The source code for this recipe can be found at `BookSamples\Chapter5\Recipe9`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步执行此食谱，你需要 Visual Studio 2015。你需要互联网访问来下载 NuGet 包。没有其他先决条件。此食谱的源代码可以在 `BookSamples\Chapter5\Recipe9`
    中找到。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To learn how to use the `dynamic` type with `await`, perform the following
    steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用 `dynamic` 类型与 `await` 结合，请执行以下步骤：
- en: Start Visual Studio 2015\. Create a new C# console application project.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 2015。创建一个新的 C# 控制台应用程序项目。
- en: 'Add references to the **ImpromptuInterface** NuGet package by following these
    steps:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤添加对 **ImpromptuInterface** NuGet 包的引用：
- en: Right-click on the **References** folder in the project, and select the **Manage
    NuGet Packages…** menu option.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目中的 **引用** 文件夹，并选择 **管理 NuGet 包…** 菜单选项。
- en: 'Now, add your preferred references to the **ImpromptuInterface NuGet** package.
    You can use the search function in the **Manage NuGet Packages** dialog as follows:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加您首选的 **ImpromptuInterface NuGet** 包引用。您可以在 **管理 NuGet 包** 对话框中使用搜索功能，如下所示：
- en: '![How to do it...](img/B05292_05_02.jpg)'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/B05292_05_02.jpg)'
- en: 'In the `Program.cs` file, use the following `using` directives:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，使用以下 `using` 指令：
- en: '[PRE25]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法下方添加以下代码片段：
- en: '[PRE26]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following code below the `Program` class definition:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program` 类定义下方添加以下代码：
- en: '[PRE27]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内部添加以下代码片段：
- en: '[PRE28]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the program.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we repeat the trick from the previous recipe but this time, with the help
    of dynamic expressions. We can achieve this goal with the help of NuGet—a package
    manager that contains many useful libraries. This time, we use a library that
    dynamically creates wrappers, implementing the interfaces we need.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重复使用之前食谱中的技巧，但这次，我们借助动态表达式。我们可以借助 NuGet——一个包含许多有用库的包管理器来实现这一目标。这次，我们使用一个动态创建包装器的库，实现我们需要的接口。
- en: To start with, we create two instances of the `ExpandoObject` type and assign
    them to dynamic local variables. These variables will be our `awaitable` and `awaiter`
    objects. Since an `awaitable` object just requires having the `GetAwaiter` method,
    there are no problems with providing it. `ExpandoObject` (combined with the `dynamic`
    keyword) allows us to customize itself and add properties and methods by assigning
    corresponding values. It is in fact a dictionary-type collection with keys of
    the type `string` and values of the type `object`. If you are familiar with the
    JavaScript programming language, you might note that this is very similar to JavaScript
    objects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们创建两个 `ExpandoObject` 类型的实例，并将它们分配给动态局部变量。这些变量将成为我们的 `awaitable` 和 `awaiter`
    对象。由于 `awaitable` 对象只需要有 `GetAwaiter` 方法，因此提供它没有问题。`ExpandoObject`（结合 `dynamic`
    关键字）允许我们自定义它，并通过分配相应的值添加属性和方法。实际上，它是一个具有 `string` 类型的键和 `object` 类型的值的字典类型集合。如果你熟悉
    JavaScript 编程语言，你可能会注意到这与 JavaScript 对象非常相似。
- en: Since `dynamic` allows us to skip compile-time checks in C#, `ExpandoObject`
    is written in such a way that if you assign something to a property, it creates
    a dictionary entry, where the key is the property name and a value is any value
    that is supplied. When you try to get the property value, it goes into the dictionary
    and provides the value that is stored in the corresponding dictionary entry. If
    the value is of the type `Action` or `Func`, we actually store a delegate, which
    in turn can be used like a method. Therefore, a combination of the `dynamic` type
    with `ExpandoObject` allows us to create an object and dynamically provide it
    with properties and methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `dynamic` 允许我们在 C# 中跳过编译时检查，`ExpandoObject` 被编写成这样：如果你将某个值赋给一个属性，它会在字典中创建一个条目，其中键是属性名，值是提供的任何值。当你尝试获取属性值时，它会进入字典，并提供了存储在相应字典条目中的值。如果值是
    `Action` 或 `Func` 类型，我们实际上存储了一个委托，这反过来又可以像方法一样使用。因此，`dynamic` 类型与 `ExpandoObject`
    的组合允许我们创建一个对象，并动态地为其提供属性和方法。
- en: Now, we need to construct our `awaiter` and `awaitable` objects. Let's start
    with `awaiter`. First, we provide a property called `Message` and an initial value
    to this property. Then, we define the `GetResult` method using a `Func<string>`
    type. We assign a lambda expression, which returns the `Message` property value.
    We then implement the `IsCompleted` property. If it is set to `true`, we can skip
    the rest of the work and proceed to our `awaitable` object that is stored in the
    `result` local variable. We just need to add a method returning the `dynamic`
    object and return our `awaiter` object from it. Then, we can use `result` as the
    `await` expression; however, it will run synchronously.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要构建我们的`awaiter`和`awaitable`对象。让我们从`awaiter`开始。首先，我们提供一个名为`Message`的属性，并为此属性提供一个初始值。然后，我们使用`Func<string>`类型定义`GetResult`方法。我们分配一个lambda表达式，它返回`Message`属性值。然后我们实现`IsCompleted`属性。如果它被设置为`true`，我们可以跳过其余的工作，并继续到存储在`result`局部变量中的`awaitable`对象。我们只需要添加一个返回`dynamic`对象的方法，并从其中返回我们的`awaiter`对象。然后，我们可以使用`result`作为`await`表达式；然而，它将同步运行。
- en: The main challenge is implementing asynchronous processing on our dynamic object.
    The C# language specifications state that an `awaiter` object must implement the
    `INotifyCompletion` or `ICriticalNotifyCompletion` interface, which `ExpandoObject`
    does not. And even when we implement the `OnCompleted` method dynamically, adding
    it to the `awaiter` object, we will not succeed because our object does not implement
    either of the aforementioned interfaces.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 主要挑战是在我们的动态对象上实现异步处理。C#语言规范指出，`awaiter`对象必须实现`INotifyCompletion`或`ICriticalNotifyCompletion`接口，而`ExpandoObject`不实现这些接口。即使我们动态地实现`OnCompleted`方法并将其添加到`awaiter`对象中，我们也不会成功，因为我们的对象没有实现上述任何一个接口。
- en: To work around this problem, we use the `ImpromptuInterface` library that we
    obtained from NuGet. It allows us to use the `Impromptu.ActLike` method to dynamically
    create proxy objects that will implement the required interface. If we try to
    create a proxy implementing the `INotifyCompletion` interface, we will still fail
    because the `proxy` object is not dynamic anymore, and this interface has the
    `OnCompleted` method only, but it does not have the `IsCompleted` property or
    the `GetResult` method. As the last workaround, we define a generic interface,
    `IAwaiter<T>`, which implements `INotifyCompletion` and adds all the required
    properties and methods. Now, we use it for proxy generation and change the `result`
    object to return a `proxy` instead of `awaiter` from the `GetAwaiter` method.
    The program now works; we just constructed an `awaitable` object that is completely
    dynamic at runtime.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用了从NuGet获取的`ImpromptuInterface`库。它允许我们使用`Impromptu.ActLike`方法动态创建实现所需接口的代理对象。如果我们尝试创建一个实现`INotifyCompletion`接口的代理，我们仍然会失败，因为`proxy`对象不再动态，而这个接口只有`OnCompleted`方法，但没有`IsCompleted`属性或`GetResult`方法。作为最后的解决方案，我们定义了一个泛型接口`IAwaiter<T>`，它实现了`INotifyCompletion`并添加了所有必需的属性和方法。现在，我们用它来生成代理，并将`result`对象从`GetAwaiter`方法返回的`awaiter`改为`proxy`。程序现在可以工作了；我们只是构建了一个在运行时完全动态的`awaitable`对象。
