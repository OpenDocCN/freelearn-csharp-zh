<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Visually Appealing User Interfaces</h1>
                
            
            
                
<p>While adding form elements to a View is simple, it takes somewhat more to produce an application that looks visually appealing. Luckily, <strong>Windows Presentation Foundation</strong> (<strong>WPF</strong>) provides us with many features that can help us to achieve this goal, such as gradient brushes, rounded corners, opacity control, layered visuals, and animations.</p>
<p>In this chapter, we'll take a look at a number of ways of using these elements in order to greatly improve the visual aspect of our applications. We'll investigate solutions that are simple to implement, using style properties, and other solutions that will take more work, such as animations and custom controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Styling applications consistently</h1>
                
            
            
                
<p>One of the easiest ways to make our applications stand out is to make them look unique. This can be achieved by defining custom styles for the controls that we use in it. However, if we decide to style our controls, it is essential that we style all of the controls that we use, as a half styled application can often look worse than an application that merely uses the default styles.</p>
<p>It is therefore absolutely essential that we design our application control styles consistently, in order to attain a professional look for our application. In this section, we'll discuss a number of tips and tricks to help us to implement these application styles.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Overriding default control styles</h1>
                
            
            
                
<p>When providing custom styles for our application controls, this typically requires us to define a new <kbd>ControlTemplate</kbd> element for each of them. As these can often be very large, it is customary to declare them in a separate resource file and merge it with the application resources in the <kbd>App.xaml</kbd> file, as shown in <a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, <em>Using the Right Controls for the Job</em>.</p>
<p>Before starting this task, we need to plan how we want our controls to look and then apply this same look to each control. Another mistake would be to customize different controls with different styles, as consistency is key to providing a professional look. For example, if we want our single-line textboxes to be a certain height, then we should also define our other controls to be the same height.</p>
<p>The custom styles that we declare for our controls can be part of our application framework. If we define them without naming them via the <kbd>x:Key</kbd> directive, they will be implicitly applied and so, the developers that utilize our application framework need not concern themselves with the look of each control, effectively freeing them up to concentrate on aggregating them into the various Views.</p>
<p>The first thing to do before starting to design our custom styles is to define a small range of colors that we will use in our application. Using too many colors in an application can make it look less professional, so we should choose a few shades of a small number of colors to use. There are a number of online tools that can help us to pick a color palette to use.</p>
<p>Once we have chosen our application colors, we should declare them, first, as <kbd>Color</kbd> objects in the <kbd>App.xaml</kbd> file, and then declare brush elements that use them, as most controls use brushes rather than colors. This has two benefits; using only these colors will promote consistency and if we ever need to change a color, we only need to change it in a single place:</p>
<pre>&lt;Color x:Key="ReadOnlyColor"&gt;#FF585858&lt;/Color&gt; 
...
&lt;SolidColorBrush x:Key="ReadOnlyBrush" 
  Color="{StaticResource ReadOnlyColor}" /&gt; </pre>
<p>It is often a good idea to also define multiple named styles for the most common types of controls. For example, having a <kbd>Label</kbd> style for <kbd>TextBlock</kbd> elements, that right aligns them and adds suitable margins, or a <kbd>Heading</kbd> style that sets a larger font size and heavier font weight. Providing the developers with a set of predefined styles helps to make the application look consistent.</p>
<p>When defining multiple named styles, it is common to reuse some of them in others. For example, if we have a default style for the <kbd>TextBox</kbd> control, we can base other style variations on it. Let's see some XAML examples:</p>
<pre>&lt;Style x:Key="TextBoxStyle" TargetType="{x:Type TextBox}"&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Margin" Value="0,0,0,5" /&gt; 
  &lt;Setter Property="Padding" Value="1.5,2" /&gt; 
  &lt;Setter Property="MinHeight" Value="25" /&gt; 
  &lt;Setter Property="TextWrapping" Value="Wrap" /&gt; 
  ... 
&lt;/Style&gt; 
&lt;Style x:Key="Max2LineTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource TextBoxStyle}"&gt; 
  &lt;Setter Property="MaxHeight" Value="44" /&gt; 
  &lt;Setter Property="VerticalScrollBarVisibility" Value="Auto" /&gt; 
  &lt;Setter Property="ToolTip" 
    Value="{Binding Text, RelativeSource={RelativeSource Self}}" /&gt;
&lt;/Style&gt; 
&lt;Style x:Key="Max3LineTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource Max2LineTextBoxStyle}"&gt; 
  &lt;Setter Property="MaxHeight" Value="64" /&gt; 
&lt;/Style&gt; 
&lt;Style x:Key="ReadOnlyTextBoxStyle" TargetType="{x:Type TextBox}"  
  BasedOn="{StaticResource TextBoxStyle}"&gt; 
  &lt;Setter Property="Background" Value="{StaticResource ReadOnlyBrush}" /&gt; 
  &lt;Setter Property="IsReadOnly" Value="True" /&gt; 
  &lt;Setter Property="Cursor" Value="Arrow" /&gt; 
&lt;/Style&gt; </pre>
<p>Here, the simplified <kbd>TextBoxStyle</kbd> style defines the majority of the properties for all <kbd>TextBox</kbd> controls. The <kbd>Max2LineTextBoxStyle</kbd> style inherits all of the property settings from this style and sets a few more that ensure that the vertical scrollbar can appear when required and enforce a maximum height for the control.</p>
<p>The <kbd>Max3LineTextBoxStyle</kbd> style extends the <kbd>Max2LineTextBoxStyle</kbd> style and so, inherits all of its property settings, as well as those of the <kbd>TextBoxStyle</kbd> style. It overrides the <kbd>MaxHeight</kbd> property that was set in the previous style. The <kbd>ReadOnlyTextBoxStyle</kbd> style also extends the <kbd>TextBoxStyle</kbd> style and sets properties to ensure that the control is read-only. Defining styles in this way ensures that controls in each View will remain consistent.</p>
<p>As well as defining default styles for our application controls, it is often also a good idea to provide default data template resources for each data Model in the application. In a similar way to the controls, predefining these data templates can result in improved consistency. We can also define a number of named templates to override the default ones with and use in different scenarios.</p>
<p>If there are a large number of data models in an application, it can be helpful to also declare their data templates in a separate resource file and merge it with the application resources in the <kbd>App.xaml</kbd> file, like to the default control templates. It is therefore not unusual to see multiple resource files being merged in the application resources file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using professional icons</h1>
                
            
            
                
<p>One thing that can often be underestimated when developing applications is the overall impact that a consistent set of decent icons can have. Using mis-matched icons that have been sourced from a number of different places can really make an otherwise professional looking application look far less professional.</p>
<p>If you or your company cannot afford to or will not for any other reason buy a set of custom icons, all is not lost. Visual Studio has long since offered sets of professional icons in a number of different formats, that we can utilize in our applications free of charge. These are the actual icons that are used in Visual Studio, Office and other Microsoft applications, so many users will already be familiar with them.</p>
<p>In older versions of Visual Studio, such as the 2010, or even 2008 versions, the provided image libraries were installed with the application and could be found at one of the following paths:</p>
<ul>
<li><kbd>C:\Program Files\Microsoft Visual Studio 9.0\Common7\VS2008ImageLibrary\1033</kbd></li>
<li><kbd>C:\Program Files\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033</kbd></li>
</ul>
<p>Note that on a 64 bit machine, this path would change to the following:</p>
<ul>
<li><kbd>C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\VS2010ImageLibrary\1033</kbd></li>
</ul>
<p>However, Microsoft changed how the image libraries could be accessed in newer versions of Visual Studio, from the 2012 version onwards. In these later versions, the image libraries were no longer included in the installation of Visual Studio. Instead, we have to search for <kbd>Visual Studio Image Library</kbd> and manually download them from the <strong>Microsoft</strong> website.</p>
<p>The newer icon sets also contain searchable Adobe Reader files that list the contents of the icon sets and provide links to the relevant folders of each of the icons. Most of the icons are also included in multiple sizes and so the newer libraries are much larger than the previous ones. </p>
<p>A few examples of the 2010 icons can be seen in the following image:</p>
<div><img class="alignnone size-full wp-image-2175 image-border" src="img/09b06e31-4096-49b5-b296-c3e365a1b914.png" style="width:53.17em;height:8.00em;"/></div>
<p>The following image shows the same icons, but in the flat style introduced in 2015:</p>
<div><img class="alignnone size-full wp-image-2415 image-border" src="img/30902505-d996-4831-8fd8-634663029cf5.jpg" style="width:53.17em;height:8.00em;"/></div>
<p class="packt_figure CDPAlignLeft CDPAlign">The following image shows how the flat style icons changed in 2017, for comparison:</p>
<div><img src="img/7286858f-fbf1-49ff-b711-1168980e9eca.png" style="width:54.67em;height:6.75em;"/></div>
<p class="CDPAlignLeft CDPAlign">Note that no image library was made available with Visual Studio 2019, so maybe this is a sign of things to come. However, the current collections of icons will cover most purposes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Layering visuals</h1>
                
            
            
                
<p>So far, we've just looked at simple redefinitions of the standard controls, by altering shapes, sizes, borders, and other common properties. However, we can do much more than that with WPF. Before continuing with this section, it is important to know that the more visuals each control is comprised of, the longer it will take to render them and so, this can negatively affect performance.</p>
<p>As such, it's important not to overdo the visual aspect of our controls if our application will be run on slow, old computers. Conversely, if we know that our end users will have plenty of RAM and/or graphics cards, then we can go the extra distance and develop visually stunning controls. Let's take a look at some techniques that we can use to improve the look of our controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Throwing shadows</h1>
                
            
            
                
<p>One of the easiest ways to make our UI elements pop out of the screen is to add a shadow to them. Each control has an <kbd>Effect</kbd> property that is inherited from the <kbd>UIElement</kbd> class. We can set an object of type <kbd>DropShadowEffect</kbd> to this property to add a shadow to our controls.</p>
<p>However, we must be conservative with the settings that we use on the <kbd>DropShadowEffect</kbd> element because this effect can be easily overdone. We also do not want to apply this effect to every control, as that would spoil the overall effect. It is most useful when setting on a panel that contains other controls, or on a border that surrounds such a panel. Let's see a simple example of applying this effect:</p>
<pre>&lt;Button Content="Click Me" Width="140" Height="34" FontSize="18"&gt; 
  &lt;Button.Effect&gt; 
    &lt;DropShadowEffect Color="Black" ShadowDepth="6" BlurRadius="6"  
      Direction="270" Opacity="0.5" /&gt; 
  &lt;/Button.Effect&gt; 
&lt;/Button&gt; </pre>
<p>Let's see what the output of this code looks like:</p>
<div><img class="alignnone size-full wp-image-2032 image-border" src="img/2b474d8e-e2de-4c43-a0a0-ab80d183dcb7.png" style="width:16.75em;height:7.83em;"/></div>
<p class="mce-root"/>
<p>In this example, we have a standard button with a <kbd>DropShadowEffect</kbd> element that is set as its <kbd>Effect</kbd> property. As we'll see later in in this chapter, the <kbd>DropShadowEffect</kbd> class has a number of uses, but its primary use is to create shadow effects.</p>
<p>When using this element for shadow effects, we generally want to set its <kbd>Color</kbd> property to black and its <kbd>Opacity</kbd> property to a value that is at least semi-transparent for best, or most realistic, results. The <kbd>ShadowDepth</kbd> property dictates how far from the element the shadow should fall. Along with the <kbd>BlurRadius</kbd> property, this property is used to add a sense of height to the element.</p>
<p>The <kbd>BlurRadius</kbd> property spreads out the shadow area while also making it less dense. Like the <kbd>ShadowDepth</kbd> property, this property has a default value of five. The <kbd>Direction</kbd> property specifies which direction the shadow should fall in, with a value of zero degrees making the shadow fall to the right and increasing values moving the shadow angle anti-clockwise.</p>
<p>Note that a value of <kbd>270</kbd> makes the shadow fall directly below the applied control and is often most suitable for use in business applications. Using this angle results in what appears to be an element that is hovering slightly above, or in front of, the screen, with a light source coming from above, which is the most natural direction for light to come from.</p>
<p>In contrast to this, an angle of <kbd>45</kbd> degrees for example, would place the shadow to the top right of the element and this would have the effect of telling the brain that there is a light source to the bottom left. However, this particular effect is unnatural looking and can detract from, rather than add to the styling of an application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaring multiple borders</h1>
                
            
            
                
<p>Another simple technique that we can use to make our controls stand out is to declare multiple <kbd>Border</kbd> elements for each control. By declaring one or more borders within an outer border, we can give our controls that professional look. We'll see how we can animate these borders differently when the user's mouse cursor is over the button later, but for now, let's see how we can create this effect:</p>
<pre>&lt;Grid Width="160" Height="68"&gt; 
  &lt;Grid.Background&gt; 
    &lt;LinearGradientBrush StartPoint="0,0" EndPoint="1,1"&gt; 
      &lt;GradientStop Color="Red" /&gt; 
      &lt;GradientStop Color="Yellow" Offset="1" /&gt; 
    &lt;/LinearGradientBrush&gt; 
  &lt;/Grid.Background&gt; 
  &lt;Button Content="Click Me" Width="120" Height="28" FontSize="14"  
    Margin="20"&gt; 
    &lt;Button.Template&gt; 
      &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
        &lt;Border BorderBrush="Black" BorderThickness="1"  
          Background="#7FFFFFFF" Padding="1" CornerRadius="5"  
          SnapsToDevicePixels="True"&gt; 
          &lt;Border BorderBrush="#7F000000" BorderThickness="1"  
            Background="White" CornerRadius="3.5"  
            SnapsToDevicePixels="True"&gt; 
            &lt;ContentPresenter HorizontalAlignment="Center"  
              VerticalAlignment="Center" /&gt; 
          &lt;/Border&gt; 
        &lt;/Border&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Button.Template&gt; 
  &lt;/Button&gt; 
&lt;/Grid&gt; </pre>
<p>In this example, we have declared a simple <kbd>ControlTemplate</kbd> element for our <kbd>Button</kbd> control to demonstrate the double border technique. Note that we would typically declare this template in the <kbd>Application.Resources</kbd> section of the <kbd>App.xaml</kbd> file, so that it could be reused, but we have declared it locally to save space here.</p>
<p>Note that we need to adjust the corner radius of the inner border to accurately fit within the outer border. If we had used the same size for both, they would not have correctly fit together. Also, we have set the <kbd>SnapsToDevicePixels</kbd> property to <kbd>true</kbd> on the two borders to ensure that they are not blurred by anti-aliasing artefacts.</p>
<p>One further point to note is that we have used <kbd>#7FFFFFFF</kbd> as the value for the background of the outer border and the border brush of the inner border. The alpha channel in this value is set to <kbd>7F</kbd>, which equates to an opacity value of <kbd>0.5</kbd>. This means that these elements will be partly transparent and so the colors from the background will partly show through the border edges.</p>
<p>We added our button into a <kbd>Grid</kbd> panel and set a <kbd>LinearGradientBrush</kbd> object as its background to demonstrate this semi-transparent effect. When rendered, our background gradient and button will look like the following image:</p>
<div><img class="alignnone size-full wp-image-2033 image-border" src="img/b436441f-bb8c-4a96-8ccb-ef4f5c39f9b4.png" style="width:16.17em;height:8.50em;"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Reusing composite visuals</h1>
                
            
            
                
<p>The next technique involves defining a particular motif that will be rendered in the background of our controls. This could be all or part of a company logo, a particular shape, or even just a simple, well-placed curve. This will form the bottom most level of our control visuals and can have additional levels of visuals on top. Let's take a look at one way in which we could implement such a design, starting with defining some resources:</p>
<pre>&lt;RadialGradientBrush x:Key="LayeredButtonBackgroundBrush" RadiusX="1.85"  
  RadiusY="0.796" Center="1.018,-0.115" GradientOrigin="0.65,- 0.139"&gt; 
  &lt;GradientStop Color="#FFCACACD" /&gt; 
  &lt;GradientStop Color="#FF3B3D42" Offset="1" /&gt; 
&lt;/RadialGradientBrush&gt; 
&lt;LinearGradientBrush x:Key="LayeredButtonCurveBrush" StartPoint="0,0"  
  EndPoint="1,1"&gt;
  &lt;GradientStop Color="#FF747475" Offset="0" /&gt; 
  &lt;GradientStop Color="#FF3B3D42" Offset="1" /&gt; 
&lt;/LinearGradientBrush&gt; 
&lt;Grid x:Key="LayeredButtonBackgroundElements"&gt; 
  &lt;Rectangle Fill="{StaticResource LayeredButtonBackgroundBrush}" /&gt; 
  &lt;Path StrokeThickness="0" 
    Fill="{StaticResource LayeredButtonCurveBrush}"&gt; 
    &lt;Path.Data&gt; 
      &lt;CombinedGeometry GeometryCombineMode="Intersect"&gt; 
        &lt;CombinedGeometry.Geometry1&gt; 
          &lt;EllipseGeometry Center="-20,50.7" RadiusX="185" RadiusY="46" /&gt;
        &lt;/CombinedGeometry.Geometry1&gt; 
        &lt;CombinedGeometry.Geometry2&gt; 
          &lt;RectangleGeometry Rect="0,0,106,24" /&gt; 
        &lt;/CombinedGeometry.Geometry2&gt; 
      &lt;/CombinedGeometry&gt; 
    &lt;/Path.Data&gt; 
  &lt;/Path&gt; 
&lt;/Grid&gt; 
&lt;VisualBrush x:Key="LayeredButtonBackground"  
  Visual="{StaticResource LayeredButtonBackgroundElements}" /&gt; </pre>
<p>There are a few elements to this design, so let's take a look at each one individually. We started by declaring a <kbd>RadialGradientBrush</kbd> element with the key <kbd>LayeredButtonBackgroundBrush</kbd> and a <kbd>LinearGradientBrush</kbd> with a key of <kbd>LayeredButtonCurveBrush</kbd>.</p>
<p>The <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties of the <kbd>RadialGradientBrush</kbd> element specify the <kbd>X</kbd> and <kbd>Y</kbd> radii of the outermost ellipse that encompasses the radial gradient, while the <kbd>Center</kbd> and <kbd>GradientOrigin</kbd> properties dictate the center and focal point of the radial gradient and enable us to position it precisely within our rectangle.</p>
<p>The <kbd>LinearGradientBrush</kbd> element has a <kbd>StartPoint</kbd> value of <kbd>0,0</kbd> and an <kbd>EndPoint</kbd> value of <kbd>1,1</kbd>, which results in a diagonal gradient. With this particular design, the idea is to have a sharp contrast between the two gradients at the center and to somewhat blend them together at the edges.</p>
<p>Next, we declare a <kbd>Grid</kbd> panel with the key <kbd>LayeredButtonBackgroundElements</kbd>, which contains a <kbd>Rectangle</kbd> and a <kbd>Path</kbd> element. The rectangle is stretched to fill the panel by default and is painted with the <kbd>LayeredButtonBackgroundBrush</kbd> resource. The <kbd>Path</kbd> element is painted with the <kbd>LayeredButtonCurveBrush</kbd> resource.</p>
<p>The <kbd>Data</kbd> property of the <kbd>Path</kbd> object is where we define the shape of the path. There are a number of ways that we can specify the path data; however, in this example, we use a <kbd>CombinedGeometry</kbd> element with a <kbd>GeometryCombineMode</kbd> value of <kbd>Intersect</kbd>, which outputs a single shape that represents the intersection of the two specified geometry shapes.</p>
<p>Inside the <kbd>CombinedGeometry</kbd> element, we have the <kbd>Geometry1</kbd> and <kbd>Geometry2</kbd> properties, where we combine the two geometry shapes according to the <kbd>Intersect</kbd> mode specified by the <kbd>GeometryCombineMode</kbd> property.</p>
<p>Our first shape defines the curve in our design and comes from an <kbd>EllipseGeometry</kbd> element, using the <kbd>Center</kbd> property to position the ellipse and the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties to shape it. The second shape is a rectangle that comes from a <kbd>RectangleGeometry</kbd> element and is defined by its <kbd>Rect</kbd> property.</p>
<p>The intersection of these two shapes is the result of this path and approximately covers the bottom section of our overall shape, up to the curve. The partly obscured rectangle element behind this completes the remainder of the overall shape.</p>
<p>The <kbd>Visual</kbd> property of the <kbd>VisualBrush</kbd> element with the <kbd>LayeredButtonBackground</kbd> key is set to the <kbd>LayeredButtonBackgroundElements</kbd> panel, so any UI element that is painted with this brush will now have this design imprinted on it. Once we have added these resources to the <kbd>Application.Resources</kbd> section in the <kbd>App.xaml</kbd> file, we can use them through the <kbd>VisualBrush</kbd> element, as follows:</p>
<pre>&lt;Button Background="{StaticResource LayeredButtonBackground}" Width="200"  
  Height="40" SnapsToDevicePixels="True" /&gt;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>This will render the gradients in the button background, like this:</p>
<div><img class="alignnone size-full wp-image-2034 image-border" src="img/b2245a20-d18a-4ec1-a932-ade30cc797cd.png" style="width:21.67em;height:8.33em;"/></div>
<p>In this example, we manually specify the reference to the visual brush to paint the <kbd>Button</kbd> object's background. However, setting the background in this way would require the developers that use our application framework to do this each time they add a button. A better solution would be to redesign the default button template so that the visual brush is automatically applied to each button. We'll see an example of this later in this chapter when we pull together a number of these techniques.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reflecting light</h1>
                
            
            
                
<p>Another technique involves adding a semi-opaque layer with a gradient that fades to transparency over the top of our controls to give the appearance of the reflection of a light source. This can easily be achieved using a simple <kbd>Border</kbd> element and a <kbd>LinearGradientBrush</kbd> instance. Let's look at how we can accomplish this:</p>
<pre>&lt;Button Content="Click Me" Width="140" Height="34" FontSize="18"  
  Foreground="White" Margin="20"&gt; 
  &lt;Button.Template&gt; 
    &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
      &lt;Border Background="#FF007767" CornerRadius="5"  
        SnapsToDevicePixels="True"&gt; 
        &lt;Grid&gt; 
          &lt;Rectangle RadiusX="4" RadiusY="4" Margin="1,1,1,7"  
            SnapsToDevicePixels="True"&gt; 
            &lt;Rectangle.Fill&gt; 
              &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1"&gt; 
                &lt;GradientStop Color="#BFFFFFFF" /&gt; 
                &lt;GradientStop Color="#00FFFFFF" Offset="0.8" /&gt; 
              &lt;/LinearGradientBrush&gt; 
            &lt;/Rectangle.Fill&gt; 
          &lt;/Rectangle&gt; 
          &lt;ContentPresenter HorizontalAlignment="Center"  
            VerticalAlignment="Center" /&gt; 
        &lt;/Grid&gt; 
      &lt;/Border&gt; 
    &lt;/ControlTemplate&gt; 
  &lt;/Button.Template&gt; 
&lt;/Button&gt; </pre>
<p>When run, this example will produce a button that looks like this:</p>
<div><img class="alignnone size-full wp-image-2035 image-border" src="img/489c3568-28ae-42ee-9b59-30c186132bcc.png" style="width:16.67em;height:7.83em;"/></div>
<p>Let's examine this example. We start by declaring the <kbd>Button</kbd> element with a few style properties. Rather than defining a separate style or control template in a resources section, as we would in a real-world application, we again declare the template inline to save space here.</p>
<p>In the control template, we first declare a <kbd>Border</kbd> element with a jade green background and a <kbd>CornerRadius</kbd> value of <kbd>5</kbd>. We again set the <kbd>SnapsToDevicePixels</kbd> property to <kbd>true</kbd> to ensure that the edges remain sharp.</p>
<p>Inside the border, we define two elements within a <kbd>Grid</kbd> panel. The first is the <kbd>Rectangle</kbd> element that produces the reflection effect and the second is the required <kbd>ContentPresenter</kbd> object. The rectangle uses a value of <kbd>4</kbd> in the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties and sets the <kbd>Margin</kbd> property appropriately to ensure that there is a tiny gap around the edge of the reflection.</p>
<p>It also sets its <kbd>SnapsToDevicePixels</kbd> property to true to ensure that this tiny gap is not blurred. Note that the value for the bottom margin is <kbd>7</kbd>, because we do not want the reflection effect to cover the bottom half of the button. The <kbd>Fill</kbd> property is where the reflection effect is actually created.</p>
<p>In the rectangle's <kbd>Fill</kbd> property, we define a vertical <kbd>LinearGradientBrush</kbd> element by setting both of the <kbd>X</kbd> values of the <kbd>StartPoint</kbd> and <kbd>EndPoint</kbd> properties and the <kbd>StartPoint.Y</kbd> property to <kbd>0</kbd> and the <kbd>Endpoint.Y</kbd> property to <kbd>1</kbd>; plotting these points on a graph will produce a vertical line, and so this produces a vertical gradient.</p>
<p>In the <kbd>GradientStops</kbd> collection of the <kbd>LinearGradientBrush</kbd> object, we have defined two <kbd>GradientStop</kbd> elements. The first has an offset of zero and is set to a white color with a hexadecimal alpha channel value of <kbd>BF</kbd>, which approximates an opacity value of <kbd>0.7</kbd>. The second has an offset of <kbd>0.8</kbd> and is set to a white color that has a hexadecimal alpha channel value of <kbd>00</kbd>, which results in a completely transparent color and could be replaced with the <kbd>Transparent</kbd> color.</p>
<p>The resulting gradient, therefore, starts slightly transparent at the top and is fully transparent at the bottom, which, with the bottom margin and offset values, is actually around the middle of the button. As with our other examples, the <kbd>ContentPresenter</kbd> object is declared afterwards so that it is rendered on top of the reflection effect.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating glowing effects</h1>
                
            
            
                
<p>Another effect that we can create for our controls is that of a glowing appearance, as if a light were shining outward from inside the control. We'll need another <kbd>LinearGradientBrush</kbd> instance and UI element to paint it on. A <kbd>Rectangle</kbd> element suits this role well, as it's very lightweight. We should define these resources in the application resources in the <kbd>App.xaml</kbd> file to enable every View to use them:</p>
<pre>&lt;TransformGroup x:Key="GlowTransformGroup"&gt; 
  &lt;ScaleTransform CenterX="0.5" CenterY="0.85" ScaleY="1.8" /&gt; 
  &lt;TranslateTransform Y="0.278" /&gt; 
&lt;/TransformGroup&gt; 
&lt;RadialGradientBrush x:Key="GreenGlow" Center="0.5,0.848"  
  GradientOrigin="0.5,0.818" RadiusX="-1.424" RadiusY="-0.622"  
  RelativeTransform="{StaticResource GlowTransformGroup}"&gt; 
  &lt;GradientStop Color="#CF65FF00" Offset="0.168" /&gt; 
  &lt;GradientStop Color="#4B65FF00" Offset="0.478" /&gt; 
  &lt;GradientStop Color="#0065FF00" Offset="1" /&gt; 
&lt;/RadialGradientBrush&gt; 
&lt;Style x:Key="GlowingButtonStyle" TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
        &lt;Border BorderBrush="White" BorderThickness="1"  
          Background="DarkGray" CornerRadius="3"&gt; 
          &lt;Grid&gt; 
            &lt;Rectangle IsHitTestVisible="False" RadiusX="2"
              RadiusY="2" Fill="{StaticResource GreenGlow}" /&gt; 
            &lt;ContentPresenter Content="{TemplateBinding Content}" 
              HorizontalAlignment="Center" VerticalAlignment="Center" /&gt; 
          &lt;/Grid&gt; 
          &lt;Border.Effect&gt; 
            &lt;DropShadowEffect Color="#FF65FF00" ShadowDepth="4"
              Opacity="0.4" Direction="270" BlurRadius="10" /&gt; 
          &lt;/Border.Effect&gt; 
        &lt;/Border&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>We start off by declaring a <kbd>TransformGroup</kbd> element that enables us to group one or more transform objects together. Inside it, we define a <kbd>ScaleTransform</kbd> element that scales applied elements vertically by the default factor of <kbd>1</kbd> and horizontally by a factor of <kbd>1.8</kbd>. We specify the center of this transformation using its <kbd>CenterX</kbd> and <kbd>CenterY</kbd> properties. Next, we declare a <kbd>TranslateTransform</kbd> element that moves applied elements downwards by a small amount.</p>
<p>After this, we define a <kbd>RadialGradientBrush</kbd> object that will represent the glow in our design. We use the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties to shape the brush element and specify the <kbd>Center</kbd> and <kbd>GradientOrigin</kbd> properties to dictate the center and focal point of the radial gradient.</p>
<p>We then set the <kbd>TransformGroup</kbd> element to the <kbd>RelativeTransform</kbd> property of the brush to apply the transforms to it. Note that the three <kbd>GradientStop</kbd> elements all use the same <kbd>R</kbd>, <kbd>G</kbd> and <kbd>B</kbd> values, and just differ in the alpha channel, or opacity values.</p>
<p>Next, we declare the <kbd>GlowingButtonStyle</kbd> style for type <kbd>Button</kbd>, setting the <kbd>SnapsToDevicePixels</kbd> property to <kbd>true</kbd>, to keep its lines crisp and sharp. In the <kbd>Template</kbd> property, we define a <kbd>ControlTemplate</kbd> element with a white <kbd>Border</kbd> element that has slightly rounded corners.</p>
<p>Inside the border, we declare a <kbd>Grid</kbd> panel containing a <kbd>Rectangle</kbd> and a <kbd>ContentPresenter</kbd> element. Again, the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties of the rectangle are set to a smaller value than that of the <kbd>CornerRadius</kbd> property of the parent border control to ensure that it fits evenly within it. Our <kbd>RadialGradientBrush</kbd> resource is assigned as the rectangle's <kbd>Fill</kbd> property.</p>
<p>The <kbd>ContentPresenter</kbd> object is centered to ensure that the content of the button will be rendered in its center. Returning to the <kbd>Border</kbd> element, we see a <kbd>DropShadowEffect</kbd> is declared within its <kbd>Effect</kbd> property. However, this element is not here to create a shadow effect; this class is multi-functional and can also render glowing effects as well as shadow effects.</p>
<p>The trick is to set its <kbd>Color</kbd> property to a color other than black and its <kbd>BlurRadius</kbd> property to a larger value than we would typically use when creating a shadow effect. In this particular case, we set the <kbd>Direction</kbd> property to <kbd>270</kbd> and the <kbd>ShadowDepth</kbd> property to <kbd>4</kbd> in order to position the glow effect toward the bottom of the border, where the light is supposed to be coming from.</p>
<p>Unfortunately, this effect does not translate to grayscale and paper well, so the glowing effect is somewhat lost when not viewed in color and on screen. For readers of the e-book version of this book, here is what the glowing effect from our example looks like:</p>
<div><img class="alignnone size-full wp-image-2036 image-border" src="img/ad149cc5-d086-44df-8589-8152a3b2abfd.png" style="width:15.08em;height:7.33em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Putting it all together</h1>
                
            
            
                
<p>While these various effects can improve the look of our controls on their own, the biggest improvement can be found when amalgamating a number of them into a single design. In this next example, we'll do just that. We first need to add a few more resources to use:</p>
<pre>&lt;SolidColorBrush x:Key="TransparentWhite" Color="#7FFFFFFF" /&gt; 
&lt;SolidColorBrush x:Key="VeryTransparentWhite" Color="#3FFFFFFF" /&gt; 
&lt;SolidColorBrush x:Key="TransparentBlack" Color="#7F000000" /&gt; 
&lt;SolidColorBrush x:Key="VeryTransparentBlack" Color="#3F000000" /&gt; 
&lt;VisualBrush x:Key="SemiTransparentLayeredButtonBackground"  
  Visual="{StaticResource LayeredButtonBackgroundElements}" 
  Opacity="0.65" /&gt; </pre>
<p>There isn't anything too complicated here. We simply have a number of colors defined with varying levels of transparency and a slightly transparent version of our visual brush that references our layered background elements. Let's move on to the encompassing style now:</p>
<pre>&lt;Style TargetType="{x:Type Button}"&gt; 
  &lt;Setter Property="SnapsToDevicePixels" Value="True" /&gt; 
  &lt;Setter Property="Cursor" Value="Hand" /&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
        &lt;Border CornerRadius="3" 
          BorderBrush="{StaticResource TransparentBlack}" 
          BorderThickness="1"  
          Background="{StaticResource TransparentWhite}"&gt; 
          &lt;Border Name="InnerBorder" CornerRadius="2"  
            Background="{StaticResource LayeredButtonBackground}" 
            Margin="1"&gt; 
            &lt;Grid&gt; 
              &lt;Rectangle IsHitTestVisible="False" RadiusX="2"
                RadiusY="2" Fill="{StaticResource GreenGlow}" /&gt;
              &lt;ContentPresenter Content="{TemplateBinding Content}"
                Margin="{TemplateBinding Padding}" 
                HorizontalAlignment="{TemplateBinding 
                HorizontalContentAlignment}" 
                VerticalAlignment="{TemplateBinding 
                VerticalContentAlignment}" /&gt; 
            &lt;/Grid&gt; 
          &lt;/Border&gt; 
          &lt;Border.Effect&gt; 
            &lt;DropShadowEffect Color="Black" ShadowDepth="6" 
              BlurRadius="6" Direction="270" Opacity="0.5" /&gt; 
          &lt;/Border.Effect&gt; 
        &lt;/Border&gt; 
        &lt;ControlTemplate.Triggers&gt; 
          &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
            &lt;Setter TargetName="InnerBorder"  
              Property="Background" Value="{StaticResource
              SemiTransparentLayeredButtonBackground}" /&gt; 
          &lt;/Trigger&gt; 
          &lt;Trigger Property="IsPressed" Value="True"&gt; 
            &lt;Setter TargetName="InnerBorder" Property="Background" 
              Value="{StaticResource LayeredButtonBackground}" /&gt; 
          &lt;/Trigger&gt; 
        &lt;/ControlTemplate.Triggers&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>Looking at the example XAML, we can see that the <kbd>SnapsToDevicePixels</kbd> property is set to <kbd>true</kbd>, to avoid anti-aliasing artifacts blurring the edges of the button, and the <kbd>Cursor</kbd> property is set to display the pointing finger cursor when the user's mouse is over the button.</p>
<p>Within the control template, we see the two nested <kbd>Border</kbd> elements. Note that the outer border uses the <kbd>TransparentBlack</kbd> and <kbd>TransparentWhite</kbd> brush resources so that it is semi-transparent. Also, note that the white inner border actually comes from the background of the outer border rather than the inner border, which sets the <kbd>Margin</kbd> property to <kbd>1</kbd> to give the impression of an inner border.</p>
<p>In this example, the inner border element is only responsible for displaying the layered button elements from the visual brush and has no displayed border of its own. Again, we have adjusted its <kbd>CornerRadius</kbd> property so that it fits neatly within the outer border. We can zoom in on the magnification level in the WPF designer to help us to decide what values we should use here.</p>
<p>Inside the inner border, we declare a <kbd>Grid</kbd> panel, so that we can add both the required <kbd>ContentPresenter</kbd> and the <kbd>Rectangle</kbd> element that is painted with the <kbd>GreenGlow</kbd> brush from the resources. Again, we set its <kbd>IsHitTestVisible</kbd> property to <kbd>false</kbd>, so that users cannot interact with it and set the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties to match the <kbd>CornerRadius</kbd> value of the inner border.</p>
<p>We use <kbd>TemplateBinding</kbd> elements to map properties of the <kbd>ContentPresenter</kbd> object to suitable properties from the templated object so that setting properties on our button can affect its positioning and content. Next, we set the previously displayed <kbd>DropShadowEffect</kbd> element to the <kbd>Effect</kbd> property of the outer border and that sums up the contained UI elements in the template.</p>
<p>To make the template more useful, we have set some <kbd>Trigger</kbd> objects in the <kbd>ControlTemplate.Triggers</kbd> collection, that will add mouse over effects for our button. The first trigger targets the <kbd>IsMouseOver</kbd> property and sets the background of the inner border to the slightly more transparent version of the layered button elements visual brush when true.</p>
<p>The second trigger targets the <kbd>IsPressed</kbd> property and re-applies the original visual brush when the property is true. Note that these two triggers must be defined in this order, so that the one that targets the <kbd>IsPressed</kbd> property will override the other when both conditions are true. It is of course, a matter of taste, whether the button lights up or goes out when clicked, or perhaps even changes color.</p>
<p>Note that we omitted the <kbd>x:Key</kbd> directive on this style so that it will be implicitly applied to all <kbd>Button</kbd> elements that do not have a different style explicitly applied to them. We are, therefore, able to declare our <kbd>Button</kbd> elements without specifying the style, like the following code snippet:</p>
<pre>&lt;Button Content="Click Me" Width="200" Height="40" FontSize="20"  
  Foreground="White" /&gt; </pre>
<p>This results in the following visual output:</p>
<div><img class="alignnone size-full wp-image-2037 image-border" src="img/a290a5d8-c832-4018-8e76-f4f183565601.png" style="width:21.75em;height:8.33em;"/></div>
<p>We could take this glowing idea further too, by defining a number of different color resources and using data triggers inside a data template to change the color of the glow to indicate different states of a data object. This enables us to provide further visual information to the users, in addition to the usual textual feedback methods.</p>
<p>For example, a blue glow on a data Model object could specify an unchanged object, while green could signify an object with valid changes and red could highlight an object in error. We'll see how we can implement this idea in the next chapter, but for now, let's continue looking at different ways to make our applications stand out from the crowd.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving away from the ordinary</h1>
                
            
            
                
<p>The vast majority of business applications in general, look fairly ordinary, with various form pages containing banks of standard rectangular form fields. Visually appealing applications on the other hand, stand out from the crowd. Therefore, in order to create visually appealing applications, we need to move away from the ordinary.</p>
<p>Whether this means simply adding control templates with rounded corners for our controls or something more is up to you. There are many different ways that we can enhance the look of our controls and we'll take a look at a number of these ideas in this section. Let's start with a refection effect that is best suited for use with logos or startup and background images.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Casting reflections</h1>
                
            
            
                
<p>All <kbd>FrameworkElement</kbd>-derived classes have a <kbd>RenderTransform</kbd> property that we can utilize to transform their rendered output in a variety of ways. A <kbd>ScaleTransform</kbd> element enables us to scale each object in both horizontal and vertical directions. One useful facet about the <kbd>ScaleTransform</kbd> object is that we can also scale negatively, and therefore reverse the visual output.</p>
<p>One visually pleasing effect that we can create with this particular facet is a mirror image, or reflection, of the object. In order to enhance this effect, we can use an opacity mask to fade out the reflection as it recedes from the object. This can give the visual impression of an object being reflected on a shiny surface, as shown in the following image:</p>
<div><img class="alignnone size-full wp-image-2038 image-border" src="img/66ac37ab-3ec6-4727-a887-664fbc9d9344.png" style="width:34.17em;height:9.33em;"/></div>
<p>Let's see how we can achieve this result:</p>
<pre>&lt;StackPanel HorizontalAlignment="Center" VerticalAlignment="Center"  
  Width="348"&gt; 
  &lt;TextBlock Name="TextBlock" FontFamily="Candara" 
    Text="APPLICATION NAME" FontSize="40" FontWeight="Bold"&gt; 
    &lt;TextBlock.Foreground&gt; 
      &lt;LinearGradientBrush StartPoint="0,0" EndPoint="1,0"&gt; 
        &lt;GradientStop Color="Orange" /&gt; 
        &lt;GradientStop Color="Red" Offset="0.5" /&gt; 
        &lt;GradientStop Color="Orange" Offset="1" /&gt; 
      &lt;/LinearGradientBrush&gt; 
    &lt;/TextBlock.Foreground&gt; 
  &lt;/TextBlock&gt; 
  &lt;Rectangle Height="31" Margin="0,-11.6,0,0"&gt; 
    &lt;Rectangle.Fill&gt; 
      &lt;VisualBrush Visual="{Binding ElementName=TextBlock}"&gt; 
        &lt;VisualBrush.RelativeTransform&gt; 
          &lt;ScaleTransform ScaleY="-1.0" CenterX="0.5" CenterY="0.5" /&gt; 
        &lt;/VisualBrush.RelativeTransform&gt; 
      &lt;/VisualBrush&gt; 
    &lt;/Rectangle.Fill&gt; 
    &lt;Rectangle.OpacityMask&gt; 
      &lt;LinearGradientBrush StartPoint="0,0" EndPoint="0,1"&gt; 
        &lt;GradientStop Color="#DF000000" /&gt; 
        &lt;GradientStop Color="Transparent" Offset="0.8" /&gt; 
      &lt;/LinearGradientBrush&gt; 
    &lt;/Rectangle.OpacityMask&gt; 
  &lt;/Rectangle&gt; 
&lt;/StackPanel&gt; </pre>
<p>In this example, we use a <kbd>StackPanel</kbd> object to position a <kbd>TextBlock</kbd> element above a <kbd>Rectangle</kbd> element. The text will be the object to reflect and the reflection will be generated in the rectangle. The panel's width is constrained to ensure that the reflection fits the text element exactly. We start by naming the <kbd>TextBlock</kbd> element and setting some typeface properties, along with the text to output.</p>
<p>We've set a <kbd>LinearGradientBrush</kbd> object as the color for the text to make it more interesting, although this plays no part in creating the reflection effect. Next, note that the <kbd>Rectangle</kbd> element is sized and positioned exactly to fit the size of the text from the <kbd>TextBlock</kbd> element. We can of course use this technique to reflect anything and are not restricted to just reflecting text elements.</p>
<p>The background of the rectangle is painted with a <kbd>VisualBrush</kbd> object, where the <kbd>Visual</kbd> property is data bound to the visual output of the <kbd>TextBlock</kbd> element, using the <kbd>ElementName</kbd> property. Note the <kbd>RelativeTransform</kbd> property of the <kbd>VisualBrush</kbd> object, enables us to transform the visual in some way and is set to an instance of the <kbd>ScaleTransform</kbd> class.</p>
<p>This is one of the most important constituents for creating this effect, as this element is what inverts the related visual in the vertical plane. Setting the <kbd>ScaleY</kbd> property to <kbd>-1</kbd> will invert the visual vertically for us, while setting the <kbd>ScaleX</kbd> property to <kbd>-1</kbd> would invert the visual horizontally. Note that we omit the <kbd>ScaleX</kbd> property here because we want it set at its default value of <kbd>1</kbd>.</p>
<p>Next, we see the <kbd>OpacityMask</kbd> property, which lets us set a gradient brush to be mapped to the opacity of the rectangle. When the alpha channel of the brush is <kbd>1</kbd>, the rectangle will be opaque, when it is <kbd>0</kbd>, the rectangle will be transparent and when it is in between, the rectangle will be semi-transparent. This is the other essential part of this effect and creates the fade of the reflected image.</p>
<p>In our example, we have a vertical gradient that is almost solid black at the top and gets increasingly transparent until it reaches four fifths of the way down, where it becomes fully transparent. When set as the rectangle's <kbd>OpacityMask</kbd>, only the alpha channel values are used and this results in it being totally visible at the top and then fading to invisibility four fifths of the way down, as shown in the preceding image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring borderless windows</h1>
                
            
            
                
<p>Using WPF, it is possible to create windows without borders, a title bar, and the standard minimize, restore and close buttons. It is also possible to create irregular shaped windows and windows with transparent areas that display whatever lies beneath. Although it would be somewhat unconventional to make our main application window borderless, we can still take advantage of this ability.</p>
<p>For example, we could create a borderless window for custom message boxes, or perhaps for extended tooltips, or any other popup control that provides information to the end user. Creating borderless windows can be achieved in a few simple steps. Let's start with the basics and assume that we're adding this to our existing application framework.</p>
<p>In this case, we've already got our <kbd>MainWindow</kbd> class and need to add an additional window. As we saw in <a href="c60a6db9-4352-4eb3-ac1d-406fd337b1b4.xhtml">Chapter 6</a>, <em>Adapting the Built-In Controls</em>, we can do this by adding a new <kbd>UserControl</kbd> to our project and replacing the word <kbd>UserControl</kbd> with the word <kbd>Window</kbd>, <em>in both the XAML file and its associated code behind file</em>. Failure to change both will result in a design time error that complains about mismatched classes.</p>
<p>Alternatively, we can right click on the start up project and select Add and then Window…, and then cut and paste it wherever you want it to reside. Unfortunately, Visual Studio provides no other way to add a <kbd>Window</kbd> control into our other projects.</p>
<p>Once we have our <kbd>Window</kbd> object, all we need to do is to set its <kbd>WindowStyle</kbd> property to <kbd>None</kbd> and its <kbd>AllowsTransparency</kbd> property to <kbd>true</kbd>. This will result in the white background of our window appearing:</p>
<pre>&lt;Window  
  x:Class="CompanyName.ApplicationName.Views.Controls.BorderlessWindow"    
   
   
  Height="100" Width="200" WindowStyle="None" AllowsTransparency="True"&gt; 
&lt;/Window&gt;

...

using System.Windows; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class BorderlessWindow : Window 
  { 
    public BorderlessWindow() 
    { 
      InitializeComponent(); 
    } 
  } 
} </pre>
<p>However, while this removes the default window chrome that we are all used to and provides us with a borderless window, it also removes the standard buttons, so we are unable to close, resize, or even move the window directly. Luckily, making our window moveable is a very simple matter. We just need to add the following line of code into our window's constructor after the <kbd>InitializeComponent</kbd> method is called:</p>
<pre>MouseLeftButtonDown += (o, e) =&gt; DragMove(); </pre>
<p>This <kbd>DragMove</kbd> method is declared within the <kbd>Window</kbd> class and enables us to click and drag the window from anywhere within its bounds. We could easily recreate the normal window functionality of only being able to move the window from the title bar by adding our own title bar and attaching this anonymous event handler to that object's <kbd>MouseLeftButtonDown</kbd> event instead.</p>
<p>If we want our borderless window to be resizable, there is a <kbd>ResizeMode</kbd> property in the <kbd>Window</kbd> class that provides us with a few options. One value that we can use with our borderless window is the <kbd>CanResizeWithGrip</kbd> value. This option adds a so-called resize grip, specified by a triangular pattern of dots in the bottom right corner of the window, that users can resize the window with.</p>
<p>If we set the <kbd>ResizeMode</kbd> property to this value and set the background to a color that will contrast with this resize grip, we will end with this visual output:</p>
<div><img class="alignnone size-full wp-image-2041 image-border" src="img/7e42ec98-e6ba-4dc9-98a5-522bf0c8ca00.png" style="width:21.67em;height:13.33em;"/></div>
<p>However, we still have no way to close the window. For this, we could add our own button, or perhaps enable the window to be closed by pressing the escape <em>Esc</em><em> </em>key or some other key on the keyboard. Either way, whatever the trigger, closing the window is a simple matter of calling the window's <kbd>Close</kbd> method.</p>
<p>Rather than implementing a replacement window chrome, which could be easily achieved with a few borders, let's focus on developing a borderless window with an irregular shape, that we could use to popup helpful information for the users. Ordinarily, we would need to set the window's background to transparent to hide it, but we will be replacing its control template, so we don't need to do this.</p>
<p>For this example, we don't need a resize grip either, so let's set the <kbd>ResizeMode</kbd> property to <kbd>NoResize</kbd>. We also have no need to move this callout window by mouse, so we don't need to add the anonymous event handler that calls the <kbd>DragMove</kbd> method.</p>
<p>As this window will only offer information to the user, we should also set a few other window properties. One important property to set is the <kbd>ShowInTaskbar</kbd> property, which specifies whether the application icon should appear in the Windows Taskbar or not. As this window will be an integral part of our main application, we set this property to <kbd>false</kbd>, so that its icon will be hidden.</p>
<p>Another useful property for this situation is the <kbd>WindowStartupLocation</kbd> property, which enables the window to be positioned using the <kbd>Window.Top</kbd> and <kbd>Window.Left</kbd> properties. In this way, the callout window can be programmatically positioned on screen anywhere that it is needed. Before continuing any further, let's see the code for this window:</p>
<pre>&lt;Window x:Class="CompanyName.ApplicationName.Views.Controls.CalloutWindow" 
   
   
  xmlns:Controls=
    "clr-namespace:CompanyName.ApplicationName.Views.Controls" 
  WindowStartupLocation="Manual"&gt; 
  &lt;Window.Resources&gt; 
    &lt;Style TargetType="{x:Type Controls:CalloutWindow}"&gt; 
      &lt;Setter Property="ShowInTaskbar" Value="False" /&gt; 
      &lt;Setter Property="WindowStyle" Value="None" /&gt; 
      &lt;Setter Property="AllowsTransparency" Value="True" /&gt; 
      &lt;Setter Property="ResizeMode" Value="NoResize" /&gt; 
      &lt;Setter Property="Template"&gt; 
        &lt;Setter.Value&gt; 
          &lt;ControlTemplate TargetType="{x:Type Controls:CalloutWindow}"&gt; 
            &lt;Grid Margin="0,0,0,12"&gt; 
              &lt;Grid.ColumnDefinitions&gt; 
                &lt;ColumnDefinition Width="*" /&gt; 
                &lt;ColumnDefinition Width="5*" /&gt; 
              &lt;/Grid.ColumnDefinitions&gt; 
              &lt;Path Grid.ColumnSpan="2"  
                Fill="{TemplateBinding Background}"  
                Stroke="{TemplateBinding BorderBrush}"  
                StrokeThickness="2" Stretch="Fill"&gt; 
                &lt;Path.Data&gt; 
                  &lt;CombinedGeometry GeometryCombineMode="Union"&gt; 
                    &lt;CombinedGeometry.Geometry1&gt; 
                      &lt;PathGeometry&gt; 
                        &lt;PathFigure StartPoint="0,60"&gt; 
                          &lt;LineSegment Point="50,45" /&gt; 
                          &lt;LineSegment Point="50,75" /&gt; 
                        &lt;/PathFigure&gt; 
                      &lt;/PathGeometry&gt; 
                    &lt;/CombinedGeometry.Geometry1&gt; 
                    &lt;CombinedGeometry.Geometry2&gt; 
                      &lt;RectangleGeometry RadiusX="20" RadiusY="20"  
                        Rect="50,0,250,150" /&gt; 
                    &lt;/CombinedGeometry.Geometry2&gt; 
                  &lt;/CombinedGeometry&gt; 
                &lt;/Path.Data&gt; 
              &lt;/Path&gt; 
              &lt;ContentPresenter Grid.Column="1"  
                Content="{TemplateBinding Content}"  
                HorizontalAlignment="{TemplateBinding  
                HorizontalContentAlignment}"  
                VerticalAlignment="{TemplateBinding  
                VerticalContentAlignment}"  
                Margin="{TemplateBinding Padding}"&gt; 
                &lt;ContentPresenter.Resources&gt; 
                  &lt;Style TargetType="{x:Type TextBlock}"&gt; 
                    &lt;Setter Property="TextWrapping" Value="Wrap" /&gt; 
                  &lt;/Style&gt; 
                &lt;/ContentPresenter.Resources&gt; 
              &lt;/ContentPresenter&gt; 
              &lt;Grid.Effect&gt; 
                &lt;DropShadowEffect Color="Black"  
                  Direction="270" ShadowDepth="7" Opacity="0.3" /&gt; 
              &lt;/Grid.Effect&gt; 
            &lt;/Grid&gt; 
          &lt;/ControlTemplate&gt; 
        &lt;/Setter.Value&gt; 
      &lt;/Setter&gt; 
    &lt;/Style&gt; 
  &lt;/Window.Resources&gt; 
&lt;/Window&gt; </pre>
<p>While this example is not overly long, there is a lot to discuss here. In order to clarify the situation somewhat, let's also see the code behind before we examine this code:</p>
<pre>using System.Windows; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class CalloutWindow : Window 
  { 
    static CalloutWindow() 
    { 
      BorderBrushProperty.OverrideMetadata(typeof(CalloutWindow),  
        new FrameworkPropertyMetadata( 
        new SolidColorBrush(Color.FromArgb(255, 238, 156, 88))));       
      HorizontalContentAlignmentProperty.OverrideMetadata(  
        typeof(CalloutWindow),  
        new FrameworkPropertyMetadata(HorizontalAlignment.Center)); 
      VerticalContentAlignmentProperty.OverrideMetadata( 
        typeof(CalloutWindow),  
        new FrameworkPropertyMetadata(VerticalAlignment.Center)); 
    } 
 
    public CalloutWindow() 
    { 
      InitializeComponent(); 
    } 
 
    public new static readonly DependencyProperty BackgroundProperty =       
      DependencyProperty.Register(nameof(Background), typeof(Brush),  
      typeof(CalloutWindow), 
      new PropertyMetadata(new LinearGradientBrush(Colors.White, 
      Color.FromArgb(255, 250, 191, 143), 90))); 
 
    public new Brush Background 
    { 
      get { return (Brush)GetValue(BackgroundProperty); } 
      set { SetValue(BackgroundProperty, value); } 
    } 
  } 
} </pre>
<p>This code-behind file is simpler than the XAML file, so let's quickly walk through it first. We added a static constructor in order to call the <kbd>OverrideMetadata</kbd> method on a few pre-existing Dependency Properties. This enables us to override the default settings of these properties, and we do this in a static constructor because we want to run this code just once per class and because it is called before any other constructor or method in the class.</p>
<p>In this constructor, we override the metadata for the <kbd>BorderBrush</kbd> property, in order to set a default border color for our callout window. We do the same for both the <kbd>HorizontalContentAlignment</kbd> and <kbd>VerticalContentAlignment</kbd> properties to ensure that the window content will be centered by default. By doing this, we are re-using these existing properties.</p>
<p>However, we can also totally replace the pre-existing properties. As an example, we've replaced the <kbd>Background</kbd> property to paint our callout background. In this case, we declare our own <kbd>Background</kbd> property, specified by the <kbd>new</kbd> keyword, and set its own default brush color. We then use that to paint the background of our callout shape, although we could just as easily add another setter into our style to reuse the original <kbd>Background</kbd> property.</p>
<p>Looking at the XAML code now, we can see the <kbd>WindowStartupLocation</kbd> property set in the <kbd>Window</kbd> declaration, followed by a style in the window's <kbd>Resources</kbd> section. In this style, we set the aforementioned properties and define the window's control template. Inside the <kbd>ControlTemplate</kbd> object, we define a <kbd>Grid</kbd> panel. We'll return to this later, but for now, note that there is a nine pixel margin set on the bottom of the panel.</p>
<p>Next, note that the panel has two star-sized <kbd>ColumnDefinition</kbd> elements declared, one with a width of <kbd>*</kbd> and another with a width of <kbd>5*</kbd>. If we add these together, we end with a total width of six equal divisions. This means that the first column will be one sixth of the total width of the window and the second column will take up the remaining five sixths. We will soon see why this is set as it is.</p>
<p>Inside the <kbd>Grid</kbd> panel, we first declare the <kbd>Path</kbd> element that is used to define the shape of our callout. We set the <kbd>Grid.ColumnSpan</kbd> property on it to <kbd>2</kbd>, to ensure that it takes all of the space of the parent window. Next, we set our new <kbd>Background</kbd> property to the <kbd>Fill</kbd> property, so that users of our window can set <kbd>Background</kbd> property and have that brush paint just the background of our path.</p>
<p>We also set the <kbd>Stroke</kbd> property of the <kbd>Path</kbd> element to the overridden <kbd>BorderBrush</kbd> property and although we didn't, we could have exposed the <kbd>StrokeThickness</kbd> property by declaring another Dependency Property. Note that we use <kbd>TemplateBinding</kbd> elements to access the properties of the window, as they are the most efficient in this particular case.</p>
<p>Take special note of the <kbd>Path.Stretch</kbd> property, which we have set to <kbd>Fill</kbd> and defines how the shape should fill the space that it is provided with. Using this <kbd>Fill</kbd> value specifies that the content should fill all of the available space, rather than preserve its originally defined aspect ratio. However, if we want to preserve the aspect ratio, then we can change this property to the <kbd>Uniform</kbd> value instead.</p>
<p>The most important part of the path is found in the <kbd>Path.Data</kbd> section. This defines the shape of the rendered path and like our layered background example, we utilize a <kbd>CombinedGeometry</kbd> element here to combine two separate geometries. Unlike the previous example, here we use a <kbd>GeometryCombineMode</kbd> value of <kbd>Union</kbd>, which renders the output of both geometry shapes together.</p>
<p>In the <kbd>CombinedGeometry.Geometry1</kbd> element, we declare a <kbd>PathGeometry</kbd> object with a <kbd>PathFigure</kbd> element that has a starting point and two <kbd>LineSegment</kbd> elements. Together with the starting point, these two elements form the triangular section of our callout, that points to the area on the screen that our window's information relates to. Note that this triangle is fifty pixels wide in the path.</p>
<p>In the <kbd>CombinedGeometry.Geometry2</kbd> element, we declare a <kbd>RectangleGeometry</kbd> object, with its size specified by the <kbd>Rect</kbd> property and the size of its rounded corners being specified by the <kbd>RadiusX</kbd> and <kbd>RadiusY</kbd> properties. The rectangle is positioned fifty pixels away from the left edge and its width is two hundred and fifty pixels wide.</p>
<p>The overall area taken up by the rectangle and the triangle is therefore three hundred pixels. One sixth of three hundred is fifty and this is how wide the triangle in our shape is. This explains why our first <kbd>Grid</kbd> column is set to take one sixth of the total space.</p>
<p>After the <kbd>Path</kbd> object, we declare the <kbd>ContentPresenter</kbd> element that is required to output the actual content of the window and set it to be in the second column of the panel. In short, this column is used to position the <kbd>ContentPresenter</kbd> element directly over the rectangular section of our shape, avoiding the triangular section.</p>
<p>In the <kbd>ContentPresenter</kbd> element, we data bind several positional properties to the relevant properties of the window using <kbd>TemplateBinding</kbd> elements. We also data bind its <kbd>Content</kbd> property to the <kbd>Content</kbd> property of the window using another <kbd>TemplateBinding</kbd> element.</p>
<p>Note that we could have declared our UI controls directly within the <kbd>Window</kbd> control. However, had we done that, then we would not be able to data bind to its <kbd>Content</kbd> property in this way, as setting it externally would replace all of our declared XAML controls, including the <kbd>ContentPresenter</kbd> object. By providing a new template, we are totally overriding the default behavior of the window.</p>
<p>Also note that we have declared a style in the <kbd>Resources</kbd> section of the <kbd>ContentPresenter</kbd> element. This style has been declared without the <kbd>x:Key</kbd> directive. This is so that it will be implicitly applied to all <kbd>TextBlock</kbd> objects within scope, specifically to affect the <kbd>TextBlock</kbd> objects that the <kbd>ContentPresenter</kbd> element will automatically generate for <kbd>string</kbd> values, while not affecting others.</p>
<p>The style sets the <kbd>TextBlock.TextWrapping</kbd> property to the <kbd>Wrap</kbd> member of the <kbd>TextWrapping</kbd> enumeration, which has the effect of wrapping long text lines onto the following lines. The default setting is <kbd>NoWrap</kbd>, which would result in long strings not being fully displayed in our window.</p>
<p>Finally, we come to the end of the XAML example and find a <kbd>DropShadowEffect</kbd> object set as the <kbd>Effect</kbd> property of the <kbd>Grid</kbd> panel. As with all shadow effects, we set the <kbd>Color</kbd> property to black and the <kbd>Opacity</kbd> property to a value less or equal to <kbd>0.5</kbd>. The <kbd>Direction</kbd> property is set to <kbd>270</kbd>, which produces a shadow that lies directly underneath our callout shape.</p>
<p>Note that we set the <kbd>ShadowDepth</kbd> property to a value of <kbd>7</kbd>. <em>Now, do you remember the bottom margin that was set on the grid?</em> That was set to a value just above this value and was to ensure that enough space was left in the window to display our shadow underneath our callout shape. Without this, the shadow would sit outside the bounding box of the window and not be displayed.</p>
<p>If we had set a different value for the <kbd>Direction</kbd> property, then we would need to adjust the <kbd>Grid</kbd> panel's margin to ensure that it left enough space around the window to display the shadow in its new location. Let's now take a look at how we could use our new window:</p>
<pre>CalloutWindow calloutWindow = new CalloutWindow(); <br/>calloutWindow.Width = 225; 
calloutWindow.Height = 120; 
calloutWindow.FontSize = 18; 
calloutWindow.Padding = new Thickness(20); 
calloutWindow.Content = "Please fill in the first line of your address."; 
calloutWindow.Show(); </pre>
<p>Running this code from a suitable location would result in the following rendered output:</p>
<div><img class="alignnone size-full wp-image-2062 image-border" src="img/c2690552-94de-4c3d-a524-ca01581833ae.png" style="width:23.75em;height:14.83em;"/></div>
<p>In our window-showing code, we set a <kbd>string</kbd> to the <kbd>Content</kbd> property of the window. However, this property is of type <kbd>object</kbd>, so we can add any object as its value. In the same way that we set our View Model instances to the <kbd>Content</kbd> property of a <kbd>ContentControl</kbd> earlier in this book, we can also do that with our window.</p>
<p>Given a suitable <kbd>DataTemplate</kbd> that defines some UI for a particular custom object type, we could set an instance of that object to our window's <kbd>Content</kbd> property and have the controls from that template rendered within our callout window, so we are not restricted to only using type <kbd>string</kbd> for content here. Let's use a previous example:</p>
<pre>calloutWindow.DataContext = new UsersViewModel(); </pre>
<p>With a few slight adjustments to our <kbd>calloutWindow</kbd> dimension properties, we would see this:</p>
<div><img class="alignnone size-full wp-image-2063 image-border" src="img/11b6417d-e6c4-4127-b2d5-b2a60fb2fd38.png" style="width:25.83em;height:17.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Visualizing data</h1>
                
            
            
                
<p>While there are a number of pre-existing graph controls and third party data visualization controls available in WPF, we can create our own relatively easily. Expressing data in textual terms alone, while generally acceptable, is not optimal. Breaking the norm in an application always makes that application stand out from the rest that strictly adheres to the standard.</p>
<p>As an example, imagine a simple situation, where we have a dashboard that visualizes the number of work tasks that have come in and the number that have been completed. We could just output the numbers in a big, bold font, but that would be the normal kind of output. <em>What about if we visualized each number as a shape, with its size being specified by the number?</em></p>
<p>Let's reuse our layering techniques from earlier and design some visually appealing spheres, that grow in size depending upon a particular value. To do this, we can create another custom control, with a <kbd>Value</kbd> Dependency Property to data bind to. Let's first look at the code of the <kbd>Sphere</kbd> class:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Media; 
using System.Windows.Shapes; 
using CompanyName.ApplicationName.CustomControls.Enums;
using MediaColor = System.Windows.Media.Color; 
 
namespace CompanyName.ApplicationName.CustomControls 
{ 
  [TemplatePart(Name = "PART_Background", Type = typeof(Ellipse))] 
  [TemplatePart(Name = "PART_Glow", Type = typeof(Ellipse))] 
  public class Sphere : Control 
  { 
    private RadialGradientBrush greenBackground =
      new RadialGradientBrush(new GradientStopCollection() { 
      new GradientStop(MediaColor.FromRgb(0, 254, 0), 0),
      new GradientStop(MediaColor.FromRgb(1, 27, 0), 0.974) }); 
    private RadialGradientBrush greenGlow = 
      new RadialGradientBrush(new GradientStopCollection() { 
      new GradientStop(MediaColor.FromArgb(205, 67, 255, 46), 0),
      new GradientStop(MediaColor.FromArgb(102, 88, 254, 72), 0.426),
      new GradientStop(MediaColor.FromArgb(0, 44, 191, 32), 1) }); 
    private RadialGradientBrush redBackground = 
      new RadialGradientBrush(new GradientStopCollection() { 
      new GradientStop(MediaColor.FromRgb(254, 0, 0), 0),
      new GradientStop(MediaColor.FromRgb(27, 0, 0), 0.974) }); 
    private RadialGradientBrush redGlow = 
      new RadialGradientBrush(new GradientStopCollection() { 
      new GradientStop(MediaColor.FromArgb(205, 255, 46, 46), 0), 
      new GradientStop(MediaColor.FromArgb(102, 254, 72, 72), 0.426),
      new GradientStop(MediaColor.FromArgb(0, 191, 32, 32), 1) }); 
 
    static Sphere() 
    { 
      DefaultStyleKeyProperty.OverrideMetadata(typeof(Sphere),  
        new FrameworkPropertyMetadata(typeof(Sphere))); 
    } 
 
    public static readonly DependencyProperty ValueProperty =  
      DependencyProperty.Register(nameof(Value), typeof(double),  
      typeof(Sphere), new PropertyMetadata(50.0)); 
 
    public double Value 
    { 
      get { return (double)GetValue(ValueProperty); } 
      set { SetValue(ValueProperty, value); } 
    } 
 
    public static readonly DependencyProperty ColorProperty =  
      DependencyProperty.Register(nameof(Color), typeof(SphereColor),  
      typeof(Sphere), new PropertyMetadata(SphereColor.Green,  
      OnColorChanged)); 
 
    public SphereColor Color 
    { 
      get { return (SphereColor)GetValue(ColorProperty); } 
      set { SetValue(ColorProperty, value); } 
    } 
 
    private static void OnColorChanged(DependencyObject  
      dependencyObject, DependencyPropertyChangedEventArgs e) 
    { 
      ((Sphere)dependencyObject).SetEllipseColors(); 
    } 
 
    public override void OnApplyTemplate() 
    { 
      SetEllipseColors(); 
    } 
 
    private void SetEllipseColors() 
    { 
      Ellipse backgroundEllipse =  
        GetTemplateChild("PART_Background") as Ellipse; 
      Ellipse glowEllipse = GetTemplateChild("PART_Glow") as Ellipse;
      if (backgroundEllipse != null) backgroundEllipse.Fill = 
        Color == SphereColor.Green ? greenBackground : redBackground; 
      if (glowEllipse != null) glowEllipse.Fill =  
        Color == SphereColor.Green ? greenGlow : redGlow;
    } 
  } 
} </pre>
<p>As this class will declare its own <kbd>Color</kbd> property, we start by adding a <kbd>MediaColor</kbd> using alias directive, which we'll just use as a shortcut to accessing the methods of the <kbd>System.Windows.Media.Color</kbd> class, when declaring the brushes that will be used in the <kbd>Sphere</kbd> class. </p>
<p>From the class declaration, we can see that there are two named parts specified in <kbd>TemplatePartAttribute</kbd> attributes. These specify that the two mentioned <kbd>Ellipse</kbd> elements are required in our control's template in the <kbd>Generic.xaml</kbd> file. Inside the class, we define a number of <kbd>RadialGradientBrush</kbd> resources to paint our spheres with.</p>
<p>In the static constructor, we call the <kbd>OverrideMetadata</kbd> method to let the Framework know where our control's default style is. We then see the declaration of the <kbd>Value</kbd> and <kbd>Color</kbd> Dependency Properties, with the <kbd>Color</kbd> property's related <kbd>PropertyChangedCallback</kbd> hander method.</p>
<p>In this <kbd>OnColorChanged</kbd> method, we cast the <kbd>dependencyObject</kbd> input parameter to an instance of our <kbd>Sphere</kbd> class and call its <kbd>SetEllipseColors</kbd> method. In that method, we use the <kbd>FrameworkElement.GetTemplateChild</kbd> method to access the two main <kbd>Ellipse</kbd> objects from our <kbd>ControlTemplate</kbd> element.</p>
<p>Remember that we must always check these objects for <kbd>null</kbd>, as our <kbd>ControlTemplate</kbd> could have been replaced with one that does not contain these ellipse elements. If they are not <kbd>null</kbd>, we set their <kbd>Fill</kbd> properties to one of our brush resources using the ternary operator and depending upon the value of our <kbd>Color</kbd> property.</p>
<p>One alternative for creating this functionality would be to declare a Dependency Property of type <kbd>Brush</kbd> to data bind to each ellipse's <kbd>Fill</kbd> property and to set the relevant brush resources to these properties, instead of accessing the XAML elements directly. Before viewing the control's default style, let's see the <kbd>SphereColor</kbd> enumeration that is used by the <kbd>Color</kbd> property:</p>
<pre>namespace CompanyName.ApplicationName.CustomControls.Enums 
{ 
  public enum SphereColor 
  { 
    Green, Red 
  } 
} </pre>
<p>As you can see, this is a simple affair and could be easily extended. Note that this enumeration has been declared within the <kbd>CustomControls</kbd> namespace and project, so that the project is self-contained and can be reused in other applications without any external dependencies. Let's take a look at our control's default style from <kbd>Generic.xaml</kbd> now:</p>
<pre>&lt;Style TargetType="{x:Type CustomControls:Sphere}"&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type CustomControls:Sphere}"&gt; 
        &lt;ControlTemplate.Resources&gt; 
          &lt;DropShadowEffect x:Key="Shadow" BlurRadius="10" 
            Direction="270" ShadowDepth="7" Opacity="0.5" /&gt; 
          &lt;LinearGradientBrush x:Key="Reflection" 
            StartPoint="0,0" EndPoint="0,1"&gt; 
            &lt;GradientStop Color="#90FFFFFF" Offset="0.009" /&gt;
            &lt;GradientStop Color="#2DFFFFFF" Offset="0.506" /&gt; 
            &lt;GradientStop Offset="0.991" /&gt; 
          &lt;/LinearGradientBrush&gt; 
        &lt;/ControlTemplate.Resources&gt; 
        &lt;Grid Height="{Binding Value,  
          RelativeSource={RelativeSource TemplatedParent}}"
          Width="{Binding Value,
          RelativeSource={RelativeSource TemplatedParent}}"&gt;
          &lt;Grid.RowDefinitions&gt; 
            &lt;RowDefinition Height="5*" /&gt; 
            &lt;RowDefinition Height="2*" /&gt; 
          &lt;/Grid.RowDefinitions&gt; 
          &lt;Grid.ColumnDefinitions&gt; 
            &lt;ColumnDefinition Width="*" /&gt; 
            &lt;ColumnDefinition Width="8*" /&gt; 
            &lt;ColumnDefinition Width="*" /&gt; 
          &lt;/Grid.ColumnDefinitions&gt; 
          &lt;Ellipse Name="PART_Background" Grid.RowSpan="2"  
            Grid.ColumnSpan="3" Stroke="#FF1B0000"  
            Effect="{StaticResource Shadow}" /&gt; 
          &lt;Ellipse Name="PART_Glow" Grid.RowSpan="2"
            Grid.ColumnSpan="3" /&gt; 
          &lt;Ellipse Grid.Column="1" Margin="0,2,0,0" 
            Fill="{StaticResource Reflection}" /&gt; 
        &lt;/Grid&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>When looking at our control's default template, we can see some of resources defined in the <kbd>ControlTemplate.Resources</kbd> section. We first declare a <kbd>DropShadowEffect</kbd> element, similar to our previous uses of this class. Next, we define a vertical <kbd>LinearGradientBrush</kbd> element, to use as a light reflection layer, in a similar way to our earlier example.</p>
<p>Previously, we saw that the default value of the <kbd>GradientStop.Offset</kbd> property is zero and so, we can omit the setting of this property if that is the value that we need to use. In this brush resource, we see that the last <kbd>GradientStop</kbd> element has no <kbd>Color</kbd> value specified. This is because its default value of this property is <kbd>Transparent</kbd> and that is the value that we need to use here.</p>
<p>In the actual markup for our control, we declare three <kbd>Ellipse</kbd> objects within a <kbd>Grid</kbd> panel. Two of these elements are named and referenced in the control's code, while the third ellipse uses the brush from resources to create the "shine" on top of the other ellipses. The panel's size properties are data bound to the <kbd>Value</kbd> Dependency Property, using a <kbd>TemplatedParent</kbd> source.</p>
<p>Note that we have used the star-sizing capabilities of the <kbd>Grid</kbd> panel to both position and size our ellipse elements, with the exception of the two pixels in the top margin specified on the reflection ellipse. In this way, our control can be any size and the positioning of the various layers will remain visually correct. Note that we could not achieve this by hard coding exact margin values for each element.</p>
<p>Let's see how we could use this in a simple View:</p>
<pre>&lt;Grid TextElement.FontSize="28" TextElement.FontWeight="Bold" Margin="20"&gt; 
  &lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition /&gt; 
    &lt;ColumnDefinition /&gt; 
  &lt;/Grid.ColumnDefinitions&gt; 
  &lt;Grid.RowDefinitions&gt; 
    &lt;RowDefinition /&gt; 
    &lt;RowDefinition Height="Auto" /&gt; 
  &lt;/Grid.RowDefinitions&gt; 
  &lt;CustomControls:Sphere Color="Red" Value="{Binding InCount}"  
    VerticalAlignment="Bottom" /&gt; 
  &lt;CustomControls:Sphere Grid.Column="1" Value="{Binding OutCount}"  
    VerticalAlignment="Bottom" /&gt; 
  &lt;TextBlock Grid.Row="1" Text="{Binding InCount}"  
    HorizontalAlignment="Center" Margin="0,10,0,0" /&gt; 
  &lt;TextBlock Grid.Row="1" Grid.Column="1" Text="{Binding OutCount}"  
    HorizontalAlignment="Center" Margin="0,10,0,0" /&gt; 
&lt;/Grid&gt; </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is how our example looks when rendered:</p>
<div><img class="alignnone size-full wp-image-2044 image-border" src="img/4e45b0d9-ac6f-4e99-a95f-dd64c527c422.png" style="width:25.17em;height:21.08em;"/></div>
<p>As you can see, WPF is very powerful and enables us to create completely original looking controls. However, we can also use it to recreate more commonly seen controls. As an example, let's see how we can create an alternative control to gauge how close we may be to our particular target value:</p>
<div><img class="alignnone size-full wp-image-2045 image-border" src="img/5665f562-3a70-484b-b46f-7006d54a7373.png" style="width:25.42em;height:19.92em;"/></div>
<p>This example features a semi-circular arc, which is something that does not exist in a form that is usable from XAML, so we'll first create an <kbd>Arc</kbd> control to use internally within our <kbd>Gauge</kbd> control. Let's see how we can achieve this by adding a new custom control:</p>
<pre>using System; 
using System.Windows; 
using System.Windows.Media; 
using System.Windows.Shapes; 
 
namespace CompanyName.ApplicationName.CustomControls 
{ 
  public class Arc : Shape 
  { 
    public static readonly DependencyProperty StartAngleProperty =
      DependencyProperty.Register(nameof(StartAngle), typeof(double),  
      typeof(Arc), new FrameworkPropertyMetadata(180.0, <br/>      FrameworkPropertyMetadataOptions.AffectsRender)); 
 
    public double StartAngle 
    { 
      get { return (double)GetValue(StartAngleProperty); } 
      set { SetValue(StartAngleProperty, value); } 
    } 
 
    public static readonly DependencyProperty EndAngleProperty =
      DependencyProperty.Register(nameof(EndAngle), typeof(double),  
      typeof(Arc), new FrameworkPropertyMetadata(0.0, <br/>      FrameworkPropertyMetadataOptions.AffectsRender)); 
 
    public double EndAngle 
    { 
      get { return (double)GetValue(EndAngleProperty); } 
      set { SetValue(EndAngleProperty, value); } 
    } 
 
    protected override Geometry DefiningGeometry 
    { 
      get { return GetArcGeometry(); } 
    } 
 
    private Geometry GetArcGeometry() 
    { 
      Point startPoint = ConvertToPoint(Math.Min(StartAngle, EndAngle)); 
      Point endPoint = ConvertToPoint(Math.Max(StartAngle, EndAngle)); 
      Size arcSize = new Size(Math.Max(0, (RenderSize.Width -
        StrokeThickness) / 2), Math.Max(0, (RenderSize.Height -  
        StrokeThickness) / 2)); 
      bool isLargeArc = Math.Abs(EndAngle - StartAngle) &gt; 180; 
      StreamGeometry streamGeometry = new StreamGeometry(); 
      using (StreamGeometryContext context = streamGeometry.Open()) 
      { 
        context.BeginFigure(startPoint, false, false); 
        context.ArcTo(endPoint, arcSize, 0, isLargeArc, 
          SweepDirection.Counterclockwise, true, false); 
      } 
      streamGeometry.Transform = 
        new TranslateTransform(StrokeThickness / 2, StrokeThickness / 2);
      streamGeometry.Freeze(); 
      return streamGeometry; 
    } 
 
    private Point ConvertToPoint(double angleInDegrees) 
    { 
      double angleInRadians = angleInDegrees * Math.PI / 180;
      double radiusX = (RenderSize.Width - StrokeThickness) / 2;
      double radiusY = (RenderSize.Height - StrokeThickness) / 2; 
      return new Point(radiusX * Math.Cos(angleInRadians) + radiusX,  
        radiusY * Math.Sin(-angleInRadians) + radiusY); 
    } 
  } 
} </pre>
<p>Note that we extend the <kbd>Shape</kbd> class when creating our <kbd>Arc</kbd> class. We do this because it provides us with a wide variety of stroke and fill properties and also the apparatus to render our custom shape from a <kbd>Geometry</kbd> object. Additionally, users of our <kbd>Arc</kbd> control will also be able to take advantage of the <kbd>Shape</kbd> class' transformation abilities through its <kbd>Stretch</kbd> and <kbd>GeometryTransform</kbd> properties.</p>
<p>To draw our arc, we will use the <kbd>ArcTo</kbd> method of the <kbd>StreamGeometryContext</kbd> class and with it, we need to specify exact <kbd>Point</kbd> values for its start and end. However, in order to reflect the correct value in the size of our arc, it is easier to define it using angle values for its start and end.</p>
<p class="mce-root">Therefore, we add <kbd>StartAngle</kbd> and <kbd>EndAngle</kbd> Dependency Properties to our <kbd>Arc</kbd> class. Note that these two properties are declared with the <kbd>FrameworkPropertyMetadataOptions.AffectsRender</kbd> member. This notifies the Framework that changes to these properties need to cause a new rendering pass, so new values will be accurately represented in the control.</p>
<p>After these property declarations, we see the overridden <kbd>DefiningGeometry</kbd> property, that enables us to return a <kbd>Geometry</kbd> object that defines the shape to be rendered. We simply return the result from the <kbd>GetArcGeometry</kbd> method from this property.</p>
<p class="mce-root"/>
<p>In the <kbd>GetArcGeometry</kbd> method, we obtain the required start and end <kbd>Point</kbd> elements from the <kbd>ConvertToPoint</kbd> method, passing in the <kbd>StartAngle</kbd> and <kbd>EndAngle</kbd> property values. Note that we use the <kbd>Min</kbd> and <kbd>Max</kbd> methods of the <kbd>Math</kbd> class here to ensure that the start point is calculated from the smaller angle and the end point is calculated from the larger angle.</p>
<p>Our arc shape's fill will actually come from the geometric arc's stroke, so we will not be able to add a stroke to it. In WPF, the stroke of a shape with a thickness of one pixel will extend no further than the shape's bounding box. However, at the furthest point, strokes with larger thickness values are rendered so that their center remains on the line of the bounding box also therefore, half of it will extend outside the bounds of the element and half will be rendered within the bounds:</p>
<div><img class="alignnone size-full wp-image-2127 image-border" src="img/085f2c30-a9b1-4bc5-9816-685a724888ae.png" style="width:53.83em;height:18.08em;"/></div>
<p>Therefore, we calculate the size of the arc by dividing the <kbd>RenderSize</kbd> value minus the <kbd>StrokeThickness</kbd> value by two. This will reduce the size of the arc so that it remains totally within the bounds of our control. We make use of the <kbd>Math.Max</kbd> method to ensure that the values that we pass to the <kbd>Size</kbd> class are never less than zero and avoid exceptions.</p>
<p>When using the <kbd>ArcTo</kbd> method, we need to specify a value that determines whether we want to connect our start and end points with a short arc or a long one. Our <kbd>isLargeArc</kbd> variable therefore determines whether the two specified angles would produce an arc of more than one hundred and eighty degrees or not.</p>
<p>Next, we create a <kbd>StreamGeometry</kbd> object and retrieve a <kbd>StreamGeometryContext</kbd> object from its <kbd>Open</kbd> method, with which to define our geometric shape. Note that we could equally use a <kbd>PathGeometry</kbd> object here, but as we do not need its data binding, animation, or other abilities, we use the more efficient <kbd>StreamGeometry</kbd> object instead.</p>
<p>We enter the arc's start point in the <kbd>BeginFigure</kbd> method and the remaining parameters in the <kbd>ArcTo</kbd> method. Note that we call these methods on our <kbd>StreamGeometryContext</kbd> object from within a <kbd>using</kbd> statement to ensure that it is closed and disposed of properly, once we are finished with it.</p>
<p>Next, we apply a <kbd>TranslateTransform</kbd> element to the <kbd>Transform</kbd> property of the <kbd>StreamGeometry</kbd> object in order to shift the arc so that it is fully contained within our control. Without this step, our arc would stick out of the bounding box of our control to the upper left, by the amount of half of the <kbd>StrokeThickness</kbd> property value.</p>
<p>Once we have finished manipulating our <kbd>StreamGeometry</kbd> object, we call its <kbd>Freeze</kbd> method, which makes it unmodifiable and rewards us with additional performance benefits. We'll find out more about this in <a href="ef8426a1-cec3-4ae0-801a-798557f3fbd4.xhtml">Chapter 11</a>, <em>Improving Application Performance, </em>but for now, let's continue looking through this example.</p>
<p>Finally, we get to the <kbd>ConvertToPoint</kbd> method, which converts the values of our two angle Dependency Properties into two-dimensional <kbd>Point</kbd> objects. Our first job is to convert each angle from degrees into radians, as the methods of the <kbd>Math</kbd> class that we need to use require radian values.</p>
<p>Next, we calculate the two radii of our arc using half of the <kbd>RenderSize</kbd> value minus the <kbd>StrokeThickness</kbd> property value, so that the size of the arc does not exceed the bounding box of our <kbd>Arc</kbd> control. Finally, we perform some basic trigonometry using the <kbd>Math.Cos</kbd> and <kbd>Math.Sin</kbd> methods when calculating the <kbd>Point</kbd> element to return.</p>
<p>That completes our simple <kbd>Arc</kbd> control and so now, we can utilize this new class in our <kbd>Gauge</kbd> control. We'll need to create another new custom control for it, so let's first see the properties and code in our new <kbd>Gauge</kbd> class:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.CustomControls 
{ 
  public class Gauge : Control 
  { 
    static Gauge() 
    { 
      DefaultStyleKeyProperty.OverrideMetadata (typeof(Gauge),  
        new FrameworkPropertyMetadata(typeof(Gauge))); 
    } 
 
    public static readonly DependencyPropertyKey valueAnglePropertyKey = 
      DependencyProperty.RegisterReadOnly(nameof(ValueAngle),  
      typeof(double), typeof(Gauge), new PropertyMetadata(180.0)); 
 
    public static readonly DependencyProperty ValueAngleProperty =  
      valueAnglePropertyKey.DependencyProperty; 
 
    public double ValueAngle 
    { 
      get { return (double)GetValue(ValueAngleProperty); } 
      private set { SetValue(valueAnglePropertyKey, value); } 
    } 
 
    public static readonly DependencyPropertyKey  
      rotationAnglePropertyKey = DependencyProperty.RegisterReadOnly( 
      nameof(RotationAngle), typeof(double), typeof(Gauge),
      new PropertyMetadata(180.0)); 
 
    public static readonly DependencyProperty RotationAngleProperty =  
      rotationAnglePropertyKey.DependencyProperty; 
 
    public double RotationAngle 
    { 
      get { return (double)GetValue(RotationAngleProperty); } 
      private set { SetValue(rotationAnglePropertyKey, value); } 
    } 
 
    public static readonly DependencyProperty ValueProperty =  
      DependencyProperty.Register(nameof(Value), typeof(double),  
      typeof(Gauge), new PropertyMetadata(0.0, OnValueChanged)); 
 
    private static void OnValueChanged(DependencyObject  
      dependencyObject, DependencyPropertyChangedEventArgs e) 
    { 
      Gauge gauge = (Gauge)dependencyObject; 
      if (gauge.MaximumValue == 0.0)  
        gauge.ValueAngle = gauge.RotationAngle = 180.0; 
      else if ((double)e.NewValue &gt; gauge.MaximumValue) 
      { 
        gauge.ValueAngle = 0.0; 
        gauge.RotationAngle = 360.0; 
      } 
      else 
      { 
        double scaledPercentageValue =  
          ((double)e.NewValue / gauge.MaximumValue) * 180.0; 
        gauge.ValueAngle = 180.0 - scaledPercentageValue; 
        gauge.RotationAngle = 180.0 + scaledPercentageValue; 
      } 
    } 
 
    public double Value 
    { 
      get { return (double)GetValue(ValueProperty); } 
      set { SetValue(ValueProperty, value); } 
    } 
 
    public static readonly DependencyProperty MaximumValueProperty =  
      DependencyProperty.Register(nameof(MaximumValue), typeof(double),  
      typeof(Gauge), new PropertyMetadata(0.0)); 
 
    public double MaximumValue 
    { 
      get { return (double)GetValue(MaximumValueProperty); } 
      set { SetValue(MaximumValueProperty, value); } 
    } 
 
    public static readonly DependencyProperty TitleProperty =  
      DependencyProperty.Register(nameof(Title), typeof(string),  
      typeof(Gauge), new PropertyMetadata(string.Empty)); 
 
    public string Title 
    { 
      get { return (string)GetValue(TitleProperty); } 
      set { SetValue(TitleProperty, value); } 
    } 
  } 
} </pre>
<p>As usual, we start by overriding the metadata of the <kbd>DefaultStyleKeyProperty</kbd> for our control type in the static constructor, to help the Framework find where its default style is defined. We then declare the internal, read-only <kbd>ValueAngle</kbd> and <kbd>RotationAngle</kbd> Dependency Properties and the regular public <kbd>Value</kbd>, <kbd>MaximumValue</kbd>, and <kbd>Title</kbd> Dependency Properties.</p>
<p>We declare a <kbd>PropertyChangedCallback</kbd> hander for the <kbd>Value</kbd> property, and, in that method, we first cast the <kbd>dependencyObject</kbd> input parameter to an instance of our <kbd>Gauge</kbd> class. If the value of the <kbd>MaximumValue</kbd> property is zero, then we simply set both of the <kbd>ValueAngle</kbd> and <kbd>RotationAngle</kbd> properties to <kbd>180.0</kbd>, which results in the arc and needle being displayed in their start positions, on the left.</p>
<p>If the new value of the data bound <kbd>Value</kbd> property is more than the value of the <kbd>MaximumValue</kbd> property, then we make the arc and needle display in their end, or full, positions to the right. We do this by setting the <kbd>ValueAngle</kbd> property to <kbd>0.0</kbd> and the <kbd>RotationAngle</kbd> property to <kbd>360.0</kbd>.</p>
<p>If the new value of the <kbd>Value</kbd> property is valid, then we calculate the <kbd>scaledPercentageValue</kbd> variable. We do this by first dividing the new value by the value of the <kbd>MaximumValue</kbd> property, to get the percentage of the maximum value. We then multiply that figure by <kbd>180.0</kbd>, because our gauge covers a range of one hundred and eighty degrees.</p>
<p>We then subtract the <kbd>scaledPercentageValue</kbd> variable value from <kbd>180.0</kbd> for the <kbd>ValueAngle</kbd> property and add it to <kbd>180.0</kbd> for the <kbd>RotationAngle</kbd> property. This is because the <kbd>ValueAngle</kbd> property is used by our arc and needs to be between <kbd>180.0</kbd> and <kbd>0.0</kbd>, and the <kbd>RotationAngle</kbd> property is used by our gauge needle and needs to be between <kbd>180.0</kbd> and <kbd>360.0</kbd>.</p>
<p>This will soon be made clearer, so let's now see how we use these properties and the <kbd>Arc</kbd> control in our <kbd>Gauge</kbd> control's default style from the <kbd>Generic.xaml</kbd> file:</p>
<pre>&lt;Style TargetType="{x:Type CustomControls:Gauge}"&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type CustomControls:Gauge}"&gt; 
        &lt;Grid Background="{Binding Background,  
          RelativeSource={RelativeSource TemplatedParent}}"&gt; 
          &lt;Grid Margin="{Binding Padding,  
            RelativeSource={RelativeSource TemplatedParent}}"&gt; 
            &lt;Grid.RowDefinitions&gt; 
              &lt;RowDefinition Height="Auto" /&gt; 
              &lt;RowDefinition /&gt; 
              &lt;RowDefinition Height="Auto" /&gt; 
            &lt;/Grid.RowDefinitions&gt; 
            &lt;TextBlock Text="{Binding Title,  
              RelativeSource={RelativeSource TemplatedParent}}"  
              HorizontalAlignment="Center" /&gt; 
            &lt;Canvas Grid.Row="1" Width="300" Height="150"
              HorizontalAlignment="Center" Margin="0,5"&gt;
              &lt;CustomControls:Arc Width="300" Height="300"
                StrokeThickness="75"  Stroke="#FF444444" /&gt;
              &lt;CustomControls:Arc Width="300" Height="300"
                StrokeThickness="75" Stroke="OrangeRed" StartAngle="180"
                EndAngle="{Binding AngleValue, 
                RelativeSource={RelativeSource TemplatedParent}}" /&gt; 
              &lt;Path Canvas.Left="150" Canvas.Top="140"  
                Fill="White" StrokeThickness="5" Stroke="White" 
                StrokeLineJoin="Round" Data="M0,0 L125,10, 0,20Z"
                Stretch="Fill" Width="125" Height="20"&gt; 
                &lt;Path.RenderTransform&gt; 
                  &lt;RotateTransform Angle="{Binding RotationAngle,
                    RelativeSource={RelativeSource TemplatedParent}}"
                    CenterX="0" CenterY="10" /&gt; 
                &lt;/Path.RenderTransform&gt; 
              &lt;/Path&gt; 
            &lt;/Canvas&gt; 
            &lt;TextBlock Grid.Row="2" Text="{Binding Value, StringFormat=N0,
              RelativeSource={RelativeSource TemplatedParent}}"
              HorizontalAlignment="Center" FontWeight="Bold" /&gt; 
          &lt;/Grid&gt; 
        &lt;/Grid&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>We start our default style as usual, by specifying the type of our control in both the style and the control template. Inside the template, we have two <kbd>Grid</kbd> panels and data bind the <kbd>Background</kbd> property of the outer panel and the <kbd>Margin</kbd> property of the inner panel to properties of our templated control, so that users can set them externally.</p>
<p>We then define three rows in our inner panel. The control's <kbd>Title</kbd> property is data bound to a horizontally centered <kbd>TextBlock</kbd> element in the first row. In the second row, we declare a horizontally centered <kbd>Canvas</kbd> panel that contains two of our new <kbd>Arc</kbd> controls and a <kbd>Path</kbd> object.</p>
<p>The first <kbd>Arc</kbd> control is gray and represents the background track that the <kbd>Arc</kbd> that represents our <kbd>Gauge</kbd> control's <kbd>Value</kbd> property sits on. The second <kbd>Arc</kbd> control is colored <kbd>OrangeRed</kbd> and displays the current value of our <kbd>Gauge</kbd> control's <kbd>Value</kbd> property, by data binding its <kbd>EndAngle</kbd> property to the <kbd>AngleValue</kbd> Dependency Property of the <kbd>Gauge</kbd> control.</p>
<p>Note that the angles in our <kbd>Arc</kbd> control follow the common Cartesian coordinate system, with an angle of zero degrees falling to the right and increasing values moving anti-clockwise. Therefore, to draw a semi-circular arc from left to right, we start with an angle of <kbd>180</kbd> degrees and end at <kbd>0</kbd> degrees, as demonstrated by the background arc in our <kbd>Gauge</kbd> control.</p>
<p>Furthermore, our <kbd>Arc</kbd> controls have the same width and height values, but as we don't need their lower halves, we crop them using the height of the canvas panel. The <kbd>Path</kbd> object represents the gauge needle in our control and is painted white.</p>
<p>We set the <kbd>StrokeLineJoin</kbd> property to the <kbd>Round</kbd> value in order to curve the three corners, where the lines of the needle path meet. Note that the needle is positioned exactly half way across the width of the canvas and ten pixels above the bottom, to enable its center line to lie along the bottom of the canvas.</p>
<p>Rather than declaring <kbd>PathFigure</kbd> and <kbd>LineSegment</kbd> objects to define the needle, we have used the shorthand notation inline in the <kbd>Data</kbd> property. The <kbd>M</kbd> specifies that we should move to (or start from) point <kbd>0,0</kbd>, the <kbd>L</kbd> specifies that we want to draw a line to point <kbd>125,10</kbd> and then from there to point <kbd>0,20</kbd>, and the <kbd>Z</kbd> means that we want to close the path by joining the first and last points.</p>
<p>We then set the width and height of the path to the same values that were declared within <kbd>Data</kbd> property. Now, the essential part of enabling this needle to point to the relevant position to reflect the data bound <kbd>Value</kbd> property, is the <kbd>RotateTransform</kbd> object that is applied to the path's <kbd>RenderTransform</kbd> property. Note that its center point is set to be the center of the bottom of the needle, as that is the point that we want to rotate from.</p>
<p>As the <kbd>RotateTransform</kbd> object rotates clockwise with increasing <kbd>Angle</kbd> values, we cannot reuse the <kbd>AngleValue</kbd> Dependency Property with it. Therefore, in this particular example, we define the needle pointing to the right and use a range of <kbd>180.0</kbd> to <kbd>360.0</kbd> degrees in the <kbd>RotationAngle</kbd> read-only Dependency Property with the transform object to match the position of the value arc.</p>
<p>At the end of the example, we see another horizontally centered <kbd>TextBlock</kbd>, element that outputs the current, unaltered value of the data bound <kbd>Value</kbd> Dependency Property. Note that we use the <kbd>StringFormat</kbd> value of <kbd>N0</kbd> to remove the decimal places from the value before displaying it.</p>
<p>That completes our new <kbd>Gauge</kbd> control and so, all we need to do now is see how we can use it:</p>
<pre>&lt;CustomControls:Gauge Width="400" Height="300"  
  MaximumValue="{Binding InCount}" Value="{Binding OutCount}"  
  Title="Support Tickets Cleared" Foreground="White" FontSize="34" 
  Padding="10" /&gt; </pre>
<p>We could extend our new <kbd>Gauge</kbd> control to make it more usable in several ways. We could add a <kbd>MinimumValue</kbd> Dependency Property to enable its use with value ranges that do not start at zero, or we could expose further properties to enable users to color, size, or further customize the control. Alternatively, we could rewrite it to enable it to be any size, instead of hard coding sizes as we did previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Livening up the UI controls</h1>
                
            
            
                
<p>In addition to making our UI controls look visually appealing, we can also "<em>liven them up</em>" by adding user interactivity in the form of mouse over effects. While most mouse over effects are created using <kbd>Trigger</kbd> and <kbd>Setter</kbd> objects, that immediately update the relevant style properties when the related trigger condition is met, we can alternatively use animations to produce these effects.</p>
<p>Having even subtle transitions between states, rather than instantly switching, can also provide a richer user experience. Let's reuse our initial double bordered example from earlier and add some mouse interactivity animations to it to demonstrate this point. We'll need to add a few more resources into a suitable resource collection and adjust a couple of our previously declared resources too:</p>
<pre>&lt;Color x:Key="TransparentWhiteColor"&gt;#7FFFFFFF&lt;/Color&gt;
&lt;Color x:Key="TransparentBlackColor"&gt;#7F000000&lt;/Color&gt;</pre>
<p>Now that we have declared our semi-transparent <kbd>Color</kbd> resources, we can adjust our earlier brush resources to utilize them:</p>
<pre>&lt;SolidColorBrush x:Key="TransparentWhite"  
  Color="{StaticResource TransparentWhiteColor}" /&gt; 
&lt;SolidColorBrush x:Key="TransparentBlack" 
  Color="{StaticResource TransparentBlackColor}" /&gt; </pre>
<p>Let's view our full example now:</p>
<pre>&lt;Grid Width="160" Height="68"&gt; 
  &lt;Grid.Background&gt; 
    &lt;LinearGradientBrush StartPoint="0,0" EndPoint="1,1"&gt; 
      &lt;GradientStop Color="Red" /&gt; 
      &lt;GradientStop Color="Yellow" Offset="1" /&gt; 
    &lt;/LinearGradientBrush&gt; 
  &lt;/Grid.Background&gt; 
  &lt;Button Content="Click Me" Width="120" Height="28" FontSize="14"  
    Margin="20"&gt; 
    &lt;Button.Template&gt; 
      &lt;ControlTemplate TargetType="{x:Type Button}"&gt; 
        &lt;Border Name="OuterBorder" 
          BorderBrush="{StaticResource TransparentBlack}" 
          BorderThickness="1" Padding="1" 
          Background="{StaticResource TransparentWhite}"  
          CornerRadius="5" SnapsToDevicePixels="True"&gt; 
          &lt;Border Name="InnerBorder"  
            BorderBrush="{StaticResource TransparentBlack}" 
            BorderThickness="1" Background="White"
            CornerRadius="3.5" SnapsToDevicePixels="True"&gt; 
            &lt;ContentPresenter HorizontalAlignment="Center"  
              VerticalAlignment="Center" /&gt; 
          &lt;/Border&gt; 
        &lt;/Border&gt; 
        &lt;ControlTemplate.Triggers&gt; 
          &lt;Trigger Property="IsMouseOver" Value="True"&gt; 
            &lt;Trigger.EnterActions&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard Storyboard.TargetName="OuterBorder"  
                  Storyboard.TargetProperty=
                  "BorderBrush.(SolidColorBrush.Color)"&gt; 
                  &lt;ColorAnimation To="Black" Duration="0:0:0.25" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard Storyboard.TargetName="InnerBorder"  
                  Storyboard.TargetProperty=
                  "BorderBrush.(SolidColorBrush.Color)"&gt; 
                  &lt;ColorAnimation To="Black" Duration="0:0:0.3" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
              &lt;BeginStoryboard Name="BackgroundFadeIn" 
                HandoffBehavior="Compose"&gt; 
                &lt;Storyboard Storyboard.TargetName="InnerBorder"  
                  Storyboard.TargetProperty=
                  "Background.(SolidColorBrush.Color)"&gt;
                  &lt;ColorAnimation To="{StaticResource  
                    TransparentWhiteColor}" Duration="0:0:0.2" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.EnterActions&gt; 
            &lt;Trigger.ExitActions&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard Storyboard.TargetName="OuterBorder"  
                  Storyboard.TargetProperty=
                  "BorderBrush.(SolidColorBrush.Color)"&gt;
                  &lt;ColorAnimation To="{StaticResource  
                    TransparentBlackColor}" Duration="0:0:0.5" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard Storyboard.TargetName="InnerBorder"  
                  Storyboard.TargetProperty=
                  "BorderBrush.(SolidColorBrush.Color)"&gt;
                  &lt;ColorAnimation To="{StaticResource  
                    TransparentBlackColor}" Duration="0:0:0.3" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
              &lt;BeginStoryboard Name="BackgroundFadeOut"  
                HandoffBehavior="Compose"&gt; 
                &lt;Storyboard Storyboard.TargetName="InnerBorder"  
                  Storyboard.TargetProperty=
                  "Background.(SolidColorBrush.Color)"&gt; 
                  &lt;ColorAnimation To="White" Duration="0:0:0.4" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.ExitActions&gt; 
          &lt;/Trigger&gt; 
          &lt;Trigger Property="IsPressed" Value="True"&gt; 
            &lt;Trigger.EnterActions&gt; 
              &lt;BeginStoryboard Name="MouseDownBackground"  
                HandoffBehavior="Compose"&gt; 
                &lt;Storyboard Storyboard.TargetName="InnerBorder" 
                  Storyboard.TargetProperty=
                  "Background.(SolidColorBrush.Color)"&gt; 
                  &lt;ColorAnimation From="#D6FF21" Duration="0:0:1"  
                    DecelerationRatio="1.0" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/Trigger.EnterActions&gt; 
          &lt;/Trigger&gt; 
          &lt;EventTrigger RoutedEvent="Unloaded"&gt; 
            &lt;RemoveStoryboard BeginStoryboardName="BackgroundFadeIn" /&gt; 
            &lt;RemoveStoryboard BeginStoryboardName="BackgroundFadeOut" /&gt; 
            &lt;RemoveStoryboard BeginStoryboardName="MouseDownBackground" /&gt; 
          &lt;/EventTrigger&gt; 
        &lt;/ControlTemplate.Triggers&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Button.Template&gt; 
  &lt;/Button&gt; 
&lt;/Grid&gt; </pre>
<p>While this example might seem quite long, it is actually fairly simple. We start with our original control template, albeit with the previously hardcoded brush values being replaced by our newly defined resources. The main difference with the original example is found in the <kbd>ControlTemplate.Triggers</kbd> collection.</p>
<p>The first trigger will start its various storyboards when the <kbd>IsMouseOver</kbd> property of the <kbd>Button</kbd> element is true, or in other words, when the user moves the mouse cursor over the button. Our storyboards are split between the <kbd>Trigger.EnterActions</kbd> and <kbd>Trigger.ExitActions</kbd> collections.</p>
<p>Remember that the storyboards in the <kbd>Trigger.EnterActions</kbd> collection will be started as the mouse enters the bounds of the button, while the storyboards in the <kbd>Trigger.ExitActions</kbd> collection will be started as the mouse leaves the bounds of the button. We declare three <kbd>BeginStoryboard</kbd> objects with their associated <kbd>Storyboard</kbd> objects within each of these <kbd>TriggerActionCollection</kbd> objects.</p>
<p>The first animation targets the <kbd>BorderBrush</kbd> property of the <kbd>OuterBorder</kbd> element. Note that this property is of type <kbd>Brush</kbd>, but there is no <kbd>BrushAnimation</kbd> class in WPF. Therefore, we need to target the <kbd>Color</kbd> property of the <kbd>SolidColorBrush</kbd> that is actually applied to this property and use a <kbd>ColorAnimation</kbd> object instead.</p>
<p>In order to do this, we need to use indirect targeting to first reference the <kbd>BorderBrush</kbd> property and then to chain to the <kbd>Color</kbd> property using the syntax <kbd>BorderBrush.(SolidColorBrush.Color)</kbd>. Note that this will only work if we are in fact using a <kbd>SolidColorBrush</kbd> element, as we are in this example.</p>
<p>However, if we were using one of the gradient brushes instead of a <kbd>SolidColorBrush</kbd> element, we could target the various colors of its <kbd>GradientStop</kbd> elements with a slightly different syntax. For example, we could target the color of the first <kbd>GradientStop</kbd> element in a gradient brush like this:</p>
<pre>BorderBrush.(GradientBrush.GradientStops)[0].(GradientStop.Color) </pre>
<p>Returning to this example now, the second animation targets the <kbd>BorderBrush</kbd> property of the <kbd>InnerBorder</kbd> element and follows the syntactical example of the first animation. While the third animation also uses indirect targeting to reference the <kbd>Background</kbd> property of the <kbd>InnerBorder</kbd> element, it is somewhat different to the other two animations.</p>
<p>For this animation, we name the <kbd>BeginStoryboard</kbd> object <kbd>BackgroundFadeIn</kbd> and set its <kbd>HandoffBehavior</kbd> property to <kbd>Compose</kbd>, to enable smoother transitions between this and the other animations of this property. The specified name will be used later in the example.</p>
<p>Note that these three <kbd>ColorAnimation</kbd> objects only have their <kbd>To</kbd> and <kbd>Duration</kbd> properties set and that the three duration values are slightly different. This has the effect of slightly thickening the effect, although synchronizing the times also works well.</p>
<p>We have omitted the <kbd>From</kbd> values on these animations to avoid situations where the current animated colors do not match the <kbd>From</kbd> values and have to immediately jump to the starting values before animating to the <kbd>To</kbd> values. By omitting these values, the animations will start at their current color values and will result in smoother transitions.</p>
<p>The three animations in the <kbd>Trigger.ExitActions</kbd> collection are very similar to those in the <kbd>EnterActions</kbd> collection, albeit animating the colors back to their original starting colors, so we can skip their explanation here. However, it is worth highlighting the fact that the third animation is also declared in a named <kbd>BeginStoryboard</kbd> that has its <kbd>HandoffBehavior</kbd> property set to <kbd>Compose</kbd>.</p>
<p>The next <kbd>Trigger</kbd> object will start its associated storyboard when the <kbd>IsPressed</kbd> property of the <kbd>Button</kbd> element is true, and as it is declared within the <kbd>EnterActions</kbd> collection, it will start when the user presses the mouse button down, rather than upon its release.</p>
<p>This animation also uses indirect targeting to reference the <kbd>Background</kbd> property of the <kbd>InnerBorder</kbd> element and also has a named <kbd>BeginStoryboard</kbd> object with its <kbd>HandoffBehavior</kbd> property set to <kbd>Compose</kbd>. Unlike the other animations, this one has an extended duration and also sets the <kbd>DecelerationRatio</kbd> property to <kbd>1.0</kbd>, which results in quick start and slow end.</p>
<p>Finally, we reach the last trigger, which is an <kbd>EventTrigger</kbd> object that will be triggered when the <kbd>Button</kbd> object is unloaded. In this trigger, we remove the three named storyboards, thereby freeing the extra resources that they consume when using the <kbd>Compose</kbd> handoff behavior. This was the sole purpose for naming the three <kbd>BeginStoryboard</kbd> objects that reference the <kbd>Background</kbd> property.</p>
<p>When animating mouse over effects on buttons, we are not restricted to simply changing the background and border colors. The more imaginative that we can be, the more our applications will stand out from the crowd.</p>
<p>For example, rather than simply changing the background color of the button, we can instead move the focal point of the gradient with the mouse. We'll need to use some code to do this, so we'll need to create another custom control to demonstrate this point. Let's first take a look at the code from our new custom control:</p>
<pre>using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Controls.Primitives; 
using System.Windows.Input; 
using System.Windows.Media; 
using CompanyName.ApplicationName.CustomControls.Enums; 
 
namespace CompanyName.ApplicationName.CustomControls 
{ 
  [TemplatePart(Name = "PART_Root", Type = typeof(Grid))] 
  public class GlowButton : ButtonBase 
  { 
    private RadialGradientBrush glowBrush = null; 
 
    static GlowButton() 
    { 
      DefaultStyleKeyProperty.OverrideMetadata (typeof(GlowButton),
        new FrameworkPropertyMetadata(typeof(GlowButton))); 
    } 
 
    public GlowMode GlowMode { get; set; } = GlowMode.FullCenterMovement; 
 
    public static readonly DependencyProperty GlowColorProperty =
      DependencyProperty.Register(nameof(GlowColor), typeof(Color),
      typeof(GlowButton), new PropertyMetadata( 
      Color.FromArgb(121, 71, 0, 255), OnGlowColorChanged)); 
 
    public Color GlowColor 
    { 
      get { return (Color)GetValue(GlowColorProperty); } 
      set { SetValue(GlowColorProperty, value); } 
    } 
      
    private static void OnGlowColorChanged( 
      DependencyObject dependencyObject, 
      DependencyPropertyChangedEventArgs e) 
    { 
      ((GlowButton)dependencyObject).SetGlowColor((Color)e.NewValue); 
    } 
 
    public override void OnApplyTemplate() 
    { 
      Grid rootGrid = GetTemplateChild("PART_Root") as Grid; 
      if (rootGrid != null) 
      { 
        rootGrid.MouseMove += Grid_MouseMove; 
        glowBrush =   
          (RadialGradientBrush)rootGrid.FindResource("GlowBrush"); 
        SetGlowColor(GlowColor); 
      } 
    } 
 
    private void SetGlowColor(Color value) 
    { 
      GlowColor = Color.FromArgb(121, value.R, value.G, value.B); 
      if (glowBrush != null) 
      { 
        GradientStop gradientStop = glowBrush.GradientStops[2]; 
        gradientStop.Color = GlowColor; 
      } 
    } 
 
    private void Grid_MouseMove(object sender, MouseEventArgs e) 
    { 
      Grid grid = (Grid)sender; 
      if (grid.IsMouseOver &amp;&amp; glowBrush != null) 
      { 
        Point mousePosition = e.GetPosition(grid); 
        double x = mousePosition.X / ActualWidth; 
        double y = GlowMode != GlowMode.HorizontalCenterMovement ?
          mousePosition.Y / ActualHeight : glowBrush.Center.Y; 
        glowBrush.Center = new Point(x, y); 
        if (GlowMode == GlowMode.HorizontalCenterMovement)  
          glowBrush.GradientOrigin = 
          new Point(x, glowBrush.GradientOrigin.Y); 
        else if (GlowMode == GlowMode.FullCenterMovement)  
          glowBrush.GradientOrigin = new Point(x, y); 
      } 
    } 
  } 
} </pre>
<p>We start as usual, by adding the relevant references and declaring the <kbd>PART_RootGrid</kbd> panel element as being a required part of the control template in the <kbd>TemplatePartAttribute</kbd> attribute. As our custom control is a button, we extend the <kbd>ButtonBase</kbd> class.</p>
<p>Next, we define the <kbd>glowBrush</kbd> field and set it to <kbd>null</kbd>. In the static constructor, we call the <kbd>OverrideMetadata</kbd> method to inform the Framework of where our control's default style is. We then declare a <kbd>GlowMode</kbd> CLR property of type <kbd>GlowMode</kbd> and set it to the default <kbd>FullCenterMovement</kbd> member. Let's see the members of this <kbd>GlowMode</kbd> enumeration now:</p>
<pre>namespace CompanyName.ApplicationName.CustomControls.Enums 
{ 
  public enum GlowMode 
  { 
    NoCenterMovement, HorizontalCenterMovement, FullCenterMovement 
  } 
} </pre>
<p>Returning to our <kbd>GlowButton</kbd> class, we also declare a <kbd>GlowColor</kbd> Dependency Property and define a default purple color, a property changed handler and some CLR property wrappers for it. In the <kbd>OnGlowColorChanged</kbd> handler method, we cast the <kbd>dependencyObject</kbd> input parameter to our <kbd>GlowButton</kbd> class and call the <kbd>SetGlowColor</kbd> method, passing in the new <kbd>Color</kbd> input value.</p>
<p>Next, we see the <kbd>OnApplyTemplate</kbd> method that is called when the button element's control template has been applied. In this method, we attempt to access the <kbd>PART_Root</kbd> panel element using the <kbd>GetTemplateChild</kbd> method and check it for <kbd>null</kbd>. If it is not <kbd>null</kbd>, we do a number of things.</p>
<p>First, we attach the <kbd>Grid_MouseMove</kbd> event handler method to the grid's <kbd>MouseMove</kbd> event. Note that this is the way to attach event handlers to the UI elements that are declared in the <kbd>Generic.xaml</kbd> file, as it has no related code behind file.</p>
<p>Next, we call the grid's <kbd>FindResource</kbd> method in order to access the <kbd>GlowBrush</kbd> resource from its <kbd>Resources</kbd> section and set it to our local <kbd>glowBrush</kbd> field, as we will be referencing it regularly. After this, we call the <kbd>SetGlowColor</kbd> method and pass in the current <kbd>GlowColor</kbd> value.</p>
<p>We do this because the <kbd>OnApplyTemplate</kbd> method is generally called after the properties have been set, but we are unable to update the brush resource until the template has been applied. When writing custom controls, we often need to update properties from this method, once the template has been applied.</p>
<p>Next is the <kbd>SetGlowColor</kbd> method and in it we first make the set color semi-transparent. If the <kbd>glowBrush</kbd> variable is not <kbd>null</kbd>, we then access the third <kbd>GradientStop</kbd> element from its <kbd>GradientStops</kbd> collection and set its <kbd>Color</kbd> property to the value of our <kbd>GlowColor</kbd> property.</p>
<p>Note that the third <kbd>GradientStop</kbd> element represents the dominant color in this gradient and so in this example, we are only updating this single element, in order to save space in this book. This gives the overall impression of a complete color change, but anyone that looks carefully will be able to see a dash of purple showing through from the other two unchanged <kbd>GradientStop</kbd> elements. You may wish to extend this example to update the whole <kbd>GradientStops</kbd> collection.</p>
<p>Next, we see the <kbd>Grid_MouseMove</kbd> event handling method that was attached to the <kbd>rootGrid</kbd> variable in the <kbd>OnApplyTemplate</kbd> method. In it, we check that the mouse is currently over the grid and that the <kbd>glowBrush</kbd> variable is not <kbd>null</kbd>. If these conditions are true, we call the <kbd>GetPosition</kbd> method on the <kbd>MouseEventArgs</kbd> input parameter to get the current position of the mouse.</p>
<p>Using the mouse position and the current value of the <kbd>GlowMode</kbd> property, we determine the movement mode and update the position of the <kbd>glowBrush</kbd> field's <kbd>Center</kbd> and/or <kbd>GradientOrigin</kbd> properties.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This has the effect of moving the center and/or the focal point of the gradient with the mouse cursor when it is over our glow button. Let's see the XAML in the <kbd>Generic.xaml</kbd> file now:</p>
<pre>&lt;Style TargetType="{x:Type CustomControls:GlowButton}"&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type CustomControls:GlowButton}"&gt; 
        &lt;Grid Name="PART_Root"&gt; 
          &lt;Grid.Resources&gt; 
            &lt;RadialGradientBrush x:Key="GlowBrush"  
              RadiusY="0.622" Center="0.5,0.848"  
              GradientOrigin="0.5,0.818" RadiusX="1.5"&gt;
              &lt;RadialGradientBrush.RelativeTransform&gt;
                &lt;ScaleTransform x:Name="ScaleTransform"  
                  CenterX="0.5" CenterY="0.5" ScaleX="1.0" ScaleY="1.8" /&gt; 
              &lt;/RadialGradientBrush.RelativeTransform&gt; 
              &lt;GradientStop Color="#B9F6F2FF" /&gt; 
              &lt;GradientStop Color="#A9F4EFFF" Offset="0.099" /&gt; 
              &lt;GradientStop Color="{Binding GlowColor, <br/>                RelativeSource={RelativeSource AncestorType={x:Type <br/>                CustomControls:GlowButton}}}" Offset="0.608" /&gt; 
              &lt;GradientStop Offset="1" Color="#004700FF" /&gt; 
            &lt;/RadialGradientBrush&gt; 
            &lt;RadialGradientBrush x:Key="LayeredButtonBackgroundBrush"  
              RadiusX="1.85" RadiusY="0.796" Center="1.018, -0.115" 
              GradientOrigin="0.65,-0.139"&gt; 
              &lt;GradientStop Color="#FFCACACD" /&gt; 
              &lt;GradientStop Color="#FF3B3D42"  Offset="1" /&gt; 
            &lt;/RadialGradientBrush&gt; 
            &lt;LinearGradientBrush x:Key="LayeredButtonCurveBrush"  
              StartPoint="0,0" EndPoint="1,1"&gt; 
              &lt;GradientStop Color="#FF747475" Offset="0" /&gt;
              &lt;GradientStop Color="#FF3B3D42" Offset="1" /&gt; 
            &lt;/LinearGradientBrush&gt; 
            &lt;Grid x:Key="LayeredButtonBackgroundElements"&gt; 
              &lt;Rectangle 
                Fill="{StaticResource LayeredButtonBackgroundBrush}" /&gt; 
              &lt;Path StrokeThickness="0"  
                Fill="{StaticResource LayeredButtonCurveBrush}"&gt;
                &lt;Path.Data&gt; 
                  &lt;CombinedGeometry GeometryCombineMode="Intersect"&gt;
                    &lt;CombinedGeometry.Geometry1&gt;
                      &lt;EllipseGeometry Center="-20,50.7" RadiusX="185"  
                        RadiusY="46" /&gt; 
                    &lt;/CombinedGeometry.Geometry1&gt;
                    &lt;CombinedGeometry.Geometry2&gt; 
                      &lt;RectangleGeometry Rect="0,0,106,24" /&gt;
                    &lt;/CombinedGeometry.Geometry2&gt; 
                  &lt;/CombinedGeometry&gt; 
                &lt;/Path.Data&gt; 
              &lt;/Path&gt; 
            &lt;/Grid&gt; 
            &lt;VisualBrush x:Key="LayeredButtonBackground"  
              Visual="{StaticResource LayeredButtonBackgroundElements}" /&gt; 
          &lt;/Grid.Resources&gt; 
          &lt;Border CornerRadius="3" BorderBrush="#7F000000"  
            BorderThickness="1" Background="#7FFFFFFF"  
            SnapsToDevicePixels="True"&gt; 
            &lt;Border CornerRadius="2" Margin="1"  
              Background="{StaticResource LayeredButtonBackground}"  
              SnapsToDevicePixels="True"&gt; 
              &lt;Grid&gt; 
                &lt;Rectangle x:Name="Glow" IsHitTestVisible="False"
                  RadiusX="2" RadiusY="2" 
                  Fill="{StaticResource GlowBrush}" Opacity="0" /&gt; 
                &lt;ContentPresenter Content="{TemplateBinding Content}"
                  Margin="{TemplateBinding Padding}"
                  HorizontalAlignment="Center"
                  VerticalAlignment="Center" /&gt;
              &lt;/Grid&gt; 
            &lt;/Border&gt; 
          &lt;/Border&gt; 
          &lt;Grid.Triggers&gt; 
            &lt;EventTrigger RoutedEvent="MouseEnter"&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Storyboard.TargetName="Glow"
                    Storyboard.TargetProperty="Opacity" To="1.0"
                    Duration="0:0:0.5" DecelerationRatio="1" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
            &lt;EventTrigger RoutedEvent="MouseLeave"&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Storyboard.TargetName="Glow"
                    Storyboard.TargetProperty="Opacity" To="0.0"
                    Duration="0:0:1" DecelerationRatio="1" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
            &lt;EventTrigger RoutedEvent="MouseDown"&gt; 
              &lt;BeginStoryboard&gt; 
                &lt;Storyboard&gt; 
                  &lt;DoubleAnimation Storyboard.TargetName="ScaleTransform"
                    Storyboard.TargetProperty="ScaleX" From="10.0"
                    To="1.0" Duration="0:0:0.15" AccelerationRatio="0.5" /&gt; 
                  &lt;DoubleAnimation Storyboard.TargetName="ScaleTransform"
                    Storyboard.TargetProperty="ScaleY" From="10.0"
                    To="1.8" Duration="0:0:0.15" AccelerationRatio="0.5" /&gt; 
                &lt;/Storyboard&gt; 
              &lt;/BeginStoryboard&gt; 
            &lt;/EventTrigger&gt; 
          &lt;/Grid.Triggers&gt; 
        &lt;/Grid&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>Inside this <kbd>ControlTemplate</kbd>, we see the <kbd>Grid</kbd> named <kbd>PART_Root</kbd>, and, inside it, we see a number of resources declared in its <kbd>Resources</kbd> section. Much of this XAML is taken up by the same resources that we used in our layered button background example, so we can skip their explanation.</p>
<p>There is however, one new resource of type <kbd>RadialGradientBrush</kbd> and named <kbd>GlowBrush</kbd>. This is the brush that puts the color into our button. In particular, note that its <kbd>RelativeTransform</kbd> property is set to a <kbd>ScaleTransform</kbd> element named <kbd>ScaleTransform</kbd> and that its third <kbd>GradientStop</kbd> object is data bound to the <kbd>GlowColor</kbd> property from our control.</p>
<p>In the actual template, we see our double <kbd>Border</kbd> elements with their <kbd>SnapsToDevicePixels</kbd> properties set to true to ensure a sharp, rendered image. Again, the outer border has a larger <kbd>CornerRadius</kbd> value than the inner border, to ensure their tight fit together, and the inner border's background is painted with the <kbd>LayeredButtonBackground</kbd> visual brush that we saw earlier.</p>
<p>Inside the inner border, we have a <kbd>Grid</kbd> panel that contains a <kbd>Rectangle</kbd> element and the required <kbd>ContentPresenter</kbd> object. We use the <kbd>GlowBrush</kbd> resource to paint the background of the rectangle and set its <kbd>IsHitTestVisible</kbd> property to <kbd>false</kbd>, so that it takes no part in user interaction. Note that in this example, we set its <kbd>Opacity</kbd> property to zero to make it initially invisible.</p>
<p>We data bind the button's <kbd>Content</kbd> and <kbd>Padding</kbd> properties to the <kbd>Content</kbd> and <kbd>Margin</kbd> properties of the <kbd>ContentPresenter</kbd> element, respectively, and center it within the control. That completes the visual markup for our glow button and now, we reach the all-important <kbd>Grid.Triggers</kbd> collection, where we declare three <kbd>EventTrigger</kbd> objects to trigger our mouse over effects.</p>
<p>The first trigger starts its associated storyboard when the <kbd>MouseEnter</kbd> event is raised. Its associated <kbd>DoubleAnimation</kbd> object animates the "glowing" rectangle's <kbd>Opacity</kbd> property to <kbd>1.0</kbd> over half a second. Note that we omit the <kbd>From</kbd> property here, so that the <kbd>Opacity</kbd> value will start animating from its current value, rather than jumping back to <kbd>0.0</kbd> each time it starts the animation.</p>
<p>The second trigger starts its storyboard when the <kbd>MouseLeave</kbd> event is raised. Its <kbd>DoubleAnimation</kbd> object animates the rectangle's <kbd>Opacity</kbd> property back to <kbd>0.0</kbd> over a whole second. Note that we also omit the <kbd>From</kbd> property here so that the <kbd>Opacity</kbd> value will start animating from its current value, rather than jumping to <kbd>1.0</kbd> each time it starts its animation. This ensures a smoother transition.</p>
<p>The third trigger starts its storyboard when the <kbd>MouseDown</kbd> event is raised and it contains two <kbd>DoubleAnimation</kbd> objects. They animate the <kbd>ScaleX</kbd> and <kbd>ScaleY</kbd> properties of the <kbd>ScaleTransform</kbd> object from <kbd>10.0</kbd> to their usual values over one hundred and fifty milliseconds, which produces an interesting effect when the user clicks the button.</p>
<p>Using the <kbd>GlowColor</kbd> and <kbd>GlowMode</kbd> properties, we can produce a wide range of buttons and interaction effects. After defining the relevant XAML namespace in our View, we can use this glow button example in the following way:</p>
<pre>&lt;CustomControls:GlowButton Content="Glowing button"  
  GlowMode="NoCenterMovement" GlowColor="Red" FontSize="28"  
  Foreground="White" Height="60" Width="275" /&gt; </pre>
<p>When our example is run, it can produce mouse over effects, which vary depending on the position of the mouse cursor, as shown in the following examples:</p>
<div><img class="alignnone size-full wp-image-2047 image-border" src="img/e7db5a27-60f6-4860-bdfc-b8e067842d25.png" style="width:52.92em;height:17.08em;"/><br/></div>
<p>The top left button illustrates the <kbd>HorizontalCenterMovement</kbd> mode, the top right shows the <kbd>FullCenterMovement</kbd> mode and the bottom two highlight two mouse positions when using the <kbd>NoCenterMovement</kbd> mode. The top two use the default color and the bottom two were rendered using a <kbd>GlowColor</kbd> of <kbd>Red</kbd>. This reveals the differences between the various <kbd>GlowMode</kbd> values in our example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we investigated a number of techniques that we can use to improve the look of our applications, from simply adding shadows to implementing far more complicated layered visuals. We saw the importance of remaining consistent throughout our application and how to get that professional look.</p>
<p>We then looked at more advanced techniques for making our application stand out from the crowd and saw further examples of how to create a variety of custom controls. We finished with a look at how we can incorporate animations into our everyday controls, in order to bring about a sense of exclusivity to our applications.</p>
<p>In the following chapter, we're going to investigate a number of ways that we can validate the data in our applications. We'll examine the various validation interfaces that are available to us in WPF and work on extending our application framework with a complete validation system using data annotations.</p>


            

            
        
    </body></html>