- en: 3 Architectural Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin: Join our book community on Discord'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Qr code Description automatically generated](img/file11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter delves into fundamental architectural principles: pillars of contemporary
    software development practices. These principles help us create flexible, resilient,
    testable, and maintainable code.We can use these principles to stimulate critical
    thinking, fostering our ability to evaluate trade-offs, anticipate potential issues,
    and create solutions that stand the test of time by influencing our decision-making
    process and helping our design choices.As we embark on this journey, we constantly
    refer to those principles throughout the book, particularly the SOLID principles,
    which improve our ability to build flexible and robust software systems.In this
    chapter, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The separation of concerns (SoC) principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **DRY** principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **KISS** principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **SOLID** principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also revise the following notions:'
  prefs: []
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contravariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns (SoC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name implies, the idea is to separate our software into logical blocks,
    each representing a concern. A “concern” refers to a specific aspect of a program.
    It’s a particular interest or focus within a system that serves a distinct purpose.
    Concerns could be as broad as data management, as specific as user authentication,
    or even more specific, like copying an object into another. The Separation of
    Concerns principle suggests that each concern should be isolated and managed separately
    to improve the system’s maintainability, modularity, and understandability.
  prefs: []
  type: TYPE_NORMAL
- en: The Separation of Concerns principle applies to all programming paradigms. In
    a nutshell, this principle means factoring a program into the correct pieces.
    For example, modules, subsystems, and microservices are macro-pieces, while classes
    and methods are smaller pieces.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'By correctly separating concerns, we can prevent changes in one area from affecting
    others, allow for more efficient code reuse, and make it easier to understand
    and manage different parts of a system independently.Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Security and logging are cross-cutting concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a user interface is a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling an HTTP request is a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying an object into another is a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrating a distributed workflow is a concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving to the DRY principle, it is imperative to consider concerns when
    dividing software into pieces to create cohesive units. A good separation of concerns
    helps create modular designs and face design dilemmas more effectively, leading
    to a maintainable application.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t repeat yourself (DRY)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The DRY principle advocates the separation of concerns principle and aims to
    eliminate redundancy in code as well. It promotes the idea that each piece of
    knowledge or logic should have a single, unambiguous representation within a system.So,
    when you have duplicated logic in your system, encapsulate it and reuse that new
    encapsulation in multiple places instead. If you find yourself writing the same
    or similar code in multiple places, refactor that code into a reusable component
    instead. Leverage functions, classes, modules, or other abstractions to refactor
    the code.Adhering to the DRY principle makes your code more maintainable, less
    error-prone, and easier to modify because a change in logic or bug fix needs to
    be made in only one place, reducing the likelihood of introducing errors or inconsistencies.However,
    it is imperative to regroup duplicated logic by concern, not only by the similarities
    of the code itself. Let’s look at those two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is very similar, but encapsulating a single class or method could
    very well be a mistake. Why? Keeping two separate classes is more logical because
    the admin program can have different reasons for modification compared to the
    public program.However, encapsulating the list logic into the `IBookPresenter`
    interface could make sense. It would allow us to react differently to both types
    of users if needed, like filtering the admin panel list but doing something different
    in the public section. One way to do this is by replacing the `foreach` loop with
    a `presenter` `DisplayListAsync(books)` call, like the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There is more to those simple implementations to discuss, like the possibility
    of supporting multiple implementations of the interfaces for added flexibility,
    but let’s keep some subjects for further down the book.
  prefs: []
  type: TYPE_NORMAL
- en: When you don’t know how to name a class or a method, you may have identified
    a problem with your separation of concerns. This is a good indicator that you
    should go back to the drawing board. Nevertheless, naming is hard, so sometimes,
    that’s just it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keeping our code DRY while following the separation of concerns principles is
    imperative. Otherwise, what may seem like a good move could become a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: Keep it simple, stupid (KISS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another straightforward principle, yet one of the most important. Like
    in the real world, the more moving pieces, the more chances something breaks.
    This principle is a design philosophy that advocates for simplicity in design.
    It emphasizes the idea that systems work best when they are kept simple rather
    than made complex.Striving for simplicity might involve writing shorter methods
    or functions, minimizing the number of parameters, avoiding over-architecting,
    and choosing the simplest solution to solve a problem.Adding interfaces, abstraction
    layers, and complex object hierarchy adds complexity, but are the added benefits
    better than the underlying complexity? If so, they are worth it; otherwise, they
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: As a guiding principle, when you can write the same program with less complexity,
    do it. This is also why predicting future requirements can often prove detrimental,
    as it may inadvertently inject unnecessary complexity into your codebase for features
    that might never materialize.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We study design patterns in the book and design systems using them. We learn
    how to apply a high degree of engineering to our code, which can lead to over-engineering
    if done in the wrong context. Towards the end of the book, we circle back on the
    KISS principle when exploring the vertical slice architecture and request-endpoint-response
    (REPR) patterns.Next, we delve into the SOLID principles, which are the key to
    flexible software design.
  prefs: []
  type: TYPE_NORMAL
- en: The SOLID principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SOLID is an acronym representing five principles that extend the basic OOP
    concepts of **Abstraction**, **Encapsulation**, **Inheritance**, and **Polymorphism**.
    They add more details about what to do and how to do it, guiding developers toward
    more robust and flexible designs.It is crucial to remember that these are just
    guiding principles, not rules that you must follow, no matter what. Think about
    what makes sense for your specific project. If you’re building a small tool, it
    might be acceptable not to follow these principles as strictly as you would for
    a crucial business application. In the case of business-critical applications,
    it might be a good idea to stick to them more closely. Still, it’s usually a smart
    move to follow them, no matter the size of your app. That’s why we’re discussing
    them before diving into design patterns.The SOLID acronym represents the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S**ingle responsibility principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**O**pen/Closed principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L**iskov substitution principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**nterface segregation principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**ependency inversion principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these principles, your systems should become easier to test and
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle (SRP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Essentially, the SRP means that a single class should hold one, and only one,
    responsibility, leading me to the following quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“There should never be more than one reason for a class to change.”— Robert
    C. Martin, originator of the single responsibility principle*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OK, but why? Before answering, take a moment to remember a project you’ve worked
    on where someone changed one or more requirements along the way. I recall several
    projects that would have benefited from this principle. Now, imagine how much
    simpler it would have been if each part of your system had just one job: one reason
    to change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Software maintainability problems can be due to both tech and non-tech people.
    Nothing is purely black or white—most things are a shade of gray. The same applies
    to software design: always do your best, learn from your mistakes, and stay humble
    (a.k.a. continuous improvement).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By understanding that applications are born to change, you will feel better
    when that happens, while the SRP helps mitigate the impact of changes. For example,
    it helps make our classes more readable and reusable and to create more flexible
    and maintainable systems. Moreover, when a class does only one thing, it’s easier
    to see how changes will affect the system, which is more challenging with complex
    classes since one change might break other parts. Furthermore, fewer responsibilities
    mean less code. Less code is easier to understand, helping you grasp that part
    of the software more quickly.Let’s try this out in action.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Single Responsibility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we look at the `Product` class used in both code samples. That class
    represents a simple fictive product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code sample has no implementation because it is irrelevant to understanding
    the SRP. We focus on the class API instead. Please assume we implemented the data-access
    logic using your favorite database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following class breaks the SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What does not conform to the SRP in the preceding class? By reading the name
    of the methods, we can extract two responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling public products (highlighted code).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling private products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ProductRepository` class mixes public and private product logic. From
    that API alone, there are many possibilities where an error could lead to leaking
    restricted data to public users. That is also true because the class exposes the
    private logic to the public-facing consumers; someone else could make a mistake.We
    are ready to rethink the class now that we identified the responsibilities. We
    know it has two responsibilities, so breaking the class into two sounds like an
    excellent first step. Let’s start with extracting a public API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PublicProductReader` class now contains only two methods: `GetAllAsync`
    and `GetOneAsync`. When reading the name of the class and its methods, it is clear
    that the class handles only public product data. By lowering the complexity of
    the class, we made it easier to understandNext, let’s do the same for the private
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `PrivateProductRepository` class follows the same pattern. It includes the
    read methods, named the same as the `PublicProductReader` class, and the mutation
    methods only users with private access can use.We improved our code’s readability,
    flexibility, and security by splitting the initial class into two. However, one
    thing to be careful about with the SRP is not to over-separate classes. The more
    classes in a system, the more complex assembling the system can become, and the
    harder it can be to debug and follow the execution paths. On the other hand, many
    well-separated responsibilities should lead to a better, more testable system.It
    is tough to define one hard rule that defines “one reason” or “a single responsibility”.
    However, as a rule of thumb, aim at packing a cohesive set of functionalities
    in a single class that revolves around its responsibility. You should strip out
    any excess logic and add missing pieces.A good indicator of the SRP violation
    is when you don’t know how to name an element, which points towards the fact that
    the element should not reside there, that you should extract it, or that you should
    split it into multiple smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Using precise names for variables, methods, classes, and other elements is very
    important and should not be overlooked.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another good indicator is when a method becomes too big, maybe containing many
    `if` statements or loops. In that case, you can split that method into multiple
    smaller methods, classes, or any other construct that suits your requirements.
    That should make the code easier to read and make the initial method’s body cleaner.
    It often also helps you get rid of useless comments and improve testability. Next,
    we explore how to change behaviors without modifying code, but before that, let’s
    look at interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Open/Closed principle (OCP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start this section with a quote from Bertrand Meyer, the person who first
    wrote the term open/closed principle in 1988:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Software entities (classes, modules, functions, and so on) should be open
    for extension but closed for modification.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OK, but what does that mean? It means you should be able to change the class
    behaviors from the outside without altering the code.As a bit of history, the
    first appearance of the OCP in 1988 referred to inheritance, and OOP has evolved
    a lot since then. Inheritance is still useful, but you should be careful as it
    is easily misused. Inheritance creates direct coupling between classes. You should,
    most of the time, opt for composition over inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: “Composition over inheritance” is a principle that suggests it’s better to build
    objects by combining simple, flexible parts (composition) rather than by inheriting
    properties from a larger, more complex object (inheritance).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think of it like building with LEGO® blocks. It’s easier to build and adjust
    your creation if you put together small blocks (composition) rather than trying
    to alter a big, single block that already has a fixed shape (inheritance).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Meanwhile, we explore three versions of a business process to illustrate the
    OCP.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Open Close
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we look at the `Entity` and `EntityRepository` classes used in the code
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Entity` class represents a simple fictive entity with no properties; consider
    it anything you’d like. The `EntityRepository` class has a single `CreateAsync`
    method that inserts an instance of an `Entity` in a database (if it was implemented).
  prefs: []
  type: TYPE_NORMAL
- en: The code sample has few implementation details because it is irrelevant to understanding
    the OCP. Please assume we implemented the `CreateAsync` logic using your favorite
    database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For the rest of the sample, we refactor the `EntityService` class, beginning
    with a version that inherits the `EntityRepository` class, breaking the OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As the namespace implies, the preceding `EntityService` class offers no composability.
    Moreover, we tightly coupled it with the `EntityRepository` class. Since we just
    covered the *composition over inheritance* principle, we can quickly isolate the
    problem: **inheritance**.As the next step to fix this mess, let’s extract a private
    `_repository` field to hold an `EntityRepository` instance instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `EntityService` is composed of an `EntityRepository` instance, and
    there is no more inheritance. However, we still tightly coupled both classes,
    and it is impossible to change the behavior of the `EntityService` this way without
    changing its code.To fix our last issues, we can inject an `EntityRepository`
    instance into the class constructor where we set our private field like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding change, we broke the tight coupling between the `EntityService`
    and the `EntityRepository` classes. We can also control the behavior of the `EntityService`
    class from the outside by deciding what instance of the `EntityRepository` class
    we inject into the `EntityService` constructor. We could even go further by leveraging
    an abstraction instead of a concrete class and explore this subsequently while
    covering the DIP.As we just explored, the OCP is a super powerful principle, yet
    simple, that allows controlling an object from the outside. For example, we could
    create two instances of the `EntityService` class with different `EntityRepository`
    instances that connect to different databases. Here’s a rough example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, assuming we implemented the `EntityRepository` class
    and configured `repository1` and `repository2` differently, the result of executing
    the `ComplexBusinessProcessAsync` method on `service1` and `service2` would create
    the entity in two different databases. The behavior change between the two instances
    happened without changing the code of the `EntityService` class; composition:
    1, inheritance: 0.'
  prefs: []
  type: TYPE_NORMAL
- en: We explore the **Strategy pattern**—the best way of implementing the OCP—in
    *Chapter 5*, *Strategy, Abstract Factory, and Singleton*. We revisit that pattern
    and also learn to assemble our program’s well-designed pieces and sew them together
    using dependency injection in *Chapter 6*, *Dependency Injection*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore the principle we can perceive as the most complex of the five,
    yet the one we will use the less.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle (LSP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Liskov Substitution Principle (LSP) states that in a program, if we replace
    an instance of a superclass (supertype) with an instance of a subclass (subtype),
    the program should not break or behave unexpectedly.Imagine we have a base class
    called `Bird` with a function called `Fly`, and we add the `Eagle` and `Penguin`
    subclasses. Since a penguin can’t fly, replacing an instance of the `Bird` class
    with an instance of the `Penguin` subclass might cause problems because the program
    expects all birds to be able to fly.So, according to the LSP, our subclasses should
    behave so the program can still work correctly, even if it doesn’t know which
    subclass it’s using, preserving system stability.Before moving on with the LSP,
    let’s look at covariance and contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We won’t go too deep into this, so we don’t move too far away from the LSP,
    but since the formal definition mentions them, we must understand these at least
    a minimum.Covariance and contravariance represent specific polymorphic scenarios.
    They allow reference types to be converted into other types implicitly. They apply
    to generic type arguments, delegates, and array types. Chances are, you will never
    need to remember this, as most of it is implicit, yet, here’s an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Covariance (**`out`**)** enables us to use a more derived type (a subtype)
    instead of the supertype. Covariance is usually applicable to method return types.
    For instance, if a base class method returns an instance of a class, the equivalent
    method of a derived class can return an instance of a subclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contravariance (**`in`**)** is the reverse situation. It allows a less derived
    type (a supertype) to be used instead of the subtype. Contravariance is usually
    applicable to method argument types. If a method of a base class accepts a parameter
    of a particular class, the equivalent method of a derived class can accept a parameter
    of a superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use some code to understand this more, starting with the model we are
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Simple class hierarchy, we have a `TwoHandedSword` class that inherits from
    the `Sword` class and the `Sword` class that inherits from the `Weapon` class.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To demo covariance, we leverage the following generic interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In C#, the `out` modifier, the highlighted code, explicitly specifies that
    the generic parameter `T` is covariant. Covariance applies to return types, hence
    the `Get` method that returns the generic type `T`.Before testing this out, we
    need an implementation. Here’s a barebone one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code, which represents the `T` parameter, is of type `Sword`,
    a subclass of `Weapon`. Since covariance means you can **return (output) the instance
    of a subtype as its supertype**, using the `Sword` subtype allows exploring this
    with the `Weapon` supertype. Here’s the xUnit fact that demonstrates covariance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line represents covariance, showing that we can implicitly convert
    the `ICovariant<Sword>` subtype to the `ICovariant<Weapon>` supertype.The code
    after that showcases what happens with that polymorphic change. For example, the
    `Get` method of the `weaponGetter` object returns a `Weapon` type, not a `Sword`,
    even if the underlying instance is a `SwordGetter` object. However, that `Weapon`
    is, in fact, a `Sword`, as the assertions demonstrate.Next, let’s explore contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Contravariance**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To demo covariance, we leverage the following generic interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In C#, the `in` modifier, the highlighted code, explicitly specifies that the
    generic parameter `T` is contravariant. Contravariance applies to input types,
    hence the `Set` method that takes the generic type `T` as a parameter.Before testing
    this out, we need an implementation. Here’s a barebone one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code, which represents the `T` parameter, is of type `Weapon`,
    the topmost class in our model; other classes derive from it. Since contravariance
    means you can **input the instance of a subtype as its supertype**, using the
    `Weapon` supertype allows exploring this with the `Sword` and `TwoHandedSword`
    subtypes. Here’s the xUnit fact that demonstrates contravariance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted line represents contravariance. We can implicitly convert the
    `IContravariant<Weapon>` supertype to the `IContravariant<Sword>` subtype.The
    code after that showcases what happens with that polymorphic change. For example,
    the `Set` method of the `weaponSetter` object can take a `Weapon`, a **Sword**
    , or a `TwoHandedSword` instance because they are all subtypes of the `Weapon`
    type (or is the `Weapon` type itself).The same happens with the `swordSetter`
    instance, but it only takes a `Sword` or a `TwoHandedSword` instance, starting
    at the `Sword` type in the inheritance hierarchy because the compiler considers
    the `swordSetter` instance to be an `IContravariant<Sword>`, even if the underlying
    implementation is of the `WeaponSetter` type.Writing the following yields a compiler
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The error is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That means that for the compiler, `swordSetter` is of type `IContravariant<Sword>`,
    not `IContravariant<Weapon>`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I left a link in the *Further reading* section that explains covariance and
    contravariance if you want to know more since we just covered the basics here.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we grazed covariance and contravariance, we are ready to explore the
    formal version of the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: The LSP explained
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The LSP came from Barbara Liskov at the end of the ‘80s and was revisited during
    the ‘90s by both Liskov and Jeannette Wing to create the principle that we know
    and use today. It is also similar to *Design by contract*, by Bertrand Meyer.Next,
    let’s look at the formal subtype requirement definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Let ![img](img/file12.png) be a property provable about objects x of type
    T. Then, ![img](img/file13.png) should be true for objects y of type S, where
    S is a subtype of T.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In simpler words, if `S` is a subtype of `T`, we can replace objects of type
    `T` with objects of type `S` without changing any of the expected behaviors of
    the program (correctness).The LSP adds the following signature requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters of methods in subtypes must be contravariant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of methods in subtypes must be covariant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t throw a new type of exception in subtypes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two rules are tough to violate without effort in C#.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Throwing a new type of exception in subtypes is also considered changing behaviors.
    You can, however, throw subtyped exceptions in subtypes because the existing consumers
    can handle them.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The LSP also adds the following behavioral conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conditions** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| Any precondition implemented in a supertype should yield the same outcome
    in its subtypes, but subtypes can be less strict about it, never more. | If a
    supertype validates that an argument cannot be `null` , the subtype could remove
    that validation but not add stricter validation rules. |'
  prefs: []
  type: TYPE_TB
- en: '| Any postcondition implemented in a supertype should yield the same outcome
    in its subtypes, but subtypes can be more strict about it, never less. | If the
    supertype never returns `null`, the subtype should not return `null` either or
    risk breaking the consumers of the object that are not testing for `null`.If the
    supertype does not guarantee the returned value cannot be `null`, then a subtype
    could decide never to return `null`, making both instances interchangeable. |'
  prefs: []
  type: TYPE_TB
- en: '| Subtypes must preserve the invariance of the supertype. | A subtype must
    pass all the tests written for the supertype, so there is no variance between
    them (they don’t vary/they react the same). |'
  prefs: []
  type: TYPE_TB
- en: '| The history constraint dictates that what happens in the supertype must still
    occur in the subtype, and you can’t change this. | A subtype can add new properties
    (state) and methods (behaviors).A subtype must not modify the supertype state
    in any new way. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: LSP behavioral conditions'
  prefs: []
  type: TYPE_NORMAL
- en: OK, at this point, you are right to feel that this is rather complex. Yet, rest
    assured that this is the less important of those principles because we are moving
    as far as we can from inheritance, so the LSP should not apply often.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the LSP to:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In your subtypes, add new behaviors and states; don’t change existing ones.*'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In a nutshell, applying the LSP allows us to swap an instance of a class for
    one of its subclasses without breaking anything.To make a LEGO® analogy: LSP is
    like swapping a 4x2 block with a 4x2 block with a sticker on it: neither the structure''s
    structural integrity nor the block''s role changed; the new block only has a new
    sticker state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An excellent way of enforcing those behavioral constraints is automated testing.
    You can write a test suite and run it against all subclasses of a specific supertype
    to enforce the preservation of behaviors.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s jump into some code to visualize that in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Liskov Substitution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To demonstrate the LSP, we will explore some scenarios. Each scenario is a
    test class that follows the same structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code structure, the highlighted code changes for every test.
    The setup is simple; I use the test method to simulate code that a program could
    execute, and just by running the same code three times on different classes, each
    theory fails once:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial test passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test of a subtype respecting the LSP passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test of a subtype violating the LSP fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter `sut` is the subject under test, a well-known acronym.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Of course, we can’t explore all scenarios, so I picked three; let’s check the
    first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 1: ExceptionTest'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This scenario explores what can happen when a subtype throws a new exception
    type.The following code is the consumer of the subject under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very standard. We wrapped the execution of some code
    (the `Do` method) in a try-catch block to handle a specific exception.The initial
    subject under test (the `SuperClass`) simulates that at some point during the
    execution of the `Do` method, it throws an exception of type `SuperException`.
    When we execute the code, the try-catch block catches the `SuperException`, and
    everything goes as planned. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `SubClassOk` class simulates that the execution changed, and it throws
    a `SubException` that inherits the `SuperException` class. When we execute the
    code, the try-catch block catches the `SubException`, because it’s a subtype of
    `SuperException`, and everything goes as planned. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `SubClassBreak` class simulates that it is throwing `AnotherException`,
    a new type of exception. When we execute the code, the program stops unexpectedly
    because we did not design the try-catch block for that. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So as trivial as it may sound, throwing that exception breaks the program and
    go against the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 2: PreconditionTest'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This scenario explores that *any precondition implemented in a supertype should
    yield the same outcome in its subtypes, but subtypes can be less strict about
    it, never more*.The following code is the consumer of the subject under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very standard. We have the `value` variable that could
    come from anywhere. Then we pass it to the `IsValid` method. Finally, we do something
    with the `result`; in this case, we write a line to the console.The initial subject
    under test (the `SuperClass`) simulates that a precondition exists that enforces
    that the value must be positive. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `SubClassOk` class simulates that the execution changed and tolerates
    negative values up to -10\. Everything is fine when executing the code because
    the precondition is less strict. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `SubClassBreak` class simulates that the execution changed and
    restricts using values under 10\. When executing the code, it breaks because we
    were not expecting that error; the precondition was more strict than the `SuperClass`.
    Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Yet another example of how a simple change can break its consumers and the LSP.
    Of course, this is an overly simplified example focusing only on the precondition,
    but the same applies to more complex scenarios. Coding is like playing with blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario 3: PostconditionTest'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'This scenario explores that *postconditions implemented in a supertype should
    yield the same outcome in its subtypes, but subtypes can be more strict about
    it, never less*.The following code is the consumer of the subject under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very standard and very similar to the second scenario.
    We have the `value` variable that could come from anywhere. Then we pass it to
    the `Do` method. Finally, we do something with the `result`; in this case, we
    write a line to the console. The `Do` method returns an instance of a `Model`
    class, which has only a `Value` property. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The initial subject under test (the `SuperClass`) simulates that at some point
    during the execution, it returns a `Model` instance and sets the value of the
    `Value` property to the value of the `value` parameter. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `SubClassOk` class simulates that the execution changed and returns
    a `SubModel` instance instead. The `SubModel` class inherits the `Model` class
    and adds a `DoCount` property. When executing the code, everything is fine because
    the output is invariant (a `SubModel` is a `Model` and behaves the same). Here’s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `SubClassBreak` class simulates that the execution changed and
    returns `null` when the value of the `value` parameter is 5\. When executing the
    code, it breaks at runtime with a `NullReferenceException` when accessing the
    `Value` property during the interpolation that happens in the `Console.WriteLine`
    call. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This last scenario shows once again how a simple change can break our program.
    Of course, this is also an overly simplified example focusing only on the postcondition
    and history constraint, but the same applies to more complex scenarios.What about
    the history constraint? We added a new state element to the `SubClassOk` class
    by creating the `_doCount` field. Moreover, by adding the `SubModel` class, we
    added the `DoCount` property to the return type. That field and property were
    nonexistent in the supertype, and they did not alter its behaviors: LSP followed!'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The key idea of the LSP is that the consumer of a supertype should remain unaware
    of whether it''s interacting with an instance of a supertype or an instance of
    a subtype.We could also name this principle the backward-compatibility principle
    because everything that worked in a way before must still work at least the same
    after the substitution, which is why this principle is essential.Once again, this
    is only a principle, not a law. You can also see a violation of the LSP as a *code
    smell*. From there, analyze whether you have a design problem and its impact.
    Use your analytical skills on a case-by-case basis and conclude whether or not
    it would be acceptable to break the LSP in that specific case. Sometimes you want
    to change the program''s behavior and break the LSP, but beware that you might
    break certain execution paths you did not account for and introduce defects.The
    more we progress, the more we move away from inheritance, and the less we need
    to worry about this principle. However, if you use inheritance and want to ensure
    your subtypes don’t break the program: apply the LSP, and you will be rewarded
    by improving your chances of producing defect-free, backward-compatible changes.Let’s
    look at the ISP next.'
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle (ISP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with another famous quote by Robert C. Martin:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Many client-specific interfaces are better than one general-purpose interface.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What does that mean? It means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You should create interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should value small interfaces more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not create multipurpose interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see a multipurpose interface as “an interface to rule them all” or a
    God class, introduced in *Chapter 1*, *Introduction*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An interface could refer to a class interface (the public members of a class)
    or a C# interface. We focus on C# interfaces in the book, as we use them extensively.
    Moreover, C# interfaces are very powerful.Speaking of interfaces, let’s quickly
    look at them before digging into some code.
  prefs: []
  type: TYPE_NORMAL
- en: What is an interface?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Interfaces are among the most valuable tools in the C# toolbox for creating
    flexible and maintainable software. It can be tough to understand and grasp the
    power of interfaces at first, especially from an explanation, so don’t worry if
    you don’t; you will see plenty in action throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an interface as allowing a class to impersonate different things
    (APIs), bringing polymorphism to the next level.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next are some more details that overview interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: The role of an interface is to define a cohesive contract (public methods, properties,
    and events). In its theoretical form, an interface contains no code; it is only
    a contract. In practice, since C# 8, we can create default implementation in interfaces,
    which could be helpful to limit breaking changes in a library (such as adding
    a method to an interface without breaking any class implementing that interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface should be small (ISP), and its members should align toward a common
    goal (cohesion) and share a single responsibility (SRP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C#, a class can implement multiple interfaces, exposing multiples of those
    public contracts or, more accurately, be any and all of them. By leveraging polymorphism,
    we can consume a class as if it was any of the interfaces it implements or its
    supertype if it inherits another class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class does not inherit from an interface; it implements an interface. However,
    an interface can inherit from another interface.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s explore the ISP example now that we refreshed our memory.
  prefs: []
  type: TYPE_NORMAL
- en: Project – Interface Segregation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this project, we start with the same class as the SRP example but extract
    an interface from the `ProductRepository` class. Let’s start by looking at the
    `Product` class as a reminder, which represents a simple fictive product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code sample has no implementation because it is irrelevant to understanding
    the ISP. We focus on the interfaces instead. Please assume we implemented the
    data-access logic using your favorite database.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now, let’s look at the interface extracted from the `ProductRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the `IProductRepository` interface breaks the SRP and the ISP
    the same way the `ProductRepository` class did before. We already identified the
    SRP issues earlier but did not reach the point of extracting interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductRepository` class implements the `IProductRepository` interface
    and is the same as the SRP example (all methods `throw new NotImplementedException()`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the SRP example, we identified the following responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling public products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling private products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on our previous analysis, we have two functional requirements (public
    and private access). By digging deeper, we can also identify five different database
    operations. Here’s the result in a grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Public** | **Private** |'
  prefs: []
  type: TYPE_TB
- en: '| Read one product | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Read all products | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Create a product | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Update a product | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Delete a product | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: a grid that shows what the software needs to do (functional requirements)
    and what needs to happen in the database (database operation requirements).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extract the following families of database operations from Table 3.3:'
  prefs: []
  type: TYPE_NORMAL
- en: Read products (read one, read all).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write or alter products (create, update, delete).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on that more thorough analysis, we can extract the `IProductReader` and
    `IProductWriter` interfaces representing the database operation. Then we can create
    the `PublicProductReader` and `PrivateProductRepository` classes to implement
    our functional requirements.Let’s start with the `IProductReader` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With this interface, we cover the *read one product* and *read all products*
    use cases. Next, the `IProductWriter` interface covers the other three database
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can cover all the database use cases with the preceding interfaces. Next,
    let’s create the `PublicProductReader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `PublicProductReader` only implements the `IProductReader`
    interface, covering the identified scenarios. We do the `PrivateProductRepository`
    class next before exploring the advantages of the ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `PrivateProductRepository` class implements the
    `IProductReader` and `IProductWriter` interfaces, covering all the database needs.
    Now that we have covered the building blocks, let’s explore what this can do.
    Here’s the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, the `ReadProducts`, `ModifyProducts`, and `ReadAndUpdateProducts`
    methods write messages in the console to demonstrate the advantages of applying
    the ISP.The `publicProductReader` (instance of `PublicProductReader`) and `privateProductRepository`
    (instance of `PrivateProductRepository`) variables are passed to the methods to
    show what we can and cannot do with the current design.Before getting into the
    weed, when we execute the program, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: First operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code represents the first operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `PublicProductReader` and `PrivateProductRepository` classes implement
    the `IProductReader` interface, the `ReadProducts` method accepts them, leading
    to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That means we can centralize some code that reads from both implementations
    without changing them.
  prefs: []
  type: TYPE_NORMAL
- en: Second operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code represents the second operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since only the `PrivateProductRepository` class implements the `IProductWriter`
    interface, the `WriteProducts` method accepts only the `privateProductRepository`
    variable and outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one advantage of well-segregated interfaces and responsibilities; if
    we try to execute the following line, the compiler yields the error saying that
    we “cannot convert from PublicProductReader to IProductWriter”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That error makes sense because PublicProductReader does not implement the `IProductWriter`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Third operation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code represents the third operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the two calls to the `ReadAndWriteProducts` method individually,
    but before that, let’s look at the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first execution reads and writes to the `PrivateProductRepository` instance,
    which is possible because it implements both the `IProductReader` and `IProductWriter`
    interfaces.The second call, however, reads from the public reader but writes using
    the private writer. The last example shows the power of the ISP, especially when
    mixed with the SRP, and how easy it is to swap one piece for another when segregating
    our interfaces correctly and designing our code for the program’s use cases.
  prefs: []
  type: TYPE_NORMAL
- en: You should not divide all your repositories into readers and writers; this sample
    only demonstrates some possibilities. Always design your programs for the specifications
    that you have.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To summarize the idea behind the ISP, if you have multiple smaller interfaces,
    it is easier to reuse them and expose only the features you need instead of exposing
    APIs that part of your program doesn’t need. Furthermore, it is easier to compose
    bigger pieces using multiple specialized interfaces by implementing them as needed
    than remove methods from a big interface if we don’t need them in one of its implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway is to **only depend on the interfaces that you consume**.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you don’t see all of the benefits yet, don’t worry. All the pieces should
    come together as we move on to the last SOLID principle, to dependency injection,
    the rest of the book, and as you practice applying the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Like the SRP, be careful not to overuse the ISP mindlessly. Think about cohesion
    and what you are trying to achieve, not how granular an interface can become.
    The finer-grained your interfaces, the more flexible your system will be but remember
    that flexibility has a cost, which can become very high very quickly. For example,
    your highly-flexible system may be very hard to navigate and understand, increasing
    the cognitive load required to work on the project.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, we explore the last of the SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle (DIP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DIP provides flexibility, testability, and modularity, by reducing tight
    coupling between classes or modules.Let’s continue with another quote from Robert
    C. Martin (including the implied context from Wikipedia):'
  prefs: []
  type: TYPE_NORMAL
- en: '*One should “depend upon abstractions, [not] concretions.”*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous section, we explored interfaces (abstractions), one of the pivotal
    elements of our SOLID arsenal, and using interfaces is the best way to approach
    the DIP.
  prefs: []
  type: TYPE_NORMAL
- en: Are you wondering why not use abstract classes? While helpful at providing default
    behaviors over inheritance, they’re not fully abstract. If one is, it’s better
    to use an interface instead.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Interfaces are more flexible and powerful, acting as contracts between parts
    of a system. They also allow a class to implement multiple interfaces, boosting
    flexibility. However, don’t discard abstract classes mindlessly. Actually, don’t
    discard anything mindlessly.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Exposing interfaces can save countless hours of struggling to find complex
    workaround when writing unit tests. That is even more true when building a framework
    or library that others use. In that case, please pay even more attention to providing
    your consumers with interfaces to mock if necessary.All that talk about interfaces
    again is great, but how can we invert the flow of dependencies? Spoiler alert:
    interfaces!Let’s compare a direct dependency and an inverted dependency first.'
  prefs: []
  type: TYPE_NORMAL
- en: Direct dependency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A direct dependency occurs when a particular piece of code (like a class or
    a module) relies directly on another. For example, if Class A uses a method from
    Class B, then Class A directly depends on Class B, which is a typical scenario
    in traditional programming.Say we have a `SomeService` class that uses the `SqlDataPersistence`
    class for production but the `LocalDataPersistence` class during development and
    testing. Without inverting the dependency flow, we end up with the following UML
    dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Direct dependency graph schema](img/file14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Direct dependency graph schema'
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding system, we could not change the `SqlDataPersistence` or `LocalDataPersistence`
    classes by the `CosmosDbDataPersistence` class (not in the diagram) without impacting
    the `SomeService` class.We call direct dependencies like these **tight coupling**.
  prefs: []
  type: TYPE_NORMAL
- en: Inverted dependency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An inverted dependency occurs when high-level modules (which provide complex
    logic) are independent of low-level modules (which provide basic, foundational
    operations). We can achieve this by introducing an abstraction (like an interface)
    between the modules. This means that instead of Class A depending directly on
    Class B, Class A would rely on an abstraction that Class B implements.Here is
    the updated schema that improves the direct dependency example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Indirect dependency graph schema](img/file15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Indirect dependency graph schema'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we successfully inverted the dependency flow by ensuring
    the `SomeService` class depends only on an `IDataPersistance` interface (abstraction)
    that the `SqlDataPersistence` and `LocalDataPersistence` classes implement. We
    could then use the `CosmosDbDataPersistence` class (not in the diagram) without
    impacting the `SomeService` class.We call inverted dependencies like these **loose
    coupling**.Now that we covered how to invert the dependency flow of classes, we
    look at inverting subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: Direct subsystems dependency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The preceding direct dependency example divided into packages, which have the
    same issue, would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: direct dependency graph divided into packages](img/file16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: direct dependency graph divided into packages'
  prefs: []
  type: TYPE_NORMAL
- en: The `Core` package depends on the `SQL` and `Local` packages leading to tight
    coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Packages usually represent assemblies or namespaces. However, dividing responsibilities
    around assemblies allows loading only the implementations that the program need.
    For example, one program could load the `Local` assembly, another could load the
    `SQL` assembly, and a third could load both.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enough said; let’s invert the dependency flow of those subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: Inverted subsystems dependency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We discussed modules and packages, yet the example diagram of inverted dependency
    illustrated classes. Using a similar approach, we can reduce dependencies between
    subsystems and create more flexible programs by arranging our code in separate
    assemblies. This way, we can achieve loose coupling and improved modularity in
    our software. To continue the inverted dependency example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an abstraction assembly containing only interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create other assemblies that contain the implementation of the contracts from
    that first assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create assemblies that consume the code through the abstraction assembly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are multiple examples of this in .NET, such as the `Microsoft.Extensions.DependencyInjection.Abstractions`
    and `Microsoft.Extensions.DependencyInjection` assemblies. We explore this concept
    further in *Chapter 12*, *Layering and Clean Architecture*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then, if we divide the inverted dependency examples into multiple packages,
    it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: inverted dependency examples divided into multiple packages](img/file17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: inverted dependency examples divided into multiple packages'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the diagram, the `Core` package directly depends on the `Abstractions` package,
    while two implementations are available: `Local` and `Sql`. Since we only rely
    on abstractions, we can swap one implementation for the other without impacting
    `Core`, and the program will run just fine unless something is wrong with the
    implementation itself (but that has nothing to do with the DIP).We could also
    create a new `CosmosDb` package and a `CosmosDbDataPersistence` class that implements
    the `IDataPersistence` interface, then use it in the `Core` without breaking anything.
    Why? Because we are only directly depending on abstractions, leading to a loosely
    coupled system.Next, we dig into some code.'
  prefs: []
  type: TYPE_NORMAL
- en: Project – Dependency inversion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, we translate the preceding iteration of the inverted dependency
    example in code. We create the following assemblies to align with the preceding
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App` is a console application that references all projects to showcase different
    use cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Core` is a class library that depends on the `Abstractions` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abstractions` is a class library that contains the `IDataPersistence` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sql` and `Local` are class libraries that reference the `Abstractions` project
    and implement the `IDataPersistence` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code sample has few implementation details because it is irrelevant to understanding
    the DIP. Please assume we implemented the `Persist` methods logic using your favorite
    in-memory and SQL databases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Visually, the relationships between the packages look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: the visual representation of the packages and their relationships](img/file18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: the visual representation of the packages and their relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code-wise, our abstraction contains a `Persist` method that we use to showcase
    the DIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `LocalDataPersistence` class depends on the `Abstractions` package
    and outputs a line to the console, allowing us to trace what happens in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `SqlDataPersistence` class is very similar to the `LocalDataPersistence`
    class; it depends on the `Abstractions` package and outputs a line in the console,
    allowing us to trace what happens in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we get to the program flow, we still have the `SomeService` class to
    look at, which depends on the `Abstractions` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted code shows that the `SomeService` class calls the `Persist`
    method of the provided `IDataPersistence` interface implementation. The `SomeService`
    class is not aware of where the data go. In the case of full implementation, the
    `someDataPersistence` instance is responsible for where the data would be persisted.
    Other than that, the `Operation` method writes lines to the console so we can
    trace what happens. Now from the `App` package, the `Program.cs` file contains
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `SqlDataPersistence` and a `LocalDataPersistence`
    instance. Doing that forced us to depend on both packages, but we could have chosen
    otherwise.Then we create an instance of the `SomeService` class. We then pass
    both `IDataPersistence` implementations to the `Operation` method one after the
    other.When we execute the program we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first half of the preceding terminal output represents the first call to
    the `Operation` method, where we passed the `LocalDataPersistence` instance. The
    second half represents the second call, where we passed the `SqlDataPersistence`
    instance.The highlighted lines show that depending on an interface allowed us
    to change this behavior (OCP). Moreover, we could create a `CosmosDb` package,
    reference it from the `App` package, then pass an instance of a `CosmosDbDataPersistence`
    class to the `Operation` method, and the `Core` package would not know about it.
    Why? Because we inverted the dependency flow, creating a loosely coupled system.
    We even did some *dependency injection*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency injection**, or **Inversion of Control** (**IoC**), is a design
    principle that is a first-class citizen of ASP.NET Core. It allows us to map abstractions
    to implementations, and when we need a new type, the whole object tree gets created
    automatically based on our configuration. We start that journey in *Chapter 7*,
    *Dependency Injection*.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The core idea is to depend on abstractions. Interfaces are pure contracts, which
    makes them more flexible than abstract classes. Abstract classes are still helpful,
    and we explore ways to leverage them in the book.Depending on implementations
    (classes) creates tight coupling between classes, which leads to a system that
    can be harder to maintain. The cohesion between your dependencies is essential
    in whether the coupling will help or hurt you in the long run. Don’t discard concrete
    types everywhere mindlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we covered many architectural principles. We began by exploring
    DRY, KISS, and separation of concerns principles before learning about the SOLID
    principles and their importance in modern software engineering. By following those
    principles, you should be able to build better, more maintainable software.As
    we also covered, principles are only principles, not laws. You must always be
    careful not to abuse them so they remain helpful instead of harmful. The context
    is always essential; internal tools and critical business applications require
    different levels of tinkering. The key takeaways from this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t over-engineer your solutions (KISS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulate and reuse business logic (DRY).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organize elements around concerns and responsibilities (SoC/SRP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aim at composability (OCP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support backward compatibility (LSP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write granular interfaces/contracts (ISP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depend on abstractions and invert the dependency flow (DIP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all those principles in our toolbox, we are ready to jump into design patterns
    and get our design level one step further, with the next chapter covering the
    MVC pattern in the context of ASP.NET Core REST APIs.Afterward, in the following
    few chapters, we explore how to implement some of the most frequently used Gang
    of Four (GoF) patterns and then how to apply them at another level using dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few practice questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How many principles are represented by the SOLID acronym?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that when following the SOLID principles, the idea is to create bigger
    components that can each manage more elements of a program by creating God-sized
    classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By following the DRY principle, you want to remove all code duplication from
    everywhere, irrespective of the source, and encapsulate that code into a reusable
    component. Is this affirmation correct?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is it true that the ISP tells us that creating multiple smaller interfaces is
    better than creating one large one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What principle tells us that creating multiple smaller classes that handle a
    single responsibility is better than one class handling multiple responsibilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Covariance and contravariance (C#): [https://adpg.link/BxBG](https://adpg.link/BxBG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
