<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adapting the Built-In Controls</h1>
                </header>
            
            <article>
                
<p>The .NET Framework comes with a plethora of built-in controls that cover most real-world scenarios. And when we need something slightly different, we have seen that we can utilize the WPF styling and/or templating systems to adapt them to our requirements. However, there are also further ways of adjusting the built-in controls to suit our needs.</p>
<p>Each .NET control has a number of methods, each named with the prefix <kbd>On</kbd>, for example, <kbd>OnInitialized</kbd>, or <kbd>OnApplyTemplate</kbd>. These are protected methods, that can be overridden in any custom class that extends a .NET control. They are called at certain points in the control's lifetime and enable us to change the default behavior of each control.</p>
<p>They enable us to do things as simple as starting a process as soon as a control has been initialized, or accessing a named control from a custom <kbd>ControlTemplate</kbd>, once it has been applied. But they can also be used to completely change the default behavior, or the look and feel of the control. In this chapter, we will investigate these methods and give examples of how they can be utilized to our advantage.</p>
<p>We will then examine further ways of customizing the built-in controls, by adjusting their default <kbd>ControlTemplate</kbd> and leveraging new uses from them, while maintaining or extending their existing functionality. In this chapter, we consider the built-in controls merely as a starting point for our requirements, and learn how to build upon them, keeping what we need and changing what we don't.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting protected methods</h1>
                </header>
            
            <article>
                
<p>Each .NET control has several methods that enable developers that extend that control to either interact with, or alter its functionality. Note that these are not events, but protected methods, that are called at specific points throughout the control's lifetime. As we have already seen in <em><a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, Using the Right Controls for the Job</em>, each .NET control extends a number of base classes, with each providing certain additional functionality.</p>
<p>In a similar way, each base class also provides a number of these protected methods, that enable us to interact with the control internally. In this chapter, we will also show how we can create our own methods that enable developers that extend our own control classes to adapt or extend their functionality.</p>
<p>Let's first take a look at the protected methods of the <kbd>Window</kbd> class:</p>
<pre>protected override Size ArrangeOverride(Size arrangeBounds); 
protected override Size MeasureOverride(Size availableSize); 
protected virtual void OnActivated(EventArgs e); 
protected virtual void OnClosed(EventArgs e); 
protected virtual void OnClosing(CancelEventArgs e); 
protected override void OnContentChanged(object oldContent, object newContent); 
protected virtual void OnContentRendered(EventArgs e); 
protected override AutomationPeer OnCreateAutomationPeer(); 
protected virtual void OnDeactivated(EventArgs e); 
protected virtual void OnLocationChanged(EventArgs e); <br/>protected override void 
    OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e); 
protected virtual void OnSourceInitialized(EventArgs e); 
protected virtual void OnStateChanged(EventArgs e); 
protected internal sealed override void  
    OnVisualParentChanged(DependencyObject oldParent); </pre>
<p>You may notice that they are all marked with either the virtual or override keywords, indicating that they can be overridden in extending classes. Apart from the <kbd>ArrangeOverride</kbd> and <kbd>MeasureOverride</kbd> methods, that we discovered in <em><a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, Using the Right Controls for the Job,</em> you should see that their names all start with the prefix <kbd>On</kbd>. This signifies that they are called upon some action having taken place.</p>
<p>For example, the <kbd>OnActivated</kbd> method is called when the <kbd>Window</kbd> becomes the active window on the computer, while the <kbd>OnDeactivated</kbd> method is called when the <kbd>Window</kbd> loses focus. These methods are usually used together to pause and resume animations, or other processes, while the <kbd>Window</kbd> is not in focus.</p>
<p>As expected, the <kbd>OnClosed</kbd> method is called upon the <kbd>Window</kbd> being closed and gives us a chance to dispose of any resources, or to save user preferences before closing the application. Conversely, The <kbd>OnClosing</kbd> method is called before the <kbd>Window</kbd> is closed and gives us a chance to cancel the close operation.</p>
<p>Therefore, the <kbd>OnClosing</kbd> method would be a good method from which to display a dialog, asking the user to confirm the close operation. Let's take a quick look at how we might achieve this in a class that extends the <kbd>Window</kbd> class:</p>
<pre>using System.ComponentModel; 
using System.Windows; 
 
... 
 
protected override void OnClosing(CancelEventArgs e) 
{ 
  base.OnClosing(e); 
  MessageBoxResult result = MessageBox.Show("Are you sure you want to close?", <br/>    "Close Confirmation", MessageBoxButton.OKCancel, MessageBoxImage.Question); 
  e.Cancel = result == MessageBoxResult.Cancel; 
} </pre>
<p>In this simple example, we override the <kbd>OnClosing</kbd> method and in it, we first call the base class method, to ensure that any base class routines are run as expected. We then display a message box to the user, asking them to confirm their close operation.</p>
<p>With the resulting value attained from the user via the message box buttons, we set the <kbd>Cancel</kbd> property of the <kbd>CancelEventArgs</kbd> object that is passed into the method. If the returned value is <kbd>Cancel</kbd>, the <kbd>Cancel</kbd> property is set to <kbd>true</kbd> and the close operation is canceled, otherwise, it is set to <kbd>false</kbd> and the application is closed.</p>
<p>Returning to the <kbd>Window</kbd> class now, we see the <kbd>OnLocationChanged</kbd> method, which is called whenever the <kbd>Window</kbd> is moved or resized in a manner that moves its top left corner. We could use this method to save the last position of the <kbd>Window</kbd>, so that it could be returned there the next time the user opened their application. However, this operation is more typically performed upon the user closing the application.</p>
<p>The <kbd>OnSourceInitialized</kbd> method is called after the window source is created, but before it is shown and the <kbd>OnStateChanged</kbd> method is called when the <kbd>WindowState</kbd> property is changed. So you see, these methods provide us with opportunities to perform actions at specific points throughout each control's lifetime.</p>
<p>Each base class adds its own collection of these protected methods for us to take advantage of, and ones of interest are overridden in the extending classes. Looking at the <kbd>Window</kbd> class declaration, we see that it extends the <kbd>ContentControl</kbd> class. Notice that its <kbd>OnContentChanged</kbd> method is marked with the <kbd>override</kbd> keyword.</p>
<p>This is because this method, which is actually declared in the <kbd>ContentControl</kbd> class, has been overridden in the <kbd>Window</kbd> class so that it could add its own code after the base class functionality has been executed. Let's have a look at the source code for this method from the <kbd>Window</kbd> class. The comments in the source code have been removed for brevity:</p>
<pre>protected override void OnContentChanged(object oldContent, object newContent) 
{ 
    base.OnContentChanged(oldContent, newContent); 
 
    SetIWindowService(); 
    if (IsLoaded == true) 
    { 
        PostContentRendered(); 
    } 
    else 
    { 
        if (_postContentRenderedFromLoadedHandler == false) 
        { 
            this.Loaded += new RoutedEventHandler(LoadedHandler); 
            _postContentRenderedFromLoadedHandler = true; 
        } 
    } 
} </pre>
<p>The method starts by calling the base class version of the method, which is always a good practice unless we want to stop the existing functionality from being performed. Next, it calls the <kbd>SetIWindowService</kbd> method, which just sets the <kbd>Window</kbd> object to the <kbd>IWindowServiceProperty</kbd> Dependency Property, and then it checks if the <kbd>Window</kbd> has passed the loading stage or not.</p>
<p>If it has, then it calls the <kbd>PostContentRendered</kbd> method, which basically invokes the <kbd>OnContentRendered</kbd> method using the <kbd>Dispatcher</kbd> object. Otherwise, if the <kbd>_postContentRenderedFromLoadedHandler</kbd> variable is <kbd>false</kbd>, it attaches an event handler to the <kbd>Loaded</kbd> event and sets the variable to <kbd>true</kbd>, to ensure that it is not attached more than once.</p>
<p>Returning to our investigation now, we see that the <kbd>Window</kbd> class adds protected methods relating to the <kbd>Window</kbd> and the <kbd>ContentControl</kbd> class adds protected methods relating to the content of the control. Let's see the protected methods of the <kbd>ContentControl</kbd> class now:</p>
<pre>protected virtual void AddChild(object value); 
protected virtual void AddText(string text); 
protected virtual void OnContentChanged(object oldContent, object newContent); 
protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat); 
protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate); 
protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector); </pre>
<p>Apart from the first two methods, which can be used to add a specified object or text string to the <kbd>ContentControl</kbd> element, the remaining four methods are all called in response to a change in the content, or the format of the content of the control.</p>
<p>Moving on now, the <kbd>ContentControl</kbd> class extends the <kbd>Control</kbd> class, which introduces the concept of the <kbd>ControlTemplate</kbd>. As such, it provides a protected <kbd>OnTemplateChanged</kbd> method, which is called when the <kbd>ControlTemplate</kbd> value is changed:</p>
<pre>protected override Size ArrangeOverride(Size arrangeBounds); 
protected override Size MeasureOverride(Size constraint); 
protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e); 
protected virtual void OnPreviewMouseDoubleClick(MouseButtonEventArgs e); 
protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate); </pre>
<p>The <kbd>Control</kbd> class extends the <kbd>FrameworkElement</kbd> class, which provides framework-level methods and events. These include a mouse, keyboard, stylus, touch, and focus-related protected methods, along with several others:</p>
<pre>protected virtual Size ArrangeOverride(Size finalSize); 
protected override Geometry GetLayoutClip(Size layoutSlotSize); 
protected override Visual GetVisualChild(int index); 
protected virtual Size MeasureOverride(Size availableSize); 
protected virtual void OnContextMenuClosing(ContextMenuEventArgs e); 
protected virtual void OnContextMenuOpening(ContextMenuEventArgs e); 
protected override void OnGotFocus(RoutedEventArgs e); 
protected virtual void OnInitialized(EventArgs e); 
protected override void OnPropertyChanged(DependencyPropertyChangedEventArgs e); 
protected virtual void OnToolTipClosing(ToolTipEventArgs e); 
protected virtual void OnToolTipOpening(ToolTipEventArgs e); </pre>
<p>Perhaps by now you will have noticed that many of these method names relate closely to the names of events raised by each class. In fact, there is a .NET Framework programming guideline for having protected virtual methods that raise events, to allow derived classes to override the event invocation behavior and we'll see an example of this later in this chapter.</p>
<p>When overriding these methods, we are therefore required to call the base class method in order to raise the corresponding event. When in doubt, it's usually best to call the base class version of the method to ensure that default functionality is not lost. However, it's good practice to view the base class method source code on the <a href="http://www.referencesource.microsoft.com">www.referencesource.microsoft.com</a> website, to check if we need to call it or not.</p>
<p>You may be wondering what the difference between handling the events and overriding the related protected methods is and there are a few answers to this, depending upon the method in question. The first thing to point out is that in order to override a protected method, we need to declare a subclass of the class that declares the method.</p>
<p><em>So, assuming that we already have a class that extends a base class, what are the differences?</em> For some methods, such as the <kbd>OnClosing</kbd> method that we explored, there is little difference. We could implement the same functionality in an event handler that is attached to the <kbd>Closing</kbd> event, although without the call to the base class method. In fact, this is the only real difference.</p>
<p>When overriding the <kbd>OnClosing</kbd> method, we are in control of when or if the base class method is called. When handling the event, we have no control over this. So, if we need to perform some action before the base class routine is executed or if we want to stop it from executing, then we will need to override the <kbd>OnClosing</kbd> method.</p>
<p>So, the appearance of the <kbd>OnClosing</kbd> method is there, purely for convenience, for us to be able to alter the default behavior of the <kbd>Closing</kbd> event. Other methods, however, such as the <kbd>OnContextMenuClosing</kbd> method, introduce a way for us to perform class-wide handling for the related events.</p>
<p>Sometimes though, we have no alternative to overriding these protected methods. Typically, these types of methods do not start with the prefix <kbd>On</kbd> and do not relate to any event. Occasionally, to perform a particular operation, we may need to extend a class, just so that we can provide a new implementation for one of these methods.</p>
<p>Let's look at an example using the <kbd>GetLayoutClip</kbd> method from the <kbd>FrameworkElement</kbd> class that we just saw.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clipping the layout</h1>
                </header>
            
            <article>
                
<p>By default, the <kbd>TextBlock</kbd> class clips its textual content at its bounding rectangle, so that text does not leak out of it. Clipping is the process of cutting off a portion of the visible output of a control. <em>But what about if we want the text to extend its bounds?</em></p>
<p>There is a property named <kbd>Clip</kbd>, that we typically use to adjust the visible portion of controls. However, this can only reduce what is already visible. It cannot increase the rendering space available to the control. Before we continue with our example, let's take a short detour to investigate this property.</p>
<p>The <kbd>Clip</kbd> property, which is defined in the <kbd>UIElement</kbd> class, takes a <kbd>Geometry</kbd> object as its value. The object that we pass it can be created from any of the classes that extend the <kbd>Geometry</kbd> class, including the <kbd>CombinedGeometry</kbd> class. Therefore, the clipped object can be made into any shape. Let's view a simple example:</p>
<pre>&lt;Rectangle Fill="Salmon" Width="150" Height="100" RadiusX="25" RadiusY="50"&gt; 
  &lt;Rectangle.Clip&gt; 
    &lt;EllipseGeometry Center="150,50" RadiusX="150" RadiusY="50" /&gt; 
  &lt;/Rectangle.Clip&gt; 
&lt;/Rectangle&gt; </pre>
<p>Here, we use an <kbd>EllipseGeometry</kbd> object to make a <kbd>Rectangle</kbd> element appear as a small bullet shape. It works by displaying all of the image pixels from the <kbd>Rectangle</kbd> element that lies within the oval boundary of the <kbd>EllipseGeometry</kbd> object and hiding all those that lie outside the boundary. Let's take a look at the visual output of this code:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/9b3b1ba2-8602-4dae-9312-033e7c73e078.png"/></span></p>
<p>Returning to our previous example, the <kbd>TextBlock</kbd> class also clips its content in a similar way, but with a rectangle the size of the control, instead of an off-centered oval. Rather than using the <kbd>Clip</kbd> property, which provides the user with the same ability to clip the control as the other controls offer, it uses a protected method to ask for the <kbd>Geometry</kbd> object to use in the clipping process.</p>
<p>We could indeed return any geometric shape from this method, but it would not have the same visual effect as passing the shape to the <kbd>Clip</kbd> property would. For our example, we don't want to restrict the visible size of the control, but instead, remove the clipped area at the bounds of the control.</p>
<p><span>If we knew exactly what size we wanted to set the clipped range at, we could return a <kbd>Geometry</kbd> object of that size from the <kbd>GetLayoutClip</kbd> method. However, for our purposes, and to enable any of our custom</span> <kbd>TextBlock</kbd> objects to leak endless text out of their bounds, we can simply return <kbd>null</kbd> from this method. Let's look at the difference between the two.</p>
<p>First, we create our <kbd>BoundlessTextBlock</kbd> class by extending the <kbd>TextBlock</kbd> class. Probably, one of the easiest ways to do this in <strong>Visual Studio</strong> is to add a WPF User Control object into our <span class="packt_screen">Controls</span> folder and then simply replace the word <kbd>UserControl</kbd> with the word <kbd>TextBlock</kbd> in both the XAML file and its associated code behind file. Failure to change both will result in a design-time error that complains that <strong>Partial declarations of</strong> <span class="packt_screen">'</span><strong><kbd>BoundlessTextBlock</kbd></strong>' <strong>must not specify different base classes</strong>:</p>
<pre>&lt;TextBlock x:Class="CompanyName.ApplicationName.Views.Controls.BoundlessTextBlock" 
   
   /&gt; </pre>
<p><span>As can be seen from this example, our XAML file can be left remarkably empty, and for our requirements, we only need to override the single <kbd>GetLayoutClip</kbd> method in the code behind file. In this first example, we will return an <kbd>EllipseGeometry</kbd> object with the same size as the text block that will be used in the user interface:</span></p>
<pre>using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Media; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class BoundlessTextBlock : TextBlock 
  { 
    public BoundlessTextBlock() 
    { 
      InitializeComponent(); 
    } 
 
    protected override Geometry GetLayoutClip(Size layoutSlotSize) 
    { 
      return new EllipseGeometry(new Rect(new Size(150, 22))); 
    } 
  } 
} </pre>
<p><span>Let's see how we can use our new class. First, we need to define a XAML Namespace that maps to the CLR namespace where we saved the class. Next, for demonstration purposes, we wrap our <kbd>BoundlessTextBlock</kbd> object in a <kbd>Border</kbd> object, so that we can see its natural bounds:</span></p>
<pre> <br/>... 
<br/>&lt;Border BorderBrush="Black" BorderThickness="1" HorizontalAlignment="Center" <br/>  VerticalAlignment="Center" SnapsToDevicePixels="True"&gt; 
<span>  &lt;Controls:BoundlessTextBlock Text="Can you see what has happened?" <br/>    Background="Aqua" FontSize="14" Width="150" Height="22" /&gt;</span> 
&lt;/Border&gt; </pre>
<p>Let's take a look at the visual output from this example:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/64858898-4506-4b38-9503-07f8038db0cb.png"/></span></p>
<p><span>As you can see, the visual output from our <kbd>BoundlessTextBlock</kbd> object has been restricted to display only the pixels that lie within the <kbd>EllipseGeometry</kbd> object that was returned from the <kbd>GetLayoutClip</kbd> method. <em>But what will happen if we return an</em> <kbd>EllipseGeometry</kbd> <em>object that is larger than our custom text block?</em> Let's find out, by returning this object instead:</span></p>
<pre>return new EllipseGeometry(new Rect(new Size(205, 22)));</pre>
<p><span>Now, looking at the visual output of our <kbd>BoundlessTextBlock</kbd> object, we can see that the content of our custom text block now extends beyond its bounds, thanks to the <kbd>Border</kbd> object and the blue background:</span></p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/9368f750-445e-4664-990f-a16f067a8d3e.png"/></span></p>
<p><span>So, we can see that the clipping that is applied using the <kbd>Geometry</kbd> object that is returned from the <kbd>GetLayoutClip</kbd> method is not only unaffected by the control's natural bounds, but in fact, can directly alter them. Returning to our original idea on this subject, if we want to totally remove the clipping at the control's bounding edges, we can simply return <kbd>null</kbd> from this method instead:</span></p>
<pre>protected override Geometry GetLayoutClip(Size layoutSlotSize) 
{ 
  return null; 
} </pre>
<p>Let's see the result of this change now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/bb9a6ae0-1df0-4509-9f03-e1ce24889ec7.png"/></span></p>
<p>As you can see, the text now reaches right out of the boundary of the containing <kbd>TextBlock</kbd> object, and continues until the end of the text value. Note that it would extend as long as the text string requires, if given enough space by its parent control(s).</p>
<p><span>Let's look at another example of extending these classes to alter their functionality now.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Altering default behavior</h1>
                </header>
            
            <article>
                
<p><span>The developers of the <kbd>ItemsControl</kbd> class gave it a particular default behavior. They thought that any objects that extended the</span> <kbd>UIElement</kbd> <span>class would have their own UI container and so, should be displayed directly, rather than allowing them to be templated in the usual way.</span></p>
<p><span>There is a method named <kbd>IsItemItsOwnContainer</kbd> in the <kbd>ItemsControl</kbd> class, which is called by the <strong>WPF</strong> Framework, to determine if an item in the <kbd>Items</kbd> collection is its own item container or not. Let's first take a look at the source code of this method:</span></p>
<pre><span>public bool IsItemItsOwnContainer(object item)</span> 
{ 
  return IsItemItsOwnContainerOverride(item); 
} </pre>
<p><span>Note that internally, this method just calls the <kbd>IsItemItsOwnContainerOverride</kbd> method, returning its value unchanged. Let's take a look at the source code of that method now:</span></p>
<pre><span>protected virtual bool IsItemItsOwnContainerOverride(object item)</span> 
{ 
<span>  return (item is UIElement);</span> 
} </pre>
<p>Here, we see two things: The first is the default implementation that was just mentioned, where <kbd>true</kbd> <span>is returned for all items that extend the <kbd>UIElement</kbd> class, and</span> <kbd>false</kbd> for all other types. The second is that this method is marked as <kbd>virtual</kbd>, so we are able to extend this class and override the method to return a different value.</p>
<p><span>Let's now look at the crucial part of the <kbd>ItemsControl</kbd> class source code (without the comments), where our overridden method would be used. This excerpt is from the <kbd>GetContainerForItem</kbd> method:</span></p>
<pre><span>DependencyObject container;</span> 
 
if (<span>IsItemItsOwnContainerOverride</span>(item)) 
<span>  container = item as DependencyObject;</span> 
else 
<span>  container = GetContainerForItemOverride();</span> </pre>
<p><span>With the default implementation, we see that <kbd>UIElement</kbd> items are cast to the type of <kbd>DependencyObject</kbd>, and set as the container, while a new container is created for items of all other types. Before overriding this method, let's see what effect the default behavior has, using an example.</span></p>
<p>The aim of this example is to render a little hollow circle for each item in a collection. Think of a slide show, where these circles would represent the slides, or a page numbering or linking system. We, therefore, need a collection control containing some items and a <kbd>DataTemplate</kbd>, with which to define the circles. Let's see the collection control with the items on their own first:</p>
<pre>&lt;UserControl <br/>  x:Class="CompanyName.ApplicationName.Views.ForcedContainerItemsControlView" 
   
   
  Height="175" Width="287"&gt; 
  &lt;Grid&gt; 
    &lt;Grid.Resources&gt; 
      &lt;ItemsPanelTemplate x:Key="HorizontalPanelTemplate"&gt; 
        &lt;StackPanel Orientation="Horizontal" /&gt; 
      &lt;/ItemsPanelTemplate&gt; 
      &lt;Style TargetType="{x:Type Rectangle}"&gt; 
        &lt;Setter Property="Width" Value="75" /&gt; 
        &lt;Setter Property="Height" Value="75" /&gt; 
        &lt;Setter Property="RadiusX" Value="15" /&gt; 
        &lt;Setter Property="RadiusY" Value="15" /&gt; 
      &lt;/Style&gt; 
    &lt;/Grid.Resources&gt; 
    &lt;Grid.RowDefinitions&gt; 
      &lt;RowDefinition Height="Auto" /&gt; 
      &lt;RowDefinition /&gt; 
    &lt;/Grid.RowDefinitions&gt; 
    &lt;ListBox Name="ListBox" Height="105" Margin="20,20,20,0"<br/>      ItemsPanel="{StaticResource HorizontalPanelTemplate}"&gt; 
      &lt;Rectangle Fill="Red" /&gt; 
      &lt;Rectangle Fill="Orange" /&gt; 
      &lt;Rectangle Fill="Green" /&gt; 
    &lt;/ListBox&gt; 
  &lt;/Grid&gt; 
&lt;/UserControl&gt; </pre>
<p>We start with the resources, where we have declared an <kbd>ItemsPanelTemplate</kbd>, that is set to an instance of a <kbd>StackPanel</kbd>, with its <kbd>Orientation</kbd> property set to <kbd>Horizontal</kbd>. This will make the panel's items appear horizontally. We then added a basic <kbd>Style</kbd>, in which we set our common properties for the <kbd>Rectangle</kbd> class.</p>
<p>In the markup, we have a <kbd>Grid</kbd> panel with two rows. In the first row, we have a <kbd>ListBox</kbd> named <kbd>ListBox</kbd>, with three colored <kbd>Rectangle</kbd> objects declared within its <kbd>Items</kbd> collection. Its <kbd>ItemsPanel</kbd> property is set to the <kbd>ItemsPanelTemplate</kbd> instance that we declared in the control's <kbd>Resources</kbd> section. The second row is currently empty, but let's see the visual output so far:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f4a3615c-e68a-4350-a624-4b2a3db432b7.png"/></p>
<p>So far, so good. We can see our three rounded rectangles in the <kbd>ListBox</kbd> control. Now, let's add a <kbd>DataTemplate</kbd> into the <kbd>Resources</kbd> section and an <kbd>ItemsControl</kbd> element into the second row of the <kbd>Grid</kbd> panel, declaring it directly underneath the <kbd>ListBox</kbd> XAML:</p>
<pre>&lt;DataTemplate x:Key="EllipseDataTemplate" DataType="{x:Type UIElement}"&gt; 
  &lt;Ellipse Width="16" Height="16" <br/>    Stroke="Gray" StrokeThickness="2" Margin="4" /&gt; 
&lt;/DataTemplate&gt; 
 
... 
 
&lt;ItemsControl Grid.Row="1" ItemsSource="{Binding Items, ElementName=ListBox}" <br/>  ItemsPanel="{StaticResource HorizontalPanelTemplate}" <br/>  ItemTemplate="{StaticResource EllipseDataTemplate}" <br/>  HorizontalAlignment="Center" /&gt; </pre>
<p>Note that this <kbd>ItemsControl</kbd> element has its <kbd>ItemsSource</kbd> property data bound to the <kbd>Items</kbd> property from the <kbd>ListBox</kbd>, using an <kbd>ElementName</kbd> binding. Like the <kbd>ListBox</kbd> control, it also arranges its items horizontally, using the <kbd>ItemsPanelTemplate</kbd> resource. It also applies the new <kbd>DataTemplate</kbd> element that we just added into the <kbd>Resources</kbd> section.</p>
<p>In this <kbd>DataTemplate</kbd>, we define a hollow gray <kbd>Ellipse</kbd> element to be rendered for each item in the collection, specifying its dimensions, spacing and stroke settings. Let's take a look at the visual output of our example now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/8094656d-d5f4-442e-81d2-d4f0811ec150.png"/></span></p>
<p>As you can see, we have some unexpected results. Instead of rendering the small gray ellipses that we defined in the <kbd>DataTemplate</kbd>, the items in the <kbd>ItemsControl</kbd> display the actual items from the <kbd>ListBox</kbd>. Even worse than that, as each UI element can only be displayed in one location at any given point in time, the original items no longer even appear in the <kbd>ListBox</kbd>.</p>
<p>You may see an <kbd>ArgumentException</kbd> being thrown regarding this issue:</p>
<pre><strong>Must disconnect the specified child from current parent Visual before attaching to new parent Visual.</strong></pre>
<p><span><em>But why haven't these objects been rendered as hollow circles in the second</em> <kbd>ListBox</kbd><em>, according to our</em> <kbd>DataTemplate</kbd><em>?</em> <em>Do you remember the</em> <kbd>IsItemItsOwnContainerOverride</kbd> <em>method that we investigated?</em> Well, that is the reason.</span></p>
<p><span>The objects that are data-bound to the <kbd>ItemsControl</kbd>'s <kbd>ItemsSource</kbd> property</span> <span>extend the</span> <kbd>UIElement</kbd> <span>class, and so the</span> <kbd>ItemsControl</kbd> <span>class uses them as their own containers, rather than creating a new container and applying the item template to them.</span></p>
<p><span><em>So, how do we change this default behavior?</em> That's right, we need to extend the <kbd>ItemsControl</kbd> class and override the <kbd>IsItemItsOwnContainerOverride</kbd> method to always return <kbd>false</kbd>. In this way, a new container will always be created and the item template will always be applied. Let's see how this would look in a new class:</span></p>
<pre>using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public class ForcedContainerItemsControl : ItemsControl 
  { 
 protected override bool IsItemItsOwnContainerOverride(object item) 
    { 
      return false; 
    } 
  } 
} </pre>
<p><span>Here we have the very simple <kbd>ForcedContainerItemsControl</kbd> class, with its single overridden method, that always returns <kbd>false</kbd>. We need to do nothing else in this class, as we are happy to use the default behavior of the <kbd>ItemsControl</kbd> class for everything else.</span></p>
<p><span>All that remains is for us to use our new class in our example. We start by adding a XAML Namespace for our <kbd>Controls</kbd> CLR Namespace:</span></p>
<pre> </pre>
<p>Next, we replace the <kbd>ItemsControl</kbd> XAML with the following:</p>
<pre>&lt;Controls:ForcedContainerItemsControl Grid.Row="1" <br/>  ItemsSource="{Binding Items, ElementName=ListBox}" <br/>  ItemsPanel="{StaticResource HorizontalPanelTemplate}" <br/>  ItemTemplate="{StaticResource EllipseDataTemplate}" <br/>  HorizontalAlignment="Center" Height="32" /&gt; </pre>
<p>Let's see the new visual output now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/576ab18e-5550-4f71-aa5e-9cb53c8bcadc.png"/></span></p>
<p>Now, we see what we were originally expecting to see: a little hollow circle rendered for each item in the collection. The items in our custom <kbd>ItemsControl</kbd> have now all been generated a new container and had our template applied to them as expected.</p>
<p><em>But what if we need to make use of the selected item in this example?</em> The <kbd>ItemsControl</kbd> class has no concept of a selected item, so in this case, we would need to use a <kbd>ListBox</kbd> control in the second row of the <kbd>Grid</kbd> panel.</p>
<p><span>However, note that the <kbd>ListBox</kbd> class has also overridden the <kbd>IsItemItsOwnContainerOverride</kbd> method, so that it does not suffer from this same problem.</span></p>
<p><span>In fact, it will only use an item as a container if it is actually the correct container for this class; a <kbd>ListBoxItem</kbd>. Let's see its overridden method:</span></p>
<pre>protected override bool IsItemItsOwnContainerOverride(object item)  
{  
  return (item is ListBoxItem); 
} </pre>
<p>Therefore, if we need access to the <kbd>SelectedItem</kbd> property from the <kbd>ListBox</kbd> class, then we do not need to create our own extended class to override this method, and can instead use their standard implementation. To get the same visual output however, we would need some styles to hide the <kbd>ListBox</kbd>'s border and selected item highlights. Let's see a basic example of this:</p>
<pre>&lt;Style x:Key="HiddenListBoxItems" TargetType="{x:Type ListBoxItem}"&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type ListBoxItem}"&gt; 
        &lt;ContentPresenter /&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; 
&lt;Style x:Key="HiddenListBox" TargetType="{x:Type ListBox}"&gt; 
  &lt;Setter Property="Template"&gt; 
    &lt;Setter.Value&gt; 
      &lt;ControlTemplate TargetType="{x:Type ListBox}"&gt; 
        &lt;ScrollViewer&gt; 
          &lt;ItemsPresenter SnapsToDevicePixels="{TemplateBinding <br/>            SnapsToDevicePixels}" /&gt; 
        &lt;/ScrollViewer&gt; 
      &lt;/ControlTemplate&gt; 
    &lt;/Setter.Value&gt; 
  &lt;/Setter&gt; 
&lt;/Style&gt; </pre>
<p>We would also need to update our <kbd>EllipseDataTemplate</kbd> template to include a trigger to highlight the small <kbd>Ellipse</kbd> object when its related item is selected in the top <kbd>ListBox</kbd> control:</p>
<pre>&lt;DataTemplate x:Key="EllipseDataTemplate" DataType="{x:Type UIElement}"&gt; 
  &lt;Ellipse Width="16" Height="16" Stroke="Gray" StrokeThickness="2" <br/>    Margin="8"&gt; 
    &lt;Ellipse.Style&gt; 
      &lt;Style TargetType="{x:Type Ellipse}"&gt; 
        &lt;Setter Property="Fill" Value="Transparent" /&gt; 
        &lt;Style.Triggers&gt; 
          &lt;DataTrigger Binding="{Binding IsSelected, <br/>            RelativeSource={RelativeSource <br/>            AncestorType={x:Type ListBoxItem}}}" Value="True"&gt; 
            &lt;Setter Property="Fill" Value="LightGray" /&gt; 
          &lt;/DataTrigger&gt; 
        &lt;/Style.Triggers&gt; 
      &lt;/Style&gt; 
    &lt;/Ellipse.Style&gt; 
  &lt;/Ellipse&gt; 
&lt;/DataTemplate&gt; </pre>
<p><span>And finally, we'll need to replace our <kbd>ForcedContainerItemsControl</kbd> element with a standard <kbd>ListBox</kbd> and apply our styles to it and its containers:</span></p>
<pre>&lt;ListBox Grid.Row="1" ItemsSource="{Binding Items, ElementName=ListBox}" <br/>  ItemsPanel="{StaticResource HorizontalPanelTemplate}" <br/>  ItemTemplate="{StaticResource EllipseDataTemplate}" <br/>  SelectedItem="{Binding SelectedItem, ElementName=ListBox}" <br/>  Style="{StaticResource HiddenListBox}" <br/>  ItemContainerStyle="{StaticResource HiddenListBoxItems}" <br/>  HorizontalAlignment="Center" /&gt; </pre>
<p>When we run the application now, we see that the small hollow <kbd>Ellipse</kbd> objects become filled when their related item is selected in the top <kbd>ListBox</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/4c9e7f03-1edb-4ed1-9a87-b3fd865b0c61.png"/></span></p>
<p class="CDPAlignLeft CDPAlign"><span>So, we've seen how we can override these protected methods to change the default behavior of the built-in controls. Let's now take a look at how we can build these protected methods into our own custom classes, so that they can affect the natural flow of a piece of our control's functionality.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating overridable methods</h1>
                </header>
            
            <article>
                
<p>The first thing that we need to do is to define either an abstract or a virtual method in our base class. Note that the class would need to be abstract in order to declare an abstract method. Which one we chose will depend on if we want to leave the implementation up to the developers that use our code, or if we have some implementation that we need to put in the method ourselves.</p>
<p>Let's look at an example to clarify this. Here, we see a method from an abstract <kbd>BaseDragDropManager</kbd> class. It handles the <kbd>PreviewMouseMove</kbd> event on controls that are used as drag and drop sources, for example, on a <kbd>ListBox</kbd> from which an item is being dragged:</p>
<pre>private void DragSourcePreviewMouseMove(object sender, MouseEventArgs e) 
{ 
  if (_isMouseDown &amp;&amp; IsConfirmedDrag(e.GetPosition(sender as ListBox))) 
  { 
    _isMouseDown = false; 
    OnDragSourcePreviewMouseMove(sender, e); 
    if (e.Handled) return; 
    OnDragStart(sender as UIElement); 
  } 
} <br/><br/>protected virtual void <br/>  OnDragSourcePreviewMouseMove(object sender, MouseEventArgs e) { } 
<br/>protected abstract void OnDragStart(UIElement uiElement); </pre>
<p>In this example, the <kbd>DragSourcePreviewMouseMove</kbd> method first performs a check to verify that a drag operation has been initiated by the user. It then calls the <kbd>OnDragSourcePreviewMouseMove</kbd> method, which is marked as <kbd>virtual</kbd>, which makes overriding it in derived classes optional.</p>
<p>The next line of the <kbd>DragSourcePreviewMouseMove</kbd> method checks the <kbd>Handled</kbd> property of the <kbd>MouseEventArgs</kbd> input parameter and if it has been set to <kbd>true</kbd> in the derived class, it returns execution to the caller, instead of continuing with the drag and drop operation. If the event has not been handled, then the <kbd>OnDragStart</kbd> method is called.</p>
<p>This is the crucial bit that links the possible input from the derived classes. The only reason to override the <kbd>OnDragSourcePreviewMouseMove</kbd> method in an extending class is to set the <kbd>Handled</kbd> property of the <kbd>MouseEventArgs</kbd> input parameter to <kbd>true</kbd> and stop the drag and drop operation from starting, perhaps according to some information that the extending class has.</p>
<p>Conversely, the <kbd>OnDragStart</kbd> method is marked as <kbd>abstract</kbd>, requiring it to be overridden in all derived classes. This is the method that prepares the data for the drag and drop process, and is required to call the <kbd>StartDrag</kbd> method of the base class to start the operation, passing the prepared data.</p>
<p>In this particular example, our virtual method is left empty in the base class and there is no need to call it from the overridden method. More typically, the base class would contain a default implementation, which could be overridden in derived classes, but may require a call to the base class, in order to retain its functionality.</p>
<p>For example, a .NET Framework programming guideline exists for raising base class events from derived classes. Ordinarily, derived classes cannot raise base class events and any attempts to do so will be met with a compilation error:</p>
<pre><strong>The event ClassName.EventName can only appear on the left hand side of += or -= (except when used from within the type ClassName)</strong></pre>
<p>The solution to this problem from the guidelines is to wrap the invocation of these events in a protected method in the base class, so it can be called or overridden in derived classes. Let's add a custom <kbd>EventArgs</kbd> class and an event into our <kbd>AddressControl</kbd> control that demonstrates this guideline:</p>
<pre>public class AddressEventArgs : EventArgs 
{ 
  public AddressEventArgs(Address oldAddress, Address newAddress) 
  { 
    OldAddress = oldAddress; 
    NewAddress = newAddress; 
  } 
 
  public Address OldAddress { get; } 
 
  public Address NewAddress { get; } 
} 
 
... 
 
public event EventHandler&lt;AddressEventArgs&gt; AddressChanged;  
 
... 
 
public virtual Address Address 
{ 
  get { return (Address)GetValue(AddressProperty); } 
  set 
  { 
    if (!Address.Equals(value)) 
    { 
      Address oldAddress = Address; 
      SetValue(AddressProperty, value); 
      OnAddressChanged(new AddressEventArgs(oldAddress, value)); 
    } 
  } 
} 
 
... 
 
protected virtual void OnAddressChanged(AddressEventArgs e) 
{ 
  AddressChanged?.Invoke(this, e); 
} </pre>
<p>First, we create a custom <kbd>EventArgs</kbd> class for our event. Then, we declare an event named <kbd>AddressChanged</kbd> and a protected virtual method that raises it, using the null conditional operator. This can be called directly from derived classes to raise the event, but also overridden, to add to or to stop the base class implementation from executing.</p>
<p>Finally, we update our <kbd>Address</kbd> property to call the invocation method, passing in the required previous and current <kbd>Address</kbd> objects. Note that we now also mark this property as <kbd>virtual</kbd>, so that derived classes can override it as well, to fully control how, when and if the event should be raised.</p>
<p>This is a far more preferable solution to declaring a virtual event and overriding it in a derived class, as the compiler does not always handle this situation as expected, due to some complicated event overriding rules, and we cannot always be certain which version of the event a subscriber will actually by subscribing to.</p>
<p>Now that we have a better understanding of these protected methods, let's take a look at what other kinds of things we can do by overriding them in derived classes. We will use an extended example that raises a number of problems, that we can fix by overriding a number of these protected base class methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tailoring to attain our requirements</h1>
                </header>
            
            <article>
                
<p>Let's imagine that we want to create an application that displays tabular data. This doesn't initially sound very complicated, but it is actually a very good example with which to demonstrate how to adapt the built-in .NET controls to fulfill our requirements. As we progress through this example, we will come across several potential problems and find out how to overcome each one in turn.</p>
<p>For this extended example, we will create a <kbd>Spreadsheet</kbd> control. As always, when creating new controls, we look at the existing controls, to see if any of them can provide us with a good starting point. The first control that springs to mind is the <kbd>Grid</kbd> panel, as it has rows, columns and therefore also cells, but the creation of all of the <kbd>RowDefinition</kbd> and <kbd>ColumnDefinition</kbd> objects could be cumbersome or problematic.</p>
<p>There is also the <kbd>UniformGrid</kbd> panel, but as its name suggests, all of its cells are uniform, or the same size as each other, but this is not always the case in spreadsheets. We could potentially use an <kbd>ItemsControl</kbd> object and a custom <kbd>DataTemplate</kbd> to draw the borders and contents of each cell manually, <em>but could there be a better starting point?</em></p>
<p><em>How about the</em> <kbd>DataGrid</kbd> <em>control?</em> It has rows, columns, and cells, and even draws the grid lines between the cells for us. It also has the concept of a selected cell, which could be useful if we wanted users to interact with our spreadsheet control. It has no numbers, letters, or selected cell markers in the grid axes, but we can extend the control to add these, so it seems like the best candidate for the job.</p>
<p>The first thing that we need to do is to create a new class that extends the <kbd>DataGrid</kbd> class. As we saw earlier in this chapter, we can do this by adding a <kbd>UserControl</kbd> to our project and replacing the word <kbd>UserControl</kbd> with the word <kbd>DataGrid</kbd> in both the XAML file and its code behind file. Failure to change both will result in a design-time error that complains about mismatched classes.</p>
<p>Let's take a look at our new <kbd>Spreadsheet</kbd> class:</p>
<pre>using System.Windows.Controls; 
 
namespace CompanyName.ApplicationName.Views.Controls 
{ 
  public partial class Spreadsheet : DataGrid 
  { 
    public Spreadsheet() 
    { 
      InitializeComponent(); 
    } 
  } 
} </pre>
<p>The code behind is a simple affair, currently with no custom code in it. The XAML however, has a number of important properties set in it, so let's see that now:</p>
<pre>&lt;DataGrid x:Class="CompanyName.ApplicationName.Views.Controls.Spreadsheet" 
   
   
  AutoGenerateColumns="False" SelectionUnit="Cell" SelectionMode="Single" <br/>  IsReadOnly="True" RowHeight="20" RowHeaderWidth="26" ColumnHeaderHeight="26"<br/>  CanUserAddRows="False" CanUserDeleteRows="False" CanUserReorderColumns="False"<br/>  CanUserResizeColumns="False" CanUserResizeRows="False" <br/>  HorizontalGridLinesBrush="{DynamicResource GridlinesBrush}" <br/>  VerticalGridLinesBrush="{DynamicResource GridlinesBrush}" <br/>  BorderBrush="{DynamicResource BorderBrush}"&gt; 
  &lt;DataGrid.Resources&gt; 
    &lt;Color x:Key="BackgroundColor"&gt;#FFE6E6E6&lt;/Color&gt; 
    &lt;Color x:Key="BorderColor"&gt;#FF999999&lt;/Color&gt; 
    &lt;SolidColorBrush x:Key="BackgroundBrush" Color="{StaticResource BackgroundColor}" /&gt; 
    &lt;SolidColorBrush x:Key="BorderBrush" Color="{StaticResource BorderColor}" /&gt; 
    &lt;SolidColorBrush x:Key="SelectedBackgroundBrush" Color="#FFD2D2D2" /&gt; 
    &lt;SolidColorBrush x:Key="GridlinesBrush" Color="#FFD4D4D4" /&gt; 
    &lt;SolidColorBrush x:Key="SelectionBrush" Color="#FF217346" /&gt; 
  &lt;/DataGrid.Resources&gt; 
&lt;/DataGrid&gt; </pre>
<p>For this implementation, we set the <kbd>AutoGenerateColumns</kbd> property to <kbd>False</kbd>, because we will be programmatically creating the columns of our spreadsheet control. In order to approximate a spreadsheet control, we also need to restrict the selection possibilities of our custom <kbd>DataGrid</kbd>.</p>
<p>As such, we set the <kbd>SelectionUnit</kbd> property to <kbd>Cell</kbd>, so that users select just the cell that they click on, rather than the whole row, which is the default selection behavior. In addition, to simplify this example, we also set the <kbd>SelectionMode</kbd> property to <kbd>Single</kbd>, the <kbd>IsReadOnly</kbd> property to <kbd>True</kbd> and the <kbd>RowHeight</kbd> property to <kbd>20</kbd>.</p>
<p>Our row and column headers will both be 26 pixels each, so we set the <kbd>RowHeaderWidth</kbd> and <kbd>ColumnHeaderHeight</kbd> properties to <kbd>26</kbd>. Note that we could set the row and column header dimensions in their relative styles instead, but we will need to reference these properties later, so it is important that we set them here. The next five properties, prefixed with <kbd>CanUser</kbd>, have also been set to <kbd>False</kbd>, to further shorten this example.</p>
<p>We then set both of the <kbd>HorizontalGridLinesBrush</kbd> and <kbd>VerticalGridLinesBrush</kbd> properties to the <kbd>GridlinesBrush</kbd> brush from the <kbd>Resources</kbd> section and the <kbd>BorderBrush</kbd> property to the <kbd>BorderBrush</kbd> brush. Note that we need to use a <kbd>DynamicResource</kbd> markup extension in these cases, because these brushes are defined after the <kbd>DataGrid</kbd> declaration, along with the rest of the resources, and the XAML parser would not be able to locate them with a standard <kbd>StaticResource</kbd> markup extension.<span> </span></p>
<p><span>Also, note that it is essential that we remove the empty</span><span> </span><kbd>Grid</kbd><span> </span><span>panel that Visual Studio adds into each new</span><span> </span><kbd>UserControl</kbd><span>. The reason is that any elements declared inside the</span><span> </span><kbd>DataGrid</kbd><span> </span><span>control are determined to be its items and we cannot simultaneously use both its</span><span> </span><kbd>Items</kbd><span> </span><span>property and its</span><span> </span><kbd>ItemsSource</kbd><span> </span><span>property, which we intend on using. If we use them both, we'll see this exception being thrown at runtime:</span></p>
<pre><strong><span>System.InvalidOperationException: 'Items collection must be empty before using </span>ItemsSource.<span>'</span></strong></pre>
<p>Let's move on now, to investigate how we can display data in our spreadsheet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating with Data</h1>
                </header>
            
            <article>
                
<p>In order to get some data into our <kbd>Spreadsheet</kbd> control, we will need a class to represent each cell in the spreadsheet. Let's take a look at a basic <kbd>Cell</kbd> class now:</p>
<pre>namespace CompanyName.ApplicationName.DataModels<br/>{<br/>  public class Cell : BaseDataModel<br/>  {<br/>    private string address = string.Empty, content = string.Empty;<br/>    private double width = 0;<br/><br/>    public Cell(string address, string content, double width)<br/>    {<br/>      Address = address;<br/>      Content = content;<br/>      Width = width;<br/>    }<br/><br/>    public string Address<br/>    {<br/>      get { return address; }<br/>      set { if (address != value) { address = value; <br/>        NotifyPropertyChanged(); } }<br/>    }<br/><br/>    public string Content<br/>    {<br/>      get { return content; }<br/>      set { if (content != value) { content = value; <br/>        NotifyPropertyChanged(); } }<br/>    }<br/><br/>    public double Width<br/>    {<br/>      get { return width; }<br/>      set { if (width != value) { width = value; NotifyPropertyChanged(); } }<br/>    }<br/><br/>    public override string ToString()<br/>    {<br/>      return $"{Address}: {Content}";<br/>    }<br/>  }<br/>} </pre>
<p>This is a very straight forward class, with just three properties, a constructor to populate those properties, and an overridden <kbd>ToString</kbd> method. As usual, we extend our <kbd>BaseDataModel</kbd> class to provide us with access to the <kbd>INotifyPropertyChanged</kbd> interface. Note that in a real spreadsheet-based application, we would have many more properties in this class, to enable us to style and format the content appropriately.</p>
<p>Let's now move on, to create our <kbd>SpreadsheetViewModel</kbd> and <kbd>SpreadsheetView</kbd> classes. In the <kbd>SpreadsheetViewModel</kbd> class, we populate a <kbd>DataTable</kbd> with some basic example data and we data bind that to our new <kbd>Spreadsheet</kbd> control in the <kbd>SpreadsheetView</kbd> class:</p>
<pre>using CompanyName.ApplicationName.DataModels; <br/>using System.Data; <br/> <br/>namespace CompanyName.ApplicationName.ViewModels <br/>{ <br/>  public class SpreadsheetViewModel : BaseViewModel <br/>  { <br/>    private DataRowCollection dataRowCollection = null; <br/><br/>    public SpreadsheetViewModel() <br/>    { <br/>      Cell[] Cells = new Cell[9]; <br/>      Cells[0] = new Cell("A1", "", 64); <br/>      Cells[1] = new Cell("B1", "", 96); <br/>      Cells[2] = new Cell("C1", "", 64); <br/>      Cells[3] = new Cell("A2", "", 64); <br/>      Cells[4] = new Cell("B2", "Hello World", 96); <br/>      Cells[5] = new Cell("C2", "", 64); <br/>      Cells[6] = new Cell("A3", "", 64); <br/>      Cells[7] = new Cell("B3", "", 96); <br/>      Cells[8] = new Cell("C3", "", 64); <br/><br/>      DataTable table = new DataTable(); <br/>      table.Columns.Add("A", typeof(Cell)); <br/>      table.Columns.Add("B", typeof(Cell)); <br/>      table.Columns.Add("C", typeof(Cell)); <br/>      table.Rows.Add(Cells[0], Cells[1], Cells[2]); <br/>      table.Rows.Add(Cells[3], Cells[4], Cells[5]); <br/>      table.Rows.Add(Cells[6], Cells[7], Cells[8]); <br/><br/>      Rows = table.Rows; <br/>    } <br/><br/>    public DataRowCollection Rows <br/>    { <br/>      get { return dataRowCollection; } <br/>      set { if (dataRowCollection != value) { dataRowCollection = value; <br/>        NotifyPropertyChanged(); } } <br/>    } <br/>  } <br/>}</pre>
<p>In this very simple View Model, we declare a single property of type <kbd>DataRowCollection</kbd>, to contain our spreadsheet data. Using this type enables us to easily populate our spreadsheet from a <kbd>DataTable</kbd> object, which we may have loaded from a database, or generated from an XML file, for example.</p>
<p>In the constructor, we programmatically initialize and populate a <kbd>DataTable</kbd> with example <kbd>Cell</kbd> objects and set its <kbd>Rows</kbd> property value to our <kbd>Rows</kbd> property. Let's see how this <kbd>Rows</kbd> property is data-bound to our <kbd>Spreadsheet</kbd> control in the <kbd>SpreadsheetView</kbd> class now:</p>
<pre>&lt;UserControl x:Class="CompanyName.ApplicationName.Views.SpreadsheetView" 
   
   
  &gt; 
  &lt;Controls:Spreadsheet ItemsSource="{Binding Rows}" Margin="50" /&gt; 
&lt;/UserControl&gt; </pre>
<p>Once again, this is a very simple class, with nothing other than a XAML Namespace declaration for our <kbd>Controls</kbd> project and one of our <kbd>Spreadsheet</kbd> controls, with its <kbd>ItemsSource</kbd> property data bound to the <kbd>Rows</kbd> property of our View Model. The code behind is even more bare, with no custom code in it at all. Also, remember to link our View and <span>View Model</span> together, using whichever method you prefer.</p>
<p>Before we can see any data in our <kbd>Spreadsheet</kbd> control, however, we will need to declare a <kbd>DataTemplate</kbd> to define how each cell should be rendered and programmatically set up our columns, in relation to the data-bound items. Let's declare the required XAML Namespace in the XAML file and add the <kbd>DataTemplate</kbd> into the <kbd>Resources</kbd> section of our <kbd>Spreadsheet</kbd> control first:</p>
<pre> 
... 
&lt;DataTemplate x:Key="CellTemplate" DataType="{x:Type DataModels:Cell}"&gt; 
  &lt;TextBlock Text="{Binding Content}" HorizontalAlignment="Center" <br/>    VerticalAlignment="Center" /&gt; 
&lt;/DataTemplate&gt; </pre>
<p>Here, we have a horizontally centered <kbd>TextBlock</kbd> control, to output the contents of each cell. In a real-world application, we'd surround it with a <kbd>Border</kbd> element, to color the background of each cell and data bind to many more properties, to enable us to set different style and formatting settings for each cell. For this example, however, we'll keep it simple.</p>
<p>Returning to the subject of column generation now, remember that we do not know how many columns there will be in the incoming data, so we need to find a place to set them up programmatically. For this, we return to the protected base class methods.</p>
<p>Looking through the protected methods of the <kbd>DataGrid</kbd> class, we see a good candidate: the <kbd>OnItemsSourceChanged</kbd> method. This method will be called each time the <kbd>ItemsSource</kbd> value changes, so it's an ideal place to initialize our spreadsheet columns when the data source changes.</p>
<p>But our items are <kbd>DataRow</kbd> objects, with each <kbd>Cell</kbd> object being in a different location in its <kbd>ItemArray</kbd> collection. We need a way to use the array syntax to data bind each <kbd>Cell</kbd>, but the built-in column types don't have this functionality. As such, we will need to create a custom one and the <kbd>DataGridTemplateColumn</kbd> class is the best place to start.</p>
<p>We can override this class to add a property named <kbd>Binding</kbd> of type <kbd>Binding</kbd> and use it to set the binding on the UI element that is generated for each cell. Looking through the protected methods in the <kbd>DataGridTemplateColumn</kbd> class, we find the <kbd>GenerateElement</kbd> method, which generates these UI elements. Let's see this new <kbd>DataGridBoundTemplateColumn</kbd> class now:</p>
<pre>using System.Windows; <br/>using System.Windows.Controls; <br/>using System.Windows.Data; <br/> <br/>namespace CompanyName.ApplicationName.Views.Controls <br/>{ <br/>  public class DataGridBoundTemplateColumn : DataGridTemplateColumn <br/>  { <br/>    public Binding Binding { get; set; } <br/><br/>    protected override FrameworkElement GenerateElement(DataGridCell cell,<br/>      object dataItem) <br/>    { <br/>      FrameworkElement element = base.GenerateElement(cell, dataItem); <br/>      if (Binding != null) <br/>        element.SetBinding(ContentPresenter.ContentProperty, Binding); <br/>      return element; <br/>    } <br/>  } <br/>} </pre>
<p>This is another simple class and, we start by extending the <kbd>DataGridTemplateColumn</kbd> class and declaring the aforementioned <kbd>Binding</kbd> property. We then override the <kbd>GenerateElement</kbd> method and in it, first call the base class implementation to generate the <kbd>FrameworkElement</kbd> object that relates to the current cell, passing the input parameters through unchanged.</p>
<p>If the <kbd>Binding</kbd> property is not <kbd>null</kbd>, we then call the <kbd>SetBinding</kbd> method on the element, specifying the <kbd>ContentPresenter.ContentProperty</kbd> Dependency Property as the binding target and passing the <kbd>Binding</kbd> object from the <kbd>Binding</kbd> property through to connect with it. We end by simply returning the generated element.</p>
<p>Now, let's return to the code behind of our <kbd>Spreadsheet</kbd> class, where we need to use our new <kbd>DataGridBoundTemplateColumn</kbd> class:</p>
<pre>using CompanyName.ApplicationName.DataModels; 
using System.Collections; 
using System.Data; 
using System.Linq; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Data; 
 
... 
 
protected override void OnItemsSourceChanged(IEnumerable oldValue, <br/>  IEnumerable newValue) 
{ 
  if (!(newValue is DataRowCollection rows) || rows.Count == 0) return; 
  Cell[] cells = rows[0].ItemArray.Cast&lt;Cell&gt;().ToArray(); 
  Columns.Clear(); 
  DataTemplate cellTemplate = (DataTemplate)FindResource("CellTemplate"); 
  for (int i = 0; i &lt; cells.Length; i++) 
  { 
    DataGridBoundTemplateColumn column = new DataGridBoundTemplateColumn 
    { 
      Header = GetColumnName(i + 1), 
      CellTemplate = cellTemplate, 
      Binding = new Binding($"[{i}]"), 
      Width = cells[i].Width 
    }; 
    Columns.Add(column); 
  } 
} 
 
private string GetColumnName(int index) 
{ 
    if (index &lt;= 26) return ((char)(index + 64)).ToString(); 
    if (index % 26 == 0) <br/>      return string.Concat(GetColumnName(index / 26 - 1), "Z"); 
    return string.Concat(GetColumnName(index / 26), <br/>      GetColumnName(index % 26)); 
} </pre>
<p>As mentioned previously, we override the <kbd>OnItemsSourceChanged</kbd> method to initialize our spreadsheet columns each time the data source changes. In it, we use C# 6.0 Pattern Matching to verify that the <kbd>newValue</kbd> input parameter is not <kbd>null</kbd> and is of type <kbd>DataRowCollection</kbd>, before also checking that the collection has one or more rows in it.</p>
<p>If the <kbd>DataRowCollection</kbd> object is valid, then we cast the items in the <kbd>ItemArray</kbd> collection of its first row to an array of our custom type <kbd>Cell</kbd>. We only need to use the first row, because here, we are just setting up the columns, not the data. We then clear the columns of our spreadsheet control and find the <kbd>DataTemplate</kbd> named <kbd>CellTemplate</kbd> from the control's <kbd>Resources</kbd> section.</p>
<p>Next, we iterate through the <kbd>Cell</kbd> objects in the array, adding a new <kbd>DataGridBoundTemplateColumn</kbd> element to the spreadsheet's <kbd>Columns</kbd> collection for each one. Each column element is initialized with a <kbd>Header</kbd>, taken from the <kbd>GetColumnName</kbd> method, the <kbd>CellTemplate</kbd> <kbd>DataTemplate</kbd>, the <kbd>Width</kbd> from the <kbd>Cell</kbd> object, and a <kbd>Binding</kbd> object.</p>
<p>Note that the <kbd>Binding</kbd> path is set to <kbd>$"[{i}]"</kbd>, which would translate to <kbd>"[0]"</kbd> for the first item for example, and represents the standard indexing notation. This would result in the binding path being set to the first item in each row of the data-bound collection, or put another way, each cell in the first column of our data source.</p>
<p>If the input value in the <kbd>GetColumnName</kbd> method is between 1 and 26, we add 64 to it, before casting it to a <kbd>char</kbd> and then calling the <kbd>ToString</kbd> method on the result. The capital A character has the integer value of 65 in the ASCII table and so, this code has the effect of turning the index of the first 26 columns into the letters A to Z.</p>
<p>If the input value is more than <kbd>26</kbd> and is also an exact multiple of <kbd>26</kbd>, then we return the string concatenation of a recursive call to the <kbd>GetColumnName</kbd> method, passing in the factor of the input value when it is divided by <kbd>26</kbd>, with <kbd>1</kbd> subtracted from it, and the letter <kbd>Z</kbd>.</p>
<p>If none of the <kbd>if</kbd> conditions are met, we return the result of two more recursive calls: the first passed value represents the factor of the input value when it is divided by 26 and the second represents the remainder of the input value when it is divided by 26.</p>
<p>In plain English, the first line outputs letters A to Z, while the second handles column identities that contain more than a single letter and end in the letter Z, and the third line handles all of the rest. Let's see what we have when running the application so far:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/6fc648f4-48be-49de-966a-1cf54de2665e.png"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Progressing toward the Target</h1>
                </header>
            
            <article>
                
<p><em>So, what changes do we need to make to the turn this</em> <kbd>DataGrid</kbd> <em>control into something that looks more like a spreadsheet?</em> We need to style it accordingly and to populate the row headers with numbers that identify each row. We also need to highlight the relevant row and column headers when a cell is selected and can implement an animated selection rectangle to highlight the selected cell, instead of using the default highlighting shown in the image.</p>
<p class="mce-root">First, let's populate the row headers with numbers. There are several ways to achieve this, but I prefer to simply ask each row what its index is in a converter class and connect it to the row header via a data binding. Let's see this converter now:</p>
<pre>using System; 
using System.Globalization; 
using System.Windows; 
using System.Windows.Controls; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
[ValueConversion(typeof(DataGridRow), typeof(int))] 
  public class DataGridRowToRowNumberConverter : IValueConverter 
  { 
    public object Convert(object value, Type targetType, object parameter,<br/>      CultureInfo culture) 
    { 
      if (value is DataGridRow dataGridRow) <br/>        return dataGridRow.GetIndex() + 1; 
      return DependencyProperty.UnsetValue; 
    } 
 
    public object ConvertBack(object value, Type targetType, <br/>      object parameter, CultureInfo culture) 
    { 
      throw new NotImplementedException(); 
    } 
  } 
} </pre>
<p>This is another simple class and, as usual, we start by specifying the data types involved in the converter in the <kbd>ValueConversion</kbd> attribute. In this case, our input will be <kbd>DataRow</kbd> objects and our output will be their integer row numbers. In the <kbd>Convert</kbd> method, we use Pattern Matching from C# 6.0 as a shortcut to validate that our input value is not <kbd>null</kbd> and is of the appropriate type and if suitable, to cast it to that type.</p>
<p>If the input is valid, we call the <kbd>GetIndex</kbd> method on the pre-cast <kbd>dataGridRow</kbd> variable, remembering to add 1 to the zero-based method result, before returning it from the converter. For all other input values, we return the <kbd>DependencyProperty.UnsetValue</kbd> value. As we will not need to convert any values in the other direction, we leave the <kbd>ConvertBack</kbd> method unimplemented.</p>
<p>Let's see how we use this <kbd>converter</kbd> class now. First, we need to set up a XAML Namespace for our <kbd>Converters</kbd> CLR Namespace and create an instance of it in the control's <kbd>Resources</kbd> section:</p>
<pre><span/> <br/>... 
 
&lt;Converters:DataGridRowToRowNumberConverter <br/>  x:Key="DataGridRowToRowNumberConverter" /&gt; </pre>
<p>We are then able to use it in a data binding on the <kbd>Text</kbd> property of a <kbd>TextBlock</kbd> element in the <kbd>DataTemplate</kbd>, that is applied to the <kbd>RowHeaderTemplate</kbd> property in our custom <kbd>DataGrid</kbd>:</p>
<pre>&lt;DataGrid.RowHeaderTemplate&gt; 
  &lt;DataTemplate&gt; 
    &lt;TextBlock Text="{Binding Path = ., <br/>      RelativeSource={RelativeSource AncestorType={x:Type DataGridRow}}, <br/>      Converter={StaticResource DataGridRowToRowNumberConverter}}" /&gt; 
  &lt;/DataTemplate&gt; 
&lt;/DataGrid.RowHeaderTemplate&gt; </pre>
<p>Note that the binding path is set to <kbd>.</kbd>, which as you may remember, sets it to the whole binding object. The <kbd>RelativeSource</kbd> binding sets the binding source to the first ancestor of the <kbd>TextBlock</kbd> of type <kbd>DataGridRow</kbd>, and so we pass the whole <kbd>DataGridRow</kbd> object through to the binding and therefore, also to the converter, as required.</p>
<p>Also, note that we must declare this <kbd>RowHeaderTemplate</kbd> property below the <kbd>Resources</kbd> section in the XAML file. Failure to do this will result in the following runtime error:</p>
<pre><strong>Cannot find resource named 'DataGridRowToRowNumberConverter'. Resource names are case sensitive.</strong></pre>
<p>Whereas sometimes we can fix these "reference not found" errors by using a <kbd>DynamicResource</kbd> markup extension instead of a <kbd>StaticResource</kbd> markup extension, it won't work in this case. This is because we can only use them on a <kbd>DependencyProperty</kbd> of a <kbd>DependencyObject</kbd> and the <kbd>Converter</kbd> property is not a <kbd>DependencyProperty</kbd> and the <kbd>Binding</kbd> class is not a <kbd>DependencyObject</kbd>.</p>
<p>Let's see what our spreadsheet looks like now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/57f6f121-0eaa-4d6d-9e52-bf5083725d6f.png"/></span></p>
<p>As can be seen from the preceding image, we clearly need to add some styling to fix some issues and make it look more like a typical spreadsheet:</p>
<pre>&lt;!--Default Selection Colors--&gt; 
&lt;SolidColorBrush <br/>  x:Key="{x:Static SystemColors.HighlightBrushKey}" Color="Transparent" /&gt; 
&lt;SolidColorBrush <br/>  x:Key="{x:Static SystemColors.HighlightTextBrushKey}" Color="Black" /&gt; 
&lt;SolidColorBrush <br/>  x:Key="{x:Static DataGrid.FocusBorderBrushKey}" Color="Transparent" /&gt; 
&lt;SolidColorBrush x:Key="{x:Static <br/>  SystemColors.InactiveSelectionHighlightBrushKey}" Color="Transparent" /&gt; 
&lt;LinearGradientBrush x:Key="HorizontalBorderGradient" StartPoint="0,0"<br/>  EndPoint="0,1"&gt; 
  &lt;GradientStop Color="{StaticResource BackgroundColor}" /&gt; 
  &lt;GradientStop Color="{StaticResource BorderColor}" Offset="1" /&gt; 
&lt;/LinearGradientBrush&gt; 
&lt;LinearGradientBrush x:Key="VerticalBorderGradient" StartPoint="0,0"<br/>  EndPoint="1,0"&gt; 
  &lt;GradientStop Color="{StaticResource BackgroundColor}" /&gt; 
  &lt;GradientStop Color="{StaticResource BorderColor}" Offset="1" /&gt; 
&lt;/LinearGradientBrush&gt; 
&lt;LinearGradientBrush x:Key="DiagonalBorderGradient" StartPoint="0.2,0" <br/>  EndPoint="1,1"&gt; 
  &lt;GradientStop Color="{StaticResource BackgroundColor}" Offset="0.45" /&gt; 
  &lt;GradientStop Color="{StaticResource BorderColor}" Offset="1" /&gt; 
&lt;/LinearGradientBrush&gt; 
 
... 
 
&lt;Style TargetType="{x:Type DataGridRowHeader}"&gt; <br/>  &lt;Setter Property="Background" <br/>    Value="{StaticResource BackgroundBrush}" /&gt; <br/>  &lt;Setter Property="BorderThickness" Value="0,0,1,1" /&gt; <br/>  &lt;Setter Property="BorderBrush" <br/>    Value="{StaticResource VerticalBorderGradient}" /&gt; <br/>  &lt;Setter Property="Padding" Value="4,0" /&gt; <br/>  &lt;Setter Property="HorizontalContentAlignment" Value="Center" /&gt; <br/>  &lt;Setter Property="FontSize" Value="13" /&gt; <br/>&lt;/Style&gt; <br/>&lt;Style TargetType="{x:Type DataGridColumnHeader}"&gt; <br/>  &lt;Setter Property="Background" <br/>    Value="{StaticResource BackgroundBrush}" /&gt; <br/>  &lt;Setter Property="BorderThickness" Value="0,0,1,1" /&gt; <br/>  &lt;Setter Property="BorderBrush" <br/>    Value="{StaticResource HorizontalBorderGradient}" /&gt; <br/>  &lt;Setter Property="Padding" Value="0" /&gt; <br/>  &lt;Setter Property="HorizontalContentAlignment" Value="Center" /&gt; <br/>  &lt;Setter Property="FontSize" Value="13" /&gt; <br/>&lt;/Style&gt; </pre>
<p>The only thing to note here are the first four <kbd>SolidColorBrush</kbd> objects that we declared. They are used by the .NET Framework to set the default selection colors for a number of the built-in controls. We can use them to change the default blue background and white text shown in the previous image. There are many more of these default colors to be found in the <kbd>SystemColors</kbd> class, so it's worth familiarizing yourself with them.</p>
<p>Let's see what our spreadsheet looks like now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/968e19ba-f48e-47ac-9c51-fbeecc315929.png"/></span></p>
<p>Now, our <kbd>Spreadsheet</kbd> control is starting to look more like a typical spreadsheet application, but we have no highlighting for our selected cell anymore. You may also notice that the row headers are not center-aligned horizontally, as our style suggests they should be.</p>
<p>This happens because, unlike the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridColumnHeader</kbd> class, the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridRowHeader</kbd> class does not map the <kbd>HorizontalContentAlignment</kbd> property to the <kbd>HorizontalAlignment</kbd> property on any internal elements within the template.</p>
<p>This might at first seem like an oversight on Microsoft's part, but it is actually because, in the default <kbd>ControlTemplate</kbd>, each <kbd>DataGridRowHeader</kbd> object has an additional control that displays the validation error to the right of the header content. With this extra control taking up the limited space, there is not enough space to horizontally center the row header.</p>
<p>To fix this problem, we will need to alter the default <kbd>ControlTemplate</kbd>, to remove the control that displays the error template. Co-incidentally, we will also need to alter this template to be able to highlight the selected cell in the row header. Likewise, to highlight the selected cell in the column header, we will need to adjust the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridColumnHeader</kbd> class.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Highlighting the selection</h1>
                </header>
            
            <article>
                
<p>Let’s now move onto the task of highlighting the selected cell. Here, we will find out what is required to create a selection rectangle around the selected cell, that smoothly animates from selection to selection. But before that, let's <span>investigate </span>how we can also indicate which cell is selected in the axes of our spreadsheet control.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Indicating in the Axes</h1>
                </header>
            
            <article>
                
<p>In order to highlight the currently selected cell in the row and column headers, we will need to update the two relating default <kbd>ControlTemplate</kbd> objects, as just described. But before we do that, we will need to declare two new <kbd>IValueConverter</kbd> classes as well. Let's look at the row header converter class first:</p>
<pre>using System; 
using System.Data; 
using System.Globalization; 
using System.Linq; 
using System.Windows.Data; 
 
namespace CompanyName.ApplicationName.Converters 
{ 
  public class DataGridRowHeaderSelectionMultiConverter : <br/>    IMultiValueConverter 
  { 
    public object Convert(object[] values, Type targetType, <br/>      object parameter, CultureInfo culture) 
    { 
      if (values == null || values.Count() != 2 || <br/>        !(values[0] is DataRow selectedDataRow) || <br/>        !(values[1] is DataRow dataRowToCompare)) return false; 
      return selectedDataRow.Equals(dataRowToCompare); 
    } 
<br/>    public object[] ConvertBack(object value, Type[] targetTypes, <br/>      object parameter, CultureInfo culture) 
    { 
      throw new NotImplementedException(); 
    } 
  } 
} </pre>
<p>For this converter, we extend the <kbd>IMultiValueConverter</kbd> interface, and in the <kbd>Convert</kbd> method, we first validate our values input parameter. If it is <kbd>null</kbd>, contains more or less than two objects, or if either of the contained objects are not non-<kbd>null</kbd> <kbd>DataRow</kbd> objects, we return <kbd>false</kbd>. If the input parameter is valid, we use C# 6.0 Pattern Matching to cast the two contained objects to the <kbd>DataRow</kbd> type.</p>
<p>The first represents the <kbd>DataRow</kbd> object that contains the currently selected cell and the second comes from the <kbd>DataRow</kbd> object to compare. We return <kbd>true</kbd> if the selected <kbd>DataRow</kbd> object equals the currently compared <kbd>DataRow</kbd> object and <kbd>false</kbd> for all others. You can think of this as each row header asking the converter in turn, if it is in the same <kbd>DataRow</kbd> object as the currently selected cell. The <kbd>ConvertBack</kbd> method is unrequired for our example and so, is left unimplemented.</p>
<p><span>Let's now investigate the changes that we need to make to the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridRowHeader</kbd> class. As described in <em><a href="d5906090-c679-45d6-81cd-016d4337eb75.xhtml">Chapter 5</a>, Using the Right Controls for the Job</em>, in the <em>Modifying Existing Controls</em></span> section<span>, we can create a copy of the default <kbd>ControlTemplate</kbd> from the <span class="packt_screen">Properties</span> panel in Visual Studio. Note that if we do not already have a control of the correct type in our XAML file, we can simply declare one temporarily, select it, then continue with the process of template extraction as described, remembering to delete it afterwards.</span></p>
<p><span>As this template is quite long, we won't show it all here, instead highlighting just the areas that we need to change. The entire code will be available in the separate downloadable code bundle that comes with this book. </span>Before we can use this template however, we need to add a reference to the <kbd>PresentationFramework.Aero</kbd> assembly to our project and a XAML Namespace for the <kbd>Microsoft.Windows.Themes</kbd> CLR Namespace:</p>
<pre> </pre>
<p>Next, we need to add an instance of our new converter class into our spreadsheet control's <kbd>Resources</kbd> section:</p>
<pre>&lt;Converters:DataGridRowHeaderSelectionMultiConverter <br/>  x:Key="DataGridRowHeaderSelectionMultiConverter" /&gt; </pre>
<p>Now, let's see the template:</p>
<pre>&lt;ControlTemplate x:Key="DataGridRowHeaderControlTemplate" <br/>  TargetType="{x:Type DataGridRowHeader}"&gt; <br/>  &lt;Grid&gt; <br/>    &lt;Themes:DataGridHeaderBorder Name="Border" <br/>      IsHitTestVisible="False" ... &gt; <br/>      &lt;ContentPresenter ... HorizontalAlignment="{TemplateBinding <br/>        HorizontalContentAlignment}" /&gt; <br/>    &lt;/Themes:DataGridHeaderBorder&gt; <br/>    &lt;Rectangle Name="ColorSelectionBar" Fill="Transparent" <br/>      IsHitTestVisible="False" VerticalAlignment="Stretch" <br/>      HorizontalAlignment="Right" Width="2" Margin="0,-1,0,0" /&gt; <br/>    ... <br/>  &lt;/Grid&gt; <br/>  &lt;ControlTemplate.Triggers&gt; <br/>    &lt;DataTrigger Value="True"&gt; <br/>      &lt;DataTrigger.Binding&gt; <br/>        &lt;MultiBinding Converter="{StaticResource <br/>          DataGridRowHeaderSelectionMultiConverter}"&gt; <br/>          &lt;Binding Path="CurrentCell.Item" RelativeSource="{RelativeSource <br/>            AncestorType={x:Type DataGrid}}" /&gt; <br/>          &lt;Binding /&gt; <br/>        &lt;/MultiBinding&gt; <br/>      &lt;/DataTrigger.Binding&gt; <br/>      &lt;Setter Property="Foreground" <br/>        Value="{StaticResource SelectionBrush}" /&gt; <br/>      &lt;Setter TargetName="ColorSelectionBar" Property="Fill" <br/>        Value="{StaticResource SelectionBrush}" /&gt; <br/>      &lt;Setter TargetName="Border" Property="Background" <br/>        Value="{StaticResource SelectedBackgroundBrush}" /&gt; <br/>    &lt;/DataTrigger&gt; <br/>  &lt;/ControlTemplate.Triggers&gt; <br/>&lt;/ControlTemplate&gt;</pre>
<p>In order to apply the template, we'll need to add another <kbd>Setter</kbd> element into our <kbd>Style</kbd> for the <kbd>DataGridRowHeader</kbd> class, making sure that the template is declared before it in the XAML:</p>
<pre><span>&lt;Setter Property="Template" <br/>  Value ="{StaticResource DataGridRowHeaderControlTemplate}" /&gt;</span> </pre>
<p>After attaining a copy of the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridRowHeader</kbd> class, we first named the <kbd>DataGridHeaderBorder</kbd> element <kbd>Border</kbd>, so that we could refer to it from the template's <kbd>Triggers</kbd> collection. We also set its <kbd>IsHitTestVisible</kbd> property to <kbd>False</kbd> to prevent selection from the row headers.</p>
<p>We then removed the control that displayed the validation error template and connected the <kbd>HorizontalAlignment</kbd> property of the internal <kbd>ContentPresenter</kbd> element with the <kbd>HorizontalContentAlignment</kbd> property of the parent <kbd>DataGridRowHeader</kbd> object via a <kbd>TemplateBinding</kbd> element, so that our style will actually center the header content, as previously expected.</p>
<p>Next, we added a new <kbd>Rectangle</kbd> element, named <kbd>ColorSelectionBar</kbd>, and a <kbd>DataTrigger</kbd> object. The <kbd>Rectangle</kbd> element has its <kbd>Fill</kbd> property set to <kbd>Transparent</kbd>, so that it cannot initially be seen, and its <kbd>IsHitTestVisible</kbd> property set to <kbd>False</kbd>, to prevent users from being able to interact with it.</p>
<p>We set its <kbd>VerticalAlignment</kbd> property to <kbd>Stretch</kbd>, so that it spans the full height of the row header, and its <kbd>HorizontalAlignment</kbd> property to <kbd>Right</kbd>, to ensure that it lies to the right of the header, out of the way of the row indicator. Finally, we set its top margin to <kbd>-1</kbd>, in order to extend it over the top border of the header, as it already extends over the bottom border by one pixel.</p>
<p>We then added a <kbd>DataTrigger</kbd> object into the <kbd>Triggers</kbd> collection, using a <kbd>MultiBinding</kbd> object to define its conditions. We assigned our <kbd>DataGridRowHeaderSelectionMultiConverter</kbd> instance to the <kbd>Converter</kbd> property of the <kbd>MultiBinding</kbd> object.</p>
<p>Note that the <kbd>MultiBinding</kbd> object has two bindings: one is the <kbd>DataRow</kbd> object that relates to the <kbd>CurrentCell</kbd> property of the <kbd>DataGrid</kbd> control and the other is set directly to the <kbd>DataRow</kbd> object that the template is applied to.</p>
<p>When the converter returns <kbd>true</kbd>, we paint the <kbd>ColorSelectionBar</kbd> element and the header foreground with our <kbd>SelectionBrush</kbd> brush and the <kbd>Border</kbd> element, which represents the background of the row header, with the <kbd>SelectedBackgroundBrush</kbd> brush. This results in the row header of the selected cell being highlighted each time a cell is selected.</p>
<p>Let's now do the same for the column headers, starting with a look at the required <kbd>DataGridColumnHeaderSelectionMultiConverter</kbd> class:</p>
<pre>using System; <br/>using System.Globalization; <br/>using System.Linq; <br/>using System.Windows; <br/>using System.Windows.Data; <br/> <br/>namespace CompanyName.ApplicationName.Converters <br/>{ <br/>  public class DataGridColumnHeaderSelectionMultiConverter : <br/>    IMultiValueConverter <br/>  { <br/>    public object Convert(object[] values, Type targetType, <br/>      object parameter, CultureInfo culture) <br/>    { <br/>      if (values == null || values.Count() != 2 || <br/>        values.Any(v =&gt; v == null || v == DependencyProperty.UnsetValue))<br/>        return false; <br/>      string selectedColumnHeader = values[0].ToString(); <br/>      string columnHeaderToCompare = values[1].ToString(); <br/>      return selectedColumnHeader.Equals(columnHeaderToCompare); <br/>    } <br/><br/>    public object[] ConvertBack(object value, Type[] targetTypes, <br/>      object parameter, CultureInfo culture) <br/>    { <br/>      throw new NotImplementedException(); <br/>    } <br/>  } <br/>}</pre>
<p>We again extend the <kbd>IMultiValueConverter</kbd> interface, and in the <kbd>Convert</kbd> method, we start by checking the input values to ensure their validity for this converter. We validate that the <kbd>values</kbd> input parameter is not <kbd>null</kbd> and that it contains two non-<kbd>null</kbd> values, that are also not unset values. If any of these checks fail, we return <kbd>false</kbd>.</p>
<p>If the <kbd>values</kbd> input parameter is valid, we call the <kbd>object.ToString</kbd> method on the two objects contained within it. The first value represents the text in the selected column header and the second represents the text in the column header to compare.</p>
<p>Every column header will call this converter in turn and if the column header to compare equals the selected column header, that signifies that it is the column that contains the selected cell and we return <kbd>true</kbd>, otherwise we return <kbd>false</kbd>. As the <kbd>ConvertBack</kbd> method is unrequired for this example, it is left unimplemented.</p>
<p>Before we alter the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridColumnHeader</kbd> class, we will need to add a reference to our new <kbd>converter</kbd> class into our spreadsheet control's <kbd>Resources</kbd> section:</p>
<pre>&lt;Converters:DataGridColumnHeaderSelectionMultiConverter<br/>  x:Key="DataGridColumnHeaderSelectionMultiConverter" /&gt; </pre>
<p>Now, let's see the edited template:</p>
<pre>&lt;ControlTemplate x:Key="DataGridColumnHeaderControlTemplate" <br/>  TargetType="{x:Type DataGridColumnHeader}"&gt; <br/>  &lt;Grid&gt; <br/>    &lt;Themes:DataGridHeaderBorder Name="Border" ... /&gt; <br/>    &lt;Rectangle Name="ColorSelectionBar" Fill="Transparent" <br/>      IsHitTestVisible="False" HorizontalAlignment="Stretch" <br/>      VerticalAlignment="Bottom" Height="2" Margin="-1,0,0,0" /&gt; <br/>    ... <br/>  &lt;/Grid&gt; <br/>  &lt;ControlTemplate.Triggers&gt; <br/>    &lt;DataTrigger Value="True"&gt; <br/>      &lt;DataTrigger.Binding&gt; <br/>        &lt;MultiBinding Converter="{StaticResource <br/>          DataGridColumnHeaderSelectionMultiConverter}"&gt; <br/>          &lt;Binding Path="CurrentCell.Column.Header" RelativeSource="{<br/>            RelativeSource AncestorType={x:Type DataGrid}}" /&gt; <br/>          &lt;Binding Path="Content" RelativeSource="{RelativeSource Self}" /&gt; <br/>        &lt;/MultiBinding&gt; <br/>      &lt;/DataTrigger.Binding&gt; <br/>      &lt;Setter Property="Foreground" <br/>        Value="{StaticResource SelectionBrush}" /&gt; <br/>      &lt;Setter TargetName="ColorSelectionBar" Property="Fill" <br/>        Value="{StaticResource SelectionBrush}" /&gt; <br/>      &lt;Setter TargetName="Border" Property="Background" <br/>        Value="{StaticResource SelectedBackgroundBrush}" /&gt; <br/>    &lt;/DataTrigger&gt; <br/>  &lt;/ControlTemplate.Triggers&gt; <br/>&lt;/ControlTemplate&gt; </pre>
<p>Starting with the default <kbd>ControlTemplate</kbd> for the <kbd>DataGridColumnHeader</kbd> class, we again added a single UI element and a single <kbd>DataTrigger</kbd> object, with which to control its visibility, as we did with our custom <kbd>DataGridRowHeader</kbd> <kbd>ControlTemplate</kbd>. However, this template requires less alteration, as its header is already centered and we do not need to remove any elements.</p>
<p>Once again, the <kbd>Rectangle</kbd> object named <kbd>ColorSelectionBar</kbd> is the new element. Note that we set its <kbd>Fill</kbd> property to <kbd>Transparent</kbd>, so that it cannot initially be seen. Remember that there is a column header on every column and we don't want them all to be highlighted at once.</p>
<p>We set the <kbd>Rectangle</kbd> element's <kbd>IsHitTestVisible</kbd> property to <kbd>False</kbd>, to prevent users from being able to interact with it. We set its <kbd>HorizontalAlignment</kbd> property to <kbd>Stretch</kbd>, so that it spans the full width of the column header, regardless of its size, and its <kbd>VerticalAlignment</kbd> property to <kbd>Bottom</kbd> to ensure that it lies at the bottom of the header, leaving space for the column identifier.</p>
<p>We set its left margin to <kbd>-1</kbd>, in order to extend it over the left border of the header, as it already extends over the right border by one pixel. In the <kbd>Triggers</kbd> section of the <kbd>ControlTemplate</kbd>, we added a <kbd>DataTrigger</kbd> object, with a <kbd>MultiBinding</kbd> object that has a reference to our <kbd>DataGridColumnHeaderSelectionMultiConverter</kbd> class set to its <kbd>Converter</kbd> property.</p>
<p>Note that we have two <kbd>Binding</kbd> elements connected to it: one is set to the <kbd>Header</kbd> property of the currently selected <kbd>Column</kbd> object and the other is set directly to the <kbd>Content</kbd> property of the <kbd>DataGridColumnHeader</kbd> class. Each column header will call the converter in turn and if you remember, the column that contains the selected cell will result in the converter returning <kbd>true</kbd>.</p>
<p>When the <kbd>MultiBinding</kbd> object that is connected to this converter returns <kbd>true</kbd>, the <kbd>DataTrigger</kbd> <kbd>Setter</kbd> fills the header foreground and the <kbd>ColorSelectionBar</kbd> rectangle with the <kbd>SelectionBrush</kbd> resource and the background of the header with the <kbd>SelectedBackground</kbd> resource, highlighting the column header of the currently selected cell.</p>
<p>In order to apply this <kbd>ControlTemplate</kbd> object, we'll also need to add a <kbd>Setter</kbd> element into our <kbd>Style</kbd> for the <kbd>DataGridColumnHeader</kbd> class, making sure that the template declaration is before the <kbd>Style</kbd> declaration in the XAML:</p>
<pre><span>&lt;Setter Property="Template" <br/>  Value ="{StaticResource DataGridColumnHeaderControlTemplate}" /&gt;</span> </pre>
<p>As you can see, we have made minimal changes to the two default <kbd>ControlTemplate</kbd> objects, yet we have managed to adapt them to our purposes. In this way, we are able to manipulate the built-in .NET controls, to further extend their original usefulness. Let's see the visual output from this latest addition to our code:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/ce0be1cf-7f18-4517-98ee-9ecfb2dde47b.png"/></span></p>
<p class="CDPAlignLeft CDPAlign"><span>We now have a grid that is starting to look more like a typical spreadsheet application. Let's continue and add cell selection highlights for the users.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emphasizing the Selection</h1>
                </header>
            
            <article>
                
<p>All that is left for us to do now is to implement the selection rectangle and the style for the Select All button in the top left corner of the control. We can accomplish both tasks by adjusting the default <kbd>ControlTemplate</kbd> for the <kbd>DataGrid</kbd> class. Let's break this down into steps. First, we need to add a <kbd>ControlTemplate</kbd> for the Select All button into our <kbd>Resources</kbd> section:</p>
<pre>&lt;ControlTemplate x:Key="SelectAllButtonControlTemplate" <br/>  TargetType="{x:Type Button}"&gt; <br/>  &lt;Border BorderThickness="0,0,1,1" BorderBrush="{StaticResource <br/>    DiagonalBorderGradient}" Background="{StaticResource BackgroundBrush}"&gt; <br/>    &lt;Polygon Fill="#FFB3B3B3" Points="0,12 12,12 12,0" <br/>      HorizontalAlignment="Right" VerticalAlignment="Bottom" <br/>      Stretch="Uniform" Margin="10,3,3,3" /&gt; <br/>  &lt;/Border&gt; <br/>&lt;/ControlTemplate&gt; </pre>
<p>Here, we have another very simple template, where we replace the default definition of a <kbd>Button</kbd> control with a basic triangle. It contains a <kbd>Border</kbd> element, that draws its right and bottom borders with the <kbd>DiagonalBorderGradient</kbd> brush that we added to the spreadsheet control's resources. It also paints the background of the <kbd>Button</kbd> control with our <kbd>BackgroundBrush</kbd> resource.</p>
<p>Within the <kbd>Border</kbd> element, we declare a <kbd>Polygon</kbd> shape, which we fill with a gray brush. Its shape is determined by the values declared in its <kbd>Points</kbd> property, so it begins at <kbd>0,12</kbd>, continues to <kbd>12,12</kbd> , and <kbd>12,0</kbd>, before returning to <kbd>0,12</kbd>. Plotting these values on a graph would show a triangle and that is the shape that this <kbd>Polygon</kbd> element will render.</p>
<p>We align it to the bottom right of the <kbd>Border</kbd> element and set its <kbd>Stretch</kbd> property to <kbd>Uniform</kbd> to ensure that its aspect ratio is maintained throughout any changes of its size. Finally, we set its <kbd>Margin</kbd> property to space it away from the <kbd>Border</kbd> element's edge.</p>
<p>Next, we need to apply the <kbd>SelectAllButtonControlTemplate</kbd> template to the Select All button and add a transparent <kbd>Canvas</kbd> element into the <kbd>ControlTemplate</kbd> for the <kbd>ScrollViewer</kbd> object that appears inside the default <kbd>ControlTemplate</kbd> for the <kbd>DataGrid</kbd> class. Let's extract this from the default template and declare it in our <kbd>Resources</kbd> section too:</p>
<pre>&lt;ControlTemplate x:Key="ScrollViewerControlTemplate" <br/>  TargetType="{x:Type ScrollViewer}"&gt; <br/>  &lt;Grid&gt; <br/>    ... <br/>    &lt;Button Command="ApplicationCommands.SelectAll" <br/>      Focusable="False" Width="26" Height="26" <br/>      Template="{StaticResource SelectAllButtonControlTemplate}" /&gt; <br/>    ... <br/>    &lt;ScrollContentPresenter x:Name="PART_ScrollContentPresenter" ... /&gt; <br/>    &lt;Border Grid.Row="1" Grid.Column="1" ClipToBounds="True" <br/>      BorderThickness="0" IsHitTestVisible="False" Margin="-2"&gt; <br/>      &lt;Canvas Name="SelectionRectangleCanvas" Background="{x:Null}" <br/>        IsHitTestVisible="False" RenderTransformOrigin="0.5,0.5" <br/>        Margin="2" /&gt; <br/>    &lt;/Border&gt; <br/>    &lt;ScrollBar x:Name="PART_VerticalScrollBar" ... /&gt; <br/>    ... <br/>  &lt;/Grid&gt; <br/>&lt;/ControlTemplate&gt; </pre>
<p>We first set a width and height of 26 pixels on the Select All button, in line with the dimensions of our row and column headers. We then apply our <kbd>ControlTemplate</kbd> from the <kbd>Resources</kbd> section to it. We also removed the <kbd>Visibility</kbd> binding from the default template, as we won't be needing that in our example. Note that this button has no action in our example and is purely decorative.</p>
<p>Next, we added the transparent <kbd>Canvas</kbd> control, that will display the selection rectangle, within a <kbd>Border</kbd> element. Note that we must add it after the required <kbd>PART_ScrollContentPresenter</kbd> named part, to ensure that the selection rectangle will appear above the cells in the Z plane. Also, notice that we must wrap it in an invisible <kbd>Border</kbd> element, so that we can clip its bounds. Try removing the <kbd>ClipToBounds</kbd> property and resize the control to be smaller as an experiment to see what happens.</p>
<p>We set the <kbd>Margin</kbd> property on the <kbd>Border</kbd> element to be <kbd>-2</kbd> in all directions, so that it can display the selection rectangle over and just outside the bounds of each cell. We, therefore, need to set the <kbd>Margin</kbd> property on the <kbd>Canvas</kbd> that draws the rectangle to <kbd>2</kbd> in all directions, to compensate for the border's negative margin.</p>
<p>We name the <kbd>Canvas</kbd> element, so that we can access it from the code behind, and set its <kbd>Background</kbd> property to <kbd>null</kbd>, which is slightly cheaper than setting it to <kbd>Transparent</kbd>. We then set the <kbd>IsHitTestVisible</kbd> property to <kbd>False</kbd>, to make it invisible to the users and their mouse cursors and center the origin of the render transform, which we will use to update the position of the <kbd>Canvas</kbd> element each time the containing <kbd>ScrollViewer</kbd> object is moved.</p>
<p class="mce-root"/>
<p>Let's see our simplified <kbd>ControlTemplate</kbd> for the <kbd>DataGrid</kbd> class now:</p>
<pre>&lt;ControlTemplate x:Key="DataGridControlTemplate" <br/>  TargetType="{x:Type DataGrid}"&gt; <br/>  &lt;Border ... &gt; <br/>    &lt;ScrollViewer x:Name="DG_ScrollViewer" Focusable="False" <br/>      CanContentScroll="False" <br/>      Template="{StaticResource ScrollViewerControlTemplate}"&gt; <br/>      &lt;ItemsPresenter <br/>        SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}" /&gt; <br/>    &lt;/ScrollViewer&gt; <br/>  &lt;/Border&gt; <br/>&lt;/ControlTemplate&gt;</pre>
<p>We made a few changes to the default <kbd>ControlTemplate</kbd> for the <kbd>DataGrid</kbd> control. The first was to set the <kbd>CanContentScroll</kbd> property to <kbd>False</kbd> on the <kbd>ScrollViewer</kbd> element named <kbd>DG_ScrollViewer</kbd>, to make it scroll in physical units (pixels) instead of logical units (rows). The only other change was to replace its inline <kbd>ControlTemplate</kbd> object with a reference to the custom template that we added into the <kbd>Resources</kbd> section.</p>
<p>We must also remember to assign this custom <kbd>ControlTemplate</kbd> object to our spreadsheet control. This can be achieved in the class declaration:</p>
<pre>&lt;DataGrid <br/>  x:Class="CompanyName.ApplicationName.Views.Controls.Spreadsheet" ... <br/>  Template="{DynamicResource DataGridControlTemplate}"&gt; <br/>  ... <br/>&lt;/DataGrid&gt; </pre>
<p>Now, let's see our <kbd>Spreadsheet</kbd> control again, with all the latest changes:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/7c7201f5-8745-48c0-8415-b0f3ac0b159e.png"/></span></p>
<p>We can see that the job is nearly complete. We now have the XAML all set up to display the selection rectangle, but we still need to programmatically position and animate it. First, we'll need to attain a reference to the <kbd>Scrollviewer</kbd> from our custom <kbd>DataGrid</kbd> template. </p>
<p>We can achieve this by overriding another method from the <kbd>DataGrid</kbd> base class. The <kbd>OnApplyTemplate</kbd> method is called whenever a <kbd>ControlTemplate</kbd> is applied, so it's an ideal location to access the elements contained within it:</p>
<pre>private ScrollViewer scrollViewer; 
 
... 
 
public override void OnApplyTemplate() 
{ 
  scrollViewer = Template.FindName("DG_ScrollViewer", this) as ScrollViewer; 
} </pre>
<p>In this method, we call the <kbd>FindName</kbd> method on the <kbd>Spreadsheet</kbd> control's template, passing in the name of our <kbd>ScrollViewer</kbd> object and a reference to the spreadsheet, as the templated parent. We then cast the returned object to a <kbd>ScrollViewer</kbd>, using the <kbd>as</kbd> operator keyword, to avoid exceptions being thrown.</p>
<p>Note that as this spreadsheet example is quite long, we have omitted the usual <kbd>null</kbd> checks, with regards to accessing the internal controls from the <kbd>ControlTemplate</kbd> elements. In a real-world application, these checks should always be implemented, as we can never be sure that our required elements will be in the template, because it may have been changed.</p>
<p>Next, we need a reference to the <kbd>Canvas</kbd> panel that we will draw our selection rectangle on:</p>
<pre>private Canvas selectionRectangleCanvas; 
 
... 
 
private void SpreadsheetScrollViewer_ScrollChanged(object sender, <br/>  ScrollChangedEventArgs e) <br/>{ <br/>    if (selectionRectangleCanvas == null) GetCanvasReference(); <br/>} <br/> <br/>private void GetCanvasReference() <br/>{ <br/>    ControlTemplate scrollViewerControlTemplate = scrollViewer.Template; <br/>    selectionRectangleCanvas = scrollViewerControlTemplate.<br/>      FindName("SelectionRectangleCanvas", scrollViewer) as Canvas; <br/>    selectionRectangleCanvas.RenderTransform = new TranslateTransform(); <br/>} </pre>
<p>In the <kbd>SpreadsheetScrollViewer_ScrollChanged</kbd> event handler, we start by checking if the <kbd>selectionRectangleCanvas</kbd> private variable is <kbd>null</kbd>. If it is, we call the <kbd>GetCanvasReference</kbd> method, to attain a reference to it and to assign it to a private member variable.</p>
<p>In the <kbd>GetCanvasReference</kbd> method, we access the <kbd>ControlTemplate</kbd> object from the <kbd>Template</kbd> property of the <kbd>ScrollViewer</kbd> element that we previously stored a reference to. We call the <kbd>FindName</kbd> method on it, passing in the name of our <kbd>Canvas</kbd> object and a reference to the <kbd>ScrollViewer</kbd> element, as its templated parent.</p>
<p>We then assign the returned object, cast to the <kbd>Canvas</kbd> type, to the private <kbd>selectionRectangleCanvas</kbd> member variable and set a new <kbd>TranslateTransform</kbd> object to its <kbd>RenderTransform</kbd> property. We will use this to update the position of the <kbd>Canvas</kbd> element each time the containing <kbd>ScrollViewer</kbd> object's viewport is moved, and this will ensure that the selection rectangle will be scrolled, along with the spreadsheet.</p>
<p>Note that we attain a reference to the <kbd>Canvas</kbd> element from this event handler only in an attempt to shorten this example. A far better solution would be to extend the <kbd>ScrollViewer</kbd> class and declare a <kbd>TemplateChanged</kbd> event, that passed a reference of the new template in a custom <kbd>EventArgs</kbd> class.</p>
<p>We could raise it from an overridden <kbd>OnApplyTemplate</kbd> method, as we did to access our <kbd>ScrollViewer</kbd> reference, and subscribe to it from our <kbd>Spreadsheet</kbd> class. The problem with our current implementation is that the <kbd>ScrollChanged</kbd> event is raised many times and each time, we check if we already have the reference and so a lot of CPU cycles will be wasted when scrolling.</p>
<p>Returning to the current implementation now, let's assign our event handler for the <kbd>ScrollChanged</kbd> event to the <kbd>ScrollViewer</kbd> in our custom template for the <kbd>DataGrid</kbd> class:</p>
<pre><span>&lt;ScrollViewer x:Name="DG_ScrollViewer" ... <br/>  ScrollChanged="SpreadsheetScrollViewer_ScrollChanged"&gt;</span> </pre>
<p>Let's now investigate the code that is used to draw and animate the selection rectangle:</p>
<pre>using System; 
using System.Windows.Media; 
using System.Windows.Media.Animation; 
using System.Windows.Shapes; 
 
... 
 
private Rectangle selectionRectangle; 
private bool isSelectionRectangleInitialized = false; 
 
... 
 
private void UpdateSelectionRectangle(Point startPosition, <br/>  Point endPosition) <br/>{ <br/>  TimeSpan duration = TimeSpan.FromMilliseconds(150); <br/>  if (!isSelectionRectangleInitialized) <br/>    InitializeSelectionRectangle(startPosition, endPosition); <br/>  else <br/>  { <br/>    selectionRectangle.BeginAnimation(WidthProperty, new DoubleAnimation(<br/>      endPosition.X - startPosition.X, duration), HandoffBehavior.Compose); <br/>    selectionRectangle.BeginAnimation(HeightProperty, new DoubleAnimation(<br/>      endPosition.Y - startPosition.Y, duration), HandoffBehavior.Compose); <br/>  } <br/>  TranslateTransform translateTransform = <br/>    selectionRectangle.RenderTransform as TranslateTransform; <br/>  translateTransform.BeginAnimation(TranslateTransform.XProperty, <br/>    new DoubleAnimation(startPosition.X - RowHeaderWidth + <br/>    scrollViewer.HorizontalOffset, duration), HandoffBehavior.Compose); <br/>  translateTransform.BeginAnimation(TranslateTransform.YProperty, <br/>    new DoubleAnimation(startPosition.Y - ColumnHeaderHeight + <br/>    scrollViewer.VerticalOffset, duration), HandoffBehavior.Compose); <br/>} <br/> <br/>private void InitializeSelectionRectangle(Point startPosition, <br/>  Point endPosition) <br/>{ <br/>  selectionRectangle = new Rectangle(); <br/>  selectionRectangle.Width = endPosition.X - startPosition.X; <br/>  selectionRectangle.Height = endPosition.Y - startPosition.Y; <br/>  selectionRectangle.Stroke = <br/>    new SolidColorBrush(Color.FromRgb(33, 115, 70)); <br/>  selectionRectangle.StrokeThickness = 2; <br/>  selectionRectangle.RenderTransform = new TranslateTransform(); <br/>  Canvas.SetTop(selectionRectangle, 0); // row and column header <br/>  Canvas.SetLeft(selectionRectangle, 0); <br/>  selectionRectangleCanvas.Children.Add(selectionRectangle); <br/>  isSelectionRectangleInitialized = true; <br/>} </pre>
<p>In the <kbd>UpdateSelectionRectangle</kbd> method, we first declare a duration of 150 ms to use in our animations and check if the selection rectangle has been initialized or not. If it hasn't, we call the <kbd>InitializeSelectionRectangle</kbd> method, passing the <kbd>startPosition</kbd> and <kbd>endPosition</kbd> input parameters through. Let's examine this method before continuing.</p>
<p>In the <kbd>InitializeSelectionRectangle</kbd> method, we initialize the <kbd>SelectionRectangle</kbd> element, with dimensions calculated from the two <kbd>Point</kbd> input parameters and default values for its stroke. We assign a new <kbd>TranslateTransform</kbd> object to its <kbd>RenderTransform</kbd> property, to enable its position to be manipulated in code.</p>
<p>We then use the <kbd>SetTop</kbd> and <kbd>SetLeft</kbd> Attached Properties of the <kbd>Canvas</kbd> class to position the rectangle in the top left corner of the <kbd>Canvas</kbd> panel, that we added into our custom <kbd>ControlTemplate</kbd> for the <kbd>ScrollViewer</kbd> class.</p>
<p>We end by adding the <kbd>SelectionRectangle</kbd> element into the <kbd>Children</kbd> collection of the <kbd>selectionRectangleCanvas</kbd> panel and setting the <kbd>isSelectionRectangleInitialized</kbd> variable to <kbd>true</kbd>, to ensure that this initialization code is only called once.</p>
<p>Returning to the <kbd>UpdateSelectionRectangle</kbd> method now, if the selection rectangle has already been initialized, then we animate its size, from the size of the previous cell to the size of the newly selected cell, using the <kbd>startPosition</kbd> and <kbd>endPosition</kbd> input parameters.</p>
<p>We call the <kbd>BeginAnimation</kbd> method on the <kbd>SelectionRectangle</kbd> element for both its <kbd>WidthProperty</kbd> and <kbd>HeightProperty</kbd> dependency properties, so that the dimensions of the rectangle will smoothly animate from the size of the previously selected cell to the size of the new one.</p>
<p>Next, we access the <kbd>TranslateTransform</kbd> instance from the <kbd>RenderTransform</kbd> property of the <kbd>SelectionRectangle</kbd> element and call the <kbd>BeginAnimation</kbd> method on it, for both the <kbd>Xproperty</kbd> and <kbd>Yproperty</kbd> Dependency Properties. This is what animates the position of the selection rectangle on the <kbd>Canvas</kbd> that we added into the <kbd>ScrollViewer</kbd> element's template.</p>
<p>To calculate the horizontal position, we subtract the value of the <kbd>RowHeaderWidth</kbd> property, that we set earlier in the XAML class declaration, from the <kbd>X</kbd> property value of the <kbd>startPosition</kbd> input parameter and then add the value of the <kbd>HorizontalOffset</kbd> property of the <kbd>ScrollViewer</kbd> element.</p>
<p>Likewise, the vertical position is calculated from the <kbd>Y</kbd> property value of the <kbd>startPosition</kbd> input parameter, with the value of the <kbd>ColumnHeaderHeight</kbd> property subtracted from it and the value of the <kbd>VerticalOffset</kbd> property of the <kbd>ScrollViewer</kbd> element added to it.</p>
<p>All four animations share the same duration, that we declared at the start, so that they morph the dimensions and position of our selection rectangle in unison. They also all set a <kbd>HandoffBehavior</kbd> value of <kbd>Compose</kbd>, which basically provides smoother joins between consecutive animations. We'll discover more about this in <em><a href="83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml">Chapter 7</a>, Mastering Practical Animations,</em> but for now, we'll keep it simple.</p>
<p>So, our <kbd>UpdateSelectionRectangle</kbd> method is responsible for animating the selection rectangle between the previous and current cell selections, <em>but where is it called from?</em> That's right... we're going to call it from yet another overridden protected base class method.</p>
<p>Looking through the protected base class methods of the <kbd>DataGrid</kbd> class, we find the <kbd>OnSelectedCellsChanged</kbd> method, which is called each time a user selects a new cell in our spreadsheet control, so it's the perfect candidate. Let's take a look at its implementation now:</p>
<pre>protected override void <br/>  OnSelectedCellsChanged(SelectedCellsChangedEventArgs e) <br/>{ <br/>  // base.OnSelectedCellsChanged(e); <br/>  if (e.AddedCells != null &amp;&amp; e.AddedCells.Count == 1) <br/>  { <br/>    DataGridCellInfo cellInfo = e.AddedCells[0]; <br/>    if (!cellInfo.IsValid) return; <br/>    FrameworkElement cellContent = <br/>      cellInfo.Column.GetCellContent(cellInfo.Item); <br/>    if (cellContent == null) return; <br/>    DataGridCell dataGridCell = (DataGridCell)cellContent.Parent; <br/>    if (dataGridCell == null) return; <br/>    Point relativePoint = <br/>      dataGridCell.TransformToAncestor(this).Transform(new Point(0, 0)); <br/>    Point startPosition = <br/>      new Point(relativePoint.X - 3, relativePoint.Y - 3); <br/>    Point endPosition = <br/>      new Point(relativePoint.X + dataGridCell.ActualWidth, <br/>      relativePoint.Y + dataGridCell.ActualHeight); <br/>    UpdateSelectionRectangle(startPosition, endPosition); <br/>  } <br/>}</pre>
<p>Note that the base class version of this method is responsible for raising the <kbd>SelectedCellsChanged</kbd> event, so if we need that to happen, we should call it from this method. If we are ever in doubt if to call the base class version of a method that we're overriding, it's generally safer to do so, as we might lose some required functionality that it provides otherwise. As we do not require this event in this example however, we can safely omit the call to the base class method.</p>
<p>In our overridden <kbd>OnSelectedCellsChanged</kbd> method, we check that the <kbd>AddedCells</kbd> property of the <kbd>SelectedCellsChangedEventArgs</kbd> input parameter contains exactly one item. Note that in this example, it should only ever contain a single item, because we set the <kbd>SelectionMode</kbd> property to <kbd>Single</kbd> on our spreadsheet control, but it is always good practice to validate these things.</p>
<p>We then extract the single <kbd>DataGridCellInfo</kbd> object from the <kbd>AddedCells</kbd> property and return execution from the method if it is invalid. If it is valid, we call the <kbd>GetCellContent</kbd> method on its <kbd>Column</kbd> property, passing in its <kbd>Item</kbd> property, to access the cell content as a <kbd>FrameworkElement</kbd> object. This could benefit from a little more explanation.</p>
<p>The <kbd>Column</kbd> property contains the <kbd>DataGridBoundTemplateColumn</kbd> element that relates to the selected cell and likewise, the <kbd>Item</kbd> property holds the <kbd>DataRow</kbd> object that contains the selected cell. The returned <kbd>FrameworkElement</kbd> object represents the content of the <kbd>DataGridCell</kbd> element, which in our case is a <kbd>ContentPresenter</kbd> object.</p>
<p>Any UI elements that we declare in the <kbd>DataTemplate</kbd> element that is applied to the <kbd>DataGridBoundTemplateColumn</kbd>. The <kbd>CellTemplate</kbd> property can be accessed through this <kbd>ContentPresenter</kbd> object, by walking the visual tree. In our case, that is a simple <kbd>TextBlock</kbd> element. Returning to our code now, if this cell content is <kbd>null</kbd>, we return execution from the method.</p>
<p>If the cell content is valid, we cast its <kbd>Parent</kbd> property value to its actual type of <kbd>DataGridCell</kbd>. If this <kbd>DataGridCell</kbd> object is <kbd>null</kbd>, we also return execution from the method. If it is valid, we call its <kbd>TransformToAncestor</kbd> method, followed by the <kbd>Transform</kbd> method, to find its onscreen position, relative to the spreadsheet control.</p>
<p>We then use the relative position to create the start point, or the top left corner, of the rectangle, by subtracting 3 pixels in each axis. This ensures that the rectangle will sit just outside the cell contents, overlapping it slightly.</p>
<p>Similarly, we also use the relative position to create the endpoint, or the bottom right corner, of the rectangle, by adding the actual dimensions of the <kbd>DataGridCell</kbd> object to it. Finally, we call the <kbd>UpdateSelectionRectangle</kbd> method, to draw the selection rectangle, passing the calculated start and endpoints through.</p>
<p>Now, our selection rectangle is working and smoothly animates from one selected cell to the next. However, on a bigger spreadsheet, you might notice that it won't scroll in line with the spreadsheet itself. This is because there is not yet a connection between its position and the horizontal and vertical offsets of the <kbd>ScrollViewer</kbd> that it is defined inside.</p>
<p>To address this issue, we will need to update the positional information on the <kbd>TranslateTransform</kbd> object, from the <kbd>Canvas</kbd> element that the selection rectangle is drawn on, each time the spreadsheet control is scrolled. Let's see how we do this, by adding further code into our <kbd>SpreadsheetScrollViewer_ScrollChanged</kbd> event handler now:</p>
<pre>private void SpreadsheetScrollViewer_ScrollChanged(object sender, <br/>  ScrollChangedEventArgs e) <br/>{ <br/>  if (selectionRectangleCanvas == null) GetCanvasReference(); <br/>  TranslateTransform selectionRectangleCanvasTransform = <br/>    selectionRectangleCanvas.RenderTransform as TranslateTransform; <br/>  selectionRectangleCanvas.RenderTransform = new TranslateTransform(<br/>    selectionRectangleCanvasTransform.X - e.HorizontalChange, <br/>    selectionRectangleCanvasTransform.Y - e.VerticalChange); <br/>} </pre>
<p>Skipping over the existing code that attained the reference to our selection rectangle <kbd>Canvas</kbd> panel, we access the <kbd>TranslateTransform</kbd> element, that we declared in the <kbd>GetCanvasReference</kbd> method, from its <kbd>RenderTransform</kbd> property. We then create a new <kbd>TranslateTransform</kbd> object, with the values coming from the original one, plus the distance scrolled in either direction, and set it back to the <kbd>RenderTransform</kbd> property.</p>
<p>Note that we have to do this because the <kbd>TranslateTransform</kbd> element is immutable and cannot be altered. Therefore, we need to replace it with a new element instead of just updating its property values. Any attempts to modify it will result in a runtime exception being thrown:</p>
<pre><strong>System.InvalidOperationException: 'Cannot set a property on object 'System.Windows.Media.TranslateTransform' because it is in a read-only state.'</strong></pre>
<p>Let's take a final look at the visual output of our spreadsheet control now:</p>
<p class="CDPAlignCenter CDPAlign"><span><img src="assets/82470a99-ef3b-49b0-b420-274a72fb2aff.png"/></span></p>
<p>Of course, we could continue to improve our spreadsheet control, perhaps by adding event handlers to detect changes to the size of the rows and columns when users resize them and update the selection rectangle accordingly. We could extend the <kbd>Cell</kbd> class, to add style and format properties, to style each cell and format the content.</p>
<p>We could add a formula bar or an alternative information panel to display formulas or further information from the cells when clicked on. We could implement multi-cell selection, or enable users to edit cell contents. But either way, hopefully, this extended example has now provided you with enough understanding to be able to undertake these kinds of advanced projects successfully yourself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we further investigated the built-in controls, paying particular attention to the polymorphic ability to override base class methods in derived classes. We first examined examples from the .NET Framework source code, before moving on to create our own examples that highlight this ability.</p>
<p>We continued, introducing extended examples, to help to fully understand the benefits that can be gained from using this method. Through these examples, we highlighted a number of problems, and learned how to overcome them each in turn, by extending the built-in controls and overriding particular base class methods.</p>
<p>In the next chapter, we will take a thorough look at the WPF animation system and discover how we can utilize it in everyday applications. We'll also find out a number of techniques to fine-tune animations to get that perfect effect and discover how we can build animation functionality right into our application framework.</p>


            </article>

            
        </section>
    </body></html>