<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Vertex Functions</h1>
                
            
            <article>
                
<p class="calibre3">The term shader originates from the fact that Cg has been used mainly to simulate realistic lighting conditions (shadows) on 3D models. Despite this, shaders are now much more than that. They not only define the way the objects are going to look, they can also redefine their shapes entirely. If you want to learn how to manipulate the geometry of a 3D object via shaders, this is the chapter for you.</p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">In this chapter, you will learn the following recipes:</span></span></p>
<ul class="calibre11">
<li class="calibre12"><span><span>Accessing a vertex color in a Surface Shader</span></span></li>
<li class="calibre12"><span><span>Animating vertices in a Surface Shader</span></span></li>
<li class="calibre12"><span><span>Extruding your models</span></span></li>
<li class="calibre12"><span><span>Implementing a snow shader</span></span></li>
<li class="calibre12"><span><span>Implementing a volumetric explosion</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">In</span></span> <a href="part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10">Chapter 2</a>, <em class="calibre14"><span class="calibre6">Creating Your First Shader</span></em><span class="calibre6"><span class="calibre6">, we explained that 3D models are not just a collection of triangles. Each</span></span> vertex <span class="calibre6"><span class="calibre6">can contain data that is essential to render the model itself correctly. This chapter will explore how to access this information in order to use it in a shader. We will also explore in detail how the geometry of an object can be deformed simply using Cg code.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing a vertex color in a Surface Shader</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">Let's begin this chapter by taking a look at how we can access the information of a model's</span></span> vertex <span class="calibre6"><span class="calibre6">using the</span></span> vertex <span class="calibre6"><span class="calibre6">function in a Surface Shader. This will arm us with the knowledge to start utilizing the elements contained within a model's </span></span>vertex<span class="calibre6"><span class="calibre6"> in order to create really useful and visually appealing effects.</span></span></p>
<p class="calibre3">A vertex in a vertex function can return information about itself that we need to be aware of. You can actually retrieve the vertices' normal directions as a float3 value and the position of the vertex as float3, and you can even store color values in each vertex and return that color as float4. This is what we will take a look at in this recipe. We need to see how to store color information and retrieve this stored color information inside each vertex of a Surface Shader.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">In order to write this shader, we need to prepare a few assets. </span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">In order to view the colors of a</span></span> vertex, we need to have a model that has had color applied to its vertices. While you could use Unity to apply colors, you would have to write a tool to allow an individual to apply the colors or write some scripts to achieve the color application.</p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">In the case of this recipe, you can use a 3D modeling tool such as Maya or Blender to apply the colors to our model. There is a model available in the example code provided with the book in the <kbd class="calibre13">Chapter 06 </kbd></span></span>| <span class="calibre6"><span class="calibre6"><kbd class="calibre13">Models</kbd> folder (<kbd class="calibre13">VertexColorObject.fbx</kbd>) that you can obtain at the book's <em class="calibre14"><span class="calibre6">Support</span></em> page at <span class="calibre6"><span class="calibre6"><span class="calibre6"><a href="https://www.packtpub.com/books/content/support" class="calibre10">https://www.packtpub.com/books/content/support</a></span></span></span>.</span></span></p>
<p class="calibre3"><span class="calibre6">The following steps will set us up to create this Vertex Shader:</span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Create a new scene and place the imported model (<kbd class="calibre13">VertexColorObject</kbd>) in the scene.</span></span></li>
<li class="calibre12" value="2"><span><span>Create a new <span>Shader</span> (<kbd class="calibre13">SimpleVertexColor</kbd>) and <span>Material</span> (<kbd class="calibre13">SimpleVertexColorMat</kbd>).</span></span></li>
<li class="calibre12" value="3"><span><span>When completed, assign the shader to the material and then the material to the imported model.</span></span></li>
</ol>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Your scene should now look similar to the following screenshot:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00137.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">With our scene, shader, and material created and ready to go, we can begin to write the code for our shader. Launch the shader by double-clicking on it in the <span class="calibre6"><span class="calibre6">Project</span></span> tab in the Unity editor. Perform the following steps:</span></span></p>
<ol class="calibre15">
<li value="1" class="calibre12"><span><span>As we are creating a very simple shader, we will not need to include any properties in our <kbd class="calibre13"><span><span><span>Properties</span></span></span></kbd></span></span> <span><span>block. We wi</span></span><span><span>ll still include a <kbd class="calibre13">Global Color Tint</kbd>, just to stay consistent with the other shaders in this book. Enter the following code in the</span></span> <span><span><kbd class="calibre13"><span><span><span>Properties</span></span></span></kbd> block of your shader:</span></span></li>
</ol>
<pre class="calibre62"><strong class="calibre1">Properties</strong><br class="title-page-name"/>{<br class="title-page-name"/>  _MainTint("Global Color Tint", Color) = (1,1,1,1)<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12"><span><span>This next step tells Unity that we w</span></span>ill be including a vertex function in our shader:</li>
</ol>
<pre class="calibre62"><span><span>CGPROGRAM<br class="title-page-name"/></span></span><span><span><span>#pragma</span> surface surf Lambert vertex:vert</span></span></pre>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">As usual, if we have included properties in our <kbd class="calibre13">Properties</kbd> block, we must make sure to create a corresponding variable in our <kbd class="calibre13">CGPROGRAM</kbd> statement. Enter the following code just below the <kbd class="calibre13">#pragma</kbd> statement:</li>
</ol>
<pre class="calibre62"><span><span>float4 _MainTint;</span></span></pre>
<ol start="4" class="calibre15">
<li class="calibre12" value="4">We now turn our attention to the <kbd class="calibre13">Input struct</kbd>. We need to add a new variable in order for our <kbd class="calibre13">surf()</kbd> function to access the data given to us by our <kbd class="calibre13">vert()</kbd> function:</li>
</ol>
<pre class="calibre62"><span><span><span>struct</span> Input <br class="title-page-name"/></span></span><span><span>{<br class="title-page-name"/>  </span></span><span><span>float2 uv_MainTex;<br class="title-page-name"/>  </span></span><span><span>float4 vertColor;<br class="title-page-name"/></span></span><span><span>};</span></span></pre>
<ol start="5" class="calibre15">
<li class="calibre12" value="5">Now we can write our simple <kbd class="calibre13">vert()</kbd> function to gain access to the colors stored in each vertex of our mesh:</li>
</ol>
<pre class="calibre62">void vert(inout appdata_full v, out Input o)<br class="title-page-name"/>{<br class="title-page-name"/>  UNITY_INITIALIZE_OUTPUT(Input,o);<br class="title-page-name"/>  o.vertColor = v.color;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li class="calibre12" value="6">Finally, we can use the vertex color data from our <kbd class="calibre13">Input struct</kbd> to be assigned to the <kbd class="calibre13">o.Albedo</kbd> parameters in the built-in <kbd class="calibre13">SurfaceOutput</kbd> struct:</li>
</ol>
<pre class="calibre62"><span><span><span>void</span> surf (Input IN, inout SurfaceOutput o) <br class="title-page-name"/></span></span><span><span>{<br class="title-page-name"/>  </span></span><span><span>o.Albedo = IN.vertColor.rgb * _MainTint.rgb;<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="7" class="calibre15">
<li class="calibre12" value="7">With our code completed, we can now re-enter the Unity editor and let the shader compile. If all goes well, you should see something similar to the following screenshot:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00138.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">Unity provides us with a way to access the</span></span> vertex <span class="calibre6"><span class="calibre6">information of the model to which a shader is attached. This gives us the power to modify things such as the vertices' position and color. With this recipe, we have imported a mesh from Maya (though just about any 3D software application can be used), where</span></span> vertex <span class="calibre6"><span class="calibre6">colors were added to <kbd class="calibre13"><span><span><span>Verts</span></span></span></kbd>. You'll notice that by importing the model, the default material will not display the</span></span> vertex <span class="calibre6"><span class="calibre6">colors. We actually have to write a shader to extract the</span></span> vertex <span class="calibre6"><span class="calibre6">color and display it on the surface of the model. Unity provides us with a lot of built-in functionality when using Surface Shaders, which makes the process of extracting this vertex information quick and efficient.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Our first task is to tell Unity that we will be using a</span></span> vertex <span class="calibre6"><span class="calibre6">function when creating our shader. We do this by adding the <kbd class="calibre13"><span><span><span>vertex:vert</span></span></span></kbd> parameter to the <kbd class="calibre13"><span><span><span>#pragma</span></span></span></kbd> statement of <kbd class="calibre13"><span><span><span>CGPROGRAM</span></span></span></kbd>. This automatically makes Unity look for a</span></span> vertex <span class="calibre6"><span class="calibre6">function named <kbd class="calibre13"><span><span><span>vert()</span></span></span></kbd> when it goes to compile the shader. If it doesn't find one, Unity will throw a compiling error and ask you to add a <kbd class="calibre13"><span><span><span>vert()</span></span></span></kbd> function to your shader.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">This brings us to our next step. We have to actually code the <kbd class="calibre13"><span><span><span>vert()</span></span></span></kbd> function, as seen in <em class="calibre14">step 5</em>. We first use a built-in macro to make sure that the <kbd class="calibre13">0</kbd> variable is initialized to 0 if it doesn't have anything that is a requirement if you are targeting</span></span> DirectX <span class="calibre6"><span class="calibre6">11 or above. </span></span></p>
<div class="packt_infobox">For more information on the macro, as well as all of the other macros that ShaderLab has to offer, check out: <a href="https://docs.unity3d.com/Manual/SL-BuiltinMacros.html" class="calibre31">https://docs.unity3d.com/Manual/SL-BuiltinMacros.html</a>.</div>
<p class="calibre3"><span class="calibre6"><span class="calibre6">By having this function, we can access the built-in data struct called <kbd class="calibre13"><span><span><span>appdata_full</span></span></span></kbd></span></span>. <span class="calibre6"><span class="calibre6">This built-in struct is where the</span></span> vertex <span class="calibre6"><span class="calibre6">information is stored. So, we then extract the</span></span> vertex <span class="calibre6"><span class="calibre6">color information by passing it to our <kbd class="calibre13"><span><span><span>Input</span></span></span> struct</kbd> by adding the code, <kbd class="calibre13"><span><span><span>o.vertColor = v.color</span></span></span></kbd></span></span>. </p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The <kbd class="calibre13"><span><span><span>o</span></span></span></kbd></span></span> <span class="calibre6"><span class="calibre6">variable represents our <kbd class="calibre13"><span><span><span>Input</span></span></span> struct</kbd> and the <span class="calibre6"><span class="calibre6"><span class="calibre6">v</span></span></span> variable is our <kbd class="calibre13"><span><span><span>appdata_full</span></span></span> vertex</kbd> data. In this case, we are simply taking the color information from the <kbd class="calibre13"><span><span><span>appdata_full</span></span></span></kbd> struct and putting it in our <kbd class="calibre13"><span><span><span>Input</span></span></span> struct</kbd>. Once the</span></span> vertex color is in our Input struct, we can use it in our <kbd class="calibre13">surf()</kbd> function. In the case of this recipe, we simply apply the color to the o.Albedo parameter to the built-in <kbd class="calibre13">SurfaceOutput</kbd> struct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">You can also access the fourth component from the <kbd class="calibre13"><span><span><span>vert</span></span></span></kbd> color data. If you notice, the <kbd class="calibre13"><span><span><span>vertColor</span></span></span></kbd> variable we declared in the <kbd class="calibre13"><span><span><span>Input</span></span></span> struct</kbd> is of the <kbd class="calibre13"><span><span><span>float4</span></span></span></kbd> type. This means that we are also passing the alpha value of the</span></span> vertex colors. Knowing this, you can use it to your advantage for the purpose of storing a fourth vertex color to perform effects such as transparency or giving yourself one more mask to blend two textures. It's really up to you and your production to determine if you really need to use the fourth component, but it is worth mentioning here.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Animating vertices in a Surface Shader</h1>
                
            
            <article>
                
<p class="calibre3">Now that we know how to access data on a per-vertex basis, let's expand our knowledge set to include other types of data and the position of a vertex.</p>
<p class="calibre3">Using a vertex function, we can access the position of each vertex in a mesh. This allows us to actually modify each individual vertex while the shader does the processing.</p>
<p class="calibre3">In this recipe, we will create a shader that will allow us to modify the positions of each vertex on a mesh with a sine wave. This technique can be used to create animations for objects such as flags or waves on an ocean.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">Let's gather our assets together so that we can create the code for our Vertex Shader:</span></span></p>
<ol class="calibre15">
<li value="1" class="calibre12"><span><span>Create a new scene and place a plane mesh in the center of the scene (<span>GameObject </span></span></span>| <span><span><span>3D Objects </span></span></span>| <span><span><span>Plane</span>). </span></span></li>
</ol>
<div class="packt_tip">The <kbd class="calibre37">Plane</kbd> object created may seem to be a single quad but, in fact, has 121 verts, which we are going to be moving. Using a quad would provide unexpected results. <span class="calibre27">To check for yourself, select the <kbd class="calibre37">Plane</kbd> object and, under the <span class="calibre27">Plane (Mesh Filter)</span> component, double-click on the <span class="calibre27">Mesh</span> property.</span></div>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Create a new shader (<kbd class="calibre13">VertexAnimation</kbd>) and material (<kbd class="calibre13">VertexAnimationMat</kbd>).</li>
<li value="3" class="calibre12"><span><span>Finally, assign the shader to the material and the material to the plane mesh.</span></span></li>
</ol>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Your scene should look similar to the following screenshot:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00139.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">With our scene ready to go, let's double-click on our newly created shader to open it in the code editor:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Let's begin with our shader and populate the <kbd class="calibre13"><span><span><span>Properties</span></span></span></kbd> block:</span></span></li>
</ol>
<pre class="calibre62"><span><span><span>Properties <br class="title-page-name"/></span></span></span><span><span>{<br class="title-page-name"/>  </span></span><span><span>_MainTex ("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>  </span></span><span><span>_tintAmount ("Tint Amount", Range(0,1)) = 0.5<br class="title-page-name"/>  </span></span><span><span>_ColorA ("Color A", Color) = (1,1,1,1)<br class="title-page-name"/>  </span></span><span><span>_ColorB ("Color B", Color) = (1,1,1,1)<br class="title-page-name"/>  </span></span><span><span>_Speed ("Wave Speed", Range(0.1, 80)) = 5<br class="title-page-name"/>  </span></span><span><span>_Frequency ("Wave Frequency", Range(0, 5)) = 2<br class="title-page-name"/>  </span></span><span><span>_Amplitude ("Wave Amplitude", Range(-1, 1)) = 1<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="2" class="calibre15">
<li class="calibre12" value="2">We now need to tell Unity that we are going to be using a vertex function by adding the following to the <kbd class="calibre13">#pragma</kbd> statement:</li>
</ol>
<pre class="calibre62"><span><span>CGPROGRAM<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>#pragma</span></strong> surface surf Lambert vertex:vert</span></span></pre>
<ol start="3" class="calibre15">
<li class="calibre12" value="3">In order to access the values that have been given to us by our properties, we need to declare a corresponding variable in our <kbd class="calibre13">CGPROGRAM</kbd> block:</li>
</ol>
<pre class="calibre62"><span><span>sampler2D _MainTex;<br class="title-page-name"/></span></span><span><span>float4 _ColorA;<br class="title-page-name"/></span></span><span><span>float4 _ColorB;<br class="title-page-name"/></span></span><span><span>float _tintAmount;<br class="title-page-name"/></span></span><span><span>float _Speed;<br class="title-page-name"/></span></span><span><span>float _Frequency;<br class="title-page-name"/></span></span><span><span>float _Amplitude;<br class="title-page-name"/></span></span><span><span>float _OffsetVal;</span></span></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">We will be using the vertex position modification as a <kbd class="calibre13">vert</kbd> color as well. This will allow us to tint our object:</li>
</ol>
<pre class="calibre62"><span><span><span>struct</span> Input <br class="title-page-name"/></span></span><span><span>{<br class="title-page-name"/>  f</span></span><span><span>loat2 uv_MainTex;<br class="title-page-name"/>  f</span></span><span><span>loat3 vertColor;<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">At this point, we can perform our vertex modification using a sine wave and vertex function. Enter the following code after the <kbd class="calibre13">Input struct</kbd>:</li>
</ol>
<pre class="calibre62">void vert(inout appdata_full v, out Input o)<br class="title-page-name"/>{<br class="title-page-name"/>  UNITY_INITIALIZE_OUTPUT(Input,o);<br class="title-page-name"/>  float time = _Time * _Speed;<br class="title-page-name"/>  float waveValueA = sin(time + v.vertex.x * _Frequency) * _Amplitude;<br class="title-page-name"/><br class="title-page-name"/>  v.vertex.xyz = float3(v.vertex.x, v.vertex.y + waveValueA, v.vertex.z);<br class="title-page-name"/>  v.normal = normalize(float3(v.normal.x + waveValueA, v.normal.y, v.normal.z));<br class="title-page-name"/>  o.vertColor = float3(waveValueA,waveValueA,waveValueA);<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Finally, we complete our shader by performing a <kbd class="calibre13">lerp()</kbd> function between two colors so that we can tint the peaks and valleys of our new mesh, modified by our vertex function:</li>
</ol>
<pre class="calibre62"><span><span><span>void</span> surf (Input IN, inout SurfaceOutput o)<br class="title-page-name"/></span></span><span><span>{<br class="title-page-name"/></span></span><span><span>  half4 c = tex2D (_MainTex, IN.uv_MainTex);<br class="title-page-name"/></span></span><span><span>  float3 tintColor = lerp(_ColorA, _ColorB, IN.vertColor).rgb; <br class="title-page-name"/></span></span><span><span>  o.Albedo = c.rgb * (tintColor * _tintAmount);<br class="title-page-name"/></span></span><span><span>  o.Alpha = c.a;<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="7" class="calibre15">
<li class="calibre12" value="7">After completing the code for your shader, switch back to Unity and let the shader compile. Once compiled, select the <span>Material</span> and assign the <span>Base (RGB)</span> <span>Texture</span> to the <kbd class="calibre13">UV Checker</kbd> material that is included in <kbd class="calibre13">Chapter 6 </kbd>| <kbd class="calibre13">Textures</kbd> folder of this book's example code.</li>
</ol>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">From there, assign <span>Color A</span> and <span>Color B</span> to different colors. After the changes, <span><span>you should see something similar to the following screenshot:</span></span></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00140.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">This particular shader uses the same concept from the last recipe, except that this time, we are modifying the positions of the vertices in the mesh. This is really useful if you don't want to rig up simple objects, such as a flag, and then animate them using a skeleton structure or hierarchy of transforms.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">We simply create a sine wave value using the <kbd class="calibre13"><span><span><span>sin()</span></span></span></kbd> function that is built into the Cg language. After calculating this value, we add it to the <em class="calibre14"><span class="calibre6"><span class="calibre6"><span class="calibre6">y</span></span></span></em> value of each</span></span> vertex <span class="calibre6"><span class="calibre6">position, creating a wave-like effect.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">We also modified the normal on the mesh just to give it more realistic shading based on the sine wave value.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">You will see how easy it is to perform more complex</span></span> vertex <span class="calibre6"><span class="calibre6">effects by utilizing the built-in</span></span> vertex <span class="calibre6"><span class="calibre6">parameters that Surface Shaders give us.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Extruding your models</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">One of the biggest problems in games is repetition. Creating new content is a time-consuming task, and when you have to face thousands of enemies, chances are that they will all look the same. A relatively cheap technique to add variation to your models is using a shader that alters its basic geometry. This recipe will show you a technique called <strong class="calibre5"><span class="calibre6"><span class="calibre6">normal extrusion</span></span></strong>, which can be used to create a chubbier or skinnier version of a model, as shown in the following screenshot of a soldier from the Unity camp demo:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00141.jpeg" class="calibre119"/></div>
<p class="calibre3">For ease of use, I have provided a prefab of the solider in the example code for this book under the <kbd class="calibre13">Chapter 6 </kbd>| <kbd class="calibre13">Prefabs</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">For this recipe, you need to have access to the shader used by the model that you want to alter. Once you have it, we duplicate it so that we can edit it safely. It can be done as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Find the shader your model is using and, once selected, duplicate it by pressing <em class="calibre2"><span>Ctrl </span></em>+ <em class="calibre2"><span>D</span></em>. If it is just using the Standard Shader, as in this example, it is also possible to just create a new Standard Material such as normal, and the Albedo map will automatically transfer over. Either way, rename this new shader <kbd class="calibre13">NormalExtrusion</kbd></span></span>.</li>
<li class="calibre12" value="2"><span><span>Duplicate the original material of the model and assign the cloned shader to it.</span></span></li>
<li class="calibre12" value="3"><span><span>Assign the new material to your model</span></span> (<kbd class="calibre13">NormalExtrusionMat</kbd>) <span><span>and start editing it.</span></span></li>
</ol>
<p class="calibre3"><span class="calibre6"><span class="calibre6">In order for this effect to work, your model should have <strong class="calibre5"><span class="calibre6"><span class="calibre6">normals</span></span></strong>.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">To create this effect, start by modifying the duplicated shader:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Let's start by adding a property to our shader, which will be used to modulate its extrusion. The range presented here goes from <kbd class="calibre13"><span><span><span>-0.0001</span></span></span></kbd> to <kbd class="calibre13"><span><span><span>0.0001</span></span></span></kbd>, but you might have to adjust this according to your own needs:</span></span></li>
</ol>
<pre class="calibre18"><span><span>__Amount ("Extrusion Amount", Range(-0.0001, 0.0001)) = 0</span></span></pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Couple the property with its respective variable:</li>
</ol>
<pre class="calibre62"><span><span>float _Amount;</span></span></pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Change the <kbd class="calibre13">#pragma</kbd> directive so that it now uses a vertex modifier. You can do this by adding <kbd class="calibre13">vertex:function_name</kbd> at the end of it. In our case, we have called the <kbd class="calibre13">vert:</kbd> function:</li>
</ol>
<pre class="calibre62"><span><span><span>#pragma</span> surface surf Standard vertex:vert</span></span></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Add the following vertex modifier:</li>
</ol>
<pre class="calibre62"><span><span><span>void</span> vert (inout appdata_full v) <br class="title-page-name"/>{<br class="title-page-name"/></span></span><span><span>  v.vertex.xyz += v.normal * _Amount;<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">The shader is now ready; you can use the Extrusion Amount slider in the material's <span>Inspector</span> tab to make your model skinnier or chubbier. Also, feel free to create a clone of the material in order to have different extrusion amounts for each character:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00142.jpeg" class="calibre120"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">Surface Shaders work in two steps. In all the previous chapters, we only explored its last one: the</span></span> surface f<span class="calibre6"><span class="calibre6">unction. There is another function that can be used: the</span></span> vertex <span class="calibre6"><span class="calibre6">modifier</span></span><span class="calibre6"><span class="calibre6">. It takes the data structure of a</span></span> vertex <span class="calibre6"><span class="calibre6">(which is usually called <kbd class="calibre13"><span><span><span>appdata_full</span></span></span></kbd></span></span>) <span class="calibre6"><span class="calibre6">and applies a transformation to it. This gives us the freedom to do virtually anything with the geometry of our model. We signal to the</span></span> GPU<span class="calibre6"><span class="calibre6"> that such a function exists by adding <kbd class="calibre13"><span><span><span>vertex:vert</span></span></span></kbd> to the <kbd class="calibre13"><span><span><span>#pragma</span></span></span></kbd> directive of the Surface Shader. You can refer to <a href="part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 7</span></a>, <em class="calibre14"><span class="calibre6">Fragment Shaders and Grab Passes</span></em>, to learn how</span></span> vertex <span class="calibre6"><span class="calibre6">modifiers can be defined in a Vertex and Fragment Shader instead.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">One of the most simple yet effective techniques that can be used to alter the geometry of a model is called normal extrusion. It works by projecting a</span></span> vertex <span class="calibre6"><span class="calibre6">along its normal direction. This is done by the following line of code:</span></span></p>
<pre class="calibre19"><span><span>v.vertex.xyz += v.normal * _Amount;</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The position of a</span></span> vertex <span class="calibre6"><span class="calibre6">is displaced by <kbd class="calibre13"><span><span><span>_Amount</span></span></span></kbd> units toward the</span></span> vertex normal. <span class="calibre6"><span class="calibre6">If <kbd class="calibre13"><span><span><span>_Amount</span></span></span></kbd> gets too high, the results can be quite unpleasant. With smaller values, however, you can add a lot of variation to your models.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">If you have multiple enemies and want each one to have its own <span class="calibre6">weight</span>, you have to create a different material for each one of them. This is necessary as materials are normally shared between models and changing one will change all of them. There are several ways in which you can do this; the quickest one is to create a script that automatically does it for you. The following script, once attached to an object with a <kbd class="calibre13"><span><span><span>Renderer</span></span></span></kbd></span></span>, <span class="calibre6"><span class="calibre6">will duplicate its first material and set the <kbd class="calibre13"><span><span><span>_Amount</span></span></span></kbd> property automatically:</span></span></p>
<pre class="calibre19"><span><span><strong class="calibre1"><span>using</span> </strong>UnityEngine;<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>public class</span></strong> NormalExtruder : MonoBehaviour {<br class="title-page-name"/></span></span><span><span>  [Range(-0.0001f, 0.0001f)]<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>  public float</span></strong> amount = 0;<br class="title-page-name"/></span></span><span><span>  // Use this for initialization<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>  void</span> </strong>Start () <br class="title-page-name"/>  {<br class="title-page-name"/></span></span><span><span>    Material material = GetComponent&lt;Renderer&gt;().sharedMaterial;<br class="title-page-name"/></span></span><span><span>    Material newMaterial = <strong class="calibre1"><span>new</span> </strong>Material(material);<br class="title-page-name"/></span></span><span><span>    newMaterial.SetFloat("_Amount", amount);<br class="title-page-name"/></span></span><span><span>    GetComponent&lt;Renderer&gt;().material = newMaterial;<br class="title-page-name"/></span></span><span><span>  }<br class="title-page-name"/></span></span><span><span>}</span></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding extrusion maps</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">This technique can actually be improved even further. We can add an extra texture (or use the alpha channel of the main one) to indicate the amount of extrusion. This allows for much better control over which parts are raised or lowered. The following code shows you how it is possible to achieve such an effect (the main difference from what we've done before is in bold):</span></span></p>
<pre class="calibre19">Shader "CookbookShaders/Chapter06/Normal Extrusion Map" <br class="title-page-name"/>{<br class="title-page-name"/>  Properties<br class="title-page-name"/>  {<br class="title-page-name"/>    _MainTex("Texture", 2D) = "white" {}<br class="title-page-name"/>    _ExtrusionTex("Extrusion map", 2D) = "white" {}<br class="title-page-name"/>  _ Amount("Extrusion Amount", Range(-0.0001, 0.0001)) = 0<br class="title-page-name"/>  }<br class="title-page-name"/>  SubShader<br class="title-page-name"/>  {<br class="title-page-name"/>    Tags{ "RenderType" = "Opaque" }<br class="title-page-name"/><br class="title-page-name"/>    CGPROGRAM<br class="title-page-name"/>    #pragma surface surf Standard vertex:vert<br class="title-page-name"/>    struct Input <br class="title-page-name"/>    {<br class="title-page-name"/>      float2 uv_MainTex;<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    float _Amount;<br class="title-page-name"/><br class="title-page-name"/>    <strong class="calibre1">sampler2D _ExtrusionTex;</strong><br class="title-page-name"/><strong class="calibre1">    void vert(inout appdata_full v) </strong><br class="title-page-name"/><strong class="calibre1">    {</strong><br class="title-page-name"/><strong class="calibre1">      float4 tex = tex2Dlod (_ExtrusionTex, float4(v.texcoord.xy,0,0));</strong><br class="title-page-name"/><strong class="calibre1">      float extrusion = tex.r * 2 - 1;</strong><br class="title-page-name"/><strong class="calibre1">      v.vertex.xyz += v.normal * _Amount * extrusion;</strong><br class="title-page-name"/><strong class="calibre1">    }<br class="title-page-name"/></strong><br class="title-page-name"/>    sampler2D _MainTex;<br class="title-page-name"/>    void surf(Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>    {<br class="title-page-name"/>      float4 tex = tex2D(_ExtrusionTex, IN.uv_MainTex);<br class="title-page-name"/>      float extrusion = abs(tex.r * 2 - 1);<br class="title-page-name"/><br class="title-page-name"/>      o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb;<br class="title-page-name"/>      o.Albedo = lerp(o.Albedo.rgb, float3(0, 0,0), extrusion * _Amount   <br class="title-page-name"/>                      / 0.0001 * 1.1);<br class="title-page-name"/>    }<br class="title-page-name"/>  ENDCG<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  Fallback "Diffuse"<br class="title-page-name"/>}</pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The red channel of <kbd class="calibre13"><span><span><span>_ExtrusionTex</span></span></span></kbd> is used as a multiplying coefficient for normal extrusion. A value of <kbd class="calibre13">0.5</kbd> leaves the model unaffected; darker or lighter shades are used to extrude vertices inward or outward, respectively. You should note that in order to sample a texture within a</span></span> vertex <span class="calibre6"><span class="calibre6">modifier, <kbd class="calibre13"><span><span><span>tex2Dlod</span></span></span></kbd> should be used instead of <kbd class="calibre13"><span><span><span>tex2D</span></span></span></kbd></span></span>.</p>
<div class="packt_infobox">In shaders, color channels go from zero to one, although sometimes you need to represent negative values as well (such as inward extrusion). When this is the case, treat <kbd class="calibre37">0.5</kbd> as zero; consider having smaller values as negative and higher values as positive. This is exactly what happens with normals, which are usually encoded in RGB textures. The <kbd class="calibre37">UnpackNormal()</kbd> function is used to map a value in the range (0,1) on the range (-1,+1). Mathematically speaking, this is equivalent to <kbd class="calibre37">tex.r * 2 -1</kbd>.</div>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Extrusion maps are perfect for zombifying characters by shrinking the skin to highlight the shape of the bones underneath. The following screenshot shows you how a <span class="calibre6">healthy</span> soldier can be transformed into a corpse using just a shader and extrusion map. Compared to the previous example, you may notice how the clothing is unaffected. The shader used in the following screenshot also darkens the extruded regions to give an even more emaciated look to the soldier:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00143.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a snow shader</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">The simulation of snow has always been a challenge in games. The vast majority of games simply include snow directly in the model's texture so that their tops look white. However, what if one of these objects starts rotating? Snow is not just a lick of paint on a surface; it is a proper accumulation of material and should be treated as such. This recipe shows you how to give a snowy look to your models using just a shader.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">This effect is achieved in two steps. First, white is used for all the triangles facing the sky. Second, their vertices are extruded to simulate the effect of snow accumulation. You can see the result in the following screenshot:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00144.jpeg" class="calibre121"/></div>
<div class="packt_infobox">Keep in mind that this recipe does not aim to create a photorealistic snow effect. It provides a good starting point, but it is up to the artist to create the right textures and find the right parameters to make it fit your game.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">This effect is purely based on shaders. We will need the following:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Create a new shader for the snow effect (<kbd class="calibre13">SnowShader</kbd>).</span></span></li>
<li class="calibre12" value="2"><span><span>Create a new material for the shader (<kbd class="calibre13">SnowMat</kbd>).</span></span></li>
</ol>
<ol start="3" class="calibre15">
<li class="calibre12" value="3"><span><span>Assign the newly created material to the object that you want to be snowy and assign a color so it's easier to tell where the snow is:</span></span></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00145.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">To create a snowy effect, open your shader and make the following changes:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Replace the properties of the shader with the following ones:</span></span></li>
</ol>
<pre class="calibre18">_Color("Main Color", Color) = (1.0,1.0,1.0,1.0)<br class="title-page-name"/>_MainTex("Base (RGB)", 2D) = "white" {}<br class="title-page-name"/>_Bump("Bump", 2D) = "bump" {}<br class="title-page-name"/>_Snow("Level of snow", Range(1, -1)) = 1<br class="title-page-name"/>_SnowColor("Color of snow", Color) = (1.0,1.0,1.0,1.0)<br class="title-page-name"/>_SnowDirection("Direction of snow", Vector) = (0,1,0)<br class="title-page-name"/>_SnowDepth("Depth of snow", Range(0,1)) = 0</pre>
<ol start="2" class="calibre15">
<li class="calibre12" value="2">Complete them with their relative variables:</li>
</ol>
<pre class="calibre18"><strong class="calibre1">sampler2D</strong> _MainTex;<br class="title-page-name"/><strong class="calibre1">sampler2D</strong> _Bump;<br class="title-page-name"/><strong class="calibre1">float</strong> _Snow;<br class="title-page-name"/><strong class="calibre1">float4</strong> _SnowColor;<br class="title-page-name"/><strong class="calibre1">float4</strong> _Color;<br class="title-page-name"/><strong class="calibre1">float4</strong> _SnowDirection;<br class="title-page-name"/><strong class="calibre1">float</strong> _SnowDepth;</pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Replace the <kbd class="calibre13">Input</kbd> structure with the following one:</li>
</ol>
<pre class="calibre18">struct Input <br class="title-page-name"/>{<br class="title-page-name"/>  float2 uv_MainTex;<br class="title-page-name"/>  float2 uv_Bump;<br class="title-page-name"/>  float3 worldNormal;<br class="title-page-name"/>  INTERNAL_DATA<br class="title-page-name"/>};</pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Replace the surface function with the following one. It will color the snowy parts of the model white:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutputStandard o) <br class="title-page-name"/>{<br class="title-page-name"/>  half4 c = tex2D(_MainTex, IN.uv_MainTex);<br class="title-page-name"/><br class="title-page-name"/>  o.Normal = UnpackNormal(tex2D(_Bump, IN.uv_Bump));<br class="title-page-name"/>  <br class="title-page-name"/>  if (dot(WorldNormalVector(IN, o.Normal), _SnowDirection.xyz) <br class="title-page-name"/>      &gt;= _Snow)<br class="title-page-name"/>  {<br class="title-page-name"/>  o.Albedo = _SnowColor.rgb;<br class="title-page-name"/>  }<br class="title-page-name"/>  else<br class="title-page-name"/>  {<br class="title-page-name"/>  o.Albedo = c.rgb * _Color;<br class="title-page-name"/>  }<br class="title-page-name"/>      <br class="title-page-name"/>  o.Alpha = 1;<br class="title-page-name"/>}</pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Configure the <kbd class="calibre13">#pragma</kbd> directive so that it uses vertex modifiers:</li>
</ol>
<pre class="calibre18"><span><span><span>#pragma</span> surface surf Standard vertex:vert</span></span></pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">Add the following vertex modifiers, which extrude the vertices covered in snow:</li>
</ol>
<pre class="calibre18">void vert(inout appdata_full v) <br class="title-page-name"/>{<br class="title-page-name"/>  float4 sn = mul(UNITY_MATRIX_IT_MV, _SnowDirection);<br class="title-page-name"/><br class="title-page-name"/>  if (dot(v.normal, sn.xyz) &gt;= _Snow)<br class="title-page-name"/>  {<br class="title-page-name"/>    v.vertex.xyz += (sn.xyz + v.normal) * _SnowDepth * _Snow;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<ol start="7" class="calibre15">
<li class="calibre12" value="7">You can now use the material's <span><span>Inspector</span></span> tab to select how much of your model is going to be covered and how thick the snow should be:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00146.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">This shader works in two steps:</span></span></p>
<ul class="calibre11">
<li class="calibre12">Coloring the surface</li>
<li class="calibre12">Altering the geometry.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coloring the surface</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">The first step alters the color of the triangles that are facing the sky. It affects all the triangles with a normal direction similar to <kbd class="calibre13"><span><span><span>_SnowDirection</span></span></span></kbd></span></span>. <span class="calibre6"><span class="calibre6">As seen before in <a href="part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08" class="calibre10"><span>Chapter 3</span></a>, <em class="calibre14"><span class="calibre6">Understanding Lighting Models</span></em>, comparing unit vectors can be done using the <strong class="calibre5"><span class="calibre6"><span class="calibre6">dot product</span></span></strong>. When two vectors are orthogonal, their dot product is zero; it is one (or minus one) when they are parallel to each other. The <kbd class="calibre13"><span><span><span>_Snow</span></span></span></kbd> property is used to decide how aligned they should be in order to be considered as facing the sky.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">If you look closely at the</span></span> surface <span class="calibre6"><span class="calibre6">function, you can see that we are not dotting the normal and snow direction directly. This is because they are usually defined in a different space. The snow direction is expressed in world coordinates, while the object normals are usually relative to the model itself. If we rotate the model, its normals will not change, which is not what we want. To fix this, we need to convert the normals from their object coordinates to world coordinates. This is done with the <kbd class="calibre13"><span><span><span>WorldNormalVector()</span></span></span></kbd> function, as seen in the following code:</span></span></p>
<pre class="calibre19"><span><span><strong class="calibre1"><span>if</span> </strong>(dot(WorldNormalVector(IN, o.Normal), _SnowDirection.xyz) &gt;=<br class="title-page-name"/>  _Snow)<br class="title-page-name"/>{<br class="title-page-name"/></span></span><span><span>  o.Albedo = _SnowColor.rgb;<br class="title-page-name"/>}<br class="title-page-name"/></span></span><span><span><span><strong class="calibre1">else<br class="title-page-name"/></strong>{<br class="title-page-name"/></span></span></span><span><span>  o.Albedo = c.rgb * _Color;<br class="title-page-name"/>}</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">This shader simply colors the model white; a more advanced one should initialize the <kbd class="calibre13"><span><span><span>SurfaceOutputStandard</span></span></span></kbd> structure with textures and parameters from a realistic snow material.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Altering the geometry</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">The second effect of this shader alters the geometry to simulate the accumulation of snow. Firstly, we identify which triangles have been colored white by testing the same condition used in the</span></span> surface <span class="calibre6"><span class="calibre6">function. This time, unfortunately, we cannot rely on <kbd class="calibre13"><span><span><span>WorldNormalVector()</span></span></span></kbd> as the <kbd class="calibre13"><span><span><span>SurfaceOutputStandard</span></span></span></kbd> structure is not yet initialized in the</span></span> vertex <span class="calibre6"><span class="calibre6">modifier. We use this other method instead, which converts <kbd class="calibre13"><span><span><span>_SnowDirection</span></span></span></kbd> to object coordinates:</span></span></p>
<pre class="calibre19"><span><span><strong class="calibre1"><span>float4</span> </strong>sn = mul(UNITY_MATRIX_IT_MV, _SnowDirection);</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Then, we can extrude the geometry to simulate the accumulation of snow:</span></span></p>
<pre class="calibre19"><span><span><strong class="calibre1"><span>if</span> </strong>(dot(v.normal, sn.xyz) &gt;= _Snow)<br class="title-page-name"/>{<br class="title-page-name"/></span></span><span><span>    v.vertex.xyz += (sn.xyz + v.normal) * _SnowDepth * _Snow;<br class="title-page-name"/>}</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Once again, this is a very basic effect. You could use a texture map to control the accumulation of snow more precisely or give a peculiar, uneven look.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">If you need high-quality snow effects and props for your game, you can also check these resources on the Unity <span class="calibre6">Asset Store</span>:</span></span></p>
<ul class="calibre11">
<li class="calibre12"><span><span><strong class="calibre1"><span><span>Winter Suite ($30)</span></span></strong>: A much more sophisticated version of the snow shader presented in this recipe can be found at <span><span><span><a href="https://www.assetstore.unity3d.com/en/#!/content/13927" class="calibre10">https://www.assetstore.unity3d.com/en/#!/content/13927</a>.</span></span></span></span></span></li>
<li class="calibre12"><span><span><strong class="calibre1"><span><span>Winter Pack ($60)</span></span></strong>: A very realistic set of props and materials for snowy environments can be found at <span><span><span><a href="https://www.assetstore.unity3d.com/en/#!/content/13316" class="calibre10">https://www.assetstore.unity3d.com/en/#!/content/13316</a>.</span></span></span></span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementing a volumetric explosion</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">The art of game development is a clever trade-off between realism and efficiency. This is particularly true for explosions; they are at the heart of many games, yet the physics behind them is often beyond the computational power of modern machines. Explosions are, essentially, nothing more than very hot balls of gas; hence, the only way to correctly simulate them is by integrating a fluid simulation into your game. As you can imagine, this is unfeasible for a runtime application, and many games simulate them simply with particles. When an object explodes, it is common to simply instantiate fire, smoke, and debris particles so that, together, they can achieve believable results. This approach, unfortunately, is not very realistic and is easy to spot. There is an intermediate technique that can be used to achieve a much more realistic effect: <span class="calibre6"><span class="calibre6">volumetric explosions</span></span>. The idea behind this concept is that explosions are not treated like a bunch of particles; they are evolving 3D objects, not just flat 2D textures.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Getting ready</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">Complete this recipe with the following steps:</span></span></p>
<ol class="calibre15">
<li class="calibre12" value="1"><span><span>Create a new shader for this effect (<kbd class="calibre13">VolumetricExplosion</kbd>).</span></span></li>
<li class="calibre12" value="2"><span><span>Create a new material to host the shader (<kbd class="calibre13">VolumetricExplosionMat</kbd>).</span></span></li>
<li class="calibre12" value="3"><span><span>Attach the material to a sphere. You can create one directly from the editor, navigating to <span><span>GameObject </span></span></span></span>| <span><span><span><span>3D Object </span></span></span></span>| <span><span><span><span>Sphere</span></span></span></span>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00147.jpeg" class="calibre25"/></div>
<div class="packt_infobox">This recipe works well with the standard Unity Sphere, but if you need big explosions, you might need to use a high-poly sphere. In fact, a vertex function can only modify the vertices of a mesh. All the other points will be interpolated using the positions of the nearby vertices. Fewer vertices means a lower resolution for your explosions.</div>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">For this recipe, you will also need a ramp texture that has, in a gradient, all the colors your explosions will have. You can create a texture like the following screenshot using GIMP or Photoshop:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00148.jpeg" class="calibre25"/></div>
<div class="packt_tip">You can find this image (<kbd class="calibre37">explosionRamp</kbd>) in <kbd class="calibre37">Chapter 6 </kbd>| <kbd class="calibre37">Textures</kbd> folder in the example code provided with this book.</div>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Once you have the picture, import it to Unity. Then, from its <span>Inspector</span>, make sure that <span>Filter Mode</span> is set to <span>Bilinear</span> and the <span>Wrap Mode</span> to <span>Clamp</span>. These two settings make sure that the ramp texture is sampled smoothly.</li>
<li value="6" class="calibre12"><span><span>Lastly, you will need a noisy texture. You can search on the internet for freely available</span></span> noise textures. <span><span>The most commonly used ones are generated using <span>Perlin noise.</span><span><span> I have included an example in <kbd class="calibre13">Chapter 6 </kbd></span></span></span></span>| <span><span><span><span><kbd class="calibre13">Textures</kbd> folder for your use:</span></span></span></span></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00149.jpeg" class="calibre25"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How to do it…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">This effect works in two steps: a</span></span> vertex function to change the geometry, and a surface function to give it the right color. The steps are as follows:</p>
<ol class="calibre15">
<li value="1" class="calibre12">Remove the current properties and add the following properties to the shader:</li>
</ol>
<pre class="calibre18">Properties <br class="title-page-name"/>{<br class="title-page-name"/>  _RampTex("Color Ramp", 2D) = "white" {}<br class="title-page-name"/>  _RampOffset("Ramp offset", Range(-0.5,0.5))= 0<br class="title-page-name"/>    <br class="title-page-name"/>  _NoiseTex("Noise Texture", 2D) = "gray" {}<br class="title-page-name"/>  _Period("Period", Range(0,1)) = 0.5<br class="title-page-name"/>    <br class="title-page-name"/>  _Amount("_Amount", Range(0, 1.0)) = 0.1<br class="title-page-name"/>  _ClipRange("ClipRange", Range(0,1)) = 1<br class="title-page-name"/>}</pre>
<ol start="2" class="calibre15">
<li value="2" class="calibre12">Add their relative variables so that the Cg code of the shader can actually access them:</li>
</ol>
<pre class="calibre18"><span><span><strong class="calibre1"><span>sampler2D</span> </strong>_RampTex;<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>half</span> </strong>_RampOffset;<br class="title-page-name"/><br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>sampler2D</span> </strong>_NoiseTex;<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>float</span> </strong>_Period;<br class="title-page-name"/><br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>half</span> </strong>_Amount;<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>half</span> </strong>_ClipRange;</span></span></pre>
<ol start="3" class="calibre15">
<li value="3" class="calibre12">Change the <kbd class="calibre13">Input</kbd> structure so that it receives the UV data of the ramp texture:</li>
</ol>
<pre class="calibre18"><span><span><strong class="calibre1"><span>struct</span> </strong>Input <br class="title-page-name"/>{<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>  float2</span> </strong>uv_NoiseTex;<br class="title-page-name"/></span></span><span><span>};</span></span></pre>
<ol start="4" class="calibre15">
<li value="4" class="calibre12">Add the following vertex function:</li>
</ol>
<pre class="calibre18"><span><span><strong class="calibre1"><span>void</span> </strong>vert(<strong class="calibre1"><span>inout</span> </strong>appdata_full v) {<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>  float3</span> </strong>disp = tex2Dlod(_NoiseTex, <strong class="calibre1"><span>float4</span></strong>(v.texcoord.xy,0,0));<br class="title-page-name"/></span></span><span><span><strong class="calibre1"><span>  float</span> </strong>time = sin(_Time[3] *_Period + disp.r*10);<br class="title-page-name"/></span></span><span><span>  v.vertex.xyz += v.normal * disp.r * _Amount * time;<br class="title-page-name"/></span></span><span><span>}</span></span></pre>
<ol start="5" class="calibre15">
<li value="5" class="calibre12">Add the following surface function:</li>
</ol>
<pre class="calibre18">void surf(Input IN, inout SurfaceOutput o) <br class="title-page-name"/>{<br class="title-page-name"/>  float3 noise = tex2D(_NoiseTex, IN.uv_NoiseTex);<br class="title-page-name"/><br class="title-page-name"/>  float n = saturate(noise.r + _RampOffset);<br class="title-page-name"/><br class="title-page-name"/>  clip(_ClipRange - n);<br class="title-page-name"/><br class="title-page-name"/>  half4 c = tex2D(_RampTex, float2(n,0.5));<br class="title-page-name"/><br class="title-page-name"/>  o.Albedo = c.rgb;<br class="title-page-name"/>  o.Emission = c.rgb*c.a;<br class="title-page-name"/>}</pre>
<ol start="6" class="calibre15">
<li value="6" class="calibre12">We specify the vertex function in the <kbd class="calibre13">#pragma</kbd> directive, adding the <kbd class="calibre13">nolightmap</kbd> parameter to prevent Unity from adding realistic lighting to our explosion:</li>
</ol>
<pre class="calibre18"><span><span><strong class="calibre1"><span>#pragma</span></strong> surface surf Lambert vertex:vert nolightmap</span></span></pre>
<ol start="7" class="calibre15">
<li value="7" class="calibre12"><span><span>T</span></span>he last step is selecting the material and, from its <span>Inspector</span>, attaching the two textures in the relative slots:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00150.jpeg" class="calibre25"/></div>
<ol start="8" class="calibre15">
<li value="8" class="calibre12">This is animated material, meaning that it evolves over time. You can watch the material changing in the editor by clicking on <span>Animated Materials</span> from the <span>Scene</span> window:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00151.jpeg" class="calibre122"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How it works…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">If you are reading this recipe, you should already be familiar with how Surface Shaders and</span></span> vertex <span class="calibre6"><span class="calibre6">modifiers work. The main idea behind this effect is to alter the geometry of the sphere in a seemingly chaotic way, exactly as it happens in a real explosion. The following screenshot shows you what such an explosion will look like inside the editor. You can see that the original mesh has been heavily deformed:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00152.jpeg" class="calibre123"/></div>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The</span></span> vertex <span class="calibre6"><span class="calibre6">function is a variant of the technique called</span></span> normal extrusion i<span class="calibre6"><span class="calibre6">ntroduced in the <em class="calibre14"><span class="calibre6">Extruding your models</span></em> recipe of this chapter. The difference here is that the amount of extrusion is determined both by the time and noise texture.</span></span></p>
<div class="packt_infobox">When you need a random number in Unity, you can rely on the <kbd class="calibre37">Random.Range()</kbd> function. There is no standard way to get random numbers in a shader, so the easiest way is to sample a noise texture.</div>
<p class="calibre3"><span class="calibre6"><span class="calibre6">There is no standard way to do this, so take this as an example only:</span></span></p>
<pre class="calibre19"><span><span><strong class="calibre1"><span>float</span> </strong>time = sin(_Time[3] *_Period + disp.r*10);</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The built-in <kbd class="calibre13"><span><span><span>_Time[3]</span></span></span></kbd> variable is used to get the current time from within the shader, and the red channel of the <kbd class="calibre13"><span><span><span>disp.r</span></span></span></kbd> noise texture is used to make sure that each</span></span> vertex <span class="calibre6"><span class="calibre6">moves independently. The <kbd class="calibre13"><span><span><span>sin()</span></span></span></kbd> function makes the vertices go up and down, simulating the chaotic behavior of an explosion. Then, the normal extrusion takes place:</span></span></p>
<pre class="calibre19"><span><span>v.vertex.xyz += v.normal * disp.r * _Amount * time;</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">You should play with these numbers and variables until you find a pattern of movement that you are happy with.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">The last part of the effect is achieved by the</span></span> surface <span class="calibre6"><span class="calibre6">function. Here, the noise texture is used to sample a random color from the ramp texture. However, there are two more aspects that are worth noting. The first one is the introduction of <kbd class="calibre13"><span><span><span>_RampOffset</span></span></span></kbd></span></span>. <span class="calibre6"><span class="calibre6">Its usage forces the explosion to sample colors from the left or right side of the texture. With positive values, the surface of the explosion tends to show more grey tones—exactly what happens when it is dissolving. You can use <kbd class="calibre13"><span><span><span>_RampOffset</span></span></span></kbd> to determine how much fire or smoke there should be in your explosion. The second aspect introduced in the</span></span> surface <span class="calibre6"><span class="calibre6">function is the usage of <kbd class="calibre13"><span><span><span>clip()</span></span></span></kbd></span></span>. <span class="calibre6"><span class="calibre6">What <kbd class="calibre13"><span><span><span>clip()</span></span></span></kbd> does is it clips (removes) pixels from the rendering pipeline. When invoked with a negative value, the current pixel is not drawn. This effect is controlled by <kbd class="calibre13"><span><span><span>_ClipRange</span></span></span></kbd></span></span>, <span class="calibre6"><span class="calibre6">which determines which pixels of the volumetric explosions are going to be transparent.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">By controlling both <kbd class="calibre13"><span><span><span>_RampOffset</span></span></span></kbd> and <kbd class="calibre13"><span><span><span>_ClipRange</span></span></span></kbd></span></span>, <span class="calibre6"><span class="calibre6">you have full control and can determine how the explosion behaves and dissolves.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">There's more…</h1>
                
            
            <article>
                
<p class="calibre3"><span class="calibre6"><span class="calibre6">The shader presented in this recipe makes a sphere look like an explosion. If you really want to use it, you should couple it with some scripts in order to get the most out of it. The best thing to do is to create an explosion object and make it into a prefab so that you can reuse it every time you need to. You can do this by dragging the sphere back into the <span class="calibre6"><span class="calibre6">Project</span></span> window. Once it is done, you can create as many explosions as you want using the <kbd class="calibre13"><span><span><span>Instantiate()</span></span></span></kbd> function.</span></span></p>
<p class="calibre3"><span class="calibre6"><span class="calibre6">It is worth noticing, however, that all the objects with the same material share the same look. If you have multiple explosions at the same time, they should not use the same material. When you are instantiating a new explosion, you should also duplicate its material. You can do this easily with this piece of code:</span></span></p>
<pre class="calibre19"><span><span>GameObject explosion = Instantiate(explosionPrefab) as GameObject;<br class="title-page-name"/></span></span><span><span>Renderer renderer = explosion.GetComponent&lt;Renderer&gt;();<br class="title-page-name"/></span></span><span><span>Material material = new Material(renderer.sharedMaterial);<br class="title-page-name"/></span></span><span><span>renderer.material = material;</span></span></pre>
<p class="calibre3"><span class="calibre6"><span class="calibre6">Lastly, if you are going to use this shader in a realistic way, you should attach a script to it that changes its size, <kbd class="calibre13"><span><span><span>_RampOffset</span></span></span></kbd>, and <kbd class="calibre13"><span><span><span>_ClipRange</span></span></span></kbd> according to the type of explosion that you want to recreate.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">See also</h1>
                
            
            <article>
                
<ul class="calibre11">
<li class="calibre12"><span><span>Much more can be done to make explosions realistic. The approach presented in this recipe only creates an empty shell; inside it, the explosion is actually empty.</span></span></li>
<li class="calibre12"><span><span>An easy trick to improve this is to create particles inside it. However, you can only go so far with this.</span></span></li>
<li class="calibre12"><span><span>The short movie, <em class="calibre2"><span><span>The Butterfly Effect</span></span></em> (<span><span><span><a href="http://unity3d.com/pages/butterfly" class="calibre10">http://unity3d.com/pages/butterfly</a></span></span></span>), created by <span><span>Unity Technologies</span></span> in collaboration with <span><span>Passion Pictures</span></span> and <span><span>Nvidia</span></span>, is the perfect example.</span></span></li>
<li class="calibre12"><span><span>It is based on the same concept of altering the geometry of a sphere, but it renders it with a technique called <strong class="calibre1"><span><span>volume ray casting</span></span></strong>.</span></span></li>
</ul>
<ul class="calibre11">
<li class="calibre12"><span><span>In a nutshell, it renders the geometry as if it's full. You can see an example in the following screenshot:</span></span></li>
</ul>
<div class="cdpaligncenter"><img src="../images/00153.jpeg" class="calibre25"/></div>
<ul class="calibre11">
<li class="calibre12"><span><span>If you are looking for high-quality explosions, check out <span><span>Pyro</span></span> <span><span>Technix</span></span> (<span><span><span><a href="https://www.assetstore.unity3d.com/en/#!/content/16925" class="calibre10">https://www.assetstore.unity3d.com/en/#!/content/16925</a></span></span></span>) in the Asset Store. It includes volumetric explosions and couples them with realistic shockwaves.</span></span></li>
</ul>


            </article>

            
        </section>
    </body></html>