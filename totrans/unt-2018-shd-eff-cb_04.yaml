- en: Understanding Lighting Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we introduced Surface Shaders and explained how we
    can change physical properties (such as Albedo and Specular) to simulate different
    materials. How does this really work? At the heart of every Surface Shader, there
    is its **lighting model**. It's the function that takes these properties and calculates
    the final shade of each pixel. Unity usually hides this from the developers because
    in order to write a lighting model, you have to understand how light reflects
    and refracts onto surfaces. This chapter will finally show you how lighting models
    work and give you the basics to create your own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom diffuse lighting model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a toon shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Phong Specular type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a BlinnPhong Specular type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Anisotropic Specular type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simulating the way light works is a very challenging and resource-consuming
    task. For many years, video games have used very simple lighting models which,
    despite lacking realism, were very believable. Even if most 3D engines are now
    using physically-based renderers, it is worth exploring some simpler techniques.
    The ones presented in this chapter are reasonably realistic and widely adopted
    on devices with low resources such as mobile phones. Understanding these simple
    lighting models is also essential if you want to create your own.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom diffuse lighting model
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are familiar with Unity 4, you may know that the default shader it provided
    was based on a lighting model called **Lambertian reflectance**. This recipe will
    show you how it is possible to create a shader with a custom lighting model and
    explains the mathematicsinvolved and implementation. The following diagram shows
    the same geometry rendered with a Standard Shader (right) and a diffuse Lambert
    one (left):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Shaders based on Lambertian reflectance are classified as non-photorealistic;
    no object in the real world really looks like this. However, Lambert Shaders are
    still often used in low-poly games as they produce a neat contrast between the
    faces of complex geometries. The lighting model used to calculate the Lambertian
    reflectance is also very efficient, making it perfect for mobile games.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Unity has already provided us with a lighting function that we can use for our
    shaders. It is called the Lambertian lighting model. It is one of the more basic
    and efficient forms of reflectance, which you can find in a lot of games even
    today. As it is already built in the Unity Surface Shader language, we thought
    it best to start with this first and build on it. You can also find an example
    in the Unity reference manual, but we will go into more depth and explain where
    the data is coming from and why it is working the way it is. This will help you
    get a nice grounding in setting up custom lighting models so that we can build
    on this knowledge in the future recipes in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by carrying out the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先执行以下步骤：
- en: Create a new shader and give it a name (`SimpleLambert`).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器并给它命名（`SimpleLambert`）。
- en: Create a new material, give it a name (`SimpleLambertMat`), and assign the new
    shader to its `shader` property.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的材质，给它命名（`SimpleLambertMat`），并将新着色器分配给其 `shader` 属性。
- en: Then, create a sphere object and place it roughly in the center of the scene
    and attach the new material to it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个球体对象，并将其大致放置在场景的中心，并将新材质附加到它上面。
- en: Finally, let's create a directional light to cast some light on our object if
    one isn't created already.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个方向光，如果还没有创建的话，以便照亮我们的物体。
- en: 'When your assets have been set up in Unity, you should have a scene that resembles
    the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在 Unity 中设置好资产后，你应该有一个类似于以下截图的场景：
- en: '![](img/00079.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The Lambertian reflectance can be achieved with the following changes to the
    shader:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对着色器进行以下更改可以实现朗伯反射：
- en: 'Begin by replacing the shader''s `Properties` block with the following :'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先替换着色器的 `Properties` 块，如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since we are removing all of the other properties, remove the `_Glossiness`,
    `_Metallic`, and `_Color` declarations inside of the `SubShader` section.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在移除所有其他属性，请从 `SubShader` 部分中移除 `_Glossiness`、`_Metallic` 和 `_Color` 声明。
- en: 'Change the `#pragma` directive of the shader so that, instead of `Standard`,
    it uses our custom lighting model:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改着色器的 `#pragma` 指令，使其不再使用 `Standard`，而是使用我们自定义的光照模型：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you try to run the script now, it will complain that it doesn't know what
    the `SimpleLambert` lighting model is. We will need to create a function called
    `Lighting`  + the name that we gave here with instructions on how to light the
    object, which we will be writing later on in this recipe. In this case, it would
    be `LightingSimpleLambert`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试运行脚本，它将抱怨它不知道 `SimpleLambert` 光照模型是什么。我们需要创建一个名为 `Lighting` + 我们在这里给出的名称的函数，其中包含如何照亮物体的说明，我们将在本食谱的后面部分编写。在这种情况下，它将是
    `LightingSimpleLambert`。
- en: 'Use a very simple surface function, which just samples the texture according
    to its UV data:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个非常简单的表面函数，它只是根据其 UV 数据采样纹理：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a function called `LightingSimpleLambert()` that will contain the following
    code for the Lambertian reflectance:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `LightingSimpleLambert()` 的函数，该函数将包含以下代码以实现朗伯反射：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save your script and return to the Unity editor. You should notice that it
    looks somewhat different than what was there before:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到 Unity 编辑器。你应该注意到它看起来与之前有些不同：
- en: '![](img/00080.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: 'The effect is even easier to see if we use the cylinders we used in the previous
    chapter, [Chapter 3](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08), *Surface
    Shaders and Texture Mapping*:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用上一章[第3章](part0063.html#1S2JE0-e8c76c858d514bc3b1668fda96f8fa08)，“表面着色器和纹理映射”中使用的圆柱体，效果甚至更容易看到：
- en: '![](img/00081.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As previously seen in [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08),
    *Creating Your First Shader*, the `#pragma` directive is used to specify which
    surface function to use. Choosing a different lighting model works in a similar
    fashion: `SimpleLambert` forces Cg to look for a function called `LightingSimpleLambert()`.
    Note the `Lighting` at the beginning, which is omitted in the directive.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第2章](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08)，“创建您的第一个着色器”中，`#pragma`
    指令用于指定要使用哪个表面函数。选择不同的光照模型以类似的方式工作：`SimpleLambert` 强制 Cg 寻找名为 `LightingSimpleLambert()`
    的函数。注意开头的 `Lighting`，在指令中省略了它。
- en: 'The `Lighting` function takes three parameters: the *surface output* (which
    contains the physical properties such as the albedo and transparency), the *direction*
    the light is coming from, and its *attenuation*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lighting` 函数接受三个参数：*表面输出*（其中包含物理属性，如反射率和透明度）、光线来的*方向*以及其*衰减*。'
- en: 'According to Lambertian reflectance, the amount of light a surface reflects
    depends on the angle between the incident light and surface normal. If you have
    played pool billiards, you are surely familiar with this concept; the direction
    of a ball depends on its incident angle against the wall. If you hit a wall at
    a 90 degree angle, the ball will come back at you; if you hit it with a very low
    angle, its direction will be mostly unchanged. The Lambertian model makes the
    same assumption; if the light hits a triangle at a 90 degree angle, all the light
    gets reflected back. The lower the angle, the less light is reflected back to
    you. This concept is shown in the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据朗伯反射定律，一个表面反射的光量取决于入射光与表面法线之间的角度。如果你玩过台球，你一定熟悉这个概念；球的方向取决于其与墙壁的入射角度。如果你以90度角击打墙壁，球会反弹回来；如果你以非常低的角度击打它，其方向基本不会改变。朗伯模型做出了相同的假设；如果光线以90度角击中三角形，所有光线都会被反射回去。角度越低，反射回你的光线就越少。这一概念在以下图中展示：
- en: '![](img/00082.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00082.jpeg)'
- en: This simple concept has to be translated into a mathematical form. In vector
    algebra, the angle between two unit vectors can be calculated via an operator
    called **dot product**. When the dot product is equal to zero, two vectors are
    orthogonal, which means that they make a 90-degree angle. When it is equal to
    one (or minus one), they are parallel to each other. Cg has a function called
    `dot()`, which implements the dot product extremely efficiently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单概念必须被转换成数学形式。在向量代数中，两个单位向量之间的角度可以通过一个称为**点积**的运算符来计算。当点积等于零时，两个向量是正交的，这意味着它们形成一个90度的角。当它等于一（或负一）时，它们是相互平行的。Cg有一个名为`dot()`的函数，它实现了点积的高效计算。
- en: 'The following diagram shows a light source (sun) shining on a complex surface.
    **L** indicates the light direction (called `lightDir` in the shader) and **N**
    is the normal to the surface. The light is reflected with the same angle that
    it hits the surface with:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了一个光源（太阳）照射在复杂表面上的情况。**L**表示光线方向（在着色器中称为`lightDir`）和**N**是表面的法线。光线以与击中表面的相同角度被反射：
- en: '![](img/00083.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00083.jpeg)'
- en: For more information on normals and what they mean mathematically check out: [https://en.wikipedia.org/wiki/Normal_(geometry)](https://en.wikipedia.org/wiki/Normal_(geometry))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于法线和它们在数学上的含义的信息，请查看：[https://en.wikipedia.org/wiki/Normal_(geometry)](https://en.wikipedia.org/wiki/Normal_(geometry))
- en: 'Lambertian reflectance simply uses the `NdotL` dot product as a multiplicative
    coefficient for the intensity of light:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 朗伯反射定律简单地将`NdotL`点积作为光强度的乘法系数：
- en: '![](img/00084.gif)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00084.gif)'
- en: When *N* and *L* are parallel, all the light is reflected back to the source,
    causing the geometry to appear brighter. The `_LightColor0` variable contains
    the color of the light that is calculated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当**N**和**L**平行时，所有光线都会反射回光源，导致几何体看起来更亮。`_LightColor0`变量包含计算出的光线颜色。
- en: Prior to Unity 5, the intensity of the lights was different. If you are using
    an old diffuse shader based on the Lambertian model, you may notice that `NdotL` is
    multiplied by two: `(NdotL * atten * 2)`, rather than `(NdotL * atten)`. If you
    are importing a custom shader from Unity 4, you will need to correct this manually.
    Legacy Shaders, however, have already been designed taking this aspect into account.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 5之前，光线的强度是不同的。如果你使用基于朗伯模型的旧漫反射着色器，你可能注意到`NdotL`被乘以了两个：`(NdotL * atten
    * 2)`，而不是`(NdotL * atten)`。如果你从Unity 4导入自定义着色器，你需要手动进行修正。然而，遗留的着色器已经考虑到这一方面。
- en: When the dot product is negative, the light is coming from the opposite side
    of the triangle. This is not a problem for opaque geometries as triangles that
    are not facing the camera frontally are culled (discarded) and not rendered.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当点积为负时，光线来自三角形的对面。对于不透明几何体来说这不是问题，因为不是正对相机的前面的三角形会被裁剪（丢弃）并且不会被渲染。
- en: This basic Lambert is a great starting point when you are prototyping your shaders
    as you can get a lot accomplished in terms of writing the core functionality of
    the shader while not having to worry about the basic `Lighting` functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正在原型化你的着色器时，这个基本朗伯模型是一个很好的起点，因为你可以在不担心基本`Lighting`函数的情况下，完成很多关于编写着色器核心功能的工作。
- en: Unity has provided us with a lighting model that has already taken the task
    of creating a Lambert lighting for you. If you look at the `UnityCG.cginc` file
    found in your Unity's installation directory under the `Data` folder, you will
    notice that you have Lambert and BlinnPhong lighting models available for you
    to use. The moment you compile your shader with `#pragma surface surf Lambert`,
    you are telling the shader to utilize Unity's implementation of the Lambert `Lighting`
    function in the `UnityCG.cginc` file so that you don't have to write that code
    over and over again. We will explore how the BlinnPhong model works later in this
    chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Creating a toon shader
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most used effects in games is **toon shading**, which is also known
    as **celluloid** (**CEL**) shading. It is a non-photorealistic rendering technique
    that makes 3D models appear flat. Many games use it to give the illusion that
    the graphics are being hand-drawn rather than being 3D modeled. You can see, in
    the following diagram, a sphere rendered with a toon Shader (left) and a Standard
    Shader (right):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Achieving this effect using just surface functions is not impossible, but it
    would be extremely expensive and time consuming. The surface function, in fact,
    only works on the properties of the material, not its actual lighting condition.
    As toon shading requires us to change the way light reflects, we need to create
    our custom lighting model instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this recipe by creating a shader and its material and importing
    a special texture, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new shader; in this example, we will duplicate the one made
    in the previous recipe by selecting it in the Project tab and then hit *Ctrl *+ *D*.
    We will change the name of this new `shader` to `ToonShader`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can rename an object in the Project window by single-clicking on the name.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Create a new material for the shader (`ToonShaderMat`) and attach it to a 3D
    model. Toon shading works best on curved surfaces.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This recipe requires an additional texture called a **ramp map**,which will
    be used to dictate when we want to use certain colors depending on the shade received:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'This book has an example texture in `Chapter 4` | `Textures` folder. If you
    decide to import your own, it is important that you select your next texture and,
    from the Inspector tab, change the ramp map''s Wrap Mode to Clamp. If you want
    the edges between the colors to be sharp, the Filter Mode should also be set to
    Point:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: The example project included with this book already has this step completed
    in the `Assets `| `Chapter 4 `| `Texture `| `ToonRamp` file, but it is a good
    idea to verify that this is the case before moving forward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The toon aesthetic can be achieved with the following changes to the shader:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new property for a texture called `_RampTex`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add its relative variable in the `CGPROGRAM` section:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change the `#pragma` directive so that it points to a function called `LightingToon()`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`#pragma`指令，使其指向名为`LightingToon()`的函数：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the `LightingSimpleLambert` function with the following function instead:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LightingSimpleLambert`函数替换为以下函数：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the script, open up the `ToonShaderMat`, and assign the `Ramp` property
    to your ramp map. If all goes well, you should see something like the following
    in your scene:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，打开`ToonShaderMat`，并将`Ramp`属性分配给你的渐变图。如果一切顺利，你应该能在场景中看到以下效果：
- en: '![](img/00088.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: This effect may be modified by the lighting in the scene. You can change the
    illumination of the scene by going to Window | Lighting | Settings and changing
    the Environment | Environment Lighting | Intensity Multiplier property to `0`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果可能会受到场景中光照的影响。你可以通过转到窗口 | 光照 | 设置，并更改环境 | 环境光照 | 强度乘数属性为`0`来改变场景的照明。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main characteristic of toon shading is the way the light is rendered; surfaces
    are not shaded uniformly. To achieve this effect, we need a ramp map. Its purpose
    is to remap the Lambertian light intensity `NdotL` to another value. Using a ramp
    map without a gradient, we can force the lighting to be rendered in steps. The
    following diagram shows how the ramp map is used to correct the light intensity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 卡通着色的主要特征是光照的渲染方式；表面不是均匀着色。为了实现这种效果，我们需要一个渐变图。它的目的是将Lambertian光照强度`NdotL`重新映射到另一个值。使用没有渐变的渐变图，我们可以强制光照以步骤的形式渲染。以下图表显示了如何使用渐变图来校正光照强度：
- en: '![](img/00089.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are many different ways whereby you can achieve a toon shading effect.
    Using different ramps can produce dramatic changes in the way your models look,
    so you should experiment in order to find the best one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的方法可以实现卡通着色效果。使用不同的渐变图可以显著改变模型的外观，因此你应该进行实验以找到最佳方案。
- en: 'An alternative to ramp textures is to **snap** the light intensity `NdotL`
    so that it can only assume a certain number of values equidistantly sampled from
    `0` to `1`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与渐变纹理的替代方案是**固定**光照强度`NdotL`，使其只能假设从`0`到`1`等距采样的特定数值：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To snap a number we first multiply `NdotL` by the `_CelShadingLevels` variable, 
    round the result to an integer through the `floor` function, and then divides
    it back. This rounding is done by the `floor` function which will effectively
    remove the decimal point from a number. By doing this, the `cel` quantity is forced
    to assume one of the `_CelShadingLevels` equidistant values from `0` to `1`. This
    removes the need for a ramp texture and makes all the color steps of the same
    size. If you are going for this implementation, remember to add a property called
    `_CelShadingLevels` to your shader. You can find an example of this in the example
    code for this chapter. Try dragging the Levels property to see how it affects
    how the screenshot is shown:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数字固定，我们首先将`NdotL`乘以`_CelShadingLevels`变量，通过`floor`函数将结果四舍五入到整数，然后再除以它。这种舍入是通过`floor`函数完成的，它将有效地从数字中去除小数点。通过这样做，`cel`数量被迫采用从`0`到`1`的`_CelShadingLevels`等距值之一。这消除了对渐变纹理的需求，并使所有颜色步骤的大小相同。如果你正在寻求这种实现方式，请记住在你的着色器中添加一个名为`_CelShadingLevels`的属性。你可以在本章的示例代码中找到一个例子。尝试拖动级别属性，看看它如何影响截图的显示：
- en: '![](img/00090.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Creating a Phong Specular type
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Phong高光类型
- en: The specularity of an object surface simply describes how shiny it is. These
    types of effects are often referred to as view-dependent effects in the shader
    world. This is because, in order to achieve a realistic Specular effect in your
    shaders, you need to include the direction of the camera or the user facing the
    object's surface. The most basic and performance-friendly Specular type is the
    Phong Specular effect. It is the calculation of the light direction reflecting
    off of the surface compared to the user's view direction. It is a very common
    Specular model used in many applications, from games to movies. While it isn't
    the most realistic in terms of accurately modeling the reflected Specular, it
    gives a great approximation of what is expected of shininess that performs well
    in most situations. Additionally, if your object is further away from the camera
    and there is no need for a very accurate Specular, this is a great way to provide
    a Specular effect to your shaders.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 物体表面的光泽度简单描述了它有多亮。这类效果在着色器世界中通常被称为视依赖效果。这是因为，为了在着色器中实现逼真的镜面反射效果，你需要包含相机或用户面对物体表面的方向。最基本的、性能友好的镜面反射类型是Phong镜面反射效果。它是计算光线从表面反射回来的方向与用户的视图方向相比的结果。它是在许多应用中非常常见的镜面反射模型，从游戏到电影。虽然它不是在准确模拟反射镜面方面最逼真的，但它提供了对预期光泽度的良好近似，在大多数情况下表现良好。此外，如果你的物体离相机更远，并且不需要非常精确的镜面反射，这是一种为着色器提供镜面反射效果的好方法。
- en: In this recipe, we will be covering how to implement the per-vertex version
    of the shader and also the per-pixel version using some new parameters in the
    Surface Shader's `Input` struct. We will see the difference and discuss when and
    why to use these two different implementations for different situations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将介绍如何实现着色器的逐顶点版本以及使用表面着色器`Input`结构中的新参数实现的逐像素版本。我们将看到这两种不同实现之间的差异，并讨论在不同情况下何时以及为什么使用这些不同的实现。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To start with this recipe, perform the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个食谱，请执行以下步骤：
- en: Create a new shader (`Phong`), material(`PhongMat`), and a new scene with a
    sphere in it with a Plane underneath it (GameObject | 3D Objects | Plane).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的着色器（`Phong`）、材质（`PhongMat`），以及一个包含球体和其下方的平面（GameObject | 3D Objects |
    Plane）的新场景。
- en: 'Attach the shader to the material and the material to the object. To finish
    off your new scene, create a new directional light if one is not there already,
    so that you can see your Specular effect as you code it:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将着色器附加到材质上，并将材质附加到物体上。为了完成你的新场景，如果还没有，创建一个新的方向光，这样你就可以在编写代码时看到你的镜面反射效果：
- en: '![](img/00091.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to create a Phong lighting model:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建Phong光照模型：
- en: 'You might be seeing a pattern at this point, but we always like to start out
    with our most basic part of the shader writing process: the creation of properties.
    So, let''s remove all of the current properties with their definitions in the
    `SubShader` block and then add the following properties to the shader:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经看到了一个模式，但我们总是喜欢从着色器编写过程的最基本部分开始：属性的创建。因此，让我们从`SubShader`块中移除所有当前属性及其定义，然后添加以下属性到着色器中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then have to make sure to add the corresponding variables to our `CGPROGRAM`
    block in our `SubShader{}` block:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保将相应的变量添加到我们的`SubShader{}`块中的`CGPROGRAM`块中：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have to add our custom lighting model so that we can compute our own
    Phong Specular. Don''t worry if it doesn''t make sense at this point; we will
    cover each line of code in the *How it works...* section of this recipe. Add the
    following code to the shader''s `SubShader{}` function:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须添加我们的自定义光照模型，以便我们可以计算自己的Phong镜面反射。如果现在还不理解，请不要担心；我们将在本食谱的*如何工作...*部分中逐行解释代码。将以下代码添加到着色器的`SubShader{}`函数中：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we have to tell the `CGPROGRAM` block that it needs to use our custom
    Lighting function instead of one of the built-in ones. We do this by changing
    the `#pragma` statement to the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须告诉`CGPROGRAM`块它需要使用我们的自定义光照函数而不是内置函数之一。我们通过将`#pragma`语句更改为以下内容来实现这一点：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s update the `surf` function to the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新`surf`函数为以下内容：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot demonstrates the result of our custom Phong lighting
    model using our own custom reflection vector:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图展示了我们使用自定义反射向量的自定义Phong光照模型的结果：
- en: '![](img/00092.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: Try changing the Specular Power property and notice the effect that you see.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break down the Lighting function by itself, as the rest of the shader
    should be pretty familiar to you at this point.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipes, we have used a Lighting function that provided only
    the light direction, `lightDir`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Unity comes with a set of Lighting functions that you can use, including one
    that provides the view direction, `viewDir`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out how to write your own custom lighting mode refer to the following
    table replacing NameYouChoose with the lighting function name you gave in the
    `#pragma` statement or go to [http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html](http://docs.unity3d.com/Documentation/Components/SL-SurfaceShaderLighting.html) for
    more details:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '| **Not view-dependent** | `` `half4 LightingNameYouChoose` (`SurfaceOutput
    s`, `half3` `lightDir`, `half atten` ``); |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| **View-dependent** | `half4 LightingNameYouChoose (SurfaceOutput s, half3
    lightDir, half3 viewDir, half atten);` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: 'In our case, we are using a Specular shader, so we need to have the view-dependent
    `Lighting` function structure. We have to write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will tell the shader that we want to create our own view-dependent shader.
    Always make sure that your Lighting function name is the same in your `Lighting`
    function declaration and the `#pragma` statement, or Unity will not be able to
    find your lighting model.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The components that play a role in the `Phong` model are described in the following
    image. We have the light direction **L** (coupled with its perfect reflection
    **R**) and normal direction **N**. They have all been encountered before in the
    Lambertian model, with the exception of **V**, which is the **view direction**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: 'The `Phong` model assumes that the final light intensity of a reflective surface
    is given by two components, its diffuse color, and Specular value, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.gif)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'The diffuse component *D* remains unchanged from the Lambertian model:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.gif)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: 'The Specular component *S* is defined as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.gif)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'Here, *p* is the Specular power defined as `_SpecPower` in the shader. The
    only unknown parameter is *R*, which is the reflection of *L* according to *N*.
    In vector algebra, this can be calculated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.gif)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly what is calculated in the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This has the effect of bending the normal towards the light; as a vertex, normal
    is pointing away from the light, it is forced to look at the light. Refer to the
    following diagram for a more visual representation. The script that produces this
    debug effect is included in this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram displays the final result of our Phong Specular calculation
    isolated in the shader:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Creating a BlinnPhong Specular type
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Blinn** is another more efficient way of calculating and estimating specularity.
    It is done by getting the half vector from the view direction and light direction.
    It was brought into the world of Cg by Jim Blinn. He found that it was much more
    efficient to just get the half vector instead of calculating our own reflection
    vectors. It cut down on the code and processing time. If you actually look at
    the built-in BlinnPhong lighting model included in the `UnityCG.cginc` file, you
    will notice that it is using the half vector as well, hence it is named BlinnPhong.
    It is just a simpler version of the full Phong calculation.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with this recipe, perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, instead of creating a whole new scene, let''s just use the objects
    and scene that we have by using File | Save Scene As..., and create a new shader
    (BlinnPhong) and material (`BlinnPhongMat`):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Once you have a new shader, double-click on it to launch your IDE of choice
    so that you can start editing your shader.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to create a BlinnPhong lighting model:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s remove all of the current properties with their definitions in
    the `SubShader` block. Then we need to add our own properties to the `Properties`
    block so that we can control the look of the Specular highlight:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we need to make sure that we have created the corresponding variables
    in our `CGPROGRAM` block so that we can access the data from our `Properties`
    block, in our subshader:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time to create our custom lighting model that will process our Diffuse
    and Specular calculations. The code is as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then update the `surf` function to the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To complete our shader, we will need to tell our CGPROGRAM block to use our
    custom lighting model rather than a built-in one by modifying the `#pragma` statement
    with the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot demonstrates the results of our BlinnPhong lighting
    model:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The BlinnPhong Specular is almost exactly like the Phong Specular, except that
    it is more efficient because it uses less code to achieve almost the same effect.
    Before the introduction of physically-based rendering, this approach was the default
    choice for Specular reflection in Unity 4.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculating the reflection vector **R** is generally expensive. The BlinnPhong
    Specular replaces it with the half vector **H** between the view direction **V**
    and light direction **L**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Instead of calculating our own reflection vector, we are simply going to get
    the vector halfway between the view direction and light direction, basically simulating
    the reflection vector. It has actually been found that this approach is more physically
    accurate than the last approach, but we thought it necessary to show you all the
    possibilities:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'According to vector algebra, the half vector can be calculated as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.gif)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Here |V+L| is the length of the vector V+L. In Cg, we simply need to add the
    view direction and light direction together and then normalize the result to a
    unity vector:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, we simply need to dot the vertex normal with this new half vector to get
    our main Specular value. After this, we just take it to a power of `_SpecPower`
    and multiply it by the Specular color variable. It's much lighter on the code
    and math, but still gives us a nice Specular highlight that will work for many
    real-time situations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The light models seen in this chapter are extremely simple; no real material
    is perfectly matte or perfectly specular. Moreover, it is not uncommon for complex
    materials such as clothing, wood, and skin to require knowledge of how light scatters
    in the layers beneath the surface. Use the following table to recap the different
    lighting models encountered so far:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '| **Technique** | **Type** | **Light Intensity (I)** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| Lambertian | Diffuse | ![](img/00105.gif) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `Phong` | Specular | ![](img/00106.gif)![](img/00107.gif) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| BlinnPhong | Specular | ![](img/00108.gif)![](img/00109.gif) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: 'There are other interesting models such as the Oren-Nayar lighting model for
    rough surfaces: [https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model](https://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Anisotropic Specular type
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Anisotropic** is a type of Specular or reflection that simulates the directionality
    of grooves in a surface and modifies/stretches the Specular in the perpendicular
    direction. It is very useful when you want to simulate brushed metals, not a metal
    with a clear, smooth, and polished surface. Imagine the Specular that you see
    when you look at the data side of a CD or DVD or the way Specular is shaped at
    the bottom of a pot or pan. You will notice that if you carefully examine the
    surface, there is a direction to the grooves, usually in the way the metal was
    brushed. When you apply a Specular to this surface, you get a Specular stretched
    in the perpendicular direction.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe will introduce you to the concept of augmenting your Specular highlights
    to achieve different types of brushed surfaces. In future recipes, we will look
    at the ways in which we can use the concepts of this recipe to achieve other effects,
    such as stretched reflections and hair, but here, you are going to learn the fundamentals
    of the technique first. We will be using this shader as a reference for our own
    custom Anisotropic Shader:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader](http://wiki.unity3d.com/index.php?title=Anisotropic_Highlight_Shader).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows examples of different types of Specular effects
    that you can achieve using Anisotropic Shaders in Unity:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.gif)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this recipe by creating a shader, its material, and some lights
    for our scene:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene with some objects and lights so that we can visually debug
    our shader. In this case, we will be using some capsules, a sphere, and a cylinder.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，其中包含一些对象和光源，以便我们可以直观地调试我们的着色器。在这种情况下，我们将使用一些胶囊、一个球体和一个圆柱体。
- en: 'Then create a new shader and material, and hook them up to your objects:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的着色器和材质，并将它们连接到您的对象上：
- en: '![](img/00111.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.jpeg)'
- en: Lastly, we will need some sort of normal map that will indicate the directionality
    of our Anisotropic Specular highlight.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一种类型的法线图，以指示我们的各向异性高光的方向性。
- en: 'The following screenshot shows the Anisotropy normal map we will be using for
    this recipe. It is available from this book''s support page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了我们将用于此菜谱的各向异性法线图。它可以从本书的支持页面[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)获取：
- en: '![](img/00112.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00112.jpeg)'
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an Anisotropic effect, we need to make the following changes to the
    shader previously created:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建各向异性效果，我们需要对之前创建的着色器进行以下更改：
- en: 'We first need to remove the old properties and then add the properties that
    we are going to need for our shader. These will allow a lot of artistic control
    over the final appearance of the surface:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要删除旧属性，然后添加我们将需要用于着色器的属性。这些将允许对表面最终外观进行大量艺术控制：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We then need to make the connection between our `Properties` block and
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在`Properties`块和
- en: 'our `SubShader{}` block so that we can use the data being provided by the `Properties`
    block:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`SubShader{}`块，以便我们可以使用`Properties`块提供的数据：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can create our `Lighting` function that will produce the correct Anisotropic
    effect on our surface. We will use the following code for this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的`Lighting`函数，该函数将在我们的表面上产生正确的各向异性效果。我们将使用以下代码来完成此操作：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to use this new `Lighting` function, we need to tell the subshader''s
    `#pragma` statement to look for it instead of using one of the built-in `Lighting`
    functions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用这个新的`Lighting`函数，我们需要告诉子着色器的`#pragma`语句去寻找它，而不是使用内置的`Lighting`函数之一：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have also given the Anisotropic normal map its own UVs by declaring the
    following code in the `struct Input`. This isn''t entirely necessary as we could
    just use the UVs from the main texture, but this gives us independent control
    over the tiling of our brushed metal effect so that we can scale it to any size
    we want:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在`struct Input`中声明了以下代码，为各向异性法线图赋予了它自己的UV。这并不是完全必要的，因为我们可以直接使用主纹理的UV，但这样我们可以独立控制刷漆金属效果的重叠，以便我们可以将其缩放到任何大小：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also need to add the `struct SurfaceAnisoOutput`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加`struct SurfaceAnisoOutput`：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we need to use the `surf()` function to pass the correct data to our
    `Lighting` function. Hence, we will get the per-pixel information from our Anisotropic
    normal map and set our Specular parameters as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要使用`surf()`函数将正确的数据传递给我们的`Lighting`函数。因此，我们将从我们的各向异性法线图中获取每像素信息，并将我们的高光参数设置如下：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Save your script and return to the Unity editor. Select the `AnisotropicMat`
    material and assign the Anisotropic Direction property to the texture we talked
    about in the *Getting ready* section of this recipe. Afterward, adjust the Anisotopic
    `Offset` property using the slider and notice the changes.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本并返回到Unity编辑器。选择`AnisotropicMat`材质，并将各向异性方向属性分配给我们在本菜谱的“准备”部分中提到的纹理。之后，使用滑块调整各向异性`偏移`属性，并注意变化。
- en: 'The Anisotropic normal map allows us to give the surface direction and helps
    us disperse the Specular highlight around the surface. The following screenshot
    demonstrates the result of our Anisotropic Shader:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 各向异性法线图使我们能够给表面赋予方向，并帮助我们分散表面上的高光。以下截图展示了我们的各向异性着色器的结果：
- en: '![](img/00113.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00113.jpeg)'
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's break down this shader into its core components and explain why we are
    getting the effect. We will mostly be covering the custom Lighting function here,
    as the rest of the shader should be pretty self-explanatory at this point.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个着色器分解为其核心组件，并解释我们为什么会得到这种效果。我们在这里主要会涵盖自定义光照函数，因为到目前为止，着色器的其余部分应该相当容易理解。
- en: 'We first start by declaring our own `SurfaceAnisoOutput struct`. We need to
    do this in order to get the per-pixel information from the Anisotropic normal
    map, and the only way we can do this in a Surface Shader is to use a `tex2D()`
    function in the `surf()` function. The following code shows the custom surface
    output structure used in our shader:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明自己的`SurfaceAnisoOutput`结构体。我们需要这样做是为了从各向异性法线图中获取每个像素的信息，而在表面着色器中，我们唯一能够做到这一点的方法是在`surf()`函数中使用`tex2D()`函数。以下代码展示了我们在着色器中使用的自定义表面输出结构：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can use the `SurfaceAnisoOutput` struct as a way of interacting between the
    Lighting function and the surface function. In our case, we are storing the per-pixel
    texture information in the variable called `anisoTex` in our `surf()` function
    and then passing this data to the `SurfaceAnisoOutput` struct by storing it in
    the `AnisoDirection` variable. Once we have this, we can use the per-pixel information
    in the `Lighting` function using `s.AnisoDirection`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`SurfaceAnisoOutput`结构体作为光照函数和表面函数之间交互的一种方式。在我们的情况下，我们在`surf()`函数中将每个像素的纹理信息存储在名为`anisoTex`的变量中，然后通过将数据存储在`AnisoDirection`变量中来将其传递给`SurfaceAnisoOutput`结构体。一旦我们有了这个，我们就可以使用`Lighting`函数中的`s.AnisoDirection`来使用每个像素的信息。
- en: 'With this data connection set up, we can move on to our actual lighting calculations.
    This begins by getting the usual out of the way, the half vector, so that we don''t
    have to do the full reflection calculation and diffuse lighting, which is the
    vertex normal dotted with the light vector or direction. This is done in Cg with
    the following lines:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好这种数据连接后，我们可以继续进行实际的光照计算。这首先是通过获取通常的半向量来开始的，这样我们就不必进行完整的反射计算和漫反射光照，即顶点法线与光向量或方向的点乘。这是在Cg中使用以下行完成的：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we start the actual modification to the Specular to get the right look.
    We first dot the normalized sum of the vertex normal and per-pixel vectors from
    our Anisotropic normal map with the `halfVector` calculated in the previous step.
    This gives us a float value that gives a value of `1` as the surface normal, which
    is modified by the Anisotropic normal map as it becomes parallel with `halfVector`
    and `0` as it is perpendicular. Finally, we modify this value with a `sin()` function
    so that we can basically get a darker middle highlight and ultimately a ring effect
    based on `halfVector`. All the previously mentioned operations are summarized
    in the following two lines of Cg code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始对Specular进行实际修改以获得正确的视觉效果。我们首先将顶点法线与每个像素向量的归一化总和与上一步计算的`halfVector`进行点乘。这给我们一个浮点值，当表面法线与`halfVector`平行时，其值为`1`，而当它垂直时，其值为`0`。最后，我们使用`sin()`函数修改这个值，以便我们基本上可以得到一个较暗的中间高光，并最终基于`halfVector`得到一个环状效果。所有之前提到的操作都在以下两行Cg代码中总结：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we scale the effect of the `aniso` value by taking it to a power of
    `s.Gloss`, and then globally decrease its strength by multiplying it by `s.Specular`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将其提升到`s.Gloss`的幂来缩放`aniso`值的效果，然后通过乘以`s.Specular`来全局降低其强度：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This effect is great for creating more advanced metal type surfaces, especially
    the ones that are brushed and appear to have directionality to them. It also works
    well for hair or any sort of soft surface with directionality to it. The following
    screenshot shows the result of displaying the final Anisotropic lighting calculation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种效果非常适合创建更高级的金属类型表面，特别是那些刷过并且看起来有方向性的表面。它也适用于头发或任何有方向性的软表面。以下截图显示了显示最终各向异性光照计算的最终结果：
- en: '![](img/00114.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00114.jpeg)'
