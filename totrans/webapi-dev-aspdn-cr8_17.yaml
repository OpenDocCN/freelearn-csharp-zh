- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud-Native Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters, we have covered a range of fundamental skills for
    web API development using ASP.NET Core. We discussed different styles of API development,
    such as REST, gRPC, and GraphQL, and how to implement the data access layer using
    Entity Framework Core. We also introduced how to secure a web API using the ASP.NET
    Core Identity framework. Additionally, we learned how to write unit tests and
    integration tests for web API applications, as well as common practices for API
    development, such as testing, caching, observability, and more. We also discussed
    how to deploy the containerized web API application to the cloud by using CI/CD
    pipelines. These are all essential skills for web API development.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is just the beginning of the journey. As we wrap up our exploration
    of the fundamental concepts of web API development using ASP.NET Core, it is time
    to embark on a journey to explore more advanced topics. In this chapter, we will
    transition from the basics to delve into topics that are important for developers
    aspiring to master web API development. Now, let us elevate our skills to the
    next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will delve into the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web API design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a high-level understanding of these
    topics and be able to explore them further on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code example in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17).
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term **domain-driven design**, also known as **DDD**, was coined by Eric
    Evans in his book *Domain-Driven Design: Tackling Complexity in the Heart of Software*,
    published in 2003\. DDD consists of a set of principles and practices that focus
    on the domain model and domain logic, which help developers manage the complexity
    and build flexible and maintainable software. DDD is not bound to any particular
    technology or framework. You can use it in any software project, including web
    API development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Eric Evans’ book, he defines three important principles of DDD:'
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on the core domain and domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basing complex designs on the domain models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborating with technical and domain experts to iteratively refine the model
    that solves domain problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A domain is a subject area that the software system is built for. The domain
    model is a conceptual model of the domain, which incorporates both data and behavior.
    Developers build the domain model based on the domain knowledge from domain experts.
    The domain model is the core of the software system that can be used to solve
    domain problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will introduce the basic concepts of DDD and
    how to apply them to web API development. Note that domain-driven design is a
    comprehensive topic that cannot be covered in a single chapter. So, the subsections
    are not intended to be a complete guide to DDD. Instead, it will provide a high-level
    overview of DDD and explain some of the key concepts of DDD. If you want to learn
    more about DDD, you can refer to other resources, such as Eric Evans’ DDD book.
  prefs: []
  type: TYPE_NORMAL
- en: Ubiquitous language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the core concepts of DDD is that to build a software system for a complex
    business domain, we need to build ubiquitous language and a domain model that
    reflects the business domain. Under domain-driven design, the software structure
    and code, such as class names, class methods, and so on, should match the business
    domain. The domain terms should be embedded in the code. When developers talk
    to domain experts, they should use the same terms. For example, if we are building
    a web API for a banking system, we may have a `Banking` domain. When we discuss
    the requirements with domain experts, we may hear terms such as `Account`, `Transaction`,
    `Deposit`, `Withdrawal`, and so on. In a banking system, an `Account` object can
    have different types, such as `SavingAccount`, `LoanAccount`, `CreditCardAccount`,
    and so on. A `SavingAccount` may have a `Deposit()` method and a `Withdrawal()`
    method. In the code of the system, we should use the same terms as the domain
    experts.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a ubiquitous language is an essential pillar of DDD. This language
    provides a common understanding between domain experts, developers, and users,
    allowing them to effectively communicate system requirements, design, and implementation.
    By consciously using the ubiquitous language in the code, developers can build
    a domain model that accurately reflects the business domain. Without this, the
    code may become disconnected from the business domain and become difficult to
    manage.
  prefs: []
  type: TYPE_NORMAL
- en: Bounded context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of DDD, the concept of a bounded context is essential. A bounded
    context is a boundary that defines a domain model and serves as a delineated area
    of responsibility within a software system. It is like a linguistic territory
    in which a specific model holds meaning and relevance. By encapsulating a distinct
    understanding of the domain, bounded contexts promote clarity and precision in
    communication between domain experts and developers.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where we are building a web API for a banking system. Without
    bounded contexts, the term `Account` could be interpreted differently in the `Banking`
    domain and the `customer relationship management` (CRM) domain. This ambiguity
    can lead to confusion, misaligned expectations, and ultimately, a fragmented understanding
    of the entire system. To avoid this, bounded contexts should be used to clearly
    define the scope of the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, a domain consists of several subdomains, each of which may refer
    to a distinct part of the business domain, thus creating different bounded contexts.
    These bounded contexts communicate with each other through programmatic interfaces,
    such as web APIs and message queues.
  prefs: []
  type: TYPE_NORMAL
- en: DDD layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A DDD solution is often represented as a layered architecture. Each layer has
    a specific responsibility. The following diagram shows the typical layers of a
    DDD application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Typical layers of a DDD application](img/B18971_17_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – Typical layers of a DDD application
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, there are four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer**: This layer is responsible for presenting the data to
    the user and receiving user input. Normally, this layer is implemented as a user
    interface, such as a web application, a mobile application, or a desktop application.
    In this book, we mainly focus on web API applications that do not have a user
    interface. In this case, the presentation layer can be a client application that
    consumes the web API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application layer**: This layer is responsible for coordinating the application’s
    activity. It receives user input from the presentation layer, invokes the domain
    layer to perform business logic, and returns the results to the presentation layer.
    In our case, the application layer is the web API application, which receives
    HTTP requests from the client application, invokes the domain layer to execute
    business logic, and returns the results to the client application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Deposit` method for the `SavingAccount` class, the logic in the domain layer
    does not have any knowledge of how to save data to the database. Instead, it only
    focuses on the business logic of the `Deposit` method using abstractions and interfaces.
    This layer often contains entities, value objects, aggregates, repositories, and
    domain services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure layer**: This layer implements the application infrastructure,
    such as data access, caching, logging, messaging, and so on. It often integrates
    with external systems as dependencies, such as database, message queues, and so
    on. In our case, the infrastructure layer can include the data access layer, which
    uses EF Core to access the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DDD focuses primarily on the domain and application layers. This is because
    the UI layer and the infrastructure layer are not specific to DDD and can be implemented
    with any technology or framework. For example, the UI layer can be implemented
    using **ASP.NET Core MVC**, **Blazor**, **React**, **WPF**, or any other UI framework
    on various platforms, while the core domain logic remains the same. Similarly,
    DDD does not dictate data storage, which can be a relational database, a NoSQL
    database, or any other data storage. The domain layer uses the repository pattern
    to access the data, which is independent of data storage. Another example is the
    logging mechanism, which is also not specific to DDD, as the domain layer needs
    to log the business events but does not care about the logging system used.
  prefs: []
  type: TYPE_NORMAL
- en: DDD building blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DDD has a set of building blocks that can be used to build the domain model.
    These building blocks include entities, value objects, aggregates, repositories,
    and domain services. In the following subsections, we will introduce these building
    blocks and how to use them to build the domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have essential knowledge of **object-oriented programming** (**OOP**)
    and **object-relational mapping** (**ORM**) if you have read the previous chapters.
    In OOP, an object is an instance of a class. An object has a state and behavior.
    The state is represented by the properties of the object, while the behavior is
    represented by the methods of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In DDD, the entity is similar to an object in OOP, but it is more than that.
    An **entity** is an object that has a unique identity and is defined by its identity,
    not its attributes. Normally, an entity is mapped to a table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The identity of an entity is normally represented by an ID property. The ID
    property is immutable, which means that once it is set, it cannot be changed.
    The ID property can be a primitive type, such as an integer, a string, or a GUID.
    It can also be composite keys.
  prefs: []
  type: TYPE_NORMAL
- en: If two entities have the same properties but different identities, they are
    considered different entities.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a banking system, `Account` is an entity. It has a unique identity
    that can be represented by an `Id` property. Two accounts cannot have the same
    `Id` property.
  prefs: []
  type: TYPE_NORMAL
- en: Value object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **value object** is another type of object in DDD. It is identified by its
    properties, rather than a unique identity. Normally, a value object is immutable,
    which means that its properties cannot be changed once it is created. If two value
    objects have the same properties, they are considered the same value object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `Address` is a value object. It is identified by its properties,
    such as `Street`, `City`, `State`, and `ZipCode`. If two addresses have the same
    `Street`, `City`, `State`, and `ZipCode`, they are considered the same address.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An **aggregate** is a cluster of associated objects, including entities and
    value objects, which are treated as a unit for data changes. An aggregate has
    a root entity, which is the only object that can be accessed from outside the
    aggregate. The root entity is responsible for maintaining the consistency and
    integrity of the aggregate. It is important to note that if the external objects
    need to access the objects inside the aggregate or modify the objects inside the
    aggregate, they must go through the root entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in an invoicing system, an `Invoice` entity is an aggregate root.
    It contains a list of `InvoiceItem` entities, which are the items of the invoice.
    To add an item to the invoice, the external objects must go through the `Invoice`
    entity, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, if we need to add or remove an item from the invoice,
    we must get the `Invoice` entity first, and then call the `AddItem()` or `RemoveItem()`
    method to add or remove the item. We cannot directly add or remove an item from
    the `Items` property because the `Items` property is private and can only be accessed
    from inside the `Invoice` entity. In this way, the domain logic is encapsulated
    inside the `Invoice` entity, and the consistency and integrity of the invoice
    are maintained. Similarly, we cannot change the `Total` property directly. Instead,
    the `AddItem` or `RemoveItem` method can update the `Total` property.
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **repository** is an abstraction layer used to access the data persistence
    layer. It encapsulates the data access logic and provides a way to query and save
    data. To ensure the domain layer does not depend on any specific data access technology,
    a repository is typically implemented as an interface. The infrastructure layer
    can then use a specific data access technology, such as EF Core or Dapper, to
    implement the repository interface and access different data sources, such as
    relational databases or NoSQL databases. This decouples the domain layer from
    the data access technology and data storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a repository interface is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We introduced the repository pattern in [*Chapter 9*](B18971_09.xhtml#_idTextAnchor371).
    It is not a specific DDD pattern. However, it is often used in DDD to decouple
    the domain layer from the data access layer.
  prefs: []
  type: TYPE_NORMAL
- en: Domain service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A **domain service** is a stateless service that contains domain logic that
    does not belong to any specific entity or value object. It is often used to implement
    complex domain logic that involves multiple entities or value objects. To access
    the data persistence layer, a domain service may depend on one or more repositories.
    Additionally, it may also depend on other external services. These dependencies
    are injected into the domain service through the dependency injection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a banking system, the `TransferService` domain service is responsible
    for the logic of transferring money from one account to another. To do this, it
    relies on the `AccountRepository` to access the `Account` entity. Additionally,
    it may need to use an external service to send a notification to the account holder
    after the transfer is complete. If the accounts are in different banks, the `TransferService`
    domain service may also need to use an external service to transfer money between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of a domain service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows a `TransferService` domain service. It has four dependencies:
    `IAccountRepository`, `ITransactionRepository`, `INotificationService`, and `IBankTransferService`.
    The `TransferAsync` method transfers money from one account to another. It first
    obtains the accounts from `IAccountRepository`, and then transfers money between
    the accounts. After that, it saves the changes to `IAccountRepository` and creates
    transaction records in `ITransactionRepository`. Finally, it sends a notification
    to the account holders using `INotificationService`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is simplified for demonstration purposes. The actual implementation
    to transfer money between two accounts is much more complicated. For example,
    it may need to check the balance of the accounts, check the daily transfer limit,
    and so on. It may also need to transfer money between different banks, which involves
    a lot of complex logic to handle any errors that may occur during the transfer.
    If any error occurs, it may need to roll back the transaction. This is a typical
    example of a domain service that implements complex domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: Unit of work
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the preceding example, when transferring money between two accounts, the
    process involves multiple steps. What if an error occurs during the process? In
    order to prevent any money from being lost during the process of transferring
    funds between two accounts, it is necessary to wrap the process in a transaction.
    This will ensure that in the event of an error occurring, the transaction will
    be rolled back, and the funds will remain secure. For example, if the `TransferAsync()`
    method throws an exception after the money has been withdrawn from `fromAccount`
    but before it is deposited to `toAccount`, the transaction will be rolled back,
    and the money will not be lost.
  prefs: []
  type: TYPE_NORMAL
- en: The term **transaction** is often used in the context of databases. This kind
    of transaction is called a **unit of work** in DDD. A unit of work is a sequence
    of operations that must be performed as a whole. All the steps in a unit of work
    must succeed or fail together. If any step fails, the entire unit of work must
    be rolled back. This prevents the data from being left in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: A unit of work can be implemented in various ways. In many scenarios, a unit
    of work is implemented as a database transaction. Another example is a message
    queue. When a message is received, it is processed as a unit of work. If the process
    is successful, the message is removed from the queue. Otherwise, the message remains
    in the queue and will be processed again at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Application service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The application service is responsible for managing the application process.
    It receives user input from the presentation layer, invokes the domain service
    to execute business logic, and returns the results to the Presentation Layer.
    In a web API application, the Application Service can be implemented as a web
    API controller or a separate service that is invoked by the web API controller.
  prefs: []
  type: TYPE_NORMAL
- en: The application service should be thin and delegate most of the work to the
    domain service. Typically, the application service uses `AutoMapper`. For example,
    an `InvoiceDto` class may contain the properties of an invoice, such as `Id`,
    `Date`, `Status`, `Total`, and so on. It does not have any method to add or remove
    an invoice item or close the invoice. It is purely a data container. If a property
    of the `Invoice` entity is not needed in the presentation layer, it should not
    be included in `InvoiceDto`.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation layer can send a DTO to the application service when it needs
    to create or update an entity. The application service will then map the DTO to
    the entity and invoke the domain service to execute the necessary business logic.
    Finally, the application service will map the entity back to the DTO and return
    it to the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of an application service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `IInvoiceService` interface defines the methods
    of the application service. The `InvoiceService` class implements the `IInvoiceService`
    interface. It has two dependencies: `IInvoiceRepository` and `IMapper`. `IInvoiceRepository`
    is used to access the `Invoice` entity, while `IMapper` is used to map `InvoiceDto`
    to the `Invoice` entity and vice versa. The `CreateAsync()` method receives `InvoiceDto`
    from the presentation layer via the controller, maps it to the `Invoice` entity,
    and then invokes the `AddAsync()` method of `IInvoiceRepository` to add the `Invoice`
    entity to the database. Finally, it maps the `Invoice` entity back to `InvoiceDto`
    and returns it to the presentation layer.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, there is no domain service. This is because the logic
    to create an invoice is simple. In this case, the application service layer can
    directly invoke the repository to add the invoice to the database. However, if
    the logic is more complex, involving multiple entities or aggregates, it is better
    to use a domain service to implement the logic.
  prefs: []
  type: TYPE_NORMAL
- en: DDD focuses on how to build a domain model that reflects the business domain
    and how to maintain the consistency and integrity of the domain model. It is not
    used to produce reports or user interfaces. Reports may need complex queries that
    are not suitable for the domain model. For this case, you may need to use a separate
    reporting database or reporting service. Similarly, the user interface may need
    to display data in a different way than the domain model. However, the domain
    model should remain the same no matter how the data are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: DDD can help you to manage the complexity and build a flexible and maintainable
    software system. But keep in mind that DDD is not a silver bullet. Typically,
    DDD is used for complex business domains. Developers must implement a lot of isolation,
    abstraction, and encapsulation to maintain the model. This may lead to a lot of
    effort and complexity. If your project is simple, DDD may be a bit overkill. In
    this case, a simple layered architecture may be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Clean architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clean architecture is a software architecture that was proposed by Robert C.
    Martin (also known as Uncle Bob) in his book *Clean Architecture: A Craftsman’s
    Guide to Software Structure and Design*, published in 2017\. It is a layered architecture
    that focuses on the separation of concerns. Similar to DDD, clean architecture
    is not a specific technology or framework. It is a set of principles and practices
    that can be applied to any software project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean architecture is also called onion architecture because the layers are
    arranged in a circular shape, like an onion. The following diagram shows the typical
    layers of clean architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Typical layers of clean architecture](img/B18971_17_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – Typical layers of clean architecture
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates the dependencies flowing from the outer layers
    to the inner layers. At the center of the architecture lies the application core
    layer, which contains the entities and interfaces for business logic. Additionally,
    this layer contains domain services that implement the interfaces. It does not
    depend on any other layers. Surrounding the application core layer is the Infrastructure
    Layer and UI layer, both of which depend on the application core layer. This architecture
    ensures that the application core layer is unaware of how the data are stored
    or presented to the user. In addition, the Infrastructure Layer and UI layer can
    be replaced without impacting the application core layer.
  prefs: []
  type: TYPE_NORMAL
- en: Clean architecture shares some similarities with DDD. Both of them are layered
    architectures that focus on the separation of concerns. They both use dependency
    injection (or inversion of control) to decouple the layers. DDD focuses on the
    domain layer, while clean architecture prioritizes the importance of isolating
    the core business logic from the external dependencies. The separation of concerns
    allows for modifications to external components without affecting the core business
    logic, making it easier to adapt to evolving requirements.
  prefs: []
  type: TYPE_NORMAL
- en: DDD and clean architecture complement each other and can be used together. While
    DDD guides how to build a domain model and understand the business domain, clean
    architecture offers a blueprint for organizing and structuring the codebase. Combining
    these approaches can lead to a flexible and maintainable software system.
  prefs: []
  type: TYPE_NORMAL
- en: DDD and clean architecture are both layered architectures that focus on a business
    domain. Next, let us discuss the architecture of the entire software system. In
    the next section, we will introduce microservices, which is a popular architecture
    for building scalable and maintainable software systems.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many traditional applications are built as a monolith. A monolithic application
    is deployed as a single unit on a single server. The monolithic application is
    easy to develop and deploy. However, as the application grows, it becomes more
    and more difficult to maintain and scale. A small change in the application may
    require the entire application to be rebuilt, retested, and redeployed. Moreover,
    if one part of the application needs to be scaled, the application must be scaled
    as a whole, which is not cost-effective. In addition, if one part of the application
    fails, it may affect the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: This is where microservices come in. A microservice is a small, independent
    service that is responsible for a specific business domain. Each microservice
    has its own database and dependencies. It can be developed, deployed, and scaled
    independently. These microservices communicate with each other through programmatic
    interfaces, such as web APIs or message queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices provide several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility**: Each microservice is responsible for a specific
    business domain. It has its own dependencies and database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience and fault tolerance**: Microservices are designed to be resilient
    and fault tolerant. If one microservice fails, it does not affect other microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Microservices can be scaled independently based on demand.
    If one microservice has a high workload, we can increase the number of instances
    of that microservice to handle the workload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technology diversity**: Each microservice can be built using different technologies
    and frameworks as long as they communicate with each other through standard interfaces,
    such as HTTP APIs or gRPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD**: Microservices facilitate CI/CD by allowing individual microservices
    to be built, tested, and deployed independently, minimizing disruption to the
    entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices is not a new concept; it has been around for decades. However,
    it has become more popular in recent years, especially with the rise in cloud
    computing. Cloud computing provides a scalable and cost-effective infrastructure
    for microservices. In addition, the emergence of container technology, such as
    Docker, makes it easier to build and deploy microservices. By using containers
    and container orchestration tools, such as **Kubernetes**, developers can easily
    build and deploy microservices to the cloud. The orchestration tools can automatically
    scale the microservices based on the workload. This makes it easier to build a
    scalable and cost-effective software system.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices do not have to be exclusive to other architectures. In fact, they
    can be used in conjunction with other architectures to create a more robust and
    efficient system. You can use layers, such as DDD and clean architecture, to build
    each microservice. By leveraging the benefits of both architectures, organizations
    can create a powerful and reliable system that meets their needs. This approach
    can be especially beneficial for organizations that require a high degree of scalability
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in an online shopping system, we may have the following microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product service**: This service is responsible for managing the products,
    such as adding a new product, updating a product, deleting a product, and so on.
    It has its own database to store the product data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order service**: This service is responsible for managing the orders, such
    as creating a new order, updating an order, deleting an order, and so on. It also
    has its own database to store the order data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payment service**: This service is responsible for processing payments, such
    as credit card payments, PayPal payments, and so on. It has its own database to
    store the payment data. It may also need to integrate with external payment services,
    such as PayPal, Stripe, online banking services, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shipping service**: This service is responsible for shipping the products,
    such as shipping a product to a customer and tracking the shipment. It needs to
    integrate with external shipping services, such as FedEx, UPS, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification service**: This service is responsible for sending notifications
    to the customers, such as sending an email or a text message notification, and
    so on. It needs to integrate with external notification services, such as SendGrid,
    Twilio, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identity service**: This service is responsible for managing users, such
    as creating a new user, updating a user, deleting a user, and so on. It may provide
    third-party authentication, such as from Microsoft, Google, Facebook, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway service**: This service is responsible for routing the requests to
    the appropriate microservices. It is the entry point of the system. It does not
    have its own database. Instead, it routes the requests to the appropriate microservices
    based on the request URL. It can also implement rate-limiting, authentication,
    authorization, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client applications**: These are the client applications that consume the
    microservices. They can be web applications, mobile applications, or desktop applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each service is responsible for a specific business domain and has its own dependencies.
    Developers can use different technologies and frameworks to build the services
    because they communicate with each other through standard HTTP APIs or gRPC. If
    one service needs to be scaled, it can be scaled independently. For example, if
    the `Order` service has a high workload, we can increase the number of instances
    of the `Order` service to handle the workload. This is much more cost-effective
    than scaling the entire application. Moreover, if one service fails, it does not
    affect other services. For example, if the `Payment` service fails, the `Order`
    service and `Product` service can still work. It can still receive orders and
    allow users to view products. When the `Payment` service is back online, it can
    process the orders that have not been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices have become more and more popular in recent years. However, it
    increases the complexity of the system. Before adopting microservices, you should
    carefully consider whether it is suitable for your project. Consider the following
    challenges to microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Distributed system complexity**: Microservices are distributed systems. They
    are more complex than monolithic applications. For example, if one service needs
    to call another service, you need to consider how to handle the communication
    between the services and how to maintain the consistency of the data. In addition,
    you need to handle network failures, partial failures, cascading failures, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management**: Each microservice has its own database. This makes it
    difficult to maintain data consistency, as transactions that span multiple microservices
    are not supported. To query data from multiple microservices, a distributed query
    mechanism must be implemented, which can be a complex process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery**: In a microservice architecture, each service has its
    own URL. They need to know the URLs of other services in order to communicate
    with them. This is called service discovery. There are many ways to implement
    service discovery, such as using a service registry, using a service mesh, and
    so on. The container orchestration tools, such as Kubernetes, can also be used
    to implement service discovery, as they can maintain the internal service URLs
    of the microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: Testing a microservice architecture is more complex than testing
    a monolithic application. In addition to unit testing, integration testing, and
    end-to-end testing, you also need to test the communication between the microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring**: Monitoring a microservice architecture requires a well-designed
    monitoring system. You need to monitor the health of each microservice, as well
    as the communication between the microservices. The tracing mechanism can be used
    to trace the requests between the microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, if your application is simple, do not overcomplicate it by using
    microservices. As your application grows, you can consider refactoring it into
    microservice architecture step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us discuss some common design patterns for web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web API design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a flexible, scalable, and maintainable web API application, leveraging
    well-established design patterns is essential. These patterns address common challenges
    encountered in web API development, providing effective solutions. Microsoft’s
    comprehensive guide offers insights into these design patterns, and you can find
    more details at the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These design patterns are not exclusive to ASP.NET Core; they can be applied
    to any web API, regardless of the underlying technology or framework. In the following
    sub-sections, we will introduce some key design patterns, outlining the problems
    they solve, their implementation details, and considerations for their usage.
    These patterns cover solution design and implementation, messaging, reliability,
    and so on, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command query responsibility** **segregation** (**CQRS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish/subscribe** (**pub/sub**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend for** **frontend** (**BFF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CQRS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CQRS is a powerful tool for addressing the challenge of scaling and optimizing
    read and write operations. By separating the responsibilities for handling commands
    (writes) and queries (reads), CQRS enables each operation to be optimized independently,
    resulting in improved scalability and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the data model of an application is designed to support both
    read and write operations. However, the requirements for read and write operations
    are often different. The read operations may execute different queries, resulting
    in different DTO models. The write operations may need to update multiple tables
    in the database. This may lead to a complex data model that is difficult to maintain.
    In addition, the read operations and write operations may have different performance
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: CQRS divides the application’s data model into separate models for reading and
    writing. This enables the use of different storage mechanisms and optimizations
    tailored to the specific needs of each operation. CQRS uses queries to read data
    and commands to update data. Queries do not change the state of the system, while
    commands do.
  prefs: []
  type: TYPE_NORMAL
- en: To better separate the read and write operations, CQRS can also use different
    data stores for reading and writing. For example, the read store can use multiple
    read-only replicas of the write store, which can improve the performance of the
    read operations. The replicas must be kept in sync with the write store, which
    can be done by using built-in database replication features or an event-driven
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical CQRS architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Typical CQRS architecture](img/B18971_17_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.3 – Typical CQRS architecture
  prefs: []
  type: TYPE_NORMAL
- en: To implement CQRS in ASP.NET Core web API applications, you can use the `MediatR`
    library, which is a simple mediator implementation in .NET. This library is a
    simple mediator implementation in .NET that enables the use of the mediator pattern.
    The mediator pattern is a behavioral design pattern that enables objects to interact
    without having to refer to each other explicitly. Instead, they communicate through
    the mediator, which decouples the objects and allows for greater flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical CQRS architecture using the `MediatR`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – Typical CQRS architecture using the MediatR library](img/B18971_17_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.4 – Typical CQRS architecture using the MediatR library
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the mediator is responsible for receiving the commands
    and queries from the business logic layer and then invoking the corresponding
    handlers to execute the commands and queries. Then, the handlers can use the repositories
    to access the data persistence layer for reading and writing data. The business
    logic layer does not need to know how the mediator invokes the handlers. It only
    needs to send the commands and queries to the mediator. This decouples the business
    logic layer from the data persistence layer. This pattern also makes it easier
    to send commands and queries to multiple handlers. For example, if we have a command
    to send an email notification to the customer and we need to add a text message
    notification, we can simply add a new handler to handle the command without changing
    the client code.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a sample application that demonstrates how to implement CQRS in
    ASP.NET Core web API applications in the `/chapter17/CqrsDemo` folder of the source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample project has a separate infrastructure project to implement the data
    persistence layer by following clean architecture. When you run the `dotnet ef`
    command to add a migration or update the database, you need to specify the startup
    project. For example, to add a migration, you need to navigate to the `CqrsDemo.Infrastructure`
    project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotnet ef migrations add InitialCreate --****startup-project ../CqrsDemo.WebApi**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about the `dotnet ef` command, you can refer to the following
    link: [https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project](https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow the next steps, you can use the project in the `/chapter17/CqrsDemo/start`
    folder of the source code. This project contains a basic ASP.NET Core web API
    application to manage the invoices. It contains the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CqrsDemo.WebApi`: This is the ASP.NET Core web API project. It contains the
    controllers and application configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CqrsDemo.Core`: This is the core project that contains the domain models,
    interfaces of repositories, services, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CqrsDemo.Infrastructure`: This project contains the implementation of the
    repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the model mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the core project, note that the service layer uses DTOs, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods use different DTO types for reading and writing. To map the entities
    to DTOs and vice versa, we can use `AutoMapper`, which is a popular `object-to-object
    mapper` library. The following code shows how to configure `AutoMapper` in the
    `InvoiceProfile.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can register `AutoMapper` in the `Program.cs` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the mapper, just simply inject the `IMapper` interface into the service
    layer, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using `AutoMapper` can save us a lot of time for mapping the entities to DTOs
    and vice versa. Next, we can implement the queries and commands using the `MediatR`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement the CQRS pattern using the `MediatR` library. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the `MediatR` NuGet package. Run the following command
    in the terminal window to install the `MediatR` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Queries` folder in the `CqrsDemo.Core` project. Then, create a `GetInvoiceByIdQuery.cs`
    file in the `Queries` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a `GetInvoiceByIdQuery` class that implements the
    `IRequest<InvoiceDto?>` interface. This interface is used to indicate that this
    is a query that returns an `InvoiceDto` object. The `Id` property is used to specify
    the ID of the invoice to be retrieved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, create a `GetInvoiceListQuery.cs` file in the `Queries` folder with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `GetInvoiceListQuery` query returns a list of `InvoiceWithoutItemsDto`
    objects. This is because we do not need the invoice items when listing the invoices.
    This is an example to show how to use different DTOs for reading and writing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a `Handlers` folder in the `Queries` folder. Then, create a `GetInvoiceByIdQueryHandler.cs`
    file in the `Handlers` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GetInvoiceByIdQueryHandler` class implements the `IRequestHandler<GetInvoiceByIdQuery,
    InvoiceDto?>` interface. This interface is used to indicate that this handler
    handles the `GetInvoiceByIdQuery` query and returns an `InvoiceDto` object. The
    `Handle()` method receives the `GetInvoiceByIdQuery` query and invokes the `GetAsync()`
    method of `IInvoiceService` to get the invoice by using the ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `IInvoiceService` interface can be injected into the handler. Alternatively,
    you may choose to inject the `IInvoiceRepository` interface directly into the
    handler and implement business logic there. Ultimately, it is your decision where
    to store the logic. It is important to keep in mind that the goal is to separate
    business logic from the data persistence layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, create a `GetInvoiceListQueryHandler.cs` file in the `Handlers`
    folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have two handlers to handle the `GetInvoiceByIdQuery` query and the
    `GetInvoiceListQuery` query. Next, we need to update the controllers to use the
    `MediatR` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `InvoicesController.cs` file in the `CqrsDemo.WebApi` project with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code injects the `ISender()` interface into the controller. You
    can also inject the `IMediator` interface instead. In this example, we will use
    the `ISender` interface to send the requests to the handlers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `GetInvoice()` method of the `InvoicesController` class with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a `GetInvoiceByIdQuery` object that contains the
    `id` parameter. The `ISender` interface will invoke the `GetInvoiceByIdQueryHandler`
    handler to handle the query. Then, the handler will invoke the `GetAsync` method
    of the `IInvoiceService` to get the invoice via the ID. So, the controller is
    decoupled from the service layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, update the `GetInvoices` method of the `InvoicesController` class
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a `GetInvoiceListQuery` object that contains the
    `pageIndex` and `pageSize` parameters. The `ISender` interface will invoke the
    `GetInvoiceListQueryHandler` handler to handle the query. Then, the handler will
    invoke the `GetPagedListAsync()` method of the `IInvoiceService` to get the list
    of invoices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to register the `MediatR` in the `Program.cs` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code registers all three `MediatR` interfaces and the handlers
    in the `CqrsDemo.Core` project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we use the queries to implement the read operations. You can run the application
    and test the endpoints, such as `/api/invoices/{id}` and `/api/invoices/paged`.
    These endpoints should work as before.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will implement the write operations using commands. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Commands` folder in the `CqrsDemo.Core` project. Then, create a `CreateInvoiceCommand.cs`
    file in the `Commands` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a `CreateInvoiceCommand` class that implements the
    `IRequest<InvoiceDto>` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Handlers` folder in the `Commands` folder. Then, create a `CreateInvoiceCommandHandler.cs`
    file in the `Handlers` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `InvoicesController` class with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the application and send a `POST` request to the `/api/invoices` endpoint.
    You should be able to create a new invoice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will not implement all the commands and queries in this example. You can
    work on the remaining commands and queries as an exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MediatR` makes it easy to implement the CQRS pattern in ASP.NET Core web API
    applications. However, it is not the only way to implement CQRS. You can also
    implement CQRS without using the `MediatR` library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One benefit of using the `MediatR` library is that it can send requests to
    multiple handlers. For example, we can create a command to send an email notification
    and a text message notification to the customer. Then, we can create two handlers
    to handle the command. Follow these steps to implement this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two properties to the invoice models, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to update the `Invoice` class, `CreateOrUpdateInvoiceDto` class, `InvoiceWithoutItemsDto`
    class, and `InvoiceDto` class. You can also define a `Contact` class for better
    encapsulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the database migration and update the database. You may also need to update
    the seed data. Note that you need to specify the startup project when running
    the `dotnet ef` command. For example, to add a migration, you need to navigate
    to the `CqrsDemo.Infrastructure` project and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, update the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Notification` folder in the `CqrsDemo.Core` project. Then, create
    a `SendInvoiceNotification` class in the `Notification` folder with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a `SendInvoiceNotification` class that implements
    the `INotification` interface. This interface is used to indicate that this is
    a notification that does not return any result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `Handlers` folder in the `Notification` folder. Then, create a `SendInvoiceEmailNotificationHandler`
    class in the `Handlers` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we use `IInvocieService` to obtain the invoice via the
    ID. Then, we check if the invoice exists and if the contact email is specified.
    If so, we send an email notification to the customer. For simplicity, we just
    print a message to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, create a `SendInvoiceTextMessageNotificationHandler` class in the
    `Handlers` folder with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code is similar to the previous handler. It sends a text message
    notification to the customer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Inject the `IPublisher` interface into the `InvoicesController` class, as shown
    in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `IPublisher` interface is used to publish a notification or event through
    the mediator pipeline to be handled by multiple handlers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `CreateInvoice` method in the `InvoicesController` class with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, when creating a new invoice, we send a `SendInvoiceNotification`
    notification to the `IPublisher` interface. The `IPublisher` interface will invoke
    the `SendInvoiceEmailNotificationHandler` handler and the `SendInvoiceTextMessageNotificationHandler`
    handler to handle the notification. Then, they will send the email notification
    and text message notification to the customer. If we need more notifications,
    we can simply add more handlers to handle the notification without changing the
    controller code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the application and send a `POST` request to the `/api/invoices` endpoint
    to create a new invoice. You should be able to see the console messages for the
    email notification and text message notifications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is just a simple example to demonstrate how to use the `MediatR` library
    to implement the CQRS pattern. CQRS and `MediatR` allow us to separate the read
    and write concerns and decouple the business logic layer from the data persistence
    layer. You can also try to use different databases for reading and writing or
    even for different projects. However, note that using different databases may
    lead to data consistency issues. You can use the event-sourcing pattern with the
    CQRS pattern to maintain data consistency and full audit trails. We will not cover
    the event-sourcing pattern in this book. You can find more details about the event-sourcing
    pattern at the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will introduce a popular pattern for asynchronous communication between
    microservices: the pub/sub pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Pub/sub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a microservice architecture, the microservices communicate with each other
    through standard interfaces, such as HTTP APIs or gRPC. Sometimes, a microservice
    may need to communicate with other services in an asynchronous way. It may also
    need to broadcast an event to multiple services. The pub/sub pattern can be used
    to address the need for loosely coupled communication between microservices. It
    facilitates broadcasting events or messages to multiple subscribers without them
    being directly aware of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pub/sub pattern is a communication model that facilitates the exchange
    of messages between publishers and subscribers without requiring them to be aware
    of each other. It consists of three components: publishers, subscribers, and a
    message broker. Publishers are responsible for publishing events or messages to
    the message broker, which then distributes them to subscribers. Subscribers, in
    turn, subscribe to the message broker and receive the events or messages that
    have been published. This pattern allows for asynchronous communication between
    publishers and subscribers, enabling them to remain independent of each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many message brokers can be used to implement the pub/sub pattern. Some popular
    message brokers include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RabbitMQ**: RabbitMQ is an open-source, cross-platform message broker that
    is widely used in microservice architectures. It is lightweight and easy to deploy
    on-premises and in the cloud. For more details, refer to the following link: [https://rabbitmq.com/](https://rabbitmq.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redis**: Redis is an open-source in-memory data structure store. It is versatile
    and has high performance. Redis is a popular choice for various use cases, such
    as key-value databases, caches, and message brokers. We learned how to use Redis
    as a cache in [*Chapter 15*](B18971_15.xhtml#_idTextAnchor632). It can also be
    used as a message broker to implement the pub/sub pattern. For more details, refer
    to the following link: [https://redis.io/](https://redis.io/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache Kafka**: Apache Kafka is an open-source, distributed event-streaming
    platform. It is a reliable and scalable message broker that can be used to implement
    the pub/sub pattern. It ensures the durable and reliable storage of event streams
    in a scalable, fault-tolerant, and secure manner. You can manage it yourself or
    use a managed service provided by a variety of cloud providers. For more details,
    refer to the following link: [https://kafka.apache.org/](https://kafka.apache.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Service Bus**: Azure Service Bus is a fully managed enterprise message
    broker provided by Microsoft Azure. It supports message queues and topics. For
    more details, refer to the following link: [https://learn.microsoft.com/en-us/azure/service-bus-messaging/](https://learn.microsoft.com/en-us/azure/service-bus-messaging/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pub/sub pattern decouples the microservices from each other. It also improves
    the scalability and reliability. All the messages or events are handled in an
    asynchronous way. This helps the service continue to function even if the workload
    increases or one of the services fails. However, it also increases the complexity
    of the system. You need to manage the message ordering, message priority, message
    duplication, message expiration, dead-letter queues, and so on. To learn more
    about the pub/sub pattern, you can refer to the following link: [https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber](https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber).'
  prefs: []
  type: TYPE_NORMAL
- en: Backends for frontends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Backends for frontends** (**BFFs**) address the challenge of efficiently
    serving diverse client interfaces with distinct requirements. This is useful when
    applications need to serve multiple client types, such as web, mobile, and desktop.
    Each client type may need a different data format. In this case, a monolithic
    backend may struggle to cater to the unique needs of each client. Specifically,
    if the backend includes multiple microservices, each microservice may need to
    provide multiple endpoints to serve different client types. This can lead to a
    complex and inefficient system.'
  prefs: []
  type: TYPE_NORMAL
- en: BFF architecture is a useful solution for applications that need to serve multiple
    client types, such as web, mobile, and desktop. Each client type may have distinct
    requirements for a data format, which can be difficult to manage with a monolithic
    backend. If the backend includes multiple microservices, each microservice may
    need to provide multiple endpoints to serve different client types, resulting
    in a complex and inefficient system. BFFs can help address this challenge by efficiently
    serving diverse client interfaces with distinct requirements.
  prefs: []
  type: TYPE_NORMAL
- en: BFF introduces dedicated backend services tailored for specific frontend clients.
    Each frontend client has its corresponding backend, enabling fine-grained control
    over data retrieval, processing, and presentation. This allows for a more efficient
    and flexible system that can better meet the needs of each client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a typical BFF architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Typical BFF architecture](img/B18971_17_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.5 – Typical BFF architecture
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 17**.5*, each BFF service is responsible for a specific frontend
    client. It can retrieve data from multiple microservices and combine the data
    into a single response. Each BFF service is fine-tuned to meet the specific needs
    of the frontend client. It also illustrates how each BFF service is responsible
    for a particular frontend client. Each BFF service is tailored to meet the specific
    requirements of the frontend client. It can retrieve data from multiple microservices
    and combine them into a single response.
  prefs: []
  type: TYPE_NORMAL
- en: BFFs should be lightweight. They can contain client-specific logic but should
    not contain business logic. The main purpose of BFFs is to tailor the data for
    each frontend client. However, this may lead to code duplication. If the data
    format is similar for multiple frontend clients, BFFs may not be required.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a microservice architecture, resilience and reliability are essential for
    a successful system. web APIs are often subject to unpredictable environments,
    such as network latency, transient failures, service unavailability, high traffic,
    and so on. To ensure that these APIs are resilient and reliable, several patterns
    can be implemented. These include retry, rate-limiting, time out, circuit breaker,
    and so on. In this section, we will discuss how to use the `Polly` library to
    implement these patterns in ASP.NET Core web API applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a sample project in the `/chapter17/PollyDemo` folder. This project
    contains two basic ASP.NET Core web API applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PollyServerWebApi`, which behaves as a server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PollyClientWebApi`, which is also a web API application but also behaves as
    a client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use these two applications to demonstrate how to use the `Polly` library
    to implement the rate-limiting, retry, timeout, and circuit breaker. `Polly` is
    a popular .NET resilience and transient-fault-handling library. You can find more
    details about `Polly` at the following link: [https://www.thepollyproject.org/](https://www.thepollyproject.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Polly` in ASP.NET Core web API applications, you need to install the
    `Polly` NuGet package. Navigate to the `PollyClientWebApi` project and run the
    following command in the terminal window to install the `Polly` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`Polly` provides a resilience pipeline builder to build a resilience pipeline.
    A resilience pipeline runs a series of resilience policies. Each policy is responsible
    for handling a specific type of issue. The following code shows how to create
    a resilience pipeline builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will explore several resilience policies provided by `Polly`.
  prefs: []
  type: TYPE_NORMAL
- en: Timeout
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **timeout** pattern is a common pattern used to handle slow or unresponsive
    services. When a service is slow or unresponsive, the client may wait for an extended
    period before receiving a response. To avoid this, a timeout can be set for the
    service. If the service cannot respond within the given time frame, the client
    can return an error to the user, thus preventing them from waiting unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18971_04.xhtml#_idTextAnchor170), we introduced a `RequestTimeout`
    middleware to set the timeout for the ASP.NET Core web API application. The `RequestTimeout`
    middleware is applied to the endpoints or actions that need to be timed out. Sometimes,
    we may need to set the timeout for a specific method call, such as calling a REST
    API or querying a database. Let us explore other ways to set the timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HttpClient` class in .NET Core provides a timeout feature. You can set
    the timeout for the `HttpClient` object by setting the `Timeout` property. The
    following code shows how to set the timeout for the `HttpClient` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates an `HttpClient` object and sets the timeout to 10
    seconds. If the service does not respond within 10 seconds, the `HttpClient` object
    will throw an exception. You can catch the exception and return an error to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the timeout for the `HttpClient` object is useful for simple tasks,
    such as calling a REST API. However, it is not suitable for more complex tasks
    that do not use `HttpClient`, such as a database query. For other tasks, such
    as a database query, you can use the `CancellationToken` to set the timeout. The
    following code shows how to set the timeout for a database query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a `CancellationTokenSource` object and sets the timeout
    to 10 seconds. If the database query is not complete within 10 seconds, the `GetAsync()`
    method will throw an exception. This prevents the client from waiting for an extended
    period before receiving a response.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, there may be multiple services that need to be called. Moreover,
    setting the timeout for each service call may be tedious. To simplify this, we
    can use the `Polly` library to implement the timeout policy.
  prefs: []
  type: TYPE_NORMAL
- en: '`Polly` provides a timeout policy that can be used to set the timeout for a
    service. Follow these steps to implement the timeout policy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an endpoint in the `PollyServerWebApi` application to simulate a slow
    service. Open the `Program.cs` file and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a minimal API endpoint that simulates a slow service.
    It generates a random delay between 1 and 20 seconds. This endpoint will return
    a response after the delay. This is just an example of simulating a slow service.
    In a real-world application, the service may be slow due to network latency, high
    traffic, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a controller in the `PollyClientWebApi` application to call the slow
    service. Add a `PollyController` class in the `Controllers` folder with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This controller uses the `IHttpClientFactory` to create an `HttpClient` object.
    Then, it calls the slow service and returns the response to the client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the two applications and send a request to the `/api/polly/slow-response`
    endpoint of the `PollyClientWebApi` application. You should be able to see the
    response after a random delay between 1 and 20 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will implement the timeout policy using `Polly`. For example, we can
    set the timeout to 5 seconds, which means if the service does not respond within
    5 seconds, the client will return an error to the user instead of waiting for
    a long time. Update the `GetSlowResponse()` method of the `PollyController` class
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses `Polly` to create a `ResiliencePipelineBuilder` object.
    Then, it adds a timeout policy with a timeout of 5 seconds. The `ExecuteAsync()`
    method is used to execute the pipeline. If the service does not respond within
    5 seconds, the `ExecuteAsync()` method will throw an exception. The `catch` block
    is used to catch the exception and return an error to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that in the `ExecuteAsync()` method, the cancellation token is passed to
    the `GetAsync()` method of the `HttpClient` object. If it does not, the `HttpClient`
    will continue to wait even if the timeout occurs. It is important to respect the
    cancellation token from the `Polly` resilience pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the two applications and send a request to the `/api/polly/slow-response`
    endpoint of the `PollyClientWebApi` application. You should be able to see the
    error message after 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding example, we defined the timeout policy in the controller.
    To reuse the timeout policy, we can define a global timeout policy in the `Program.cs`
    file and then use dependency injection to inject the policy into the controller.
    Follow these steps to implement the global timeout policy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Polly.Extensions` NuGet package. Navigate to the `PollyClientWebApi`
    project and run the following command in the terminal window to install the `Polly.Extensions`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: builder.Services.AddResiliencePipeline("timeout-5s-pipeline", configure =>{    configure.AddTimeout(TimeSpan.FromSeconds(5));});
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `ResiliencePipelineProvider<string>` class into the `PollyController`
    class, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ResiliencePipelineProvider<string>` class is used to retrieve the global
    timeout policy. The `string` type parameter specifies the type of the policy name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `GetSlowResponse()` method of the `PollyController` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this way, we can reuse the global timeout policy by its name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Polly` supports many other resilience patterns. Next, let us discuss rate-limiting.'
  prefs: []
  type: TYPE_NORMAL
- en: Rate-limiting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **rate-limiting** pattern is a common pattern used to limit the number of
    requests that can be made to a service. The rate should be set to a reasonable
    value to avoid overloading the service. You can run a performance test to determine
    the optimal rate limit. The performance of the service depends on many factors,
    such as the hardware, network, and the complexity of business logic. Once you
    have determined the optimal rate limit, you can apply it to the service to ensure
    that it can handle the workload.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a service can handle 100 requests per second when the number
    of requests exceeds 100, the service may become slow or even unavailable. The
    client may encounter a timeout error. To avoid this, we can set the rate limit
    for the service. When the number of requests exceeds the rate limit, the service
    will reject the requests and return an error to the client. This can prevent the
    service from being overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a rate-limiting middleware that can be used to configure
    rate-limiting in various policies, such as `fixed window`, `sliding window`, `token
    bucket`, and `concurrency`. We introduced rate-limiting middleware in [*Chapter
    4*](B18971_04.xhtml#_idTextAnchor170). You can find more details about rate-limiting
    middleware at the following link: [https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the `PollyDemo` solution in the `/chapter17/PollyDemo/end` folder.
    In the `Program.cs` file of the `PollyServerWebApi` project, you can find the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The rate-limiting policy is applied to the `WeatherForecastController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code configures a fixed window rate limiter with a rate limit
    of five requests per 3 seconds. Of course, this is just an example for demonstration
    purposes. When the `PollyClientWebApi` application sends more than five requests
    per 3 seconds to the `PollyServerWebApi` application, the `PollyServerWebApi`
    application will return a `429 Too Many Requests` error to the client. The `OnRejected`
    callback is used to handle the rejected requests. In this example, we simply return
    a message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `dotnet run` command to run the `PollyServerWebApi` application and
    the `PollyClientWebApi` application. Then, send more than five requests per 3
    seconds to the `/weatherforecast` endpoint of the `PollyClientWebApi` application.
    You should be able to see the `429 Too Many Requests` error in the `PollyClientWebApi`
    application. In this way, we can limit the number of requests to the `PollyServerWebApi`
    service so that it can handle the workload without being overloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use `Polly` to implement the rate-limiting pattern. Follow these
    steps to implement the rate-limiting pattern using `Polly`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `Polly.RateLimiting` NuGet package for the `PollyClientWebApi`
    project by running the following command in the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `/api/normal-response` endpoint in the `PollyServerWebApi` application
    to simulate a normal service. Open the `Program.cs` file and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This endpoint will return a response after a random delay between 1 and 1000
    milliseconds, which means, in the worst case, it may take 1 second to return a
    response. To limit the number of requests to this endpoint, we can use the rate-limiting
    policy for the `PollyClientWebApi` application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will use the dependency injection to inject the rate-limiting policy for
    convenience. Define a rate-limiting policy in the `Program.cs` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a fixed window rate limiter with a rate limit of
    5 requests per 3 seconds. The policy is named `rate-limit-5-requests-in-3-seconds`.
    You can use any name you like.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this example, we create a separate `Polly` pipeline for the rate-limiting
    policy. You can also combine multiple policies into a single pipeline. For example,
    you can combine the rate-limiting policy and the timeout policy into a single
    pipeline using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inject the `ResiliencePipelineProvider<string>` class into the `PollyController`
    class of the `PollyClientWebApi` project, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will find that the code is quite similar to the timeout policy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the two applications and send more than 5 requests per 3 seconds to the
    `/api/polly/rate-limit` endpoint of the `PollyClientWebApi` application. Sometimes,
    you may see an error message in the console window of the `PollyClientWebApi`
    application as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, you can use `Polly` to implement other rate-limiting policies, such
    as `sliding window`, `concurrency`, and `token bucket`. Here is an example of
    the sliding window rate limiter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a sliding window rate limiter with a rate limit of
    100 requests per minute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As the Polly `RateLimiter` is a disposable resource, it is a good practice
    to dispose of it when it is no longer needed. `Polly` provides an `OnPipelineDisposed`
    callback that can be used to dispose of the `RateLimiter` object. For example,
    we can dispose of the `RateLimiter` object in the `OnPipelineDisposed` callback
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this way, we can dispose of the `RateLimiter` object when the pipeline is
    disposed of so that it does not consume resources unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Retry
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let us discuss `429 Too Many Requests` error, or a `500 Internal Server
    Error` error, it can retry the request after a delay because the error may be
    caused by a temporary issue, such as rate-limiting or a network glitch. The next
    time the client API sends the request, it may succeed. This is called retry.
  prefs: []
  type: TYPE_NORMAL
- en: The retry pattern is a common approach to addressing transient failures in communication
    between microservices. This pattern is particularly useful in a microservice architecture,
    where network glitches or the temporary unavailability of a service can cause
    communication failures. By implementing retry mechanisms, these transient issues
    can be managed, and the overall reliability of the system can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the retry pattern using `Polly`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Get()` method of the `WeatherForecastController` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a `ResiliencePipelineBuilder` object to build a resilience
    pipeline. Then, it adds a retry policy to the pipeline. The retry policy will
    retry the request three times if it fails. The delay between retries is 500 milliseconds.
    The `MaxDelay` property is used to specify the maximum delay duration. The `OnRetry`
    callback is used to log the retry attempts. Finally, it executes the pipeline
    to send the request to the `PollyServerWebApi` application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the two applications and send more than five requests per 3 seconds to
    the `/weatherforecast` endpoint of the `PollyClientWebApi` application. Sometimes,
    you may see that the request takes a longer time to complete. This is because
    the request is retried if it fails. You should also be able to see the retry attempts
    in the console window of the `PollyClientWebApi` application, as shown in the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this way, we can automatically retry the request if it fails. This can improve
    the reliability of the system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The retry policy can be configured in various ways. For example, we can configure
    the retry policy to retry the request only when the response status code is `429`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also delay the retry attempts with an exponential backoff strategy. This
    is because the service may be overloaded, and the retry attempts may fail again.
    In this case, we can delay the retry attempts to avoid overloading the service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use the exponential backoff strategy, we can specify the `BackoffType` property
    of the `RetryStrategyOptions` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BackoffType` property is a `DelayBackoffType` enum that can be set to `Constant`,
    `Linear`, or `Exponential`. The `Constant` strategy will delay the retry attempts
    with a constant delay. The `Linear` strategy will delay the retry attempts with
    a linear delay. The `Exponential` strategy will delay the retry attempts with
    an exponential delay. The default strategy is `Constant`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are a few considerations when using the retry pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: The retry pattern should only be used to handle transient failures. If you want
    to implement a repeatable operation, you should use some scheduling mechanism,
    such as a background service, or suitable tools, such as `Polly` retry to implement
    a scheduled repeating operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using different retry policies for different types of errors. For example,
    an API call may involve HTTP requests, database queries, and JSON deserialization.
    If the HTTP request fails due to a network glitch, you can retry the request.
    However, if the JSON deserialization fails, it is unlikely to succeed even if
    you retry the JSON deserialization method. In this case, you can use `ShouldHandle`
    to specify the types of errors that should be retried.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **circuit breaker** pattern is a useful tool for preventing service overload
    and failure. In the event that a service is becoming seriously overloaded, a client
    should stop sending requests for a period of time in order to allow the service
    to recover. This is known as the circuit breaker pattern and can help to avoid
    a service crash or total failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `Polly` to implement the circuit breaker pattern. As we have already
    learned how to use Polly to implement the timeout pattern, the rate-limiting pattern,
    and the retry pattern, you should be able to understand the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `/api/random-failure-response` endpoint in the `PollyServerWebApi`
    application to simulate an overloaded service. Open the `Program.cs` file and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This endpoint will return a `500 Internal Server Error` error with an 80% chance
    (approximately). This is just an example of simulating an overloaded service.
    In a real-world application, the service may be overloaded due to high traffic,
    network latency, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to the `Program.cs` file of the `PollyClientWebApi`
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code defines a circuit breaker policy named `circuit-breaker-5-seconds`
    with a failure ratio of 0.7\. This means if the failure ratio is greater than
    0.7, the circuit breaker will open. The `SamplingDuration` property is used to
    specify the duration of the sampling over which the failure ratios are calculated.
    The `MinimumThroughput` property means that at least 10 requests must be made
    within the sampling duration. The `BreakDuration` property means that the circuit
    breaker will stay open for 5 seconds if it opens. The `ShouldHandle` property
    is used to specify the types of errors that should be handled by the circuit breaker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new action in the `PollyController` class of the `PollyClientWebApi`
    application to call the overloaded service. Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses `result.EnsureSuccessStatusCode()` to throw an exception
    if the response status code is not successful. As the overloaded service has an
    80% chance of returning an error, the circuit breaker will open after a couple
    of requests. Then, the circuit breaker will stay open for 5 seconds. During this
    period, the client will not send any requests to the overloaded service. After
    5 seconds, the circuit breaker will close, and the client will send requests to
    the overloaded service again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the two applications and send more than 10 requests to the `/api/polly/circuit-breaker`
    endpoint of the `PollyClientWebApi` application. Sometimes, you will see a `500
    Internal Server Error` error as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send more requests, and you will see that the circuit breaker opens and returns
    a different error message as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that the error message is different from the previous one, which
    indicates that the circuit breaker is open, so any requests to the overloaded
    service will be rejected. You need to wait for 5 seconds before sending more requests
    to the overloaded service. During these 5 seconds, all the requests to the `/api/polly/circuit-breaker`
    endpoint will not be sent to the overloaded service and will return the same error
    message instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Circuit breakers are not the same as the retry pattern. The retry pattern expects
    the operation to succeed eventually. However, the circuit breaker pattern prevents
    the operation from being executed if it is likely to fail, which can save resources
    and allow the external service to recover. You can use these two patterns together.
    But note that the retry logic should check the exception type thrown by the circuit
    breaker. If the circuit breaker indicates that the operation failure is not a
    transient issue, the retry logic should not retry the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`Polly` is a powerful library that implements many resilience patterns. This
    section cannot cover all the patterns provided by `Polly`. You can find more examples
    at the following link: [https://www.pollydocs.org/index.html](https://www.pollydocs.org/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the design patterns discussed in this chapter, there are more
    patterns for microservice architecture. As many of these patterns are beyond the
    scope of this book, we will not discuss them in detail. You can find more details
    about these patterns from Microsoft Learn: [https://learn.microsoft.com/en-us/azure/architecture/patterns/](https://learn.microsoft.com/en-us/azure/architecture/patterns/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored several concepts and patterns for microservice
    architecture, including domain drive design, clean architecture, CQRS, pub/sub,
    and BFF, and resilience patterns, such as timeout, rate-limiting, retry, and circuit
    breaker. These patterns can help us design and implement a maintainable, reliable,
    and scalable microservice architecture. Although this chapter does not cover all
    the patterns for microservice architecture, it should provide a basic understanding
    of what they are and how they can be used. These patterns are essential for developers
    who wish to progress beyond the basic knowledge of ASP.NET Core web API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will discuss some open-source frameworks that can be
    used to build ASP.NET Core web API applications. You can check the chapter out
    at the following link: [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about microservice architecture, the following resources from
    Microsoft Learn are highly recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Architectural principles: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common web application architectures: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Microservices: Architecture for Containerized .NET Applications: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architect Modern Web Applications with ASP.NET Core and Azure: [https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/](https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Architecting Cloud Native .NET Applications for Azure: [https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Serverless apps: Architecture, patterns, and Azure implementation: [https://learn.microsoft.com/en-us/dostnet/architecture/serverless/](https://learn.microsoft.com/en-us/dotnet/architecture/serverless/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cloud Design Patterns: [https://docs.microsoft.com/en-us/azure/architecture/patterns/](https://docs.microsoft.com/en-us/azure/architecture/patterns/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
