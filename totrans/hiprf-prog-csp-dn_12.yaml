- en: '*Chapter 10*: Setting Up Our Database Project'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this and the following two chapters, we will be improving the performance
    of your database-based applications. In this chapter, we will be setting up our
    relational database and the code to access that database. In the next chapter,
    we will write benchmarks to test the performance of the different frameworks,
    which consist of Entity Framework, Dapper, and ADO.NET. Finally, in [*Chapter
    12*](B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215), *Responsive User Interfaces*,
    we will learn how to improve the performance of SQL Server and Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: Data is extensively used in all aspects of our daily lives. In today's world
    of big data, the volume of data being collected and stored for all kinds of analysis
    is phenomenal. When working with data, performance can slow down exponentially
    as the size of your data grows. And depending on how much data you have to process,
    time is often critical.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a database and populate it, and we will write
    the code to access the database and perform insert, update, select, and delete
    operations. Our database access code will consist of Entity Framework, Dapper.NET,
    and ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: No code performance improvements will be discussed in this chapter. We are only
    concerned with setting up our database and source code in preparation for the
    benchmarking that we will be doing in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and populating a SQL Server database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code to access the database using Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code to access the database using Dapper.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code to access the database using ADO.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log on to SQL Server Management Studio and execute database creation and seeding
    scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store secrets in `secrets.json` when developing so that secrets don't get stored
    in version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access SQL Server databases and perform **Create/Insert, Read/Select, Update,
    and Delete** (**CRUD**) operations using Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access SQL Server databases and perform CRUD operations using Dapper.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access SQL Server databases and perform CRUD operations using ADO.NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with this chapter, you will need to ensure that you have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server 2019 Express Edition or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server Management Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will set up our database and get our project ready for
    benchmarking. We will be benchmarking different methods of inserting, updating,
    selecting, and deleting data. Let''s start with setting up our database:'
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `instnwnd.sql` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the file has been downloaded, open it in SQL Server Management Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the file. This will install the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new query window and enter the following SQL code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the code has been entered, execute the script. This code generates the
    `InsertProduct` stored procedure. This stored procedure inserts a product into
    the `Products` table of the `Northwind` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing SQL with the following SQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the SQL to generate the `GetProductName` stored procedure. A product
    name can have different variations. This stored procedure gets the top 1 name
    for the given product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing SQL code with the following SQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute the SQL to generate the `FilterProducts` stored procedure. The stored
    procedure returns all the products whose names contain the search term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, replace the existing SQL with this SQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute this SQL to generate the `UpdateProductName` stored procedure. This
    procedure updates a product name from its current name to a new name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the existing SQL with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Execute this code to generate the `DeleteProduct` stored procedure. This deletes
    products from the database that match the given product name.
  prefs: []
  type: TYPE_NORMAL
- en: Once the database has been installed and all the procedures have been written
    and executed, you can close SQL Server Management Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have set up our database, we will set up our database access project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our database access project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be creating our database access project and classes.
    In the next chapter, we will be writing some benchmarks that reference the classes
    that we will write in this chapter. Create the project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new .NET 6.0 console application called `CH10_DataAccessBenchmarks`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the latest version of the `Microsoft.EntityFrameworkCore.SqlServer` NuGet
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the latest version of the `Dapper` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the latest version of the `System.Data.SqlClient` NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Configuration`, and add two classes called `DatabaseSettings`
    and `SecretsManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder called `Data`, and add three classes called `AdoDotNetData`, `DapperDotNet`,
    and `EntityFrameworkCoreData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder called `Models`, and add three classes called `Product`, `SqlCommandModel`,
    and `SqlCommandParameterModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a folder called `Reflection`, and add a class called `Properties`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the main root, add a class called `BenchmarkTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we have created and updated our database with the stored procedures
    we will be calling, and we have also put in place the project, folders, and class
    files that we will be using to benchmark the various types of data operations
    we normally perform on a database from code. Let's start by writing the `Properties`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Properties class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of our benchmarking, we need to obtain the `FieldCount` value of a
    `DbDataRecord`. But the property is not readily accessible without using reflection.
    Therefore, to make our lives easier, we will write a class called `Properties`
    that helps us get the values of properties using reflection easily. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Properties` class and add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need both these namespaces to be imported as we are using reflection and
    need access to the `DbDataRecord` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetProperty` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a generic type and a property name. Then, it obtains the property
    and returns it as a `PropertyInfo` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `GetValue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a generic object type, return type, and property name. Then,
    it calls the `GetProperty` method by passing in the generic object type and property
    name. The `GetValue` method is then called, passing in the source object. The
    result is cast to the generic return type and returned to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetFieldCount` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts a `DbDataRecord` object. It calls our `GetValue` method
    by passing in the return type, our `DbDataRecord`, and our `FieldCount` property
    name. An integer is returned that contains the number of fields that our `DbDataRecord`
    object has.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have created our `Properties` class. As part of our benchmarking,
    we will be inserting, reading, editing, and deleting data from a SQL Server database.
    And so, in the next section, we will update our `DatabaseSettings` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the DatabaseSettings class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `DatabaseSettings` class is really simple: it contains a single property.
    Open the database and add the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This property holds our connection string for the SQL Server database. We will
    be setting this property in each of our benchmark methods. Then, it will be passed
    to the constructors of our data access classes.
  prefs: []
  type: TYPE_NORMAL
- en: Because database connection strings are a sensitive form of data that should
    be kept very private, we will be storing our database connection strings in a
    `secrets.json` file during the development process. But in production, we will
    obtain the connection string from an `appsettings.json` file. And so, in the next
    section, we will be writing a `SecretsManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the SecretsManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to update our `SecretsManager` class so that we
    can safely obtain secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Our development environment will use a `secrets.json` file. This is very serious
    as private credentials have been found and accessed on source code hosting sites
    such as GitHub before now, and we don't want to be the ones responsible for checking
    in code that contains secrets that should be kept private.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following NuGet packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need these packages so that we can configure the project for user secrets
    and `appsettings.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `SecretsManager` class and add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need these `using` statements for our property, filesystem, and environment
    variable access, and for access to the Microsoft `IConfiguration` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Configuration` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property will hold the correct configuration object, which depends on whether
    we are in development or production mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `GetSecrets` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method determines whether we are in development or non-development mode.
    If we are in development mode, then we use the secrets configuration mode. Otherwise,
    we obtain secrets from the `appsettings.json` file. The method accepts a section
    name, which is the name of the secret we want to retrieve, and it returns the
    value of that secret.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have finished writing our `secrets` class. For our data manipulation
    benchmarks, we will be focusing on a single table – the `Products` table of the
    `Northwind` database. We will need a class that will act as a model for the data.
    So, in the next section, we'll write the `Product` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Product class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will update our `Product` class. It is a simple object
    that is used for data manipulation benchmarks and contains properties that match
    the `Products` table in the `Northwind` database. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Product` class and update it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we annotated our class with the `Table` annotation, passing the name of
    the table in the `Northwind` database that this class maps to into the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following properties and annotations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These properties match the columns of the `Product` table in the `Northwind`
    database. The `[Key]` annotation identifies the `ProductID` property as the table's
    primary key. Two foreign keys are identified by the `[ForeignKey]` annotation.
    We pass the name of the table into this annotation, which contains the primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: "And that's it – we've finished writing our `Product` class. We will be using\
    \ several commands \Land parameters when accessing data. To make life easy, we\
    \ will have a `SqlCommandModel`class for defining our commands, and a `SqlCommandParameterModel`\
    \ class for defining our command parameters. Let's begin by writing the `SqlCommandModel`\
    \ class."
  prefs: []
  type: TYPE_NORMAL
- en: Writing the SqlCommandModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we write a simple class that models a SQL command. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SqlCommandModel` class, define the class as public, and add the `System.Data`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following three properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `CommandText` property holds our SQL command. This may be the name of a
    stored procedure or a SQL statement. The `CommandType` property determines whether
    the command is a `Text` command or a `StoredProcedure` command, while the `CommandParameters`
    property contains an array of SQL command parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have written `SqlCommandModel`, let's write the `SqlCommandParameterModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the SqlCommandParameterModel class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll write our `SqlCommandParameterModel` class. This class
    is simply a SQL parameter definition model.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `SqlCommandParameterModel` class, make the class public, and add the
    `System.Data` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This class models a standard parameter that consists of the name of the parameter,
    its database type, and its value.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have created the core functionality that we need in place for
    our data access classes. In the following sections, we will be writing data access
    classes to access data using Entity Framework, Dapper, and ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind choosing SQL Server for the database server is that it is
    one of the most common database servers and is used in many business scenarios
    the world over. In professional environments where SQL Server is employed, the
    three most common data access methods are Entity Framework, Dapper, and ADO.NET.
    That is why we will be benchmarking them in this chapter. Let's start by writing
    our ADO.NET data access class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the AdoDotNet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be writing our data insertion methods. However, we
    will not be running our benchmarks, which will be performed in the next chapter
    as we analyze our results. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `AdoDotNetData` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we implemented the `IDisposable` pattern. When we have
    finished with our class, we dispose of our class, which also disposes of disposable
    objects that it holds in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ExecuteNonQuery` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a `SqlCommandModel` object. A new instance of the `SqlCommand`
    object is created. We pass the SQL command and SQL connection into the constructor
    during instantiation. Then, we loop through the command parameters, instantiating
    and adding a `SqlParameter` for each `model.CommandParameter` to the `sqlCommand`
    object. Next, we open a connection to the database, execute the query, and close
    the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code executes the non-query SQL code that's been passed in via
    the `sql` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following generic scalar method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a SQL command as a string. A connection to the database is
    opened, and a new `SqlCommand` is instantiated. The `ExecuteScalar` command is
    executed, which returns a single value from the database. Before the value is
    returned, it is cast to the generic type specified by the caller and returned
    as that type. The connection is then closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following scalar method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a `SqlCommandModel` and uses it to build up a `SqlCommand`.
    The `SqlCommand` class is executed by calling the `ExecuteScalar` method and is
    cast to the generic type before being returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following reader method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a SQL statement and executes it by calling the `ExecuteReader`
    method. Once the method has been executed, we obtain the reader's enumerator.
    Then, we iterate through the enumerator and build up an object for the current
    iteration and yield the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following reader method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This reader method takes a `SqlCommandModel` and builds up a `SqlCommand`. It
    executes the reader and obtains `SqlDataReader`. It iterates through the reader
    and builds up an instance of the generic type that is then yielded to the user.
  prefs: []
  type: TYPE_NORMAL
- en: That's our ADO.NET data access class completed. Now, let's learn how to write
    the Entity Framework data access class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the EntityFrameworkCoreData class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be writing the methods for our Entity Framework data
    access class. The code we will write in this section will be executed in the next
    chapter. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `EntityFrameworkCoreData` class and edit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our class inherits from the `DbContext` class of the `Microsoft.EntityFrameworkCore`
    library. We declare a variable to hold our database connection string, and a variable
    to hold a collection of `Products`. In our constructor, we set the connection
    string and call the base constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `OnConfiguring` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method determines that we will be using SQL Server and passes in the SQL
    Server connection string that we will be using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method, which executes raw SQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a SQL statement and executes it against the database as raw
    SQL. The returned value is the number of records affected by the execution of
    the statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method for executing a stored procedure as a non-query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we build up a `SqlParameter` array from our `SqlCommandModel`.
    Then, we execute raw SQL by passing in each of the parameters to the stored procedure.
    This execution is a non-query and returns the number of rows affected by running
    the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method will execute and return a scalar value of the `string`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method executes a stored procedure with a single parameter. We obtain the
    enumerable return object and filter it to get the first record. The name of the
    product is then returned as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the final method to our class, which returns an enumerator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This executes a stored procedure with a single parameter and returns an enumerator
    full of filtered products.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have written all our Entity Framework classes. Now, it's time
    to write our Dapper.NET methods.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the DapperDotNet class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write our Dapper.NET methods. This is the last section
    before we write our benchmarking methods. We will run the code we write in this
    section in the next chapter. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `DapperDotNet` class, add the `SimpleCRUD` package, and modify it
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We implement the `IDisposable` pattern in this class and set the SQL dialect
    to the SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following non-query method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method executes raw SQL and returns the number of records affected by the
    SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to execute a non-query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a `SqlCommandModel` instance and builds up a `DynamicParameter`
    bag. Then, it executes a stored procedure defined by the model's `CommandText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following generic scalar method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a SQL statement and executes it, returning a single value
    of the required type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method, which executes a stored procedure and returns a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a `SqlCommandModel` instance and uses it to execute a stored
    procedure. Remember to add the missing `using` statements for `SqlCommandModel`
    to the class. The stored procedure execution returns a type of `IEnumerable<Product>`.
    So, we obtain the first product in the list and return its `ProductName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method, which executes raw SQL and returns a type of `IEnumerator<T>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method executes a raw SQL string and returns a type of `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method, which executes a stored procedure and returns a type
    of `IEnumerator<Product>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a `SqlCommandModel` instance and builds up a parameterized
    stored procedure that is executed. A type of `IEnumerator<Product>` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add our final dapper method, which will obtain the first product name that
    matches the `productName` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a product name and executes the `GetProductName` stored procedure.
    The stored procedure matches all the products in the database whose product names
    are like the product name argument. Then, it gets the first product in the returned
    list and returns its product name.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our database and data access project setup in preparation for
    the benchmarking work we will be doing in the next chapter. Let's review what
    we have accomplished in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we downloaded the `Products` table.
  prefs: []
  type: TYPE_NORMAL
- en: After making sure that we have our database in place with the required stored
    procedures, we started a .NET 6.0 console application. We added our model class
    and data access classes for performing data access operations in Entity Framework,
    Dapper, and ADO.NET.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be benchmarking the data access methods for each
    of these frameworks. In the *Further reading* section, you can further your knowledge
    of Entity Framework, Dapper, and ADO.NET using the links provided.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Entity Framework Core: [https://docs.microsoft.com/ef/core/](https://docs.microsoft.com/ef/core/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Dapper: [https://dapper-tutorial.net/dapper](https://dapper-tutorial.net/dapper'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'ADO.NET: [https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/](https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
