- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Leveraging Attributes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用属性
- en: We briefly touched on the concept of C# attributes in [*Chapter 2*](B19418_02.xhtml#_idTextAnchor026),
    *Metaprogramming Concepts*. They are an obvious choice for adding explicit metadata
    to your source code. This is what they are intended for. Attributes should not
    carry heavy logic with them and should be viewed as just metadata.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了 C# 属性的概念，见[*第2章*](B19418_02.xhtml#_idTextAnchor026)，*元编程概念*。它们是向源代码添加显式元数据的明显选择。这正是它们的目的。属性不应携带复杂的逻辑，而应被视为仅是元数据。
- en: In this chapter, we will look into how you can leverage them in your code base,
    providing mechanisms for adorning types and members with valuable, rich information
    that can be used for different scenarios.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在代码库中利用它们，提供为类型和成员添加有价值、丰富信息的机制，这些信息可用于不同的场景。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: What is an attribute and how can it be applied?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性是什么，以及如何应用它？
- en: Finding types with specific attributes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找具有特定属性的类型
- en: Generic attributes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型属性
- en: From this chapter, you should understand the power of attributes as a building
    block for metaprogramming, how to create your own custom attributes, and how you
    can discover them being used.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中，您应该了解属性作为元编程构建块的力量，如何创建自己的自定义属性，以及您如何发现它们的使用。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5))
    and it builds on top of the **Fundamentals** code, which is found at [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的特定源代码可以在 GitHub 上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter5)），并且它建立在**基础**代码之上，该代码位于[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Fundamentals)。
- en: What is an attribute and how can it be applied?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性是什么，以及如何应用它？
- en: An **attribute** is a special type that the C# compiler understands. It can
    be used to associate metadata to assemblies, types, and any member of a type.
    During compilation, the compiler will pick up the attributes and add them to the
    compiled assembly as metadata. You can place more than one attribute on every
    item.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**是 C# 编译器理解的特殊类型。它可以用来将元数据关联到程序集、类型以及类型的任何成员。在编译期间，编译器将拾取属性并将它们作为元数据添加到编译的程序集中。您可以在每个项目上放置多个属性。'
- en: 'Creating your own custom attribute is as simple as this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的自定义属性就像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then using it is done as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用它的方法如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that you create the attribute with the **Attribute** postfix in the name.
    While using it, you don’t need it and you only have **[Custom]**. The C# compiler
    has a convention built into it saying you have to have the postfix, but it will
    ignore it when it’s used. This is a little bit weird and definitely violates the
    principle of least surprise.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您在属性名称中使用**Attribute**后缀。在使用它时，您不需要它，您只需要**[Custom]**。C# 编译器内置了一个约定，即您必须使用后缀，但在使用时它将忽略它。这有点奇怪，并且肯定违反了最小惊讶原则。
- en: The nice thing about attributes is that they live outside the scope of the element
    itself, meaning that you don’t have to create an instance of the type with the
    metadata to access the metadata.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的优点在于它们存在于元素本身的范围之外，这意味着您不需要创建具有元数据的类型的实例来访问元数据。
- en: Attributes can take parameters to give them specific information you want to
    capture. However, all parameters must be available at compile time. This means
    you can’t create new objects dynamically for any of the parameters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以接受参数以提供您想要捕获的特定信息。然而，所有参数必须在编译时可用。这意味着您不能为任何参数动态创建新对象。
- en: 'For instance, we can add a parameter to the attribute by taking the instance
    of another type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过获取另一个类型的实例来向属性添加参数：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The compiler will allow the attribute to take the type – after all, it is a
    valid C# type. However, when you try to use it, you’re not allowed to create a
    new instance:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将允许属性接受类型——毕竟，它是一个有效的 C# 类型。然而，当您尝试使用它时，不允许您创建新实例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is because the compiler needs the values to be available at compile time.
    Even though attributes are ultimately instantiated at runtime, the information
    captured and added to the compiled assembly is never executed. This means that
    you’re limited to things the compiler can resolve, such as primitive types (for
    example, **int**, **float**, and **double**) and things such as strings – anything
    that can be represented as constants and not have to be created by the runtime
    to work.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器需要在编译时获取这些值。尽管属性最终是在运行时实例化的，但捕获并添加到编译后的汇编中的信息永远不会被执行。这意味着你只能限于编译器可以解析的事物，例如原始类型（例如，**int**、**float**
    和 **double**）以及诸如字符串之类的对象——任何可以表示为常量且不需要由运行时创建以工作的事物。
- en: 'A valid parameter could be a string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的参数可以是字符串：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the constructor now taking a string, it will work not just at compile time
    but also at runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构造函数接受一个字符串，它不仅会在编译时工作，也会在运行时工作。
- en: 'Since strings can be literal constants, you are allowed to use them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串可以是字面常量，你可以使用它们：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Already, you can see the power of attributes – the ability to have additional
    information sitting there that your code can reason about and you can use to make
    decisions or even use for reporting.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 已经，你可以看到属性的力量——能够拥有附加信息，你的代码可以据此进行推理，你可以用它来做决策，甚至用于报告。
- en: Limiting attribute usage
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制属性使用
- en: For attributes, you can also add metadata to them, which feels a little bit
    like inception; metadata for the metadata. The metadata that you add is to limit
    the scope of how the attribute can be used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性，你还可以向它们添加元数据，这有点像“自我包含”；元数据的元数据。你添加的元数据是为了限制属性的使用范围。
- en: You can be very specific about what elements in your code the attribute is for
    (class, property, field, and so on).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对代码中的哪些元素使用属性（类、属性、字段等）非常具体。
- en: 'The **[AttributeUsage]** attribute allows you to be specific about the attribute.
    Let’s say you want to limit the usage to only classes – you can do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**[AttributeUsage]** 属性允许你具体指定属性。假设你只想将使用限制为类——你可以这样做：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you then try to add the attribute to something else other than a class,
    you will get a compiler error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将属性添加到除类之外的其他事物上，你将得到一个编译器错误：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The **[AttributeUsage]** type is an enum holding different values for the different
    code elements attributes support. Every value in the enum represents a flag, making
    it possible to combine them and target multiple code element types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**[AttributeUsage]** 类型是一个枚举，包含支持不同代码元素属性的不同值。枚举中的每个值都代表一个标志，这使得它们可以组合起来并针对多个代码元素类型。'
- en: 'Let’s limit the code elements to **Class**, **Method**, and **Property** by
    applying the **[AttributeUsage]** attribute with these specified for the custom
    attribute:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过应用具有这些指定的自定义属性 **[AttributeUsage]** 属性来限制代码元素为 **Class**、**Method** 和 **Property**：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, using the bitwise **OR** construct (**|**) you can add all the
    elements you want to support.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用位运算符 **OR** 构造（**|**）你可以添加所有你想要支持的元素。
- en: A little fun fact about **[AttributeUsage]** is that it uses itself to tell
    the compiler that it can only be used for classes. Again, a little bit of inception
    there; the **[AttributeUsage]** attribute is using **[AttributeUsage]** to provide
    metadata about itself.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **[AttributeUsage]** 的一个有趣的事实是，它使用自身来告诉编译器它只能用于类。再次，那里有点“自我包含”；**[AttributeUsage]**
    属性正在使用 **[AttributeUsage]** 来提供关于自身的元数据。
- en: In addition to limiting the code elements an attribute can be associated with,
    you can also tell whether or not you allow multiple instances of the attribute
    to be applied. You can also specify whether or not you allow the attribute to
    be available as metadata for types inheriting from the type that has the attribute
    applied to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了限制属性可以关联的代码元素之外，你还可以指定是否允许应用属性的多个实例。你还可以指定是否允许属性作为具有该属性的应用类型的元数据。
- en: The **[AttributeUsage]** attribute does, however, only take one parameter in
    its constructor. That means we have to use its properties explicitly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**[AttributeUsage]** 属性在其构造函数中实际上只接受一个参数。这意味着我们必须显式地使用其属性。'
- en: 'By default, attributes are limited to only being associated once per code element
    type. Trying to associate the attribute more than once will give you a compiler
    error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，属性仅限于每个代码元素类型仅关联一次。尝试多次关联属性将会导致编译器错误：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This behavior can be changed by simply using the **AllowMultiple** property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用**AllowMultiple**属性，您可以改变这种行为：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compiling the same code will now be allowed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将允许编译相同的代码。
- en: 'The other property you can use for limiting the usage of the attributes is
    the **Inherited** property. Setting this to **false** will tell the compiler that
    the associated attribute is only the specific type it is being used explicitly
    and not for the derived type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**Inherited**属性来限制属性的用法。将此属性设置为**false**将告诉编译器，相关的属性仅与显式使用的特定类型相关联，而不是与派生类型相关联：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you saw earlier, you can add the attribute in a normal way to the class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您之前所见，您可以通过常规方式将属性添加到类中：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can add a class that inherits from the type with the **[Custom]** attribute
    applied to it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加一个继承自具有**[Custom]**属性的类型的类：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The metadata associated with the **MyClass** base type will not be associated
    with **MyOtherClass** when the **Inherited** property is set to **false**. This
    is, by default, turned on, meaning that the derived type will have the same metadata
    associated with it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当**Inherited**属性设置为**false**时，与**MyClass**基类型关联的元数据将不会与**MyOtherClass**关联。默认情况下，这是开启的，这意味着派生类型将具有与之关联的相同元数据。
- en: To create an attribute, inheriting from **Attribute** and applying **[AttributeUsage]**
    is all you need to do. However, you might want to bring more clarity and explicitness
    to your metadata by not allowing inheritance from your attribute. Sealing your
    class will disable anyone inheriting from your custom attribute.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个属性，您只需要从**Attribute**继承并应用**[AttributeUsage]**。然而，您可能希望通过不允许从您的属性继承来为您的元数据带来更多的清晰性和明确性。密封您的类将阻止任何人从您的自定义属性继承。
- en: Sealing your attribute class
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭您的属性类
- en: Since attributes represent specific metadata, they’re not a regular code construct
    that you use for holding logic. Therefore, you will find that you don’t need to
    create base attributes that other, more specific attributes inherit from. In fact,
    it could make your metadata unclear if you use inheritance as your metadata will
    lose explicitness and you would bring implicitness into it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性代表特定的元数据，它们不是用于存储逻辑的常规代码结构。因此，您会发现您不需要创建其他更具体属性继承的基属性。实际上，如果您使用继承作为元数据，可能会使元数据变得不清晰，并且您会引入隐含性。
- en: 'Because of this, it is considered good practice to not allow for the inheritance
    of attributes and stop it at a compiler level by making the attribute class **sealed**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，被认为是一个好的实践，不允许属性的继承，并在编译器级别通过使属性类**密封**来停止它：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you then try to create a more specific attribute that inherits from it, you
    will get a compiler error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试创建一个继承自它的更具体属性，您将得到编译器错误。
- en: Now that we’ve covered all the mechanics involved in creating custom attributes
    and how you can make them very specific to your use case, you are probably eager
    to start actually discovering them and putting them to good use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了创建自定义属性及其如何针对您的特定用例进行定制所涉及的所有机制，您可能已经迫不及待地想要开始实际发现它们并将它们用于良好的用途。
- en: Finding types with specific attributes
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找具有特定属性的类型
- en: Since attributes are created at compile time and do not require you to have
    an instance of a type that has been associated with attributes, you can discover
    attributes using the type system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性是在编译时创建的，并且不需要您有一个与属性关联的类型实例，您可以使用类型系统来发现属性。
- en: If you look at the **System.Type** type, you’ll see that it implements a type
    called **MemberInfo** that sits in the **System.Reflection** namespace. This base
    class serves as the base class for **PropertyInfo**, **MethodInfo**, **FieldInfo**,
    and most of the specific info types representing code elements we can discover
    through the type system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看**System.Type**类型，您会发现它实现了一个名为**MemberInfo**的类型，该类型位于**System.Reflection**命名空间中。这个基类作为**PropertyInfo**、**MethodInfo**、**FieldInfo**以及大多数代表我们可以通过类型系统发现的代码元素的特定信息类型的基类。
- en: On the **MemberInfo** type, you find a method called **GetCustomAttributes()**.
    This lets you get a collection of attributes associated with the particular code
    element.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在**MemberInfo**类型上，您会发现一个名为**GetCustomAttributes()**的方法。这允许您获取与特定代码元素关联的属性集合。
- en: 'Take the class we had before:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前拥有的类：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can then quite easily get to the custom attributes on a type and loop through
    them and perform the actions you want to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以非常容易地获取类型上的自定义属性，遍历它们并执行您想要的操作：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using **typeof()** is very explicit and can be used just for this type. For
    a more dynamic solution, you can discover what types have a specific attribute,
    which you can leverage for the work we did in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types* *Using Reflection*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **typeof()** 非常明确，并且可以仅用于此类型。对于更动态的解决方案，你可以发现具有特定属性的类型，你可以利用这些属性来完成我们在 [*第
    4 章*](B19418_04.xhtml#_idTextAnchor059)，[*“使用反射进行类型推理”*] 中所做的 **“类型推理”** 工作。
- en: Personal Identifiable Information (PII)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人可识别信息 (PII)
- en: Let’s go back to the GDPR theme we touched on in previous chapters. In [*Chapter
    4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using Reflection*,
    we used types to discover what was personally identifiable information. Another
    approach could be to use custom attributes as an explicit metadata approach. With
    attributes, we can associate more than what we did with a base type in [*Chapter
    4*](B19418_04.xhtml#_idTextAnchor059), *Reasoning about Types Using Reflection*.
    You can add metadata about the reason for collecting the data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到之前章节中提到的 GDPR 主题。在 [*第 4 章*](B19418_04.xhtml#_idTextAnchor059)，[*“使用反射进行类型推理”*]
    中，我们使用类型来发现哪些是个人可识别信息。另一种方法可能是使用自定义属性作为显式的元数据方法。通过属性，我们可以关联比我们在 [*第 4 章*](B19418_04.xhtml#_idTextAnchor059)，[*“使用反射进行类型推理”*]
    中使用的基本类型更多的信息。你可以添加关于收集数据原因的元数据。
- en: 'You can capture this with an attribute like the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下属性来捕获它：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code creates an attribute that can be applied to classes, properties, and
    parameters. It does not allow multiple instances of itself to be applied to the
    code element it will be applied to. It allows the metadata to be available for
    any type that inherits from the type that has this metadata applied to it or its
    members. One of the things it is interesting to know about GDPR is the reason
    the system collects specific data – the attribute, therefore, has this as optional
    metadata.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个可以应用于类、属性和参数的属性。它不允许将多个实例应用于将要应用到的代码元素。它允许元数据对任何继承自应用了此元数据的类型或其成员的类型都可用。关于
    GDPR，有趣的是了解系统收集特定数据的原因——因此，属性作为可选元数据具有这个功能。
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You’ll find this implementation in the **Fundamentals** project in the GitHub
    repository.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中的 **Fundamentals** 项目中找到这个实现。
- en: 'Start by creating a folder called [*Chapter 5*](B19418_05.xhtml#_idTextAnchor083).
    Change into this folder in your command-line interface and create a new console
    project:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为 [*第 5 章*](B19418_05.xhtml#_idTextAnchor083) 的文件夹。在命令行界面中切换到该文件夹并创建一个新的控制台项目：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next thing you’ll need to do is to reference the Fundamentals project.
    If you have the project next to the **Chapter5** folder, do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你需要做的是引用 Fundamentals 项目。如果你将项目放在 **Chapter5** 文件夹旁边，请执行以下操作：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With that in place, let’s say you want to create an object that encapsulates
    an employee:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，假设你想要创建一个封装员工的对象：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This type clearly holds properties that would be identifiable for the person;
    let’s add the appropriate metadata for its members:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型显然持有对个人可识别的属性；让我们为其成员添加适当的元数据：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this, we now have enough information to discover any type in the system
    that holds this type of information.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了足够的信息来发现系统中任何持有此类信息的类型。
- en: Building on the assembly and type discovery system introduced in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, we can query specifically for this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 **第 4 章** 中引入的汇编和类型发现系统，[*“使用反射进行类型推理”*](B19418_04.xhtml#_idTextAnchor059)，我们可以专门查询这个。
- en: Since every member on a type inherits from the **MemberInfo** type found in
    the **System.Reflection** namespace, we can easily create a convenience extension
    method allowing us to check whether a member has a specific attribute associated
    with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型上的每个成员都继承自 **System.Reflection** 命名空间中找到的 **MemberInfo** 类型，我们可以轻松创建一个便利的扩展方法，允许我们检查成员是否具有与其关联的特定属性。
- en: 'You can then create a simple extension method that allows you to check whether
    an attribute is associated with a member:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个简单的扩展方法，允许你检查属性是否与成员关联：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Important note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You’ll find this implementation in the **Fundamentals** project in the GitHub
    repository.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中的 **Fundamentals** 项目中找到这个实现。
- en: 'With this in place, you can discover all the types with this information:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，你可以发现所有包含此类信息的类型：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **HasAttribute<>** extension method is a powerful little helper that you’ll
    find handy in all scenarios where you want to do simple querying of type metadata
    based on attributes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**HasAttribute<>** 扩展方法是一个强大的小助手，你会在所有想要根据属性进行简单类型元数据查询的场景中找到它。'
- en: 'To create a GDPR report with the reason for collecting information, change
    the **Program.cs** file look like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含收集信息原因的 GDPR 报告，将 **Program.cs** 文件修改如下：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code leverages the type discovery introduced in [*Chapter 4*](B19418_04.xhtml#_idTextAnchor059),
    *Reasoning about Types Using Reflection*, and uses LINQ extension methods to select
    all the types that have properties with **[PersonalIdentifiableInformationAttribute]**
    applied. It then groups them by type so that you can easily loop through and present
    the members with the attribute per type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码利用了在 [*第4章*](B19418_04.xhtml#_idTextAnchor059) 中引入的类型发现，*使用反射进行类型推理*，并使用 LINQ
    扩展方法选择所有应用了 **[PersonalIdentifiableInformationAttribute]** 属性的类型。然后按类型分组，这样你可以轻松地遍历并按类型展示具有该属性的成员。
- en: 'Running this will yield the following result:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下结果：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This type of metadata is very valuable for a business. If your business gets
    a query from the government about a GDPR audit, with your code fully loaded with
    metadata you can easily create a report on what type of data you’re collecting
    and the reason for collecting it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的元数据对商业来说非常有价值。如果你的业务收到政府关于 GDPR 审计的查询，并且你的代码完全加载了元数据，你可以轻松地创建一份关于你收集的数据类型及其收集原因的报告。
- en: You could also present this type of information to the end users of your system.
    It is very valuable for a user to know what the system collects about them. This
    builds a trusting relationship between the system and your users.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将此类信息展示给系统最终用户。了解系统收集关于他们的信息对用户来说非常有价值。这建立了系统与用户之间的信任关系。
- en: GDPR is a very good use case for getting very useful metadata into your code
    base, but it is just one of many use cases. You can, of course, make use of metadata
    in a more actionable way other than just for reporting.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GDPR 是将非常有用的元数据引入代码库的一个非常好的用例，但它只是众多用例之一。当然，你可以以更可操作的方式利用元数据，而不仅仅是用于报告。
- en: Generic attributes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型属性
- en: One of the limitations of C# attributes that we used to have is that attributes
    could not be generic types taking generic arguments. Prior to C# 11, you would
    get a compiler error if you added a generic argument to your attribute class.
    This limitation is lifted with the release of **C# 11**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 C# 属性的一个限制是属性不能是接受泛型参数的泛型类型。在 C# 11 之前，如果你在你的属性类中添加了泛型参数，你会得到编译器错误。这种限制随着
    C# 11 的发布而被解除。
- en: 'Up till C# 11, the only way you could collect type information was for the
    attribute to have parameters or properties that were of type **System.Type**.
    This became very verbose:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一直到 C# 11，你收集类型信息的方式只有当属性有参数或属性类型为 **System.Type** 时。这变得非常冗长：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And then adorning a type with the attribute would be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用属性装饰类型的方式如下：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With C# 11, now you can improve how you get type information:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 11，现在你可以改进获取类型信息的方式：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you adorn a type with the attribute, you use the generic argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用属性装饰类型时，你使用泛型参数：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you’re looking to have a parameter that is dynamic in type, you can do the
    following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个动态类型的参数，你可以这样做：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code defines an attribute that takes a generic argument and it then requires
    a parameter for the attribute, which will then be of the generic type. It then
    uses the same generic type when exposing the metadata as a property on the attribute.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个接受泛型参数的属性，然后要求属性有一个参数，该参数将是泛型类型。然后它使用相同的泛型类型在属性上公开元数据作为属性。
- en: 'When adorning types with the attribute, you specify the type and the parameter
    because the attribute has to be of the type specified:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当用属性装饰类型时，你指定类型和参数，因为属性必须是指定类型：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Important note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Normally the C# compiler is very good at inferring the type for generic arguments
    based on the type passed in. But with generic attributes, you have to explicitly
    give it the generic type every time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C# 编译器非常擅长根据传入的类型推断泛型参数的类型。但使用泛型属性时，你必须每次都显式地给出泛型类型。
- en: Generic attributes can be another powerful metadata collection approach. It
    adds flexibility to how you can construct your metadata.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型属性可以是一种强大的元数据收集方法。它增加了你构建元数据的方式的灵活性。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve looked at what C# attributes are and how powerful they
    are for describing explicit metadata in your code. We’ve looked at all the mechanics
    of how you can create your own custom attributes and apply them very to different
    code elements. From this type of metadata, you can now enrich your code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C#属性是什么以及它们在描述代码中的显式元数据方面的强大功能。我们研究了如何创建自己的自定义属性并将它们应用到不同的代码元素上的一切机制。从这种类型的元数据中，你现在可以丰富你的代码。
- en: With the enrichment looked at in this chapter, you’ve seen how you can quite
    easily discover this metadata and put it to good use for your business.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章探讨的丰富内容，你看到了如何非常容易地发现这种元数据并将其用于你的业务。
- en: In our next chapter, we will dive further into the capabilities of the .NET
    runtime and look at how you can dynamically generate code based on metadata, making
    you more productive as a developer in doing so.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步深入探讨.NET运行时的功能，并查看你如何根据元数据动态生成代码，这样可以使你在作为开发者进行这项工作时更加高效。
