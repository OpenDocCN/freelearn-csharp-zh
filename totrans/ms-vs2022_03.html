<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-52">
    <a id="_idTextAnchor052">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-53">
    <a id="_idTextAnchor053">
    </a>
    
     Advanced Code Analysis and Refactoring
    
   </h1>
   <p>
    
     This chapter elevates our skills by focusing on advanced code analysis and refactoring techniques in Visual
    
    
     
      Studio 2022.
     
    
   </p>
   <p>
    
     Understanding the fundamentals of code analysis, particularly through the lens of static code analysis powered by Roslyn, lays a robust foundation for identifying vulnerabilities and ensuring code correctness.
    
    
     Moreover, with built-in IntelliCode, which harnesses machine learning to optimize code bases, you’ll learn how to enhance maintainability and
    
    
     
      scalability effectively.
     
    
   </p>
   <p>
    
     Beyond these foundational concepts, we’ll also delve into the importance of code metrics, providing invaluable insights into evaluating the maintainability and security postures of your projects.
    
    
     By using these metrics, you’ll gain the strategic foresight required to make informed decisions and enact targeted enhancements to your
    
    
     
      code base.
     
    
   </p>
   <p>
    
     Throughout this chapter, I’ll illustrate these concepts with real-world code review refactoring case studies.
    
    
     By exploring the practical applications of Visual Studio tools, you’ll not only grasp theoretical concepts but also understand how to implement them effectively in your day-to-day
    
    
     
      development workflows.
     
    
   </p>
   <p>
    
     By the end of this chapter, you’ll emerge equipped with the knowledge and required tools to elevate the quality of your code, enhance security practices, and streamline maintenance efforts—all within the familiar and powerful environment of
    
    
     
      Visual Studio.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding code analysis in
     
     
      
       Visual Studio
      
     
    </li>
    <li>
     
      Utilizing static code analysis for quality assurance
     
     
      
       and security
      
     
    </li>
    <li>
     
      Leveraging IntelliCode for
     
     
      
       code refactoring
      
     
    </li>
    <li>
     
      Using code metrics for maintainability
     
     
      
       and security
      
     
    </li>
    <li>
     
      Refactoring
     
     
      
       case studies
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-54">
    <a id="_idTextAnchor054">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following version of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022,
     
     
      
       version
      
     
     
      
       17.12.0
      
     
    </li>
    <li>
     
      
       Preview 1.0
      
     
    </li>
   </ul>
   <p>
    
     The code files for this chapter can be found
    
    
     
      at
     
    
    <a href="https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03">
     
      
       https://github.com/PacktPublishing/Mastering-Visual-Studio-2022/tree/main/ch03
      
     
    </a>
   </p>
   <h1 id="_idParaDest-55">
    <a id="_idTextAnchor055">
    </a>
    
     Understanding code analysis in Visual Studio
    
   </h1>
   <p>
    
     First, let’s discuss how Visual Studio and .NET work to analyze
    
    
     
      our code.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Code analysis
     
    </strong>
    
     in Visual Studio 2022 is designed to help
    
    <a id="_idIndexMarker183">
    </a>
    
     us improve the quality of our code.
    
    
     It provides several tools and metrics to analyze and enhance code maintainability, readability, and performance.
    
    
     By identifying potential issues and suggesting improvements, it aims to streamline the development process, reduce bugs, and improve overall
    
    
     
      code quality.
     
    
   </p>
   <p>
    
     Visual Studio 2022 can perform code analysis in two
    
    
     
      primary ways:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Legacy analysis (FxCop static analysis)
      
     </strong>
     
      : This method analyzes compiled code to identify issues.
     
     
      It’s an old
     
     <a id="_idIndexMarker184">
     </a>
     
      approach that
     
     <a id="_idIndexMarker185">
     </a>
     
      only checks the code after it has
     
     
      
       been compiled.
      
     
    </li>
    <li>
     <strong class="bold">
      
       .NET Compiler Platform-based code analyzers
      
     </strong>
     
      : These are modern analyzers that analyze your code live as you
     
     <a id="_idIndexMarker186">
     </a>
     
      type.
     
     
      They are dynamic
     
     <a id="_idIndexMarker187">
     </a>
     
      and can provide real-time feedback, making it easier to catch and fix issues early in the
     
     
      
       development process.
      
     
    </li>
   </ul>
   <p>
    
     Now, let’s delve into the .NET Compiler
    
    <a id="_idIndexMarker188">
    </a>
    
     Platform, also known as
    
    <strong class="bold">
     
      Roslyn
     
    </strong>
    
     , which revolutionizes code analysis capabilities in Visual Studio 2022.
    
    
     Roslyn is a platform that exposes the C# and Visual Basic compilers’ code analysis capabilities to developers.
    
    
     It provides a set of APIs that allow the creation of tools and applications focused on code analysis, refactoring,
    
    
     
      and transformation.
     
    
   </p>
   <p>
    
     Here’s some benefit
    
    
     
      of Roslyn:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Rich language support
      
     </strong>
     
      : Roslyn supports the C# and Visual Basic languages, providing comprehensive language
     
     <a id="_idIndexMarker189">
     </a>
     
      features and syntax support for building custom developer tools
     
     
      
       and extensions.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Programmatic code manipulation
      
     </strong>
     
      : With Roslyn, we can programmatically analyze, refactor, and generate code using .NET APIs, empowering them to automate repetitive tasks and improve code quality
     
     
      
       and consistency.
      
     
    </li>
    <li>
     <strong class="bold">
      
       IDE extensibility
      
     </strong>
     
      : Roslyn enables the development of custom IDE extensions and tools that enhance the functionality of Visual Studio and other .NET IDEs, extending their capabilities to support specialized workflows and
     
     
      
       development scenarios.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Open source community
      
     </strong>
     
      : Roslyn is an open source project hosted on GitHub that fosters collaboration and contributions from the developer community.
     
     
      Developers can contribute enhancements, bug fixes, and new features to the Roslyn code base, driving the innovation and evolution of
     
     
      
       the platform.
      
     
    </li>
   </ul>
   <p>
    
     Roslyn significantly reduces the difficulty of creating tools and applications focused on code, paving the way for innovation in various domains, including meta-programming, generating and transforming code, integrating interactive features into C# and Visual Basic languages, and embedding these languages into
    
    
     
      specialized domains.
     
    
   </p>
   <h2 id="_idParaDest-56">
    <a id="_idTextAnchor056">
    </a>
    
     How Roslyn works
    
   </h2>
   <p>
    
     Roslyn revolutionizes the
    
    <a id="_idIndexMarker190">
    </a>
    
     traditional compiler structure by decomposing it into distinct components.
    
    
     Moreover, it provides access to each phase of the compiler pipeline through APIs that mirror the compiler’s
    
    
     
      internal processes.
     
    
   </p>
   <p>
    
     Here’s an illustration of how this mirroring
    
    
     
      is organized:
     
    
   </p>
   <div><div><img alt="Figure 3.1 – Compiler API and Complier Pipeline" src="img/B22218_03_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1 – Compiler API and Complier Pipeline
    
   </p>
   <p>
    
     The compiler API and compiler pipeline provide access to several
    
    
     
      key phases:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Parse Phase
      
     </strong>
     
      : Source code undergoes tokenization and parsing, resulting in a syntax tree that adheres to the
     
     <a id="_idIndexMarker191">
     </a>
     
      
       language’s grammar.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Declaration Phase
      
     </strong>
     
      : Declarations
     
     <a id="_idIndexMarker192">
     </a>
     
      from both source code and imported metadata are analyzed to construct named symbols.
     
     
      These symbols are organized into a hierarchical
     
     
      
       symbol table.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Bind Phase
      
     </strong>
     
      : Identifiers within the code
     
     <a id="_idIndexMarker193">
     </a>
     
      are matched to symbols, generating a semantic model that reflects the
     
     
      
       compiler’s analysis.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Emit Phase
      
     </strong>
     
      : The compiler accumulates
     
     <a id="_idIndexMarker194">
     </a>
     
      all relevant information and emits it as an assembly.
     
     
      This assembly is represented through an API that
     
     <a id="_idIndexMarker195">
     </a>
     
      produces
     
     <strong class="bold">
      
       Intermediate Language
      
     </strong>
     
      (
     
     <strong class="bold">
      
       IL
      
     </strong>
     
      )
     
     
      
       byte code.
      
     
    </li>
   </ul>
   <p>
    
     This modular approach grants comprehensive access to information at each stage of the compiler pipeline.
    
    
     It empowers developers with rich capabilities for code analysis and manipulation.
    
    
     The availability of three-phase compiler APIs (syntax trees, semantic model, and workspace level) is particularly instrumental in facilitating robust
    
    
     
      code analysis.
     
    
   </p>
   <p>
    
     First, the
    
    <strong class="bold">
     
      syntax trees
     
    </strong>
    
     serve as a foundational
    
    <a id="_idIndexMarker196">
    </a>
    
     representation of the structure of source code, encompassing both lexical and syntactic elements.
    
    
     They are pivotal in various stages of software development, including compilation, code analysis, binding, refactoring, and IDE functionalities.
    
    
     Offering a complete reflection of the source information, syntax trees maintain fidelity with the original text, ensuring immutability and thread safety.
    
    
     This facilitates the natural manipulation of source code without direct
    
    
     
      textual edits.
     
    
   </p>
   <p>
    
     Moving to semantics, the
    
    <strong class="bold">
     
      semantic model
     
    </strong>
    
     delves
    
    <a id="_idIndexMarker197">
    </a>
    
     deeper into the meaning behind the code.
    
    
     It captures all semantic details within a single source file, shedding light on symbol references, expression types, diagnostics (errors and warnings), variable flow within source regions, and other nuanced aspects.
    
    
     By encapsulating language rules, this model enables clear distinctions between program elements in source code and those from
    
    
     
      precompiled libraries.
     
    
   </p>
   <p>
    
     At the workspace level, a central hub organizes information across entire solutions, streamlining code analysis and refactoring processes.
    
    
     This layer consolidates project data into a cohesive object model, offering seamless access to compiler layer object models without the need for file parsing, configuration adjustments, or inter-project dependency management.
    
    
     Crucially, it underpins the development of robust code analysis and refactoring tools within integrated development environments such as
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-57">
    <a id="_idTextAnchor057">
    </a>
    
     How does Visual Studio 2022 use Roslyn?
    
   </h2>
   <p>
    
     Visual Studio 2022 uses the .NET
    
    <a id="_idIndexMarker198">
    </a>
    
     Compiler Platform (Roslyn) to analyze and refactor C# or Visual Basic code in real time as developers write code.
    
    
     This process is integrated into the development environment, providing
    
    <a id="_idIndexMarker199">
    </a>
    
     immediate feedback on code style, quality, maintainability, design, and other issues.
    
    
     In the subsequent sections, we’ll learn how Visual Studio 2022 utilizes Roslyn for analysis
    
    
     
      and refactoring.
     
    
   </p>
   <h3>
    
     Analyzing with Roslyn analyzers
    
   </h3>
   <p>
    
     Visual Studio 2022 includes built-in code style analyzers (IDExxxx, e.g., IDE0001) and code quality analyzers (CAxxxx, e.g., CA1822) that inspect your code during design time in all open files.
    
    
     These analyzers are part of the .NET 5 SDK and are enabled
    
    
     
      by default.
     
    
   </p>
   <p>
    
     We can install external
    
    <a id="_idIndexMarker200">
    </a>
    
     analyzers, such as
    
    <strong class="bold">
     
      StyleCop
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Roslynator
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      XUnit Analyzers
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      SonarAnalyzer
     
    </strong>
    
     , as NuGet packages
    
    <a id="_idIndexMarker201">
    </a>
    
     or Visual Studio extensions.
    
    
     These
    
    <a id="_idIndexMarker202">
    </a>
    
     analyzers extend the built-in
    
    <a id="_idIndexMarker203">
    </a>
    
     capabilities, allowing more specialized checks
    
    
     
      and rules.
     
    
   </p>
   <p>
    
     Furthermore, we
    
    <a id="_idIndexMarker204">
    </a>
    
     create our own custom analyzer using the
    
    <strong class="bold">
     
      Analyzer with Code Fix
     
    </strong>
    
     template, which includes a
    
    <a id="_idIndexMarker205">
    </a>
    
     VSIX extension and a separate project for the analyzer.
    
    
     This can be deployed via NuGet.
    
    
     That allows us to create our own custom analyzer.
    
    
     The analyzer can show a squiggly line below the matching code and an entry in the error list, with optional code fixes.
    
    
     This approach allows a more integrated development experience, with feedback and fixes available directly within
    
    
     
      the IDE.
     
    
   </p>
   <p>
    
     For scenarios where analysis does not require integration with Visual Studio, such as on a build server, we can use the
    
    <strong class="bold">
     
      Standalone Code Analysis Tool
     
    </strong>
    
     template.
    
    
     This tool opens a solution workspace and analyzes
    
    <a id="_idIndexMarker206">
    </a>
    
     projects without requiring VSIX extensions or NuGet packages to be installed in the project
    
    
     
      or IDE.
     
    
   </p>
   <h3>
    
     Refactoring with Roslyn
    
   </h3>
   <p>
    
     Roslyn’s Syntax API parses C# code into a tree of nodes (class nodes, method nodes, etc.), enabling detailed manipulation of the code structure.
    
    
     This API is crucial for automating code refactoring, such as
    
    <a id="_idIndexMarker207">
    </a>
    
     automating the migration of applications to .
    
    
     
      NET Core.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      SyntaxEditor
     
    </strong>
    
     class is used to apply changes to the code tree.
    
    
     It ensures that when a node is replaced or deleted, all its child nodes are updated accordingly, avoiding contention and exceptions.
    
    
     This is particularly useful for refactoring scripts that need to modify the code based on certain patterns
    
    
     
      or rules.
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Code Refactoring
     
    </strong>
    
     template in Visual Studio
    
    <a id="_idIndexMarker208">
    </a>
    
     allows the creation of a VSIX extension that integrates with the
    
    <strong class="bold">
     
      Quick Actions
     
    </strong>
    
     menu in the IDE.
    
    
     This enables developers to apply quick code fixes directly from the editor without needing to define additional analyzer IDs or show entries in the
    
    
     
      error list.
     
    
   </p>
   <p>
    
     Now that we have learned how Visual Studio uses Roslyn to help us analyze and refactor our code, let’s dive deeper into the use of static code analysis for quality assurance
    
    
     
      and security.
     
    
   </p>
   <h1 id="_idParaDest-58">
    <a id="_idTextAnchor058">
    </a>
    
     Utilizing static code analysis for quality assurance and security
    
   </h1>
   <p>
    
     The built-in
    
    <strong class="bold">
     
      code quality analysis
     
    </strong>
    
     feature is enabled by default in Visual Studio for projects that target .NET 5 or later.
    
    
     However, we can
    
    <a id="_idIndexMarker209">
    </a>
    
     enable it for our older .NET project adding and
    
    <a id="_idIndexMarker210">
    </a>
    
     setting to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     the
    
    <strong class="source-inline">
     
      EnabeNETAnalyzers
     
    </strong>
    
     property in the
    
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       csproj
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     Static code analysis fosters a culture of continuous improvement and collaboration within development teams.
    
    
     By providing actionable insights and recommendations, these tools facilitate constructive code reviews, foster knowledge sharing, and ultimately elevate the skill and proficiency
    
    
     
      of developers.
     
    
   </p>
   <h2 id="_idParaDest-59">
    <a id="_idTextAnchor059">
    </a>
    
     Understanding how to use code analysis in Visual Studio
    
   </h2>
   <p>
    
     The code quality analysis will inspect our
    
    <a id="_idIndexMarker211">
    </a>
    
     codebase for security, performance, design, and other potential areas for improvement.
    
    
     By default, the analysis runs automatically, so we can see errors, warnings, and information directly when we are typing through squiggles under our code or on the error
    
    
     
      list windows.
     
    
   </p>
   <p>
    
     If we write code like the one shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     , we will see
    
    
     
      squiggles appear:
     
    
   </p>
   <div><div><img alt="Figure 3.2 – Information squiggles" src="img/B22218_03_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.2 – Information squiggles
    
   </p>
   <p>
    
     In this example, the analyzer informs us that our
    
    <strong class="source-inline">
     
      using
     
    </strong>
    
     statement can be simplified according to the feature introduced by
    
    
     
      C# 8.0.
     
    
   </p>
   <p>
    
     The analysis rules are organized into categories: Design, Documentation, Globalization, Portability and Interoperability, Maintainability, Naming, Performance, Reliability, Security, Style, and Usage.
    
    
     You can find detailed information about each rule category in the Microsoft
    
    
     
      documentation:
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories">
     
      
       https://learn.microsoft.com/en-us/dotnet/fundamentals/code-analysis/categories
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Each rule has a severity
    
    <a id="_idIndexMarker212">
    </a>
    
     level that determines
    
    
     
      its behavior:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Default
      
     </strong>
     
      : This is the default severity level for rules that are enabled but do not have a specific severity set.
     
     
      It typically means that the rule is active and will report issues, but the exact behavior (e.g., whether it’s treated as a warning, error, or suggestion) depends on the rule’s configuration or the default behavior of
     
     
      
       the tool.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Error
      
     </strong>
     
      : When a rule is set to the Error severity level, any violation of the rule will be reported as an error.
     
     
      This means that the code will not be compiled until the issue is resolved.
     
     
      Errors are typically used for critical issues that must be fixed before the code can be
     
     
      
       considered correct.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Warning
      
     </strong>
     
      : A rule set to Warning will report violations as warnings.
     
     
      Warnings do not prevent the code from compiling, but they are typically used to indicate potential issues that should be addressed to improve code quality or maintainability.
     
     
      Warnings can be configured to be treated as errors in certain build configurations, allowing developers to enforce stricter standards for
     
     
      
       production code.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Suggestion
      
     </strong>
     
      : Rules with the Suggestion severity level report issues that are not critical but could improve the code.
     
     
      These rules are typically used for stylistic issues or practices that are not required but are recommended.
     
     
      Suggestions are often used in conjunction with code fixes that automatically apply the recommended changes, making it easier for developers to improve their
     
     
      
       code quality.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Silent
      
     </strong>
     
      : A rule set to Silent will not report any issues, effectively disabling the rule.
     
     
      This is useful for rules that are not relevant to your project or when you want to temporarily disable a rule without removing it from
     
     
      
       your configuration.
      
     
    </li>
    <li>
     <strong class="bold">
      
       None
      
     </strong>
     
      : This severity
     
     <a id="_idIndexMarker213">
     </a>
     
      level is like Silent but is used to explicitly indicate that a rule should not be applied.
     
     
      It’s a way to make the intention clear that the rule is
     
     
      
       intentionally disabled.
      
     
    </li>
   </ul>
   <p>
    
     Let’s see how we can use the level of severity to enhance the quality of
    
    
     
      our project.
     
    
   </p>
   <h2 id="_idParaDest-60">
    <a id="_idTextAnchor060">
    </a>
    
     Adjusting the level of severity
    
   </h2>
   <p>
    
     We can adjust the severity level of rules by right-clicking on the suggestion through the
    
    <strong class="bold">
     
      Error List
     
    </strong>
    
     and selecting
    
    
     <strong class="bold">
      
       Set Severity
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     This allows us to prioritize and
    
    <a id="_idIndexMarker214">
    </a>
    
     customize how Visual Studio presents and addresses potential issues identified by the rules.
    
    
     Depending on the project’s requirements and development context, adjusting the severity levels can focus attention on critical issues while minimizing distractions from less
    
    
     
      impactful ones.
     
    
   </p>
   <div><div><img alt="Figure 3.3 – The Set severity option" src="img/B22218_03_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.3 – The Set severity option
    
   </p>
   <p>
    
     This action generates an
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     file in our solution’s root containing the overridden severity rule, which we can share with our team to ensure consistent
    
    
     
      coding practices.
     
    
   </p>
   <div><div><img alt="Figure 3.4 – .editorconfig file generated" src="img/B22218_03_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.4 – .editorconfig file generated
    
   </p>
   <p>
    
     An alternative method of
    
    <a id="_idIndexMarker215">
    </a>
    
     adjusting the severity level is through the
    
    <em class="italic">
     
      light bulb
     
    </em>
    
     context menu, which also offers code fixes through
    
    
     
      Quick Actions.
     
    
   </p>
   <div><div><img alt="Figure 3.5 – Setting the severity using the light bulb" src="img/B22218_03_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.5 – Setting the severity using the light bulb
    
   </p>
   <p>
    
     During a code review, we
    
    <a id="_idIndexMarker216">
    </a>
    
     might encounter practices that could be improved, as shown in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .6
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.6 – Pyramid code" src="img/B22218_03_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.6 – Pyramid code
    
   </p>
   <p>
    
     For instance, a pyramid code
    
    <a id="_idIndexMarker217">
    </a>
    
     structure might not trigger a squiggle, but the IDE might suggest simplifying an
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statement (
    
    <strong class="source-inline">
     
      IDE0046
     
    </strong>
    
     ).
    
    
     If you want to enforce a specific coding standard, you can set the severity level of this rule
    
    
     
      to
     
    
    
     <strong class="bold">
      
       Error
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.7 – Change the severity level of IDE0046" src="img/B22218_03_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.7 – Change the severity level of IDE0046
    
   </p>
   <p>
    
     Likewise, when we and our teammates encounter this rule, we are forced to refactor our code.
    
    
     We can notice that Visual Studio provides four code fixes for
    
    
     
      this Rule:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Convert to a conditional expression
      
     </strong>
     
      : This fix transforms an
     
     <strong class="source-inline">
      
       if-else
      
     </strong>
     
      statement into a conditional (
     
     
      
       ternary) expression.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Invert if
      
     </strong>
     
      : This fix inverts the condition of an if statement and swaps the
     
     
      
       code blocks.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Convert to a switch statement
      
     </strong>
     
      : This fix is applicable when you have multiple conditions based on the same variable or expression.
     
     
      It converts an if-else chain into a switch statement, which is more readable and maintainable for such case, like handling multiple conditions based on the
     
     
      
       same variable.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Convert to a switch expression
      
     </strong>
     
      : Like converting to a
     
     <strong class="source-inline">
      
       switch
      
     </strong>
     
      statement, this fix converts an
     
     <strong class="source-inline">
      
       if-else
      
     </strong>
     
      chain into a
     
     <strong class="source-inline">
      
       switch
      
     </strong>
     
      expression, which is a more concise and functional way to handle multiple conditions.
     
     
      It’s available in C# 8.0
     
     
      
       and later.
      
     
    </li>
   </ul>
   <p>
    
     For better readability, I prefer to
    
    <a id="_idIndexMarker218">
    </a>
    
     use Invert if in this example, but the IDE0046 rule force is used to turn it into a conditional expression.
    
    
     Keep in mind that this is just an example, and we can adapt the level of severity of the analysis rules in our solution according to
    
    
     
      our needs.
     
    
   </p>
   <p>
    
     As we have seen, adjusting the severity level generates a
    
    <strong class="source-inline">
     
      .editorConfig
     
    </strong>
    
     file containing our custom configurations.
    
    
     Let’s explore how we can generate such a file to easily share our Visual Studio settings with
    
    
     
      our team.
     
    
   </p>
   <h2 id="_idParaDest-61">
    <a id="_idTextAnchor061">
    </a>
    
     Generating a .editorconfig file
    
   </h2>
   <p>
    
     What I recommend if you work in a
    
    <a id="_idIndexMarker219">
    </a>
    
     team environment is
    
    <a id="_idIndexMarker220">
    </a>
    
     to generate a
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     file that you can tweak according to
    
    
     
      your needs.
     
    
   </p>
   <p>
    
     To generate a
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     file, we
    
    <em class="italic">
     
      right-click
     
    </em>
    
     on our solution, and in the contextual menu, select
    
    <strong class="bold">
     
      Add
     
    </strong>
    
     |
    
    <strong class="bold">
     
      New
     
    </strong>
    
     <strong class="bold">
      
       Editor Config
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.8 – New EditorConfig" src="img/B22218_03_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.8 – New EditorConfig
    
   </p>
   <p>
    
     This will generate a new
    
    <a id="_idIndexMarker221">
    </a>
    
     file that will contain all configurations of our IDE.
    
    
     In this file, we will retrieve all the rules of
    
    
     
      the
     
    
    
     <strong class="bold">
      
       Analyzer
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.9 – EditorConfig Analyzer" src="img/B22218_03_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.9 – EditorConfig Analyzer
    
   </p>
   <p>
    
     This allows us to list and set the severity level of each
    
    
     
      rule easily.
     
    
   </p>
   <p>
    
     Here, we can see that Visual
    
    <a id="_idIndexMarker222">
    </a>
    
     Studio Analyzer provides 94 rules about security.
    
    
     These rules cover all the topics of the OWASP Top Ten and more.
    
    
     The OWASP Top 10 serves as a widely recognized reference
    
    <a id="_idIndexMarker223">
    </a>
    
     document for developers and web application security, highlighting the most significant security vulnerabilities faced by web applications based on a collective agreement within
    
    
     
      the industry.
     
    
   </p>
   <p class="callout-heading">
    
     Further reading
    
   </p>
   <p class="callout">
    
     We can find all the security rules in
    
    
     
      Microsoft documentation:
     
    
   </p>
   <p class="callout">
    <a href="https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&amp;viewFallbackFrom=vs-2022">
     
      
       https://learn.microsoft.com/en-us/visualstudio/code-quality/security-rules-rule-set-for-managed-code?view=vs-2019&amp;viewFallbackFrom=vs-2022
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that we have learned how we can use static code analysis, let’s dive into a new feature.
    
    
     Indeed, Visual Studio 2022 now integrates IntelliCode as a built-in feature, available to all subscriptions.
    
    
     Let’s explore how it works and how we can leverage
    
    
     
      its capabilities.
     
    
   </p>
   <h1 id="_idParaDest-62">
    <a id="_idTextAnchor062">
    </a>
    
     Leveraging IntelliCode for code refactoring
    
   </h1>
   <p>
    
     As developers, we need to
    
    <a id="_idIndexMarker224">
    </a>
    
     constantly refactor our code to improve its structure, readability, or performance, especially when we are working with TDD, with respect to the flow explained in
    
    <a href="B22218_01.xhtml#_idTextAnchor015">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     One tool that has significantly
    
    <a id="_idIndexMarker225">
    </a>
    
     enhanced our refactoring process is
    
    <strong class="bold">
     
      IntelliCode
     
    </strong>
    
     , which uses artificial intelligence and machine learning to offer intelligent suggestions and automate repetitive tasks.
    
    
     IntelliCode is now integrated into Visual Studio 2022 for C#.
    
    
     In this section, we’ll explore strategies for effective code refactoring using IntelliCode, drawing from our experience
    
    
     
      and insight.
     
    
   </p>
   <p>
    
     First of all, we need to ensure that we have IntelliCode installed in our Visual Studio by going to the
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     menu through the top bar menu, which is
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       IntelliCode
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.10 – IntelliCode Options" src="img/B22218_03_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.10 – IntelliCode Options
    
   </p>
   <p>
    
     If you can't find IntelliCode in the
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     menu, install it with your Visual Studio Installer by ticking the
    
    
     <strong class="bold">
      
       IntelliCode
      
     </strong>
    
    
     
      checkbox.
     
    
   </p>
   <div><div><img alt="Figure 3.11 – Visual Studio Installer IntelliCode" src="img/B22218_03_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.11 – Visual Studio Installer IntelliCode
    
   </p>
   <p>
    
     Now that we’ve ensured that
    
    <a id="_idIndexMarker226">
    </a>
    
     IntelliCode is enabled in Visual Studio, let’s
    
    <a id="_idIndexMarker227">
    </a>
    
     explore how it can enhance our
    
    
     
      coding experience.
     
    
   </p>
   <h2 id="_idParaDest-63">
    <a id="_idTextAnchor063">
    </a>
    
     Predicting code with whole-line autocompletion
    
   </h2>
   <p>
    
     IntelliCode, introduced in Visual Studio 2022, provides
    
    <a id="_idIndexMarker228">
    </a>
    
     whole-line autocompletion with suggestions.
    
    
     This feature is designed to streamline the development process, improve code quality, and
    
    
     
      increase productivity.
     
    
   </p>
   <p>
    
     The following image shows
    
    
     
      whole-line autocompletion:
     
    
   </p>
   <div><div><img alt="Figure 3.12 – Whole-line autocompletion from typing" src="img/B22218_03_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.12 – Whole-line autocompletion from typing
    
   </p>
   <p>
    
     In
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .12
     
    </em>
    
     , we can see
    
    <em class="italic">
     
      gray text line prediction
     
    </em>
    
     generated according to the context.
    
    
     The prediction is
    
    <a id="_idIndexMarker229">
    </a>
    
     based on a large amount of public, open source GitHub repositories.
    
    
     The IntelliCode suggestions are seamlessly integrated with those from in the IntelliSense.
    
    
     These IntelliCode recommendations are highlighted and easily indentifiable by the
    
    <em class="italic">
     
      black star
     
    </em>
    
     icon located on the left of
    
    
     
      the suggestion.
     
    
   </p>
   <p>
    
     If we select another suggestion than one provided by the whole-line autocompletion, IntelliCode generates a new prediction according to
    
    
     
      our choice.
     
    
   </p>
   <div><div><img alt="Figure 3.13 – Whole-line autocompletion from IntelliSense" src="img/B22218_03_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.13 – Whole-line autocompletion from IntelliSense
    
   </p>
   <p>
    
     To accept the whole-line autocompletion, we just need to press
    
    <em class="italic">
     
      Tab
     
    </em>
    
     or click on the
    
    <em class="italic">
     
      arrow
     
    </em>
    
     that pops above the suggestion.
    
    
     We can press
    
    <em class="italic">
     
      Esc
     
    </em>
    
     or
    
    <em class="italic">
     
      Delete
     
    </em>
    
     to
    
    
     
      dismiss it.
     
    
   </p>
   <p>
    
     IntelliCode runs locally on the machine, providing whole-line autocompletion, which enhances code security and consideration for properties, unlike ChatGPT and other AI predictions tools, which are
    
    
     
      generated inline.
     
    
   </p>
   <p>
    
     Now that we’ve seen
    
    <a id="_idIndexMarker230">
    </a>
    
     how IntelliCode can help us generate code, let’s explore how it can assist us in understanding the code by providing direct access
    
    
     
      to documentation.
     
    
   </p>
   <h2 id="_idParaDest-64">
    <a id="_idTextAnchor064">
    </a>
    
     Accessing GitHub documentation
    
   </h2>
   <p>
    
     When using external libraries or nuggets, we can
    
    <a id="_idIndexMarker231">
    </a>
    
     encounter methods that we don’t know how to use efficiently.
    
    
     IntelliCode provides a helpful feature called
    
    <strong class="bold">
     
      API Usage Examples
     
    </strong>
    
     , which provides practical examples of how to use
    
    <a id="_idIndexMarker232">
    </a>
    
     these
    
    
     
      methods effectively.
     
    
   </p>
   <p>
    
     To activate this feature, go to the
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     menu (see
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    <em class="italic">
     
      .10
     
    </em>
    
     ) and tick
    
    <strong class="bold">
     
      Enable API
     
    </strong>
    
     <strong class="bold">
      
       Usage Examples
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, we can hover our cursor on the method we want to know more about, and we get a link labeled
    
    <strong class="bold">
     
      GitHub Examples
     
    </strong>
    
     <strong class="bold">
      
       and Documentation
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.14 – GitHub Examples and Documentation link" src="img/B22218_03_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.14 – GitHub Examples and Documentation link
    
   </p>
   <p>
    
     Upon clicking on the link (
    
    <strong class="bold">
     
      GitHub Examples and Documentation
     
    </strong>
    
     ), a side pin window opens with an example of the implementation of the method through several
    
    
     
      GitHub repositories:
     
    
   </p>
   <div><div><img alt="Figure 3.15 – GitHub examples" src="img/B22218_03_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.15 – GitHub examples
    
   </p>
   <p>
    
     This feature helps us to plan our refactoring according to the examples of implementation in other projects, using the experience of
    
    
     
      other developers.
     
    
   </p>
   <p>
    
     In the next section, let’s dive
    
    <a id="_idIndexMarker233">
    </a>
    
     into code metrics, which point to the areas of our project where we need to do some refactoring to improve maintainability
    
    
     
      and quality.
     
    
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor065">
    </a>
    
     Code metrics, maintainability, and security
    
   </h1>
   <p>
    
     As developers, we rely on
    
    <strong class="bold">
     
      code metrics
     
    </strong>
    
     to evaluate the quality of a software system.
    
    
     These quantitative measures provide insights into
    
    <a id="_idIndexMarker234">
    </a>
    
     various aspects of our code, such as complexity, maintainability, and security.
    
    
     By understanding these metrics, we can identify areas that may need improvement, ensuring that our code base remains manageable, secure,
    
    
     
      and efficient.
     
    
   </p>
   <h2 id="_idParaDest-66">
    <a id="_idTextAnchor066">
    </a>
    
     Understanding the metrics
    
   </h2>
   <p>
    
     Visual Studio allows us to generate a report containing a list of metrics, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Maintainability Index
      
     </strong>
     
      assesses how easy it is to maintain code, giving a score from 0 to 100, where higher scores indicate
     
     <a id="_idIndexMarker235">
     </a>
     
      better maintainability.
     
     
      Ratings are color-coded: green (20-100) for
     
     <em class="italic">
      
       good
      
     </em>
     
      , yellow (10-19) for
     
     <em class="italic">
      
       moderate
      
     </em>
     
      , and red (0-9)
     
     
      
       for
      
     
     
      <em class="italic">
       
        low
       
      </em>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cyclomatic Complexity
      
     </strong>
     
      measures a
     
     <a id="_idIndexMarker236">
     </a>
     
      code’s structural complexity by counting its different flow paths.
     
     
      High complexity suggests more tests are needed for good coverage and
     
     
      
       lower maintainability.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Depth of Inheritance
      
     </strong>
     
      gauges how
     
     <a id="_idIndexMarker237">
     </a>
     
      many classes inherit from one another, with lower values being better to prevent
     
     
      
       widespread changes.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Class Coupling
      
     </strong>
     
      measures how tightly
     
     <a id="_idIndexMarker238">
     </a>
     
      classes are connected, with high coupling indicating
     
     
      
       poor design.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Lines of Source Code
      
     </strong>
     
      counts all lines in a source file, while
     
     <strong class="bold">
      
       Lines of Executable Code
      
     </strong>
     
      approximates the
     
     <a id="_idIndexMarker239">
     </a>
     
      number of
     
     
      
       executable lines.
      
     
    </li>
   </ul>
   <p>
    
     Now that we understand the metrics, let’s delve
    
    <a id="_idIndexMarker240">
    </a>
    
     deeper into how to use them through
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-67">
    <a id="_idTextAnchor067">
    </a>
    
     Using code metrics in Visual Studio 2022
    
   </h2>
   <p>
    
     Visual Studio 2022 provides a
    
    <a id="_idIndexMarker241">
    </a>
    
     powerful suite of tools for
    
    <a id="_idIndexMarker242">
    </a>
    
     analyzing code metrics.
    
    
     Here are two ways to
    
    
     
      use them:
     
    
   </p>
   <ul>
    <li>
     
      In the top bar menu, select
     
     <strong class="bold">
      
       Analyze
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Calculate Code Metrics
      
     </strong>
     
      and choose if you want to calculate the metrics on a specific project or on
     
     
      
       the solution
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 3.16 – Calculate Code Metrics from the top menu" src="img/B22218_03_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.16 – Calculate Code Metrics from the top menu
    
   </p>
   <ul>
    <li>
     
      Alternatively, you can
     
     <em class="italic">
      
       right-click
      
     </em>
     
      directly on the solution or project you want to measure and, from the contextual menu, choose
     
     <strong class="bold">
      
       Analyze and Code Cleanup
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Calculate
      
     </strong>
     
      <strong class="bold">
       
        Code Metrics
       
      </strong>
     
    </li>
   </ul>
   <div><div><img alt="Figure 3.17 – Calculate Code Metrics for a project" src="img/B22218_03_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.17 – Calculate Code Metrics for a project
    
   </p>
   <p>
    
     After the analysis is complete, a
    
    <a id="_idIndexMarker243">
    </a>
    
     window will open displaying the code
    
    
     
      metrics results:
     
    
   </p>
   <div><div><img alt="Figure 3.18 – Code Metrics Results" src="img/B22218_03_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.18 – Code Metrics Results
    
   </p>
   <p>
    
     Here, we can view metrics
    
    <a id="_idIndexMarker244">
    </a>
    
     such as
    
    <strong class="bold">
     
      Cyclomatic Complexity
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Depth of Inheritance
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Class Coupling
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Lines of Source code
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Lines of Executable code
     
    </strong>
    
     .
    
    
     We can apply a custom filter to clamp the result between the minimum and maximum values for a metric.
    
    
     Furthermore, for better manipulation of the data, we can export the code metric results to an
    
    
     
      Excel file.
     
    
   </p>
   <p>
    
     Understanding and utilizing code metrics is essential for maintaining high-quality software.
    
    
     Visual Studio 2022 provides powerful tools for analyzing code metrics, helping developers identify and address issues relating to security and maintainability.
    
    
     By focusing on these aspects, developers
    
    <a id="_idIndexMarker245">
    </a>
    
     can ensure that their code bases remain robust, secure, and easy
    
    
     
      to manage.
     
    
   </p>
   <p>
    
     In this section, we’ve
    
    <a id="_idIndexMarker246">
    </a>
    
     navigated through tools that identify parts of code that need improvement and used IntelliCode for refactoring.
    
    
     In the final section, let’s delve into a practical use case
    
    
     
      of refactoring.
     
    
   </p>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor068">
    </a>
    
     Refactoring case studies
    
   </h1>
   <p>
    <strong class="bold">
     
      Refactoring
     
    </strong>
    
     entails restructuring code while preserving its initial functionality.
    
    
     The objective is to enhance the internal structure through incremental modifications without affecting the code’s external behavior.
    
    
     To
    
    <a id="_idIndexMarker247">
    </a>
    
     check the integrity of our code, we use unit tests (see
    
    <a href="B22218_01.xhtml#_idTextAnchor015">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     of this book).
    
    
     Refactoring is the last step in the test-driven
    
    
     
      design process.
     
    
   </p>
   <p>
    
     This section showcases a small piece of code containing bad practices.
    
    
     We will see how to fix these issues efficiently with the help of Visual Studio.
    
    
     Remember that norms and practices must be discussed with all teams and can change from one team
    
    
     
      to another.
     
    
   </p>
   <h2 id="_idParaDest-69">
    <a id="_idTextAnchor069">
    </a>
    
     Handling common bad practice
    
   </h2>
   <p>
    
     Here’s a code with bad naming and a
    
    <a id="_idIndexMarker248">
    </a>
    
     condition check that can be
    
    
     
      easily simplified:
     
    
   </p>
   <pre class="source-code">
    public static bool canregister(int age)
    {
        if(age &gt; 18)
        {
            return true;
        }
        else
        {
            return false;
        }
    }</pre>
   <p>
    
     We will use the
    
    <em class="italic">
     
      light bulb
     
    </em>
    
     to fix the
    
    <a id="_idIndexMarker249">
    </a>
    
     naming violation (
    
    <strong class="bold">
     
      IDE1006
     
    </strong>
    
     ) provided by the live
    
    
     
      code analyzer:
     
    
   </p>
   <div><div><img alt="Figure 3.19 – Fixing the name violation" src="img/B22218_03_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.19 – Fixing the name violation
    
   </p>
   <p>
    
     After that, we can simplify the age check with the
    
    
     <em class="italic">
      
       light bulb
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.20 – Simplifying the age check" src="img/B22218_03_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.20 – Simplifying the age check
    
   </p>
   <p>
    
     We can see that the
    
    <strong class="bold">
     
      Preview changes
     
    </strong>
    
     window allows us to be more aggressive in fixing all occurrences in the different levels of
    
    
     
      our solution.
     
    
   </p>
   <p>
    
     Next, as our method
    
    <a id="_idIndexMarker250">
    </a>
    
     contains only
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     , we can improve the readability by turning it into an
    
    <strong class="bold">
     
      expression body
     
    </strong>
    
     (a concise way to define the body of a method).
    
    
     We will use the
    
    <em class="italic">
     
      screwdriver
     
    </em>
    
     to
    
    
     
      do this:
     
    
   </p>
   <div><div><img alt="Figure 3.21 – Using an expression body" src="img/B22218_03_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.21 – Using an expression body
    
   </p>
   <p>
    
     The last bad practice to handle is the usage of the magic number.
    
    
     A magic number refers to a numeric literal that appears directly in the source code without any explanation of its meaning or purpose.
    
    
     It can be challenging to change or understand without proper context.
    
    
     So, we will introduce a
    
    <a id="_idIndexMarker251">
    </a>
    
     constant with a human-readable name to explain the purpose of this number.
    
    
     We will once again use the
    
    <em class="italic">
     
      light bulb
     
    </em>
    
     to
    
    
     
      do this:
     
    
   </p>
   <div><div><img alt="Figure 3.22 – Introducing a constant" src="img/B22218_03_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.22 – Introducing a constant
    
   </p>
   <p>
    
     Now we get a simple expression body, which is well named, and one that respects clean
    
    
     
      code practices.
     
    
   </p>
   <h2 id="_idParaDest-70">
    <a id="_idTextAnchor070">
    </a>
    
     Generating an interface
    
   </h2>
   <p>
    
     For instance, imagine we
    
    <a id="_idIndexMarker252">
    </a>
    
     get a
    
    <strong class="source-inline">
     
      AirTraffic
     
    </strong>
    
     class with a
    
    <strong class="source-inline">
     
      RegisterAircraft
     
    </strong>
    
     method.
    
    
     Now to add abstraction to our code we want to create an
    
    <strong class="source-inline">
     
      IAirTraffic
     
    </strong>
    
     interface.
    
    
     We’ll use the
    
    <em class="italic">
     
      screwdriver
     
    </em>
    
     to effortlessly extract
    
    
     
      the interface.
     
    
   </p>
   <div><div><img alt="Figure 3.23 – Extracting an interface" src="img/B22218_03_23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.23 – Extracting an interface
    
   </p>
   <p>
    
     This will open a window with
    
    <a id="_idIndexMarker253">
    </a>
    
     options to allow us to choose the configuration of our interface.
    
    
     We will keep the default choices to create the interface in a new file,
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       IairTraffic.cs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, we are adding a new method,
    
    <strong class="source-inline">
     
      SendMessage
     
    </strong>
    
     , and we want it to belong to the interface as well.
    
    
     Again, we can use the
    
    <em class="italic">
     
      screwdriver
     
    </em>
    
     to pull the new method up to
    
    
     
      the interface:
     
    
   </p>
   <div><div><img alt="Figure 3.24 – Pulling the method up to interface" src="img/B22218_03_24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.24 – Pulling the method up to interface
    
   </p>
   <p>
    
     This refactoring ensures that all classes implementing
    
    <strong class="source-inline">
     
      IAirTraffic
     
    </strong>
    
     will have access to the
    
    <strong class="source-inline">
     
      SendMessage
     
    </strong>
    
     method, promoting a consistent interface and
    
    
     
      code reuse.
     
    
   </p>
   <h2 id="_idParaDest-71">
    <a id="_idTextAnchor071">
    </a>
    
     File-scoping our namespace
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      file-scoped namespace
     
    </strong>
    
     feature, introduced in
    
    <a id="_idIndexMarker254">
    </a>
    
     C# 10, offers a more concise approach to declaring namespaces.
    
    
     It eliminates the need for curly braces to enclose the namespace body, streamlining the syntax and
    
    <a id="_idIndexMarker255">
    </a>
    
     
      enhancing readability.
     
    
   </p>
   <p>
    
     By default, when we create classes in Visual Studio, it uses the older version of namespace, which wraps the entire content of the file using curly braces.
    
    
     We can add a semicolon at the end of the declaration of the namespace and Visual Studio will automatically understand that you want to turn it in
    
    
     
      file-scoped namespace.
     
    
   </p>
   <p>
    
     To avoid this repetitive action, we can set file-scoped namespace as the default in Visual Studio by using the top menu bar: select
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Text Editor
     
    </strong>
    
     |
    
    <strong class="bold">
     
      C#
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Code Style
     
    </strong>
    
     |
    
    <strong class="bold">
     
      General
     
    </strong>
    
     and change the namespace declaration value to
    
    
     <strong class="bold">
      
       File scoped
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 3.25 – Making namespace declarations file scoped" src="img/B22218_03_25.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.25 – Making namespace declarations file scoped
    
   </p>
   <p>
    
     If we work in teams, we can generate the
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     file directly for the
    
    <strong class="bold">
     
      Options
     
    </strong>
    
     window by clicking on the
    
    <strong class="bold">
     
      Generate .editor file from setting
     
    </strong>
    
     option, as we can see in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .25
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     If we already have a
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     file, (created manually or generated by changing the severity level, as seen in the
    
    <em class="italic">
     
      Utilizing static code analysis for quality assurance and security
     
    </em>
    
     section in this chapter), we can add the following line to set namespace declarations
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       file_scoped
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
csharp_style_namespace_declarations = file_scoped</pre>
   <p>
    
     If we want Visual Studio to trigger
    
    <a id="_idIndexMarker256">
    </a>
    
     compile-time errors when file-scoped namespaces are not used, the syntax would be
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
csharp_style_namespace_declarations = file_scoped:error</pre>
   <p>
    
     This allows us to commit the configuration to our Git repository, ensuring it’s shared with
    
    
     
      our team.
     
    
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor072">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we explored the inner workings of Roslyn within Visual Studio 2022, empowering developers to use its capabilities fully.
    
    
     By mastering static code analysis, we can enhance quality assurance and security measures in our projects through nuanced control over severity levels and generating
    
    <strong class="source-inline">
     
      .editorconfig
     
    </strong>
    
     files and spreading them to
    
    
     
      our team.
     
    
   </p>
   <p>
    
     We saw how IntelliCode redefines productivity, offering predictive coding via whole-line autocompletion and seamless access to
    
    
     
      GitHub documentation.
     
    
   </p>
   <p>
    
     We navigated code metrics of maintainability and security, which equip us with invaluable insights that allow us to evaluate and improve code bases.
    
    
     Armed with Visual Studio 2022’s built-in tools, projects can be optimized for long-term sustainability
    
    
     
      and robustness.
     
    
   </p>
   <p>
    
     We concluded this chapter with practical refactoring case studies, addressing common pitfalls and demonstrating techniques such as interface generation and namespace refinement.
    
    
     By analyzing real-world scenarios, we gained hands-on experience in applying advanced
    
    
     
      refactoring principles.
     
    
   </p>
   <p>
    
     In the following chapter, we explore strategies for identifying performance bottlenecks, optimizing code execution, and leveraging Visual Studio 2022’s profiling tools to ensure peak performance in
    
    
     
      our applications.
     
    
   </p>
  </div>
 </body></html>