<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-19"><em class="italic"><a id="_idTextAnchor019"/>Chapter 1</em>: Customizing Logging</h1>
			<p>In this chapter, the first in this book about customizing <strong class="bold">ASP.NET</strong> <strong class="bold">Core</strong>, you will see how to customize <strong class="bold">logging</strong>. The default logging only writes to the console or the debug window. This is quite good for the majority of cases, but sometimes you need to log to a sink, such as a file or a database. Or, perhaps you want to extend the logger with additional information. In these cases, you need to know how to change the default logging. </p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>Configuring logging</li>
				<li>Creating a custom logger</li>
				<li>Plugging in an existing third-party logger provider</li>
			</ul>
			<p>The topics in this chapter refer to the <a id="_idIndexMarker000"/>hosting layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B17996.jpg" alt="Figure 1.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Technical requirements</h1>
			<p>To follow the descriptions in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new mvc -n LoggingSample -o LoggingSample</p>
			<p>Now, open the project in <strong class="bold">Microsoft</strong> <strong class="bold">Visual Studio</strong> by double-clicking the project file, or in Visual Studio Code, by typing the following command in the already-open console:</p>
			<p class="source-code">cd LoggingSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter01">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter01</a>.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/><a id="_idTextAnchor022"/>Configuring logging</h1>
			<p>In previous <a id="_idIndexMarker001"/>versions of ASP.NET Core (that is, before version 2.0), logging was configured in <strong class="source-inline">Startup.cs</strong>. As a reminder, since version 2.0, the <strong class="source-inline">Startup.cs</strong> file has been simplified, and a lot of configurations have been moved to the default <strong class="source-inline">WebHostBuilder</strong>, which is called in <strong class="source-inline">Program.cs</strong>. Also, logging was moved to the default <strong class="source-inline">WebHostBuilder</strong>.</p>
			<p>In ASP.NET Core 3.1 and later versions, the <strong class="source-inline">Program.cs</strong> file gets more generic, and <strong class="source-inline">IHostBuilder</strong> will be created first. <strong class="source-inline">IHostBuilder</strong> is pretty useful for bootstrapping an application without all of the ASP.NET web stuff. We'll learn a lot more about <strong class="source-inline">IHostBuilder</strong> later on in this book. With this <strong class="source-inline">IHostBuilder</strong>, we create <strong class="source-inline">IWebHostBuilder</strong> to configure ASP.NET Core. In ASP.NET Core 3.1 and later versions, we get <strong class="source-inline">IWebHostBuilder</strong> with the <strong class="source-inline">webBuilder</strong> variable:</p>
			<p class="source-code">public class Program</p>
			<p class="source-code">{</p>
			<p class="source-code">    public static void Main(string[] args)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CreateHostBuilder(args).Build().Run();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static IHostBuilder CreateHostBuilder(</p>
			<p class="source-code">      string[]args) =&gt;</p>
			<p class="source-code">        Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">            .ConfigureWebHostDefaults(webBuilder =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                webBuilder.UseStartup&lt;Startup&gt;();</p>
			<p class="source-code">            });</p>
			<p class="source-code">}</p>
			<p>In ASP.NET Core 6.0, Microsoft <a id="_idIndexMarker002"/>introduced the <strong class="bold">minimal API</strong> approach that simplifies <a id="_idIndexMarker003"/>the configuration a lot. This approach doesn't use the <strong class="source-inline">Startup</strong> file and adds all of the configurations to the <strong class="source-inline">Program.cs</strong> file instead. Let's see what this looks like:</p>
			<p class="source-code">var builder = WebApplication.CreateBuilder(args);</p>
			<p class="source-code">// Add services to the container.</p>
			<p class="source-code">builder.Services.AddControllersWithViews();</p>
			<p class="source-code">var app = builder.Build();</p>
			<p class="source-code">// The rest of the file isn't relevant for this chapter</p>
			<p>In ASP.NET Core, you are able to override and customize almost everything. This includes logging. <strong class="source-inline">IWebHostBuilder</strong> has a lot of extension methods that allow us to override the default behavior of different features. To override the default settings for logging, we need to use the <strong class="source-inline">ConfigureLogging</strong> method. The following code snippet shows almost exactly the same logging as was configured inside the <strong class="source-inline">ConfigureWebHostDefaults()</strong> method:</p>
			<p class="source-code">Host.CreateDefaultBuilder(args)</p>
			<p class="source-code">    .ConfigureWebHostDefaults(webBuilder =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        webBuilder</p>
			<p class="source-code">            .ConfigureLogging((hostingContext, logging) =&gt;</p>
			<p class="source-code">            {</p>
			<p class="source-code">                logging.AddConfiguration(</p>
			<p class="source-code">                  hostingContext.Configuration.GetSection(</p>
			<p class="source-code">                    "Logging"));</p>
			<p class="source-code">                logging.AddConsole();</p>
			<p class="source-code">                logging.AddDebug();</p>
			<p class="source-code">            })</p>
			<p class="source-code">            .UseStartup&lt;Startup&gt;();</p>
			<p>Using the <a id="_idIndexMarker004"/>minimal API approach, we don't need the <strong class="source-inline">ConfigureLogging</strong> method anymore, and we can use the <strong class="source-inline">Logging</strong> property of <strong class="source-inline">WebApplicationBuilder</strong> directly:</p>
			<p class="source-code">builder.Logging.AddConfiguration(builder.Configuration.GetSection("Logging"));</p>
			<p class="source-code">builder.Logging.AddConsole();</p>
			<p class="source-code">builder.Logging.AddDebug();</p>
			<p>Now that we've seen how to configure logging, let's look at building a custom logg<a id="_idTextAnchor023"/><a id="_idTextAnchor024"/>er.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor025"/>Creating a custom logger</h1>
			<p>To demonstrate a <a id="_idIndexMarker005"/>custom logger, let's use a small, simple logger I created that is able to colorize log entries with a specific log level in the console. This logger is called <strong class="source-inline">ColoredConsoleLogger</strong>, and it will be created and added using <strong class="source-inline">LoggerProvider</strong>, which we also need to write for ourselves. To specify the color and the log level to colorize, we need to add a configuration class. </p>
			<p>In the next snippets, all three parts (<strong class="source-inline">Logger</strong>, <strong class="source-inline">LoggerProvider</strong>, and <strong class="source-inline">Configuration</strong>) are shown:</p>
			<ol>
				<li>Let's create the configuration class of our logger in a new file called <strong class="source-inline">CustomLogger.cs</strong> in the same folder as the <strong class="source-inline">Program.cs</strong> file. Add the following using statement at<a id="_idIndexMarker006"/> the top of the file:<p class="source-code">namespace LoggingSample;</p><p>We will call it <strong class="source-inline">ColoredConsoleLoggerConfiguration</strong>. This class contains three properties to define – <strong class="source-inline">LogLevel</strong>, <strong class="source-inline">EventId</strong>, and <strong class="source-inline">Color</strong> – that can be set:</p><p class="source-code">public class ColoredConsoleLoggerConfiguration</p><p class="source-code">{</p><p class="source-code">    public LogLevel LogLevel { get; set; } = </p><p class="source-code">      LogLevel.Warning;</p><p class="source-code">    public int EventId { get; set; } = 0;</p><p class="source-code">    public ConsoleColor Color { get; set; } = </p><p class="source-code">      ConsoleColor.Yellow;</p><p class="source-code">}</p></li>
				<li>Next, we need a provider to retrieve the configuration and create the actual logger instance:<p class="source-code">public class ColoredConsoleLoggerProvider : ILoggerProvider</p><p class="source-code">{</p><p class="source-code">    private readonly ColoredConsoleLoggerConfiguration</p><p class="source-code">      _config;</p><p class="source-code">    private readonly ConcurrentDictionary&lt;string,</p><p class="source-code">      ColoredConsoleLogger&gt; _loggers =</p><p class="source-code">        new ConcurrentDictionary&lt;string,</p><p class="source-code">           ColoredConsoleLogger&gt;();</p><p class="source-code">    public ColoredConsoleLoggerProvider</p><p class="source-code">      (ColoredConsoleLoggerConfiguration config)</p><p class="source-code">    {</p><p class="source-code">        _config = config;</p><p class="source-code">    }</p><p class="source-code">    public ILogger CreateLogger(string categoryName)</p><p class="source-code">    {</p><p class="source-code">        return _loggers.GetOrAdd(categoryName, name =&gt;</p><p class="source-code">            new ColoredConsoleLogger(name, _config));</p><p class="source-code">    }</p><p class="source-code">    public void Dispose()</p><p class="source-code">    {</p><p class="source-code">        _loggers.Clear();</p><p class="source-code">    }</p><p class="source-code">}</p><p>Don't forget<a id="_idIndexMarker007"/> to add a <strong class="source-inline">using</strong> statement for <strong class="source-inline">System.Collections.Concurrent</strong>.</p></li>
				<li>The third class is the actual logger we want to use:<p class="source-code">public class ColoredConsoleLogger : ILogger</p><p class="source-code">{</p><p class="source-code">    private static object _lock = new Object();</p><p class="source-code">    private readonly string _name;</p><p class="source-code">    private readonly ColoredConsoleLoggerConfiguration </p><p class="source-code">      _config;</p><p class="source-code">    public ColoredConsoleLogger(</p><p class="source-code">        string name,</p><p class="source-code">        ColoredConsoleLoggerConfiguration config)</p><p class="source-code">    {</p><p class="source-code">        _name = name;</p><p class="source-code">        _config = config;</p><p class="source-code">    }</p><p class="source-code">    public IDisposable BeginScope&lt;TState&gt;(TState </p><p class="source-code">      state)</p><p class="source-code">    {</p><p class="source-code">        return null;</p><p class="source-code">    }</p><p class="source-code">    public bool IsEnabled(LogLevel logLevel)</p><p class="source-code">    {</p><p class="source-code">        return logLevel == _config.LogLevel;</p><p class="source-code">    }</p><p class="source-code">    public void Log&lt;TState&gt;(</p><p class="source-code">        LogLevel logLevel,</p><p class="source-code">        EventId eventId,</p><p class="source-code">        TState state,</p><p class="source-code">        Exception exception,</p><p class="source-code">        Func&lt;TState, Exception, string&gt; formatter)</p><p class="source-code">    {</p><p class="source-code">        if (!IsEnabled(logLevel))</p><p class="source-code">        {</p><p class="source-code">            return;</p><p class="source-code">        }</p><p class="source-code">        lock (_lock)</p><p class="source-code">        {</p><p class="source-code">            if (_config.EventId == 0 ||</p><p class="source-code">                _config.EventId == eventId.Id)</p><p class="source-code">            {</p><p class="source-code">                var color = Console.ForegroundColor;</p><p class="source-code">                Console.ForegroundColor = </p><p class="source-code">                  _config.Color;</p><p class="source-code">                Console.Write($"{logLevel} - ");</p><p class="source-code">                Console.Write($"{eventId.Id} - {_name}</p><p class="source-code">                              - ");</p><p class="source-code">                Console.Write($"{formatter(state,</p><p class="source-code">                                 exception)}\n");</p><p class="source-code">                Console.ForegroundColor = color;</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p>We now need to lock the actual console output – this is because we will encounter some race conditions where incorrect log entries get colored with the wrong color, as the console itself is not really thread-safe.</p></li>
				<li>After<a id="_idIndexMarker008"/> this is done, we can start to plug in the new logger to the configuration in <strong class="source-inline">Program.cs</strong>:<p class="source-code">builder.Logging.ClearProviders();</p><p class="source-code">var config = new ColoredConsoleLoggerConfiguration</p><p class="source-code">{</p><p class="source-code">    LogLevel = LogLevel.Information,</p><p class="source-code">    Color = ConsoleColor.Red</p><p class="source-code">};</p><p class="source-code">builder.Logging.AddProvider(new </p><p class="source-code">    ColoredConsoleLoggerProvider(config));</p></li>
			</ol>
			<p>You might need to add a using statement to the <strong class="source-inline">LoggerSample</strong> namespace.</p>
			<p>If you don't want to use the existing loggers, you can clear all the logger providers added previously. Then, we call <strong class="source-inline">AddProvider</strong> to add a new instance of our <strong class="source-inline">ColoredConsoleLoggerProvider</strong> class with the specific settings. We could also add some more instances of the provider with different settings.</p>
			<p>This shows how you could handle the log levels in a different way. You could use this approach to send emails regarding hard errors or to log debug messages to a different log sink from regular informational messages, and much more.</p>
			<p><em class="italic">Figure 1.2</em> shows <a id="_idIndexMarker009"/>the colored output of the previously created custom logger:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.2_B17996.jpg" alt="Figure 1.2 – A screenshot of the custom logger"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – A screenshot of the custom logger</p>
			<p>In many cases, it doesn't make sense to write a custom logger, as many good third-party loggers are already available, such as <strong class="source-inline">ELMAH</strong>, <strong class="source-inline">log4net</strong>, and <strong class="source-inline">NLog</strong>. In the next section, we will see how to use <strong class="source-inline">NLog</strong> in ASP.NE<a id="_idTextAnchor026"/><a id="_idTextAnchor027"/>T Core.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor028"/>Plugging in an existing third-party logger provider</h1>
			<p><strong class="source-inline">NLog</strong> was<a id="_idIndexMarker010"/> one of the very first available<a id="_idIndexMarker011"/> as a <strong class="bold">.NET Standard</strong> library, and it can<a id="_idIndexMarker012"/> be used in ASP.NET Core. <strong class="source-inline">NLog</strong> also already provides a logger provider to easily plug into ASP.NET Core.</p>
			<p>You will<a id="_idIndexMarker013"/> find <strong class="source-inline">NLog</strong> via <strong class="bold">NuGet</strong> (https://www.nuget.org/packages/NLog.Web.AspNetCore) and on GitHub (<a href="https://github.com/NLog/NLog.Web">https://github.com/NLog/NLog.Web</a>). Even if <strong class="source-inline">NLog</strong> is not yet explicitly available for ASP.NET Core 6.0, it will still work with version 6.0:</p>
			<ol>
				<li value="1">We need to add an <strong class="source-inline">NLog.Config</strong> file that defines two different sinks to log all standard messages in a single log file and custom messages only in another file. Since this file is too long to print, you can view it or download it directly from GitHub: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter01/LoggingSample6.0/NLog.Config">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter01/LoggingSample6.0/NLog.Config</a></li>
				<li>We then need to add the <strong class="source-inline">NLog</strong> ASP.NET Core package from NuGet:<p class="source-code"><strong class="bold">dotnet add package NLog.Web.AspNetCore</strong></p><p class="callout-heading">Important Note</p><p class="callout">Be sure that you are in the project directory before you execute the preceding command!</p></li>
				<li>Now, you <a id="_idIndexMarker014"/>only need to clear all the other providers in the <strong class="source-inline">ConfigureLogging</strong> method in <strong class="source-inline">Program.cs</strong> and to use <strong class="source-inline">NLog</strong> with <strong class="source-inline">IWebHostBuilder</strong> using the <strong class="source-inline">UseNLog()</strong> method:<p class="source-code">Host.CreateDefaultBuilder(args)</p><p class="source-code">    .ConfigureWebHostDefaults(webBuilder =&gt;</p><p class="source-code">    {</p><p class="source-code">        webBuilder</p><p class="source-code">            .ConfigureLogging((hostingContext,</p><p class="source-code">              logging) =&gt;</p><p class="source-code">            {</p><p class="source-code">                logging.ClearProviders();</p><p class="source-code">                logging.SetMinimumLevel(</p><p class="source-code">                  LogLevel.Trace);</p><p class="source-code">            })</p><p class="source-code">            .UseNLog()</p><p class="source-code">            .UseStartup&lt;Startup&gt;();</p><p class="source-code">    });</p><p>Using the <a id="_idIndexMarker015"/>minimal API, it looks much simpler:</p><p class="source-code">using NLog.Web;</p><p class="source-code">var builder = WebApplication.CreateBuilder(args);</p><p class="source-code">builder.Logging.ClearProviders();</p><p class="source-code">builder.Logging.SetMinimumLevel(LogLevel.Trace);</p><p class="source-code">builder.WebHost.UseNLog();</p><p>Here, you can add as many logger providers as you require.</p></li>
			</ol>
			<p>That covers using an existing third-party logger. Let's now recap what we've covered in <a id="_idTextAnchor029"/>this chapter.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor030"/>Summary</h1>
			<p>The good thing about hiding the basic configuration of an application is that it allows you to clean up the newly scaffolded projects and to keep the actual start as simple as possible. The developer is able to focus on the actual features. However, the more the application grows, the more important logging becomes. The default logging configuration is easy and it works like a charm, but in production, you need a persisted log to see errors from the past. Therefore, you need to add a custom logging configuration or a more flexible third-party logger, such as <strong class="source-inline">NLog</strong> or <strong class="source-inline">log4net</strong>.</p>
			<p>You will learn more about how to configure ASP.NET Core 6.0 in the next chapter.</p>
		</div>
	</body></html>