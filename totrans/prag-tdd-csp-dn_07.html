<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-173"><a id="_idTextAnchor183"/>7</h1>
<h1 id="_idParaDest-174"><a id="_idTextAnchor184"/>A Pragmatic View of Domain-Driven Design</h1>
<p><strong class="bold">Domain-driven design</strong> (<strong class="bold">DDD</strong>) is a set of software design principles that are widely used in modern enterprise applications. They were bundled and made popular in 2003 by Eric Evans in his book <em class="italic">Domain-Driven Design</em>. </p>
<p>You might be wondering how this is related to <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>). Is it because it is a similar-sounding acronym? The reality is that TDD and DDD work together where TDD covers the design from the client’s perspective and the quality, while DDD complements the rest of the design. You will hear the two terms used together in a conversation and in job specifications, and the reason for this will be clear by the end of <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>.</p>
<p>This chapter is meant to be a primer on DDD, so you will have the foundation required to build a complete application using a combination of TDD and DDD. </p>
<p>DDD is a technical and a philosophical topic. Given the pragmatism of this book and the length of this chapter, our focus will be limited to the pragmatic aspect of DDD related to the application we are implementing in the following chapters.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Working with a sample application</li>
<li>Exploring domains</li>
<li>Exploring services</li>
<li>Exploring repositories</li>
<li>Putting everything together</li>
</ul>
<p>By the end of the chapter, you will understand the basic DDD terminology and be able to explain it to a colleague.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor185"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch07</a></p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor186"/>Working with a sample application</h1>
<p>We need a sample application<a id="_idIndexMarker512"/> to demonstrate DDD concepts. The word <em class="italic">application</em> can have various meanings in your project. It can be one of the following:</p>
<ul>
<li>A <strong class="bold">single microservice</strong> that is part of a larger<a id="_idIndexMarker513"/> application</li>
<li>A <strong class="bold">monolith application</strong> that is a standalone<a id="_idIndexMarker514"/> application</li>
</ul>
<p>This chapter will use a monolith application, as it is easier to explain the concept and the context will be clearer. So, we’ll focus on the specifics of DDD rather than diverging into a more complex architecture.</p>
<p>Let’s take a blog application<a id="_idIndexMarker515"/> as an example. A DDD-style blog application might look like this in Microsoft <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>):</p>
<div><div><img alt="Figure 7.1 – A blog application in VS " height="120" src="img/Figure_7.1_B18370.jpg" width="333"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A blog application in VS</p>
<p><strong class="bold">UQS</strong> is our fictitious company’s initials, standing for <strong class="bold">Unicorn Quality Solutions</strong>. These projects have the following dependencies on each other:</p>
<div><div><img alt="Figure 7.2 – Project dependencies " height="295" src="img/Figure_7.2_B18370.jpg" width="832"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Project dependencies</p>
<p>Nothing special here: this is a set of regular project dependencies. Let’s dig into each project role.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor187"/>The application project</h2>
<p>Our solution communicates<a id="_idIndexMarker516"/> with the outside world, the clients, and the <code>Uqs.Blog.WebApi</code> project. This solution is using a RESTful Web API to communicate with the UI layer. This should make it easy for a browser-based UI layer, such as <strong class="bold">React</strong>, <strong class="bold">Angular</strong>, <strong class="bold">Vue</strong>, or <strong class="bold">Blazor</strong>, to exchange the data (in the form of contracts).</p>
<p>Also, it can act as a standalone API project<a id="_idIndexMarker517"/> that can be referred to as a <em class="italic">headless</em> blog, which is a fancy term to say that this is only a backend platform without a UI. Multiple UIs can interact with it, so it is not coupled to one UI.</p>
<p>This could be a standard ASP.NET Core Web API, similar to what we’ve used in the previous chapters.</p>
<p>In <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>, and <a href="B18370_03.xhtml#_idTextAnchor066"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting Started with Unit Testing</em>, you’ve seen examples of <code>WeatherForecastingController</code>. In DDD terms, the controller <a id="_idIndexMarker519"/>was acting as an <strong class="bold">application service</strong>.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor188"/>The contract objects project</h2>
<p>To communicate<a id="_idIndexMarker520"/> with the outside world, your data should have a defined structure. This defined structure comprises classes, and it is in the <code>Uqs.Blog.Contract</code> project.</p>
<p>If this is a UI<a id="_idIndexMarker521"/> project, these contracts might be called <strong class="bold">view models</strong>, as they are models that are <em class="italic">bound</em> to the UI (the view) directly. Also, they might be called <strong class="bold">data transportation objects</strong> (<strong class="bold">DTOs</strong>) as they transport the data from the<a id="_idIndexMarker522"/> server to the clients. In API projects, they<a id="_idIndexMarker523"/> are usually referred to as <strong class="bold">contracts</strong>.</p>
<p>Put simply, if the RESTful APIs<a id="_idIndexMarker524"/> have an API that requests the full information of a post, with the following URL:</p>
<pre class="source-code">https://api.uqsblog/posts/1</pre>
<p>Then the contract might look like this:</p>
<pre class="source-code">public record Author(int Id, string Name);
public record Post(int Id, string Content, Author Author, 
    DateTime CreatedDate, int NumberOfComments
    , int NumberOfViews, …);</pre>
<p>This is usually transferred in JSON. This is an example of the preceding C# contract being serialized as JSON:</p>
<pre class="source-code">{
  "id": 1,
  "content": "Some content",
  "author": {
    "id": 100,
    "name": "John Smith"
  },
  "createdDate": "2022-01-01T01:01:01",
  "numberOfComments": 5,
  "numberOfViews": 486,
  …
}</pre>
<p>Contracts are not part of the DDD philosophy, but they are needed<a id="_idIndexMarker525"/> here to have a complete application.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor189"/>The domain layer project</h2>
<p>The components of this layer<a id="_idIndexMarker526"/> are in <code>Uqs.Blog.Domain</code>. This is where all the types related to the domain design live.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Dividing layers, naming projects, and arranging them based on layers is a highly opinionated process. There is no widespread industry standard of the best approach. So, consider my approach here as <em class="italic">an example</em> rather than <em class="italic">the way</em> to do it.</p>
<p>This layer contains the following:</p>
<ul>
<li>Business logic</li>
<li>Database persistence</li>
</ul>
<p>Our project resembles a similar design to this one:</p>
<div><div><img alt="Figure 7.3 – A design diagram for the application " height="463" src="img/Figure_7.3_B18370.jpg" width="813"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – A design diagram for the application</p>
<p>This diagram represents our application; however, it’s worth noting that DDD is concerned with the backend, not the client.</p>
<p>Next, we will go through the constituents of DDD and we will start with the domain.</p>
<h1 id="_idParaDest-180"><a id="_idTextAnchor190"/>Exploring domains</h1>
<p>DDD is a collection of software design<a id="_idIndexMarker527"/> philosophies and best practices. There are a handful of books dedicated to DDD, and most of them are above 500 pages. So, we can talk a lot about DDD, but this book isn’t about DDD, so we will be brief. </p>
<p>DDD focuses on business logic and the interaction with the DB and the outside world and employs a set of practices for a robust<a id="_idIndexMarker528"/> software design. The word <em class="italic">domain</em> in DDD refers to a <em class="italic">business domain</em>, which can be car insurance, accounting, billing, banking, e-commerce, and<a id="_idIndexMarker529"/> others. DDD emphasizes the business domain, as per the term <em class="italic">domain-driven</em>.</p>
<p>Next, we will explore the architectural components that make the practical aspect of DDD.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor191"/>Domain objects</h2>
<p>A <strong class="bold">domain object</strong> is a representation of a real-life business entity. Exploring<a id="_idIndexMarker530"/> our blog project, the domain objects can be like this:</p>
<div><div><img alt="Figure 7.4 – The classes and structs contributing to a blog domain " height="425" src="img/Figure_7.4_B18370.jpg" width="999"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The classes and structs contributing to a blog domain</p>
<p>You can see how the names of these types and the properties reflect the blog business. These entities generally map directly to relational database tables, so you have database tables for posts, authors, tags, and so on.</p>
<p>In a document database, the domain objects may or may not be the ones persisted directly into your collection.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">DDD doesn’t state that domain<a id="_idIndexMarker531"/> objects should be mapped<a id="_idIndexMarker532"/> to a relational DB table, but<a id="_idIndexMarker533"/> in practice, this is what happens as it is more practical to do it in this way, especially with the use of <strong class="bold">object-relational mappers</strong> (<strong class="bold">ORMs</strong>) such as <strong class="bold">Hibernate</strong> (<strong class="bold">Java</strong>) and <strong class="bold">Entity Framework</strong> (<strong class="bold">.NET</strong>).</p>
<p>You will often find words such as <em class="italic">models</em>, <em class="italic">business objects</em>, and <em class="italic">domain objects</em> used interchangeably to mean the same thing.</p>
<p>Not all domain objects<a id="_idIndexMarker534"/> are created equal. DDD differentiates between two types of domain objects: entities and value objects.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor192"/>Entities and value objects</h2>
<p>DDD distinguishes<a id="_idIndexMarker535"/> between objects<a id="_idIndexMarker536"/> that have<a id="_idIndexMarker537"/> their own identity, which are called <code>Id</code> property, but it stands for the plain English meaning of <em class="italic">identity</em>.</p>
<h3>Value objects</h3>
<p><strong class="bold">Value objects</strong> represent typed values that have no conceptual<a id="_idIndexMarker539"/> identity. The most commonly used example of a value object is money. A £5 note (bill) doesn’t have an identity and if it is replaced by another £5 note, then nothing has changed. In other words, if two persons swapped £5 notes, then they have the same value, and we don’t have to worry about or track the notes.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">A £5 note is a value object<a id="_idIndexMarker540"/> unless the serial number of the note is important. This might be the case if this is part of a money-issuing project for the Bank of England. But in most cases, this is a value object.</p>
<p>There are plenty of examples of what can be a value object. Here are a few:</p>
<ul>
<li>Dates</li>
<li>First names, as the first name on its own doesn’t make an identity</li>
<li>Addresses</li>
</ul>
<p>Value objects are modeled in <code>Tag</code> struct.</p>
<p>Blog tags such as .NET, DDD, and TDD don’t require an ID. But for database storage, having an identifier might be more practical as it allows better management of tags.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">From a pure DDD approach, a tag should be a property in <code>Post</code>, not a standalone business object. However, what if there is a misspelling, and you wanted to fix it? What if you wanted to show the user a list of existing tags for autocomplete? Having it as an independent domain object and storing it in a standalone table or a container might lead to better performance and management.</p>
<p>In practice, .NET developers<a id="_idIndexMarker542"/> rarely use structures unless they are building something low-level, such as performance optimization, and interacting with unmanaged resources. Usually, value objects are modeled with classes, which is not very DDD-compliant. </p>
<h3>Entities</h3>
<p>An object primarily defined by its identity is called an <strong class="bold">entity</strong>. It is a type of domain model that needs<a id="_idIndexMarker543"/> to be tracked over time and whose attributes are likely to change over time. A perfect example of this would be a person entity, which has a changeable email and home address but a fixed identity, which is the person herself/himself.</p>
<p>In our preceding blog example, <code>Post</code>, <code>Author</code>, <code>Comment</code>, and <code>Commenter</code> are entities. </p>
<p><code>Comment</code> is peculiar as some can argue that it is a value type! But what if it is editable? Then, its identity becomes important.</p>
<p>Entities<a id="_idIndexMarker544"/> are represented as classes and records, and<a id="_idIndexMarker545"/> they definitely have an <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>).</p>
<h3>Entity versus value objects</h3>
<p>When designing your domain, it is important<a id="_idIndexMarker546"/> to understand the differences<a id="_idIndexMarker547"/> so that you pick the right design. Here are the major distinguishing aspects:</p>
<ul>
<li><strong class="bold">Lifespan</strong>: Entities live in a continuum while value objects are created and destroyed with ease.</li>
<li><strong class="bold">Immutability</strong>: An object is said to be immutable if its value cannot change after creation. Entities are mutable while value objects are immutable.</li>
<li><strong class="bold">Identifier</strong>: Entity objects require an identifier while value objects don’t.</li>
<li><strong class="bold">Classes or structs</strong>: Entities use classes and adhere to the .NET reference type principles (stored in heap, passed by reference, and so on) while value types are structs (at least as DDD recommends), which adhere to the .NET value type principles (stored in stack, passed by value, and so on).</li>
</ul>
<p>To summarize, when we design our domain objects, they can be done as entities or value objects depending on whether they represent an identity.</p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor193"/>Aggregates</h2>
<p><strong class="bold">Aggregates</strong> are a group of classes that form one business<a id="_idIndexMarker548"/> aim. The previous blog classes set a distinguished business objective, which is managing a blog post. These classes form an aggregate. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">The <em class="italic">aggregation</em> term that is used in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and the <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) is not the same concept as the DDD aggregate. </p>
<p>An <code>Post</code> domain object.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor194"/>Anemic models</h2>
<p>When we studied OOP, we learned that an object<a id="_idIndexMarker550"/> handles its own data and its behavior. So, if we have a class called <code>Person</code>, there might be a read-only property called <code>Email</code> in that class. Also, to set the email address, you will have a method that might be creatively called <code>void ChangeEmail(string email)</code>, which does some business logic and validations before setting the email. Our class, according to DDD, would look like this:</p>
<pre class="source-code">public class Person 
{
    public string Email { get; private set; }
    public void ChangeEmail(string email) 
    {
        …
    }
    // other properties and methods
}</pre>
<p>This class stores its own data. For example, the <code>Email</code> property is storing the email value and there is a behavior, which is represented by the <code>ChangeEmail</code> method, which is changing the stored <code>Email</code>.</p>
<p>An <code>Person</code> class earlier to an anemic version:</p>
<pre class="source-code">public class Person 
{
    public string Email { get; <strong class="bold">set;</strong> }
    // other properties
}</pre>
<p>Now the email has a setter, but how are validation and other business logic implemented<a id="_idIndexMarker551"/> if it is not within the class itself? The answer is that another class would be responsible, such as the following:</p>
<pre class="source-code">public class PersonService
{
    public void ChangeEmail(int personId, string email)
    {
      Person person = …; // get the object some how
      // validate email format
      // check that no other person is using the email
      person.Email = email;
    }
}</pre>
<p>In this scenario, another class, <code>PersonService</code>, handles the behavior of the <code>Person</code> class, and the more the behavior of <code>Person</code> is outsourced to other classes, the more the <code>Person</code> class is anemic.</p>
<p>In an anemic model, the client interprets the purpose and use of the domain object, and the business logic ends up being implemented in other classes, similar to the preceding example. An anemic model is considered an <em class="italic">anti-pattern</em>, as it opposes the theories<a id="_idIndexMarker552"/> of OOP.</p>
<p>However, the <em class="italic">anti-pattern</em> of using anemic models in domain objects is very common between<a id="_idIndexMarker553"/> developers, as the practice of setting ORMs such as <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) and other practicalities does clash with DDD best practices.</p>
<p>The rest of the book is taking the anemic model approach, as it is the dominant one in the market. It is more pragmatic and works well with ORMs.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor195"/>Ubiquitous language</h2>
<p>The word <em class="italic">ubiquitous</em>, pronounced as <em class="italic">yu-bikwitus</em>, means, according to the Cambridge<a id="_idIndexMarker554"/> Dictionary, <em class="italic">seeming to be everywhere</em>.</p>
<p>From a DDD perspective, it means using well-known terminology in naming your domain objects similar to what the business people are using. In other words, do not invent your own terminology and follow the existing language: the business language. </p>
<p>This approach<a id="_idIndexMarker555"/> has a couple of clear advantages:</p>
<ul>
<li>Smoother conversation between the business stakeholders and the developers</li>
<li>New developers get on with the business logic and the code rapidly</li>
</ul>
<p>I did use this in the blog example, where I used the terminology that is used in blogging. The same concept applies to projects of a larger size.</p>
<p>By now, you have a general idea about domain objects and aggregates in DDD. In the next section, we will dig into a major DDD topic, which we will use extensively in <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, of this book.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor196"/>Exploring services</h1>
<p><strong class="bold">Services</strong> in DDD are divided into<a id="_idIndexMarker556"/> three types, but we will focus on the <strong class="bold">domain services</strong> for now, and then we will discuss the other two later: <strong class="bold">infrastructure services</strong> and <strong class="bold">application services</strong>.</p>
<p>A domain service<a id="_idIndexMarker557"/> is the unit within the DDD ecosystem where the business logic lives. A domain<a id="_idIndexMarker558"/> service has the following responsibilities:</p>
<ul>
<li>Loading domain objects through the help of repositories</li>
<li>Applying business logic </li>
<li>Persisting the domain objects with the help of repositories</li>
</ul>
<p>It is important to understand that the domain services are unaware of how the data is loaded from the storage medium and how it is stored. They only know how to request a data-loading or persistence operation through the help of data repositories. Repositories will be covered later in this chapter.</p>
<p>Let’s add some services for our blog project to help us with publishing posts, and retrieving and updating them.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor197"/>Post management</h2>
<p>If you have ever published a blog post or an online article, you will be familiar<a id="_idIndexMarker559"/> with this process. If you open a text editor to write a blog post, you will have to fill in the title, the content, and other fields, but you can also save without completing everything. It is okay to save without filling the required fields as you are still editing, but when you want to publish, everything should be completed.</p>
<p>Let’s start implementing the domain services<a id="_idIndexMarker560"/> required to manage a post.</p>
<h3>Adding post service</h3>
<p>Adding a new post will require<a id="_idIndexMarker561"/> the author’s ID but no other field. The code for this service can look as such:</p>
<pre class="source-code">public class AddPostService
{
    private readonly IPostRepository _postRepository;
    private readonly IAuthorRepository _authorRepository;
    public AddPostService(IPostRepository postRepository,
         IAuthorRepository authorRepository)
    {
        _postRepository = postRepository;
        _authorRepository = authorRepository;
    }
    
    public int AddPost(int authorId)
    {
        var author = _authorRepository.GetById(authorId);
        if (author is null)
        {
            throw new ArgumentException(
              "Author Id not found",nameof(authorId));
        }
        if (author.IsLocked)
        {
            throw new InvalidOperationException( 
              "Author is locked");
        }
        var newPostId = _postRepository.CreatePost
          (authorId);
        return newPostId;
    }
}</pre>
<p>First, you’ll notice that I have dedicated<a id="_idIndexMarker562"/> a whole class, <code>AddPostService</code>, with a single method, <code>AddPost</code>. Some designs create a single service class such as <code>PostService</code> and add multiple business logic methods inside it. I opted for the single public method in a single<a id="_idIndexMarker563"/> class approach to respect the single-responsibility principle of <strong class="bold">SOLID</strong>.</p>
<p>I have injected into the class two repositories that are needed for the business logic: the <code>author</code> and <code>post</code> repositories. For a reminder of DI, have a look at <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>.</p>
<p>I implemented a business logic that checks whether a non-existent author is passed to the method. Also, if the author is locked from publishing, then I created a post and got back the created ID. I could have used <code>Guid</code> but the UI would want an integer.</p>
<p>The notable thing here is that the service did not know how <code>Author</code> was loaded. It might have been loaded from a relational DB, a document DB, an in-memory DB, or even a text file! The service delegated this knowledge to the repository.</p>
<p>The service here focused<a id="_idIndexMarker564"/> on a single responsibility, which is the business logic for adding a new post. This is an example of the separation of concerns.</p>
<h3>Updating title service</h3>
<p>The title of the blog<a id="_idIndexMarker565"/> can be up to 90 characters and can be updated at any time. This is sample code to achieve this:</p>
<pre class="source-code">public class UpdateTitleService
{
    private readonly IPostRepository _postRepository;
    private const int TITLE_MAX_LENGTH = 90;
    public UpdateTitleService(IPostRepository postRepo)
    {
        _postRepository = postRepo;
    }
    public void UpdateTitle(int postId, string title)
    {
        if (title is null) title = string.Empty;
        title = title.Trim();
        if (title.Length &gt; TITLE_MAX_LENGTH)
        {
            throw new
               ArgumentOutOfRangeException(nameof(title), 
               $"Title max is {TITLE_MAX_LENGTH} letters");
        }
        var post = _postRepository.GetById(postId);
        if (post is null)
        {
            throw new ArgumentException(
                $"Unable to find a post of Id {postId}", 
                nameof(post));
        }
        post.Title = title;
        _postRepository.Update(post);
    }
}</pre>
<p>The preceding logic is straightforward. What is new here is the way the service loaded the entity, then modified one of its properties, and then asked the repository to manage the update operation.</p>
<p>In both services, the business logic<a id="_idIndexMarker566"/> involved no knowledge of the data platform. This can be SQL Server, Cosmos DB, MongoDB, and so on. DDD refers to the libraries for these tools as <em class="italic">infrastructure</em>, so the services have no knowledge of the infrastructure.</p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Application services</h2>
<p>Earlier, we were describing<a id="_idIndexMarker567"/> the domain services. Application services<a id="_idIndexMarker568"/> provide the interaction with the outside world or the glue that allows a client to request something from your system.</p>
<p>A perfect example of an<a id="_idIndexMarker569"/> application service is an <strong class="bold">ASP.NET</strong> controller, where a controller can use domain<a id="_idIndexMarker570"/> services to provide a response to a <strong class="bold">RESTful</strong> request. Application services will typically use both domain<a id="_idIndexMarker571"/> services and repositories<a id="_idIndexMarker572"/> to deal with external requests.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor199"/>Infrastructure services</h2>
<p>These are used to abstract<a id="_idIndexMarker573"/> technical concerns (cloud storage, service<a id="_idIndexMarker574"/> bus, email provider, and so on). </p>
<p>We will be using services extensively in <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, of this book. So, I hope you got an idea of what they are. Later on, we will have an end-to-end project that will involve multiple services.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Service characteristics</h2>
<p>There are guidelines on how to build a service in DDD. We will go through a few of them here. However, I recommend going through the <em class="italic">Further reading</em> section at the end of this chapter if you would like to know more.</p>
<p>We will discuss stateless services, ubiquitous language, and using domain objects instead of services.</p>
<h3>Stateless</h3>
<p>A service should<a id="_idIndexMarker575"/> not hold a state. Holding a state is akin to remembering data, which means, in plain English, persisting some business data in the fields or properties of a service class.</p>
<p>Avoid maintaining a state in your service as it will complicate your architecture, and if you think that you need a state, then this is what repositories are for.</p>
<h3>Use ubiquitous language</h3>
<p>As always, use ubiquitous language. In the previous<a id="_idIndexMarker576"/> examples, we named the services and the methods following the business operations.</p>
<h3>Use domain objects where relevant</h3>
<p>DDD is against anemic models, so it encourages<a id="_idIndexMarker577"/> the user to check whether a domain model can do the operation rather than having this done in a service.</p>
<p>In our example, DDD would have encouraged us to have behavior (public methods) in <code>Post</code>. If we were to follow the DDD advice, our <code>Post</code> class would have looked like this:</p>
<pre class="source-code">public class Post
{
    public int Id { get; <strong class="bold">private set;</strong> }
    public string? Title { get; <strong class="bold">private set;</strong> }
    // more properties…
    private readonly IPostRepository _postRepository;
    private const int TITLE_MAX_LENGTH = 90;
    public Post(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }
    public void UpdateTitle<strong class="bold">(string title)</strong>
    {
        …
    }
}</pre>
<p>Note that the setters for the properties<a id="_idIndexMarker578"/> are now private as only the methods within the class can set the properties. The second note is that the <code>UpdateTitle</code> method doesn’t need to get <code>Id</code> as a parameter as it has access to <code>Id</code> from within the class. It only requires the new title.</p>
<p>The advantage of this is that your class is not anemic and follows OOP principles. Obviously, we have not followed the DDD recommendation in our implementation and wrote the <code>UpdateTitle</code> method in the service class.</p>
<p>I did not do this to upset DDD practitioners, but for practical purposes! Let me list the potential problems that you may encounter<a id="_idIndexMarker579"/> in this approach while using EF, the main .NET ORM:</p>
<ul>
<li><code>Post</code> class at runtime. This is not a common practice, and I am not even sure whether this is possible with non-hacky code.</li>
<li><code>Post</code> from the database, it will be unable to set the properties, which renders EF useless.</li>
<li><strong class="bold">Distribution of business logic</strong>: If the domain classes contain business logic, sometimes your business logic will be in services and sometimes it will be in domain objects rather than one or the other. In other words, it will be distributed in multiple classes.</li>
</ul>
<p>There are ways to make this work, but they<a id="_idIndexMarker580"/> aren’t worth the effort. Here, practicality doesn't meet the DDD theory, and this is why I opted to have anemic domain objects. The takeaway is that you know what DDD is advocating and the reason for that and you know why we are shifting from this practice.</p>
<p>Services do not care how data is loaded and persisted because it is the responsibility of the repositories, which naturally leads us to the next topic.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Exploring repositories</h1>
<p><strong class="bold">Repositories</strong> are classes that belong to infrastructure. They<a id="_idIndexMarker581"/> understand the underlying storage platform<a id="_idIndexMarker582"/> and interact with the specifics of the data store system.</p>
<p>They should not contain business logic, and they should only be concerned with loading and saving data.</p>
<p>Repositories<a id="_idIndexMarker583"/> are a way of achieving a single responsibility (as in SOLID’s single responsibility principle) by having the services and the domains responsible for business logic but not responsible for data persistence. DDD gives the data persistence responsibility to the repositories. </p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/>An example of a repository</h2>
<p>You’ve seen<a id="_idIndexMarker584"/> this line of code previously in the <code>UpdateTitleService</code> class:</p>
<pre class="source-code">var post = _postRepository.GetById(postId);</pre>
<p>Here, we will show you a potential implementation of <code>GetById</code>. </p>
<h3>Using Dapper with SQL Server</h3>
<p><strong class="bold">Dapper</strong> is a .NET library categorized<a id="_idIndexMarker585"/> under the<a id="_idIndexMarker586"/> term <em class="italic">micro-ORM</em>. It is very popular<a id="_idIndexMarker587"/> and used in <strong class="bold">StackOverflow</strong>.</p>
<p>Dapper<a id="_idIndexMarker588"/> can be used to access a SQL Server DB, so assuming our blog DB is a SQL Server one, we will use Dapper to implement <code>GetById</code> of <code>PostRepository</code>.</p>
<p>To use <code>Dapper</code> in any project, you can install it via <code>System.Data.SqlClient</code> NuGet:</p>
<pre class="source-code">using Dapper;
using System.Data.SqlClient;
…
public interface IPostRepository
{
    int CreatePost(int authorId);
    Post? GetById(int postId);
    void Update(Post post);
}
public class PostRepository : IPostRepository
{
    public Post? GetById(int postId)
    {
        var connectionString = … // Get con string from config
        using var connection = new SqlConnection
          (connectionString);
        connection.Open();
        var post = connection.Query&lt;Post&gt;(
            "SELECT * FROM Post WHERE Id = @Id", new {Id = 
                 postId}).SingleOrDefault();           
        connection.Close();
        return post;
    }
    … 
}</pre>
<p>Usually, the repository classes<a id="_idIndexMarker590"/> have an interface counterpart<a id="_idIndexMarker591"/> to allow them to be injected into services. Notice that in our previous <code>PostService</code>, we have injected <code>IPostRepository</code>.  The code shows how a repository works but it is not DI-compliant, however, it will be in the next section.</p>
<p>The <code>SqlConnection</code> class is an <strong class="bold">ADO.NET</strong> class, which allows you to manage<a id="_idIndexMarker592"/> a connection with a SQL Server DB.</p>
<p><code>Query()</code> is an extension method provided by Dapper. It allows<a id="_idIndexMarker593"/> you to issue a regular <strong class="bold">T-SQL</strong> query and map the results to an object.</p>
<h3>Using Dapper with SQL Server and DI</h3>
<p>As you’ve noticed, we<a id="_idIndexMarker594"/> have not injected <code>SqlConnection</code> and we have directly<a id="_idIndexMarker595"/> instantiated it in the code. Obviously, this<a id="_idIndexMarker596"/> is not the best practice! Here<a id="_idIndexMarker597"/> is an implementation that utilizes injecting the connection object:</p>
<pre class="source-code">public class PostRepository : IPostRepository
{
    private readonly IDbConnection _dbConnection;
    public PostRepository(<strong class="bold">IDbConnection dbConnection</strong>)
    {
        _dbConnection = dbConnection;
    }
    public Post? GetById(int postId)
    {
        _dbConnection.Open();
        var post = _dbConnection.Query&lt;Post&gt;(
            "SELECT * FROM Post WHERE Id = @Id", new {Id = 
                 postId}).SingleOrDefault();
        _dbConnection.Close();
        return post;
    }
    …
}</pre>
<p><code>SqlConnection</code> implements <code>IDbConnection</code> and we can wire this in the DI section in our startup to inject the right object at runtime (<em class="italic">not shown here, as this is a fictitious sample</em>). The DI will take care of instantiating the connection object, so we don’t have to do it here.</p>
<p>The <code>GetById</code> method uses Dapper’s ADO.NET extension methods<a id="_idIndexMarker598"/> to map the query results<a id="_idIndexMarker599"/> to a C# object. There are cleaner<a id="_idIndexMarker600"/> ways to achieve this, but I opted<a id="_idIndexMarker601"/> for the most readable one for this example.</p>
<h3>Using other DBs</h3>
<p>In the previous example, we have<a id="_idIndexMarker602"/> used a SQL Server DB; however, any other database would do. The only implementation that is going to change is within the <code>PostRepository</code> class. The consumers of <code>IPostRepository</code> will not change.</p>
<p>In the following chapters, we will demonstrate end-to-end implementations that use SQL Server (with EF) and Cosmos DB.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/>EF and repositories</h2>
<p><strong class="bold">EF</strong> is .NET’s major<a id="_idIndexMarker603"/> ORM. An <em class="italic">ORM</em> is a term to say<a id="_idIndexMarker604"/> it loads your relational DB<a id="_idIndexMarker605"/> records into objects.</p>
<p>EF provides a high level of abstraction that embodies multiple DDD patterns, most notably the repositories. When using EF, the repository pattern disappears in favor of EF and the code design becomes simpler.</p>
<p>In this chapter, it is enough to know this. In <a href="B18370_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, <em class="italic">Building an Appointment Booking App with Entity Framework and Relational DB</em>, we will have a complete implementation that includes EF with a fully working source code, which will clarify how things are done from end to end.</p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor204"/>Putting everything together</h1>
<p>This is my favorite part. I have been providing little snippets here and there and, hopefully, now you can see the big picture of how everything is linked from a DDD point of view. I have included the snippets in the source code directory. </p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor205"/>Solution Explorer view</h2>
<p>What we’ve done in this project<a id="_idIndexMarker606"/> is a collection of snippets. Let’s have a look at them:</p>
<div><div><img alt="Figure 7.5 – VS solution files from a DDD perspective " height="707" src="img/Figure_7.5_B18370.jpg" width="697"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – VS solution files from a DDD perspective</p>
<p>Let’s have a recap<a id="_idIndexMarker607"/> of every item:</p>
<ol>
<li><strong class="bold">Contracts</strong>: This is what the outside world sees. These contracts represent the shape of the data that will be exchanged between the backend and the client. The client should know the data elements of the contract, so it knows what to expect from your headless blog.</li>
<li><strong class="bold">Entities</strong>: They are the domain objects with identities.</li>
<li><strong class="bold">Value Objects</strong>: They are the domain objects that don’t require an identity.</li>
<li><strong class="bold">Domain Objects</strong>: This is the group of entities and value objects in your system.</li>
<li><strong class="bold">Repositories</strong>: These are the classes that will save and load your data from a data store (relational DB, document DB, file system, blog storage, and so on).</li>
<li><strong class="bold">Domain Services</strong>: This is where the business logic will live, and it will interact with the repositories for CRUD operations. These services are not exposed to the outside world.</li>
<li><code>REST</code> request. Application services are exposed to the outside world.</li>
</ol>
<p>It also happened that we only have<a id="_idIndexMarker608"/> a single aggregate, which is all our domain objects. A domain might have more than one aggregate. We also have <code>Post</code> as our aggregate root.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor206"/>Architectural view</h2>
<p>We’ve seen a potential project<a id="_idIndexMarker609"/> and file structure for our DDD project and now, let’s have a look at it from a software design point of view:</p>
<div><div><img alt="Figure 7.6 – A simplified software design view of DDD " height="502" src="img/Figure_7.6_B18370.jpg" width="876"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – A simplified software design view of DDD</p>
<p>Let’s discuss this DDD-style system:</p>
<ul>
<li><strong class="bold">Application Services</strong>: They interact with the clients and the domain services. They deliver the data to a client based on the contract and they deal with domain services directly.</li>
<li><strong class="bold">Domain Services</strong>: They provide services to <strong class="bold">Application Services</strong>.</li>
<li><strong class="bold">Infrastructure Services</strong>: They provide services that are not part of the domain, such as fetching the ZIP code/postcode city.</li>
<li><strong class="bold">Aggregate</strong>: Each aggregate contains several domain objects and has one aggregate root.</li>
<li><strong class="bold">Domain Objects</strong>: They are all the entities and value objects in all aggregates.</li>
</ul>
<p>I hope I was able to show<a id="_idIndexMarker610"/> you the foundation of the DDD design from the coding and projects structure and from an architectural view as well, although risking repeating the concepts twice.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor207"/>Summary</h1>
<p>There are topics in DDD that I have omitted, as they don’t contribute directly to the rest of the book, such as bounded contexts, domain events, units of work, and others. I have provided additional resources in the <em class="italic">Further reading</em> section that will help you to explore the concepts further.</p>
<p>We have discussed the basics of DDD and I am expecting this chapter to make you familiar with this concept, so we can use the terms such as <em class="italic">domain objects</em>, <em class="italic">domain services</em>, and <em class="italic">repositories</em> freely in later chapters without you raising an eyebrow. We have also seen sample code of the different constituents of DDD.</p>
<p>We have also seen where we will shift from DDD guidelines where it is more practical to do so and explained why.</p>
<p>In the next chapter, we will set a foundation for a complete project that will utilize all that you’ve learned so far, including DDD.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor208"/>Further reading</h1>
<p>To learn more about the topics discussed in this chapter, you can refer to the following resources:</p>
<ul>
<li><em class="italic">Domain-Driven Design</em> by Eric Evans, Addison-Wesley (2003)</li>
<li><em class="italic">Implementing Domain-Driven Design</em> by Vaughn Vernon, Addison-Wesley (2013)</li>
<li><em class="italic">Hands-On Domain-Driven Design with .NET Core</em> by Alexey Zimarev, Packt Publishing (2019)</li>
<li><em class="italic">Design a DDD-oriented microservice</em>: <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/ddd-oriented-microservice</a></li>
<li><em class="italic">Martin Fowler on DDD</em>: <a href="https://martinfowler.com/bliki/DomainDrivenDesign.xhtml">https://martinfowler.com/bliki/DomainDrivenDesign.xhtml</a></li>
<li><em class="italic">Quickstart: Build a console app by using the .NET V4 SDK to manage Azure Cosmos DB SQL API account resources</em>: <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4">https://docs.microsoft.com/en-us/azure/cosmos-db/sql/create-sql-api-dotnet-v4</a></li>
<li><em class="italic">Dapper on GitHub</em>: <a href="https://github.com/DapperLib/Dapper">https://github.com/DapperLib/Dapper</a></li>
</ul>
</div>
</div>
</body></html>