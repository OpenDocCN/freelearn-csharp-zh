- en: Chapter 2. Dissecting F# Origins and Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 解构 F# 的起源和设计
- en: 'This chapter reviews F# features from the historical perspective tracking them
    back to origins where possible. The review covers:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从历史的角度回顾 F# 特性，尽可能追溯到它们的起源。回顾包括：
- en: F# evolvement timeline
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 发展时间线
- en: Predecessor inherited language features
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前身继承的语言特性
- en: .NET imposed language features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 强制语言特性
- en: Intrinsic F# language features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 内在语言特性
- en: Although F# is a functional-first programming language, at the same time, you
    should not forget that it is a multi-paradigm tool that allows paradigms to be
    combined if required. Another important aspect you should keep in mind is that
    F# is designed for a .NET platform, so certain language facilities are shaped
    by underlying implementation mechanisms and interoperability requirements. The
    goal of this chapter is to dissect the language into components in a way that
    allows you to grasp the origins and the logic behind a contemporary F# design.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 F# 是一种以函数优先的编程语言，但同时，你也不应忘记它是一个多范式工具，如果需要的话，它允许结合不同的范式。另一个你应该记住的重要方面是，F#
    是为 .NET 平台设计的，因此某些语言特性是由底层实现机制和互操作性要求塑造的。本章的目标是以一种让你能够理解 F# 设计的起源和逻辑的方式，将语言分解成组件。
- en: The evolvement of F#
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 的发展
- en: Press began mentioning ([http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language](http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language)
    ) the F# programming language in the Summer of 2002 as a research project at Microsoft
    Research Cambridge ([http://research.microsoft.com/en-us/labs/cambridge/](http://research.microsoft.com/en-us/labs/cambridge/)
    ) aiming to create a dialect of **OCaml** language ([https://ocaml.org/](https://ocaml.org/)
    ) running on top of the .NET platform. Computer scientist Don Syme ([http://research.microsoft.com/en-us/people/dsyme/](http://research.microsoft.com/en-us/people/dsyme/)
    ) was in charge of design and the first implementation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体开始提及 ([http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language](http://developers.slashdot.org/story/02/06/08/0324233/f---a-new-net-language))
    F# 编程语言是在 2002 年夏季，作为微软剑桥研究院的一个研究项目 ([http://research.microsoft.com/en-us/labs/cambridge/](http://research.microsoft.com/en-us/labs/cambridge/))
    )，旨在创建一个在 .NET 平台上运行的 OCaml 语言 ([https://ocaml.org/](https://ocaml.org/)) 的方言。计算机科学家
    Don Syme ([http://research.microsoft.com/en-us/people/dsyme/](http://research.microsoft.com/en-us/people/dsyme/))
    负责设计和首次实现。
- en: Predecessors
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前身
- en: The F# project of Microsoft Research Cambridge didn't come from scratch. F#
    belongs to ML ([https://en.wikipedia.org/wiki/ML_(programming language)](https://en.wikipedia.org/wiki/ML_(programming%20language))
    ) programming language family. It predecessors are Standard ML ([https://en.wikipedia.org/wiki/Standard_ML](https://en.wikipedia.org/wiki/Standard_ML)
    ) and **OCaml** . Moreover, F# initially had a twin project at Microsoft Research
    Cambridge named SML.NET, which aimed at bringing **Standard ** **ML** ( **SML**
    ) to the .NET platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微软剑桥研究院的 F# 项目并非从零开始。F# 属于 ML ([https://zh.wikipedia.org/wiki/ML_(编程语言)](https://zh.wikipedia.org/wiki/ML_(编程语言)))
    编程语言家族。它的前身包括标准 ML ([https://zh.wikipedia.org/wiki/Standard_ML](https://zh.wikipedia.org/wiki/Standard_ML))
    ) 和 **OCaml**。此外，F# 在微软剑桥研究院最初还有一个双胞胎项目，名为 SML.NET，旨在将 **标准** **ML** ( **SML**
    ) 带到 .NET 平台。
- en: F# Version 1
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 版本 1
- en: The first release took place in December of 2004, labelled as a Microsoft Research
    project. This means that at that time, it didn't have the status of a Microsoft
    product, although it was providing integration with Visual Studio 2003 and Visual
    Studio 2005 Beta.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次发布是在 2004 年 12 月，被标记为微软研究院项目。这意味着在当时，它并没有成为微软产品的地位，尽管它提供了与 Visual Studio
    2003 和 Visual Studio 2005 测试版的集成。
- en: F# Version 1.1
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 版本 1.1
- en: Released in October 2005, this version is signified by bringing its object-oriented
    features to the language. It represents the milestone where F# had turned into
    a genuinely multi-paradigm language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2005 年 10 月发布的这个版本标志着将面向对象特性引入语言，这标志着 F# 成为一个真正的多范式语言的里程碑。
- en: '*"The major addition to the F# language itself in this release is what we''re
    calling the "F# Object and Encapsulation Extensions". This combines what I''ve
    found to be the best features of the .NET object oriented paradigm with the functional
    programming model that lies at the core of F#. This means that F# has become a
    mixed functional/imperative/object-oriented programming language." *Don Syme (*
    [http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx](http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx)
    *) in his blog on August 23, 2005.**'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在这个版本中，对 F# 语言本身的重大补充是我们所说的“F# 对象和封装扩展”。这结合了我认为 .NET 面向对象范例的最佳特性与 F# 核心的函数式编程模型。这意味着
    F# 已经成为一门混合了函数式/命令式/面向对象的编程语言。” —— Don Syme 在 2005 年 8 月 23 日的博客中提到。*[http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx](http://blogs.msdn.com/b/dsyme/archive/2005/08/24/455403.aspx)*
- en: Another feature that makes version 1.1 ponderous is introducing of F# Interactive,
    also known as FSI, the tool providing F# scripting capabilities and the manner
    of code development by frequenting REPL along the course. This release was suitable
    for use within the final version of Visual Studio 2005.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使 1.1 版本显得沉重的特性是引入了 F# Interactive，也称为 FSI，这是一个提供 F# 脚本能力和通过频繁使用 REPL 进行代码开发的工具。这个版本适用于
    Visual Studio 2005 的最终版本。
- en: After the version 1.1 milestone, the language continued to have frequent releases
    and introduce new major features. On October 17, 2007, Microsoft Corp officially
    declared a transition of F# from research to product development organization,
    aiming to productize F# into another first class programming language on the .NET
    platform fully integrated into Visual Studio. Following another year of intensive
    work, in December 2008 came the announcement of F# to be shipped as the integral
    part of Visual Studio 2010.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.1 版本的重要里程碑之后，该语言继续频繁发布并引入新的主要功能。2007年10月17日，微软公司正式宣布将 F# 从研究转向产品开发组织，旨在将
    F# 产品化，使其成为 .NET 平台上完全集成到 Visual Studio 的另一门一流编程语言。经过一年的密集工作，2008年12月宣布 F# 将作为
    Visual Studio 2010 的组成部分发布。
- en: F# Version 2
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 版本 2
- en: In February 2010, it was announced that the version of F# to be included into
    Visual Studio 2010 will be incremented to 2.0\. Shortly afterwards, in April 2010,
    F# 2.0 was released, indeed, as part of Visual Studio 2010 and also as the matching
    installation for Visual Studio 2008 and standalone compiler for other platforms.
    The F# version 2.0 milestone reflects almost 5 years of F# 1.x evolvement, which
    has added to object-oriented facilities on top of its functional programming base
    such major language features as active patterns, sequence expressions, asynchronous
    and parallel computations, and significant library refinements. Also, it worth
    noting that integration with Visual Studio provided developers using F# on Microsoft
    platform with world class tooling such as, debugging, IntelliSense, and the project
    system. At this point, F# 2.0 is completely ready for enterprise software development.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年2月，宣布即将包含在 Visual Studio 2010 中的 F# 版本将升级到 2.0。不久之后，2010年4月，F# 2.0 正式发布，作为
    Visual Studio 2010 的一部分，同时也是 Visual Studio 2008 的匹配安装版本，以及其他平台的独立编译器。F# 2.0 版本的重要里程碑反映了
    F# 1.x 近5年的发展历程，在此期间，在函数式编程的基础上增加了面向对象的功能，如活动模式、序列表达式、异步和并行计算，以及显著的库改进。此外，值得一提的是，与
    Visual Studio 的集成为在 Microsoft 平台上使用 F# 的开发者提供了世界级的工具，如调试、IntelliSense 和项目系统。此时，F#
    2.0 已完全准备好用于企业级软件开发。
- en: Also, F# version 2.0 delineates the stage of language evolvement that is usually
    recognized as *full-fledged* F# in comparison with primordial versions that lack
    some core features.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与原始版本相比，F# 版本 2.0 界定了语言发展的一个阶段，通常被认可为成熟的 F#。
- en: F# Version 3
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 版本 3
- en: Another intensive year and a half of F# evolvement brought to life a preview
    version of F# 3.0 in the September of 2011\. This version proclaimed targeting
    information-rich programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个半年的 F# 发展历程在2011年9月带来了 F# 3.0 的预览版本。这个版本宣称目标是信息丰富的编程。
- en: '*"A growing trend in both the theory and practice of programming is the interaction
    between programming and rich information spaces. From databases to web services
    to the semantic web to cloud-based data, the need to integrate programming with
    heterogeneous, connected, richly structured, streaming and evolving information
    sources is ever-increasing. Most modern applications incorporate one or more external
    information sources as integral components. Providing strongly typed access to
    these sources is a key consideration for strongly-typed programming languages,
    to insure low impedance mismatch in information access." *Technical Report MSR-TR-2012-101
    of Microsoft Research* ([http://research.microsoft.com/apps/pubs/?id=173076](http://research.microsoft.com/apps/pubs/?id=173076)
    ).*'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"编程理论和实践中的一个日益增长的趋势是编程与丰富信息空间之间的交互。从数据库到网络服务，再到语义网和基于云的数据，将编程与异构的、连接的、结构丰富的、流式传输和不断发展的信息源集成的需求不断增长。大多数现代应用程序都将一个或多个外部信息源作为基本组件。为这些源提供强类型访问是强类型编程语言的关键考虑因素，以确保在信息访问中低阻抗不匹配。"
    *微软研究技术报告 MSR-TR-2012-101* ([http://research.microsoft.com/apps/pubs/?id=173076](http://research.microsoft.com/apps/pubs/?id=173076)
    )。'
- en: With this goal, the language acquires query expressions, an incredibly powerful
    mechanism of type providers along with numerous reference implementations of type
    providers for major enterprise information exchange technologies. It took another
    year for F# 3.0 to get released as part of Visual Studio 2012 in September 2012.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，该语言获得了查询表达式，这是一个非常强大的类型提供者机制，以及针对主要企业信息交换技术的众多类型提供者参考实现。F# 3.0 在 2012
    年 9 月作为 Visual Studio 2012 的一部分发布，又过了一年。
- en: The following year, 2013, signified an explosive burst of activity around F#,
    indicating that the language reached some critical mass. Xamarin ([https://xamarin.com](https://xamarin.com)
    ) announced support for F#, reaching multiplatform mobile development, and multiple
    break-through developments took place in the fields of machine learning, cloud
    programming, finance time series, numeric libraries, and type providers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二年，即 2013 年，标志着围绕 F# 的活动激增，这表明该语言达到了一些关键质量。Xamarin ([https://xamarin.com](https://xamarin.com)
    ) 宣布支持 F#，实现了多平台移动开发，并在机器学习、云编程、金融时间序列、数值库和类型提供者等领域发生了多次突破性发展。
- en: This period also signifies strong cross-platform open engineering community
    effort, factually turning F# into an open source cross-platform shared implementation
    not fundamentally dependent on Microsoft anymore. The Microsoft affiliation with
    F# got limited to Visual F#, also known as *The F# Tools for Visual Studio* ,
    and even in this space, Microsoft turned to enabling community contributions and
    open engineering.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个时期也标志着强大的跨平台开放工程社区的努力，实际上将 F# 转变为一个不再根本依赖于微软的开源跨平台共享实现。微软与 F# 的关联仅限于 Visual
    F#，也称为 *Visual Studio 的 F# 工具*，即使在这一点上，微软也转向了启用社区贡献和开放工程。
- en: F# Version 4
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 版本 4
- en: 'Announced in late 2014, F# 4.0 provided some new capabilities: type constructors
    were turned into first-class functions, mutable values could be captured by closures,
    and there were high-dimensional arrays, slicing syntax for lists, normalized collections
    in core run-time libraries, among others.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年底宣布的 F# 4.0 提供了一些新功能：类型构造函数被转换为第一类函数，可变值可以被闭包捕获，还有高维数组、列表的切片语法、核心运行时库中的规范化集合等。
- en: Getting you equipped with the vision of more than a dozen years of the language's
    exciting historical evolution, I now turn to the dissection of language features.
    In this chapter, these features are to be outlined only briefly, postponing the
    complete details of idiomatic usage to later chapters.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 带着超过十多年的语言激动人心的历史演变的视野，我现在转向对语言特性的剖析。在本章中，这些特性将仅简要概述，将惯用用法的完整细节推迟到后面的章节。
- en: Predecessor inherited language features
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前驱语言继承的特性
- en: F# inherits the core of the features associated with its functional-first nature
    from ML and OCaml. This means that its chief fashion of expressing computations
    is via the definition and application of functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: F# 从 ML 和 OCaml 继承了与其函数优先性质相关的核心特性。这意味着它表达计算的主要方式是通过函数的定义和应用。
- en: F# functions are first-class entities
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 函数是一等实体
- en: 'The ability to define and apply functions is a common feature of many programming
    languages. However, F# follows ML and other functional programming languages in
    treating functions similarly to, say, numeric values. The ways of treating functions
    in F# go well beyond the limits usually associated with stored-program computer
    concept:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和应用函数的能力是许多编程语言的共同特征。然而，F# 与 ML 和其他函数式编程语言一样，将函数视为类似于数值值。F# 中处理函数的方式远远超出了通常与存储程序计算机概念相关的限制：
- en: Functions can be used as arguments to other functions; the latter are higher-order
    functions in this case
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以用作其他函数的参数；在这种情况下，后者是高阶函数
- en: Functions can be returned from other functions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以从其他函数返回
- en: Functions can be computed from other functions, for example, with the help of
    function composition operators
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以从其他函数计算得出，例如，使用函数组合运算符
- en: Functions can be elements of structures usually associated with data
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以是通常与数据相关的结构元素
- en: Functions are free of side effects
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是无副作用的
- en: Computations with functions have the main form of *evaluating expressions*  as
    opposed to *making assignments to variables* . Expressions do not carry the stigma
    of ever-changing values stored in rewritable memory. When the function `triple
    x` is applied to argument value `3` , it evaluates some inner expression and returns
    `9.` We are sure that this result is consistent, may be repeatedly reproduced,
    and may change from `9` only if the argument value changes from `3` to something
    else.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的计算主要以*评估表达式*的形式为主，而不是*向变量赋值*。表达式不带有存储在可重写内存中不断变化的值的污名。当函数`triple x`应用于参数值`3`时，它评估一些内部表达式并返回`9`。我们确信这个结果是连贯的，可能被反复重现，并且只有当参数值从`3`变为其他值时，结果才会从`9`变为其他值。
- en: Functions can be curried and partially evaluated
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可以柔性和部分评估
- en: Currying is a method of converting a function of many arguments evaluation into
    an equivalent evaluation of a sequence of functions of a single argument each.
    Partial evaluation binds one or more first arguments of a curried function, effectively
    producing a new function of fewer (non-bound) arguments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 柔性化是一种将多参数函数的评估转换为一系列单参数函数等价评估的方法。部分评估绑定了一个或多个柔性化函数的第一个参数，有效地产生了一个具有较少（非绑定）参数的新函数。
- en: Functions may be anonymous
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可能是匿名的
- en: Why bother giving a name to a function that is passed to a higher-order function
    or is returned from it? For the sake of succinctness F# allows using generic `fun`
    and `function` forms of function definitions that will not be invoked from elsewhere,
    hence the name is omitted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要在传递给高阶函数或从其返回的函数上命名？为了简洁起见，F# 允许使用不会在其他地方调用的通用 `fun` 和 `function` 函数定义形式，因此省略了名称。
- en: Functions may be recursive
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可能是递归的
- en: A frequently used example of recursive function ([https://en.wikipedia.org/wiki/Recursive_function](https://en.wikipedia.org/wiki/Recursive_function)
    ) implementation is a divide and conquer algorithm ([https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)
    ) when a problem gets broken into a few of the same problems with less dimensions,
    so the same solving function can be applied. This breaking down continues until
    solutions get simple, and then smaller solutions are combined back to in the solution
    of the original size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数([https://en.wikipedia.org/wiki/Recursive_function](https://en.wikipedia.org/wiki/Recursive_function)
    )实现的常用例子是将问题分解为几个维度更小的相同问题，即分而治之算法([https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)
    )，这样就可以应用相同的解决函数。这种分解一直持续到解决方案变得简单，然后较小的解决方案被组合回原始大小的解决方案中。
- en: Functions may raise exceptions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可以引发异常
- en: Not every expression may always bring back a result value; the most beaten up
    example of such a situation is a number divided by zero. Another typical example
    would be invalid argument value that does not allow to return result. In such
    cases instead of returning the result an exception is to be thrown.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个表达式都能始终返回一个结果值；这种情况最典型的例子是零除以一个数。另一个典型例子是无效的参数值，它不允许返回结果。在这种情况下，不是返回结果，而是抛出一个异常。
- en: Functions may reference external values
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数可以引用外部值
- en: The use of an external value freezes it in the function definition, creating
    a so called **closure** .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用外部值将它们冻结在函数定义中，从而创建所谓的**闭包**。
- en: F# is a statically typed language
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 是一种静态类型语言
- en: Expressions and their constituents carry unique types that can be inferred by
    the F# compiler. As a rule, no implicit type conversions have place ever. F# compiler
    type checks programs and catches errors that may otherwise occur at run-time for
    dynamically typed languages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式及其组成部分具有由F#编译器推断的唯一类型。一般来说，不会发生隐式类型转换。F#编译器检查程序并捕获可能在动态类型语言运行时发生的错误。
- en: F# type inference provides type generalization
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#类型推断提供类型泛化
- en: Type assignment algorithm performed by the compiler often allows the programmer
    to omit type declarations if the context unambiguously determines them. It finds
    most general type possible for value binding and expression evaluation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器执行的类型分配算法通常允许程序员在上下文明确确定类型的情况下省略类型声明。它找到对值绑定和表达式评估最一般的类型。
- en: F# supports parametric polymorphism
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#支持参数多态
- en: A function may allow a generic type of argument(s); for example, the implementation
    of a function calculating the sum of the list elements of `int` , or `int64` ,
    or `bigint` may be the same.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可能允许通用的参数类型；例如，计算`int`、`int64`或`bigint`列表元素总和的函数实现可能相同。
- en: F# inherits the variety of aggregate data structures from ML
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#从ML继承了各种聚合数据结构
- en: 'Inherited data structures include the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的数据结构包括以下内容：
- en: A tuple or values of the algebraic product type, allowing you to represent values
    of heterogeneous types
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个元组或代数积类型的值，允许你表示异构类型的值
- en: A list or a finite sequence of zero or more values of the same type
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列表或相同类型的零个或多个值的有限序列
- en: Discriminated union or a custom algebraic sum type defined via a mechanism similar
    to the ML data type, in particular, allows recursive type definition (for example,
    binary tree)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过类似于ML数据类型的机制定义的区分联合或自定义代数和类型，特别是允许递归类型定义（例如，二叉树）
- en: The option to represent the absence or the presence of a value of a certain
    type
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示某种类型值的缺失或存在的选项
- en: A record that is like a tuple with components named rather than ordered
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类似于元组但组件被命名的记录
- en: An array, of course
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然是一个数组
- en: A sequence, which is implemented as extension of the data type with lazily evaluated
    value constructors in ML
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个序列，作为ML中数据类型的扩展实现，具有懒加载的值构造函数
- en: F# supports pattern matching
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#支持模式匹配
- en: Pattern matching is a powerful mechanism of data structure decomposition, allowing
    you to disassemble the data aggregate into components or define the processing
    depending on a particular structure/attributes of the data aggregate.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是数据结构分解的强大机制，允许你将数据聚合分解成组件或根据数据聚合的特定结构/属性定义处理。
- en: F# supports data references
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#支持数据引用
- en: Data references were introduced in ML in order to support mutable storage and,
    more broadly, imperative programming. F# inherits this feature for backward compatibility
    with ML without reservations. Values of the `ref` type allow you to achieve mutability,
    changing states and representing global variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据引用是在ML中引入的，以支持可变存储和更广泛地支持命令式编程。F#为了与ML向后兼容而不保留地继承了这一特性。`ref`类型的值允许你实现可变性，改变状态并表示全局变量。
- en: Functions are non-recursive by default
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数默认是非递归的
- en: F# follows OCaml in this respect, so recursive function binding should be labeled
    with the `rec` attribute. `let rec` immediately puts the name of the function
    into the scope shadowing the potential duplicate from the outer scope. In absence
    of `rec` attribute `let` puts the name of the function into the scope only after
    the body is fully defined, making the reference either unavailable within the
    function body, or in the worst case using an unintentionally shadowed outer one
    in place of the intended.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，F#遵循OCaml，因此递归函数绑定应该带有`rec`属性。`let rec`立即将函数名放入作用域中，以覆盖外部作用域中可能的重复。如果没有`rec`属性，`let`只在主体完全定义后将其放入作用域，这使得在函数体内部引用不可用，或者在最坏的情况下，无意中使用了外部作用域中无意中覆盖的名称。
- en: Modules
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Following ML and OCaml, F# offers modules as a way of grouping together related
    values, functions, and types. Effectively modules resemble static classes of C#
    and provide developers with means of grouping together, maintaining, and extending
    related entities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循ML和OCaml，F#提供模块作为将相关值、函数和类型组合在一起的方式。实际上，模块类似于C#的静态类，为开发者提供了将相关实体分组、维护和扩展的手段。
- en: .NET-imposed language features
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET强制的语言特性
- en: Along with the features inherited from the language predecessors, the multitude
    of F# features was brought into the language for the sake of interoperability
    with the .NET platform.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从语言前辈那里继承的特性外，F# 还引入了众多特性，以便与 .NET 平台进行互操作性。
- en: F# adheres to .NET Common Language Infrastructure
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 遵循 .NET 公共语言基础设施
- en: Run-time arrangement for the F# code has been defined by .NET **Common ** **Language **
    **Infrastructure** ( **CLI** ) and does not anyhow differ from the same of C#
    or VB.NET. F# compiler ingests F# source code file(s) and produces the intermediate
    code in assembly language named MSIL packaged as binary .NET assembly(ies). During
    code execution stage MSIL is converted into machine code as needed, or **Just-in-time**
    ( **JIT** ). Interoperability with other .NET languages is achieved as F#-produced
    assemblies do not anyhow differ from assemblies produced by C# or VB.NET. Similarly,
    the JIT compiler takes care of the target hardware platform providing portability.
    CLI also takes the burden of memory management on itself, making F# programs subject
    to .NET garbage collection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: F# 代码的运行时安排由 .NET **公共** **语言** **基础设施**（**CLI**）定义，并且与 C# 或 VB.NET 的相同。F# 编译器读取
    F# 源代码文件并生成名为 MSIL 的汇编语言中间代码，并将其打包为二进制 .NET 程序集。在代码执行阶段，MSIL 根据需要转换为机器代码，或 **即时**（**JIT**）。与其他
    .NET 语言的互操作性是通过 F# 生成的程序集与 C# 或 VB.NET 生成的程序集没有差异来实现的。同样，JIT 编译器负责目标硬件平台，提供可移植性。CLI
    还承担了内存管理的负担，使 F# 程序受到 .NET 垃圾收集的影响。
- en: F# has nominal type system
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 具有名义类型系统
- en: This is a significant deviation off OCaml and ML having a structural object
    system. Apparently, this design decision was dictated by the necessity to exist
    within and interact with the .NET object system, which is nominal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 OCaml 和 ML 的结构化对象系统有显著差异。显然，这个设计决策是由存在于 .NET 对象系统内并与该系统交互的必要性所决定的，而 .NET
    对象系统是名义的。
- en: F# fully embraces .NET object orientation
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 完全拥抱 .NET 面向对象
- en: F# allows you to follow the object-oriented paradigm of .NET from both the direction
    of using the existing .NET frameworks and object-oriented libraries as well as
    the direction of contributing F# code in the form of .NET libraries, frameworks,
    and tools.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: F# 允许你从两个方向遵循 .NET 的面向对象范式：一方面是使用现有的 .NET 框架和面向对象库，另一方面是将 F# 代码以 .NET 库、框架和工具的形式贡献出来。
- en: All F# entities are inherited from a single root type of `System.Object` , or
    `obj` . As such, they come with some common methods that are overridable and customizable.
    For custom F# entities such as discriminated unions, the compiler generates the
    implementation of these common `obj` methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 F# 实体都继承自单个根类型 `System.Object` 或 `obj`。因此，它们自带一些可覆盖和可定制的常用方法。对于自定义的 F# 实体，如区分联合，编译器会生成这些常用
    `obj` 方法的实现。
- en: In addition to the use of .NET classes, F# allows you to create your own custom
    classes consisting of *data* in the form of **fields** and *functions* manipulating
    these fields in the form of **methods** and **properties** . Special methods named
    **constructors** initialize instances of each class assigning certain values to
    fields. Classes may be further parameterized by type parameters getting generic
    this way. A class may inherit from the single **base class** and implement many
    **interfaces** . The subclass may modify the behavior of the base class by *overriding*
    its properties and methods. The custom classes are consumable from other tenants
    of .NET ecosystem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 .NET 类之外，F# 允许你创建自己的自定义类，这些类由 *数据* 组成，形式为 **字段**，以及以 **方法** 和 **属性** 的形式操作这些字段的
    *函数**。名为 **构造函数** 的特殊方法初始化每个类的实例，并将某些值分配给字段。类可以通过类型参数进一步参数化，从而获得泛型。一个类可以继承自单个
    **基类** 并实现许多 **接口**。子类可以通过 *重写* 基类的属性和方法来修改其行为。自定义类可以从 .NET 生态系统的其他部分使用。
- en: F# requires calling the method of an explicit interface
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 需要调用显式接口的方法
- en: 'F# differs from other .NET languages in this matter, so let me explain this
    with a short coding example as following (`Ch2_2.fsx` ):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: F# 在这方面与其他 .NET 语言不同，因此让我用一个简短的代码示例来解释这一点（`Ch2_2.fsx`）：
- en: '[PRE0]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `MyImpl` class implements the `MyInterface` interface. However,
    an attempt to use the implementation fails implicitly as if `MyImpl` does not
    have the method at all. Only after the explicit upcast of the `MyImpl` instance
    into `MyInterface` does the implementation get accessible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `MyImpl` 类实现了 `MyInterface` 接口。然而，尝试使用该实现会隐式失败，就像 `MyImpl` 完全没有该方法一样。只有将
    `MyImpl` 实例显式上转换为 `MyInterface` 后，实现才变得可访问。
- en: 'The justification of this design decision that comes to my mind is this: it
    would disambiguate situations when there is a need for implementing more than
    one interface that has similarly named methods. Also, this matter gets less annoying
    if we consider typical interface use as in the preceding `doit` function that
    has the `doer` parameter of type `IMyInterface` . In this case, the compiler does
    the cast for using `MyImpl` in place of `IMyInterface` implicitly. The execution
    of the preceding script illustrates this subtlety in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我脑海中浮现出的这个设计决策的合理性是这样的：它将消除需要实现多个具有类似名称方法的接口时的歧义。如果我们考虑典型的接口使用，如前面的 `doit` 函数中的
    `doer` 参数类型为 `IMyInterface`，这个问题就会变得不那么令人烦恼。在这种情况下，编译器会隐式地将 `MyImpl` 转换为 `IMyInterface`
    以使用 `MyImpl`。前面脚本的执行在以下屏幕截图中展示了这一细微差别：
- en: '![F# requires calling the method of an explicit interface](img/Image00005.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![F# 需要调用显式接口的方法](img/Image00005.jpg)'
- en: Object expressions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象表达式
- en: 'F# offers the way to implement an interface without bothering to create a custom
    type just for that purpose. The following code illustrates the implementation
    of `IMyInterface` from the preceding code with an object expression ([https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)
    ), followed by the implementation usage (`Ch2_3.fsx` ):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: F# 提供了一种实现接口的方法，无需为该目的创建自定义类型。以下代码展示了如何使用对象表达式（[https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)）从前面的代码中实现
    `IMyInterface`，然后是使用实现（`Ch2_3.fsx`）：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reflection
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射
- en: F# completely embraces .NET Reflection, allowing access to the metadata information
    of the program code at run-time. It is possible from F# as well as from other
    .NET languages to introspect the running application and get to type metadata
    and to attributes decorating the source code. The final goal of such exercises
    is usually to modify the run-time behavior of the already executing code. For
    example, the goal might be dynamically adding new components, or resolving dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: F# 完全支持 .NET 反射，允许在运行时访问程序代码的元数据信息。从 F# 以及其他 .NET 语言中都可以进行运行时应用程序的反射，获取类型元数据和装饰源代码的属性。此类练习的最终目标通常是修改已执行代码的运行时行为。例如，目标可能是动态添加新组件或解决依赖关系。
- en: F# core library contains the comprehensive tools for run-time analyzing and
    constructing F#-specific types and values within `Microsoft.FSharp.Reflection`
    namespace ([https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D)
    )
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: F# 核心库包含在 `Microsoft.FSharp.Reflection` 命名空间中用于运行时分析和构建 F# 特定类型和值的综合工具（[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/microsoft.fsharp.reflection-namespace-%5Bfsharp%5D)）。
- en: Extending classes and modules
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展类和模块
- en: F# allows a very unobtrusive way to extend classes and modules ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions)
    ). The first form usually referred as **intrinsic extension** is similar to *partial
    classes* of C#. Unfortunately, in F#, this form of class augmentation cannot cross
    boundaries of the source file, namespace, or assembly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: F# 允许以非常不显眼的方式扩展类和模块（[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/type-extensions)）。第一种形式通常被称为**内建扩展**，类似于
    C# 中的**部分类**。不幸的是，在 F# 中，这种形式的类扩展不能跨越源文件、命名空间或程序集的边界。
- en: The other form of extension, referred to as **optional extension** , goes through
    source files with ease. Its purpose clearly is augmenting any modules. Although
    much more widely applicable, this type of augmentation is not visible for reflection
    and cannot be utilized outside of F# from C# or VB.NET. We will take a close look
    at these augmentation methods later in the book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种形式的扩展，称为**可选扩展**，可以轻松地通过源文件进行。其目的显然是增强任何模块。尽管这种增强应用范围更广，但这种增强在反射中不可见，并且不能在C#或VB.NET之外从F#中使用。我们将在本书的后面部分仔细研究这些增强方法。
- en: Enumerations
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations in F# ([https://msdn.microsoft.com/en-us/library/dd233216.aspx](https://msdn.microsoft.com/en-us/library/dd233216.aspx)
    ) mimic C# enumerations, allowing you to create named numeric constants. As these
    are not discriminated unions, their use with pattern matching is limited. Also,
    they may be of use when manipulating combinations of binary flags.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的枚举([https://msdn.microsoft.com/en-us/library/dd233216.aspx](https://msdn.microsoft.com/en-us/library/dd233216.aspx)
    )模仿C#枚举，允许你创建命名的数值常量。由于这些不是判别联合，它们在模式匹配中的使用有限。此外，当操作二进制标志的组合时，它们可能很有用。
- en: Structures
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: Structures in F# ([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    ) are lightweight classes represented with value types. As such, their instances
    can be put on the stack, they take less memory than reference types, and they
    may not be required to participate in garbage collection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的结构([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    )是用值类型表示的轻量级类。因此，它们的实例可以放在栈上，它们比引用类型占用更少的内存，并且可能不需要参与垃圾回收。
- en: Events
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: F# events ([https://msdn.microsoft.com/en-us/library/dd233189.aspx](https://msdn.microsoft.com/en-us/library/dd233189.aspx)
    ) allow interoperation with .NET events of CLI. However, F# goes further than
    CLI, providing powerful aggregation, filtering, and partitioning in observer-observable
    and publish-subscribe scenarios.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: F#事件([https://msdn.microsoft.com/en-us/library/dd233189.aspx](https://msdn.microsoft.com/en-us/library/dd233189.aspx)
    )允许与CLI的.NET事件进行互操作性。然而，F#在CLI之上更进一步，提供了在观察者-可观察和发布-订阅场景中的强大聚合、过滤和分区功能。
- en: Nullable types
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空类型
- en: Nullable types ([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    ) address `null` value related problems that normally do not exist in F# due to
    idiomatic `option` types usage. As a rule, in any internal scenario F# allows
    to cover absence of value with `None` case of correspondent `option` type. However,
    F# code interoperation with C# and VB.NET code as well as low-level database manipulations
    from F# when `option` types cannot be used may require using nullable types instead
    for expressing the absence of values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可空类型([https://msdn.microsoft.com/en-us/library/dd233233.aspx](https://msdn.microsoft.com/en-us/library/dd233233.aspx)
    )解决了由于惯用的`option`类型使用而在F#中通常不存在的`null`值相关的问题。一般来说，在内部场景中，F#允许使用相应`option`类型的`None`情况来覆盖值的缺失。然而，当`option`类型不能使用时，F#代码与C#和VB.NET代码的互操作性以及从F#进行低级数据库操作可能需要使用可空类型来表示值的缺失。
- en: Interoperation with the managed code
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与托管代码的互操作性
- en: C# and VB.NET using F# code only can access public methods implemented in F#,
    leaving F#-specific data types or functions out of scope. Fortunately, the access
    in the opposite direction is easier as F# supersets C# and VB.NET features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用F#代码的C#和VB.NET可以访问在F#中实现的公共方法，但F#特定的数据类型或函数则不在作用域内。幸运的是，相反方向的访问更容易，因为F#是C#和VB.NET特性的超集。
- en: Interoperation with unmanaged code
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与非托管代码的互操作性
- en: When it comes to these infrequent cases of interoperation with legacy code or
    the use of libraries written in C/C++, F# follows C# using **P/Invoke** or **COM
    Interop** .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到与遗留代码的互操作性或使用用C/C++编写的库的这些不常见情况时，F#遵循C#使用**P/Invoke**或**COM Interop**。
- en: Intrinsic F# language features
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内在的F#语言特性
- en: Along with features inherited from F# predecessors, the F# language carries
    its own set of notable novel facilities. The outline of these facilities is discussed
    in the upcoming sections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从F#的前身继承的特性外，F#语言还拥有自己一套显著的创新功能。这些功能的概述将在接下来的章节中讨论。
- en: Indentation-aware syntax
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意识到缩进的语法
- en: Yes, this is correct; the F# compiler is sensitive to indentation in the source
    code ([https://msdn.microsoft.com/en-us/library/dd233191.aspx](https://msdn.microsoft.com/en-us/library/dd233191.aspx)
    ), so correct code formatting is not just a matter of aesthetics. Why? Firstly,
    the improved code readability is enforced by the compiler, and secondly, this
    design choice dramatically decreases the amount of noise in the F# source code
    as block markers (such as curly brackets in C#) do not present, overall making
    the F# source code significantly shorter than the equivalent C# one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是正确的；F# 编译器对源代码中的缩进非常敏感([https://msdn.microsoft.com/en-us/library/dd233191.aspx](https://msdn.microsoft.com/en-us/library/dd233191.aspx)
    )，因此正确的代码格式不仅仅是美观问题。为什么？首先，编译器强制执行了代码的可读性改进，其次，这种设计选择显著减少了F#源代码中的噪声量，因为块标记（如C#中的花括号）不存在，总体上使得F#源代码比等效的C#代码短得多。
- en: Units of measure
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 度量单位
- en: This feature ([https://msdn.microsoft.com/en-us/library/dd233243.aspx](https://msdn.microsoft.com/en-us/library/dd233243.aspx)
    ) allows you to decorate values with associated units and statically validate
    unit usage correctness by the compiler as well as infer units associated with
    the expression value based on units of operands. Let us look at the following
    example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能([https://msdn.microsoft.com/en-us/library/dd233243.aspx](https://msdn.microsoft.com/en-us/library/dd233243.aspx)
    )允许您用关联的单位装饰值，并通过编译器静态验证单位使用是否正确，同时根据操作数的单位推断与表达式值关联的单位。让我们看看以下示例。
- en: 'Here, I have defined two measures: `<m>` meters for distance and `<s>` seconds
    for time. Knowing how to find speed from acceleration and distance from physics,
    I defined a `fallSpeed` function to find the speed of objects falling from the
    given argument `height` at the time of hitting the ground as shown in the following
    code (`Ch2_1.fsx` ):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我定义了两个度量单位：`<m>` 表示米（距离）和 `<s>` 表示秒（时间）。了解如何从加速度和距离中找到速度，我定义了一个 `fallSpeed`
    函数来找到物体从给定的 `height` 参数下落并撞击地面时的速度，如下面的代码所示（`Ch2_1.fsx`）:'
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now using this function, it is easy to find that a water bottle that accidentally
    dropped from the top of the Empire State Building hit the pavement of 5th Avenue
    in New York City with a speed of 86.46 meters per second (`<m/s>` ), hopefully
    not hurting a random bystander from the tourist crowd hanging out near the entrance.The
    following code represents the preceding example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用这个函数，很容易发现一个不小心从帝国大厦顶部掉下来的水瓶以每秒86.46米的速度撞击了纽约市第五大道的人行道，希望没有伤害到在入口附近闲逛的游客中的任何一位。以下代码表示了前面的示例：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the compiler will not allow anything but float decorated with `<m>`
    as the argument for `fallSpeed` . Also, the function correctly infers that units
    of measure for the resulting speed are meters per second. Neat, right? But seriously,
    consider this CNN article back from 1999 titled *Metric mishap caused loss of
    NASA orbiter* ([http://www.cnn.com/TECH/space/9909/30/mars.metric.02/](http://www.cnn.com/TECH/space/9909/30/mars.metric.02/)
    ). The $125 million loss of satellite would not occur if units of measure checks
    were in place. Unfortunately, NASA and Lockheed Martin software systems used for
    the satellite flight control were operating each in its own system of measures
    and integration tests failed to discover this defect prior to the actual flight
    beginning.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，编译器只允许将 `<m>` 装饰的浮点数作为 `fallSpeed` 的参数。此外，该函数正确地推断出结果速度的单位是每秒米。不错吧？但说真的，考虑一下这篇1999年的CNN文章，标题为
    *“度量错误导致NASA探测器损失”* ([http://www.cnn.com/TECH/space/9909/30/mars.metric.02/](http://www.cnn.com/TECH/space/9909/30/mars.metric.02/)
    )。如果存在单位检查，就不会发生1.25亿美元的卫星损失。不幸的是，NASA和洛克希德·马丁公司用于卫星飞行控制的软件系统各自运行在自己的度量系统中，集成测试未能发现这一缺陷，直到实际飞行开始之前。
- en: Overloaded operators
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符重载
- en: F# allows the overloading ([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx)
    ) of the existing operators as well as creating new unary and infix operators.
    It allows providing multiplicity of implementations for unary (prefix) and infix
    operations based on concrete types of operands. For example, an implementation
    of rational fractions arithmetic may use three versions of addition operation
    represented by infix operator `+` applicable to adding fraction to integer, integer
    to fraction, and fraction to fraction. Overloading has a positive side allowing
    to express semantic of manipulating objects of some domain tersely. But this feature
    is good in moderation as excessive overloading may be detrimental to code readability.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: F#允许对现有运算符进行重载([https://msdn.microsoft.com/en-us/library/dd233204.aspx](https://msdn.microsoft.com/en-us/library/dd233204.aspx)
    )以及创建新的单目和中缀运算符。它允许根据操作数的具体类型提供单目（前缀）和中缀操作的多种实现。例如，有理分数算术的实现可能使用三种加法操作版本，分别由中缀运算符`+`表示，适用于将分数加到整数、整数加到分数以及分数加到分数。重载具有积极的一面，可以简洁地表达操作某些领域对象的语义。但这个特性在适度时是好的，因为过度重载可能会损害代码的可读性。
- en: Inline Functions
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数
- en: Inline functions ([https://msdn.microsoft.com/en-us/library/dd548047.aspx](https://msdn.microsoft.com/en-us/library/dd548047.aspx)
    ) represent a specific compilation technique. Normally a compiled function with
    non-generic type of arguments is associated with a single piece of MSIL and each
    function reference is compiled into invocation of this code and receiving back
    the evaluated result. However, it is impossible to have compiled MSIL for generic
    arguments within .NET type system. F# offers a smart workaround by statically
    evaluating arguments of each specific function invocation and creating MSIL adjusted
    for non-generic argument types of this particular function invocation. By following
    the outlined technique F# achieves function argument generalization under very
    limited support from .NET type system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数([https://msdn.microsoft.com/en-us/library/dd548047.aspx](https://msdn.microsoft.com/en-us/library/dd548047.aspx)
    )代表一种特定的编译技术。通常，具有非泛型类型参数的编译函数与单个MSIL相关联，并且每个函数引用都被编译成对该代码的调用并返回评估结果。然而，在.NET类型系统中，无法为泛型参数编译MSIL。F#通过静态评估每个特定函数调用的参数并创建针对此特定函数调用非泛型参数类型的MSIL，提供了一种聪明的解决方案。通过遵循概述的技术，F#在.NET类型系统非常有限的支持下实现了函数参数泛化。
- en: Type constraints and statically resolved type parameters
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型约束和静态解析的类型参数
- en: 'It is sufficient to have genuinely generic function type arguments in only
    very limited number of design and implementation situations . Usually, the addition
    of a custom combination of distinctive additional properties of the argument type
    is required in order to give the F# compiler a way of statically checking whether
    the type generalization is specific enough for the task. In most such cases, type
    inference is smart enough to derive such constraining from the static context,
    but sometimes, it may be desired that the developer provide some extra constraining.
    The process and further details of supplying the additional static constraints
    is described by the link: [https://msdn.microsoft.com/en-us/library/dd233203.aspx](https://msdn.microsoft.com/en-us/library/dd233203.aspx)
    . The book puts this matter under scrutiny in [Chapter 10](text00071.html#ch10
    "Chapter 10. Type Augmentation and Generic Computations") , *Type Augmentation
    and Generic Computations* .'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常有限的设计和实现情况下，只需要有真正通用的函数类型参数。通常，需要添加自定义组合的独特附加属性来为F#编译器提供一种方式，以便在静态上检查类型泛化是否足够具体以完成任务。在大多数此类情况下，类型推断足够智能，可以从静态上下文中推导出此类约束，但有时可能希望开发者提供一些额外的约束。提供额外静态约束的过程和详细情况由以下链接描述：[https://msdn.microsoft.com/en-us/library/dd233203.aspx](https://msdn.microsoft.com/en-us/library/dd233203.aspx)。本书在[第10章](text00071.html#ch10
    "第10章。类型增强和泛型计算")中对此问题进行了审查，*类型增强和泛型计算*。
- en: Active Patterns
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动模式
- en: Active patterns ([https://msdn.microsoft.com/en-us/library/dd233248.aspx](https://msdn.microsoft.com/en-us/library/dd233248.aspx)
    ) tremendously amplify the power of pattern matching by allowing the usage of
    custom functions within pattern matching rules. In other words, pattern matching
    can be specialized for any desired level of sophistication. Active patterns are
    absolutely essential for mastery over F#, and I will devote a lot of attention
    to them in the following chapters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 活动模式（[https://msdn.microsoft.com/en-us/library/dd233248.aspx](https://msdn.microsoft.com/en-us/library/dd233248.aspx)）通过允许在模式匹配规则中使用自定义函数，极大地增强了模式匹配的能力。换句话说，模式匹配可以针对任何所需的复杂程度进行专门化。活动模式对于掌握F#至关重要，我将在接下来的章节中投入大量关注于它们。
- en: Computation Expressions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式
- en: Computation expressions ([https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)
    ) represent quite an advanced topic. They provide tools for representation of
    complex nested computations sequenced and bound with simple looking syntax sugar.
    Some of F# language's very own features are implemented with the help of computation
    expressions, namely sequence expressions, query expressions, and asynchronous
    computations. F# also allows you to write custom computation expressions, providing
    tremendous extensibility power.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式（[https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)）是一个相当高级的主题。它们提供了用于表示复杂嵌套计算的工具，这些计算通过看似简单的语法糖进行排序和绑定。F#语言的一些自身特性是通过计算表达式实现的，即序列表达式、查询表达式和异步计算。F#还允许你编写自定义的计算表达式，提供了巨大的扩展能力。
- en: Query Expressions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询表达式
- en: Query expressions ([https://msdn.microsoft.com/en-us/library/hh225374.aspx](https://msdn.microsoft.com/en-us/library/hh225374.aspx)
    ) represent the language-provided form of computation expressions addressing language
    integrated queries, also known as LINQ in F#. They are a part of mechanics addressing
    the information rich programming I've mentioned earlier, allowing data consumed
    from the multiplicity of sources and in the multiplicity of forms to be manipulated
    uniformly. For example, data obtained off OData service, web service defined with
    WSDL, or SQL server can be transformed to a certain extent without taking into
    consideration the specifics of their origin.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查询表达式（[https://msdn.microsoft.com/en-us/library/hh225374.aspx](https://msdn.microsoft.com/en-us/library/hh225374.aspx)）代表了语言提供的计算表达式形式，用于处理语言集成查询，也称为F#中的LINQ。它们是解决我之前提到的信息丰富编程的机制的一部分，允许从多种来源和多种形式中消费数据，并能够统一地操作这些数据。例如，从OData服务、使用WSDL定义的Web服务或SQL服务器获取的数据可以在一定程度上进行转换，而不必考虑其来源的具体细节。
- en: Asynchronous workflows
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步工作流
- en: Asynchronous workflows ([https://msdn.microsoft.com/en-us/library/dd233250.aspx](https://msdn.microsoft.com/en-us/library/dd233250.aspx)
    ) in F# are presented, in a manner similar to query expressions, by a language-provided
    form of computation expressions, and they demonstrate the mechanism's power and
    universal nature. They allow you to execute asynchronous code against implicitly
    provided thread pool at a high level of abstraction from asynchronous computations'
    arrangement details. As a corollary, writing F# asynchronous code is almost as
    simple as synchronous code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的异步工作流（[https://msdn.microsoft.com/en-us/library/dd233250.aspx](https://msdn.microsoft.com/en-us/library/dd233250.aspx)）以与查询表达式类似的方式呈现，由语言提供的计算表达式形式展示，并展示了该机制的强大和通用性。它们允许你在高抽象级别上针对隐式提供的线程池执行异步代码，从而无需关注异步计算的安排细节。作为结果，编写F#的异步代码几乎与同步代码一样简单。
- en: Meta-programming
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元编程
- en: 'Meta-programming ([https://msdn.microsoft.com/en-us/library/dd233212.aspx](https://msdn.microsoft.com/en-us/library/dd233212.aspx)
    ) is an extremely powerful and exciting technique that allows programs to write
    other programs. It may take different forms and occur at different levels: at
    native machine-level code, at MSIL level, or even at the source code level of
    F# or another programming language. A few years ago, I was quite excited about
    this feature and blogged a short series on this matter: **F# Metaprogramming part
    1: JIT Some Native Code on the Fly** ([https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/](https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/)
    ), **F# Metaprogramming part 2: Dynamic synthesis of executable F# code** ([https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/](https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/)
    ), and **F# Metaprogramming part 3: Creating MSIL on the Fly** ([https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/](https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/)
    ).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程 ([https://msdn.microsoft.com/en-us/library/dd233212.aspx](https://msdn.microsoft.com/en-us/library/dd233212.aspx)
    ) 是一种极其强大且令人兴奋的技术，它允许程序编写其他程序。它可能采取不同的形式，发生在不同的级别：在原生机器代码级别，在MSIL级别，甚至在F#或另一种编程语言的源代码级别。几年前，我对这个特性非常兴奋，并就此主题撰写了一系列简短的文章：**F#
    元编程第1部分：即时编译一些原生代码** ([https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/](https://infsharpmajor.wordpress.com/2012/03/04/how-hard-is-to-jit-some-native-code-from-f/))，**F#
    元编程第2部分：动态合成可执行F#代码** ([https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/](https://infsharpmajor.wordpress.com/2012/04/01/how-to-dynamically-synthesize-executable-f-code-from-text/))，以及**F#
    元编程第3部分：即时创建MSIL** ([https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/](https://infsharpmajor.wordpress.com/2012/04/12/creating-msil-from-f-on-the-fly/))。
- en: However, usually, when developers consider F# meta-programming, a different
    program level is involved, namely F#, but in a partially compiled form associated
    with the language feature known as **quoted expressions** . When the F# compiler
    comes across specifically delimited F# code, then instead of making this code
    part of the program, it compiles it into a special object representing the F#
    expression. The great power of this feature is that when compiled in this manner,
    F# expressions can be further transformed into the form that's good for execution
    in a completely different environment, for example, inside a web browser in the
    form of JavaScript or in some **Graphic** **Processing ** **Unit** ( **GPU** ),
    reaching, in principle, a vast amount of diverse computational platforms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常当开发者考虑F#元编程时，会涉及到不同的程序级别，即F#，但与称为**引用表达式**的语言特性相关联的半编译形式。当F#编译器遇到特定的F#代码时，它不会将这段代码作为程序的一部分，而是将其编译成一个表示F#表达式的特殊对象。这个特性的强大之处在于，以这种方式编译后，F#表达式可以被进一步转换为适合在完全不同的环境中执行的形式，例如，以JavaScript的形式在网页浏览器中，或者在某种**图形处理单元**（**GPU**）中，原则上可以到达大量的不同计算平台。
- en: Type providers
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提供者
- en: Type providers ([https://msdn.microsoft.com/en-us/library/hh156509.aspx](https://msdn.microsoft.com/en-us/library/hh156509.aspx)
    ) represent the meta-programming feature as well. However, instead of transforming
    some form of source code into executable form type providers does something completely
    different. A typical type provider represents a data source of certain kind as
    an assortment of types with their methods and properties ready to be seamlessly
    used exactly the same way as human-written types or libraries. It's worth noting
    that the provided types carry the same qualities as the hand-written ones. They
    can be statically checked, introspected by Intellisense, inferred by F# compiler.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者 ([https://msdn.microsoft.com/en-us/library/hh156509.aspx](https://msdn.microsoft.com/en-us/library/hh156509.aspx)
    ) 也代表了元编程功能。然而，类型提供者并不像将某种形式的源代码转换为可执行形式那样做完全不同的事情。一个典型的类型提供者将某种类型的数据源表示为一系列具有方法和属性的类型，这些类型可以无缝地被使用，就像人类编写的类型或库一样。值得注意的是，提供的类型具有与手动编写的类型相同的品质。它们可以进行静态检查，通过Intellisense进行内省，由F#编译器推断。
- en: For example, the SqlClient type provider ([http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/)
    ) allows F# developers to get type-safe access to the complete set of features
    of the Microsoft SQL server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，SqlClient类型提供者([http://fsprojects.github.io/FSharp.Data.SqlClient/](http://fsprojects.github.io/FSharp.Data.SqlClient/))允许F#开发者以类型安全的方式访问Microsoft
    SQL服务器完整的功能集。
- en: Another fantastically powerful use case for type providers is the interoperability
    between F# and other programming languages. One of the big successes in this field
    is F# R Type Provider ([http://bluemountaincapital.github.io/FSharpRProvider/](http://bluemountaincapital.github.io/FSharpRProvider/)
    ), allowing access from F# to a vast amount of R programming language libraries
    for statistical computing. Using F# in tandem with **R Type Provider** gave a
    big boost to using F# in the fields of machine learning and data science.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者另一个极其强大的用例是F#与其他编程语言之间的互操作性。这个领域的重大成功之一是F# R类型提供者([http://bluemountaincapital.github.io/FSharpRProvider/](http://bluemountaincapital.github.io/FSharpRProvider/))，它允许从F#访问大量用于统计计算的R编程语言库。与**R类型提供者**结合使用大大促进了F#在机器学习和数据科学领域的应用。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter familiarized you with F# features dissected according to origins
    and design motives. You now better understand where the each language feature
    comes from, what features come from the ML breed, what language design decisions
    are dictated by the hosting .NET platform, what features of F# are unique, and
    what the causes for their inclusion into the language were.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使你熟悉了根据起源和设计动机分解的F#特性。你现在更好地理解了每个语言特性从何而来，哪些特性来自机器学习流派，哪些语言设计决策是由托管.NET平台决定的，F#的独特特性是什么，以及它们被纳入语言的原因。
- en: 'Equipped with this knowledge, you are now ready to absorb the main contents.
    In the next chapter, I''ll turn to the feature at the core of F#: functions and
    their uses.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有了这些知识，你现在准备好吸收主要内容了。在下一章中，我将转向F#的核心特性：函数及其用法。
