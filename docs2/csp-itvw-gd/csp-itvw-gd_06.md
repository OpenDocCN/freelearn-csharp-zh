

# 高级 C#概念

随着我们深入 C#编程的领域，很明显，这种语言在其看似简单的表面之下，隐藏着丰富的先进功能，旨在解决复杂的软件开发需求。本章深入探讨 C#的这些复杂方面，为你提供知识，让你能够构建高效、灵活和健壮的应用程序。

从集合的复杂性和**语言集成查询（LINQ**）的力量到异步性的细微差别，我们将踏上一次启迪人心的探险，超越基本的编程结构。我们将探索委托和 lambda 的世界，揭开垃圾回收的神秘面纱，踏过多线程和并发的复杂路径。

虽然这些主题最初可能看起来令人畏惧，但请记住，掌握它们是区分新手程序员和资深开发者的关键。到本章结束时，你将精通以下领域：

+   使用集合和 LINQ 高效地操作数据

+   有效调试代码并优雅地处理异常

+   通过异步编程提升用户体验

+   利用委托、事件和 lambda 表达式来构建更流畅和适应性强的代码

+   使用泛型构建可重用代码

+   掌握多线程的复杂性并确保平滑的并发操作

+   通过理解和管理垃圾回收来优化性能

准备提升你的 C#技能？让我们踏上这段激动人心的旅程吧！

# 与集合和 LINQ 一起工作

在 C#编程的广阔领域中，**集合**作为基础结构，作为数据的多功能容器。但如果我们能够以类似数据库操作的方式查询和操作这些集合会怎样呢？这就是**LINQ**的用武之地。本节揭示了集合和 LINQ 的协同作用，引导你通过高效组织、查询和操作数据集的艺术。无论你是在处理简单的项目列表还是复杂的嵌套结构，集合和 LINQ 的结合将改变你在 C#中处理数据的方式。准备好探索那些不仅会提升你的编码能力，而且会极大地提高你应用程序的效率和清晰度的技术。

## “IEnumerable”和“ICollection”接口之间的关键区别是什么？何时使用每个接口是最优的？

`IEnumerable`和`ICollection`都是.NET Framework 中用于处理数据集合的接口，但它们有不同的用途：

+   **IEnumerable** 提供了遍历集合的基本能力。它暴露了一个枚举器，支持对非泛型集合进行简单遍历。本质上，如果你只需要枚举项，**IEnumerable** 就足够了。

+   **ICollection**扩展了**IEnumerable**，并提供了用于操作集合大小以及添加、删除和检查集合中元素存在性的额外方法。

在实践中，请执行以下操作：

+   当你只想迭代集合而不需要修改它时，请使用**IEnumerable**。

+   当需要操作集合本身时，例如添加或删除项目，请使用**ICollection**。

## LINQ 中的“延迟执行”原则是如何工作的，它如何影响性能？

使用`foreach`循环或使用`ToList()`或`ToArray()`等方法转换结果。这可以通过避免不必要的计算来提高性能。然而，管理数据实际*实体化*的时刻很重要——即，检索并加载到内存中。过早地实体化数据有时会消耗更多资源，尤其是在数据源很大时，例如数据库。在决定实体化结果之前，你可能想要在查询中添加更多条件或过滤器，以优化资源使用和性能。

## “Where”和“Select”LINQ 方法的主要区别是什么，何时最好使用每个方法？

**Where**和**Select**都是 LINQ 提供的扩展方法，但它们有不同的用途：

+   **Where**：此方法用于根据给定的谓词过滤集合。它返回一个新的集合，仅包含满足指定条件的元素。

+   **Select**：此方法用于投影或转换集合的元素。它返回一个新的集合，其中包含根据指定的函数或投影已转换的元素。

在实践中，请执行以下操作：

+   当你想过滤集合并仅保留满足某些标准的元素时，请使用**Where**。

+   使用**Select**当你想要转换集合中的元素时，例如提取特定的属性或以某种方式转换数据

## “All”和“Any”LINQ 方法之间的区别是什么，它们在应用于空集合时如何表现？

两者**All**和**Any**都是用于评估集合是否满足特定标准的 LINQ 方法。以下是它们的区别：

+   **All**：检查集合中的每个元素是否都满足特定条件。当需要确保集合的所有元素都满足特定标准时，请使用**All**。

+   **Any**：检查集合中是否至少有一个元素满足特定条件。当需要确定是否存在满足特定标准的元素时，请使用**Any**。

当集合为空时，以下情况发生：

+   **All**：始终返回**true**，因为没有元素会违反条件。这可能会显得反直觉，但在没有元素进行检查的情况下，它默认为**true**。

+   **Any**：始终返回**false**，因为没有元素可以满足条件。

例如，如果你想验证列表中的所有数字都是正数，你会使用`All`。如果你要检查列表中是否有负数，你会使用`Any`。

## “FirstOrDefault”与“SingleOrDefault”有什么区别，以及这些方法在什么情况下返回“null”？

`FirstOrDefault`和`SingleOrDefault`都用于从集合中检索元素，但它们服务于稍微不同的目的：

+   **FirstOrDefault**：返回满足条件的第一个元素或如果没有指定条件则返回第一个元素。如果没有找到匹配元素，则返回默认值（通常为引用类型的**null**）。

+   **SingleOrDefault**：返回满足条件的唯一元素，但如果存在多个匹配元素则抛出异常。如果没有元素匹配条件，则返回默认值。

关于返回`null`，以下规则适用：

+   对于引用类型，当在集合中找不到匹配元素时，两种方法都返回**null**。

+   然而，对于值类型（如**int**和**double**），它们将返回类型的默认值（例如**int**的默认值为**0**）。

## 你认为 .NET 中的主要集合类型有哪些，它们的关键区别是什么？

.NET 提供了几个主要的集合类型：

+   **List<T>**：元素的动态数组。它保持顺序并允许重复元素。

+   **Dictionary<TKey, TValue>**：键值对的集合。它没有定义的顺序，且键必须是唯一的。

+   **HashSet<T>**：唯一元素的集合。它不维护任何特定顺序。

+   **Queue<T>**：支持**先进先出**（**FIFO**）操作的集合。

+   **Stack<T>**：支持**后进先出**（**LIFO**）操作的集合。

## “List<T>”与“Dictionary<TKey, TValue>”之间有什么区别？

`List<T>`与`Dictionary<TKey, TValue>`之间的主要区别在于访问元素的方式。在`List<T>`中，通过索引访问元素，而在`Dictionary<TKey, TValue>`中，通过键访问元素。

## 如何优化处理大数据集时 LINQ 查询的执行？

通过几种方法可以优化 LINQ 查询，特别是对于大量数据集：

+   尽可能地使用**延迟执行**，确保查询仅在真正需要结果时才执行。这样可以避免不必要的计算。

+   根据你的特定用例选择最有效的集合类型，因为底层的数据结构可能会影响性能。

+   当可能时，使用如**Take**等方法限制结果数据集的大小，以避免处理比必要更多的数据。

+   避免或谨慎使用嵌套查询。它们可能导致性能问题，因为需要进行多轮数据检索或计算。

+   如果预期对数据进行多次操作，请使用**ToArray**或**ToList**等方法将结果实体化到内存中。这可以防止重复执行相同的 LINQ 查询。

## “IEnumerable”和“IQueryable”接口之间的关键区别是什么？解释它们的实现和使用场景。

`IEnumerable`和`IQueryable`是表示.NET 中集合的两个主要接口。这是它们的作用：

+   **IEnumerable**：在内存对象级别操作。当你对**IEnumerable**接口执行 LINQ 查询时，操作是在内存中执行的。它适用于处理内存中的集合，如数组或列表。

+   **IQueryable**：设计用于与外部数据源（例如，数据库）交互。使用**IQueryable**制作的查询被转换为针对数据源（如关系数据库的 SQL）特定的查询。此接口允许延迟执行和**内存外**（**OOM**）数据查询，这使得它对于大型数据集，尤其是在数据库中，效率更高。

这两个接口之间的主要区别在于执行位置：`IEnumerable`在内存中处理数据。而`IQueryable`允许构建一个可以转换为适合外部数据源（如数据库的 SQL）的查询的表达树。然后，它将解析的查询发送到数据源进行处理，并将结果作为`IEnumerable`检索。

## C#中数组和“List<T>”之间的关键区别是什么？在什么情况下使用这些结构是最优的？

主要区别在于灵活性和大小。数组一旦定义就具有固定的大小，而`List<T>`可以随着元素的添加或删除动态调整大小。

与其他数据结构相比，数组通常在索引访问方面更快，并且由于没有与存储额外元数据或维护未使用容量相关的开销，因此它们可以更节省内存。当项目数量已知且保持不变时，数组尤其适合，因为它们不能像列表那样动态调整大小。

另一方面，`List<T>`提供了一系列有用的方法用于操作，可以根据需要增长或缩小。当集合大小不确定或需要`List<T>`相对于数组提供的额外功能和方法时，它是一个最佳选择。

从本质上讲，虽然数组对于静态集合来说更轻量级和高效，但`List<T>`为动态集合提供了更多的灵活性。

## 在哪些场景下应该优先选择“HashSet<T）”而不是“List<T)”？

`HashSet<T>`维护一组唯一的元素，并针对需要快速查找、插入和删除操作以及确保唯一性的操作进行了优化。当需要防止重复或频繁执行查找操作时，使用`HashSet<T>`。

另一方面，`List<T>`是一个有序集合，可以包含重复元素，当元素顺序很重要时很有用。

这两种选择之间的区别在很大程度上取决于具体的用例和您打算更频繁执行的操作。

## 在 C#中，“LinkedList<T>”和“List<T>”之间的关键区别是什么？在哪些场景下使用“LinkedList<T>”是最优的？

`LinkedList<T>`是一个双链表，其中每个节点都有对前一个和下一个节点的引用。相比之下，`List<T>`是一个动态数组。基本区别在于数据存储方式和修改方式。`LinkedList<T>`由于其基于节点的结构，在列表中间进行插入和删除操作时是最优的，这允许高效地添加或删除节点而不需要移动其他元素。相反，`List<T>`由于其数组支持的性质，在索引访问方面效率较高。

当预期频繁插入或删除，尤其是在集合中间时，`LinkedList<T>`可能更高效。然而，如果主要操作涉及索引访问或集合大小相对静态，`List<T>`可能是一个更好的选择。

## “Dictionary<TKey, TValue>”在 C#中代表什么？它的典型用例有哪些？

C#中的`Dictionary<TKey, TValue>`是一个键值对集合，其中键是唯一的。这种数据结构允许基于键进行快速查找、插入和删除。其典型用例包括存储配置设置、缓存数据和需要快速检索与唯一键关联的值的场景，例如查找表或字典。

## C#中的不可变集合是什么？它们有什么优点和缺点？

C#中的不可变集合是在创建后不能被修改的集合。而不是直接修改它们，任何会改变集合的操作都会返回一个新的集合实例，其中包含所需的变化。使用不可变集合的优点包括线程安全（因为没有风险其他线程意外修改集合）以及确保数据在其生命周期内保持不变。然而，它们可能比可变集合性能差，尤其是在需要频繁修改时，因为每次修改都会创建一个新的集合。这也可能导致内存使用增加。

随着我们结束对 C#中集合和 LINQ 的讨论，你现在将更好地准备在 C#项目中以更高的效率和灵活性处理数据。在这里获得的知识为你在即将到来的项目中处理复杂的数据相关任务奠定了坚实的基础。

接下来，我们将深入探讨 C#中异常处理和调试的重要领域。这些技能对于增强应用程序的健壮性、帮助快速识别和解决问题至关重要。请关注下一部分，我们将提供关于如何熟练地处理错误和异常的见解和策略。

# 异常处理和调试

任何软件，无论其复杂程度如何，都容易受到意外行为和错误的影响。应对这些未预见的挑战需要一套强大的工具和技术，这就是异常处理和调试发挥作用的地方。本节深入探讨了在 C#代码中识别、理解和解决异常的复杂性。从优雅地使用异常处理来管理意外场景，到像外科医生一样精确地检查你的代码，我们将为你提供确保应用程序平稳高效运行的技能。拥抱将陷阱转化为学习机会，并确保你的软件解决方案具有弹性和可靠性的旅程。

## 在“catch”块中使用“throw”和“throw ex”之间有什么区别？

当你使用`throw`而不带任何参数时，你实际上是在重新抛出当前异常，保留原始堆栈跟踪。这有助于更容易地进行调试，因为你保留了有关异常最初抛出位置的信息。另一方面，当你使用`throw ex`时，你会将堆栈跟踪重置为当前的`catch`块，可能会丢失有关异常起源位置和方式的重要信息。因此，通常建议在`catch`块中使用`throw`本身来重新抛出捕获的异常。

## C#中的主要异常类型有哪些，以及它们通常在什么条件下出现？

C#提供各种异常类型，以适应不同的异常场景。以下是一些关键类型：

+   **ArgumentNullException**: 当一个方法期望非空值但传入的参数为**null**时，会抛出此异常

+   **ArgumentOutOfRangeException**: 当一个参数的值超出允许的范围时，会发生此情况

+   **DivideByZeroException**: 当尝试除以零时，会抛出此异常

+   **InvalidOperationException**: 当一个对象的状态不允许执行特定操作时，会出现此情况

+   **FileNotFoundException**: 当尝试访问的文件不存在时，会发生此异常

+   **StackOverflowException**: 当由于过度递归或其他原因导致堆栈溢出时，会抛出此异常

+   **NullReferenceException**: 当你尝试访问一个对象引用的成员，而这个对象引用是**null**时，会发生此异常

## 在“try-catch”结构中，“finally”块的作用是什么，以及是否存在可能不会执行的场景？

`finally`块确保无论在先前的`try`或`catch`块中是否抛出了异常，其中的代码都会被执行。这对于清理操作特别有用，例如关闭文件或数据库连接。

在大多数情况下，`finally`块将执行。然而，在罕见的情况下，例如程序终止或灾难性异常（例如`StackOverflowException`或进程终止），`finally`块可能不会执行，因为这些关键错误可能会破坏程序执行的正常流程，应用程序将停止，没有机会运行`finally`块。

## “内部异常”是什么，以及如何利用它来改进调试？

**内部异常**指的是导致当前异常抛出的先前异常。当当前异常是另一个异常的结果时，它特别有用。通过检查内部异常，开发者可以追溯到问题的根本原因，为导致最终异常的事件序列提供一个更清晰的画面。这在调试过程中非常有价值，因为它有助于确定问题的主要来源，以及可能导致当前状态的级联失败。当抛出自定义异常时，你可以将原始异常作为内部异常包含在内，从而保留这种因果关系链。

## “堆栈跟踪”是什么，它如何有助于跟踪异常？

**堆栈跟踪**提供了从抛出异常的点开始的方法调用序列的快照。它本质上显示了应用程序在遇到异常之前经历的方法调用层次结构。这对于开发者来说非常有用，因为它提供了关于异常发生时的执行流程和上下文的见解。通过分析堆栈跟踪，开发者通常可以确定异常的确切位置和原因，使调试和解决问题更加高效。

## 在 Visual Studio 中，“条件断点”的本质是什么，以及在什么情况下使用它是有益的？

一个`true`。这在问题仅在特定情况下或与特定数据出现时特别有用。通过使用条件断点，开发者可以有效地调试复杂问题，而无需手动多次暂停和检查程序状态。

## 我们如何处理或避免“未处理的异常”？

一个`catch`块。为了防止这种情况，请执行以下操作：

+   将可能抛出异常的代码用适当的**try**-**catch**块包围，确保你正在捕获特定的异常类型，或者在必要时捕获一般异常。

+   使用全局异常处理程序，例如.NET Framework 应用程序中的**AppDomain.UnhandledException**或**TaskScheduler.UnobservedTaskException**来处理未观察到的任务的异常。这提供了一个安全网，确保任何未捕获的异常都以某种方式得到解决。

+   总是验证和清理输入，并注意潜在的异常来源，如 I/O 操作、数据库访问和第三方库调用。

## “Debug”和“Release”配置之间有什么区别？

在 Visual Studio 中，两个主要的构建配置是`Debug`和`Release`。`Debug`配置针对代码调试而定制。它通常包括额外的调试信息，不应用某些编译器优化，并且可能通过使用预处理器指令启用不同的代码路径（例如更详细的日志记录）。这确保了调试体验的流畅性，允许开发者逐步执行代码、检查变量并有效地使用断点。

另一方面，`Release`配置针对应用程序的最终部署进行了优化。代码以完全优化编译，移除了任何调试信息，这导致了更好的性能和通常更小的二进制文件大小。此外，某些特定的调试代码路径可能被排除，确保最终产品精简高效。

理解和选择正确的配置至关重要，因为它可以显著影响应用程序的性能和行为。

## 如何故意触发一个异常？

您可以使用`throw`关键字以编程方式生成异常。例如，执行`throw new Exception("Test exception");`将引发一个带有`"Test exception"`消息的异常。故意触发异常在需要强制执行某些条件或验证代码中的假设的情况下可能很有用。

## 在单元测试开发和调试中，使用“Assert”和“Throw”有什么区别？

`Assert`主要用于验证在代码的特定点预期为真的条件。如果条件未满足，断言失败通常会停止执行，提醒开发者存在差异，尤其是在调试会话期间。它是确保开发过程中代码正确性和假设的工具。

另一方面，`Throw`用于引发异常，指示错误条件或意外场景。这些异常可以被捕获并在调用堆栈的更高层进一步处理。

虽然两者都可以用于识别和解决问题，但它们的主要目的和使用场景不同：`Assert`更多地与开发期间验证代码逻辑有关，而`Throw`则与处理异常运行时场景有关。

## 应该如何处理“Task”中的异常？在错误处理的上下文中，“async void”和“async Task”有什么区别？

当处理`Task`中的异常时，有几种方法。可以在任务上使用`ContinueWith`方法来处理异常，或者使用`await`关键字，并在`try`-`catch`块中包装等待的任务来捕获可能抛出的任何异常。

在异常处理方面，`async void`和`async Task`方法之间的区别至关重要。`async void`方法不返回任务，因此从这些方法抛出的异常会直接进入线程池。这可能导致未观察到的异常，最坏的情况下，如果没有捕获，可能会无声地失败，而开发者没有任何提示。另一方面，`async Task`返回一个封装操作的任务，异常可以通过等待任务或检查其结果来观察和处理。

随着我们深入探讨 C#中的异常处理和调试，一个我们掌握了诊断和纠正代码差异技巧的领域，我们即将步入异步编程的动态领域，使用`async`和`await`。

接下来的部分将增强您的 C#编程能力，解锁同时操作的可能性，为更响应和高效的代码执行铺平道路。让我们无缝地从精通错误调试过渡到利用现代 C#中固有的并发和并行性。准备好迎接一个令人着迷的学习曲线吧！

# 使用`async`和`await`进行异步编程

在当今快节奏的数字世界中，响应性至关重要。用户需要快速、流畅的应用程序，最重要的是，非阻塞。进入`async`和`await`关键字的领域。本节揭示了异步操作在提高应用程序性能和响应性方面的变革力量。我们将探索在不阻塞主线程的情况下并发执行任务的技术，确保无缝的用户体验。通过掌握`async`和`await`，您将解锁在幕后执行复杂操作的可能性，让您的应用程序保持快速和以用户为中心。加入我们，利用高效编码的未来，将您的应用程序提升到新的效率和交互高度。

## “async”和“await”关键字在 C#中的目的是什么？

C#中的`async`和`await`关键字用于表示和执行异步操作，允许非阻塞代码执行。`async`关键字表示一个方法可能包含异步代码，而`await`用于异步等待任务完成，而不会冻结主线程。这使您可以编写更响应的应用程序，尤其是在处理 I/O 密集型操作或长时间运行的计算时。

## 多线程和异步编程之间的主要区别是什么？

使用`event`循环来高效地处理非阻塞操作。

## “async”方法返回什么？

异步方法可以返回`void`、`Task`、`Task<T>`或`ValueTask<T>`。然而，通常建议避免从异步方法返回`void`，除非是在事件处理器中，因为这会使错误处理变得困难；在异步`void`方法中抛出的异常无法被调用者捕获，导致未处理的异常，这可能导致应用程序崩溃。返回`Task`或`Task<T>`允许调用者等待其完成或链式其他延续。

## 不谨慎使用“async”和“await”可能会出现哪些陷阱？

不谨慎地使用`async`和`await`可能导致几个问题：

+   **死锁**：尤其是在混合同步和异步代码时

+   **线程饥饿**：过度依赖线程池可能导致所有线程都被消耗，从而造成处理延迟

+   **性能开销**：不必要的使用可能会引入性能开销

+   **调试复杂性**：由于非线性的执行流程，异步代码可能更难以调试

## 在异步编程的背景下，“死锁”是什么，以及如何避免？

在异步编程的背景下，当异步代码无意中阻塞等待另一个操作完成，而该操作又正在等待原始操作时，就会发生**死锁**。这种情况导致两个操作都无法继续进行。死锁通常在混合同步和异步代码或不适当地等待任务时出现。为了避免死锁，请遵循以下指南：

+   避免在异步方法上同步等待（例如，避免使用**.Result**或**.Wait()**）

+   适度使用**ConfigureAwait(false)**以防止将延续操作回传到原始上下文，这可能是死锁的来源，尤其是在 UI 应用程序中。

## 异步如何影响调用栈？

异步可以将调用栈分割成几个部分。当调用异步方法时，它们几乎立即返回，通常在任务完成之前。这意味着传统的调用栈可能无法代表完整的执行序列，从而使得调试变得复杂。Visual Studio 中的**任务**窗口等工具可以帮助开发者理解异步操作的状态和流程。

## “Task”、“Task<T>”和“ValueTask<T>”之间有什么区别？

让我们来看看这些类型之间的区别：

+   **Task**表示一个不返回值的异步操作。它本质上是一个承诺，表示将来会完成一些工作。

+   **Task<T>**表示一个在完成时返回类型为**T**的值的异步操作。

+   **ValueTask<T>**是一个针对可能同步提供结果的场景进行优化的新类型，可能避免堆分配。它在高性能场景中特别有用，可以减少开销，但应谨慎使用，因为误用可能会引入微妙的错误或降低性能。

## 如何并发执行多个异步操作并等待它们的完成？

您可以使用 `Task.WhenAll()` 来并发执行多个异步操作并等待它们的完成。此方法返回一个单独的 `Task` 对象，当所有提供的任务都完成时，该对象将完成。这是一种同时启动多个任务，然后在所有这些任务完成后继续执行的方法。

## 在类构造函数或终结器中使用异步方法可能会引发哪些问题？

可能会出现一些问题，例如以下情况：

+   在构造函数中使用异步方法可能会使对象初始化变得复杂，因为构造函数不能返回一个 **Task** 对象。这意味着您不能在构造函数中直接调用异步方法，这使得在对象初始化期间执行异步操作变得具有挑战性。

+   在终结器中使用异步方法可能会导致问题，因为对象可能在异步操作完成之前被垃圾回收。终结器不打算包含异步代码，这样做可能会导致不可预测的行为。

## 异步方法中如何处理异常？

异步方法中的异常可以使用标准的 `try`-`catch` 块来处理。然而，需要注意的是，异常可能不会在任务变为 *faulted* 之前抛出。这意味着异常将在您调用 `await` 为任务时抛出。如果在等待的异步方法中发生异常，它将像同步代码一样传播到调用方法。还值得注意的是，如果 `Task.WhenAll()` 等待的并发任务抛出多个异常，所有异常都将捆绑成一个 `AggregateException` 异常。

## 异步编程中的“同步上下文”是什么，它的重要性是什么？

**同步上下文**表示异步操作运行的环境。它确保异步代码可以正确地与具有特定要求的环境交互，例如 Windows Forms 或 WPF 应用程序中的 UI 线程。这对于确保与 UI 交互的操作在适当的线程上执行至关重要。本质上，同步上下文充当异步代码与其执行上下文之间的桥梁，允许对 UI 或其他线程特定资源进行线程安全的更新。

## “ConfigureAwait”是如何工作的，为什么建议使用“ConfigureAwait(false)”？

`ConfigureAwait` 允许开发者在异步操作完成后指定是否将执行返回到原始 *同步上下文*。使用 `ConfigureAwait(false)` 表示延续代码不应在原始上下文中运行，这可能会防止死锁并提高性能，尤其是在库代码中。这确保了异步方法不会尝试将延续操作回传到原始上下文，这可能是不必要的，甚至是有害的。

## “任务延续”是什么，它是如何使用的？

`Task` 实例完成。它通常通过在 `Task` 实例上使用 `ContinueWith` 等方法来使用，允许开发者在无需嵌套回调的情况下链式操作。延续操作可以用来定义在异步操作之后应该运行的逻辑，而不阻塞线程，这使得序列化异步操作或处理结果变得更加容易。

## 异步方法如何与线程交互？

异步方法本身不会生成新线程。相反，它们使用机制在当前线程上异步执行代码，在必要时利用线程池进行计算密集型操作。异步方法的关键优势是它们允许可能阻塞的操作，如 I/O 密集型工作，释放控制权，从而让当前线程执行其他任务。这导致了对系统资源的更有效利用，尤其是在许多操作可能正在等待外部因素（如网络响应或文件读取）的场景中。

## 在异步操作中，“TaskCompletionSource”是什么意思？

`TaskCompletionSource` 提供了一种手动控制任务完成的方式。它在需要将异步代码与其他不原生使用 `Task` 模式的异步机制集成的场景中特别有用。本质上，使用 `TaskCompletionSource`，您可以直接设置其关联任务的结果、异常或取消状态。

## “取消令牌”是什么，它是如何使用的？

**取消令牌** 提供了一种请求取消正在进行的操作的方式。它通常传递给异步方法，异步方法可以定期检查令牌以查看是否已请求取消，从而允许操作优雅地提前终止。这对于长时间运行的操作尤为重要，您希望用户或调用代码能够中断并停止操作。

## TPL 中的“Parallel”和“async/await”之间的区别是什么？

`Parallel` 是为跨多个线程并行执行代码而设计的，专注于可以并发执行的 CPU 密集型操作。它是通过在多个核心上分配计算来优化 CPU 使用率。

另一方面，`async/await` 是为了代码的非阻塞执行而设计的，尤其是针对 I/O 密集型操作。它通过允许线程在等待长时间运行的操作完成时执行其他任务，从而提高响应性和可伸缩性。

## TPL 中的并行循环是什么，如何控制它们？

在 TPL 中，有两个主要的 `Parallel` 循环：`Parallel.For` 和 `Parallel.ForEach`。

你可以通过使用 `ParallelOptions` 并设置 `MaxDegreeOfParallelism` 来控制线程数。`MaxDegreeOfParallelism` 的默认值设置为 `-1`，表示 TPL 自动决定要使用的线程数，通常基于处理器核心的数量。然而，你可以修改此值以限制最大线程数。这在任务资源密集型且你不想过载系统的情况下可能很有用。

要管理循环，你可以使用 `Break()` 和 `Stop()` 方法，如下所述：

+   **Break()**：`Break()` 方法表示需要停止当前迭代的执行。

    下面是一个示例：

    ```cs
    var options = new ParallelOptions { MaxDegreeOfParallelism = 2 };
    ```

    ```cs
    Parallel.For(0, 10, options, (i, state) => {
    ```

    ```cs
        if (i == 5) {
    ```

    ```cs
            state.Break();
    ```

    ```cs
            return;
    ```

    ```cs
        }
    ```

    ```cs
        Console.WriteLine($"Processing item {i}");
    ```

    ```cs
    });
    ```

    在前面的示例中，`Parallel.For` 处理从 `0` 到 `9` 的数字。如果它遇到数字 `5`，它将使用 `Break()` 停止迭代中的进一步处理。

+   **Stop()**：`Stop()` 方法尽可能快地停止执行。此方法对于控制循环状态至关重要。

    下面是一个示例：

    ```cs
    Parallel.ForEach(dataCollection, (data, state) => {
    ```

    ```cs
        if (someCondition) {
    ```

    ```cs
            state.Stop();
    ```

    ```cs
            return;
    ```

    ```cs
        }
    ```

    ```cs
        // Process data
    ```

    ```cs
    });
    ```

    在前面的示例中，如果你正在处理大量数据并遇到关键错误，你可以使用 `Stop()` 立即停止处理。

## 如何使用 Parallel.ForEachAsync，以及它与 Parallel.ForEach 之间的区别是什么？

`Parallel.ForEach` 是一个用于并行执行迭代的同步方法。

`Parallel.ForEachAsync` 支持迭代中的异步操作。这在需要执行异步请求或具有等待时间的操作（如与数据库或 Web 服务的交互）时很有用。

下面是一个示例：

```cs
await Parallel.ForEachAsync(dataCollection, async (data, cancellationToken) => {
    // Asynchronous processing of each data item
    await ProcessDataAsync(data);
});
```

在前面的示例中，`Parallel.ForEachAsync` 允许数据集中的每个项目异步处理，这对于涉及延迟的任务（如数据库查询或对 Web 服务的调用）是有益的。

## 在什么情况下，不使用 await 调用异步函数是合适的，这如何影响执行？

如果你不需要在移动到下一行代码之前等待异步函数的完成，你可以不使用 `await` 来调用异步函数。然而，这可能会导致未跟踪的错误和管理线程执行困难的问题。方法执行将继续，不受异步操作状态的影响，这可能导致不可预测的行为，尤其是如果它影响了共享资源或应用程序的状态。

此外，当需要同时启动多个异步任务时，异步函数可以在不使用 `await` 的情况下被调用。然而，没有 `await`，你无法捕获任务执行过程中可能发生的异常，并且操作的结果将被忽略。

下面是一些示例：

+   这里，它是在忽略结果：

    ```cs
    _ = DoSomeAsync();
    ```

+   这里，它是在并行运行任务：

    ```cs
    public async Task ProcessDataAsync(IEnumerable<Data> dataList) {
    ```

    ```cs
        var tasks = new List<Task>();
    ```

    ```cs
        foreach (var data in dataList) {
    ```

    ```cs
            tasks.Add(ProcessSingleDataAsync(data));
    ```

    ```cs
        }
    ```

    ```cs
        await Task.WhenAll(tasks);
    ```

    ```cs
    }
    ```

    ```cs
    public async Task ProcessSingleDataAsync(Data data) {
    ```

    ```cs
        await Task.Delay(TimeSpan.FromSeconds(1));
    ```

    ```cs
        return data;
    ```

    ```cs
    }
    ```

在第二个示例中，`ProcessDataAsync` 并行启动了几个异步任务，并使用 `Task.WhenAll` 等待它们的完成。这种方法对于高效地并发处理多个任务非常有用。

## 在 C# 8.0 中，“异步流”是什么，以及“`IAsyncEnumerable`”如何转换实时数据处理？

在 C# 8.0 中引入的 `await foreach`。`IAsyncEnumerable` 是一个接口，它便于创建可以异步读取的数据流。当处理大型数据流或异步产生数据的源时，这特别有益。它提供了一种按数据可用性处理数据的方法，而不是等待整个数据集，这使得它在实时应用中特别有价值。

## 你如何使用“`SemaphoreSlim`”进行异步资源访问同步？

`SemaphoreSlim` 提供了一个 `WaitAsync` 方法，允许异步获取信号量。这在需要在不阻塞执行线程的情况下，异步限制对共享资源的并发访问时非常有用。通过使用 `SemaphoreSlim`，你可以确保有限数量的任务可以同时访问特定的资源或代码段，从而提供了一种节流或控制访问的机制。

## 在 C# 8.0 中使用“`IAsyncDisposable`”时，“异步释放”是什么意思？

`IAsyncDisposable` 接口引入了 `DisposeAsync()` 方法，可以用来执行异步清理操作。这对于需要异步交互来释放的资源特别有益，例如网络流或数据库连接。通过允许异步释放，资源可以更有效地被释放，并有助于防止潜在的死锁或阻塞场景，尤其是在高度依赖异步操作的环境中。

当我们通过使用 `async` 和 `await` 完成对异步编程动态世界的探索之旅，解锁了并行操作潜力并提高了代码效率时，我们现在站在另一个重要主题的门槛上：委托、事件和 lambda 表达式。

接下来的部分承诺将进一步提高你在 C# 中的熟练度，提供关于强大的编程结构的信息，这些结构使得事件驱动编程和函数式编程风格成为可能。准备好深入探索委托的复杂性，体验事件带来的响应性以及 lambda 表达式带来的简洁代码，随着我们继续扩展 C# 编程视野。

# 代理、事件和 lambda 表达式

撕开 C# 的层，可以看到一系列旨在促进高级编码模式和技术的机制。其中最重要的是 **代理**、**事件**和 **lambda 表达式**。本节深入探讨这些结构，揭示了它们相互交织的关系以及在 .NET 生态系统中的基本作用。代理使开发者能够将方法封装为第一类实体，为事件提供基础，并促进动态方法调用。事件反过来提供了一个强大的通信系统，允许对象无缝交互，而无需严格的依赖。同时，lambda 表达式注入了优雅和简洁，允许即时进行简洁的函数定义。这三个支柱共同构成了 C# 中许多现代编程模式的基础。开始这次探索，了解如何利用它们的组合潜力，轻松构建灵活、可维护和具有表现力的代码。

## C# 中的“事件访问器”是什么，它们如何自定义订阅或取消订阅逻辑？

在 C# 中，`add` 和 `remove` 方法分别定义了订阅或取消订阅事件的自定义操作。它们赋予开发者在工作与事件一起时添加额外逻辑或验证的能力。例如，你可能想要限制事件的订阅者数量或记录每个订阅。自定义这些访问器提供了对事件行为和交互的更多控制。

## .NET 在编译级别如何实现 lambda 表达式？它们是否成为类的实际方法？

在编译过程中，lambda 表达式根据其使用上下文被转换为匿名方法或类方法。如果 lambda 只捕获局部变量，它可能表示为静态方法。然而，如果它捕获其周围作用域中的变量（闭包），编译器将生成一个特殊的类来保存这些捕获的变量，并且 lambda 成为该生成类的成员方法。这种转换确保了 lambda 功能的保留，同时与 .NET 类型系统无缝集成。

## lambda 表达式和表达式树之间的主要区别是什么，与表达式树一起工作提供了哪些机会？

虽然 lambda 表达式是可直接执行的函数式结构，但表达式树将代码表示为结构化数据格式。换句话说，虽然 lambda 执行逻辑，但表达式树描述逻辑。表达式树允许在运行时进行代码的反射、修改或动态生成。这种能力在诸如 **对象关系映射**（ORM）系统等场景中特别有益，在这些场景中，可能需要将 LINQ 查询转换为 SQL 查询，或者用于构建自定义编译器或解释器。

## 为什么“多播代理”（multicast delegates）在现代应用程序中可能会出现问题，有哪些替代方案？

**多播代理**允许多个处理程序响应单个事件。这可能会在管理和调试中引入复杂性，并且如果处理不当，可能会导致意外的副作用。确保执行顺序或处理个别委托目标抛出的异常变得具有挑战性。一种替代方案是使用事件或**观察者模式**（Observer pattern），它提供了更结构化和受控的方式来通知多个订阅者。

## 如何在运行时根据 lambda 表达式动态创建函数？

通过使用表达式树（`Expression<TDelegate>`），可以在运行时动态构造、修改和编译 lambda 表达式。表达式树将代码表示为数据，可以在使用`Compile`方法编译成可执行代码之前进行转换或检查。

## 在 lambda 表达式和匿名方法的情况下，“闭包”（closure）指的是什么，它如何影响捕获的变量？

在 lambda 表达式和匿名方法的情况下，“闭包”（closure）指的是这些构造能够*捕获*并保留对其封装作用域中变量的访问能力。捕获的变量以某种方式存储，即使在声明它们的函数执行完毕后，它们仍然可访问和可修改。如果不正确理解，这可能会导致意外的行为，尤其是在多线程环境中，闭包可能会在线程之间引入共享状态。

## 如果事件订阅者在事件调用期间抛出异常，可能会产生什么后果？这将对该事件的其它订阅者产生什么影响，以及可以采用哪些方法来优雅地处理此类场景？

如果事件订阅者在执行过程中抛出异常，调用列表中的后续订阅者将不会执行。这意味着其他订阅者可能会错过事件通知。为了减轻这种情况，可以单独调用事件调用列表中的每个委托，并在`try`-`catch`块中包装。这确保了一个订阅者中的异常不会阻止其他订阅者的调用。适当地处理异常还可以确保主逻辑不会意外中断。

## 代理（delegates）和事件（events）之间的区别是什么，它们是如何交互的？

委托（delegates）本质上是一种类型安全的函数指针，可以指向一个或多个方法，而事件（events）是一种机制，允许一个类在发生感兴趣的事情时通知其他类或对象。事件在幕后使用委托来维护订阅者列表并指定可以处理事件的方法的签名。本质上，事件封装了委托，增加了一层额外的保护，并确保只有拥有类的对象可以引发事件。

## lambda 表达式在 C#中如何使用，它们与委托相比有什么优势？

C#中的 lambda 表达式是使用清晰简洁的语法表示匿名方法的简洁表示。它们通常与 LINQ 查询和其他需要短小内联方法的场景一起使用。与传统的委托语法相比，lambda 表达式的主要优势是简洁和清晰。lambda 表达式提供了一种更易于阅读和紧凑的方式来定义内联方法，而无需显式创建委托实例。

## 在 C#中，“Func<T>”，“Action<T>”和“Predicate<T）”之间的区别是什么，以及何时应该使用每个？

在 C#中，`Func<T>`用于返回值的委托，`Action<T>`用于不返回值的委托，`Predicate<T>`用于返回布尔值的委托。具体来说，请执行以下操作：

+   当你需要计算或检索结果时使用**Func**

+   当你想执行一个操作或动作而不期望返回值时使用**Action**

+   当你想评估一个条件并得到**true**或**false**的结果时使用**Predicate**，通常用于过滤或检查条件

## 在处理事件时可能会出现哪些挑战，以及如何减轻这些挑战？

在 C#中处理事件会带来一些挑战，例如以下这些：

+   **内存泄漏**：如果订阅者没有取消订阅事件，可能会导致内存泄漏，特别是如果发布者的生命周期比订阅者长

+   **多线程问题**：从多个线程访问事件可以引入竞争条件，即两个或多个线程同时尝试修改共享数据的情况，导致不可预测和错误的结果

+   **异常处理**：如果某个订阅者的处理程序抛出异常，可能会阻止其他处理程序执行

为了减轻这些挑战，请遵循以下指南：

+   当不再需要时，始终取消订阅事件

+   使用线程安全的方法来调用事件

+   将单个事件调用包裹在**try**-**catch**块中，以确保一个处理程序的异常不会阻止其他处理程序

当我们结束关于委托、事件和 lambda 表达式的部分，我们沉浸在对事件驱动编程和 lambda 表达式简洁语法的探索中，我们即将进入 C#编程的另一个基石——使用泛型类、方法和接口来创建可重用代码。

接下来的部分将是你掌握制作灵活且可重用代码结构的 C#艺术的门户，这将促进代码重用和类型安全。准备好深入泛型的世界，我们将学习如何创建灵活且类型安全的代码，这是成为熟练的 C#复杂编程的步骤之一。

# 如何使用泛型类、方法和接口来创建可重用代码

高效且健壮的编程的核心在于编写能够经受时间考验、适应各种场景并最小化冗余的代码。在 C#中引入的**泛型**代表了向这一理想迈进的一大步。本节介绍了泛型的强大世界，使开发者能够以类型安全、可扩展和可重用的方式定义**类**、**方法**和**接口**。泛型允许你不必局限于特定的数据类型，从而实现更抽象和灵活的编码风格，确保你能够满足广泛的业务需求，而无需承担大量代码重复的负担。通过深入研究泛型类、方法和接口，你将获得创建满足当前需求且能够适应未来需求的代码结构的见解。拥抱泛型，开启一个灵活性和类型安全和谐共存的全新世界，为真正可适应的解决方案铺平道路。

## C#中泛型的用途是什么，它们与使用“object”基类型相比提供了哪些优势？

C#中的泛型提供了一种定义类、接口和方法的方式，这些类、接口和方法在操作类型参数的同时保持类型安全和性能。与使用`object`类型相比，泛型提供了以下优势：

+   **类型安全**：泛型确保你正在使用正确的数据类型，消除了运行时类型错误的风险

+   **性能**：使用泛型时，在处理值类型时无需装箱或拆箱，从而实现更高效的运算

+   **代码复用性**：泛型允许你编写可以与不同数据类型一起工作的代码片段，从而减少代码重复

+   **消除类型转换**：使用泛型时，显式类型转换减少，使代码更简洁、更易读

## 你如何定义一个泛型类，它与标准类有何不同？你如何对泛型类型参数设置约束？

泛型类使用类型参数定义，通常用尖括号（`<T>`）表示。虽然标准类与特定数据类型一起工作，但泛型类可以与任何数据类型一起工作，这取决于实例化时提供的类型参数。例如，`List<int>`和`List<string>`是泛型`List<T>`类的实例，但分别使用`int`和`string`类型。

可以使用`where`关键字设置泛型类型参数的约束。这允许你根据继承层次结构、接口或构造函数限制用作泛型参数的类型。例如，`class MyGenericClass<T> where T : MyClass, new(),`确保`T`是或继承自`MyClass`，并且有一个无参数的构造函数。

## 泛型能否与其他 C#关键特性集成，如委托或属性？

是的——泛型可以与 C#中的各种功能结合使用，例如以下内容：

+   **委托**：你可以定义通用委托，它可以指向各种类型的函数

+   **事件**：事件可以基于通用委托

+   **属性**：虽然你不能创建通用属性类，但你可以将属性应用于通用构造

## 在 C# 中，协变和逆协变是如何应用于通用接口和委托的？

在 C# 中，**协变**和**逆协变**为使用接口和委托的泛型类型提供了灵活性，以下是如何进行分配和使用的方式：

+   **协变**（**out** 关键字）：允许你使用比最初指定的更派生的类型。例如，你可以将 **IEnumerable<Derived>** 的对象赋值给 **IEnumerable<Base>** 类型的变量。

+   **逆协变**（**in** 关键字）：允许使用比派生类型更少的类型。这在委托中很常见。

例如，一个接口可以定义为 `IInterface<out T>` 以实现协变或 `IInterface<in T>` 以实现逆协变。

## 与标准类相比，通用类中的静态字段和方法有哪些特点？

在通用类中，静态字段和方法是唯一的。对于通用类的每个类型特化，都有一个单独的静态字段集。这意味着 `MyClass<int>` 和 `MyClass<string>` 将各自拥有它们自己的静态字段实例。这种行为与非通用类不同，非通用类只有一个静态字段集，该字段集被类中的所有实例共享。

## “通用类型扩展方法”是什么意思，它是如何应用的？

在方法签名中的通用类型参数之前有一个 `this` 关键字，如下例所示：

```cs
public static class ExtensionMethods
{
    public static void MyMethod<T>(this T obj)
    {
        // Implementation here
    }
}
```

通过使用这样的扩展方法，开发者可以以干净和模块化的方式增强现有类型的功能，并从泛型提供的灵活性和类型安全中受益。

## 我们能否从通用类型类中继承？这个过程的细微差别是什么？

是的——你可以从通用类型类中继承。在继承时，你可以做以下操作：

+   你可以为基通用类指定具体类型；例如，**class Derived : Base<int> { }**

+   或者，你可以在派生类中保持通用性：**class Derived<T> : Base<T> { }**

重要的是要注意对基通用类施加的类型约束，因为这些也将应用于派生类。

## 通用类型使用了什么编译机制？是否为每个特殊类型生成单独的机器代码？

在 .NET 中，通用类型被编译成一个单独的模板（例如 `int`、`double`），为每个类型生成单独的代码以确保优化性能。然而，对于引用类型，相同的代码被共享，这使得过程更加内存高效。

在我们探索泛型类、方法和接口的探索中，我们利用了可适应和类型安全的代码结构的力量之后，我们正准备深入探讨多线程的复杂领域，创建和管理线程、同步原语，并处理线程同步和通信。

在接下来的章节中，准备好揭开 C# 中多线程的复杂性，这是开发健壮和高效应用程序的关键技能。期待获得创建和协调线程的实践经验，掌握同步原语，并应对线程同步和通信的复杂性。让我们继续前进，准备好应对 C# 多线程编程带来的挑战和机遇！

# 多线程 – 创建和管理线程、同步原语，以及处理线程同步和通信

在当今多核处理器和无缝用户体验需求的世界中，多线程的艺术已经成为开发者工具箱中不可或缺的一部分。本节将深入探讨多线程的复杂领域，提供创建、管理和协调 C# 中线程的全面指南。除了简单的线程创建之外，你还将深入了解同步原语的细微差别，确保你的多线程应用程序运行无故障或数据不一致。

但线程不仅仅是关于执行；它还关乎通信。我们将探讨线程如何有效地进行通信，确保数据传输和任务协调的顺畅。当你浏览这一节时，你会发现通过并发操作最大化性能与保持应用程序的完整性和可靠性之间的平衡。欢迎来到多线程的世界，在这里速度和协调相结合，为你的应用程序提供强大的动力。

## 如何在 C# 中创建一个线程，以及其主要启动方法是什么？

在 C# 中，可以使用 `System.Threading` 命名空间中的 `Thread` 类来创建线程。一旦实例化了一个线程，你可以使用 `Start()` 方法来启动它。以下是一个示例：

```cs
Thread myThread = new Thread(new ThreadStart(MyFunction));
myThread.Start();
```

在这里，`MyFunction` 是你希望在单独的线程上运行的方法。值得注意的是，虽然以这种方式创建线程提供了细粒度控制，但对于许多场景，TPL 提供了一种更高级和更高效的并行执行方法。

## C# 中有哪些同步原语可用于管理资源访问？

C# 提供了各种同步原语来控制对共享资源的访问并确保在多线程环境中的数据安全。这些包括以下内容：

+   **监视器（Monitor）**：通常与 **lock** 关键字隐式使用来获取对象的锁

+   **互斥锁（Mutex）**：类似于**监视器（Monitor）**，但可以在多个进程间使用，确保进程间同步

+   **信号量**：通过限制同时访问的数量来控制多个线程对资源的访问

+   **读写锁（ReaderWriterLock）**和**读写锁精简版（ReaderWriterLockSlim）**：允许多个线程读取共享数据，但只允许一个线程写入，优化了频繁读取和偶尔写入的场景

+   **lock**语句：**Monitor.Enter**和**Monitor.Exit**的简写，提供了一个基于块的获取和释放锁的作用域

## 当涉及到线程同步时，监视器（Monitor）、互斥锁（Mutex）和信号量（Semaphore）之间有什么区别？

让我们看看这些机制之间的区别：

+   **监视器**：允许线程获取对象的锁，通常通过 C#中的**lock**语句使用。它是最快的同步机制，但仅在单个进程中操作。它最适合低争用短生命周期的锁。

+   **互斥锁（Mutex）**：类似于**监视器（Monitor）**的功能，但可以在多个进程中使用。这意味着如果你有多个需要同步访问共享资源的应用程序，可以使用**互斥锁**机制。它比**监视器**机制更重，由于跨进程功能，它有性能开销。

+   **信号量（Semaphore）**：是一种控制多个线程访问共享资源的信号机制。与**监视器（Monitor）**和**互斥锁（Mutex）**不同，它们是二进制锁（锁定/解锁），**信号量**机制有一个计数，限制可以同时访问资源或资源组的线程数量。当你有一组资源并且想要限制同时访问的数量时很有用——例如，在限制并发数据库连接的场景中。

## 什么是多线程中的“死锁”，以及如何避免它？

多线程中的**死锁**发生在两个或更多线程处于一种状态，每个线程都在等待另一个线程释放资源，从而形成一个停滞状态，没有任何线程可以继续执行。这实际上阻止了涉及线程的执行。为了避免死锁，可以考虑以下策略：

+   **锁顺序**：始终以一致、预定的顺序获取锁。如果所有线程在获取锁时遵循相同的顺序，就可以避免循环等待（死锁的关键条件）。

+   **锁超时**：在尝试获取锁时使用超时。如果线程在特定时间内无法获取所有必要的锁，它可以释放它所获取的任何锁并重试。

+   **死锁检测**：有机制来检测死锁。这可能很复杂，可能不适合所有场景，但在死锁可能产生重大影响的系统中，检测和恢复机制是必不可少的。

## “ThreadPool”如何比手动创建线程更有效地管理线程？

`ThreadPool`管理一组工作线程，提供了一种在后台高效执行短期任务的有效机制。其优点包括以下：

+   **降低开销**：**ThreadPool** 通过重用线程最小化了与线程创建和销毁相关的开销。

+   **优化资源利用**：**ThreadPool** 根据工作负载动态调整池中的线程数量，确保系统资源的最佳利用。

+   **易用性**：**ThreadPool** 通过抽象线程管理细节简化了并行执行，使开发者能够专注于任务执行逻辑。

## 在 C# 中，“Task”代表什么，它与常规线程有何不同？

C# 中的 `Task` 代表异步操作。它提供了比线程更高层次的抽象，并提供了几个好处：

+   **异步编程**：使用 **async** 和 **await** 关键字，**Task** 使编写异步代码变得更加简单。

+   **资源管理**：一个 **Task** 实例可能在一个 **ThreadPool** 的线程上运行，优化线程利用和管理。

+   **可组合性**：任务可以轻松组合，允许创建异步操作的链。

+   **异常处理**：**Task** 提供了一种集中处理异步代码中异常的方法。

与常规线程的主要区别在于，`Task` 实例抽象了底层的线程细节，并为表示异步计算提供了更丰富的 API，而线程代表程序中的单个执行路径。

## 你如何确保线程之间安全的数据交换？

确保线程之间安全的数据交换对于数据一致性和系统稳定性至关重要。以下是实现方法：

+   **同步原语**：使用同步机制，如 **lock**、**Mutex**、**Semaphore** 和 **ReaderWriterLock**，以确保一次只有一个线程访问共享资源。

+   **并发集合**：利用线程安全的集合，例如 **ConcurrentDictionary**、**BlockingCollection** 或 **ConcurrentQueue**，这些集合设计用于处理并发访问，无需额外的同步。

+   **不可变数据结构**：使用创建后不可修改的不可变对象。由于它们无法改变状态，它们可以在多个线程之间安全地共享。

+   **volatile 关键字**：在需要确保特定字段始终从主内存位置（而不是缓存）读取的场景中，可以使用 **volatile** 关键字。

## “async”和“await”如何帮助创建异步代码而不直接管理线程？

`async`和`await`提供了一种编写结构上看似同步的异步代码的方法。当你使用`await`时，方法的执行被暂停，释放执行线程返回线程池，直到等待的异步操作完成。这种方法允许高效地利用资源，而不必直接管理线程的复杂性。本质上，它们抽象了异步编程的复杂性，使开发者能够专注于逻辑而不是并发机制。

## C#中的“线程局部存储”是什么，它是如何使用的？

`ThreadStatic`属性或`ThreadLocal<T>`类。TLS 在需要存储线程特定上下文信息或状态而不受其他线程干扰的场景中特别有用。

## 在使用 C#进行多线程工作时，推荐的主要方法和最佳实践有哪些？

一些推荐的方案和最佳实践包括以下内容：

+   **使用同步原语**：在访问共享资源时，始终使用同步机制，如**lock**、**Mutex**、**Semaphore**和**ReaderWriterLock**，以防止竞态条件。

+   **最小化锁竞争**：避免长时间持有锁，尤其是在执行 I/O 操作或其他阻塞任务时。

+   **利用内置库**：使用**ThreadPool**或**Task**进行异步操作，而不是手动创建和管理线程。

+   **警惕竞态条件和死锁**：了解导致这些问题的常见陷阱和场景，并积极采取措施防止它们。

+   **拥抱异步性**：对于可能阻塞线程的操作，如 I/O 或网络请求，使用**async/await**范式。

+   **测试**：定期在各种条件下测试多线程代码，包括压力和负载测试，以揭示潜在的并发问题。

## 在多线程 C#代码中，“内存屏障”或“栅栏”的作用是什么？

**内存屏障**或**栅栏**是确保在多线程环境中内存操作特定顺序的机制。它们防止编译器或处理器重新排序某些操作。这确保了特定操作在屏障之前或之后按预期执行，保持跨线程数据的一致性和完整性。它们在操作顺序对正确程序行为至关重要的场景中起着关键作用。

## 何时应用“自旋锁”最有效？

`SpinLock`是一种锁原语，在等待锁释放时，它积极地**自旋**或忙等待，而不是使线程休眠。它在预期锁持有时间非常短且挂起和恢复线程（上下文切换）的开销比短暂的忙等待更昂贵的情况下最有效。它在高性能场景中特别有用，其中线程预计几乎可以立即获取锁。

## 在多线程 C# 代码中，“volatile” 关键字的用途是什么，它与编译器优化如何交互？

C# 中的 `volatile` 关键字表示该字段可以被多个线程同时访问。这防止了编译器对该字段进行某些优化，以确保读取和写入的正确可见性和顺序。本质上，它保证了任何对 `volatile` 变量的读取或写入操作都将直接与主内存交互，而不是使用缓存数据。这确保了所有线程都将观察到变量的最新值，提供类似内存屏障的行为，以防止由于编译器或硬件优化而产生意外结果。

## “BlockingCollection”、“ConcurrentBag”、“ConcurrentQueue” 和 “ConcurrentStack” 集合之间的主要区别是什么？

让我们来看看不同的集合：

+   **BlockingCollection**: 这是对其他集合的包装，提供了阻塞和边界能力。它在需要控制生产者和消费者线程之间数据流速率的场景中非常有用。

+   **ConcurrentBag**: 这是一个线程安全的无序集合，针对每个线程频繁添加和删除项的场景进行了优化。

+   **ConcurrentQueue**: 这是一个线程安全的先进先出（FIFO）集合。

+   **ConcurrentStack**: 这是一个线程安全的后进先出（LIFO）集合。

## “ThreadLocal<T>” 的用途是什么，它有哪些优点和缺点？

`ThreadLocal<T>` 提供了一种创建线程局部数据的方式，确保每个线程都有自己的唯一值。

其优点包括以下：

+   **数据隔离**：确保数据在线程之间隔离，减少了对同步的需求

+   **性能**：访问线程局部数据通常比带有锁的共享数据更快

其缺点包括以下：

+   **增加的内存使用**：每个线程都有自己的实例可能会导致更高的内存消耗

+   **潜在的内存泄漏**：如果线程没有正确终止，或者如果 **ThreadLocal** 实例没有正确处置，可能会导致内存泄漏

## 在多线程编程的上下文中，“饥饿”是什么意思？

**多线程中的饥饿**指的是一个或多个线程始终无法访问资源或执行，因为其他线程持续垄断资源或 CPU。这可能导致系统吞吐量降低、无响应，甚至完全的应用程序停滞。饥饿通常出现在线程优先级处理不当的系统或某些线程被降级到很少或从未执行的程度。

## “CancellationToken” 如何帮助管理线程和任务的执行？

`CancellationToken` 提供了一种请求取消线程、任务或异步操作的方式。它允许以下操作：

+   **协作取消**：任务和线程可以定期检查令牌，以查看是否已请求取消，从而允许它们优雅地退出

+   **安全终止**确保长时间运行的操作可以以受控的方式终止，而不会导致数据损坏或其他问题

+   **反应性**：通过对外部事件或状态变化（如用户请求或超时）的响应取消任务，使应用程序能够更加响应

## 原子操作，如“Interlocked”类中的方法，如何促进多线程代码中的同步？

`Interlocked`类中的方法为变量提供原子操作，确保操作在没有被其他线程中断的情况下完成。这提供了以下好处：

+   **安全性**：互斥方法允许在多线程环境中安全地更新变量，而无需使用锁

+   **性能**：原子操作通常比使用锁更快，尤其是在竞争低时

+   **一致性**：互斥方法保证即使在多个线程并发访问时，数据也保持一致

互斥类通常用于如增加计数器、交换值或以线程安全的方式更新共享数据等操作。

## 在多线程编程中，所说的非阻塞调用是什么意思，为什么它们被认为比阻塞调用更有优势？

**非阻塞调用**不会在等待资源或响应时停止线程的执行。这意味着线程可以继续执行其他任务或操作。它们的优点包括以下内容：

+   **资源效率**：非阻塞调用使系统能够优化资源利用，因为线程可以在等待时执行其他任务

+   **响应性**：应用程序保持响应，尤其是在 I/O 密集型操作或网络调用中，因为它们不会陷入等待状态

+   **可伸缩性**：非阻塞操作通常导致更可伸缩的系统，尤其是在处理高并发时，因为线程不会被闲置

相比之下，**阻塞调用**会暂停线程的执行，直到它获得所需的资源或响应，这可能导致资源使用效率低下和应用程序响应速度降低。

## 为什么传统的“lock”机制不适用于异步操作？

传统的`lock`机制在等待锁释放时会阻塞执行线程。在异步操作的情况下，使用这种阻塞机制可能导致死锁，特别是如果锁定资源稍后被同一逻辑流程但在不同线程上访问。此外，在异步代码中使用`lock`会增加线程调度器的负担，因为线程可能会异步阻塞。不是有效地释放线程以处理其他任务，它保持阻塞，减少了异步性的好处。

## 如何在异步方法中确保同步？可以使用哪些原语来实现此目的？

异步方法中的同步可以使用为异步操作设计的某些同步原语来实现。以下是一些包括的内容：

+   **SemaphoreSlim**：支持同步和异步锁定，在可能混合同步和异步代码的场合很有用

+   **AsyncLock**：虽然不是 .NET Framework 本身的一部分，但像 **AsyncLock**（通常使用 **SemaphoreSlim** 实现）这样的模式可以为异步代码提供类似锁的机制

+   **Mutex** 和 **ReaderWriterLockSlim**：虽然这些同步原语传统上与线程同步相关联，但也可以在特定的异步场景中谨慎使用，以确保程序执行的安全和正确

使用这些原语可以在不阻塞线程的情况下实现异步代码的互斥，确保资源安全有效地访问。

## “Task.Yield()”如何与任务调度器交互，它的用途是什么？

`Task.Yield()` 是一个异步方法，它立即将控制权交回给任务调度器。这允许调度器在恢复当前任务之前处理其他等待的任务。其主要用途包括以下：

+   **公平性**：确保长时间运行或紧密循环的任务不会独占线程，给其他任务执行的机会

+   **响应性**：可以通过允许渲染或其他 UI 任务运行来保持 UI 的响应性

+   **高级场景**：在需要精细控制任务执行顺序的特定场景中很有用

此方法在代码中引入了一个异步点的预定位置，暂时放弃当前任务的执行，允许其他挂起的任务继续进行，从而促进操作更响应和交织的执行。

## C# 的内存模型如何影响多线程，以及该模型的关键特性有哪些是重要的？

C# 的内存模型定义了跨多个线程的内存操作的顺序和可见性保证。以下是需要理解的关键特性：

+   **顺序保证**：在单个线程中，C# 保证执行的一致顺序，称为顺序一致性。然而，从多个线程观察时，操作可能看起来顺序混乱，除非使用适当的同步。

+   **内存屏障**：这些是防止重排序并确保跨线程内存可见性的隐式或显式操作。例如，**volatile** 关键字和如 **Thread.MemoryBarrier()** 这样的操作引入了屏障。

+   **易失性读取/写入**：**volatile** 关键字确保对字段的读取和写入是直接发生的，并且不会被缓存，确保跨线程的实时可见性。

+   **原子性**: 在 C#中，某些操作是原子的（例如读取/写入引用或大多数内置数值类型），但复合操作（例如增量操作）如果不是特别同步，则不是原子的。

随着我们结束对这一章节的深入探索，在这一章节中我们掌握了 C#并发编程的复杂领域，我们即将进入至关重要的*垃圾回收*领域。在接下来的章节中，我们将揭开 C#内存管理机制的秘密，重点关注垃圾回收的自动化过程，该过程有助于回收不再使用的对象占用的内存。准备好深入探索这个关键系统组件的细微差别，获得能够帮助你开发具有优化内存使用和提升性能的应用程序的见解。让我们继续深化对 C#编程复杂世界的理解！

# 垃圾回收

作为开发者，我们为对象、数据结构和各种其他组件分配内存，但当这些内存不再使用时会发生什么？进入垃圾回收器（**GC**）的领域——它是.NET 生态系统内存管理的无声守护者。本节将向您介绍垃圾回收过程的复杂性，阐明 C#和.NET 如何确保内存资源的有效利用和回收。深入了解，您将了解 GC 的内部工作原理、其代际以及它如何识别和清理无引用对象。虽然 GC 主要在幕后操作，但了解其行为和机制对于优化应用程序性能至关重要，尤其是对于资源密集型应用程序。随着我们揭开 GC 的秘密，我们将为您提供工具和知识，以保持您的应用程序平稳高效地运行。

## 在 C#的内存管理和垃圾回收的背景下，栈和堆之间的主要区别是什么？

栈用于存储局部变量、方法执行细节和控制程序流程。它以 LIFO（后进先出）的方式操作，当方法或代码块退出时，内存会自动回收。另一方面，堆用于存储动态分配的内存，例如对象。在 C#中，堆上的内存由垃圾回收器（GC）管理。堆上的对象存在，直到 GC 确定它们不再可达，并回收内存。

## .NET 如何识别一个对象没有活动引用，并准备好进行垃圾回收？

.NET 使用标记-清除算法进行垃圾回收。最初，堆上的所有对象都被认为是*不可达的*。从根对象开始（例如，全局和静态对象、堆栈上的局部变量和 CPU 寄存器），GC 跟踪并标记每个可访问的对象。在标记阶段之后，任何未标记的对象都被认为是**垃圾**，是收集的候选对象。这些不可达的对象随后被清除或收集，释放它们占用的内存。

## 垃圾回收中的代为什么重要，它们是如何工作的？

`0`、`1`和`2`。让我们更详细地看看这些：

+   **第 0 代（Gen 0）**：包含短生命周期的对象，例如临时变量。收集这一代对象速度快且发生频率高。

+   **第 1 代（Gen 1）**：在短生命周期对象和长生命周期对象之间充当缓冲区。

+   **第 2 代（Gen 2）**：包含长生命周期对象。

这种方法背后的理念是大多数对象都是短生命周期的。通过频繁收集 Gen 0，GC 可以有效地从短生命周期对象中回收内存，而无需扫描更旧的代。在收集中存活的对象会被提升到下一代，GC 会减少对旧代进行检查的频率。

## 内存管理中“Finalize”和“Dispose”方法之间的区别是什么？

两者`Finalize`和`Dispose`方法都是释放未管理资源的机制，但它们服务于不同的目的，并在不同的上下文中使用：

+   **Finalize**：在 GC 回收对象占用的内存之前，会调用**Finalize**方法。它定义在对象的析构函数中，旨在释放对象可能持有的未管理资源。然而，依赖于最终化有其缺陷，因为您无法预测 GC 何时运行，这使得它是非确定性的。

+   **Dispose**：**Dispose**方法是**IDisposable**接口的一部分。当实现时，它提供了一种确定性的方式来释放托管和非托管资源。通常，您会显式调用**Dispose**方法或在 C#中使用对象在**using**语句中，确保当对象超出作用域时调用**Dispose**。使用**Dispose**允许及时清理资源，确保文件句柄、数据库连接等资源在不再需要时立即释放。

## 您如何向 GC 发出进行垃圾回收的需求信号？

您可以使用`GC.Collect()`方法显式请求 GC 执行收集。然而，需要注意的是，手动调用垃圾回收通常是不被鼓励的。GC 已优化，根据应用程序的内存消耗模式在最佳时间运行。强制收集可能会破坏这些优化并可能降低性能。

## 在.NET 中，“内存泄漏”是什么意思，垃圾回收如何帮助检测它？

.NET 中的**内存泄漏**指的是对象在不再需要或可访问的情况下仍然保留在内存中的情况。虽然 GC 旨在自动回收不可达对象占用的内存，但它无法释放仍然有活动引用的对象。因此，即使对象不再使用，但仍然有引用指向它（例如，由于事件处理器或静态集合），它也不会被收集，从而导致内存泄漏。

## 弱引用如何帮助防止对象被 GC 锁定？

弱引用允许你在不阻止 GC 收集该对象的情况下持有对该对象的引用。这在你想保持对对象的缓存或临时引用，但又不想让这个引用成为对象保留在内存中的唯一原因时非常有用。当对象仅有的现有引用是弱引用时，该对象就符合垃圾收集的条件。通过使用.NET 中的`WeakReference`类，你可以访问目标对象，如果它仍在内存中，但你不会阻止 GC 在必要时收集它。

## “GC.KeepAlive()”方法的目的是什么，何时应该使用它？

`GC.KeepAlive()`方法确保指定的对象在方法调用期间保持*活跃*，不会被 GC 收集。这可以用于防止过早的垃圾收集，特别是对于具有显著终结逻辑的对象。例如，如果一个对象持有资源，如文件句柄或网络连接，并且其终结器释放了该资源，使用`GC.KeepAlive()`可以防止终结器提前运行。

## GC 的操作模式（例如，工作站和服务器）如何影响其活动？

.NET 中的垃圾回收器（GC）在不同的模式下运行，以优化不同的场景：

+   **工作站模式**：通常用于单线程应用程序或运行在单核机器上的应用程序。它不利用并行性进行垃圾收集，旨在减少干扰，优先考虑应用程序的响应性。

+   **服务器模式**：针对多核系统优化，并使用并行垃圾收集以最大化吞吐量。它适用于性能和可扩展性至关重要的服务器应用程序。

这些模式调整 GC 的行为，以更好地匹配预期的应用程序工作负载和硬件。

## 大型对象堆与常规堆之间的区别是什么，它如何影响垃圾收集？

**大型对象堆（LOH**）是.NET 内存管理中的一个特殊堆，用于存储 85,000 字节或更大的对象。LOH 与常规堆的主要区别如下：

+   LOH 不像常规堆那样频繁地进行压缩。压缩大对象可能会对性能产生较大影响。

+   LOH 中的对象在 Gen 2 垃圾收集期间被收集。

由于这些特性，频繁分配大对象时必须谨慎，因为这可能导致内存碎片化和 Gen 2 收集增加。

## 锁定对象对 GC 操作有什么影响，什么是锁定对象堆？

**锁定**对象是 GC 被指示在内存压缩阶段不移动的对象。当对象的内存地址需要保持恒定时，这是必要的，通常是在与原生代码接口时。锁定对象可能会干扰内存的有效压缩并导致碎片化。在.NET 5 中引入的**锁定对象堆**（**POH**）是一个专门用于存储锁定对象的段，确保它们不会干扰常规堆，并提供更有效的锁定对象管理。

## 对象中存在终结器如何影响垃圾收集过程？

带有终结器的对象会复杂化垃圾收集过程，因为它们需要两个垃圾收集周期才能完成清理。在第一个周期中，当对象被检测为不可达时，其终结器会被调用。然后，对象被移动到已终结对象列表中。只有在随后的垃圾收集周期中，对象才会真正被回收。这意味着带有终结器的对象在内存中停留的时间更长，如果不正确管理，可能会导致内存使用增加。

## GC 如何处理频繁创建和销毁的对象（例如，在循环中）？

GC 采用代收集。频繁创建且可能短暂存活的对象被放置在年轻代（Gen 0）。其理念是，从这一代（Gen 0）频繁收集更有效率，因为许多对象会很快变得不可达。当进行这一代的垃圾收集时，只考虑堆的一个子集（年轻代），这使得过程更快。存活多次收集的对象会被提升到较老的代，这些代收集的频率较低。

## 非托管资源的使用如何影响 GC，以及如何确保它们得到适当的处理？

**非托管**资源，如文件句柄、数据库连接或原生内存，不由.NET GC 管理。如果不妥善处理，它们可能导致资源泄漏。为确保它们得到适当的处理，请遵循以下指南：

+   **实现 IDisposable 接口**：这允许你提供一个**Dispose**方法，在其中你可以释放非托管资源。

+   **使用 using 语句**：这确保了当对象超出作用域时，**Dispose**方法会自动被调用。

+   **使用终结器**：在开发者可能忘记调用**Dispose**的情况下，可以使用终结器（**~ClassName**方法）来释放资源。然而，仅依赖终结器可能会引入资源清理的延迟，因此建议将其作为**Dispose**方法的备份使用。

# 摘要

在本章中，我们开始了一段详细的旅程，深入 C# 编程的复杂领域，通过深入研究集合和 LINQ 来培养熟练的数据结构管理能力。紧接着，我们通过异常处理和调试来研究健壮的错误管理，为探索使用 `async` 和 `await` 的动态异步编程奠定了基础。

故事进一步展开，揭示了事件驱动编程的精髓，通过委托、事件和 lambda 表达式，为构建可重用和类型安全的代码的泛型世界铺平了道路。随着我们向章节的后半部分前进，读者可以沉浸在多线程的复杂性中，了解并发编程和通过垃圾回收进行高效内存管理的见解。

本章作为第五章《指导可维护和高效 C# 编程的基本原理》的序言，读者将在其中进一步深化他们的专业知识，通过探索本章中阐述的高级概念，获得更深入的理解和精炼的技能集。

# 附加阅读

+   *《使用 C# 10 和 .NET 6 进行并行编程和并发》*，作者 Alvin Ashcraft

    [`www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672`](https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672)

+   *《程序员必知的 50 个算法 - 第二版》*，作者 Imran Ahmad

    [`www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762`](https://www.packtpub.com/product/50-algorithms-every-programmer-should-know-second-edition/9781803247762)

高级 C# 概念

多线程 – 创建和管理线程，同步原语，处理线程同步和通信

多线程 – 创建和管理线程，同步原语，处理线程同步和通信

多线程 – 创建和管理线程，同步原语，处理线程同步和通信

多线程 – 创建和管理线程，同步原语，处理线程同步和通信
